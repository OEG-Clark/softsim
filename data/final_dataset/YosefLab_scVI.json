{"home.repos.pwc.inspect_result.YosefLab_scVI.None.conftest.pytest_addoption": [[7, 20], ["parser.addoption", "parser.addoption"], "function", ["None"], ["def", "pytest_addoption", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "addoption", "(", "\n", "\"--model_fit\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "default", "=", "False", ",", "\n", "dest", "=", "\"model_fit\"", ",", "\n", "help", "=", "\"Option to run full training model for test_model_fit\"", ",", "\n", ")", "\n", "parser", ".", "addoption", "(", "\n", "\"--internet-tests\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "default", "=", "False", ",", "\n", "help", "=", "\"Run tests that retrieve stuff from the internet. This increases test time.\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.None.conftest.pytest_collection_modifyitems": [[23, 31], ["config.getoption", "pytest.mark.skip", "item.add_marker"], "function", ["None"], ["", "def", "pytest_collection_modifyitems", "(", "config", ",", "items", ")", ":", "\n", "    ", "run_internet", "=", "config", ".", "getoption", "(", "\"--internet-tests\"", ")", "\n", "skip_internet", "=", "pytest", ".", "mark", ".", "skip", "(", "reason", "=", "\"need --internet-tests option to run\"", ")", "\n", "for", "item", "in", "items", ":", "\n", "# All tests marked with `pytest.mark.internet` get skipped unless", "\n", "# `--internet-tests` passed", "\n", "        ", "if", "not", "run_internet", "and", "(", "\"internet\"", "in", "item", ".", "keywords", ")", ":", "\n", "            ", "item", ".", "add_marker", "(", "skip_internet", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.None.conftest.save_path": [[33, 40], ["pytest.fixture", "tmpdir_factory.mktemp", "str", "distutils.dir_util.copy_tree", "shutil.rmtree", "str", "tmpdir_factory.getbasetemp"], "function", ["None"], ["", "", "", "@", "pytest", ".", "fixture", "(", "scope", "=", "\"session\"", ")", "\n", "def", "save_path", "(", "tmpdir_factory", ")", ":", "\n", "    ", "dir", "=", "tmpdir_factory", ".", "mktemp", "(", "\"temp_data\"", ",", "numbered", "=", "False", ")", "\n", "path", "=", "str", "(", "dir", ")", "\n", "copy_tree", "(", "\"tests/data\"", ",", "path", ")", "\n", "yield", "path", "+", "\"/\"", "\n", "shutil", ".", "rmtree", "(", "str", "(", "tmpdir_factory", ".", "getbasetemp", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.None.conftest.model_fit": [[42, 45], ["pytest.fixture", "request.config.getoption"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", "scope", "=", "\"session\"", ")", "\n", "def", "model_fit", "(", "request", ")", ":", "\n", "    ", "return", "request", ".", "config", ".", "getoption", "(", "\"--model_fit\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.extensions.typed_returns.process_return": [[9, 17], ["re.fullmatch"], "function", ["None"], ["def", "process_return", "(", "lines", ")", ":", "\n", "    ", "for", "line", "in", "lines", ":", "\n", "        ", "m", "=", "re", ".", "fullmatch", "(", "r\"(?P<param>\\w+)\\s+:\\s+(?P<type>[\\w.]+)\"", ",", "line", ")", "\n", "if", "m", ":", "\n", "# Once this is in scanpydoc, we can use the fancy hover stuff", "\n", "            ", "yield", "f'-{m[\"param\"]} (:class:`~{m[\"type\"]}`)'", "\n", "", "else", ":", "\n", "            ", "yield", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.extensions.typed_returns.scanpy_parse_returns_section": [[19, 25], ["list", "typed_returns.._format_block", "typed_returns.process_return", "typed_returns..append", "typed_returns.._dedent", "typed_returns.._consume_to_next_section"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.extensions.typed_returns.process_return"], ["", "", "", "def", "scanpy_parse_returns_section", "(", "self", ",", "section", ")", ":", "\n", "    ", "lines_raw", "=", "list", "(", "process_return", "(", "self", ".", "_dedent", "(", "self", ".", "_consume_to_next_section", "(", ")", ")", ")", ")", "\n", "lines", "=", "self", ".", "_format_block", "(", "\":returns: \"", ",", "lines_raw", ")", "\n", "if", "lines", "and", "lines", "[", "-", "1", "]", ":", "\n", "        ", "lines", ".", "append", "(", "\"\"", ")", "\n", "", "return", "lines", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.extensions.typed_returns.setup": [[27, 29], ["None"], "function", ["None"], ["", "def", "setup", "(", "app", ":", "Sphinx", ")", ":", "\n", "    ", "NumpyDocstring", ".", "_parse_returns_section", "=", "scanpy_parse_returns_section", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params": [[4, 15], ["textwrap.dedent().format_map", "textwrap.dedent"], "function", ["None"], ["def", "_doc_params", "(", "**", "kwds", ")", ":", "\n", "    ", "\"\"\"\\\n    Docstrings should start with \"\\\" in the first line for proper formatting.\n    \"\"\"", "\n", "\n", "def", "dec", "(", "obj", ")", ":", "\n", "        ", "obj", ".", "__orig_doc__", "=", "obj", ".", "__doc__", "\n", "obj", ".", "__doc__", "=", "dedent", "(", "obj", ".", "__doc__", ")", ".", "format_map", "(", "kwds", ")", "\n", "return", "obj", "\n", "\n", "", "return", "dec", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.__init__": [[52, 75], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "verbosity", ":", "int", "=", "logging", ".", "INFO", ",", "\n", "progress_bar_style", ":", "Literal", "[", "\"rich\"", ",", "\"tqdm\"", "]", "=", "\"tqdm\"", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "seed", ":", "int", "=", "0", ",", "\n", "logging_dir", ":", "str", "=", "\"./scvi_log/\"", ",", "\n", "dl_num_workers", ":", "int", "=", "0", ",", "\n", "dl_pin_memory_gpu_training", ":", "bool", "=", "False", ",", "\n", "jax_preallocate_gpu_memory", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "seed", "=", "seed", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "if", "progress_bar_style", "not", "in", "[", "\"rich\"", ",", "\"tqdm\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Progress bar style must be in ['rich', 'tqdm']\"", ")", "\n", "", "self", ".", "progress_bar_style", "=", "progress_bar_style", "\n", "self", ".", "logging_dir", "=", "logging_dir", "\n", "self", ".", "dl_num_workers", "=", "dl_num_workers", "\n", "self", ".", "dl_pin_memory_gpu_training", "=", "dl_pin_memory_gpu_training", "\n", "self", ".", "_num_threads", "=", "None", "\n", "self", ".", "jax_preallocate_gpu_memory", "=", "jax_preallocate_gpu_memory", "\n", "self", ".", "verbosity", "=", "verbosity", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.batch_size": [[86, 95], ["None"], "methods", ["None"], ["", "@", "batch_size", ".", "setter", "\n", "def", "batch_size", "(", "self", ",", "batch_size", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Minibatch size for loading data into the model.\n\n        This is only used after a model is trained. Trainers have specific\n        `batch_size` parameters.\n        \"\"\"", "\n", "self", ".", "_batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.dl_num_workers": [[101, 105], ["None"], "methods", ["None"], ["", "@", "dl_num_workers", ".", "setter", "\n", "def", "dl_num_workers", "(", "self", ",", "dl_num_workers", ":", "int", ")", ":", "\n", "        ", "\"\"\"Number of workers for PyTorch data loaders (Default is 0).\"\"\"", "\n", "self", ".", "_dl_num_workers", "=", "dl_num_workers", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.dl_pin_memory_gpu_training": [[111, 115], ["None"], "methods", ["None"], ["", "@", "dl_pin_memory_gpu_training", ".", "setter", "\n", "def", "dl_pin_memory_gpu_training", "(", "self", ",", "dl_pin_memory_gpu_training", ":", "int", ")", ":", "\n", "        ", "\"\"\"Set `pin_memory` in data loaders when using a GPU for training.\"\"\"", "\n", "self", ".", "_dl_pin_memory_gpu_training", "=", "dl_pin_memory_gpu_training", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.logging_dir": [[121, 124], ["pathlib.Path().resolve", "pathlib.Path"], "methods", ["None"], ["", "@", "logging_dir", ".", "setter", "\n", "def", "logging_dir", "(", "self", ",", "logging_dir", ":", "Union", "[", "str", ",", "Path", "]", ")", ":", "\n", "        ", "self", ".", "_logging_dir", "=", "Path", "(", "logging_dir", ")", ".", "resolve", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.num_threads": [[130, 135], ["torch.set_num_threads"], "methods", ["None"], ["", "@", "num_threads", ".", "setter", "\n", "def", "num_threads", "(", "self", ",", "num", ":", "int", ")", ":", "\n", "        ", "\"\"\"Number of threads PyTorch will use.\"\"\"", "\n", "self", ".", "_num_threads", "=", "num", "\n", "torch", ".", "set_num_threads", "(", "num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.progress_bar_style": [[141, 145], ["None"], "methods", ["None"], ["", "@", "progress_bar_style", ".", "setter", "\n", "def", "progress_bar_style", "(", "self", ",", "pbar_style", ":", "Literal", "[", "\"tqdm\"", ",", "\"rich\"", "]", ")", ":", "\n", "        ", "\"\"\"Library to use for progress bar.\"\"\"", "\n", "self", ".", "_pbar_style", "=", "pbar_style", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.seed": [[151, 158], ["pytorch_lightning.utilities.seed.seed_everything"], "methods", ["None"], ["", "@", "seed", ".", "setter", "\n", "def", "seed", "(", "self", ",", "seed", ":", "int", ")", ":", "\n", "        ", "\"\"\"Random seed for torch and numpy.\"\"\"", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "pl", ".", "utilities", ".", "seed", ".", "seed_everything", "(", "seed", ")", "\n", "self", ".", "_seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.verbosity": [[164, 193], ["scvi_logger.setLevel", "len", "rich.console.Console", "rich.logging.RichHandler", "logging.Formatter", "rich.logging.RichHandler.setFormatter", "scvi_logger.addHandler", "scvi_logger.setLevel"], "methods", ["None"], ["", "@", "verbosity", ".", "setter", "\n", "def", "verbosity", "(", "self", ",", "level", ":", "Union", "[", "str", ",", "int", "]", ")", ":", "\n", "        ", "\"\"\"\n        Sets logging configuration for scvi based on chosen level of verbosity.\n\n        If \"scvi\" logger has no StreamHandler, add one.\n        Else, set its level to `level`.\n\n        Parameters\n        ----------\n        level\n            Sets \"scvi\" logging level to `level`\n        force_terminal\n            Rich logging option, set to False if piping to file output.\n        \"\"\"", "\n", "self", ".", "_verbosity", "=", "level", "\n", "scvi_logger", ".", "setLevel", "(", "level", ")", "\n", "if", "len", "(", "scvi_logger", ".", "handlers", ")", "==", "0", ":", "\n", "            ", "console", "=", "Console", "(", "force_terminal", "=", "True", ")", "\n", "if", "console", ".", "is_jupyter", "is", "True", ":", "\n", "                ", "console", ".", "is_jupyter", "=", "False", "\n", "", "ch", "=", "RichHandler", "(", "\n", "level", "=", "level", ",", "show_path", "=", "False", ",", "console", "=", "console", ",", "show_time", "=", "False", "\n", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\"%(message)s\"", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "scvi_logger", ".", "addHandler", "(", "ch", ")", "\n", "", "else", ":", "\n", "            ", "scvi_logger", ".", "setLevel", "(", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.reset_logging_handler": [[194, 205], ["scvi_logger.removeHandler", "rich.logging.RichHandler", "logging.Formatter", "rich.logging.RichHandler.setFormatter", "scvi_logger.addHandler"], "methods", ["None"], ["", "", "def", "reset_logging_handler", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Resets \"scvi\" log handler to a basic RichHandler().\n\n        This is useful if piping outputs to a file.\n        \"\"\"", "\n", "scvi_logger", ".", "removeHandler", "(", "scvi_logger", ".", "handlers", "[", "0", "]", ")", "\n", "ch", "=", "RichHandler", "(", "level", "=", "self", ".", "_verbosity", ",", "show_path", "=", "False", ",", "show_time", "=", "False", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\"%(message)s\"", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "scvi_logger", ".", "addHandler", "(", "ch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.scvi._settings.ScviConfig.jax_preallocate_gpu_memory": [[217, 230], ["isinstance", "ValueError", "ValueError", "str"], "methods", ["None"], ["", "@", "jax_preallocate_gpu_memory", ".", "setter", "\n", "def", "jax_preallocate_gpu_memory", "(", "self", ",", "value", ":", "Union", "[", "float", ",", "bool", "]", ")", ":", "\n", "# see https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html#gpu-memory-allocation", "\n", "        ", "if", "value", "is", "False", ":", "\n", "            ", "os", ".", "environ", "[", "\"XLA_PYTHON_CLIENT_PREALLOCATE\"", "]", "=", "\"false\"", "\n", "", "elif", "isinstance", "(", "value", ",", "float", ")", ":", "\n", "            ", "if", "value", ">=", "1", "or", "value", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"Need to use a value between 0 and 1\"", ")", "\n", "# format is \".XX\"", "\n", "", "os", ".", "environ", "[", "\"XLA_PYTHON_CLIENT_MEM_FRACTION\"", "]", "=", "str", "(", "value", ")", "[", "1", ":", "4", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"value not understood, need bool or float in (0, 1)\"", ")", "\n", "", "self", ".", "_jax_gpu", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._docstrings.SetupAnnDataDocstringProcessor.__init__": [[110, 122], ["docrep.DocstringProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "summary", "=", "self", ".", "summary", ",", "\n", "param_adata", "=", "self", ".", "param_adata", ",", "\n", "param_batch_key", "=", "self", ".", "param_batch_key", ",", "\n", "param_labels_key", "=", "self", ".", "param_labels_key", ",", "\n", "param_layer", "=", "self", ".", "param_layer", ",", "\n", "param_cat_cov_keys", "=", "self", ".", "param_cat_cov_keys", ",", "\n", "param_cont_cov_keys", "=", "self", ".", "param_cont_cov_keys", ",", "\n", "param_size_factor_key", "=", "self", ".", "param_size_factor_key", ",", "\n", "param_copy", "=", "self", ".", "param_copy", ",", "\n", "returns", "=", "self", ".", "returns", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._jax.device_selecting_PRNGKey": [[7, 18], ["jax.jit", "jax.random.PRNGKey", "jax.random.PRNGKey"], "function", ["None"], ["def", "device_selecting_PRNGKey", "(", "use_cpu", ":", "bool", "=", "True", ")", "->", "Callable", ":", "\n", "# if key is generated on CPU, model params will be on CPU", "\n", "# we have to pay the price of a JIT compilation though", "\n", "    ", "if", "use_cpu", "is", "True", ":", "\n", "        ", "key", "=", "jax", ".", "jit", "(", "lambda", "i", ":", "random", ".", "PRNGKey", "(", "i", ")", ",", "backend", "=", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "# dummy function", "\n", "        ", "def", "key", "(", "i", ":", "int", ")", ":", "\n", "            ", "return", "random", ".", "PRNGKey", "(", "i", ")", "\n", "\n", "", "", "return", "key", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._attrdict.attrdict.__init__": [[18, 38], ["dict.__init__", "_attrdict.attrdict.keys", "hasattr", "isinstance", "_attrdict.attrdict", "ValueError", "_attrdict.attrdict.__init__.from_nested_dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "recursive", ":", "bool", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "def", "from_nested_dict", "(", "data", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "data", ",", "dict", ")", ":", "\n", "                ", "return", "data", "\n", "", "else", ":", "\n", "                ", "return", "attrdict", "(", "{", "key", ":", "from_nested_dict", "(", "data", "[", "key", "]", ")", "for", "key", "in", "data", "}", ")", "\n", "\n", "", "", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "for", "key", "in", "self", ".", "keys", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "self", ",", "key", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Cannot create attrdict containing key {key} due to conflict with built-in dict attribute.\"", "\n", ")", "\n", "", "if", "recursive", ":", "\n", "                ", "self", "[", "key", "]", "=", "from_nested_dict", "(", "self", "[", "key", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", "[", "key", "]", "=", "deepcopy", "(", "self", "[", "key", "]", ")", "\n", "\n", "", "", "self", ".", "__dict__", "=", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._attrdict.attrdict.__repr__": [[39, 41], ["dict.__repr__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.__repr__"], ["", "def", "__repr__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"attrdict({super().__repr__()})\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track": [[12, 60], ["ValueError", "hasattr", "tqdm.tqdm", "rich.console.Console", "rich.progress.track", "list", "tqdm.tqdm._decr_instances"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track"], ["def", "track", "(", "\n", "sequence", ":", "Iterable", ",", "\n", "description", ":", "str", "=", "\"Working...\"", ",", "\n", "disable", ":", "bool", "=", "False", ",", "\n", "style", ":", "Literal", "[", "\"rich\"", ",", "\"tqdm\"", "]", "=", "None", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Progress bar with `'rich'` and `'tqdm'` styles.\n\n    Parameters\n    ----------\n    sequence\n        Iterable sequence.\n    description\n        First text shown to left of progress bar.\n    disable\n        Switch to turn off progress bar.\n    style\n        One of [\"rich\", \"tqdm\"]. \"rich\" is interactive\n        and is not persistent after close.\n    **kwargs\n        Keyword args to tqdm or rich.\n\n    Examples\n    --------\n    >>> from scvi.utils import track\n    >>> my_list = [1, 2, 3]\n    >>> for i in track(my_list): print(i)\n    \"\"\"", "\n", "if", "style", "is", "None", ":", "\n", "        ", "style", "=", "settings", ".", "progress_bar_style", "\n", "", "if", "style", "not", "in", "[", "\"rich\"", ",", "\"tqdm\"", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"style must be one of ['rich', 'tqdm']\"", ")", "\n", "", "if", "disable", ":", "\n", "        ", "return", "sequence", "\n", "", "if", "style", "==", "\"tqdm\"", ":", "\n", "# fixes repeated pbar in jupyter", "\n", "# see https://github.com/tqdm/tqdm/issues/375", "\n", "        ", "if", "hasattr", "(", "tqdm_base", ",", "\"_instances\"", ")", ":", "\n", "            ", "for", "instance", "in", "list", "(", "tqdm_base", ".", "_instances", ")", ":", "\n", "                ", "tqdm_base", ".", "_decr_instances", "(", "instance", ")", "\n", "", "", "return", "tqdm_base", "(", "sequence", ",", "desc", "=", "description", ",", "file", "=", "sys", ".", "stdout", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "in_colab", "=", "\"google.colab\"", "in", "sys", ".", "modules", "\n", "force_jupyter", "=", "None", "if", "not", "in_colab", "else", "True", "\n", "console", "=", "Console", "(", "force_jupyter", "=", "force_jupyter", ")", "\n", "return", "track_base", "(", "sequence", ",", "description", "=", "description", ",", "console", "=", "console", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils._mde.mde": [[11, 79], ["isinstance", "dict", "dict.update", "pymde.preserve_neighbors().embed", "isinstance", "emb.cpu().numpy.cpu().numpy", "ImportError", "torch.cuda.is_available", "pymde.Standardized", "pymde.preserve_neighbors", "emb.cpu().numpy.cpu"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "mde", "(", "\n", "data", ":", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", ",", "spmatrix", ",", "torch", ".", "Tensor", "]", ",", "\n", "device", ":", "Optional", "[", "Literal", "[", "\"cpu\"", ",", "\"cuda\"", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Util to run :func:`pymde.preserve_neighbors` for visualization of scvi-tools embeddings.\n\n    Parameters\n    ----------\n    data\n        The data of shape (n_obs, k), where k is typically defined by one of the models\n        in scvi-tools that produces an embedding (e.g., :class:`~scvi.model.SCVI`.)\n    device\n        Whether to run on cpu or gpu (\"cuda\"). If None, tries to run on gpu if available.\n    kwargs\n        Keyword args to :func:`pymde.preserve_neighbors`\n    Returns\n    -------\n    The pymde embedding, defaults to two dimensions.\n\n    Notes\n    -----\n    This function is included in scvi-tools to provide an alternative to UMAP/TSNE that is GPU-\n    accelerated. The appropriateness of use of visualization of high-dimensional spaces in single-\n    cell omics remains an open research questions. See:\n\n    Chari, Tara, Joeyta Banerjee, and Lior Pachter. \"The specious art of single-cell genomics.\" bioRxiv (2021).\n\n    If you use this function in your research please cite:\n\n    Agrawal, Akshay, Alnur Ali, and Stephen Boyd. \"Minimum-distortion embedding.\" arXiv preprint arXiv:2103.02559 (2021).\n\n    Examples\n    --------\n    >>> adata = anndata.read_h5ad(path_to_anndata)\n    >>> scvi.model.SCVI.setup_anndata(adata, batch_key=\"batch\")\n    >>> vae = scvi.model.SCVI(adata)\n    >>> vae.train()\n    >>> adata.obsm[\"X_scVI\"] = vae.get_latent_representation()\n    >>> adata.obsm[\"X_mde\"] = scvi.model.utils.mde(adata.obsm[\"X_scVI\"])\n    \"\"\"", "\n", "try", ":", "\n", "        ", "import", "pymde", "\n", "", "except", "ImportError", ":", "\n", "        ", "raise", "ImportError", "(", "\"Please install pymde package via `pip install pymde`\"", ")", "\n", "\n", "", "if", "isinstance", "(", "data", ",", "pd", ".", "DataFrame", ")", ":", "\n", "        ", "data", "=", "data", ".", "values", "\n", "\n", "", "device", "=", "\"cpu\"", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cuda\"", "\n", "\n", "_kwargs", "=", "dict", "(", "\n", "embedding_dim", "=", "2", ",", "\n", "constraint", "=", "pymde", ".", "Standardized", "(", ")", ",", "\n", "repulsive_fraction", "=", "0.7", ",", "\n", "verbose", "=", "False", ",", "\n", "device", "=", "device", ",", "\n", "n_neighbors", "=", "15", ",", "\n", ")", "\n", "_kwargs", ".", "update", "(", "kwargs", ")", "\n", "\n", "emb", "=", "pymde", ".", "preserve_neighbors", "(", "data", ",", "**", "_kwargs", ")", ".", "embed", "(", "verbose", "=", "_kwargs", "[", "\"verbose\"", "]", ")", "\n", "\n", "if", "isinstance", "(", "emb", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "emb", "=", "emb", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "return", "emb", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils.test_attrdict.test_attrdict_new": [[6, 18], ["scvi.utils.attrdict", "isinstance", "pytest.raises", "print"], "function", ["None"], ["def", "test_attrdict_new", "(", ")", ":", "\n", "    ", "ad", "=", "attrdict", "(", ")", "\n", "ad", ".", "a", "=", "1", "\n", "assert", "ad", ".", "a", "==", "1", "and", "ad", "[", "\"a\"", "]", "==", "1", "\n", "\n", "ad", "[", "\"b\"", "]", "=", "\"test\"", "\n", "assert", "ad", ".", "b", "==", "\"test\"", "and", "ad", "[", "\"b\"", "]", "==", "\"test\"", "\n", "\n", "ad", ".", "c", "=", "{", "\"d\"", ":", "2", "}", "\n", "assert", "isinstance", "(", "ad", ".", "c", ",", "dict", ")", "and", "ad", ".", "c", "[", "\"d\"", "]", "==", "2", "\n", "with", "pytest", ".", "raises", "(", "AttributeError", ")", ":", "\n", "        ", "print", "(", "ad", ".", "c", ".", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils.test_attrdict.test_attrdict_from_dict": [[20, 32], ["scvi.utils.attrdict", "isinstance", "dict", "isinstance"], "function", ["None"], ["", "", "def", "test_attrdict_from_dict", "(", ")", ":", "\n", "    ", "dct", "=", "{", "\"a\"", ":", "1", ",", "\"b\"", ":", "2", ",", "\"c\"", ":", "{", "\"d\"", ":", "3", "}", "}", "\n", "ad", "=", "attrdict", "(", "dct", ")", "\n", "assert", "isinstance", "(", "ad", ",", "attrdict", ")", "and", "not", "isinstance", "(", "ad", ".", "c", ",", "attrdict", ")", "\n", "assert", "ad", ".", "a", "==", "1", "and", "ad", ".", "b", "==", "2", "and", "ad", ".", "c", "[", "\"d\"", "]", "==", "3", "\n", "assert", "dict", "(", "ad", ")", "==", "dct", "\n", "\n", "# attrdict creates a copy of dct.", "\n", "ad", ".", "a", "=", "2", "\n", "assert", "ad", ".", "a", "==", "2", "and", "dct", "[", "\"a\"", "]", "==", "1", "\n", "ad", ".", "c", "[", "\"d\"", "]", "=", "4", "\n", "assert", "ad", ".", "c", "[", "\"d\"", "]", "==", "4", "and", "dct", "[", "\"c\"", "]", "[", "\"d\"", "]", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.utils.test_attrdict.test_attrdict_recursive": [[34, 46], ["scvi.utils.attrdict", "isinstance", "isinstance", "dict"], "function", ["None"], ["", "def", "test_attrdict_recursive", "(", ")", ":", "\n", "    ", "dct", "=", "{", "\"a\"", ":", "1", ",", "\"b\"", ":", "2", ",", "\"c\"", ":", "{", "\"d\"", ":", "3", "}", "}", "\n", "ad", "=", "attrdict", "(", "dct", ",", "recursive", "=", "True", ")", "\n", "assert", "isinstance", "(", "ad", ",", "attrdict", ")", "and", "isinstance", "(", "ad", ".", "c", ",", "attrdict", ")", "\n", "assert", "ad", ".", "a", "==", "1", "and", "ad", ".", "b", "==", "2", "and", "ad", ".", "c", ".", "d", "==", "3", "\n", "assert", "dict", "(", "ad", ")", "==", "dct", "\n", "\n", "# attrdict creates a copy of dct.", "\n", "ad", ".", "a", "=", "2", "\n", "assert", "ad", ".", "a", "==", "2", "and", "dct", "[", "\"a\"", "]", "==", "1", "\n", "ad", ".", "c", ".", "d", "=", "4", "\n", "assert", "ad", ".", "c", ".", "d", "==", "4", "and", "dct", "[", "\"c\"", "]", "[", "\"d\"", "]", "==", "3", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot": [[4, 9], ["torch.zeros", "torch.zeros.scatter_", "torch.zeros.type", "index.size", "index.type"], "function", ["None"], ["def", "_doc_params", "(", "**", "kwds", ")", ":", "\n", "    ", "\"\"\"\\\n    Docstrings should start with \"\\\" in the first line for proper formatting.\n    \"\"\"", "\n", "\n", "def", "dec", "(", "obj", ")", ":", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.__init__": [[56, 106], ["torch.nn.Module.__init__", "sum", "torch.nn.Sequential", "collections.OrderedDict", "torch.nn.Sequential", "enumerate", "torch.nn.Linear", "zip", "torch.nn.BatchNorm1d", "torch.nn.LayerNorm", "activation_fn", "torch.nn.Dropout", "_base_components.FCLayers.inject_into_layer"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.inject_into_layer"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_in", ":", "int", ",", "\n", "n_out", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "use_batch_norm", ":", "bool", "=", "True", ",", "\n", "use_layer_norm", ":", "bool", "=", "False", ",", "\n", "use_activation", ":", "bool", "=", "True", ",", "\n", "bias", ":", "bool", "=", "True", ",", "\n", "inject_covariates", ":", "bool", "=", "True", ",", "\n", "activation_fn", ":", "nn", ".", "Module", "=", "nn", ".", "ReLU", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inject_covariates", "=", "inject_covariates", "\n", "layers_dim", "=", "[", "n_in", "]", "+", "(", "n_layers", "-", "1", ")", "*", "[", "n_hidden", "]", "+", "[", "n_out", "]", "\n", "\n", "if", "n_cat_list", "is", "not", "None", ":", "\n", "# n_cat = 1 will be ignored", "\n", "            ", "self", ".", "n_cat_list", "=", "[", "n_cat", "if", "n_cat", ">", "1", "else", "0", "for", "n_cat", "in", "n_cat_list", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "n_cat_list", "=", "[", "]", "\n", "\n", "", "cat_dim", "=", "sum", "(", "self", ".", "n_cat_list", ")", "\n", "self", ".", "fc_layers", "=", "nn", ".", "Sequential", "(", "\n", "collections", ".", "OrderedDict", "(", "\n", "[", "\n", "(", "\n", "\"Layer {}\"", ".", "format", "(", "i", ")", ",", "\n", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "\n", "n_in", "+", "cat_dim", "*", "self", ".", "inject_into_layer", "(", "i", ")", ",", "\n", "n_out", ",", "\n", "bias", "=", "bias", ",", "\n", ")", ",", "\n", "# non-default params come from defaults in original Tensorflow implementation", "\n", "nn", ".", "BatchNorm1d", "(", "n_out", ",", "momentum", "=", "0.01", ",", "eps", "=", "0.001", ")", "\n", "if", "use_batch_norm", "\n", "else", "None", ",", "\n", "nn", ".", "LayerNorm", "(", "n_out", ",", "elementwise_affine", "=", "False", ")", "\n", "if", "use_layer_norm", "\n", "else", "None", ",", "\n", "activation_fn", "(", ")", "if", "use_activation", "else", "None", ",", "\n", "nn", ".", "Dropout", "(", "p", "=", "dropout_rate", ")", "if", "dropout_rate", ">", "0", "else", "None", ",", "\n", ")", ",", "\n", ")", "\n", "for", "i", ",", "(", "n_in", ",", "n_out", ")", "in", "enumerate", "(", "\n", "zip", "(", "layers_dim", "[", ":", "-", "1", "]", ",", "layers_dim", "[", "1", ":", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.inject_into_layer": [[111, 115], ["None"], "methods", ["None"], ["", "def", "inject_into_layer", "(", "self", ",", "layer_num", ")", "->", "bool", ":", "\n", "        ", "\"\"\"Helper to determine if covariates should be injected.\"\"\"", "\n", "user_cond", "=", "layer_num", "==", "0", "or", "(", "layer_num", ">", "0", "and", "self", ".", "inject_covariates", ")", "\n", "return", "user_cond", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.set_online_update_hooks": [[116, 141], ["enumerate", "sum", "torch.zeros_like", "isinstance", "_base_components.FCLayers.inject_into_layer", "_base_components.FCLayers.hooks.append", "layer.bias.register_hook", "_base_components.FCLayers.hooks.append", "layer.weight.register_hook", "layer.weight.register_hook"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.inject_into_layer"], ["", "def", "set_online_update_hooks", "(", "self", ",", "hook_first_layer", "=", "True", ")", ":", "\n", "        ", "self", ".", "hooks", "=", "[", "]", "\n", "\n", "def", "_hook_fn_weight", "(", "grad", ")", ":", "\n", "            ", "categorical_dims", "=", "sum", "(", "self", ".", "n_cat_list", ")", "\n", "new_grad", "=", "torch", ".", "zeros_like", "(", "grad", ")", "\n", "if", "categorical_dims", ">", "0", ":", "\n", "                ", "new_grad", "[", ":", ",", "-", "categorical_dims", ":", "]", "=", "grad", "[", ":", ",", "-", "categorical_dims", ":", "]", "\n", "", "return", "new_grad", "\n", "\n", "", "def", "_hook_fn_zero_out", "(", "grad", ")", ":", "\n", "            ", "return", "grad", "*", "0", "\n", "\n", "", "for", "i", ",", "layers", "in", "enumerate", "(", "self", ".", "fc_layers", ")", ":", "\n", "            ", "for", "layer", "in", "layers", ":", "\n", "                ", "if", "i", "==", "0", "and", "not", "hook_first_layer", ":", "\n", "                    ", "continue", "\n", "", "if", "isinstance", "(", "layer", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "if", "self", ".", "inject_into_layer", "(", "i", ")", ":", "\n", "                        ", "w", "=", "layer", ".", "weight", ".", "register_hook", "(", "_hook_fn_weight", ")", "\n", "", "else", ":", "\n", "                        ", "w", "=", "layer", ".", "weight", ".", "register_hook", "(", "_hook_fn_zero_out", ")", "\n", "", "self", ".", "hooks", ".", "append", "(", "w", ")", "\n", "b", "=", "layer", ".", "bias", ".", "register_hook", "(", "_hook_fn_zero_out", ")", "\n", "self", ".", "hooks", ".", "append", "(", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.forward": [[142, 199], ["zip", "enumerate", "len", "len", "ValueError", "ValueError", "cat.size", "_utils.one_hot", "isinstance", "layer", "torch.cat.dim", "torch.cat", "layer", "isinstance", "_base_components.FCLayers.inject_into_layer", "torch.cat", "torch.cat.dim", "layer().unsqueeze", "o.unsqueeze().expand", "layer", "o.unsqueeze", "torch.cat.size", "o.size", "o.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.FCLayers.inject_into_layer"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Forward computation on ``x``.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(n_in,)``\n        cat_list\n            list of category membership(s) for this sample\n        x: torch.Tensor\n\n        Returns\n        -------\n        py:class:`torch.Tensor`\n            tensor of shape ``(n_out,)``\n\n        \"\"\"", "\n", "one_hot_cat_list", "=", "[", "]", "# for generality in this list many indices useless.", "\n", "\n", "if", "len", "(", "self", ".", "n_cat_list", ")", ">", "len", "(", "cat_list", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"nb. categorical args provided doesn't match init. params.\"", "\n", ")", "\n", "", "for", "n_cat", ",", "cat", "in", "zip", "(", "self", ".", "n_cat_list", ",", "cat_list", ")", ":", "\n", "            ", "if", "n_cat", "and", "cat", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"cat not provided while n_cat != 0 in init. params.\"", ")", "\n", "", "if", "n_cat", ">", "1", ":", "# n_cat = 1 will be ignored - no additional information", "\n", "                ", "if", "cat", ".", "size", "(", "1", ")", "!=", "n_cat", ":", "\n", "                    ", "one_hot_cat", "=", "one_hot", "(", "cat", ",", "n_cat", ")", "\n", "", "else", ":", "\n", "                    ", "one_hot_cat", "=", "cat", "# cat has already been one_hot encoded", "\n", "", "one_hot_cat_list", "+=", "[", "one_hot_cat", "]", "\n", "", "", "for", "i", ",", "layers", "in", "enumerate", "(", "self", ".", "fc_layers", ")", ":", "\n", "            ", "for", "layer", "in", "layers", ":", "\n", "                ", "if", "layer", "is", "not", "None", ":", "\n", "                    ", "if", "isinstance", "(", "layer", ",", "nn", ".", "BatchNorm1d", ")", ":", "\n", "                        ", "if", "x", ".", "dim", "(", ")", "==", "3", ":", "\n", "                            ", "x", "=", "torch", ".", "cat", "(", "\n", "[", "(", "layer", "(", "slice_x", ")", ")", ".", "unsqueeze", "(", "0", ")", "for", "slice_x", "in", "x", "]", ",", "dim", "=", "0", "\n", ")", "\n", "", "else", ":", "\n", "                            ", "x", "=", "layer", "(", "x", ")", "\n", "", "", "else", ":", "\n", "                        ", "if", "isinstance", "(", "layer", ",", "nn", ".", "Linear", ")", "and", "self", ".", "inject_into_layer", "(", "i", ")", ":", "\n", "                            ", "if", "x", ".", "dim", "(", ")", "==", "3", ":", "\n", "                                ", "one_hot_cat_list_layer", "=", "[", "\n", "o", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "x", ".", "size", "(", "0", ")", ",", "o", ".", "size", "(", "0", ")", ",", "o", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "for", "o", "in", "one_hot_cat_list", "\n", "]", "\n", "", "else", ":", "\n", "                                ", "one_hot_cat_list_layer", "=", "one_hot_cat_list", "\n", "", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "*", "one_hot_cat_list_layer", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "x", "=", "layer", "(", "x", ")", "\n", "", "", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.Encoder.__init__": [[238, 274], ["torch.nn.Module.__init__", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "distribution", ":", "str", "=", "\"normal\"", ",", "\n", "var_eps", ":", "float", "=", "1e-4", ",", "\n", "var_activation", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "return_dist", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "distribution", "=", "distribution", "\n", "self", ".", "var_eps", "=", "var_eps", "\n", "self", ".", "encoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "mean_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "var_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "return_dist", "=", "return_dist", "\n", "\n", "if", "distribution", "==", "\"ln\"", ":", "\n", "            ", "self", ".", "z_transformation", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "z_transformation", "=", "identity", "\n", "", "self", ".", "var_activation", "=", "torch", ".", "exp", "if", "var_activation", "is", "None", "else", "var_activation", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.Encoder.forward": [[275, 305], ["_base_components.Encoder.encoder", "_base_components.Encoder.mean_encoder", "torch.distributions.Normal", "_base_components.Encoder.z_transformation", "_base_components.Encoder.var_activation", "q_v.sqrt", "torch.distributions.Normal.rsample", "_base_components.Encoder.var_encoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "r\"\"\"\n        The forward computation for a single sample.\n\n         #. Encodes the data into latent space using the encoder network\n         #. Generates a mean \\\\( q_m \\\\) and variance \\\\( q_v \\\\)\n         #. Samples a new value from an i.i.d. multivariate normal \\\\( \\\\sim Ne(q_m, \\\\mathbf{I}q_v) \\\\)\n\n        Parameters\n        ----------\n        x\n            tensor with shape (n_input,)\n        cat_list\n            list of category membership(s) for this sample\n\n        Returns\n        -------\n        3-tuple of :py:class:`torch.Tensor`\n            tensors of shape ``(n_latent,)`` for mean and var, and sample\n\n        \"\"\"", "\n", "# Parameters for latent distribution", "\n", "q", "=", "self", ".", "encoder", "(", "x", ",", "*", "cat_list", ")", "\n", "q_m", "=", "self", ".", "mean_encoder", "(", "q", ")", "\n", "q_v", "=", "self", ".", "var_activation", "(", "self", ".", "var_encoder", "(", "q", ")", ")", "+", "self", ".", "var_eps", "\n", "dist", "=", "Normal", "(", "q_m", ",", "q_v", ".", "sqrt", "(", ")", ")", "\n", "latent", "=", "self", ".", "z_transformation", "(", "dist", ".", "rsample", "(", ")", ")", "\n", "if", "self", ".", "return_dist", ":", "\n", "            ", "return", "dist", ",", "latent", "\n", "", "return", "q_m", ",", "q_v", ",", "latent", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.DecoderSCVI.__init__": [[340, 380], ["torch.nn.Module.__init__", "_base_components.FCLayers", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Softmax", "torch.nn.Linear", "torch.nn.Softplus"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "inject_covariates", ":", "bool", "=", "True", ",", "\n", "use_batch_norm", ":", "bool", "=", "False", ",", "\n", "use_layer_norm", ":", "bool", "=", "False", ",", "\n", "scale_activation", ":", "Literal", "[", "\"softmax\"", ",", "\"softplus\"", "]", "=", "\"softmax\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "px_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "inject_covariates", "=", "inject_covariates", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "\n", "# mean gamma", "\n", "if", "scale_activation", "==", "\"softmax\"", ":", "\n", "            ", "px_scale_activation", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "", "elif", "scale_activation", "==", "\"softplus\"", ":", "\n", "            ", "px_scale_activation", "=", "nn", ".", "Softplus", "(", ")", "\n", "", "self", ".", "px_scale_decoder", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", ",", "\n", "px_scale_activation", ",", "\n", ")", "\n", "\n", "# dispersion: here we only deal with gene-cell dispersion case", "\n", "self", ".", "px_r_decoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "\n", "# dropout", "\n", "self", ".", "px_dropout_decoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.DecoderSCVI.forward": [[381, 425], ["_base_components.DecoderSCVI.px_decoder", "_base_components.DecoderSCVI.px_scale_decoder", "_base_components.DecoderSCVI.px_dropout_decoder", "torch.exp", "_base_components.DecoderSCVI.px_r_decoder"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "dispersion", ":", "str", ",", "\n", "z", ":", "torch", ".", "Tensor", ",", "\n", "library", ":", "torch", ".", "Tensor", ",", "\n", "*", "cat_list", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        The forward computation for a single sample.\n\n         #. Decodes the data from the latent space using the decoder network\n         #. Returns parameters for the ZINB distribution of expression\n         #. If ``dispersion != 'gene-cell'`` then value for that param will be ``None``\n\n        Parameters\n        ----------\n        dispersion\n            One of the following\n\n            * ``'gene'`` - dispersion parameter of NB is constant per gene across cells\n            * ``'gene-batch'`` - dispersion can differ between different batches\n            * ``'gene-label'`` - dispersion can differ between different labels\n            * ``'gene-cell'`` - dispersion can differ for every gene in every cell\n        z :\n            tensor with shape ``(n_input,)``\n        library_size\n            library size\n        cat_list\n            list of category membership(s) for this sample\n\n        Returns\n        -------\n        4-tuple of :py:class:`torch.Tensor`\n            parameters for the ZINB distribution of expression\n\n        \"\"\"", "\n", "# The decoder returns values for the parameters of the ZINB distribution", "\n", "px", "=", "self", ".", "px_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "px_scale", "=", "self", ".", "px_scale_decoder", "(", "px", ")", "\n", "px_dropout", "=", "self", ".", "px_dropout_decoder", "(", "px", ")", "\n", "# Clamp to high value: exp(12) ~ 160000 to avoid nans (computational stability)", "\n", "px_rate", "=", "torch", ".", "exp", "(", "library", ")", "*", "px_scale", "# torch.clamp( , max=12)", "\n", "px_r", "=", "self", ".", "px_r_decoder", "(", "px", ")", "if", "dispersion", "==", "\"gene-cell\"", "else", "None", "\n", "return", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.LinearDecoderSCVI.__init__": [[428, 463], ["torch.nn.Module.__init__", "_base_components.FCLayers", "_base_components.FCLayers"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "use_batch_norm", ":", "bool", "=", "False", ",", "\n", "use_layer_norm", ":", "bool", "=", "False", ",", "\n", "bias", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", "LinearDecoderSCVI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# mean gamma", "\n", "self", ".", "factor_regressor", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_output", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "1", ",", "\n", "use_activation", "=", "False", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "bias", "=", "bias", ",", "\n", "dropout_rate", "=", "0", ",", "\n", ")", "\n", "\n", "# dropout", "\n", "self", ".", "px_dropout_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_output", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "1", ",", "\n", "use_activation", "=", "False", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "bias", "=", "bias", ",", "\n", "dropout_rate", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.LinearDecoderSCVI.forward": [[465, 476], ["_base_components.LinearDecoderSCVI.factor_regressor", "torch.softmax", "_base_components.LinearDecoderSCVI.px_dropout_decoder", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "dispersion", ":", "str", ",", "z", ":", "torch", ".", "Tensor", ",", "library", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", "\n", ")", ":", "\n", "# The decoder returns values for the parameters of the ZINB distribution", "\n", "        ", "raw_px_scale", "=", "self", ".", "factor_regressor", "(", "z", ",", "*", "cat_list", ")", "\n", "px_scale", "=", "torch", ".", "softmax", "(", "raw_px_scale", ",", "dim", "=", "-", "1", ")", "\n", "px_dropout", "=", "self", ".", "px_dropout_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "px_rate", "=", "torch", ".", "exp", "(", "library", ")", "*", "px_scale", "\n", "px_r", "=", "None", "\n", "\n", "return", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.Decoder.__init__": [[507, 529], ["torch.nn.Module.__init__", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "mean_decoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "var_decoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.Decoder.forward": [[530, 555], ["_base_components.Decoder.decoder", "_base_components.Decoder.mean_decoder", "torch.exp", "_base_components.Decoder.var_decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        The forward computation for a single sample.\n\n         #. Decodes the data from the latent space using the decoder network\n         #. Returns tensors for the mean and variance of a multivariate distribution\n\n        Parameters\n        ----------\n        x\n            tensor with shape ``(n_input,)``\n        cat_list\n            list of category membership(s) for this sample\n\n        Returns\n        -------\n        2-tuple of :py:class:`torch.Tensor`\n            Mean and variance tensors of shape ``(n_output,)``\n\n        \"\"\"", "\n", "# Parameters for latent distribution", "\n", "p", "=", "self", ".", "decoder", "(", "x", ",", "*", "cat_list", ")", "\n", "p_m", "=", "self", ".", "mean_decoder", "(", "p", ")", "\n", "p_v", "=", "torch", ".", "exp", "(", "self", ".", "var_decoder", "(", "p", ")", ")", "\n", "return", "p_m", ",", "p_v", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.MultiEncoder.__init__": [[558, 599], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Linear", "_base_components.FCLayers", "range"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_heads", ":", "int", ",", "\n", "n_input_list", ":", "List", "[", "int", "]", ",", "\n", "n_output", ":", "int", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_layers_individual", ":", "int", "=", "1", ",", "\n", "n_layers_shared", ":", "int", "=", "2", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "return_dist", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "encoders", "=", "ModuleList", "(", "\n", "[", "\n", "FCLayers", "(", "\n", "n_in", "=", "n_input_list", "[", "i", "]", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers_individual", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "True", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "n_heads", ")", "\n", "]", "\n", ")", "\n", "\n", "self", ".", "encoder_shared", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers_shared", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", ")", "\n", "\n", "self", ".", "mean_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "var_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "return_dist", "=", "return_dist", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.MultiEncoder.forward": [[600, 611], ["_base_components.MultiEncoder.encoder_shared", "_base_components.MultiEncoder.mean_encoder", "torch.exp", "torch.distributions.Normal", "torch.distributions.Normal.rsample", "_base_components.MultiEncoder.var_encoder", "torch.exp.sqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "head_id", ":", "int", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "q", "=", "self", ".", "encoders", "[", "head_id", "]", "(", "x", ",", "*", "cat_list", ")", "\n", "q", "=", "self", ".", "encoder_shared", "(", "q", ",", "*", "cat_list", ")", "\n", "\n", "q_m", "=", "self", ".", "mean_encoder", "(", "q", ")", "\n", "q_v", "=", "torch", ".", "exp", "(", "self", ".", "var_encoder", "(", "q", ")", ")", "\n", "dist", "=", "Normal", "(", "q_m", ",", "q_v", ".", "sqrt", "(", ")", ")", "\n", "latent", "=", "dist", ".", "rsample", "(", ")", "\n", "if", "self", ".", "return_dist", ":", "\n", "            ", "return", "dist", ",", "latent", "\n", "", "return", "q_m", ",", "q_v", ",", "latent", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.MultiDecoder.__init__": [[614, 662], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "_base_components.FCLayers", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_hidden_conditioned", ":", "int", "=", "32", ",", "\n", "n_hidden_shared", ":", "int", "=", "128", ",", "\n", "n_layers_conditioned", ":", "int", "=", "1", ",", "\n", "n_layers_shared", ":", "int", "=", "1", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.2", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "n_out", "=", "n_hidden_conditioned", "if", "n_layers_shared", "else", "n_hidden_shared", "\n", "if", "n_layers_conditioned", ":", "\n", "            ", "self", ".", "px_decoder_conditioned", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_out", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers_conditioned", ",", "\n", "n_hidden", "=", "n_hidden_conditioned", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "True", ",", "\n", ")", "\n", "n_in", "=", "n_out", "\n", "", "else", ":", "\n", "            ", "self", ".", "px_decoder_conditioned", "=", "None", "\n", "n_in", "=", "n_input", "\n", "\n", "", "if", "n_layers_shared", ":", "\n", "            ", "self", ".", "px_decoder_final", "=", "FCLayers", "(", "\n", "n_in", "=", "n_in", ",", "\n", "n_out", "=", "n_hidden_shared", ",", "\n", "n_cat_list", "=", "[", "]", ",", "\n", "n_layers", "=", "n_layers_shared", ",", "\n", "n_hidden", "=", "n_hidden_shared", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "True", ",", "\n", ")", "\n", "n_in", "=", "n_hidden_shared", "\n", "", "else", ":", "\n", "            ", "self", ".", "px_decoder_final", "=", "None", "\n", "\n", "", "self", ".", "px_scale_decoder", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "n_in", ",", "n_output", ")", ",", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "self", ".", "px_r_decoder", "=", "nn", ".", "Linear", "(", "n_in", ",", "n_output", ")", "\n", "self", ".", "px_dropout_decoder", "=", "nn", ".", "Linear", "(", "n_in", ",", "n_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.MultiDecoder.forward": [[663, 684], ["_base_components.MultiDecoder.px_scale_decoder", "_base_components.MultiDecoder.px_dropout_decoder", "_base_components.MultiDecoder.px_decoder_conditioned", "_base_components.MultiDecoder.px_decoder_final", "torch.exp", "_base_components.MultiDecoder.px_r_decoder"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "z", ":", "torch", ".", "Tensor", ",", "\n", "dataset_id", ":", "int", ",", "\n", "library", ":", "torch", ".", "Tensor", ",", "\n", "dispersion", ":", "str", ",", "\n", "*", "cat_list", ":", "int", ",", "\n", ")", ":", "\n", "\n", "        ", "px", "=", "z", "\n", "if", "self", ".", "px_decoder_conditioned", ":", "\n", "            ", "px", "=", "self", ".", "px_decoder_conditioned", "(", "px", ",", "*", "cat_list", ")", "\n", "", "if", "self", ".", "px_decoder_final", ":", "\n", "            ", "px", "=", "self", ".", "px_decoder_final", "(", "px", ",", "*", "cat_list", ")", "\n", "\n", "", "px_scale", "=", "self", ".", "px_scale_decoder", "(", "px", ")", "\n", "px_dropout", "=", "self", ".", "px_dropout_decoder", "(", "px", ")", "\n", "px_rate", "=", "torch", ".", "exp", "(", "library", ")", "*", "px_scale", "\n", "px_r", "=", "self", ".", "px_r_decoder", "(", "px", ")", "if", "dispersion", "==", "\"gene-cell\"", "else", "None", "\n", "\n", "return", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.DecoderTOTALVI.__init__": [[712, 832], ["torch.nn.Module.__init__", "dict", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "_base_components.FCLayers", "torch.nn.Softmax", "torch.nn.Softplus"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output_genes", ":", "int", ",", "\n", "n_output_proteins", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_hidden", ":", "int", "=", "256", ",", "\n", "dropout_rate", ":", "float", "=", "0", ",", "\n", "use_batch_norm", ":", "float", "=", "True", ",", "\n", "use_layer_norm", ":", "float", "=", "False", ",", "\n", "scale_activation", ":", "Literal", "[", "\"softmax\"", ",", "\"softplus\"", "]", "=", "\"softmax\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_output_genes", "=", "n_output_genes", "\n", "self", ".", "n_output_proteins", "=", "n_output_proteins", "\n", "\n", "linear_args", "=", "dict", "(", "\n", "n_layers", "=", "1", ",", "\n", "use_activation", "=", "False", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", "use_layer_norm", "=", "False", ",", "\n", "dropout_rate", "=", "0", ",", "\n", ")", "\n", "\n", "self", ".", "px_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "\n", "# mean gamma", "\n", "self", ".", "px_scale_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_genes", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "**", "linear_args", ",", "\n", ")", "\n", "if", "scale_activation", "==", "\"softmax\"", ":", "\n", "            ", "self", ".", "px_scale_activation", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "", "elif", "scale_activation", "==", "\"softplus\"", ":", "\n", "            ", "self", ".", "px_scale_activation", "=", "nn", ".", "Softplus", "(", ")", "\n", "\n", "# background mean first decoder", "\n", "", "self", ".", "py_back_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "# background mean parameters second decoder", "\n", "self", ".", "py_back_mean_log_alpha", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_proteins", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "**", "linear_args", ",", "\n", ")", "\n", "self", ".", "py_back_mean_log_beta", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_proteins", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "**", "linear_args", ",", "\n", ")", "\n", "\n", "# foreground increment decoder step 1", "\n", "self", ".", "py_fore_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "# foreground increment decoder step 2", "\n", "self", ".", "py_fore_scale_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_proteins", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "1", ",", "\n", "use_activation", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", "use_layer_norm", "=", "False", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "activation_fn", "=", "nn", ".", "ReLU", ",", "\n", ")", "\n", "\n", "# dropout (mixture component for proteins, ZI probability for genes)", "\n", "self", ".", "sigmoid_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "self", ".", "px_dropout_decoder_gene", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_genes", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "**", "linear_args", ",", "\n", ")", "\n", "\n", "self", ".", "py_background_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_hidden", "+", "n_input", ",", "\n", "n_out", "=", "n_output_proteins", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "**", "linear_args", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.DecoderTOTALVI.forward": [[834, 905], ["_base_components.DecoderTOTALVI.px_decoder", "torch.cat", "_base_components.DecoderTOTALVI.px_scale_decoder", "_base_components.DecoderTOTALVI.px_scale_activation", "_base_components.DecoderTOTALVI.py_back_decoder", "torch.cat", "_base_components.DecoderTOTALVI.py_back_mean_log_alpha", "torch.exp", "torch.distributions.Normal().rsample", "torch.exp", "_base_components.DecoderTOTALVI.py_fore_decoder", "torch.cat", "_base_components.DecoderTOTALVI.sigmoid_decoder", "torch.cat", "_base_components.DecoderTOTALVI.px_dropout_decoder_gene", "_base_components.DecoderTOTALVI.py_background_decoder", "torch.nn.functional.normalize", "_base_components.DecoderTOTALVI.py_back_mean_log_beta", "torch.distributions.Normal", "_base_components.DecoderTOTALVI.py_fore_scale_decoder", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "library_gene", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        The forward computation for a single sample.\n\n         #. Decodes the data from the latent space using the decoder network\n         #. Returns local parameters for the ZINB distribution for genes\n         #. Returns local parameters for the Mixture NB distribution for proteins\n\n         We use the dictionary `px_` to contain the parameters of the ZINB/NB for genes.\n         The rate refers to the mean of the NB, dropout refers to Bernoulli mixing parameters.\n         `scale` refers to the quanity upon which differential expression is performed. For genes,\n         this can be viewed as the mean of the underlying gamma distribution.\n\n         We use the dictionary `py_` to contain the parameters of the Mixture NB distribution for proteins.\n         `rate_fore` refers to foreground mean, while `rate_back` refers to background mean. `scale` refers to\n         foreground mean adjusted for background probability and scaled to reside in simplex.\n         `back_alpha` and `back_beta` are the posterior parameters for `rate_back`.  `fore_scale` is the scaling\n         factor that enforces `rate_fore` > `rate_back`.\n\n        Parameters\n        ----------\n        z\n            tensor with shape ``(n_input,)``\n        library_gene\n            library size\n        cat_list\n            list of category membership(s) for this sample\n\n        Returns\n        -------\n        3-tuple (first 2-tuple :py:class:`dict`, last :py:class:`torch.Tensor`)\n            parameters for the ZINB distribution of expression\n\n        \"\"\"", "\n", "px_", "=", "{", "}", "\n", "py_", "=", "{", "}", "\n", "\n", "px", "=", "self", ".", "px_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "px_cat_z", "=", "torch", ".", "cat", "(", "[", "px", ",", "z", "]", ",", "dim", "=", "-", "1", ")", "\n", "unnorm_px_scale", "=", "self", ".", "px_scale_decoder", "(", "px_cat_z", ",", "*", "cat_list", ")", "\n", "px_", "[", "\"scale\"", "]", "=", "self", ".", "px_scale_activation", "(", "unnorm_px_scale", ")", "\n", "px_", "[", "\"rate\"", "]", "=", "library_gene", "*", "px_", "[", "\"scale\"", "]", "\n", "\n", "py_back", "=", "self", ".", "py_back_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "py_back_cat_z", "=", "torch", ".", "cat", "(", "[", "py_back", ",", "z", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "py_", "[", "\"back_alpha\"", "]", "=", "self", ".", "py_back_mean_log_alpha", "(", "py_back_cat_z", ",", "*", "cat_list", ")", "\n", "py_", "[", "\"back_beta\"", "]", "=", "torch", ".", "exp", "(", "\n", "self", ".", "py_back_mean_log_beta", "(", "py_back_cat_z", ",", "*", "cat_list", ")", "\n", ")", "\n", "log_pro_back_mean", "=", "Normal", "(", "py_", "[", "\"back_alpha\"", "]", ",", "py_", "[", "\"back_beta\"", "]", ")", ".", "rsample", "(", ")", "\n", "py_", "[", "\"rate_back\"", "]", "=", "torch", ".", "exp", "(", "log_pro_back_mean", ")", "\n", "\n", "py_fore", "=", "self", ".", "py_fore_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "py_fore_cat_z", "=", "torch", ".", "cat", "(", "[", "py_fore", ",", "z", "]", ",", "dim", "=", "-", "1", ")", "\n", "py_", "[", "\"fore_scale\"", "]", "=", "(", "\n", "self", ".", "py_fore_scale_decoder", "(", "py_fore_cat_z", ",", "*", "cat_list", ")", "+", "1", "+", "1e-8", "\n", ")", "\n", "py_", "[", "\"rate_fore\"", "]", "=", "py_", "[", "\"rate_back\"", "]", "*", "py_", "[", "\"fore_scale\"", "]", "\n", "\n", "p_mixing", "=", "self", ".", "sigmoid_decoder", "(", "z", ",", "*", "cat_list", ")", "\n", "p_mixing_cat_z", "=", "torch", ".", "cat", "(", "[", "p_mixing", ",", "z", "]", ",", "dim", "=", "-", "1", ")", "\n", "px_", "[", "\"dropout\"", "]", "=", "self", ".", "px_dropout_decoder_gene", "(", "p_mixing_cat_z", ",", "*", "cat_list", ")", "\n", "py_", "[", "\"mixing\"", "]", "=", "self", ".", "py_background_decoder", "(", "p_mixing_cat_z", ",", "*", "cat_list", ")", "\n", "\n", "protein_mixing", "=", "1", "/", "(", "1", "+", "torch", ".", "exp", "(", "-", "py_", "[", "\"mixing\"", "]", ")", ")", "\n", "py_", "[", "\"scale\"", "]", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "\n", "(", "1", "-", "protein_mixing", ")", "*", "py_", "[", "\"rate_fore\"", "]", ",", "p", "=", "1", ",", "dim", "=", "-", "1", "\n", ")", "\n", "\n", "return", "(", "px_", ",", "py_", ",", "log_pro_back_mean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.EncoderTOTALVI.__init__": [[941, 989], ["torch.nn.Module.__init__", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Linear", "_base_components.FCLayers", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "n_hidden", ":", "int", "=", "256", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "distribution", ":", "str", "=", "\"ln\"", ",", "\n", "use_batch_norm", ":", "bool", "=", "True", ",", "\n", "use_layer_norm", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "encoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "self", ".", "z_mean_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "self", ".", "z_var_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", "\n", "\n", "self", ".", "l_gene_encoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "1", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", ")", "\n", "self", ".", "l_gene_mean_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "1", ")", "\n", "self", ".", "l_gene_var_encoder", "=", "nn", ".", "Linear", "(", "n_hidden", ",", "1", ")", "\n", "\n", "self", ".", "distribution", "=", "distribution", "\n", "\n", "if", "distribution", "==", "\"ln\"", ":", "\n", "            ", "self", ".", "z_transformation", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "z_transformation", "=", "identity", "\n", "\n", "", "self", ".", "l_transformation", "=", "torch", ".", "exp", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.EncoderTOTALVI.reparameterize_transformation": [[990, 994], ["torch.distributions.Normal().rsample", "_base_components.EncoderTOTALVI.z_transformation", "torch.distributions.Normal", "var.sqrt"], "methods", ["None"], ["", "def", "reparameterize_transformation", "(", "self", ",", "mu", ",", "var", ")", ":", "\n", "        ", "untran_z", "=", "Normal", "(", "mu", ",", "var", ".", "sqrt", "(", ")", ")", ".", "rsample", "(", ")", "\n", "z", "=", "self", ".", "z_transformation", "(", "untran_z", ")", "\n", "return", "z", ",", "untran_z", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.EncoderTOTALVI.forward": [[995, 1045], ["_base_components.EncoderTOTALVI.encoder", "_base_components.EncoderTOTALVI.z_mean_encoder", "torch.distributions.Normal", "torch.distributions.Normal.rsample", "_base_components.EncoderTOTALVI.z_transformation", "_base_components.EncoderTOTALVI.l_gene_encoder", "_base_components.EncoderTOTALVI.l_gene_mean_encoder", "torch.distributions.Normal", "torch.distributions.Normal.rsample", "torch.clamp", "_base_components.EncoderTOTALVI.l_transformation", "torch.exp", "qz_v.sqrt", "torch.exp", "ql_v.sqrt", "_base_components.EncoderTOTALVI.z_var_encoder", "_base_components.EncoderTOTALVI.l_gene_var_encoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "data", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "r\"\"\"\n        The forward computation for a single sample.\n\n         #. Encodes the data into latent space using the encoder network\n         #. Generates a mean \\\\( q_m \\\\) and variance \\\\( q_v \\\\)\n         #. Samples a new value from an i.i.d. latent distribution\n\n        The dictionary ``latent`` contains the samples of the latent variables, while ``untran_latent``\n        contains the untransformed versions of these latent variables. For example, the library size is log normally distributed,\n        so ``untran_latent[\"l\"]`` gives the normal sample that was later exponentiated to become ``latent[\"l\"]``.\n        The logistic normal distribution is equivalent to applying softmax to a normal sample.\n\n        Parameters\n        ----------\n        data\n            tensor with shape ``(n_input,)``\n        cat_list\n            list of category membership(s) for this sample\n\n        Returns\n        -------\n        6-tuple. First 4 of :py:class:`torch.Tensor`, next 2 are `dict` of :py:class:`torch.Tensor`\n            tensors of shape ``(n_latent,)`` for mean and var, and sample\n\n        \"\"\"", "\n", "# Parameters for latent distribution", "\n", "q", "=", "self", ".", "encoder", "(", "data", ",", "*", "cat_list", ")", "\n", "qz_m", "=", "self", ".", "z_mean_encoder", "(", "q", ")", "\n", "qz_v", "=", "torch", ".", "exp", "(", "self", ".", "z_var_encoder", "(", "q", ")", ")", "+", "1e-4", "\n", "q_z", "=", "Normal", "(", "qz_m", ",", "qz_v", ".", "sqrt", "(", ")", ")", "\n", "untran_z", "=", "q_z", ".", "rsample", "(", ")", "\n", "z", "=", "self", ".", "z_transformation", "(", "untran_z", ")", "\n", "\n", "ql_gene", "=", "self", ".", "l_gene_encoder", "(", "data", ",", "*", "cat_list", ")", "\n", "ql_m", "=", "self", ".", "l_gene_mean_encoder", "(", "ql_gene", ")", "\n", "ql_v", "=", "torch", ".", "exp", "(", "self", ".", "l_gene_var_encoder", "(", "ql_gene", ")", ")", "+", "1e-4", "\n", "q_l", "=", "Normal", "(", "ql_m", ",", "ql_v", ".", "sqrt", "(", ")", ")", "\n", "log_library_gene", "=", "q_l", ".", "rsample", "(", ")", "\n", "log_library_gene", "=", "torch", ".", "clamp", "(", "log_library_gene", ",", "max", "=", "15", ")", "\n", "library_gene", "=", "self", ".", "l_transformation", "(", "log_library_gene", ")", "\n", "\n", "latent", "=", "{", "}", "\n", "untran_latent", "=", "{", "}", "\n", "latent", "[", "\"z\"", "]", "=", "z", "\n", "latent", "[", "\"l\"", "]", "=", "library_gene", "\n", "untran_latent", "[", "\"z\"", "]", "=", "untran_z", "\n", "untran_latent", "[", "\"l\"", "]", "=", "log_library_gene", "\n", "\n", "return", "q_z", ",", "q_l", ",", "latent", ",", "untran_latent", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.reparameterize_gaussian": [[14, 16], ["torch.distributions.Normal().rsample", "torch.distributions.Normal", "var.sqrt"], "function", ["None"], ["def", "reparameterize_gaussian", "(", "mu", ",", "var", ")", ":", "\n", "    ", "return", "Normal", "(", "mu", ",", "var", ".", "sqrt", "(", ")", ")", ".", "rsample", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.nn._base_components.identity": [[18, 20], ["None"], "function", ["None"], ["", "def", "identity", "(", "x", ")", ":", "\n", "    ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.__init__": [[68, 171], ["scvi.module.base.BaseModuleClass.__init__", "scvi.nn.FCLayers", "torch.nn.Sequential", "_mrdeconv.MRDeconv.decoder.load_state_dict", "_mrdeconv.MRDeconv.decoder.parameters", "_mrdeconv.MRDeconv.px_decoder.load_state_dict", "_mrdeconv.MRDeconv.px_decoder.parameters", "_mrdeconv.MRDeconv.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Softplus", "torch.tensor", "torch.randn", "torch.randn", "_mrdeconv.MRDeconv.register_buffer", "_mrdeconv.MRDeconv.register_buffer", "_mrdeconv.MRDeconv.register_buffer", "torch.randn", "scvi.nn.FCLayers", "torch.nn.Linear", "scvi.nn.FCLayers", "torch.nn.Linear", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_spots", ":", "int", ",", "\n", "n_labels", ":", "int", ",", "\n", "n_hidden", ":", "int", ",", "\n", "n_layers", ":", "int", ",", "\n", "n_latent", ":", "int", ",", "\n", "n_genes", ":", "int", ",", "\n", "decoder_state_dict", ":", "OrderedDict", ",", "\n", "px_decoder_state_dict", ":", "OrderedDict", ",", "\n", "px_r", ":", "np", ".", "ndarray", ",", "\n", "dropout_decoder", ":", "float", ",", "\n", "dropout_amortization", ":", "float", "=", "0.05", ",", "\n", "mean_vprior", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "var_vprior", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "mp_vprior", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "amortization", ":", "Literal", "[", "\"none\"", ",", "\"latent\"", ",", "\"proportion\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "l1_reg", ":", "float", "=", "0.0", ",", "\n", "beta_reg", ":", "float", "=", "5.0", ",", "\n", "eta_reg", ":", "float", "=", "1e-4", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_spots", "=", "n_spots", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "dropout_decoder", "=", "dropout_decoder", "\n", "self", ".", "dropout_amortization", "=", "dropout_amortization", "\n", "self", ".", "n_genes", "=", "n_genes", "\n", "self", ".", "amortization", "=", "amortization", "\n", "self", ".", "l1_reg", "=", "l1_reg", "\n", "self", ".", "beta_reg", "=", "beta_reg", "\n", "self", ".", "eta_reg", "=", "eta_reg", "\n", "# unpack and copy parameters", "\n", "self", ".", "decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_latent", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "[", "n_labels", "]", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_decoder", ",", "\n", "use_layer_norm", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", ")", "\n", "self", ".", "px_decoder", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "n_genes", ")", ",", "torch", ".", "nn", ".", "Softplus", "(", ")", "\n", ")", "\n", "# don't compute gradient for those parameters", "\n", "self", ".", "decoder", ".", "load_state_dict", "(", "decoder_state_dict", ")", "\n", "for", "param", "in", "self", ".", "decoder", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "", "self", ".", "px_decoder", ".", "load_state_dict", "(", "px_decoder_state_dict", ")", "\n", "for", "param", "in", "self", ".", "px_decoder", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "", "self", ".", "register_buffer", "(", "\"px_o\"", ",", "torch", ".", "tensor", "(", "px_r", ")", ")", "\n", "\n", "# cell_type specific factor loadings", "\n", "self", ".", "V", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "n_labels", "+", "1", ",", "self", ".", "n_spots", ")", ")", "\n", "\n", "# within cell_type factor loadings", "\n", "self", ".", "gamma", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_latent", ",", "self", ".", "n_labels", ",", "self", ".", "n_spots", ")", "\n", ")", "\n", "if", "mean_vprior", "is", "not", "None", ":", "\n", "            ", "self", ".", "p", "=", "mean_vprior", ".", "shape", "[", "1", "]", "\n", "self", ".", "register_buffer", "(", "\"mean_vprior\"", ",", "torch", ".", "tensor", "(", "mean_vprior", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"var_vprior\"", ",", "torch", ".", "tensor", "(", "var_vprior", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"mp_vprior\"", ",", "torch", ".", "tensor", "(", "mp_vprior", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mean_vprior", "=", "None", "\n", "self", ".", "var_vprior", "=", "None", "\n", "# noise from data", "\n", "", "self", ".", "eta", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "n_genes", ")", ")", "\n", "# additive gene bias", "\n", "self", ".", "beta", "=", "torch", ".", "nn", ".", "Parameter", "(", "0.01", "*", "torch", ".", "randn", "(", "self", ".", "n_genes", ")", ")", "\n", "\n", "# create additional neural nets for amortization", "\n", "# within cell_type factor loadings", "\n", "self", ".", "gamma_encoder", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "FCLayers", "(", "\n", "n_in", "=", "self", ".", "n_genes", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "None", ",", "\n", "n_layers", "=", "2", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_amortization", ",", "\n", "use_layer_norm", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "n_latent", "*", "n_labels", ")", ",", "\n", ")", "\n", "# cell type loadings", "\n", "self", ".", "V_encoder", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "FCLayers", "(", "\n", "n_in", "=", "self", ".", "n_genes", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_layers", "=", "2", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_amortization", ",", "\n", "use_layer_norm", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", ")", ",", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "n_labels", "+", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv._get_inference_input": [[173, 176], ["None"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "# we perform MAP here, so we just need to subsample the variables", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv._get_generative_input": [[177, 183], ["tensors[].long().ravel", "dict", "tensors[].long"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "ind_x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "INDICES_KEY", "]", ".", "long", "(", ")", ".", "ravel", "(", ")", "\n", "\n", "input_dict", "=", "dict", "(", "x", "=", "x", ",", "ind_x", "=", "ind_x", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.inference": [[184, 187], ["None"], "methods", ["None"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "self", ")", ":", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.generative": [[188, 242], ["torch.sum", "torch.exp", "torch.nn.functional.softplus", "torch.log", "torch.nn.functional.softplus", "torch.transpose", "torch.transpose().reshape.reshape", "torch.arange().repeat().view", "_mrdeconv.MRDeconv.decoder", "_mrdeconv.MRDeconv.px_decoder().reshape", "eps.repeat().view.repeat().view.repeat().view", "torch.cat", "torch.sum", "dict", "torch.transpose().reshape", "_mrdeconv.MRDeconv.V_encoder", "torch.arange().repeat().view.to", "torch.arange().repeat", "_mrdeconv.MRDeconv.px_decoder", "eps.repeat().view.repeat().view.repeat", "_mrdeconv.MRDeconv.unsqueeze", "torch.transpose", "torch.exp.unsqueeze().unsqueeze", "_mrdeconv.MRDeconv.gamma_encoder", "torch.arange", "torch.exp.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "self", ",", "x", ",", "ind_x", ")", ":", "\n", "        ", "\"\"\"Build the deconvolution model for every cell in the minibatch.\"\"\"", "\n", "m", "=", "x", ".", "shape", "[", "0", "]", "\n", "library", "=", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "# setup all non-linearities", "\n", "beta", "=", "torch", ".", "exp", "(", "self", ".", "beta", ")", "# n_genes", "\n", "eps", "=", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "self", ".", "eta", ")", "# n_genes", "\n", "x_", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "# subsample parameters", "\n", "\n", "if", "self", ".", "amortization", "in", "[", "\"both\"", ",", "\"latent\"", "]", ":", "\n", "            ", "gamma_ind", "=", "torch", ".", "transpose", "(", "self", ".", "gamma_encoder", "(", "x_", ")", ",", "0", ",", "1", ")", ".", "reshape", "(", "\n", "(", "self", ".", "n_latent", ",", "self", ".", "n_labels", ",", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "gamma_ind", "=", "self", ".", "gamma", "[", ":", ",", ":", ",", "ind_x", "]", "# n_latent, n_labels, minibatch_size", "\n", "\n", "", "if", "self", ".", "amortization", "in", "[", "\"both\"", ",", "\"proportion\"", "]", ":", "\n", "            ", "v_ind", "=", "self", ".", "V_encoder", "(", "x_", ")", "\n", "", "else", ":", "\n", "            ", "v_ind", "=", "self", ".", "V", "[", ":", ",", "ind_x", "]", ".", "T", "# minibatch_size, labels + 1", "\n", "", "v_ind", "=", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "v_ind", ")", "\n", "\n", "# reshape and get gene expression value for all minibatch", "\n", "gamma_ind", "=", "torch", ".", "transpose", "(", "\n", "gamma_ind", ",", "2", ",", "0", "\n", ")", "# minibatch_size, n_labels, n_latent", "\n", "gamma_reshape", "=", "gamma_ind", ".", "reshape", "(", "\n", "(", "-", "1", ",", "self", ".", "n_latent", ")", "\n", ")", "# minibatch_size * n_labels, n_latent", "\n", "enum_label", "=", "(", "\n", "torch", ".", "arange", "(", "0", ",", "self", ".", "n_labels", ")", ".", "repeat", "(", "(", "m", ")", ")", ".", "view", "(", "(", "-", "1", ",", "1", ")", ")", "\n", ")", "# minibatch_size * n_labels, 1", "\n", "h", "=", "self", ".", "decoder", "(", "gamma_reshape", ",", "enum_label", ".", "to", "(", "x", ".", "device", ")", ")", "\n", "px_rate", "=", "self", ".", "px_decoder", "(", "h", ")", ".", "reshape", "(", "\n", "(", "m", ",", "self", ".", "n_labels", ",", "-", "1", ")", "\n", ")", "# (minibatch, n_labels, n_genes)", "\n", "\n", "# add the dummy cell type", "\n", "eps", "=", "eps", ".", "repeat", "(", "(", "m", ",", "1", ")", ")", ".", "view", "(", "\n", "m", ",", "1", ",", "-", "1", "\n", ")", "# (M, 1, n_genes) <- this is the dummy cell type", "\n", "\n", "# account for gene specific bias and add noise", "\n", "r_hat", "=", "torch", ".", "cat", "(", "\n", "[", "beta", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "1", ")", "*", "px_rate", ",", "eps", "]", ",", "dim", "=", "1", "\n", ")", "# M, n_labels + 1, n_genes", "\n", "# now combine them for convolution", "\n", "px_scale", "=", "torch", ".", "sum", "(", "v_ind", ".", "unsqueeze", "(", "2", ")", "*", "r_hat", ",", "dim", "=", "1", ")", "# batch_size, n_genes", "\n", "px_rate", "=", "library", "*", "px_scale", "\n", "\n", "return", "dict", "(", "\n", "px_o", "=", "self", ".", "px_o", ",", "px_rate", "=", "px_rate", ",", "px_scale", "=", "px_scale", ",", "gamma", "=", "gamma_ind", ",", "v", "=", "v_ind", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.loss": [[244, 311], ["torch.zeros_like", "torch.ones_like", "scvi.module.base.LossRecorder", "scvi.distributions.NegativeBinomial().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "torch.var", "torch.abs().mean", "torch.zeros_like", "torch.ones_like", "gamma.unsqueeze.unsqueeze.unsqueeze", "torch.transpose().unsqueeze", "torch.transpose().unsqueeze", "torch.transpose", "torch.logsumexp", "torch.distributions.Normal().log_prob().sum().sum", "torch.distributions.Normal().log_prob().sum", "torch.log", "torch.logsumexp.sum", "torch.mean", "scvi.distributions.NegativeBinomial().log_prob", "torch.distributions.Normal().log_prob", "torch.abs", "torch.transpose", "torch.transpose", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob", "scvi.distributions.NegativeBinomial", "torch.distributions.Normal", "torch.distributions.Normal().log_prob", "torch.distributions.Normal", "torch.distributions.Normal", "torch.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", "n_obs", ":", "int", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "px_rate", "=", "generative_outputs", "[", "\"px_rate\"", "]", "\n", "px_o", "=", "generative_outputs", "[", "\"px_o\"", "]", "\n", "gamma", "=", "generative_outputs", "[", "\"gamma\"", "]", "\n", "v", "=", "generative_outputs", "[", "\"v\"", "]", "\n", "\n", "reconst_loss", "=", "-", "NegativeBinomial", "(", "px_rate", ",", "logits", "=", "px_o", ")", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "# eta prior likelihood", "\n", "mean", "=", "torch", ".", "zeros_like", "(", "self", ".", "eta", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "self", ".", "eta", ")", "\n", "glo_neg_log_likelihood_prior", "=", "(", "\n", "-", "self", ".", "eta_reg", "*", "Normal", "(", "mean", ",", "scale", ")", ".", "log_prob", "(", "self", ".", "eta", ")", ".", "sum", "(", ")", "\n", ")", "\n", "glo_neg_log_likelihood_prior", "+=", "self", ".", "beta_reg", "*", "torch", ".", "var", "(", "self", ".", "beta", ")", "\n", "\n", "v_sparsity_loss", "=", "self", ".", "l1_reg", "*", "torch", ".", "abs", "(", "v", ")", ".", "mean", "(", "1", ")", "\n", "\n", "# gamma prior likelihood", "\n", "if", "self", ".", "mean_vprior", "is", "None", ":", "\n", "# isotropic normal prior", "\n", "            ", "mean", "=", "torch", ".", "zeros_like", "(", "gamma", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "gamma", ")", "\n", "neg_log_likelihood_prior", "=", "(", "\n", "-", "Normal", "(", "mean", ",", "scale", ")", ".", "log_prob", "(", "gamma", ")", ".", "sum", "(", "2", ")", ".", "sum", "(", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "# vampprior", "\n", "# gamma is of shape n_latent, n_labels, minibatch_size", "\n", "            ", "gamma", "=", "gamma", ".", "unsqueeze", "(", "1", ")", "# minibatch_size, 1, n_labels, n_latent", "\n", "mean_vprior", "=", "torch", ".", "transpose", "(", "self", ".", "mean_vprior", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "\n", "0", "\n", ")", "# 1, p, n_labels, n_latent", "\n", "var_vprior", "=", "torch", ".", "transpose", "(", "self", ".", "var_vprior", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "\n", "0", "\n", ")", "# 1, p, n_labels, n_latent", "\n", "mp_vprior", "=", "torch", ".", "transpose", "(", "self", ".", "mp_vprior", ",", "0", ",", "1", ")", "# p, n_labels", "\n", "pre_lse", "=", "(", "\n", "Normal", "(", "mean_vprior", ",", "torch", ".", "sqrt", "(", "var_vprior", ")", "+", "1e-4", ")", "\n", ".", "log_prob", "(", "gamma", ")", "\n", ".", "sum", "(", "3", ")", "\n", ")", "+", "torch", ".", "log", "(", "\n", "mp_vprior", "\n", ")", "# minibatch, p, n_labels", "\n", "# Pseudocount for numerical stability", "\n", "log_likelihood_prior", "=", "torch", ".", "logsumexp", "(", "pre_lse", ",", "1", ")", "# minibatch, n_labels", "\n", "neg_log_likelihood_prior", "=", "-", "log_likelihood_prior", ".", "sum", "(", "1", ")", "# minibatch", "\n", "# mean_vprior is of shape n_labels, p, n_latent", "\n", "\n", "# High v_sparsity_loss is detrimental early in training, scaling by kl_weight to increase over training epochs.", "\n", "", "loss", "=", "n_obs", "*", "(", "\n", "torch", ".", "mean", "(", "\n", "reconst_loss", "+", "kl_weight", "*", "(", "neg_log_likelihood_prior", "+", "v_sparsity_loss", ")", "\n", ")", "\n", "+", "glo_neg_log_likelihood_prior", "\n", ")", "\n", "\n", "return", "LossRecorder", "(", "\n", "loss", ",", "reconst_loss", ",", "neg_log_likelihood_prior", ",", "glo_neg_log_likelihood_prior", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.sample": [[313, 321], ["torch.no_grad", "NotImplementedError"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "n_samples", "=", "1", ",", "\n", "library_size", "=", "1", ",", "\n", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"No sampling method for DestVI\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.get_proportions": [[322, 340], ["torch.no_grad", "torch.log", "torch.nn.functional.softplus", "torch.nn.functional.softplus.sum().reshape", "_mrdeconv.MRDeconv.V_encoder", "torch.nn.functional.softplus().cpu().numpy", "torch.nn.functional.softplus.sum", "torch.nn.functional.softplus().cpu", "torch.nn.functional.softplus"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "@", "auto_move_data", "\n", "def", "get_proportions", "(", "self", ",", "x", "=", "None", ",", "keep_noise", "=", "False", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Returns the loadings.\"\"\"", "\n", "if", "self", ".", "amortization", "in", "[", "\"both\"", ",", "\"proportion\"", "]", ":", "\n", "# get estimated unadjusted proportions", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "res", "=", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "self", ".", "V_encoder", "(", "x_", ")", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "(", "\n", "torch", ".", "nn", ".", "functional", ".", "softplus", "(", "self", ".", "V", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "T", "\n", ")", "# n_spots, n_labels + 1", "\n", "# remove dummy cell type proportion values", "\n", "", "if", "not", "keep_noise", ":", "\n", "            ", "res", "=", "res", "[", ":", ",", ":", "-", "1", "]", "\n", "# normalize to obtain adjusted proportions", "\n", "", "res", "=", "res", "/", "res", ".", "sum", "(", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.get_gamma": [[341, 361], ["torch.no_grad", "torch.log", "_mrdeconv.MRDeconv.gamma_encoder", "torch.transpose().reshape", "_mrdeconv.MRDeconv.gamma.cpu().numpy", "torch.transpose", "_mrdeconv.MRDeconv.gamma.cpu"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "@", "auto_move_data", "\n", "def", "get_gamma", "(", "self", ",", "x", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns the loadings.\n\n        Returns\n        -------\n        type\n            tensor\n        \"\"\"", "\n", "# get estimated unadjusted proportions", "\n", "if", "self", ".", "amortization", "in", "[", "\"latent\"", ",", "\"both\"", "]", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "gamma", "=", "self", ".", "gamma_encoder", "(", "x_", ")", "\n", "return", "torch", ".", "transpose", "(", "gamma", ",", "0", ",", "1", ")", ".", "reshape", "(", "\n", "(", "self", ".", "n_latent", ",", "self", ".", "n_labels", ",", "-", "1", ")", "\n", ")", "# n_latent, n_labels, minibatch", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "gamma", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# (n_latent, n_labels, n_spots)", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.MRDeconv.get_ct_specific_expression": [[362, 399], ["torch.no_grad", "torch.exp", "_mrdeconv.MRDeconv.decoder", "_mrdeconv.MRDeconv.px_decoder", "torch.log", "torch.transpose().reshape", "y_torch.unsqueeze", "torch.exp().unsqueeze", "torch.exp.unsqueeze", "torch.ones_like", "torch.transpose", "_mrdeconv.MRDeconv.gamma_encoder", "torch.arange", "torch.exp"], "methods", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "@", "auto_move_data", "\n", "def", "get_ct_specific_expression", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", "=", "None", ",", "ind_x", ":", "torch", ".", "Tensor", "=", "None", ",", "y", ":", "int", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Returns cell type specific gene expression at the queried spots.\n\n        Parameters\n        ----------\n        x\n            tensor of data\n        ind_x\n            tensor of indices\n        y\n            integer for cell types\n        \"\"\"", "\n", "# cell-type specific gene expression, shape (minibatch, celltype, gene).", "\n", "beta", "=", "torch", ".", "exp", "(", "self", ".", "beta", ")", "# n_genes", "\n", "y_torch", "=", "(", "y", "*", "torch", ".", "ones_like", "(", "ind_x", ")", ")", ".", "ravel", "(", ")", "\n", "# obtain the relevant gammas", "\n", "if", "self", ".", "amortization", "in", "[", "\"both\"", ",", "\"latent\"", "]", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "gamma_ind", "=", "torch", ".", "transpose", "(", "self", ".", "gamma_encoder", "(", "x_", ")", ",", "0", ",", "1", ")", ".", "reshape", "(", "\n", "(", "self", ".", "n_latent", ",", "self", ".", "n_labels", ",", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "gamma_ind", "=", "self", ".", "gamma", "[", ":", ",", ":", ",", "ind_x", "]", "# n_latent, n_labels, minibatch_size", "\n", "\n", "# calculate cell type specific expression", "\n", "", "gamma_select", "=", "gamma_ind", "[", "\n", ":", ",", "y_torch", ",", "torch", ".", "arange", "(", "ind_x", ".", "shape", "[", "0", "]", ")", "\n", "]", ".", "T", "# minibatch_size, n_latent", "\n", "h", "=", "self", ".", "decoder", "(", "gamma_select", ",", "y_torch", ".", "unsqueeze", "(", "1", ")", ")", "\n", "px_scale", "=", "self", ".", "px_decoder", "(", "h", ")", "# (minibatch, n_genes)", "\n", "px_ct", "=", "torch", ".", "exp", "(", "self", ".", "px_o", ")", ".", "unsqueeze", "(", "0", ")", "*", "beta", ".", "unsqueeze", "(", "0", ")", "*", "px_scale", "\n", "return", "px_ct", "# shape (minibatch, genes)", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.identity": [[14, 16], ["None"], "function", ["None"], ["def", "identity", "(", "x", ")", ":", "\n", "    ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.iterate": [[6, 12], ["type", "type.", "func", "_utils.iterate"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.iterate"], ["\n", "\n", "def", "dec", "(", "obj", ")", ":", "\n", "        ", "obj", ".", "__orig_doc__", "=", "obj", ".", "__doc__", "\n", "obj", ".", "__doc__", "=", "dedent", "(", "obj", ".", "__doc__", ")", ".", "format_map", "(", "kwds", ")", "\n", "return", "obj", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.broadcast_labels": [[14, 35], ["len", "ValueError", "_utils.enumerate_discrete", "_utils.iterate", "scvi.nn.one_hot", "x.repeat", "x.repeat", "len", "x.size"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.enumerate_discrete", "home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.iterate", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "return", "dec", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.enumerate_discrete": [[37, 44], ["x.size", "torch.cat", "scvi.nn.one_hot", "torch.ones", "_utils.enumerate_discrete.batch"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.CategoricalBoW.log_prob": [[20, 28], ["pyro.util.broadcast_all", "pyro.util.broadcast_all", "pyro.util.broadcast_all", "logits.clone.clone.clone", "_amortizedlda.CategoricalBoW._validate_sample"], "methods", ["None"], ["    ", "def", "log_prob", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "self", ".", "_validate_args", ":", "\n", "            ", "self", ".", "_validate_sample", "(", "value", ")", "\n", "", "logits", ",", "value", "=", "dist", ".", "util", ".", "broadcast_all", "(", "self", ".", "logits", ",", "value", ")", "\n", "logits", "=", "logits", ".", "clone", "(", "memory_format", "=", "torch", ".", "contiguous_format", ")", "\n", "logits", "[", "(", "value", "==", "0", ")", "&", "(", "logits", "==", "-", "math", ".", "inf", ")", "]", "=", "0", "\n", "log_powers", "=", "(", "logits", "*", "value", ")", ".", "sum", "(", "-", "1", ")", "\n", "return", "log_powers", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModel.__init__": [[61, 95], ["pyro.nn.PyroModule.__init__", "_amortizedlda.logistic_normal_approximation", "_amortizedlda.AmortizedLDAPyroModel.register_buffer", "_amortizedlda.AmortizedLDAPyroModel.register_buffer", "_amortizedlda.logistic_normal_approximation", "_amortizedlda.AmortizedLDAPyroModel.register_buffer", "_amortizedlda.AmortizedLDAPyroModel.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.logistic_normal_approximation", "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.logistic_normal_approximation"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_topics", ":", "int", ",", "\n", "cell_topic_prior", ":", "torch", ".", "Tensor", ",", "\n", "topic_feature_prior", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "_AMORTIZED_LDA_PYRO_MODULE_NAME", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "# Populated by PyroTrainingPlan.", "\n", "self", ".", "n_obs", "=", "None", "\n", "\n", "cell_topic_prior_mu", ",", "cell_topic_prior_sigma", "=", "logistic_normal_approximation", "(", "\n", "cell_topic_prior", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"cell_topic_prior_mu\"", ",", "\n", "cell_topic_prior_mu", ",", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"cell_topic_prior_sigma\"", ",", "\n", "cell_topic_prior_sigma", ",", "\n", ")", "\n", "(", "\n", "topic_feature_prior_mu", ",", "\n", "topic_feature_prior_sigma", ",", "\n", ")", "=", "logistic_normal_approximation", "(", "topic_feature_prior", ")", "\n", "self", ".", "register_buffer", "(", "\"topic_feature_prior_mu\"", ",", "topic_feature_prior_mu", ")", "\n", "self", ".", "register_buffer", "(", "\"topic_feature_prior_sigma\"", ",", "topic_feature_prior_sigma", ")", "\n", "\n", "# Hack: to allow auto_move_data to infer device.", "\n", "self", ".", "_dummy", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModel._get_fn_args_from_batch": [[96, 104], ["torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_fn_args_from_batch", "(", "\n", "tensor_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "\n", ")", "->", "Union", "[", "Iterable", ",", "dict", "]", ":", "\n", "\n", "        ", "x", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "library", "=", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", "\n", "return", "(", "x", ",", "library", ")", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModel.forward": [[105, 139], ["int", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.scale", "pyro.scale", "pyro.scale", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "torch.softmax", "torch.softmax", "torch.max().item", "torch.max().item", "torch.max().item", "torch.max().item", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "torch.softmax", "torch.softmax", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.scale", "pyro.scale", "pyro.scale", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "_amortizedlda.CategoricalBoW", "torch.max", "torch.max", "torch.max", "torch.max", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "library", ":", "torch", ".", "Tensor", ",", "\n", "n_obs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "# Topic feature distributions.", "\n", "        ", "with", "pyro", ".", "plate", "(", "\"topics\"", ",", "self", ".", "n_topics", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "log_topic_feature_dist", "=", "pyro", ".", "sample", "(", "\n", "\"log_topic_feature_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "topic_feature_prior_mu", ",", "self", ".", "topic_feature_prior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "topic_feature_dist", "=", "F", ".", "softmax", "(", "log_topic_feature_dist", ",", "dim", "=", "1", ")", "\n", "\n", "# Cell counts generation.", "\n", "", "max_library_size", "=", "int", "(", "torch", ".", "max", "(", "library", ")", ".", "item", "(", ")", ")", "\n", "with", "pyro", ".", "plate", "(", "\"cells\"", ",", "size", "=", "n_obs", "or", "self", ".", "n_obs", ",", "subsample_size", "=", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "with", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "                ", "log_cell_topic_dist", "=", "pyro", ".", "sample", "(", "\n", "\"log_cell_topic_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "cell_topic_prior_mu", ",", "self", ".", "cell_topic_prior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "", "cell_topic_dist", "=", "F", ".", "softmax", "(", "log_cell_topic_dist", ",", "dim", "=", "1", ")", "\n", "\n", "pyro", ".", "sample", "(", "\n", "\"feature_counts\"", ",", "\n", "CategoricalBoW", "(", "max_library_size", ",", "cell_topic_dist", "@", "topic_feature_dist", ")", ",", "\n", "obs", "=", "x", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroGuide.__init__": [[156, 175], ["pyro.nn.PyroModule.__init__", "scvi.nn.Encoder", "_amortizedlda.logistic_normal_approximation", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "topic_feature_posterior_mu.repeat", "topic_feature_posterior_sigma.repeat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.logistic_normal_approximation"], ["def", "__init__", "(", "self", ",", "n_input", ":", "int", ",", "n_topics", ":", "int", ",", "n_hidden", ":", "int", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "_AMORTIZED_LDA_PYRO_MODULE_NAME", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "# Populated by PyroTrainingPlan.", "\n", "self", ".", "n_obs", "=", "None", "\n", "\n", "self", ".", "encoder", "=", "Encoder", "(", "n_input", ",", "n_topics", ",", "distribution", "=", "\"ln\"", ",", "return_dist", "=", "True", ")", "\n", "(", "\n", "topic_feature_posterior_mu", ",", "\n", "topic_feature_posterior_sigma", ",", "\n", ")", "=", "logistic_normal_approximation", "(", "torch", ".", "ones", "(", "self", ".", "n_input", ")", ")", "\n", "self", ".", "topic_feature_posterior_mu", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "topic_feature_posterior_mu", ".", "repeat", "(", "self", ".", "n_topics", ",", "1", ")", "\n", ")", "\n", "self", ".", "unconstrained_topic_feature_posterior_sigma", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "topic_feature_posterior_sigma", ".", "repeat", "(", "self", ".", "n_topics", ",", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroGuide.topic_feature_posterior_sigma": [[177, 180], ["torch.softplus", "torch.softplus"], "methods", ["None"], ["", "@", "property", "\n", "def", "topic_feature_posterior_sigma", "(", "self", ")", ":", "\n", "        ", "return", "F", ".", "softplus", "(", "self", ".", "unconstrained_topic_feature_posterior_sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroGuide.forward": [[181, 211], ["pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.scale", "pyro.scale", "pyro.scale", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.scale", "pyro.scale", "pyro.scale", "_amortizedlda.AmortizedLDAPyroGuide.encoder", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "_library", ":", "torch", ".", "Tensor", ",", "\n", "n_obs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "# Topic feature distributions.", "\n", "        ", "with", "pyro", ".", "plate", "(", "\"topics\"", ",", "self", ".", "n_topics", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "pyro", ".", "sample", "(", "\n", "\"log_topic_feature_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "topic_feature_posterior_mu", ",", "\n", "self", ".", "topic_feature_posterior_sigma", ",", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "\n", "# Cell topic distributions guide.", "\n", "", "with", "pyro", ".", "plate", "(", "\n", "\"cells\"", ",", "size", "=", "n_obs", "or", "self", ".", "n_obs", ",", "subsample_size", "=", "x", ".", "shape", "[", "0", "]", "\n", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "cell_topic_posterior", ",", "_", "=", "self", ".", "encoder", "(", "x", ")", "\n", "cell_topic_posterior_mu", "=", "cell_topic_posterior", ".", "loc", "\n", "cell_topic_posterior_sigma", "=", "cell_topic_posterior", ".", "scale", "**", "2", "\n", "pyro", ".", "sample", "(", "\n", "\"log_cell_topic_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "cell_topic_posterior_mu", ",", "cell_topic_posterior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.__init__": [[240, 276], ["scvi.module.base.PyroBaseModuleClass.__init__", "_amortizedlda.AmortizedLDAPyroModel", "_amortizedlda.AmortizedLDAPyroGuide", "torch.full", "torch.full", "torch.full", "torch.full", "isinstance", "torch.full", "torch.full", "torch.full", "torch.full", "isinstance", "torch.full", "torch.full", "torch.full", "torch.full", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.full", "torch.full", "torch.full", "torch.full", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_topics", ":", "int", ",", "\n", "n_hidden", ":", "int", ",", "\n", "cell_topic_prior", ":", "Optional", "[", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", "]", "=", "None", ",", "\n", "topic_feature_prior", ":", "Optional", "[", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "\n", "if", "cell_topic_prior", "is", "None", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "full", "(", "(", "n_topics", ",", ")", ",", "1", "/", "self", ".", "n_topics", ")", "\n", "", "elif", "isinstance", "(", "cell_topic_prior", ",", "float", ")", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "full", "(", "(", "n_topics", ",", ")", ",", "cell_topic_prior", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "tensor", "(", "cell_topic_prior", ")", "\n", "\n", "", "if", "topic_feature_prior", "is", "None", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "full", "(", "(", "n_input", ",", ")", ",", "1", "/", "self", ".", "n_topics", ")", "\n", "", "elif", "isinstance", "(", "topic_feature_prior", ",", "float", ")", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "full", "(", "(", "n_input", ",", ")", ",", "topic_feature_prior", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "tensor", "(", "topic_feature_prior", ")", "\n", "\n", "", "self", ".", "_model", "=", "AmortizedLDAPyroModel", "(", "\n", "self", ".", "n_input", ",", "\n", "self", ".", "n_topics", ",", "\n", "self", ".", "cell_topic_prior", ",", "\n", "self", ".", "topic_feature_prior", ",", "\n", ")", "\n", "self", ".", "_guide", "=", "AmortizedLDAPyroGuide", "(", "self", ".", "n_input", ",", "self", ".", "n_topics", ",", "self", ".", "n_hidden", ")", "\n", "self", ".", "_get_fn_args_from_batch", "=", "self", ".", "_model", ".", "_get_fn_args_from_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.model": [[277, 280], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "model", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.guide": [[281, 284], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "guide", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_guide", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.topic_by_feature": [[285, 313], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "_amortizedlda.AmortizedLDAPyroModule.guide.topic_feature_posterior_mu.detach().cpu", "_amortizedlda.AmortizedLDAPyroModule.guide.topic_feature_posterior_sigma.detach().cpu", "torch.softmax", "torch.softmax", "pyro.Normal().sample", "pyro.Normal().sample", "pyro.Normal().sample", "_amortizedlda.AmortizedLDAPyroModule.guide.topic_feature_posterior_mu.detach", "_amortizedlda.AmortizedLDAPyroModule.guide.topic_feature_posterior_sigma.detach", "pyro.Normal", "pyro.Normal", "pyro.Normal", "torch.Size", "torch.Size", "torch.Size", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "topic_by_feature", "(", "self", ",", "n_samples", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Gets a Monte-Carlo estimate of the expectation of the topic by feature matrix.\n\n        Assumes the module has already been trained.\n\n        Parameters\n        ----------\n        n_samples\n            Number of samples to take for the Monte-Carlo estimate of the mean.\n\n        Returns\n        -------\n        A `n_topics x n_input` tensor containing the topic by feature matrix.\n        \"\"\"", "\n", "topic_feature_posterior_mu", ",", "topic_feature_posterior_sigma", "=", "(", "\n", "self", ".", "guide", ".", "topic_feature_posterior_mu", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "self", ".", "guide", ".", "topic_feature_posterior_sigma", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", ")", "\n", "return", "torch", ".", "mean", "(", "\n", "F", ".", "softmax", "(", "\n", "dist", ".", "Normal", "(", "\n", "topic_feature_posterior_mu", ",", "\n", "topic_feature_posterior_sigma", ",", "\n", ")", ".", "sample", "(", "sample_shape", "=", "torch", ".", "Size", "(", "(", "n_samples", ",", ")", ")", ")", ",", "\n", "dim", "=", "2", ",", "\n", ")", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.get_topic_distribution": [[315, 344], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "_amortizedlda.AmortizedLDAPyroModule.guide.encoder", "cell_topic_dist.loc.detach().cpu", "torch.softplus", "torch.softplus", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "cell_topic_dist.scale.log", "torch.softplus.detach().cpu", "torch.softmax", "torch.softmax", "cell_topic_dist.loc.detach", "pyro.Normal().sample", "pyro.Normal().sample", "pyro.Normal().sample", "torch.softplus.detach", "pyro.Normal", "pyro.Normal", "pyro.Normal", "torch.Size", "torch.Size", "torch.Size", "torch.Size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_topic_distribution", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "n_samples", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Converts `x` to its inferred topic distribution.\n\n        Parameters\n        ----------\n        x\n            Counts tensor.\n        n_samples\n            Number of samples to take for the Monte-Carlo estimate of the mean.\n\n        Returns\n        -------\n        A `x.shape[0] x n_topics` tensor containing the normalized topic distribution.\n        \"\"\"", "\n", "cell_topic_dist", ",", "_", "=", "self", ".", "guide", ".", "encoder", "(", "x", ")", "\n", "cell_topic_dist_mu", "=", "cell_topic_dist", ".", "loc", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "cell_topic_dist_sigma", "=", "2.0", "*", "cell_topic_dist", ".", "scale", ".", "log", "(", ")", "\n", "cell_topic_dist_sigma", "=", "F", ".", "softplus", "(", "cell_topic_dist_sigma", ".", "detach", "(", ")", ".", "cpu", "(", ")", ")", "\n", "return", "torch", ".", "mean", "(", "\n", "F", ".", "softmax", "(", "\n", "dist", ".", "Normal", "(", "cell_topic_dist_mu", ",", "cell_topic_dist_sigma", ")", ".", "sample", "(", "\n", "sample_shape", "=", "torch", ".", "Size", "(", "(", "n_samples", ",", ")", ")", "\n", ")", ",", "\n", "dim", "=", "2", ",", "\n", ")", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.get_elbo": [[346, 366], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "pyro.infer.Trace_ELBO().loss", "pyro.infer.Trace_ELBO().loss", "pyro.infer.Trace_ELBO().loss", "pyro.infer.Trace_ELBO", "pyro.infer.Trace_ELBO", "pyro.infer.Trace_ELBO"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss"], ["", "@", "auto_move_data", "\n", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_elbo", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "library", ":", "torch", ".", "Tensor", ",", "n_obs", ":", "int", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Computes ELBO.\n\n        Parameters\n        ----------\n        x\n            Counts tensor.\n        library\n            Library sizes for each cell.\n        n_obs\n            Size of full batch. If n_obs < x.shape[0], ELBO is scaled by (n_obs / x.shape[0]).\n\n        Returns\n        -------\n        The positive ELBO.\n        \"\"\"", "\n", "return", "Trace_ELBO", "(", ")", ".", "loss", "(", "self", ".", "model", ",", "self", ".", "guide", ",", "x", ",", "library", ",", "n_obs", "=", "n_obs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.logistic_normal_approximation": [[30, 43], ["torch.sqrt", "torch.sqrt", "torch.log", "torch.log", "torch.log().sum", "torch.log().sum", "torch.sum", "torch.sum", "torch.log", "torch.log"], "function", ["None"], ["", "", "def", "logistic_normal_approximation", "(", "\n", "alpha", ":", "torch", ".", "Tensor", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Returns the mean and standard deviation of the Logistic Normal approximation to the Dirichlet.\n\n    Uses the Laplace approximation of the Logistic Normal distribution to the Dirichlet distribution\n    as described in Srivastava et al. https://arxiv.org/pdf/1703.01488.pdf.\n    \"\"\"", "\n", "K", "=", "alpha", ".", "shape", "[", "0", "]", "\n", "mu", "=", "torch", ".", "log", "(", "alpha", ")", "-", "torch", ".", "log", "(", "alpha", ")", ".", "sum", "(", ")", "/", "K", "\n", "sigma", "=", "torch", ".", "sqrt", "(", "(", "1", "-", "2", "/", "K", ")", "/", "alpha", "+", "torch", ".", "sum", "(", "1", "/", "alpha", ")", "/", "K", "**", "2", ")", "\n", "return", "mu", ",", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.__init__": [[74, 186], ["dict", "_vae.VAE.__init__", "cls_parameters.update", "_classifier.Classifier", "scvi.nn.Encoder", "scvi.nn.Decoder", "torch.nn.Parameter", "numpy.array", "numpy.unique", "len", "_classifier.Classifier", "torch.nn.ParameterList", "ValueError", "ValueError", "torch.ones", "torch.nn.Parameter", "torch.tensor", "range", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_continuous_cov", ":", "int", "=", "0", ",", "\n", "n_cats_per_cov", ":", "Optional", "[", "Iterable", "[", "int", "]", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "str", "=", "\"gene\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", "gene_likelihood", ":", "str", "=", "\"zinb\"", ",", "\n", "y_prior", "=", "None", ",", "\n", "labels_groups", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", "use_labels_groups", ":", "bool", "=", "False", ",", "\n", "classifier_parameters", ":", "dict", "=", "dict", "(", ")", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "**", "vae_kwargs", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "n_input", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_continuous_cov", "=", "n_continuous_cov", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "log_variational", "=", "log_variational", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "**", "vae_kwargs", "\n", ")", "\n", "\n", "use_batch_norm_encoder", "=", "use_batch_norm", "==", "\"encoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_batch_norm_decoder", "=", "use_batch_norm", "==", "\"decoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_layer_norm_encoder", "=", "use_layer_norm", "==", "\"encoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "use_layer_norm_decoder", "=", "use_layer_norm", "==", "\"decoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "# Classifier takes n_latent as input", "\n", "cls_parameters", "=", "{", "\n", "\"n_layers\"", ":", "n_layers", ",", "\n", "\"n_hidden\"", ":", "n_hidden", ",", "\n", "\"dropout_rate\"", ":", "dropout_rate", ",", "\n", "}", "\n", "cls_parameters", ".", "update", "(", "classifier_parameters", ")", "\n", "self", ".", "classifier", "=", "Classifier", "(", "\n", "n_latent", ",", "\n", "n_labels", "=", "n_labels", ",", "\n", "use_batch_norm", "=", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_encoder", ",", "\n", "**", "cls_parameters", "\n", ")", "\n", "\n", "self", ".", "encoder_z2_z1", "=", "Encoder", "(", "\n", "n_latent", ",", "\n", "n_latent", ",", "\n", "n_cat_list", "=", "[", "self", ".", "n_labels", "]", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "decoder_z1_z2", "=", "Decoder", "(", "\n", "n_latent", ",", "\n", "n_latent", ",", "\n", "n_cat_list", "=", "[", "self", ".", "n_labels", "]", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "use_batch_norm", "=", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_decoder", ",", "\n", ")", "\n", "\n", "self", ".", "y_prior", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "y_prior", "\n", "if", "y_prior", "is", "not", "None", "\n", "else", "(", "1", "/", "n_labels", ")", "*", "torch", ".", "ones", "(", "1", ",", "n_labels", ")", ",", "\n", "requires_grad", "=", "False", ",", "\n", ")", "\n", "self", ".", "use_labels_groups", "=", "use_labels_groups", "\n", "self", ".", "labels_groups", "=", "(", "\n", "np", ".", "array", "(", "labels_groups", ")", "if", "labels_groups", "is", "not", "None", "else", "None", "\n", ")", "\n", "if", "self", ".", "use_labels_groups", ":", "\n", "            ", "if", "labels_groups", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"Specify label groups\"", ")", "\n", "", "unique_groups", "=", "np", ".", "unique", "(", "self", ".", "labels_groups", ")", "\n", "self", ".", "n_groups", "=", "len", "(", "unique_groups", ")", "\n", "if", "not", "(", "unique_groups", "==", "np", ".", "arange", "(", "self", ".", "n_groups", ")", ")", ".", "all", "(", ")", ":", "\n", "                ", "raise", "ValueError", "(", ")", "\n", "", "self", ".", "classifier_groups", "=", "Classifier", "(", "\n", "n_latent", ",", "n_hidden", ",", "self", ".", "n_groups", ",", "n_layers", ",", "dropout_rate", "\n", ")", "\n", "self", ".", "groups_index", "=", "torch", ".", "nn", ".", "ParameterList", "(", "\n", "[", "\n", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "tensor", "(", "\n", "(", "self", ".", "labels_groups", "==", "i", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "dtype", "=", "torch", ".", "uint8", ",", "\n", ")", ",", "\n", "requires_grad", "=", "False", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_groups", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classify": [[189, 219], ["_scanvae.SCANVAE.z_encoder", "torch.log", "torch.cat", "torch.split", "tuple", "_scanvae.SCANVAE.classifier_groups", "_scanvae.SCANVAE.classifier", "torch.zeros_like", "enumerate", "_scanvae.SCANVAE.classifier", "unw_y_g.sum"], "methods", ["None"], ["", "", "@", "auto_move_data", "\n", "def", "classify", "(", "self", ",", "x", ",", "batch_index", "=", "None", ",", "cont_covs", "=", "None", ",", "cat_covs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "log_variational", ":", "\n", "            ", "x", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "\n", "", "if", "cont_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "encoder_input", "=", "torch", ".", "cat", "(", "(", "x", ",", "cont_covs", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "encoder_input", "=", "x", "\n", "", "if", "cat_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "", "qz", ",", "z", "=", "self", ".", "z_encoder", "(", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "# We classify using the inferred mean parameter of z_1 in the latent space", "\n", "z", "=", "qz", ".", "loc", "\n", "if", "self", ".", "use_labels_groups", ":", "\n", "            ", "w_g", "=", "self", ".", "classifier_groups", "(", "z", ")", "\n", "unw_y", "=", "self", ".", "classifier", "(", "z", ")", "\n", "w_y", "=", "torch", ".", "zeros_like", "(", "unw_y", ")", "\n", "for", "i", ",", "group_index", "in", "enumerate", "(", "self", ".", "groups_index", ")", ":", "\n", "                ", "unw_y_g", "=", "unw_y", "[", ":", ",", "group_index", "]", "\n", "w_y", "[", ":", ",", "group_index", "]", "=", "unw_y_g", "/", "(", "\n", "unw_y_g", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "+", "1e-8", "\n", ")", "\n", "w_y", "[", ":", ",", "group_index", "]", "*=", "w_g", "[", ":", ",", "[", "i", "]", "]", "\n", "", "", "else", ":", "\n", "            ", "w_y", "=", "self", ".", "classifier", "(", "z", ")", "\n", "", "return", "w_y", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classification_loss": [[220, 241], ["torch.nn.functional.cross_entropy", "_scanvae.SCANVAE.classify", "y.view().long", "labelled_dataset.keys", "labelled_dataset.keys", "y.view"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classify"], ["", "@", "auto_move_data", "\n", "def", "classification_loss", "(", "self", ",", "labelled_dataset", ")", ":", "\n", "        ", "x", "=", "labelled_dataset", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "labelled_dataset", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "batch_idx", "=", "labelled_dataset", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "(", "\n", "labelled_dataset", "[", "cont_key", "]", "if", "cont_key", "in", "labelled_dataset", ".", "keys", "(", ")", "else", "None", "\n", ")", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "(", "\n", "labelled_dataset", "[", "cat_key", "]", "if", "cat_key", "in", "labelled_dataset", ".", "keys", "(", ")", "else", "None", "\n", ")", "\n", "classification_loss", "=", "F", ".", "cross_entropy", "(", "\n", "self", ".", "classify", "(", "\n", "x", ",", "batch_index", "=", "batch_idx", ",", "cat_covs", "=", "cat_covs", ",", "cont_covs", "=", "cont_covs", "\n", ")", ",", "\n", "y", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", ",", "\n", ")", "\n", "return", "classification_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.loss": [[242, 340], ["_utils.broadcast_labels", "_scanvae.SCANVAE.encoder_z2_z1", "_scanvae.SCANVAE.decoder_z1_z2", "torch.zeros_like", "torch.ones_like", "torch.distributions.kl_divergence.sum", "qz1.log_prob().sum", "_scanvae.SCANVAE.classifier", "torch.distributions.kl_divergence", "torch.mean", "scvi.module.base.LossRecorder", "px.log_prob().sum", "torch.distributions.Normal().log_prob().sum", "_scanvae.SCANVAE._compute_local_library_params", "torch.distributions.kl_divergence.sum", "scvi.module.base.LossRecorder", "torch.distributions.Categorical", "torch.distributions.Categorical", "_scanvae.SCANVAE.classification_loss", "scvi.module.base.LossRecorder", "torch.distributions.kl_divergence", "qz1.log_prob", "_scanvae.SCANVAE.classification_loss", "scvi.module.base.LossRecorder", "px.log_prob", "torch.distributions.Normal", "torch.distributions.Normal().log_prob", "torch.distributions.kl_divergence", "torch.tensor", "torch.distributions.kl_divergence.sum.view().t", "_scanvae.SCANVAE.y_prior.repeat", "torch.distributions.Normal", "loss_z1_unweight.view().t", "_scanvae.SCANVAE.size", "torch.distributions.Normal", "torch.sqrt", "torch.distributions.kl_divergence.sum.view", "torch.sqrt", "loss_z1_unweight.view"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._utils.broadcast_labels", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params", "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classification_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classification_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_ouputs", ",", "\n", "feed_labels", "=", "False", ",", "\n", "kl_weight", "=", "1", ",", "\n", "labelled_tensors", "=", "None", ",", "\n", "classification_ratio", "=", "None", ",", "\n", ")", ":", "\n", "        ", "px", "=", "generative_ouputs", "[", "\"px\"", "]", "\n", "qz1", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "z1", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "if", "feed_labels", ":", "\n", "            ", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "", "else", ":", "\n", "            ", "y", "=", "None", "\n", "", "is_labelled", "=", "False", "if", "y", "is", "None", "else", "True", "\n", "\n", "# Enumerate choices of label", "\n", "ys", ",", "z1s", "=", "broadcast_labels", "(", "y", ",", "z1", ",", "n_broadcast", "=", "self", ".", "n_labels", ")", "\n", "qz2", ",", "z2", "=", "self", ".", "encoder_z2_z1", "(", "z1s", ",", "ys", ")", "\n", "pz1_m", ",", "pz1_v", "=", "self", ".", "decoder_z1_z2", "(", "z2", ",", "ys", ")", "\n", "reconst_loss", "=", "-", "px", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "# KL Divergence", "\n", "mean", "=", "torch", ".", "zeros_like", "(", "qz2", ".", "loc", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "qz2", ".", "scale", ")", "\n", "\n", "kl_divergence_z2", "=", "kl", "(", "qz2", ",", "Normal", "(", "mean", ",", "scale", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "loss_z1_unweight", "=", "-", "Normal", "(", "pz1_m", ",", "torch", ".", "sqrt", "(", "pz1_v", ")", ")", ".", "log_prob", "(", "z1s", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "loss_z1_weight", "=", "qz1", ".", "log_prob", "(", "z1", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "(", "\n", "local_library_log_means", ",", "\n", "local_library_log_vars", ",", "\n", ")", "=", "self", ".", "_compute_local_library_params", "(", "batch_index", ")", "\n", "\n", "kl_divergence_l", "=", "kl", "(", "\n", "ql", ",", "\n", "Normal", "(", "local_library_log_means", ",", "torch", ".", "sqrt", "(", "local_library_log_vars", ")", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_divergence_l", "=", "0.0", "\n", "\n", "", "if", "is_labelled", ":", "\n", "            ", "loss", "=", "reconst_loss", "+", "loss_z1_weight", "+", "loss_z1_unweight", "\n", "kl_locals", "=", "{", "\n", "\"kl_divergence_z2\"", ":", "kl_divergence_z2", ",", "\n", "\"kl_divergence_l\"", ":", "kl_divergence_l", ",", "\n", "}", "\n", "if", "labelled_tensors", "is", "not", "None", ":", "\n", "                ", "classifier_loss", "=", "self", ".", "classification_loss", "(", "labelled_tensors", ")", "\n", "loss", "+=", "classifier_loss", "*", "classification_ratio", "\n", "return", "LossRecorder", "(", "\n", "loss", ",", "\n", "reconst_loss", ",", "\n", "kl_locals", ",", "\n", "classification_loss", "=", "classifier_loss", ",", "\n", "n_labelled_tensors", "=", "labelled_tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n", "", "return", "LossRecorder", "(", "\n", "loss", ",", "\n", "reconst_loss", ",", "\n", "kl_locals", ",", "\n", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", ",", "\n", ")", "\n", "\n", "", "probs", "=", "self", ".", "classifier", "(", "z1", ")", "\n", "reconst_loss", "+=", "loss_z1_weight", "+", "(", "\n", "(", "loss_z1_unweight", ")", ".", "view", "(", "self", ".", "n_labels", ",", "-", "1", ")", ".", "t", "(", ")", "*", "probs", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "kl_divergence", "=", "(", "kl_divergence_z2", ".", "view", "(", "self", ".", "n_labels", ",", "-", "1", ")", ".", "t", "(", ")", "*", "probs", ")", ".", "sum", "(", "\n", "dim", "=", "1", "\n", ")", "\n", "kl_divergence", "+=", "kl", "(", "\n", "Categorical", "(", "probs", "=", "probs", ")", ",", "\n", "Categorical", "(", "probs", "=", "self", ".", "y_prior", ".", "repeat", "(", "probs", ".", "size", "(", "0", ")", ",", "1", ")", ")", ",", "\n", ")", "\n", "kl_divergence", "+=", "kl_divergence_l", "\n", "\n", "loss", "=", "torch", ".", "mean", "(", "reconst_loss", "+", "kl_divergence", "*", "kl_weight", ")", "\n", "\n", "if", "labelled_tensors", "is", "not", "None", ":", "\n", "            ", "classifier_loss", "=", "self", ".", "classification_loss", "(", "labelled_tensors", ")", "\n", "loss", "+=", "classifier_loss", "*", "classification_ratio", "\n", "return", "LossRecorder", "(", "\n", "loss", ",", "\n", "reconst_loss", ",", "\n", "kl_divergence", ",", "\n", "classification_loss", "=", "classifier_loss", ",", "\n", ")", "\n", "", "return", "LossRecorder", "(", "loss", ",", "reconst_loss", ",", "kl_divergence", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.__init__": [[59, 151], ["_vae.VAE.__init__", "ValueError", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "_autozivae.AutoZIVAE.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "_autozivae.AutoZIVAE.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "_autozivae.AutoZIVAE.register_buffer", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "_autozivae.AutoZIVAE.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "Exception", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "_autozivae.AutoZIVAE.register_buffer", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "torch.nn.parameter", "_autozivae.AutoZIVAE.register_buffer", "scipy.special.logit", "scipy.special.logit", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "scipy.special.logit", "scipy.special.logit", "scipy.special.logit", "scipy.special.logit"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "alpha_prior", ":", "Optional", "[", "float", "]", "=", "0.5", ",", "\n", "beta_prior", ":", "Optional", "[", "float", "]", "=", "0.5", ",", "\n", "minimal_dropout", ":", "float", "=", "0.01", ",", "\n", "zero_inflation", ":", "str", "=", "\"gene\"", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "None", ":", "\n", "        ", "if", "\"reconstruction_loss\"", "in", "kwargs", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"No reconstruction loss must be specified for AutoZI : it is 'autozinb'.\"", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "n_input", ",", "**", "kwargs", ")", "\n", "self", ".", "zero_inflation", "=", "zero_inflation", "\n", "self", ".", "reconstruction_loss", "=", "\"autozinb\"", "\n", "self", ".", "minimal_dropout", "=", "minimal_dropout", "\n", "\n", "# Parameters of prior Bernoulli Beta distribution : alpha + beta = 1 if only one is specified", "\n", "if", "beta_prior", "is", "None", "and", "alpha_prior", "is", "not", "None", ":", "\n", "            ", "beta_prior", "=", "1.0", "-", "alpha_prior", "\n", "", "if", "alpha_prior", "is", "None", "and", "beta_prior", "is", "not", "None", ":", "\n", "            ", "alpha_prior", "=", "1.0", "-", "beta_prior", "\n", "\n", "# Create parameters for Bernoulli Beta prior and posterior distributions", "\n", "# Each parameter, whose values are in (0,1), is encoded as its logit, in the set of real numbers", "\n", "\n", "", "if", "self", ".", "zero_inflation", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "alpha_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ")", ")", "\n", "self", ".", "beta_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ")", ")", "\n", "if", "alpha_prior", "is", "None", ":", "\n", "                ", "self", ".", "alpha_prior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"alpha_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "alpha_prior", ")", "]", ")", "\n", ")", "\n", "", "if", "beta_prior", "is", "None", ":", "\n", "                ", "self", ".", "beta_prior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"beta_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "alpha_prior", ")", "]", ")", "\n", ")", "\n", "\n", "", "", "elif", "self", ".", "zero_inflation", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "alpha_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input", ",", "self", ".", "n_batch", ")", "\n", ")", "\n", "self", ".", "beta_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input", ",", "self", ".", "n_batch", ")", "\n", ")", "\n", "if", "alpha_prior", "is", "None", ":", "\n", "                ", "self", ".", "alpha_prior_logit", "=", "torch", ".", "nn", ".", "parameter", "(", "\n", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_batch", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"alpha_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "alpha_prior", ")", "]", ")", "\n", ")", "\n", "", "if", "beta_prior", "is", "None", ":", "\n", "                ", "self", ".", "beta_prior_logit", "=", "torch", ".", "nn", ".", "parameter", "(", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_batch", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"beta_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "beta_prior", ")", "]", ")", "\n", ")", "\n", "\n", "", "", "elif", "self", ".", "zero_inflation", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "alpha_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input", ",", "self", ".", "n_labels", ")", "\n", ")", "\n", "self", ".", "beta_posterior_logit", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input", ",", "self", ".", "n_labels", ")", "\n", ")", "\n", "if", "alpha_prior", "is", "None", ":", "\n", "                ", "self", ".", "alpha_prior_logit", "=", "torch", ".", "nn", ".", "parameter", "(", "\n", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_labels", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"alpha_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "alpha_prior", ")", "]", ")", "\n", ")", "\n", "", "if", "beta_prior", "is", "None", ":", "\n", "                ", "self", ".", "beta_prior_logit", "=", "torch", ".", "nn", ".", "parameter", "(", "\n", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_labels", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "\"beta_prior_logit\"", ",", "torch", ".", "tensor", "(", "[", "logit", "(", "beta_prior", ")", "]", ")", "\n", ")", "\n", "\n", "", "", "else", ":", "# gene-cell", "\n", "            ", "raise", "Exception", "(", "\"Gene-cell not implemented yet for AutoZI\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.get_alphas_betas": [[152, 171], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "outputs.items", "value.detach().cpu().numpy", "value.cpu().numpy", "value.detach().cpu", "value.cpu", "value.detach"], "methods", ["None"], ["", "", "def", "get_alphas_betas", "(", "\n", "self", ",", "as_numpy", ":", "bool", "=", "True", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "# Return parameters of Bernoulli Beta distributions in a dictionary", "\n", "        ", "outputs", "=", "{", "}", "\n", "outputs", "[", "\"alpha_posterior\"", "]", "=", "torch", ".", "sigmoid", "(", "self", ".", "alpha_posterior_logit", ")", "\n", "outputs", "[", "\"beta_posterior\"", "]", "=", "torch", ".", "sigmoid", "(", "self", ".", "beta_posterior_logit", ")", "\n", "outputs", "[", "\"alpha_prior\"", "]", "=", "torch", ".", "sigmoid", "(", "self", ".", "alpha_prior_logit", ")", "\n", "outputs", "[", "\"beta_prior\"", "]", "=", "torch", ".", "sigmoid", "(", "self", ".", "beta_prior_logit", ")", "\n", "\n", "if", "as_numpy", ":", "\n", "            ", "for", "key", ",", "value", "in", "outputs", ".", "items", "(", ")", ":", "\n", "                ", "outputs", "[", "key", "]", "=", "(", "\n", "value", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "value", ".", "requires_grad", "\n", "else", "value", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", ")", "\n", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.sample_from_beta_distribution": [[172, 199], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log", "torch.log", "torch.log", "torch.log", "torch.distributions.Gamma().rsample", "torch.distributions.Gamma().rsample", "torch.distributions.Gamma().rsample", "torch.distributions.Gamma().rsample", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.distributions.Gamma", "torch.distributions.Gamma", "torch.distributions.Gamma", "torch.distributions.Gamma"], "methods", ["None"], ["", "def", "sample_from_beta_distribution", "(", "\n", "self", ",", "\n", "alpha", ":", "torch", ".", "Tensor", ",", "\n", "beta", ":", "torch", ".", "Tensor", ",", "\n", "eps_gamma", ":", "float", "=", "1e-30", ",", "\n", "eps_sample", ":", "float", "=", "1e-7", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "# Sample from a Beta distribution using the reparameterization trick.", "\n", "# Problem : it is not implemented in CUDA yet", "\n", "# Workaround : sample X and Y from Gamma(alpha,1) and Gamma(beta,1), the Beta sample is X/(X+Y)", "\n", "# Warning : use logs and perform logsumexp to avoid numerical issues", "\n", "\n", "# Sample from Gamma", "\n", "        ", "sample_x_log", "=", "torch", ".", "log", "(", "Gamma", "(", "alpha", ",", "1", ")", ".", "rsample", "(", ")", "+", "eps_gamma", ")", "\n", "sample_y_log", "=", "torch", ".", "log", "(", "Gamma", "(", "beta", ",", "1", ")", ".", "rsample", "(", ")", "+", "eps_gamma", ")", "\n", "\n", "# Sum using logsumexp (note : eps_gamma is used to prevent numerical issues with perfect", "\n", "# 0 and 1 final Beta samples", "\n", "sample_xy_log_max", "=", "torch", ".", "max", "(", "sample_x_log", ",", "sample_y_log", ")", "\n", "sample_xplusy_log", "=", "sample_xy_log_max", "+", "torch", ".", "log", "(", "\n", "torch", ".", "exp", "(", "sample_x_log", "-", "sample_xy_log_max", ")", "\n", "+", "torch", ".", "exp", "(", "sample_y_log", "-", "sample_xy_log_max", ")", "\n", ")", "\n", "sample_log", "=", "sample_x_log", "-", "sample_xplusy_log", "\n", "sample", "=", "eps_sample", "+", "(", "1", "-", "2", "*", "eps_sample", ")", "*", "torch", ".", "exp", "(", "sample_log", ")", "\n", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.reshape_bernoulli": [[200, 232], ["scvi.nn.one_hot", "len", "torch.linear", "torch.linear", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "scvi.nn.one_hot", "bernoulli_params_res.append", "len", "torch.linear", "torch.linear", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.linear", "torch.linear", "bernoulli_params_res.append", "torch.linear", "torch.linear"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "def", "reshape_bernoulli", "(", "\n", "self", ",", "\n", "bernoulli_params", ":", "torch", ".", "Tensor", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "if", "self", ".", "zero_inflation", "==", "\"gene-label\"", ":", "\n", "            ", "one_hot_label", "=", "one_hot", "(", "y", ",", "self", ".", "n_labels", ")", "\n", "# If we sampled several random Bernoulli parameters", "\n", "if", "len", "(", "bernoulli_params", ".", "shape", ")", "==", "2", ":", "\n", "                ", "bernoulli_params", "=", "F", ".", "linear", "(", "one_hot_label", ",", "bernoulli_params", ")", "\n", "", "else", ":", "\n", "                ", "bernoulli_params_res", "=", "[", "]", "\n", "for", "sample", "in", "range", "(", "bernoulli_params", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "bernoulli_params_res", ".", "append", "(", "\n", "F", ".", "linear", "(", "one_hot_label", ",", "bernoulli_params", "[", "sample", "]", ")", "\n", ")", "\n", "", "bernoulli_params", "=", "torch", ".", "stack", "(", "bernoulli_params_res", ")", "\n", "", "", "elif", "self", ".", "zero_inflation", "==", "\"gene-batch\"", ":", "\n", "            ", "one_hot_batch", "=", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", "\n", "if", "len", "(", "bernoulli_params", ".", "shape", ")", "==", "2", ":", "\n", "                ", "bernoulli_params", "=", "F", ".", "linear", "(", "one_hot_batch", ",", "bernoulli_params", ")", "\n", "# If we sampled several random Bernoulli parameters", "\n", "", "else", ":", "\n", "                ", "bernoulli_params_res", "=", "[", "]", "\n", "for", "sample", "in", "range", "(", "bernoulli_params", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "bernoulli_params_res", ".", "append", "(", "\n", "F", ".", "linear", "(", "one_hot_batch", ",", "bernoulli_params", "[", "sample", "]", ")", "\n", ")", "\n", "", "bernoulli_params", "=", "torch", ".", "stack", "(", "bernoulli_params_res", ")", "\n", "\n", "", "", "return", "bernoulli_params", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.sample_bernoulli_params": [[233, 268], ["_autozivae.AutoZIVAE.get_alphas_betas", "_autozivae.AutoZIVAE.sample_from_beta_distribution", "_autozivae.AutoZIVAE.reshape_bernoulli", "alpha_posterior.unsqueeze().expand", "alpha_posterior.unsqueeze().expand", "beta_posterior.unsqueeze().expand", "beta_posterior.unsqueeze().expand", "alpha_posterior.unsqueeze", "alpha_posterior.size", "alpha_posterior.unsqueeze", "alpha_posterior.size", "alpha_posterior.size", "beta_posterior.unsqueeze", "beta_posterior.size", "beta_posterior.unsqueeze", "beta_posterior.size", "beta_posterior.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.sample_from_beta_distribution", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.reshape_bernoulli"], ["", "def", "sample_bernoulli_params", "(", "\n", "self", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "\n", "        ", "outputs", "=", "self", ".", "get_alphas_betas", "(", "as_numpy", "=", "False", ")", "\n", "alpha_posterior", "=", "outputs", "[", "\"alpha_posterior\"", "]", "\n", "beta_posterior", "=", "outputs", "[", "\"beta_posterior\"", "]", "\n", "\n", "if", "n_samples", ">", "1", ":", "\n", "            ", "alpha_posterior", "=", "(", "\n", "alpha_posterior", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "alpha_posterior", ".", "size", "(", "0", ")", ")", "\n", ")", "\n", "if", "self", ".", "zero_inflation", "==", "\"gene\"", "\n", "else", "alpha_posterior", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "alpha_posterior", ".", "size", "(", "0", ")", ",", "alpha_posterior", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", ")", "\n", "beta_posterior", "=", "(", "\n", "beta_posterior", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "(", "n_samples", ",", "beta_posterior", ".", "size", "(", "0", ")", ")", ")", "\n", "if", "self", ".", "zero_inflation", "==", "\"gene\"", "\n", "else", "beta_posterior", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "beta_posterior", ".", "size", "(", "0", ")", ",", "beta_posterior", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", ")", "\n", "\n", "", "bernoulli_params", "=", "self", ".", "sample_from_beta_distribution", "(", "\n", "alpha_posterior", ",", "beta_posterior", "\n", ")", "\n", "bernoulli_params", "=", "self", ".", "reshape_bernoulli", "(", "bernoulli_params", ",", "batch_index", ",", "y", ")", "\n", "\n", "return", "bernoulli_params", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.rescale_dropout": [[269, 282], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "rescale_dropout", "(", "\n", "self", ",", "px_dropout", ":", "torch", ".", "Tensor", ",", "eps_log", ":", "float", "=", "1e-8", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "if", "self", ".", "minimal_dropout", ">", "0.0", ":", "\n", "            ", "dropout_prob_rescaled", "=", "self", ".", "minimal_dropout", "+", "(", "\n", "1.0", "-", "self", ".", "minimal_dropout", "\n", ")", "*", "torch", ".", "sigmoid", "(", "px_dropout", ")", "\n", "px_dropout_rescaled", "=", "torch", ".", "log", "(", "\n", "dropout_prob_rescaled", "/", "(", "1.0", "-", "dropout_prob_rescaled", "+", "eps_log", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "px_dropout_rescaled", "=", "px_dropout", "\n", "", "return", "px_dropout_rescaled", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.generative": [[283, 320], ["super().generative", "_autozivae.AutoZIVAE.rescale_dropout", "scvi.distributions.ZeroInflatedNegativeBinomial", "_autozivae.AutoZIVAE.sample_bernoulli_params"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.generative", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.rescale_dropout", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.sample_bernoulli_params"], ["", "def", "generative", "(", "\n", "self", ",", "\n", "z", ",", "\n", "library", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "size_factor", "=", "None", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "eps_log", ":", "float", "=", "1e-8", ",", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "outputs", "=", "super", "(", ")", ".", "generative", "(", "\n", "z", "=", "z", ",", "\n", "library", "=", "library", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", "y", "=", "y", ",", "\n", "size_factor", "=", "size_factor", ",", "\n", ")", "\n", "# Rescale dropout", "\n", "rescaled_dropout", "=", "self", ".", "rescale_dropout", "(", "\n", "outputs", "[", "\"px\"", "]", ".", "zi_logits", ",", "eps_log", "=", "eps_log", "\n", ")", "\n", "outputs", "[", "\"px\"", "]", "=", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "outputs", "[", "\"px\"", "]", ".", "mu", ",", "\n", "theta", "=", "outputs", "[", "\"px\"", "]", ".", "theta", ",", "\n", "zi_logits", "=", "rescaled_dropout", ",", "\n", "scale", "=", "outputs", "[", "\"px\"", "]", ".", "scale", ",", "\n", ")", "\n", "\n", "# Bernoulli parameters", "\n", "outputs", "[", "\"bernoulli_params\"", "]", "=", "self", ".", "sample_bernoulli_params", "(", "\n", "batch_index", ",", "y", ",", "n_samples", "=", "n_samples", "\n", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.compute_global_kl_divergence": [[321, 330], ["_autozivae.AutoZIVAE.get_alphas_betas", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.Beta", "torch.distributions.Beta", "torch.distributions.Beta", "torch.distributions.Beta"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas"], ["", "def", "compute_global_kl_divergence", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "outputs", "=", "self", ".", "get_alphas_betas", "(", "as_numpy", "=", "False", ")", "\n", "alpha_posterior", "=", "outputs", "[", "\"alpha_posterior\"", "]", "\n", "beta_posterior", "=", "outputs", "[", "\"beta_posterior\"", "]", "\n", "alpha_prior", "=", "outputs", "[", "\"alpha_prior\"", "]", "\n", "beta_prior", "=", "outputs", "[", "\"beta_prior\"", "]", "\n", "\n", "return", "kl", "(", "\n", "Beta", "(", "alpha_posterior", ",", "beta_posterior", ")", ",", "Beta", "(", "alpha_prior", ",", "beta_prior", ")", "\n", ")", ".", "sum", "(", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.get_reconstruction_loss": [[332, 363], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.log", "torch.log", "torch.log", "torch.log", "scvi.distributions.ZeroInflatedNegativeBinomial().log_prob", "torch.log", "torch.log", "torch.log", "torch.log", "scvi.distributions.NegativeBinomial().log_prob", "torch.log", "torch.log", "torch.log", "torch.log", "ll_tot.sum", "scvi.distributions.ZeroInflatedNegativeBinomial", "scvi.distributions.NegativeBinomial", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "get_reconstruction_loss", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "px_rate", ":", "torch", ".", "Tensor", ",", "\n", "px_r", ":", "torch", ".", "Tensor", ",", "\n", "px_dropout", ":", "torch", ".", "Tensor", ",", "\n", "bernoulli_params", ":", "torch", ".", "Tensor", ",", "\n", "eps_log", ":", "float", "=", "1e-8", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "\n", "# LLs for NB and ZINB", "\n", "        ", "ll_zinb", "=", "torch", ".", "log", "(", "\n", "1.0", "-", "bernoulli_params", "+", "eps_log", "\n", ")", "+", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ",", "zi_logits", "=", "px_dropout", "\n", ")", ".", "log_prob", "(", "\n", "x", "\n", ")", "\n", "ll_nb", "=", "torch", ".", "log", "(", "bernoulli_params", "+", "eps_log", ")", "+", "NegativeBinomial", "(", "\n", "mu", "=", "px_rate", ",", "theta", "=", "px_r", "\n", ")", ".", "log_prob", "(", "x", ")", "\n", "\n", "# Reconstruction loss using a logsumexp-type computation", "\n", "ll_max", "=", "torch", ".", "max", "(", "ll_zinb", ",", "ll_nb", ")", "\n", "ll_tot", "=", "ll_max", "+", "torch", ".", "log", "(", "\n", "torch", ".", "exp", "(", "ll_nb", "-", "ll_max", ")", "+", "torch", ".", "exp", "(", "ll_zinb", "-", "ll_max", ")", "\n", ")", "\n", "reconst_loss", "=", "-", "ll_tot", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "return", "reconst_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.loss": [[364, 420], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "_autozivae.AutoZIVAE.compute_global_kl_divergence", "_autozivae.AutoZIVAE.get_reconstruction_loss", "dict", "scvi.module.base.LossRecorder", "_autozivae.AutoZIVAE._compute_local_library_params", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.Normal", "torch.distributions.Normal", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.compute_global_kl_divergence", "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_reconstruction_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "auto_move_data", "\n", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "kl_weight", ":", "int", "=", "1.0", ",", "\n", "n_obs", ":", "int", "=", "1.0", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "# Parameters for z latent distribution", "\n", "        ", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "px", "=", "generative_outputs", "[", "\"px\"", "]", "\n", "px_rate", "=", "px", ".", "mu", "\n", "px_r", "=", "px", ".", "theta", "\n", "px_dropout", "=", "px", ".", "zi_logits", "\n", "bernoulli_params", "=", "generative_outputs", "[", "\"bernoulli_params\"", "]", "\n", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "# KL divergences wrt z_n,l_n", "\n", "mean", "=", "torch", ".", "zeros_like", "(", "qz", ".", "loc", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "qz", ".", "scale", ")", "\n", "\n", "kl_divergence_z", "=", "kl", "(", "qz", ",", "Normal", "(", "mean", ",", "scale", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "\n", "(", "\n", "local_library_log_means", ",", "\n", "local_library_log_vars", ",", "\n", ")", "=", "self", ".", "_compute_local_library_params", "(", "batch_index", ")", "\n", "\n", "kl_divergence_l", "=", "kl", "(", "\n", "ql", ",", "\n", "Normal", "(", "local_library_log_means", ",", "torch", ".", "sqrt", "(", "local_library_log_vars", ")", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_divergence_l", "=", "0.0", "\n", "\n", "# KL divergence wrt Bernoulli parameters", "\n", "", "kl_divergence_bernoulli", "=", "self", ".", "compute_global_kl_divergence", "(", ")", "\n", "\n", "# Reconstruction loss", "\n", "reconst_loss", "=", "self", ".", "get_reconstruction_loss", "(", "\n", "x", ",", "px_rate", ",", "px_r", ",", "px_dropout", ",", "bernoulli_params", "\n", ")", "\n", "\n", "kl_global", "=", "kl_divergence_bernoulli", "\n", "kl_local_for_warmup", "=", "kl_divergence_z", "\n", "kl_local_no_warmup", "=", "kl_divergence_l", "\n", "\n", "weighted_kl_local", "=", "kl_weight", "*", "kl_local_for_warmup", "+", "kl_local_no_warmup", "\n", "loss", "=", "n_obs", "*", "torch", ".", "mean", "(", "reconst_loss", "+", "weighted_kl_local", ")", "+", "kl_global", "\n", "kl_local", "=", "dict", "(", "\n", "kl_divergence_l", "=", "kl_divergence_l", ",", "kl_divergence_z", "=", "kl_divergence_z", "\n", ")", "\n", "return", "LossRecorder", "(", "loss", ",", "reconst_loss", ",", "kl_local", ",", "kl_global", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._classifier.Classifier.__init__": [[32, 63], ["torch.nn.Module.__init__", "torch.nn.Sequential", "scvi.nn.FCLayers", "torch.nn.Linear", "layers.append", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_labels", ":", "int", "=", "5", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "logits", ":", "bool", "=", "False", ",", "\n", "use_batch_norm", ":", "bool", "=", "True", ",", "\n", "use_layer_norm", ":", "bool", "=", "False", ",", "\n", "activation_fn", ":", "nn", ".", "Module", "=", "nn", ".", "ReLU", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "logits", "=", "logits", "\n", "layers", "=", "[", "\n", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "activation_fn", "=", "activation_fn", ",", "\n", ")", ",", "\n", "nn", ".", "Linear", "(", "n_hidden", ",", "n_labels", ")", ",", "\n", "]", "\n", "if", "not", "logits", ":", "\n", "            ", "layers", ".", "append", "(", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", ")", "\n", "\n", "", "self", ".", "classifier", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._classifier.Classifier.forward": [[64, 66], ["_classifier.Classifier.classifier"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "classifier", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.__init__": [[91, 208], ["scvi.module.base.BaseModuleClass.__init__", "scvi.nn.Encoder", "scvi.nn.Encoder", "scvi.nn.DecoderSCVI", "_vae.VAE.register_buffer", "_vae.VAE.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "list", "ValueError", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "n_continuous_cov", ":", "int", "=", "0", ",", "\n", "n_cats_per_cov", ":", "Optional", "[", "Iterable", "[", "int", "]", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "str", "=", "\"gene\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "latent_distribution", ":", "str", "=", "\"normal\"", ",", "\n", "encode_covariates", ":", "bool", "=", "False", ",", "\n", "deeply_inject_covariates", ":", "bool", "=", "True", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "use_size_factor_key", ":", "bool", "=", "False", ",", "\n", "use_observed_lib_size", ":", "bool", "=", "True", ",", "\n", "library_log_means", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "library_log_vars", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "var_activation", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dispersion", "=", "dispersion", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "log_variational", "=", "log_variational", "\n", "self", ".", "gene_likelihood", "=", "gene_likelihood", "\n", "# Automatically deactivate if useless", "\n", "self", ".", "n_batch", "=", "n_batch", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "self", ".", "latent_distribution", "=", "latent_distribution", "\n", "self", ".", "encode_covariates", "=", "encode_covariates", "\n", "\n", "self", ".", "use_size_factor_key", "=", "use_size_factor_key", "\n", "self", ".", "use_observed_lib_size", "=", "use_size_factor_key", "or", "use_observed_lib_size", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "if", "library_log_means", "is", "None", "or", "library_log_means", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"If not using observed_lib_size, \"", "\n", "\"must provide library_log_means and library_log_vars.\"", "\n", ")", "\n", "\n", "", "self", ".", "register_buffer", "(", "\n", "\"library_log_means\"", ",", "torch", ".", "from_numpy", "(", "library_log_means", ")", ".", "float", "(", ")", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"library_log_vars\"", ",", "torch", ".", "from_numpy", "(", "library_log_vars", ")", ".", "float", "(", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ",", "n_batch", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ",", "n_labels", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-cell\"", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"dispersion must be one of ['gene', 'gene-batch',\"", "\n", "\" 'gene-label', 'gene-cell'], but input was \"", "\n", "\"{}.format(self.dispersion)\"", "\n", ")", "\n", "\n", "", "use_batch_norm_encoder", "=", "use_batch_norm", "==", "\"encoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_batch_norm_decoder", "=", "use_batch_norm", "==", "\"decoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_layer_norm_encoder", "=", "use_layer_norm", "==", "\"encoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "use_layer_norm_decoder", "=", "use_layer_norm", "==", "\"decoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "\n", "# z encoder goes from the n_input-dimensional data to an n_latent-d", "\n", "# latent space representation", "\n", "n_input_encoder", "=", "n_input", "+", "n_continuous_cov", "*", "encode_covariates", "\n", "cat_list", "=", "[", "n_batch", "]", "+", "list", "(", "[", "]", "if", "n_cats_per_cov", "is", "None", "else", "n_cats_per_cov", ")", "\n", "encoder_cat_list", "=", "cat_list", "if", "encode_covariates", "else", "None", "\n", "self", ".", "z_encoder", "=", "Encoder", "(", "\n", "n_input_encoder", ",", "\n", "n_latent", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "distribution", "=", "latent_distribution", ",", "\n", "inject_covariates", "=", "deeply_inject_covariates", ",", "\n", "use_batch_norm", "=", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_encoder", ",", "\n", "var_activation", "=", "var_activation", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "# l encoder goes from n_input-dimensional data to 1-d library size", "\n", "self", ".", "l_encoder", "=", "Encoder", "(", "\n", "n_input_encoder", ",", "\n", "1", ",", "\n", "n_layers", "=", "1", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "inject_covariates", "=", "deeply_inject_covariates", ",", "\n", "use_batch_norm", "=", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_encoder", ",", "\n", "var_activation", "=", "var_activation", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "# decoder goes from n_latent-dimensional space to n_input-d data", "\n", "n_input_decoder", "=", "n_latent", "+", "n_continuous_cov", "\n", "self", ".", "decoder", "=", "DecoderSCVI", "(", "\n", "n_input_decoder", ",", "\n", "n_input", ",", "\n", "n_cat_list", "=", "cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "inject_covariates", "=", "deeply_inject_covariates", ",", "\n", "use_batch_norm", "=", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_decoder", ",", "\n", "scale_activation", "=", "\"softplus\"", "if", "use_size_factor_key", "else", "\"softmax\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._get_inference_input": [[210, 224], ["dict", "tensors.keys", "tensors.keys"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "batch_index", "=", "batch_index", ",", "cont_covs", "=", "cont_covs", ",", "cat_covs", "=", "cat_covs", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._get_generative_input": [[225, 254], ["dict", "torch.log", "torch.log", "torch.log", "torch.log", "tensors.keys", "tensors.keys", "tensors.keys"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "library", "=", "inference_outputs", "[", "\"library\"", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "size_factor_key", "=", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "\n", "size_factor", "=", "(", "\n", "torch", ".", "log", "(", "tensors", "[", "size_factor_key", "]", ")", "\n", "if", "size_factor_key", "in", "tensors", ".", "keys", "(", ")", "\n", "else", "None", "\n", ")", "\n", "\n", "input_dict", "=", "dict", "(", "\n", "z", "=", "z", ",", "\n", "library", "=", "library", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "y", "=", "y", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", "size_factor", "=", "size_factor", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params": [[255, 271], ["torch.linear", "torch.linear", "torch.linear", "torch.linear", "scvi.nn.one_hot", "scvi.nn.one_hot"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "def", "_compute_local_library_params", "(", "self", ",", "batch_index", ")", ":", "\n", "        ", "\"\"\"\n        Computes local library parameters.\n\n        Compute two tensors of shape (batch_index.shape[0], 1) where each\n        element corresponds to the mean and variances, respectively, of the\n        log library sizes in the batch the cell corresponds to.\n        \"\"\"", "\n", "n_batch", "=", "self", ".", "library_log_means", ".", "shape", "[", "1", "]", "\n", "local_library_log_means", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_means", "\n", ")", "\n", "local_library_log_vars", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_vars", "\n", ")", "\n", "return", "local_library_log_means", ",", "local_library_log_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.inference": [[272, 312], ["_vae.VAE.z_encoder", "dict", "torch.log().unsqueeze", "torch.log().unsqueeze", "torch.log().unsqueeze", "torch.log().unsqueeze", "torch.log", "torch.log", "torch.log", "torch.log", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.split", "torch.split", "torch.split", "torch.split", "tuple", "_vae.VAE.l_encoder", "qz.sample", "_vae.VAE.z_encoder.z_transformation", "ql.sample.unsqueeze().expand", "ql.sample", "torch.log", "torch.log", "torch.log", "torch.log", "x.sum", "ql.sample.unsqueeze", "ql.sample.size", "ql.sample.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "self", ",", "x", ",", "batch_index", ",", "cont_covs", "=", "None", ",", "cat_covs", "=", "None", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        High level inference method.\n\n        Runs the inference (encoder) model.\n        \"\"\"", "\n", "x_", "=", "x", "\n", "if", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "library", "=", "torch", ".", "log", "(", "x", ".", "sum", "(", "1", ")", ")", ".", "unsqueeze", "(", "1", ")", "\n", "", "if", "self", ".", "log_variational", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x_", ")", "\n", "\n", "", "if", "cont_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "encoder_input", "=", "torch", ".", "cat", "(", "(", "x_", ",", "cont_covs", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "encoder_input", "=", "x_", "\n", "", "if", "cat_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "", "qz", ",", "z", "=", "self", ".", "z_encoder", "(", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "ql", "=", "None", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "ql", ",", "library_encoded", "=", "self", ".", "l_encoder", "(", "\n", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "library", "=", "library_encoded", "\n", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "            ", "untran_z", "=", "qz", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z", "=", "self", ".", "z_encoder", ".", "z_transformation", "(", "untran_z", ")", "\n", "if", "self", ".", "use_observed_lib_size", ":", "\n", "                ", "library", "=", "library", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "library", ".", "size", "(", "0", ")", ",", "library", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "library", "=", "ql", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "", "", "outputs", "=", "dict", "(", "z", "=", "z", ",", "qz", "=", "qz", ",", "ql", "=", "ql", ",", "library", "=", "library", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.generative": [[313, 393], ["_vae.VAE.decoder", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.distributions.Normal", "torch.distributions.Normal", "dict", "torch.split", "torch.split", "torch.split", "torch.split", "tuple", "torch.linear", "torch.linear", "scvi.distributions.ZeroInflatedNegativeBinomial", "_vae.VAE._compute_local_library_params", "torch.distributions.Normal", "torch.distributions.Normal", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "z.dim", "cont_covs.dim", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.distributions.NegativeBinomial", "local_library_log_vars.sqrt", "scvi.nn.one_hot", "scvi.distributions.Poisson", "cont_covs.unsqueeze().expand", "z.size", "cont_covs.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "\n", "self", ",", "\n", "z", ",", "\n", "library", ",", "\n", "batch_index", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", "size_factor", "=", "None", ",", "\n", "y", "=", "None", ",", "\n", "transform_batch", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Runs the generative model.\"\"\"", "\n", "# TODO: refactor forward function to not rely on y", "\n", "# Likelihood distribution", "\n", "if", "cont_covs", "is", "None", ":", "\n", "            ", "decoder_input", "=", "z", "\n", "", "elif", "z", ".", "dim", "(", ")", "!=", "cont_covs", ".", "dim", "(", ")", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "\n", "[", "z", ",", "cont_covs", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "z", ".", "size", "(", "0", ")", ",", "-", "1", ",", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "[", "z", ",", "cont_covs", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "if", "cat_covs", "is", "not", "None", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "", "if", "transform_batch", "is", "not", "None", ":", "\n", "            ", "batch_index", "=", "torch", ".", "ones_like", "(", "batch_index", ")", "*", "transform_batch", "\n", "\n", "", "if", "not", "self", ".", "use_size_factor_key", ":", "\n", "            ", "size_factor", "=", "library", "\n", "\n", "", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "=", "self", ".", "decoder", "(", "\n", "self", ".", "dispersion", ",", "\n", "decoder_input", ",", "\n", "size_factor", ",", "\n", "batch_index", ",", "\n", "*", "categorical_input", ",", "\n", "y", ",", "\n", ")", "\n", "if", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "y", ",", "self", ".", "n_labels", ")", ",", "self", ".", "px_r", "\n", ")", "# px_r gets transposed - last dimension is nb genes", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "px_r", "=", "self", ".", "px_r", "\n", "\n", "", "px_r", "=", "torch", ".", "exp", "(", "px_r", ")", "\n", "\n", "if", "self", ".", "gene_likelihood", "==", "\"zinb\"", ":", "\n", "            ", "px", "=", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "px_rate", ",", "\n", "theta", "=", "px_r", ",", "\n", "zi_logits", "=", "px_dropout", ",", "\n", "scale", "=", "px_scale", ",", "\n", ")", "\n", "", "elif", "self", ".", "gene_likelihood", "==", "\"nb\"", ":", "\n", "            ", "px", "=", "NegativeBinomial", "(", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ",", "scale", "=", "px_scale", ")", "\n", "", "elif", "self", ".", "gene_likelihood", "==", "\"poisson\"", ":", "\n", "            ", "px", "=", "Poisson", "(", "px_rate", ",", "scale", "=", "px_scale", ")", "\n", "\n", "# Priors", "\n", "", "if", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "pl", "=", "None", "\n", "", "else", ":", "\n", "            ", "(", "\n", "local_library_log_means", ",", "\n", "local_library_log_vars", ",", "\n", ")", "=", "self", ".", "_compute_local_library_params", "(", "batch_index", ")", "\n", "pl", "=", "Normal", "(", "local_library_log_means", ",", "local_library_log_vars", ".", "sqrt", "(", ")", ")", "\n", "", "pz", "=", "Normal", "(", "torch", ".", "zeros_like", "(", "z", ")", ",", "torch", ".", "ones_like", "(", "z", ")", ")", "\n", "return", "dict", "(", "\n", "px", "=", "px", ",", "\n", "pl", "=", "pl", ",", "\n", "pz", "=", "pz", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.loss": [[395, 428], ["torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "dict", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "scvi.module.base.LossRecorder", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "generative_outputs[].log_prob().sum", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "generative_outputs[].log_prob"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "kl_divergence_z", "=", "kl", "(", "inference_outputs", "[", "\"qz\"", "]", ",", "generative_outputs", "[", "\"pz\"", "]", ")", ".", "sum", "(", "\n", "dim", "=", "1", "\n", ")", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "kl_divergence_l", "=", "kl", "(", "\n", "inference_outputs", "[", "\"ql\"", "]", ",", "\n", "generative_outputs", "[", "\"pl\"", "]", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_divergence_l", "=", "0.0", "\n", "\n", "", "reconst_loss", "=", "-", "generative_outputs", "[", "\"px\"", "]", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "kl_local_for_warmup", "=", "kl_divergence_z", "\n", "kl_local_no_warmup", "=", "kl_divergence_l", "\n", "\n", "weighted_kl_local", "=", "kl_weight", "*", "kl_local_for_warmup", "+", "kl_local_no_warmup", "\n", "\n", "loss", "=", "torch", ".", "mean", "(", "reconst_loss", "+", "weighted_kl_local", ")", "\n", "\n", "kl_local", "=", "dict", "(", "\n", "kl_divergence_l", "=", "kl_divergence_l", ",", "kl_divergence_z", "=", "kl_divergence_z", "\n", ")", "\n", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "return", "LossRecorder", "(", "loss", ",", "reconst_loss", ",", "kl_local", ",", "kl_global", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.sample": [[429, 477], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "dict", "_vae.VAE.forward", "torch.distributions.Poisson.sample.cpu", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.distributions.Poisson", "torch.distributions.Poisson", "torch.distributions.Poisson", "torch.distributions.Poisson", "torch.distributions.Poisson.sample().permute", "torch.distributions.Poisson.sample().permute", "torch.distributions.Poisson.sample", "torch.distributions.Poisson.sample", "torch.distributions.Poisson.sample", "torch.distributions.Poisson.sample"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "n_samples", "=", "1", ",", "\n", "library_size", "=", "1", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Generate observation samples from the posterior predictive distribution.\n\n        The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n        Parameters\n        ----------\n        tensors\n            Tensors dict\n        n_samples\n            Number of required samples for each cell\n        library_size\n            Library size to scale scamples to\n\n        Returns\n        -------\n        x_new : :py:class:`torch.Tensor`\n            tensor with shape (n_cells, n_genes, n_samples)\n        \"\"\"", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", ",", "=", "self", ".", "forward", "(", "\n", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "\n", "dist", "=", "generative_outputs", "[", "\"px\"", "]", "\n", "if", "self", ".", "gene_likelihood", "==", "\"poisson\"", ":", "\n", "            ", "l_train", "=", "generative_outputs", "[", "\"px\"", "]", ".", "mu", "\n", "l_train", "=", "torch", ".", "clamp", "(", "l_train", ",", "max", "=", "1e8", ")", "\n", "dist", "=", "torch", ".", "distributions", ".", "Poisson", "(", "\n", "l_train", "\n", ")", "# Shape : (n_samples, n_cells_batch, n_genes)", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "            ", "exprs", "=", "dist", ".", "sample", "(", ")", ".", "permute", "(", "\n", "[", "1", ",", "2", ",", "0", "]", "\n", ")", "# Shape : (n_cells_batch, n_genes, n_samples)", "\n", "", "else", ":", "\n", "            ", "exprs", "=", "dist", ".", "sample", "(", ")", "\n", "\n", "", "return", "exprs", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE.marginal_ll": [[478, 527], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "_vae.VAE.forward", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "qz.log_prob().sum", "torch.logsumexp", "torch.logsumexp", "numpy.log", "sample_batch.size", "_vae.VAE._compute_local_library_params", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "ql.log_prob().sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "qz.log_prob", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "ql.log_prob", "torch.distributions.Normal", "torch.distributions.Normal", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.distributions.Normal", "torch.distributions.Normal", "local_library_log_vars.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "@", "auto_move_data", "\n", "def", "marginal_ll", "(", "self", ",", "tensors", ",", "n_mc_samples", ")", ":", "\n", "        ", "sample_batch", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "to_sum", "=", "torch", ".", "zeros", "(", "sample_batch", ".", "size", "(", ")", "[", "0", "]", ",", "n_mc_samples", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_mc_samples", ")", ":", "\n", "# Distribution parameters and sampled variables", "\n", "            ", "inference_outputs", ",", "_", ",", "losses", "=", "self", ".", "forward", "(", "tensors", ")", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "library", "=", "inference_outputs", "[", "\"library\"", "]", "\n", "\n", "# Reconstruction Loss", "\n", "reconst_loss", "=", "losses", ".", "reconstruction_loss", "\n", "\n", "# Log-probabilities", "\n", "p_z", "=", "(", "\n", "Normal", "(", "torch", ".", "zeros_like", "(", "qz", ".", "loc", ")", ",", "torch", ".", "ones_like", "(", "qz", ".", "scale", ")", ")", "\n", ".", "log_prob", "(", "z", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "p_x_zl", "=", "-", "reconst_loss", "\n", "q_z_x", "=", "qz", ".", "log_prob", "(", "z", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "log_prob_sum", "=", "p_z", "+", "p_x_zl", "-", "q_z_x", "\n", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "                ", "(", "\n", "local_library_log_means", ",", "\n", "local_library_log_vars", ",", "\n", ")", "=", "self", ".", "_compute_local_library_params", "(", "batch_index", ")", "\n", "\n", "p_l", "=", "(", "\n", "Normal", "(", "local_library_log_means", ",", "local_library_log_vars", ".", "sqrt", "(", ")", ")", "\n", ".", "log_prob", "(", "library", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "q_l_x", "=", "ql", ".", "log_prob", "(", "library", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "log_prob_sum", "+=", "p_l", "-", "q_l_x", "\n", "\n", "", "to_sum", "[", ":", ",", "i", "]", "=", "log_prob_sum", "\n", "\n", "", "batch_log_lkl", "=", "logsumexp", "(", "to_sum", ",", "dim", "=", "-", "1", ")", "-", "np", ".", "log", "(", "n_mc_samples", ")", "\n", "log_lkl", "=", "torch", ".", "sum", "(", "batch_log_lkl", ")", ".", "item", "(", ")", "\n", "return", "log_lkl", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.LDVAE.__init__": [[581, 642], ["_vae.VAE.__init__", "scvi.nn.Encoder", "scvi.nn.Encoder", "scvi.nn.LinearDecoderSCVI"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers_encoder", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "str", "=", "\"gene\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", "gene_likelihood", ":", "str", "=", "\"nb\"", ",", "\n", "use_batch_norm", ":", "bool", "=", "True", ",", "\n", "bias", ":", "bool", "=", "False", ",", "\n", "latent_distribution", ":", "str", "=", "\"normal\"", ",", "\n", "**", "vae_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "n_input", "=", "n_input", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_labels", "=", "n_labels", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers_encoder", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "log_variational", "=", "log_variational", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "use_observed_lib_size", "=", "False", ",", "\n", "**", "vae_kwargs", ",", "\n", ")", "\n", "self", ".", "use_batch_norm", "=", "use_batch_norm", "\n", "self", ".", "z_encoder", "=", "Encoder", "(", "\n", "n_input", ",", "\n", "n_latent", ",", "\n", "n_layers", "=", "n_layers_encoder", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "distribution", "=", "latent_distribution", ",", "\n", "use_batch_norm", "=", "True", ",", "\n", "use_layer_norm", "=", "False", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "self", ".", "l_encoder", "=", "Encoder", "(", "\n", "n_input", ",", "\n", "1", ",", "\n", "n_layers", "=", "1", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "use_batch_norm", "=", "True", ",", "\n", "use_layer_norm", "=", "False", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "LinearDecoderSCVI", "(", "\n", "n_latent", ",", "\n", "n_input", ",", "\n", "n_cat_list", "=", "[", "n_batch", "]", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "False", ",", "\n", "bias", "=", "bias", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.LDVAE.get_loadings": [[644, 663], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.matmul.detach().cpu().numpy", "torch.matmul.detach().cpu().numpy", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul.detach().cpu", "torch.matmul.detach().cpu", "torch.matmul.detach", "torch.matmul.detach"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_loadings", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Extract per-gene weights (for each Z, shape is genes by dim(Z)) in the linear decoder.\"\"\"", "\n", "# This is BW, where B is diag(b) batch norm, W is weight matrix", "\n", "if", "self", ".", "use_batch_norm", "is", "True", ":", "\n", "            ", "w", "=", "self", ".", "decoder", ".", "factor_regressor", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", "\n", "bn", "=", "self", ".", "decoder", ".", "factor_regressor", ".", "fc_layers", "[", "0", "]", "[", "1", "]", "\n", "sigma", "=", "torch", ".", "sqrt", "(", "bn", ".", "running_var", "+", "bn", ".", "eps", ")", "\n", "gamma", "=", "bn", ".", "weight", "\n", "b", "=", "gamma", "/", "sigma", "\n", "b_identity", "=", "torch", ".", "diag", "(", "b", ")", "\n", "loadings", "=", "torch", ".", "matmul", "(", "b_identity", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "loadings", "=", "self", ".", "decoder", ".", "factor_regressor", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", "\n", "", "loadings", "=", "loadings", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "self", ".", "n_batch", ">", "1", ":", "\n", "            ", "loadings", "=", "loadings", "[", ":", ",", ":", "-", "self", ".", "n_batch", "]", "\n", "\n", "", "return", "loadings", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC.__init__": [[40, 103], ["scvi.module.base.BaseModuleClass.__init__", "torch.nn.Parameter", "scvi.nn.Encoder", "scvi.nn.FCLayers", "torch.nn.Sequential", "_vaec.VAEC.register_buffer", "torch.randn", "torch.nn.Linear", "torch.nn.Softplus", "torch.tensor", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "5", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", "ct_weight", ":", "np", ".", "ndarray", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.05", ",", "\n", "**", "module_kwargs", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dispersion", "=", "\"gene\"", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "log_variational", "=", "log_variational", "\n", "self", ".", "gene_likelihood", "=", "\"nb\"", "\n", "self", ".", "latent_distribution", "=", "\"normal\"", "\n", "# Automatically deactivate if useless", "\n", "self", ".", "n_batch", "=", "0", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "\n", "# gene dispersion", "\n", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input", ")", ")", "\n", "\n", "# z encoder goes from the n_input-dimensional data to an n_latent-d", "\n", "self", ".", "z_encoder", "=", "Encoder", "(", "\n", "n_input", ",", "\n", "n_latent", ",", "\n", "n_cat_list", "=", "[", "n_labels", "]", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "inject_covariates", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", "use_layer_norm", "=", "True", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "# decoder goes from n_latent-dimensional space to n_input-d data", "\n", "self", ".", "decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_latent", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "[", "n_labels", "]", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "inject_covariates", "=", "True", ",", "\n", "use_batch_norm", "=", "False", ",", "\n", "use_layer_norm", "=", "True", ",", "\n", ")", "\n", "self", ".", "px_decoder", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "n_input", ")", ",", "torch", ".", "nn", ".", "Softplus", "(", ")", "\n", ")", "\n", "\n", "if", "ct_weight", "is", "not", "None", ":", "\n", "            ", "ct_weight", "=", "torch", ".", "tensor", "(", "ct_weight", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "ct_weight", "=", "torch", ".", "ones", "(", "(", "self", ".", "n_labels", ",", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "self", ".", "register_buffer", "(", "\"ct_weight\"", ",", "ct_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC._get_inference_input": [[104, 113], ["dict"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "\n", "y", "=", "y", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC._get_generative_input": [[114, 125], ["None"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "library", "=", "inference_outputs", "[", "\"library\"", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "\n", "input_dict", "=", "{", "\n", "\"z\"", ":", "z", ",", "\n", "\"library\"", ":", "library", ",", "\n", "\"y\"", ":", "y", ",", "\n", "}", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC.inference": [[126, 149], ["x.sum().unsqueeze", "_vaec.VAEC.z_encoder", "dict", "torch.log", "qz.sample", "_vaec.VAEC.z_encoder.z_transformation", "library.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "x.sum", "library.unsqueeze().expand.unsqueeze().expand.unsqueeze", "library.unsqueeze().expand.unsqueeze().expand.size", "library.unsqueeze().expand.unsqueeze().expand.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "self", ",", "x", ",", "y", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        High level inference method.\n\n        Runs the inference (encoder) model.\n        \"\"\"", "\n", "x_", "=", "x", "\n", "library", "=", "x", ".", "sum", "(", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "if", "self", ".", "log_variational", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x_", ")", "\n", "\n", "", "qz", ",", "z", "=", "self", ".", "z_encoder", "(", "x_", ",", "y", ")", "\n", "\n", "if", "n_samples", ">", "1", ":", "\n", "            ", "untran_z", "=", "qz", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z", "=", "self", ".", "z_encoder", ".", "z_transformation", "(", "untran_z", ")", "\n", "library", "=", "library", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "library", ".", "size", "(", "0", ")", ",", "library", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "\n", "", "outputs", "=", "dict", "(", "z", "=", "z", ",", "qz", "=", "qz", ",", "library", "=", "library", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC.generative": [[150, 158], ["_vaec.VAEC.decoder", "_vaec.VAEC.px_decoder", "scvi.distributions.NegativeBinomial", "dict"], "methods", ["None"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "self", ",", "z", ",", "library", ",", "y", ")", ":", "\n", "        ", "\"\"\"Runs the generative model.\"\"\"", "\n", "h", "=", "self", ".", "decoder", "(", "z", ",", "y", ")", "\n", "px_scale", "=", "self", ".", "px_decoder", "(", "h", ")", "\n", "px_rate", "=", "library", "*", "px_scale", "\n", "px", "=", "NegativeBinomial", "(", "px_rate", ",", "logits", "=", "self", ".", "px_r", ")", "\n", "return", "dict", "(", "px", "=", "px", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC.loss": [[159, 181], ["torch.zeros_like", "torch.ones_like", "torch.distributions.kl_divergence.sum", "torch.mean", "scvi.module.base.LossRecorder", "px.log_prob().sum", "torch.tensor", "torch.distributions.kl_divergence", "torch.distributions.Normal", "px.log_prob", "y.long"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "px", "=", "generative_outputs", "[", "\"px\"", "]", "\n", "\n", "mean", "=", "torch", ".", "zeros_like", "(", "qz", ".", "loc", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "qz", ".", "scale", ")", "\n", "\n", "kl_divergence_z", "=", "kl", "(", "qz", ",", "Normal", "(", "mean", ",", "scale", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "reconst_loss", "=", "-", "px", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "-", "1", ")", "\n", "scaling_factor", "=", "self", ".", "ct_weight", "[", "y", ".", "long", "(", ")", "[", ":", ",", "0", "]", "]", "\n", "loss", "=", "torch", ".", "mean", "(", "scaling_factor", "*", "(", "reconst_loss", "+", "kl_weight", "*", "kl_divergence_z", ")", ")", "\n", "\n", "return", "LossRecorder", "(", "loss", ",", "reconst_loss", ",", "kl_divergence_z", ",", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._vaec.VAEC.sample": [[182, 224], ["torch.no_grad", "dict", "scvi.distributions.NegativeBinomial", "scvi.distributions.NegativeBinomial.sample.cpu", "_vaec.VAEC.forward", "scvi.distributions.NegativeBinomial.sample().permute", "scvi.distributions.NegativeBinomial.sample", "scvi.distributions.NegativeBinomial.sample"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "n_samples", "=", "1", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Generate observation samples from the posterior predictive distribution.\n\n        The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n        Parameters\n        ----------\n        tensors\n            Tensors dict\n        n_samples\n            Number of required samples for each cell\n\n        Returns\n        -------\n        x_new : :py:class:`torch.Tensor`\n            tensor with shape (n_cells, n_genes, n_samples)\n        \"\"\"", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "generative_outputs", "=", "self", ".", "forward", "(", "\n", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "[", "1", "]", "\n", "\n", "px_r", "=", "generative_outputs", "[", "\"px_r\"", "]", "\n", "px_rate", "=", "generative_outputs", "[", "\"px_rate\"", "]", "\n", "\n", "dist", "=", "NegativeBinomial", "(", "px_rate", ",", "logits", "=", "px_r", ")", "\n", "if", "n_samples", ">", "1", ":", "\n", "            ", "exprs", "=", "dist", ".", "sample", "(", ")", ".", "permute", "(", "\n", "[", "1", ",", "2", ",", "0", "]", "\n", ")", "# Shape : (n_cells_batch, n_genes, n_samples)", "\n", "", "else", ":", "\n", "            ", "exprs", "=", "dist", ".", "sample", "(", ")", "\n", "\n", "", "return", "exprs", ".", "cpu", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.LibrarySizeEncoder.__init__": [[17, 42], ["super().__init__", "scvi.nn.FCLayers", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "use_batch_norm", ":", "bool", "=", "False", ",", "\n", "use_layer_norm", ":", "bool", "=", "True", ",", "\n", "deep_inject_covariates", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "px_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "activation_fn", "=", "torch", ".", "nn", ".", "LeakyReLU", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "inject_covariates", "=", "deep_inject_covariates", ",", "\n", ")", "\n", "self", ".", "output", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "1", ")", ",", "torch", ".", "nn", ".", "LeakyReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.LibrarySizeEncoder.forward": [[44, 46], ["_multivae.LibrarySizeEncoder.output", "_multivae.LibrarySizeEncoder.px_decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "return", "self", ".", "output", "(", "self", ".", "px_decoder", "(", "x", ",", "*", "cat_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.__init__": [[105, 252], ["scvi.module.base.BaseModuleClass.__init__", "scvi.nn.Encoder", "scvi.nn.Encoder", "scvi.nn.DecoderSCVI", "scvi.module._peakvae.Decoder", "torch.nn.Parameter", "_multivae.LibrarySizeEncoder", "scvi.module._peakvae.Decoder", "int", "int", "torch.nn.Parameter", "torch.randn", "numpy.sqrt", "numpy.sqrt", "list", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input_regions", ":", "int", "=", "0", ",", "\n", "n_input_genes", ":", "int", "=", "0", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "n_hidden", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_latent", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_layers_encoder", ":", "int", "=", "2", ",", "\n", "n_layers_decoder", ":", "int", "=", "2", ",", "\n", "n_continuous_cov", ":", "int", "=", "0", ",", "\n", "n_cats_per_cov", ":", "Optional", "[", "Iterable", "[", "int", "]", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "region_factors", ":", "bool", "=", "True", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "latent_distribution", ":", "str", "=", "\"normal\"", ",", "\n", "deeply_inject_covariates", ":", "bool", "=", "False", ",", "\n", "encode_covariates", ":", "bool", "=", "False", ",", "\n", "use_size_factor_key", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# INIT PARAMS", "\n", "self", ".", "n_input_regions", "=", "n_input_regions", "\n", "self", ".", "n_input_genes", "=", "n_input_genes", "\n", "self", ".", "n_hidden", "=", "(", "\n", "int", "(", "np", ".", "sqrt", "(", "self", ".", "n_input_regions", "+", "self", ".", "n_input_genes", ")", ")", "\n", "if", "n_hidden", "is", "None", "\n", "else", "n_hidden", "\n", ")", "\n", "self", ".", "n_batch", "=", "n_batch", "\n", "\n", "self", ".", "gene_likelihood", "=", "gene_likelihood", "\n", "self", ".", "latent_distribution", "=", "latent_distribution", "\n", "\n", "self", ".", "n_latent", "=", "int", "(", "np", ".", "sqrt", "(", "self", ".", "n_hidden", ")", ")", "if", "n_latent", "is", "None", "else", "n_latent", "\n", "self", ".", "n_layers_encoder", "=", "n_layers_encoder", "\n", "self", ".", "n_layers_decoder", "=", "n_layers_decoder", "\n", "self", ".", "n_cats_per_cov", "=", "n_cats_per_cov", "\n", "self", ".", "n_continuous_cov", "=", "n_continuous_cov", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "\n", "self", ".", "use_batch_norm_encoder", "=", "use_batch_norm", "in", "(", "\"encoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_batch_norm_decoder", "=", "use_batch_norm", "in", "(", "\"decoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_layer_norm_encoder", "=", "use_layer_norm", "in", "(", "\"encoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_layer_norm_decoder", "=", "use_layer_norm", "in", "(", "\"decoder\"", ",", "\"both\"", ")", "\n", "self", ".", "encode_covariates", "=", "encode_covariates", "\n", "self", ".", "deeply_inject_covariates", "=", "deeply_inject_covariates", "\n", "self", ".", "use_size_factor_key", "=", "use_size_factor_key", "\n", "\n", "cat_list", "=", "(", "\n", "[", "n_batch", "]", "+", "list", "(", "n_cats_per_cov", ")", "if", "n_cats_per_cov", "is", "not", "None", "else", "[", "]", "\n", ")", "\n", "\n", "n_input_encoder_acc", "=", "(", "\n", "self", ".", "n_input_regions", "+", "n_continuous_cov", "*", "encode_covariates", "\n", ")", "\n", "n_input_encoder_exp", "=", "self", ".", "n_input_genes", "+", "n_continuous_cov", "*", "encode_covariates", "\n", "encoder_cat_list", "=", "cat_list", "if", "encode_covariates", "else", "None", "\n", "\n", "## accessibility encoder", "\n", "self", ".", "z_encoder_accessibility", "=", "Encoder", "(", "\n", "n_input", "=", "n_input_encoder_acc", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", "n_output", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "dropout_rate", "=", "self", ".", "dropout_rate", ",", "\n", "activation_fn", "=", "torch", ".", "nn", ".", "LeakyReLU", ",", "\n", "distribution", "=", "self", ".", "latent_distribution", ",", "\n", "var_eps", "=", "0", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "## expression encoder", "\n", "self", ".", "z_encoder_expression", "=", "Encoder", "(", "\n", "n_input", "=", "n_input_encoder_exp", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", "n_output", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "dropout_rate", "=", "self", ".", "dropout_rate", ",", "\n", "activation_fn", "=", "torch", ".", "nn", ".", "LeakyReLU", ",", "\n", "distribution", "=", "self", ".", "latent_distribution", ",", "\n", "var_eps", "=", "0", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "# expression decoder", "\n", "self", ".", "z_decoder_expression", "=", "DecoderSCVI", "(", "\n", "self", ".", "n_latent", "+", "self", ".", "n_continuous_cov", ",", "\n", "n_input_genes", ",", "\n", "n_cat_list", "=", "cat_list", ",", "\n", "n_layers", "=", "n_layers_decoder", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "inject_covariates", "=", "self", ".", "deeply_inject_covariates", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_decoder", ",", "\n", "scale_activation", "=", "\"softplus\"", "if", "use_size_factor_key", "else", "\"softmax\"", ",", "\n", ")", "\n", "\n", "# accessibility decoder", "\n", "self", ".", "z_decoder_accessibility", "=", "DecoderPeakVI", "(", "\n", "n_input", "=", "self", ".", "n_latent", "+", "self", ".", "n_continuous_cov", ",", "\n", "n_output", "=", "n_input_regions", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "cat_list", ",", "\n", "n_layers", "=", "self", ".", "n_layers_decoder", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_decoder", ",", "\n", "deep_inject_covariates", "=", "self", ".", "deeply_inject_covariates", ",", "\n", ")", "\n", "\n", "## accessibility region-specific factors", "\n", "self", ".", "region_factors", "=", "None", "\n", "if", "region_factors", ":", "\n", "            ", "self", ".", "region_factors", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "self", ".", "n_input_regions", ")", ")", "\n", "\n", "## expression dispersion parameters", "\n", "", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input_genes", ")", ")", "\n", "\n", "## expression library size encoder", "\n", "self", ".", "l_encoder_expression", "=", "LibrarySizeEncoder", "(", "\n", "n_input_encoder_exp", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_encoder", ",", "\n", "deep_inject_covariates", "=", "self", ".", "deeply_inject_covariates", ",", "\n", ")", "\n", "\n", "## accessibility library size encoder", "\n", "self", ".", "l_encoder_accessibility", "=", "DecoderPeakVI", "(", "\n", "n_input", "=", "n_input_encoder_acc", ",", "\n", "n_output", "=", "1", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_encoder", ",", "\n", "deep_inject_covariates", "=", "self", ".", "deeply_inject_covariates", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._get_inference_input": [[254, 266], ["tensors.get", "tensors.get", "dict"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "cont_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ")", "\n", "cat_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.inference": [[267, 353], ["_multivae.MULTIVAE.z_encoder_accessibility", "_multivae.MULTIVAE.z_encoder_expression", "_multivae.MULTIVAE.l_encoder_expression", "_multivae.MULTIVAE.l_encoder_accessibility", "torch.distributions.Normal().rsample", "_multivae.MULTIVAE._mix_modalities", "_multivae.MULTIVAE._mix_modalities", "_multivae.MULTIVAE._mix_modalities", "dict", "x_rna.sum", "x_chr.sum", "torch.cat", "torch.cat", "torch.split", "tuple", "qz_acc.sample", "_multivae.MULTIVAE.z_encoder_accessibility.z_transformation", "qz_expr.sample", "_multivae.MULTIVAE.z_encoder_expression.z_transformation", "libsize_expr.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "libsize_acc.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "torch.distributions.Normal", "libsize_expr.unsqueeze().expand.unsqueeze().expand.unsqueeze", "libsize_expr.unsqueeze().expand.unsqueeze().expand.size", "libsize_expr.unsqueeze().expand.unsqueeze().expand.size", "libsize_acc.unsqueeze().expand.unsqueeze().expand.unsqueeze", "libsize_acc.unsqueeze().expand.unsqueeze().expand.size", "libsize_acc.unsqueeze().expand.unsqueeze().expand.size", "qzp_v.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._mix_modalities", "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._mix_modalities", "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._mix_modalities", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "\n", "self", ",", "\n", "x", ",", "\n", "batch_index", ",", "\n", "cont_covs", ",", "\n", "cat_covs", ",", "\n", "n_samples", "=", "1", ",", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "\n", "# Get Data and Additional Covs", "\n", "        ", "x_rna", "=", "x", "[", ":", ",", ":", "self", ".", "n_input_genes", "]", "\n", "x_chr", "=", "x", "[", ":", ",", "self", ".", "n_input_genes", ":", "]", "\n", "\n", "mask_expr", "=", "x_rna", ".", "sum", "(", "dim", "=", "1", ")", ">", "0", "\n", "mask_acc", "=", "x_chr", ".", "sum", "(", "dim", "=", "1", ")", ">", "0", "\n", "\n", "if", "cont_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "encoder_input_expression", "=", "torch", ".", "cat", "(", "(", "x_rna", ",", "cont_covs", ")", ",", "dim", "=", "-", "1", ")", "\n", "encoder_input_accessibility", "=", "torch", ".", "cat", "(", "(", "x_chr", ",", "cont_covs", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "encoder_input_expression", "=", "x_rna", "\n", "encoder_input_accessibility", "=", "x_chr", "\n", "\n", "", "if", "cat_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "# Z Encoders", "\n", "", "qz_acc", ",", "z_acc", "=", "self", ".", "z_encoder_accessibility", "(", "\n", "encoder_input_accessibility", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "qz_expr", ",", "z_expr", "=", "self", ".", "z_encoder_expression", "(", "\n", "encoder_input_expression", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "qzm_acc", "=", "qz_acc", ".", "loc", "\n", "qzm_expr", "=", "qz_expr", ".", "loc", "\n", "qzv_acc", "=", "qz_acc", ".", "scale", "**", "2", "\n", "qzv_expr", "=", "qz_expr", ".", "scale", "**", "2", "\n", "# L encoders", "\n", "libsize_expr", "=", "self", ".", "l_encoder_expression", "(", "\n", "encoder_input_expression", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "libsize_acc", "=", "self", ".", "l_encoder_accessibility", "(", "\n", "encoder_input_accessibility", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "\n", "# ReFormat Outputs", "\n", "if", "n_samples", ">", "1", ":", "\n", "            ", "untran_za", "=", "qz_acc", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z_acc", "=", "self", ".", "z_encoder_accessibility", ".", "z_transformation", "(", "untran_za", ")", "\n", "untran_zr", "=", "qz_expr", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z_expr", "=", "self", ".", "z_encoder_expression", ".", "z_transformation", "(", "untran_zr", ")", "\n", "\n", "libsize_expr", "=", "libsize_expr", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "libsize_expr", ".", "size", "(", "0", ")", ",", "libsize_expr", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "libsize_acc", "=", "libsize_acc", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "libsize_acc", ".", "size", "(", "0", ")", ",", "libsize_acc", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "\n", "## Sample from the average distribution", "\n", "", "qzp_m", "=", "(", "qzm_acc", "+", "qzm_expr", ")", "/", "2", "\n", "qzp_v", "=", "(", "qzv_acc", "+", "qzv_expr", ")", "/", "(", "2", "**", "0.5", ")", "\n", "zp", "=", "Normal", "(", "qzp_m", ",", "qzp_v", ".", "sqrt", "(", ")", ")", ".", "rsample", "(", ")", "\n", "\n", "## choose the correct latent representation based on the modality", "\n", "qz_m", "=", "self", ".", "_mix_modalities", "(", "qzp_m", ",", "qzm_expr", ",", "qzm_acc", ",", "mask_expr", ",", "mask_acc", ")", "\n", "qz_v", "=", "self", ".", "_mix_modalities", "(", "qzp_v", ",", "qzv_expr", ",", "qzv_acc", ",", "mask_expr", ",", "mask_acc", ")", "\n", "z", "=", "self", ".", "_mix_modalities", "(", "zp", ",", "z_expr", ",", "z_acc", ",", "mask_expr", ",", "mask_acc", ")", "\n", "\n", "outputs", "=", "dict", "(", "\n", "z", "=", "z", ",", "\n", "qz_m", "=", "qz_m", ",", "\n", "qz_v", "=", "qz_v", ",", "\n", "z_expr", "=", "z_expr", ",", "\n", "qzm_expr", "=", "qzm_expr", ",", "\n", "qzv_expr", "=", "qzv_expr", ",", "\n", "z_acc", "=", "z_acc", ",", "\n", "qzm_acc", "=", "qzm_acc", ",", "\n", "qzv_acc", "=", "qzv_acc", ",", "\n", "libsize_expr", "=", "libsize_expr", ",", "\n", "libsize_acc", "=", "libsize_acc", ",", "\n", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._get_generative_input": [[354, 386], ["dict", "torch.log", "tensors.keys", "tensors.keys", "tensors.keys", "torch.ones_like"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ",", "transform_batch", "=", "None", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "qz_m", "=", "inference_outputs", "[", "\"qz_m\"", "]", "\n", "libsize_expr", "=", "inference_outputs", "[", "\"libsize_expr\"", "]", "\n", "\n", "size_factor_key", "=", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "\n", "size_factor", "=", "(", "\n", "torch", ".", "log", "(", "tensors", "[", "size_factor_key", "]", ")", "\n", "if", "size_factor_key", "in", "tensors", ".", "keys", "(", ")", "\n", "else", "None", "\n", ")", "\n", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "if", "transform_batch", "is", "not", "None", ":", "\n", "            ", "batch_index", "=", "torch", ".", "ones_like", "(", "batch_index", ")", "*", "transform_batch", "\n", "\n", "", "input_dict", "=", "dict", "(", "\n", "z", "=", "z", ",", "\n", "qz_m", "=", "qz_m", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", "libsize_expr", "=", "libsize_expr", ",", "\n", "size_factor", "=", "size_factor", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.generative": [[387, 431], ["_multivae.MULTIVAE.z_decoder_accessibility", "_multivae.MULTIVAE.z_decoder_expression", "dict", "torch.split", "tuple", "latent.dim", "cont_covs.dim", "torch.cat", "torch.cat", "torch.exp", "cont_covs.unsqueeze().expand", "latent.size", "cont_covs.unsqueeze"], "methods", ["None"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "\n", "self", ",", "\n", "z", ",", "\n", "qz_m", ",", "\n", "batch_index", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", "libsize_expr", "=", "None", ",", "\n", "size_factor", "=", "None", ",", "\n", "use_z_mean", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Runs the generative model.\"\"\"", "\n", "if", "cat_covs", "is", "not", "None", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "", "latent", "=", "z", "if", "not", "use_z_mean", "else", "qz_m", "\n", "if", "cont_covs", "is", "None", ":", "\n", "            ", "decoder_input", "=", "latent", "\n", "", "elif", "latent", ".", "dim", "(", ")", "!=", "cont_covs", ".", "dim", "(", ")", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "\n", "[", "latent", ",", "cont_covs", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "latent", ".", "size", "(", "0", ")", ",", "-", "1", ",", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "[", "latent", ",", "cont_covs", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Accessibility Decoder", "\n", "", "p", "=", "self", ".", "z_decoder_accessibility", "(", "decoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "\n", "# Expression Decoder", "\n", "if", "not", "self", ".", "use_size_factor_key", ":", "\n", "            ", "size_factor", "=", "libsize_expr", "\n", "", "px_scale", ",", "_", ",", "px_rate", ",", "px_dropout", "=", "self", ".", "z_decoder_expression", "(", "\n", "\"gene\"", ",", "decoder_input", ",", "size_factor", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "\n", "return", "dict", "(", "\n", "p", "=", "p", ",", "\n", "px_scale", "=", "px_scale", ",", "\n", "px_r", "=", "torch", ".", "exp", "(", "self", ".", "px_r", ")", ",", "\n", "px_rate", "=", "px_rate", ",", "\n", "px_dropout", "=", "px_dropout", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.loss": [[433, 508], ["_multivae.MULTIVAE.get_reconstruction_loss_accessibility", "_multivae.MULTIVAE.get_reconstruction_loss_expression", "_multivae.MULTIVAE._mix_modalities", "torch.distributions.kl_divergence.sum", "torch.where().sum", "torch.mean", "dict", "torch.tensor", "scvi.module.base.LossRecorder", "x_rna.sum", "x_chr.sum", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.where", "torch.distributions.Normal", "torch.distributions.Normal", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.logical_and", "torch.sqrt", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.get_reconstruction_loss_accessibility", "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.get_reconstruction_loss_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._mix_modalities", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "loss", "(", "\n", "self", ",", "tensors", ",", "inference_outputs", ",", "generative_outputs", ",", "kl_weight", ":", "float", "=", "1.0", "\n", ")", ":", "\n", "# Get the data", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "\n", "x_rna", "=", "x", "[", ":", ",", ":", "self", ".", "n_input_genes", "]", "\n", "x_chr", "=", "x", "[", ":", ",", "self", ".", "n_input_genes", ":", "]", "\n", "\n", "mask_expr", "=", "x_rna", ".", "sum", "(", "dim", "=", "1", ")", ">", "0", "\n", "mask_acc", "=", "x_chr", ".", "sum", "(", "dim", "=", "1", ")", ">", "0", "\n", "\n", "# Compute Accessibility loss", "\n", "x_accessibility", "=", "x", "[", ":", ",", "self", ".", "n_input_genes", ":", "]", "\n", "p", "=", "generative_outputs", "[", "\"p\"", "]", "\n", "libsize_acc", "=", "inference_outputs", "[", "\"libsize_acc\"", "]", "\n", "rl_accessibility", "=", "self", ".", "get_reconstruction_loss_accessibility", "(", "\n", "x_accessibility", ",", "p", ",", "libsize_acc", "\n", ")", "\n", "\n", "# Compute Expression loss", "\n", "px_rate", "=", "generative_outputs", "[", "\"px_rate\"", "]", "\n", "px_r", "=", "generative_outputs", "[", "\"px_r\"", "]", "\n", "px_dropout", "=", "generative_outputs", "[", "\"px_dropout\"", "]", "\n", "x_expression", "=", "x", "[", ":", ",", ":", "self", ".", "n_input_genes", "]", "\n", "rl_expression", "=", "self", ".", "get_reconstruction_loss_expression", "(", "\n", "x_expression", ",", "px_rate", ",", "px_r", ",", "px_dropout", "\n", ")", "\n", "\n", "# mix losses to get the correct loss for each cell", "\n", "recon_loss", "=", "self", ".", "_mix_modalities", "(", "\n", "rl_accessibility", "+", "rl_expression", ",", "# paired", "\n", "rl_expression", ",", "# expression", "\n", "rl_accessibility", ",", "# accessibility", "\n", "mask_expr", ",", "\n", "mask_acc", ",", "\n", ")", "\n", "\n", "# Compute KLD between Z and N(0,I)", "\n", "qz_m", "=", "inference_outputs", "[", "\"qz_m\"", "]", "\n", "qz_v", "=", "inference_outputs", "[", "\"qz_v\"", "]", "\n", "kl_div_z", "=", "kld", "(", "\n", "Normal", "(", "qz_m", ",", "torch", ".", "sqrt", "(", "qz_v", ")", ")", ",", "\n", "Normal", "(", "0", ",", "1", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "# Compute KLD between distributions for paired data", "\n", "qzm_expr", "=", "inference_outputs", "[", "\"qzm_expr\"", "]", "\n", "qzv_expr", "=", "inference_outputs", "[", "\"qzv_expr\"", "]", "\n", "qzm_acc", "=", "inference_outputs", "[", "\"qzm_acc\"", "]", "\n", "qzv_acc", "=", "inference_outputs", "[", "\"qzv_acc\"", "]", "\n", "kld_paired", "=", "kld", "(", "\n", "Normal", "(", "qzm_expr", ",", "torch", ".", "sqrt", "(", "qzv_expr", ")", ")", ",", "Normal", "(", "qzm_acc", ",", "torch", ".", "sqrt", "(", "qzv_acc", ")", ")", "\n", ")", "+", "kld", "(", "\n", "Normal", "(", "qzm_acc", ",", "torch", ".", "sqrt", "(", "qzv_acc", ")", ")", ",", "Normal", "(", "qzm_expr", ",", "torch", ".", "sqrt", "(", "qzv_expr", ")", ")", "\n", ")", "\n", "kld_paired", "=", "torch", ".", "where", "(", "\n", "torch", ".", "logical_and", "(", "mask_acc", ",", "mask_expr", ")", ",", "\n", "kld_paired", ".", "T", ",", "\n", "torch", ".", "zeros_like", "(", "kld_paired", ")", ".", "T", ",", "\n", ")", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n", "# KL WARMUP", "\n", "kl_local_for_warmup", "=", "kl_div_z", "\n", "weighted_kl_local", "=", "kl_weight", "*", "kl_local_for_warmup", "\n", "\n", "# PENALTY", "\n", "# distance_penalty = kl_weight * torch.pow(z_acc - z_expr, 2).sum(dim=1)", "\n", "\n", "# TOTAL LOSS", "\n", "loss", "=", "torch", ".", "mean", "(", "recon_loss", "+", "weighted_kl_local", "+", "kld_paired", ")", "\n", "\n", "kl_local", "=", "dict", "(", "kl_divergence_z", "=", "kl_div_z", ")", "\n", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "return", "LossRecorder", "(", "loss", ",", "recon_loss", ",", "kl_local", ",", "kl_global", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.get_reconstruction_loss_expression": [[509, 524], ["scvi.distributions.ZeroInflatedNegativeBinomial().log_prob().sum", "scvi.distributions.NegativeBinomial().log_prob().sum", "scvi.distributions.ZeroInflatedNegativeBinomial().log_prob", "torch.distributions.Poisson().log_prob().sum", "scvi.distributions.NegativeBinomial().log_prob", "scvi.distributions.ZeroInflatedNegativeBinomial", "torch.distributions.Poisson().log_prob", "scvi.distributions.NegativeBinomial", "torch.distributions.Poisson"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "get_reconstruction_loss_expression", "(", "self", ",", "x", ",", "px_rate", ",", "px_r", ",", "px_dropout", ")", ":", "\n", "        ", "rl", "=", "0.0", "\n", "if", "self", ".", "gene_likelihood", "==", "\"zinb\"", ":", "\n", "            ", "rl", "=", "(", "\n", "-", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ",", "zi_logits", "=", "px_dropout", "\n", ")", "\n", ".", "log_prob", "(", "x", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "", "elif", "self", ".", "gene_likelihood", "==", "\"nb\"", ":", "\n", "            ", "rl", "=", "-", "NegativeBinomial", "(", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ")", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "", "elif", "self", ".", "gene_likelihood", "==", "\"poisson\"", ":", "\n", "            ", "rl", "=", "-", "Poisson", "(", "px_rate", ")", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "", "return", "rl", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE.get_reconstruction_loss_accessibility": [[525, 529], ["torch.sigmoid", "torch.nn.BCELoss"], "methods", ["None"], ["", "def", "get_reconstruction_loss_accessibility", "(", "self", ",", "x", ",", "p", ",", "d", ")", ":", "\n", "        ", "f", "=", "torch", ".", "sigmoid", "(", "self", ".", "region_factors", ")", "if", "self", ".", "region_factors", "is", "not", "None", "else", "1", "\n", "return", "torch", ".", "nn", ".", "BCELoss", "(", "reduction", "=", "\"none\"", ")", "(", "p", "*", "d", "*", "f", ",", "(", "x", ">", "0", ")", ".", "float", "(", ")", ")", ".", "sum", "(", "\n", "dim", "=", "-", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._multivae.MULTIVAE._mix_modalities": [[531, 560], ["torch.where", "torch.where", "torch.logical_and"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_mix_modalities", "(", "x_paired", ",", "x_expr", ",", "x_acc", ",", "mask_expr", ",", "mask_acc", ")", ":", "\n", "        ", "\"\"\"\n        Mixes modality-specific vectors according to the modality masks.\n\n        in positions where both `mask_expr` and `mask_acc` are True (corresponding to cell\n        for which both expression and accessibility data is available), values from `x_paired`\n        will be used. If only `mask_expr` is True, use values from `x_expr`, and if only\n        `mask_acc` is True, use values from `x_acc`.\n\n        Parameters\n        ----------\n        x_paired\n            the values for paired cells (both modalities available), will be used in\n            positions where both `mask_expr` and `mask_acc` are True.\n        x_expr\n            the values for expression-only cells, will be used in positions where\n            only `mask_expr` is True.\n        x_acc\n            the values for accessibility-only cells, will be used on positions where\n            only `mask_acc` is True.\n        mask_expr\n            the expression mask, indicating which cells have expression data\n        mask_acc\n            the accessibility mask, indicating which cells have accessibility data\n        \"\"\"", "\n", "x", "=", "torch", ".", "where", "(", "mask_expr", ".", "T", ",", "x_expr", ".", "T", ",", "x_acc", ".", "T", ")", ".", "T", "\n", "x", "=", "torch", ".", "where", "(", "torch", ".", "logical_and", "(", "mask_acc", ",", "mask_expr", ")", ",", "x_paired", ".", "T", ",", "x", ".", "T", ")", ".", "T", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.Decoder.__init__": [[44, 70], ["super().__init__", "scvi.nn.FCLayers", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_output", ":", "int", ",", "\n", "n_cat_list", ":", "Iterable", "[", "int", "]", "=", "None", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "use_batch_norm", ":", "bool", "=", "False", ",", "\n", "use_layer_norm", ":", "bool", "=", "True", ",", "\n", "deep_inject_covariates", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "px_decoder", "=", "FCLayers", "(", "\n", "n_in", "=", "n_input", ",", "\n", "n_out", "=", "n_hidden", ",", "\n", "n_cat_list", "=", "n_cat_list", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "0", ",", "\n", "activation_fn", "=", "torch", ".", "nn", ".", "LeakyReLU", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "inject_covariates", "=", "deep_inject_covariates", ",", "\n", ")", "\n", "self", ".", "output", "=", "torch", ".", "nn", ".", "Sequential", "(", "\n", "torch", ".", "nn", ".", "Linear", "(", "n_hidden", ",", "n_output", ")", ",", "torch", ".", "nn", ".", "Sigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.Decoder.forward": [[72, 75], ["_peakvae.Decoder.output", "_peakvae.Decoder.px_decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "*", "cat_list", ":", "int", ")", ":", "\n", "        ", "x", "=", "self", ".", "output", "(", "self", ".", "px_decoder", "(", "z", ",", "*", "cat_list", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE.__init__": [[130, 215], ["scvi.module.base.BaseModuleClass.__init__", "scvi.nn.Encoder", "_peakvae.Decoder", "int", "int", "_peakvae.Decoder", "torch.nn.Parameter", "numpy.sqrt", "numpy.sqrt", "list", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input_regions", ":", "int", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_latent", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_layers_encoder", ":", "int", "=", "2", ",", "\n", "n_layers_decoder", ":", "int", "=", "2", ",", "\n", "n_continuous_cov", ":", "int", "=", "0", ",", "\n", "n_cats_per_cov", ":", "Optional", "[", "Iterable", "[", "int", "]", "]", "=", "None", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "model_depth", ":", "bool", "=", "True", ",", "\n", "region_factors", ":", "bool", "=", "True", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "latent_distribution", ":", "str", "=", "\"normal\"", ",", "\n", "deeply_inject_covariates", ":", "bool", "=", "False", ",", "\n", "encode_covariates", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input_regions", "=", "n_input_regions", "\n", "self", ".", "n_hidden", "=", "(", "\n", "int", "(", "np", ".", "sqrt", "(", "self", ".", "n_input_regions", ")", ")", "if", "n_hidden", "is", "None", "else", "n_hidden", "\n", ")", "\n", "self", ".", "n_latent", "=", "int", "(", "np", ".", "sqrt", "(", "self", ".", "n_hidden", ")", ")", "if", "n_latent", "is", "None", "else", "n_latent", "\n", "self", ".", "n_layers_encoder", "=", "n_layers_encoder", "\n", "self", ".", "n_layers_decoder", "=", "n_layers_decoder", "\n", "self", ".", "n_cats_per_cov", "=", "n_cats_per_cov", "\n", "self", ".", "n_continuous_cov", "=", "n_continuous_cov", "\n", "self", ".", "model_depth", "=", "model_depth", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "latent_distribution", "=", "latent_distribution", "\n", "self", ".", "use_batch_norm_encoder", "=", "use_batch_norm", "in", "(", "\"encoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_batch_norm_decoder", "=", "use_batch_norm", "in", "(", "\"decoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_layer_norm_encoder", "=", "use_layer_norm", "in", "(", "\"encoder\"", ",", "\"both\"", ")", "\n", "self", ".", "use_layer_norm_decoder", "=", "use_layer_norm", "in", "(", "\"decoder\"", ",", "\"both\"", ")", "\n", "self", ".", "deeply_inject_covariates", "=", "deeply_inject_covariates", "\n", "self", ".", "encode_covariates", "=", "encode_covariates", "\n", "\n", "cat_list", "=", "(", "\n", "[", "n_batch", "]", "+", "list", "(", "n_cats_per_cov", ")", "if", "n_cats_per_cov", "is", "not", "None", "else", "[", "]", "\n", ")", "\n", "\n", "n_input_encoder", "=", "self", ".", "n_input_regions", "+", "n_continuous_cov", "*", "encode_covariates", "\n", "encoder_cat_list", "=", "cat_list", "if", "encode_covariates", "else", "None", "\n", "self", ".", "z_encoder", "=", "Encoder", "(", "\n", "n_input", "=", "n_input_encoder", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", "n_output", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "dropout_rate", "=", "self", ".", "dropout_rate", ",", "\n", "activation_fn", "=", "torch", ".", "nn", ".", "LeakyReLU", ",", "\n", "distribution", "=", "self", ".", "latent_distribution", ",", "\n", "var_eps", "=", "0", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "z_decoder", "=", "Decoder", "(", "\n", "n_input", "=", "self", ".", "n_latent", "+", "self", ".", "n_continuous_cov", ",", "\n", "n_output", "=", "n_input_regions", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "cat_list", ",", "\n", "n_layers", "=", "self", ".", "n_layers_decoder", ",", "\n", "use_batch_norm", "=", "self", ".", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "self", ".", "use_layer_norm_decoder", ",", "\n", "deep_inject_covariates", "=", "self", ".", "deeply_inject_covariates", ",", "\n", ")", "\n", "\n", "self", ".", "d_encoder", "=", "None", "\n", "if", "self", ".", "model_depth", ":", "\n", "# Decoder class to avoid variational split", "\n", "            ", "self", ".", "d_encoder", "=", "Decoder", "(", "\n", "n_input", "=", "n_input_encoder", ",", "\n", "n_output", "=", "1", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_layers", "=", "self", ".", "n_layers_encoder", ",", "\n", ")", "\n", "", "self", ".", "region_factors", "=", "None", "\n", "if", "region_factors", ":", "\n", "            ", "self", ".", "region_factors", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "self", ".", "n_input_regions", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE._get_inference_input": [[216, 228], ["tensors.get", "tensors.get", "dict"], "methods", ["None"], ["", "", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "cont_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ")", "\n", "cat_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE._get_generative_input": [[229, 247], ["tensors.get", "tensors.get", "torch.ones_like"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ",", "transform_batch", "=", "None", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "qz_m", "=", "inference_outputs", "[", "\"qz\"", "]", ".", "loc", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "cont_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ")", "\n", "\n", "cat_covs", "=", "tensors", ".", "get", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", "\n", "\n", "if", "transform_batch", "is", "not", "None", ":", "\n", "            ", "batch_index", "=", "torch", ".", "ones_like", "(", "batch_index", ")", "*", "transform_batch", "\n", "", "input_dict", "=", "{", "\n", "\"z\"", ":", "z", ",", "\n", "\"qz_m\"", ":", "qz_m", ",", "\n", "\"batch_index\"", ":", "batch_index", ",", "\n", "\"cont_covs\"", ":", "cont_covs", ",", "\n", "\"cat_covs\"", ":", "cat_covs", ",", "\n", "}", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE.get_reconstruction_loss": [[248, 251], ["torch.nn.BCELoss"], "methods", ["None"], ["", "def", "get_reconstruction_loss", "(", "self", ",", "p", ",", "d", ",", "f", ",", "x", ")", ":", "\n", "        ", "rl", "=", "torch", ".", "nn", ".", "BCELoss", "(", "reduction", "=", "\"none\"", ")", "(", "p", "*", "d", "*", "f", ",", "(", "x", ">", "0", ")", ".", "float", "(", ")", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "return", "rl", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE.inference": [[252, 285], ["_peakvae.PEAKVAE.z_encoder", "dict", "torch.split", "tuple", "torch.cat", "_peakvae.PEAKVAE.d_encoder", "qz.sample", "_peakvae.PEAKVAE.z_encoder.z_transformation"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "\n", "self", ",", "\n", "x", ",", "\n", "batch_index", ",", "\n", "cont_covs", ",", "\n", "cat_covs", ",", "\n", "n_samples", "=", "1", ",", "\n", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"Helper function used in forward pass.\"\"\"", "\n", "if", "cat_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "", "if", "cont_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", ":", "\n", "            ", "encoder_input", "=", "torch", ".", "cat", "(", "[", "x", ",", "cont_covs", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "encoder_input", "=", "x", "\n", "# if encode_covariates is False, cat_list to init encoder is None, so", "\n", "# batch_index is not used (or categorical_input, but it's empty)", "\n", "", "qz", ",", "z", "=", "self", ".", "z_encoder", "(", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "d", "=", "(", "\n", "self", ".", "d_encoder", "(", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "if", "self", ".", "model_depth", "\n", "else", "1", "\n", ")", "\n", "\n", "if", "n_samples", ">", "1", ":", "\n", "# when z is normal, untran_z == z", "\n", "            ", "untran_z", "=", "qz", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z", "=", "self", ".", "z_encoder", ".", "z_transformation", "(", "untran_z", ")", "\n", "\n", "", "return", "dict", "(", "d", "=", "d", ",", "qz", "=", "qz", ",", "z", "=", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE.generative": [[286, 316], ["_peakvae.PEAKVAE.z_decoder", "dict", "torch.split", "tuple", "latent.dim", "cont_covs.dim", "torch.cat", "torch.cat", "cont_covs.unsqueeze().expand", "latent.size", "cont_covs.unsqueeze"], "methods", ["None"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "\n", "self", ",", "\n", "z", ",", "\n", "qz_m", ",", "\n", "batch_index", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", "use_z_mean", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Runs the generative model.\"\"\"", "\n", "\n", "if", "cat_covs", "is", "not", "None", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "", "latent", "=", "z", "if", "not", "use_z_mean", "else", "qz_m", "\n", "if", "cont_covs", "is", "None", ":", "\n", "            ", "decoder_input", "=", "latent", "\n", "", "elif", "latent", ".", "dim", "(", ")", "!=", "cont_covs", ".", "dim", "(", ")", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "\n", "[", "latent", ",", "cont_covs", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "latent", ".", "size", "(", "0", ")", ",", "-", "1", ",", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "[", "latent", ",", "cont_covs", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "p", "=", "self", ".", "z_decoder", "(", "decoder_input", ",", "batch_index", ",", "*", "categorical_input", ")", "\n", "\n", "return", "dict", "(", "p", "=", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._peakvae.PEAKVAE.loss": [[317, 336], ["torch.distributions.kl_divergence().sum", "_peakvae.PEAKVAE.get_reconstruction_loss", "scvi.module.base.LossRecorder", "torch.sigmoid", "torch.distributions.kl_divergence", "torch.tensor", "torch.distributions.Normal", "_peakvae.PEAKVAE.sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_reconstruction_loss"], ["", "def", "loss", "(", "\n", "self", ",", "tensors", ",", "inference_outputs", ",", "generative_outputs", ",", "kl_weight", ":", "float", "=", "1.0", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "d", "=", "inference_outputs", "[", "\"d\"", "]", "\n", "p", "=", "generative_outputs", "[", "\"p\"", "]", "\n", "\n", "kld", "=", "kl_divergence", "(", "\n", "qz", ",", "\n", "Normal", "(", "0", ",", "1", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "f", "=", "torch", ".", "sigmoid", "(", "self", ".", "region_factors", ")", "if", "self", ".", "region_factors", "is", "not", "None", "else", "1", "\n", "rl", "=", "self", ".", "get_reconstruction_loss", "(", "p", ",", "d", ",", "f", ",", "x", ")", "\n", "\n", "loss", "=", "(", "rl", ".", "sum", "(", ")", "+", "kld", "*", "kl_weight", ")", ".", "sum", "(", ")", "\n", "\n", "return", "LossRecorder", "(", "loss", ",", "rl", ",", "kld", ",", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.__init__": [[98, 242], ["scvi.module.base.BaseModuleClass.__init__", "scvi.nn.EncoderTOTALVI", "scvi.nn.DecoderTOTALVI", "_totalvae.TOTALVAE.register_buffer", "_totalvae.TOTALVAE.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "list", "ValueError", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "protein_background_prior_mean.ravel", "protein_background_prior_scale.ravel", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.log", "torch.log", "torch.log", "torch.log", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "protein_background_prior_mean.ravel.astype", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "protein_background_prior_scale.ravel.astype", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_input_genes", ":", "int", ",", "\n", "n_input_proteins", ":", "int", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "n_hidden", ":", "int", "=", "256", ",", "\n", "n_latent", ":", "int", "=", "20", ",", "\n", "n_layers_encoder", ":", "int", "=", "2", ",", "\n", "n_layers_decoder", ":", "int", "=", "1", ",", "\n", "n_continuous_cov", ":", "int", "=", "0", ",", "\n", "n_cats_per_cov", ":", "Optional", "[", "Iterable", "[", "int", "]", "]", "=", "None", ",", "\n", "dropout_rate_decoder", ":", "float", "=", "0.2", ",", "\n", "dropout_rate_encoder", ":", "float", "=", "0.2", ",", "\n", "gene_dispersion", ":", "str", "=", "\"gene\"", ",", "\n", "protein_dispersion", ":", "str", "=", "\"protein\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", "gene_likelihood", ":", "str", "=", "\"nb\"", ",", "\n", "latent_distribution", ":", "str", "=", "\"normal\"", ",", "\n", "protein_batch_mask", ":", "Dict", "[", "Union", "[", "str", ",", "int", "]", ",", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "encode_covariates", ":", "bool", "=", "True", ",", "\n", "protein_background_prior_mean", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "protein_background_prior_scale", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "use_size_factor_key", ":", "bool", "=", "False", ",", "\n", "use_observed_lib_size", ":", "bool", "=", "True", ",", "\n", "library_log_means", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "library_log_vars", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gene_dispersion", "=", "gene_dispersion", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "log_variational", "=", "log_variational", "\n", "self", ".", "gene_likelihood", "=", "gene_likelihood", "\n", "self", ".", "n_batch", "=", "n_batch", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "self", ".", "n_input_genes", "=", "n_input_genes", "\n", "self", ".", "n_input_proteins", "=", "n_input_proteins", "\n", "self", ".", "protein_dispersion", "=", "protein_dispersion", "\n", "self", ".", "latent_distribution", "=", "latent_distribution", "\n", "self", ".", "protein_batch_mask", "=", "protein_batch_mask", "\n", "self", ".", "encode_covariates", "=", "encode_covariates", "\n", "self", ".", "use_size_factor_key", "=", "use_size_factor_key", "\n", "self", ".", "use_observed_lib_size", "=", "use_size_factor_key", "or", "use_observed_lib_size", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "if", "library_log_means", "is", "None", "or", "library_log_means", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"If not using observed_lib_size, \"", "\n", "\"must provide library_log_means and library_log_vars.\"", "\n", ")", "\n", "\n", "", "self", ".", "register_buffer", "(", "\n", "\"library_log_means\"", ",", "torch", ".", "from_numpy", "(", "library_log_means", ")", ".", "float", "(", ")", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"library_log_vars\"", ",", "torch", ".", "from_numpy", "(", "library_log_vars", ")", ".", "float", "(", ")", "\n", ")", "\n", "\n", "# parameters for prior on rate_back (background protein mean)", "\n", "", "if", "protein_background_prior_mean", "is", "None", ":", "\n", "            ", "if", "n_batch", ">", "0", ":", "\n", "                ", "self", ".", "background_pro_alpha", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input_proteins", ",", "n_batch", ")", "\n", ")", "\n", "self", ".", "background_pro_log_beta", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "clamp", "(", "torch", ".", "randn", "(", "n_input_proteins", ",", "n_batch", ")", ",", "-", "10", ",", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "background_pro_alpha", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "randn", "(", "n_input_proteins", ")", "\n", ")", "\n", "self", ".", "background_pro_log_beta", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "clamp", "(", "torch", ".", "randn", "(", "n_input_proteins", ")", ",", "-", "10", ",", "1", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "protein_background_prior_mean", ".", "shape", "[", "1", "]", "==", "1", "and", "n_batch", "!=", "1", ":", "\n", "                ", "init_mean", "=", "protein_background_prior_mean", ".", "ravel", "(", ")", "\n", "init_scale", "=", "protein_background_prior_scale", ".", "ravel", "(", ")", "\n", "", "else", ":", "\n", "                ", "init_mean", "=", "protein_background_prior_mean", "\n", "init_scale", "=", "protein_background_prior_scale", "\n", "", "self", ".", "background_pro_alpha", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "from_numpy", "(", "init_mean", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", ")", "\n", "self", ".", "background_pro_log_beta", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "log", "(", "torch", ".", "from_numpy", "(", "init_scale", ".", "astype", "(", "np", ".", "float32", ")", ")", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "gene_dispersion", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input_genes", ")", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input_genes", ",", "n_batch", ")", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "n_input_genes", ",", "n_labels", ")", ")", "\n", "", "else", ":", "# gene-cell", "\n", "            ", "pass", "\n", "\n", "", "if", "self", ".", "protein_dispersion", "==", "\"protein\"", ":", "\n", "            ", "self", ".", "py_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "2", "*", "torch", ".", "rand", "(", "self", ".", "n_input_proteins", ")", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein-batch\"", ":", "\n", "            ", "self", ".", "py_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "2", "*", "torch", ".", "rand", "(", "self", ".", "n_input_proteins", ",", "n_batch", ")", "\n", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein-label\"", ":", "\n", "            ", "self", ".", "py_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "2", "*", "torch", ".", "rand", "(", "self", ".", "n_input_proteins", ",", "n_labels", ")", "\n", ")", "\n", "", "else", ":", "# protein-cell", "\n", "            ", "pass", "\n", "\n", "", "use_batch_norm_encoder", "=", "use_batch_norm", "==", "\"encoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_batch_norm_decoder", "=", "use_batch_norm", "==", "\"decoder\"", "or", "use_batch_norm", "==", "\"both\"", "\n", "use_layer_norm_encoder", "=", "use_layer_norm", "==", "\"encoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "use_layer_norm_decoder", "=", "use_layer_norm", "==", "\"decoder\"", "or", "use_layer_norm", "==", "\"both\"", "\n", "\n", "# z encoder goes from the n_input-dimensional data to an n_latent-d", "\n", "# latent space representation", "\n", "n_input", "=", "n_input_genes", "+", "self", ".", "n_input_proteins", "\n", "n_input_encoder", "=", "n_input", "+", "n_continuous_cov", "*", "encode_covariates", "\n", "cat_list", "=", "[", "n_batch", "]", "+", "list", "(", "[", "]", "if", "n_cats_per_cov", "is", "None", "else", "n_cats_per_cov", ")", "\n", "encoder_cat_list", "=", "cat_list", "if", "encode_covariates", "else", "None", "\n", "self", ".", "encoder", "=", "EncoderTOTALVI", "(", "\n", "n_input_encoder", ",", "\n", "n_latent", ",", "\n", "n_layers", "=", "n_layers_encoder", ",", "\n", "n_cat_list", "=", "encoder_cat_list", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "distribution", "=", "latent_distribution", ",", "\n", "use_batch_norm", "=", "use_batch_norm_encoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_encoder", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "DecoderTOTALVI", "(", "\n", "n_latent", "+", "n_continuous_cov", ",", "\n", "n_input_genes", ",", "\n", "self", ".", "n_input_proteins", ",", "\n", "n_layers", "=", "n_layers_decoder", ",", "\n", "n_cat_list", "=", "cat_list", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "dropout_rate_decoder", ",", "\n", "use_batch_norm", "=", "use_batch_norm_decoder", ",", "\n", "use_layer_norm", "=", "use_layer_norm_decoder", ",", "\n", "scale_activation", "=", "\"softplus\"", "if", "use_size_factor_key", "else", "\"softmax\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_sample_dispersion": [[244, 279], ["_totalvae.TOTALVAE.inference"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "def", "get_sample_dispersion", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "torch", ".", "Tensor", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "label", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Returns the tensors of dispersions for genes and proteins.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input_genes)``\n        y\n            tensor of values with shape ``(batch_size, n_input_proteins)``\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        label\n            tensor of cell-types labels with shape ``(batch_size, n_labels)``\n        n_samples\n            number of samples\n\n        Returns\n        -------\n        type\n            tensors of dispersions of the negative binomial distribution\n        \"\"\"", "\n", "outputs", "=", "self", ".", "inference", "(", "\n", "x", ",", "y", ",", "batch_index", "=", "batch_index", ",", "label", "=", "label", ",", "n_samples", "=", "n_samples", "\n", ")", "\n", "px_r", "=", "outputs", "[", "\"px_\"", "]", "[", "\"r\"", "]", "\n", "py_r", "=", "outputs", "[", "\"py_\"", "]", "[", "\"r\"", "]", "\n", "return", "px_r", ",", "py_r", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_reconstruction_loss": [[280, 325], ["scvi.distributions.NegativeBinomialMixture", "scvi.distributions.NegativeBinomialMixture.log_prob", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.masked_scatter_", "torch.zeros_like.masked_scatter_", "torch.zeros_like.sum", "torch.zeros_like.sum", "reconst_loss_protein_full.sum", "scvi.distributions.ZeroInflatedNegativeBinomial().log_prob().sum", "scvi.distributions.NegativeBinomial().log_prob().sum", "pro_batch_mask_minibatch.bool", "scvi.distributions.ZeroInflatedNegativeBinomial().log_prob", "scvi.distributions.NegativeBinomial().log_prob", "scvi.distributions.ZeroInflatedNegativeBinomial", "scvi.distributions.NegativeBinomial"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "get_reconstruction_loss", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "torch", ".", "Tensor", ",", "\n", "px_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "py_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "pro_batch_mask_minibatch", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"Compute reconstruction loss.\"\"\"", "\n", "px_", "=", "px_dict", "\n", "py_", "=", "py_dict", "\n", "# Reconstruction Loss", "\n", "if", "self", ".", "gene_likelihood", "==", "\"zinb\"", ":", "\n", "            ", "reconst_loss_gene", "=", "(", "\n", "-", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "px_", "[", "\"rate\"", "]", ",", "theta", "=", "px_", "[", "\"r\"", "]", ",", "zi_logits", "=", "px_", "[", "\"dropout\"", "]", "\n", ")", "\n", ".", "log_prob", "(", "x", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "reconst_loss_gene", "=", "(", "\n", "-", "NegativeBinomial", "(", "mu", "=", "px_", "[", "\"rate\"", "]", ",", "theta", "=", "px_", "[", "\"r\"", "]", ")", "\n", ".", "log_prob", "(", "x", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "\n", "", "py_conditional", "=", "NegativeBinomialMixture", "(", "\n", "mu1", "=", "py_", "[", "\"rate_back\"", "]", ",", "\n", "mu2", "=", "py_", "[", "\"rate_fore\"", "]", ",", "\n", "theta1", "=", "py_", "[", "\"r\"", "]", ",", "\n", "mixture_logits", "=", "py_", "[", "\"mixing\"", "]", ",", "\n", ")", "\n", "reconst_loss_protein_full", "=", "-", "py_conditional", ".", "log_prob", "(", "y", ")", "\n", "if", "pro_batch_mask_minibatch", "is", "not", "None", ":", "\n", "            ", "temp_pro_loss_full", "=", "torch", ".", "zeros_like", "(", "reconst_loss_protein_full", ")", "\n", "temp_pro_loss_full", ".", "masked_scatter_", "(", "\n", "pro_batch_mask_minibatch", ".", "bool", "(", ")", ",", "reconst_loss_protein_full", "\n", ")", "\n", "\n", "reconst_loss_protein", "=", "temp_pro_loss_full", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "reconst_loss_protein", "=", "reconst_loss_protein_full", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "reconst_loss_gene", ",", "reconst_loss_protein", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE._get_inference_input": [[326, 341], ["dict", "tensors.keys", "tensors.keys"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "y", "=", "y", ",", "batch_index", "=", "batch_index", ",", "cat_covs", "=", "cat_covs", ",", "cont_covs", "=", "cont_covs", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE._get_generative_input": [[342, 367], ["dict", "tensors.keys", "tensors.keys", "tensors.keys"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "library_gene", "=", "inference_outputs", "[", "\"library_gene\"", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "label", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "size_factor_key", "=", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "\n", "size_factor", "=", "(", "\n", "tensors", "[", "size_factor_key", "]", "if", "size_factor_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", ")", "\n", "\n", "return", "dict", "(", "\n", "z", "=", "z", ",", "\n", "library_gene", "=", "library_gene", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", "label", "=", "label", ",", "\n", "cat_covs", "=", "cat_covs", ",", "\n", "cont_covs", "=", "cont_covs", ",", "\n", "size_factor", "=", "size_factor", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.generative": [[369, 429], ["_totalvae.TOTALVAE.decoder", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "dict", "torch.split", "torch.split", "torch.split", "torch.split", "tuple", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "z.dim", "cont_covs.dim", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.nn.one_hot", "scvi.nn.one_hot", "cont_covs.unsqueeze().expand", "z.size", "cont_covs.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "\n", "self", ",", "\n", "z", ":", "torch", ".", "Tensor", ",", "\n", "library_gene", ":", "torch", ".", "Tensor", ",", "\n", "batch_index", ":", "torch", ".", "Tensor", ",", "\n", "label", ":", "torch", ".", "Tensor", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", "size_factor", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", "]", ":", "\n", "        ", "if", "cont_covs", "is", "None", ":", "\n", "            ", "decoder_input", "=", "z", "\n", "", "elif", "z", ".", "dim", "(", ")", "!=", "cont_covs", ".", "dim", "(", ")", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "\n", "[", "z", ",", "cont_covs", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "z", ".", "size", "(", "0", ")", ",", "-", "1", ",", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "            ", "decoder_input", "=", "torch", ".", "cat", "(", "[", "z", ",", "cont_covs", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "if", "cat_covs", "is", "not", "None", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "\n", "", "if", "transform_batch", "is", "not", "None", ":", "\n", "            ", "batch_index", "=", "torch", ".", "ones_like", "(", "batch_index", ")", "*", "transform_batch", "\n", "\n", "", "if", "not", "self", ".", "use_size_factor_key", ":", "\n", "            ", "size_factor", "=", "library_gene", "\n", "\n", "", "px_", ",", "py_", ",", "log_pro_back_mean", "=", "self", ".", "decoder", "(", "\n", "decoder_input", ",", "size_factor", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "\n", "if", "self", ".", "gene_dispersion", "==", "\"gene-label\"", ":", "\n", "# px_r gets transposed - last dimension is nb genes", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "label", ",", "self", ".", "n_labels", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene\"", ":", "\n", "            ", "px_r", "=", "self", ".", "px_r", "\n", "", "px_r", "=", "torch", ".", "exp", "(", "px_r", ")", "\n", "\n", "if", "self", ".", "protein_dispersion", "==", "\"protein-label\"", ":", "\n", "# py_r gets transposed - last dimension is n_proteins", "\n", "            ", "py_r", "=", "F", ".", "linear", "(", "one_hot", "(", "label", ",", "self", ".", "n_labels", ")", ",", "self", ".", "py_r", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein-batch\"", ":", "\n", "            ", "py_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "py_r", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein\"", ":", "\n", "            ", "py_r", "=", "self", ".", "py_r", "\n", "", "py_r", "=", "torch", ".", "exp", "(", "py_r", ")", "\n", "\n", "px_", "[", "\"r\"", "]", "=", "px_r", "\n", "py_", "[", "\"r\"", "]", "=", "py_r", "\n", "return", "dict", "(", "\n", "px_", "=", "px_", ",", "\n", "py_", "=", "py_", ",", "\n", "log_pro_back_mean", "=", "log_pro_back_mean", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.inference": [[431, 551], ["_totalvae.TOTALVAE.encoder", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.distributions.Normal", "torch.distributions.Normal", "dict", "x.sum().unsqueeze", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.split", "torch.split", "torch.split", "torch.split", "tuple", "qz.sample", "_totalvae.TOTALVAE.encoder.z_transformation", "ql.sample", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "_totalvae.TOTALVAE.unsqueeze().expand", "_totalvae.TOTALVAE.encoder.l_transformation", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.nn.one_hot", "scvi.nn.one_hot", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "x.sum", "scvi.nn.one_hot", "scvi.nn.one_hot", "_totalvae.TOTALVAE.unsqueeze", "_totalvae.TOTALVAE.size", "_totalvae.TOTALVAE.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "torch", ".", "Tensor", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "label", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "n_samples", "=", "1", ",", "\n", "cont_covs", "=", "None", ",", "\n", "cat_covs", "=", "None", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        Internal helper function to compute necessary inference quantities.\n\n        We use the dictionary ``px_`` to contain the parameters of the ZINB/NB for genes.\n        The rate refers to the mean of the NB, dropout refers to Bernoulli mixing parameters.\n        `scale` refers to the quanity upon which differential expression is performed. For genes,\n        this can be viewed as the mean of the underlying gamma distribution.\n\n        We use the dictionary ``py_`` to contain the parameters of the Mixture NB distribution for proteins.\n        `rate_fore` refers to foreground mean, while `rate_back` refers to background mean. ``scale`` refers to\n        foreground mean adjusted for background probability and scaled to reside in simplex.\n        ``back_alpha`` and ``back_beta`` are the posterior parameters for ``rate_back``.  ``fore_scale`` is the scaling\n        factor that enforces `rate_fore` > `rate_back`.\n\n        ``px_[\"r\"]`` and ``py_[\"r\"]`` are the inverse dispersion parameters for genes and protein, respectively.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input_genes)``\n        y\n            tensor of values with shape ``(batch_size, n_input_proteins)``\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        label\n            tensor of cell-types labels with shape (batch_size, n_labels)\n        n_samples\n            Number of samples to sample from approximate posterior\n        cont_covs\n            Continuous covariates to condition on\n        cat_covs\n            Categorical covariates to condition on\n        \"\"\"", "\n", "x_", "=", "x", "\n", "y_", "=", "y", "\n", "if", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "library_gene", "=", "x", ".", "sum", "(", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "", "if", "self", ".", "log_variational", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x_", ")", "\n", "y_", "=", "torch", ".", "log", "(", "1", "+", "y_", ")", "\n", "\n", "", "if", "cont_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", "is", "True", ":", "\n", "            ", "encoder_input", "=", "torch", ".", "cat", "(", "(", "x_", ",", "y_", ",", "cont_covs", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "encoder_input", "=", "torch", ".", "cat", "(", "(", "x_", ",", "y_", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "if", "cat_covs", "is", "not", "None", "and", "self", ".", "encode_covariates", "is", "True", ":", "\n", "            ", "categorical_input", "=", "torch", ".", "split", "(", "cat_covs", ",", "1", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "categorical_input", "=", "tuple", "(", ")", "\n", "", "qz", ",", "ql", ",", "latent", ",", "untran_latent", "=", "self", ".", "encoder", "(", "\n", "encoder_input", ",", "batch_index", ",", "*", "categorical_input", "\n", ")", "\n", "\n", "z", "=", "latent", "[", "\"z\"", "]", "\n", "untran_z", "=", "untran_latent", "[", "\"z\"", "]", "\n", "untran_l", "=", "untran_latent", "[", "\"l\"", "]", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "library_gene", "=", "latent", "[", "\"l\"", "]", "\n", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "            ", "untran_z", "=", "qz", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "z", "=", "self", ".", "encoder", ".", "z_transformation", "(", "untran_z", ")", "\n", "\n", "untran_l", "=", "ql", ".", "sample", "(", "(", "n_samples", ",", ")", ")", "\n", "if", "self", ".", "use_observed_lib_size", ":", "\n", "                ", "library_gene", "=", "library_gene", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "\n", "(", "n_samples", ",", "library_gene", ".", "size", "(", "0", ")", ",", "library_gene", ".", "size", "(", "1", ")", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "library_gene", "=", "self", ".", "encoder", ".", "l_transformation", "(", "untran_l", ")", "\n", "\n", "# Background regularization", "\n", "", "", "if", "self", ".", "gene_dispersion", "==", "\"gene-label\"", ":", "\n", "# px_r gets transposed - last dimension is nb genes", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "label", ",", "self", ".", "n_labels", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "gene_dispersion", "==", "\"gene\"", ":", "\n", "            ", "px_r", "=", "self", ".", "px_r", "\n", "", "px_r", "=", "torch", ".", "exp", "(", "px_r", ")", "\n", "\n", "if", "self", ".", "protein_dispersion", "==", "\"protein-label\"", ":", "\n", "# py_r gets transposed - last dimension is n_proteins", "\n", "            ", "py_r", "=", "F", ".", "linear", "(", "one_hot", "(", "label", ",", "self", ".", "n_labels", ")", ",", "self", ".", "py_r", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein-batch\"", ":", "\n", "            ", "py_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "py_r", ")", "\n", "", "elif", "self", ".", "protein_dispersion", "==", "\"protein\"", ":", "\n", "            ", "py_r", "=", "self", ".", "py_r", "\n", "", "py_r", "=", "torch", ".", "exp", "(", "py_r", ")", "\n", "if", "self", ".", "n_batch", ">", "0", ":", "\n", "            ", "py_back_alpha_prior", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "background_pro_alpha", "\n", ")", "\n", "py_back_beta_prior", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "\n", "torch", ".", "exp", "(", "self", ".", "background_pro_log_beta", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "py_back_alpha_prior", "=", "self", ".", "background_pro_alpha", "\n", "py_back_beta_prior", "=", "torch", ".", "exp", "(", "self", ".", "background_pro_log_beta", ")", "\n", "", "self", ".", "back_mean_prior", "=", "Normal", "(", "py_back_alpha_prior", ",", "py_back_beta_prior", ")", "\n", "\n", "return", "dict", "(", "\n", "qz", "=", "qz", ",", "\n", "z", "=", "z", ",", "\n", "untran_z", "=", "untran_z", ",", "\n", "ql", "=", "ql", ",", "\n", "library_gene", "=", "library_gene", ",", "\n", "untran_l", "=", "untran_l", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.loss": [[553, 653], ["_totalvae.TOTALVAE.get_reconstruction_loss", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "dict", "dict", "scvi.module.base.LossRecorder", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.distributions.Normal", "torch.distributions.Normal", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.distributions.kl_divergence.sum.masked_scatter_", "torch.distributions.kl_divergence.sum.sum", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "scvi.nn.one_hot", "scvi.nn.one_hot", "torch.zeros_like.bool", "torch.zeros_like.bool", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "_totalvae.TOTALVAE.protein_batch_mask[].astype", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.Normal", "torch.distributions.Normal", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "b.item"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_reconstruction_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "pro_recons_weight", "=", "1.0", ",", "# double check these defaults", "\n", "kl_weight", "=", "1.0", ",", "\n", ")", "->", "Tuple", "[", "\n", "torch", ".", "FloatTensor", ",", "torch", ".", "FloatTensor", ",", "torch", ".", "FloatTensor", ",", "torch", ".", "FloatTensor", "\n", "]", ":", "\n", "        ", "\"\"\"\n        Returns the reconstruction loss and the Kullback divergences.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input_genes)``\n        y\n            tensor of values with shape ``(batch_size, n_input_proteins)``\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        label\n            tensor of cell-types labels with shape (batch_size, n_labels)\n\n        Returns\n        -------\n        type\n            the reconstruction loss and the Kullback divergences\n        \"\"\"", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "px_", "=", "generative_outputs", "[", "\"px_\"", "]", "\n", "py_", "=", "generative_outputs", "[", "\"py_\"", "]", "\n", "\n", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "]", "\n", "\n", "if", "self", ".", "protein_batch_mask", "is", "not", "None", ":", "\n", "            ", "pro_batch_mask_minibatch", "=", "torch", ".", "zeros_like", "(", "y", ")", "\n", "for", "b", "in", "torch", ".", "unique", "(", "batch_index", ")", ":", "\n", "                ", "b_indices", "=", "(", "batch_index", "==", "b", ")", ".", "reshape", "(", "-", "1", ")", "\n", "pro_batch_mask_minibatch", "[", "b_indices", "]", "=", "torch", ".", "tensor", "(", "\n", "self", ".", "protein_batch_mask", "[", "b", ".", "item", "(", ")", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "device", "=", "y", ".", "device", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "pro_batch_mask_minibatch", "=", "None", "\n", "\n", "", "reconst_loss_gene", ",", "reconst_loss_protein", "=", "self", ".", "get_reconstruction_loss", "(", "\n", "x", ",", "y", ",", "px_", ",", "py_", ",", "pro_batch_mask_minibatch", "\n", ")", "\n", "\n", "# KL Divergence", "\n", "kl_div_z", "=", "kl", "(", "qz", ",", "Normal", "(", "0", ",", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "            ", "n_batch", "=", "self", ".", "library_log_means", ".", "shape", "[", "1", "]", "\n", "local_library_log_means", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_means", "\n", ")", "\n", "local_library_log_vars", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_vars", "\n", ")", "\n", "kl_div_l_gene", "=", "kl", "(", "\n", "ql", ",", "\n", "Normal", "(", "local_library_log_means", ",", "torch", ".", "sqrt", "(", "local_library_log_vars", ")", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_div_l_gene", "=", "0.0", "\n", "\n", "", "kl_div_back_pro_full", "=", "kl", "(", "\n", "Normal", "(", "py_", "[", "\"back_alpha\"", "]", ",", "py_", "[", "\"back_beta\"", "]", ")", ",", "self", ".", "back_mean_prior", "\n", ")", "\n", "if", "pro_batch_mask_minibatch", "is", "not", "None", ":", "\n", "            ", "kl_div_back_pro", "=", "torch", ".", "zeros_like", "(", "kl_div_back_pro_full", ")", "\n", "kl_div_back_pro", ".", "masked_scatter_", "(", "\n", "pro_batch_mask_minibatch", ".", "bool", "(", ")", ",", "kl_div_back_pro_full", "\n", ")", "\n", "kl_div_back_pro", "=", "kl_div_back_pro", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_div_back_pro", "=", "kl_div_back_pro_full", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "loss", "=", "torch", ".", "mean", "(", "\n", "reconst_loss_gene", "\n", "+", "pro_recons_weight", "*", "reconst_loss_protein", "\n", "+", "kl_weight", "*", "kl_div_z", "\n", "+", "kl_div_l_gene", "\n", "+", "kl_weight", "*", "kl_div_back_pro", "\n", ")", "\n", "\n", "reconst_losses", "=", "dict", "(", "\n", "reconst_loss_gene", "=", "reconst_loss_gene", ",", "\n", "reconst_loss_protein", "=", "reconst_loss_protein", ",", "\n", ")", "\n", "kl_local", "=", "dict", "(", "\n", "kl_div_z", "=", "kl_div_z", ",", "\n", "kl_div_l_gene", "=", "kl_div_l_gene", ",", "\n", "kl_div_back_pro", "=", "kl_div_back_pro", ",", "\n", ")", "\n", "\n", "return", "LossRecorder", "(", "loss", ",", "reconst_losses", ",", "kl_local", ",", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.sample": [[654, 678], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "dict", "scvi.distributions.NegativeBinomial", "scvi.distributions.NegativeBinomialMixture", "scvi.distributions.NegativeBinomial.sample().cpu", "scvi.distributions.NegativeBinomialMixture.sample().cpu", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "_totalvae.TOTALVAE.forward", "scvi.distributions.NegativeBinomial.sample", "scvi.distributions.NegativeBinomialMixture.sample"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "sample", "(", "self", ",", "tensors", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "inference_outputs", ",", "generative_outputs", ",", "=", "self", ".", "forward", "(", "\n", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "\n", "", "px_", "=", "generative_outputs", "[", "\"px_\"", "]", "\n", "py_", "=", "generative_outputs", "[", "\"py_\"", "]", "\n", "\n", "rna_dist", "=", "NegativeBinomial", "(", "mu", "=", "px_", "[", "\"rate\"", "]", ",", "theta", "=", "px_", "[", "\"r\"", "]", ")", "\n", "protein_dist", "=", "NegativeBinomialMixture", "(", "\n", "mu1", "=", "py_", "[", "\"rate_back\"", "]", ",", "\n", "mu2", "=", "py_", "[", "\"rate_fore\"", "]", ",", "\n", "theta1", "=", "py_", "[", "\"r\"", "]", ",", "\n", "mixture_logits", "=", "py_", "[", "\"mixing\"", "]", ",", "\n", ")", "\n", "rna_sample", "=", "rna_dist", ".", "sample", "(", ")", ".", "cpu", "(", ")", "\n", "protein_sample", "=", "protein_dist", ".", "sample", "(", ")", ".", "cpu", "(", ")", "\n", "\n", "return", "rna_sample", ",", "protein_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.marginal_ll": [[679, 739], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "_totalvae.TOTALVAE.forward", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "_totalvae.TOTALVAE.back_mean_prior.log_prob().sum", "qz.log_prob().sum", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "numpy.log", "x.size", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.distributions.Normal().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "ql.log_prob().sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "scvi.nn.one_hot", "scvi.nn.one_hot", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "_totalvae.TOTALVAE.back_mean_prior.log_prob", "qz.log_prob", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "torch.distributions.Normal().log_prob", "ql.log_prob", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.Normal", "torch.linear.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "@", "auto_move_data", "\n", "def", "marginal_ll", "(", "self", ",", "tensors", ",", "n_mc_samples", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "to_sum", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", ")", "[", "0", "]", ",", "n_mc_samples", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_mc_samples", ")", ":", "\n", "# Distribution parameters and sampled variables", "\n", "            ", "inference_outputs", ",", "generative_outputs", ",", "losses", "=", "self", ".", "forward", "(", "tensors", ")", "\n", "# outputs = self.module.inference(x, y, batch_index, labels)", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "py_", "=", "generative_outputs", "[", "\"py_\"", "]", "\n", "log_library", "=", "inference_outputs", "[", "\"untran_l\"", "]", "\n", "# really need not softmax transformed random variable", "\n", "z", "=", "inference_outputs", "[", "\"untran_z\"", "]", "\n", "log_pro_back_mean", "=", "generative_outputs", "[", "\"log_pro_back_mean\"", "]", "\n", "\n", "# Reconstruction Loss", "\n", "reconst_loss", "=", "losses", ".", "_reconstruction_loss", "\n", "reconst_loss_gene", "=", "reconst_loss", "[", "\"reconst_loss_gene\"", "]", "\n", "reconst_loss_protein", "=", "reconst_loss", "[", "\"reconst_loss_protein\"", "]", "\n", "\n", "# Log-probabilities", "\n", "log_prob_sum", "=", "torch", ".", "zeros", "(", "qz", ".", "loc", ".", "shape", "[", "0", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "                ", "n_batch", "=", "self", ".", "library_log_means", ".", "shape", "[", "1", "]", "\n", "local_library_log_means", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_means", "\n", ")", "\n", "local_library_log_vars", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "n_batch", ")", ",", "self", ".", "library_log_vars", "\n", ")", "\n", "p_l_gene", "=", "(", "\n", "Normal", "(", "local_library_log_means", ",", "local_library_log_vars", ".", "sqrt", "(", ")", ")", "\n", ".", "log_prob", "(", "log_library", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "q_l_x", "=", "ql", ".", "log_prob", "(", "log_library", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "log_prob_sum", "+=", "p_l_gene", "-", "q_l_x", "\n", "\n", "", "p_z", "=", "Normal", "(", "0", ",", "1", ")", ".", "log_prob", "(", "z", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "p_mu_back", "=", "self", ".", "back_mean_prior", ".", "log_prob", "(", "log_pro_back_mean", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "p_xy_zl", "=", "-", "(", "reconst_loss_gene", "+", "reconst_loss_protein", ")", "\n", "q_z_x", "=", "qz", ".", "log_prob", "(", "z", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "q_mu_back", "=", "(", "\n", "Normal", "(", "py_", "[", "\"back_alpha\"", "]", ",", "py_", "[", "\"back_beta\"", "]", ")", "\n", ".", "log_prob", "(", "log_pro_back_mean", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "log_prob_sum", "+=", "p_z", "+", "p_mu_back", "+", "p_xy_zl", "-", "q_z_x", "-", "q_mu_back", "\n", "\n", "to_sum", "[", ":", ",", "i", "]", "=", "log_prob_sum", "\n", "\n", "", "batch_log_lkl", "=", "torch", ".", "logsumexp", "(", "to_sum", ",", "dim", "=", "-", "1", ")", "-", "np", ".", "log", "(", "n_mc_samples", ")", "\n", "log_lkl", "=", "torch", ".", "sum", "(", "batch_log_lkl", ")", ".", "item", "(", ")", "\n", "return", "log_lkl", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.Dense.__init__": [[15, 22], ["flax.linen.initializers.variance_scaling", "kwargs.update", "flax.linen.Dense.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# scale set to reimplement pytorch init", "\n", "        ", "scale", "=", "1", "/", "3", "\n", "kernel_init", "=", "variance_scaling", "(", "scale", ",", "\"fan_in\"", ",", "\"uniform\"", ")", "\n", "# bias init can't see input shape so don't include here", "\n", "kwargs", ".", "update", "(", "{", "\"kernel_init\"", ":", "kernel_init", "}", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.FlaxEncoder.setup": [[31, 46], ["_jaxvae.Dense", "_jaxvae.Dense", "_jaxvae.Dense", "_jaxvae.Dense", "flax.linen.BatchNorm", "flax.linen.BatchNorm", "flax.linen.Dropout", "flax.linen.Dropout"], "methods", ["None"], ["def", "setup", "(", "self", ")", ":", "\n", "        ", "self", ".", "dense1", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense2", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense3", "=", "Dense", "(", "self", ".", "n_latent", ")", "\n", "self", ".", "dense4", "=", "Dense", "(", "self", ".", "n_latent", ")", "\n", "\n", "is_eval", "=", "not", "self", ".", "is_training", "\n", "self", ".", "batchnorm1", "=", "nn", ".", "BatchNorm", "(", "\n", "momentum", "=", "0.99", ",", "epsilon", "=", "0.001", ",", "use_running_average", "=", "is_eval", "\n", ")", "\n", "self", ".", "batchnorm2", "=", "nn", ".", "BatchNorm", "(", "\n", "momentum", "=", "0.99", ",", "epsilon", "=", "0.001", ",", "use_running_average", "=", "is_eval", "\n", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ",", "deterministic", "=", "is_eval", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ",", "deterministic", "=", "is_eval", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.FlaxEncoder.__call__": [[47, 64], ["jax.log1p", "jax.log1p", "_jaxvae.FlaxEncoder.dense1", "_jaxvae.FlaxEncoder.batchnorm1", "flax.linen.relu", "_jaxvae.FlaxEncoder.dropout1", "_jaxvae.FlaxEncoder.dense2", "_jaxvae.FlaxEncoder.batchnorm2", "flax.linen.relu", "_jaxvae.FlaxEncoder.dropout2", "_jaxvae.FlaxEncoder.dense3", "_jaxvae.FlaxEncoder.dense4", "jax.exp", "jax.exp"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ":", "jnp", ".", "ndarray", ")", ":", "\n", "\n", "        ", "x_", "=", "jnp", ".", "log1p", "(", "x", ")", "\n", "\n", "h", "=", "self", ".", "dense1", "(", "x_", ")", "\n", "h", "=", "self", ".", "batchnorm1", "(", "h", ")", "\n", "h", "=", "nn", ".", "relu", "(", "h", ")", "\n", "h", "=", "self", ".", "dropout1", "(", "h", ")", "\n", "h", "=", "self", ".", "dense2", "(", "h", ")", "\n", "h", "=", "self", ".", "batchnorm2", "(", "h", ")", "\n", "h", "=", "nn", ".", "relu", "(", "h", ")", "\n", "h", "=", "self", ".", "dropout2", "(", "h", ")", "\n", "\n", "mean", "=", "self", ".", "dense3", "(", "h", ")", "\n", "log_var", "=", "self", ".", "dense4", "(", "h", ")", "\n", "\n", "return", "mean", ",", "jnp", ".", "exp", "(", "log_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.FlaxDecoder.setup": [[72, 91], ["_jaxvae.Dense", "_jaxvae.Dense", "_jaxvae.Dense", "_jaxvae.Dense", "_jaxvae.Dense", "flax.linen.BatchNorm", "flax.linen.BatchNorm", "flax.linen.Dropout", "flax.linen.Dropout", "_jaxvae.FlaxDecoder.param", "jax.random.normal", "jax.random.normal", "jax.random.normal", "jax.random.normal"], "methods", ["None"], ["def", "setup", "(", "self", ")", ":", "\n", "        ", "self", ".", "dense1", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense2", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense3", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense4", "=", "Dense", "(", "self", ".", "n_hidden", ")", "\n", "self", ".", "dense5", "=", "Dense", "(", "self", ".", "n_input", ")", "\n", "\n", "is_eval", "=", "not", "self", ".", "is_training", "\n", "self", ".", "batchnorm1", "=", "nn", ".", "BatchNorm", "(", "\n", "momentum", "=", "0.99", ",", "epsilon", "=", "0.001", ",", "use_running_average", "=", "is_eval", "\n", ")", "\n", "self", ".", "batchnorm2", "=", "nn", ".", "BatchNorm", "(", "\n", "momentum", "=", "0.99", ",", "epsilon", "=", "0.001", ",", "use_running_average", "=", "is_eval", "\n", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ",", "deterministic", "=", "is_eval", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ",", "deterministic", "=", "is_eval", ")", "\n", "\n", "self", ".", "disp", "=", "self", ".", "param", "(", "\n", "\"disp\"", ",", "lambda", "rng", ",", "shape", ":", "jax", ".", "random", ".", "normal", "(", "rng", ",", "shape", ")", ",", "(", "self", ".", "n_input", ",", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.FlaxDecoder.__call__": [[93, 109], ["_jaxvae.FlaxDecoder.dense1", "_jaxvae.FlaxDecoder.dense2", "_jaxvae.FlaxDecoder.batchnorm1", "flax.linen.relu", "_jaxvae.FlaxDecoder.dropout1", "_jaxvae.FlaxDecoder.dense3", "_jaxvae.FlaxDecoder.dense4", "_jaxvae.FlaxDecoder.batchnorm2", "flax.linen.relu", "_jaxvae.FlaxDecoder.dropout2", "_jaxvae.FlaxDecoder.dense5", "_jaxvae.FlaxDecoder.disp.ravel"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "z", ":", "jnp", ".", "ndarray", ",", "batch", ":", "jnp", ".", "ndarray", ")", ":", "\n", "\n", "        ", "h", "=", "self", ".", "dense1", "(", "z", ")", "\n", "h", "+=", "self", ".", "dense2", "(", "batch", ")", "\n", "\n", "h", "=", "self", ".", "batchnorm1", "(", "h", ")", "\n", "h", "=", "nn", ".", "relu", "(", "h", ")", "\n", "h", "=", "self", ".", "dropout1", "(", "h", ")", "\n", "h", "=", "self", ".", "dense3", "(", "h", ")", "\n", "# skip connection", "\n", "h", "+=", "self", ".", "dense4", "(", "batch", ")", "\n", "h", "=", "self", ".", "batchnorm2", "(", "h", ")", "\n", "h", "=", "nn", ".", "relu", "(", "h", ")", "\n", "h", "=", "self", ".", "dropout2", "(", "h", ")", "\n", "h", "=", "self", ".", "dense5", "(", "h", ")", "\n", "return", "h", ",", "self", ".", "disp", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE.setup": [[122, 136], ["_jaxvae.FlaxEncoder", "_jaxvae.FlaxDecoder"], "methods", ["None"], ["def", "setup", "(", "self", ")", ":", "\n", "        ", "self", ".", "encoder", "=", "FlaxEncoder", "(", "\n", "n_input", "=", "self", ".", "n_input", ",", "\n", "n_latent", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "dropout_rate", "=", "self", ".", "dropout_rate", ",", "\n", "is_training", "=", "self", ".", "is_training", ",", "\n", ")", "\n", "\n", "self", ".", "decoder", "=", "FlaxDecoder", "(", "\n", "n_input", "=", "self", ".", "n_input", ",", "\n", "dropout_rate", "=", "0.0", ",", "\n", "n_hidden", "=", "self", ".", "n_hidden", ",", "\n", "is_training", "=", "self", ".", "is_training", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE.required_rngs": [[138, 141], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "required_rngs", "(", "self", ")", ":", "\n", "        ", "return", "(", "\"params\"", ",", "\"dropout\"", ",", "\"z\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE._get_inference_input": [[142, 147], ["dict"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "\n", "input_dict", "=", "dict", "(", "x", "=", "x", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE.inference": [[148, 158], ["_jaxvae.JaxVAE.encoder", "numpyro.Normal", "_jaxvae.JaxVAE.make_rng", "numpyro.Normal.rsample", "dict", "jax.sqrt", "jax.sqrt"], "methods", ["None"], ["", "def", "inference", "(", "self", ",", "x", ":", "jnp", ".", "ndarray", ",", "n_samples", ":", "int", "=", "1", ")", "->", "dict", ":", "\n", "        ", "mean", ",", "var", "=", "self", ".", "encoder", "(", "x", ")", "\n", "stddev", "=", "jnp", ".", "sqrt", "(", "var", ")", "+", "self", ".", "eps", "\n", "\n", "qz", "=", "dist", ".", "Normal", "(", "mean", ",", "stddev", ")", "\n", "z_rng", "=", "self", ".", "make_rng", "(", "\"z\"", ")", "\n", "sample_shape", "=", "(", ")", "if", "n_samples", "==", "1", "else", "(", "n_samples", ",", ")", "\n", "z", "=", "qz", ".", "rsample", "(", "z_rng", ",", "sample_shape", "=", "sample_shape", ")", "\n", "\n", "return", "dict", "(", "qz", "=", "qz", ",", "z", "=", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE._get_generative_input": [[159, 174], ["dict"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "\n", "self", ",", "\n", "tensors", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "inference_outputs", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "input_dict", "=", "dict", "(", "\n", "x", "=", "x", ",", "\n", "z", "=", "z", ",", "\n", "batch_index", "=", "batch_index", ",", "\n", ")", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE.generative": [[175, 191], ["jax.nn.one_hot().squeeze", "jax.nn.one_hot().squeeze", "jax.nn.one_hot().squeeze", "jax.nn.one_hot().squeeze", "_jaxvae.JaxVAE.decoder", "jax.exp", "jax.exp", "jax.nn.softmax", "jax.nn.softmax", "jax.nn.softmax", "jax.nn.softmax", "dict", "x.sum", "jax.exp", "jax.exp", "scvi.distributions.JaxNegativeBinomialMeanDisp", "numpyro.Poisson", "jax.nn.one_hot", "jax.nn.one_hot", "jax.nn.one_hot", "jax.nn.one_hot"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "def", "generative", "(", "self", ",", "x", ",", "z", ",", "batch_index", ")", "->", "dict", ":", "\n", "# one hot adds an extra dimension", "\n", "        ", "batch", "=", "jax", ".", "nn", ".", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ".", "squeeze", "(", "-", "2", ")", "\n", "rho_unnorm", ",", "disp", "=", "self", ".", "decoder", "(", "z", ",", "batch", ")", "\n", "disp_", "=", "jnp", ".", "exp", "(", "disp", ")", "\n", "rho", "=", "jax", ".", "nn", ".", "softmax", "(", "rho_unnorm", ",", "axis", "=", "-", "1", ")", "\n", "total_count", "=", "x", ".", "sum", "(", "-", "1", ")", "[", ":", ",", "jnp", ".", "newaxis", "]", "\n", "mu", "=", "total_count", "*", "rho", "\n", "\n", "if", "self", ".", "gene_likelihood", "==", "\"nb\"", ":", "\n", "            ", "disp_", "=", "jnp", ".", "exp", "(", "disp", ")", "\n", "px", "=", "NegativeBinomial", "(", "mean", "=", "mu", ",", "inverse_dispersion", "=", "disp_", ")", "\n", "", "else", ":", "\n", "            ", "px", "=", "dist", ".", "Poisson", "(", "mu", ")", "\n", "\n", "", "return", "dict", "(", "px", "=", "px", ",", "rho", "=", "rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.module._jaxvae.JaxVAE.loss": [[192, 212], ["numpyro.kl_divergence().sum", "jax.mean", "jax.mean", "scvi.module.base.LossRecorder", "px.log_prob().sum", "numpyro.kl_divergence", "px.log_prob", "numpyro.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "px", "=", "generative_outputs", "[", "\"px\"", "]", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "reconst_loss", "=", "-", "px", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "-", "1", ")", "\n", "kl_divergence_z", "=", "dist", ".", "kl_divergence", "(", "qz", ",", "dist", ".", "Normal", "(", "0", ",", "1", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "kl_local_for_warmup", "=", "kl_divergence_z", "\n", "weighted_kl_local", "=", "kl_weight", "*", "kl_local_for_warmup", "\n", "\n", "loss", "=", "jnp", ".", "mean", "(", "reconst_loss", "+", "weighted_kl_local", ")", "\n", "\n", "kl_local", "=", "kl_divergence_z", "\n", "return", "LossRecorder", "(", "loss", ",", "reconst_loss", ",", "kl_local", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder.__init__": [[43, 78], ["kwargs.items", "isinstance", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "jax.array", "isinstance", "dict", "isinstance", "dict", "isinstance", "dict", "isinstance", "dict", "setattr", "_base_module.LossRecorder.extra_metric_attrs.append"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "loss", ":", "LossRecord", ",", "\n", "reconstruction_loss", ":", "Optional", "[", "LossRecord", "]", "=", "None", ",", "\n", "kl_local", ":", "Optional", "[", "LossRecord", "]", "=", "None", ",", "\n", "kl_global", ":", "Optional", "[", "LossRecord", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "\n", "        ", "default", "=", "(", "\n", "torch", ".", "tensor", "(", "0.0", ")", "if", "isinstance", "(", "loss", ",", "torch", ".", "Tensor", ")", "else", "jnp", ".", "array", "(", "0.0", ")", "\n", ")", "\n", "if", "reconstruction_loss", "is", "None", ":", "\n", "            ", "reconstruction_loss", "=", "default", "\n", "", "if", "kl_local", "is", "None", ":", "\n", "            ", "kl_local", "=", "default", "\n", "", "if", "kl_global", "is", "None", ":", "\n", "            ", "kl_global", "=", "default", "\n", "\n", "", "self", ".", "_loss", "=", "loss", "if", "isinstance", "(", "loss", ",", "dict", ")", "else", "dict", "(", "loss", "=", "loss", ")", "\n", "self", ".", "_reconstruction_loss", "=", "(", "\n", "reconstruction_loss", "\n", "if", "isinstance", "(", "reconstruction_loss", ",", "dict", ")", "\n", "else", "dict", "(", "reconstruction_loss", "=", "reconstruction_loss", ")", "\n", ")", "\n", "self", ".", "_kl_local", "=", "(", "\n", "kl_local", "if", "isinstance", "(", "kl_local", ",", "dict", ")", "else", "dict", "(", "kl_local", "=", "kl_local", ")", "\n", ")", "\n", "self", ".", "_kl_global", "=", "(", "\n", "kl_global", "if", "isinstance", "(", "kl_global", ",", "dict", ")", "else", "dict", "(", "kl_global", "=", "kl_global", ")", "\n", ")", "\n", "self", ".", "extra_metric_attrs", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "key", ",", "value", ")", "\n", "self", ".", "extra_metric_attrs", ".", "append", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder._get_dict_sum": [[79, 85], ["dictionary.values"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_get_dict_sum", "(", "dictionary", ")", ":", "\n", "        ", "total", "=", "0.0", "\n", "for", "value", "in", "dictionary", ".", "values", "(", ")", ":", "\n", "            ", "total", "+=", "value", "\n", "", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder.loss": [[86, 89], ["_base_module.LossRecorder._get_dict_sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder._get_dict_sum"], ["", "@", "property", "\n", "def", "loss", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "_get_dict_sum", "(", "self", ".", "_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder.reconstruction_loss": [[90, 93], ["_base_module.LossRecorder._get_dict_sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder._get_dict_sum"], ["", "@", "property", "\n", "def", "reconstruction_loss", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "_get_dict_sum", "(", "self", ".", "_reconstruction_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder.kl_local": [[94, 97], ["_base_module.LossRecorder._get_dict_sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder._get_dict_sum"], ["", "@", "property", "\n", "def", "kl_local", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "_get_dict_sum", "(", "self", ".", "_kl_local", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder.kl_global": [[98, 101], ["_base_module.LossRecorder._get_dict_sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.LossRecorder._get_dict_sum"], ["", "@", "property", "\n", "def", "kl_global", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ":", "\n", "        ", "return", "self", ".", "_get_dict_sum", "(", "self", ".", "_kl_global", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.__init__": [[106, 110], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.device": [[111, 117], ["list", "set", "len", "RuntimeError", "_base_module.BaseModuleClass.parameters"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "device", "=", "list", "(", "set", "(", "p", ".", "device", "for", "p", "in", "self", ".", "parameters", "(", ")", ")", ")", "\n", "if", "len", "(", "device", ")", ">", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Module tensors on multiple devices.\"", ")", "\n", "", "return", "device", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.on_load": [[118, 123], ["None"], "methods", ["None"], ["", "def", "on_load", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"\n        Callback function run in :method:`~scvi.model.base.BaseModelClass.load` prior to loading module state dict.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.forward": [[124, 168], ["_base_module._generic_forward"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._generic_forward"], ["", "@", "auto_move_data", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "get_inference_input_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "get_generative_input_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "inference_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "generative_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "loss_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "compute_loss", "=", "True", ",", "\n", ")", "->", "Union", "[", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "LossRecorder", "]", ",", "\n", "]", ":", "\n", "        ", "\"\"\"\n        Forward pass through the network.\n\n        Parameters\n        ----------\n        tensors\n            tensors to pass through\n        get_inference_input_kwargs\n            Keyword args for ``_get_inference_input()``\n        get_generative_input_kwargs\n            Keyword args for ``_get_generative_input()``\n        inference_kwargs\n            Keyword args for ``inference()``\n        generative_kwargs\n            Keyword args for ``generative()``\n        loss_kwargs\n            Keyword args for ``loss()``\n        compute_loss\n            Whether to compute loss on forward pass. This adds\n            another return value.\n        \"\"\"", "\n", "return", "_generic_forward", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_kwargs", ",", "\n", "generative_kwargs", ",", "\n", "loss_kwargs", ",", "\n", "get_inference_input_kwargs", ",", "\n", "get_generative_input_kwargs", ",", "\n", "compute_loss", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass._get_inference_input": [[170, 173], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_inference_input", "(", "self", ",", "tensors", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Parse tensors dictionary for inference related values.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass._get_generative_input": [[174, 182], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_generative_input", "(", "\n", "self", ",", "\n", "tensors", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "inference_outputs", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Parse tensors dictionary for generative related values.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.inference": [[183, 199], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "inference", "(", "\n", "self", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "torch", ".", "distributions", ".", "Distribution", "]", "]", ":", "\n", "        ", "\"\"\"\n        Run the inference (recognition) model.\n\n        In the case of variational inference, this function will perform steps related to\n        computing variational distribution parameters. In a VAE, this will involve running\n        data through encoder networks.\n\n        This function should return a dictionary with str keys and :class:`~torch.Tensor` values.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.generative": [[200, 213], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "generative", "(", "\n", "self", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "torch", ".", "distributions", ".", "Distribution", "]", "]", ":", "\n", "        ", "\"\"\"\n        Run the generative model.\n\n        This function should return the parameters associated with the likelihood of the data.\n        This is typically written as :math:`p(x|z)`.\n\n        This function should return a dictionary with str keys and :class:`~torch.Tensor` values.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.loss": [[214, 225], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "loss", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "->", "LossRecorder", ":", "\n", "        ", "\"\"\"\n        Compute the loss for a minibatch of data.\n\n        This function uses the outputs of the inference and generative functions to compute\n        a loss. This many optionally include other penalty terms, which should be computed here.\n\n        This function should return an object of type :class:`~scvi.module.base.LossRecorder`.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.BaseModuleClass.sample": [[226, 230], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "sample", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate samples from the learned model.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.__init__": [[263, 266], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "on_load_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "on_load_kwargs", "=", "on_load_kwargs", "or", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass._get_fn_args_from_batch": [[267, 284], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "_get_fn_args_from_batch", "(", "\n", "tensor_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "\n", ")", "->", "Union", "[", "Iterable", ",", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Parse the minibatched data to get the correct inputs for ``model`` and ``guide``.\n\n        In Pyro, ``model`` and ``guide`` must have the same signature. This is a helper method\n        that gets the args and kwargs for these two methods. This helper method aids ``forward`` and\n        ``guide`` in having transparent signatures, as well as allows use of our generic\n        :class:`~scvi.dataloaders.AnnDataLoader`.\n\n        Returns\n        -------\n        args and kwargs for the functions, args should be an Iterable and kwargs a dictionary.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.model": [[285, 289], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "model", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.guide": [[290, 294], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "guide", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.list_obs_plate_vars": [[295, 310], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "list_obs_plate_vars", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Model annotation for minibatch training with pyro plate.\n\n        A dictionary with:\n        1. \"name\" - the name of observation/minibatch plate;\n        2. \"in\" - indexes of model args to provide to encoder network when using amortised inference;\n        3. \"sites\" - dictionary with\n            keys - names of variables that belong to the observation plate (used to recognise\n             and merge posterior samples for minibatch variables)\n            values - the dimensions in non-plate axis of each variable (used to construct output\n             layer of encoder network when using amortised inference)\n        \"\"\"", "\n", "return", "{", "\"name\"", ":", "\"\"", ",", "\"in\"", ":", "[", "]", ",", "\"sites\"", ":", "{", "}", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.on_load": [[311, 321], ["model.history_.copy", "model.train", "pyro.clear_param_store"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "on_load", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"\n        Callback function run in :method:`~scvi.model.base.BaseModelClass.load` prior to loading module state dict.\n\n        For some Pyro modules with AutoGuides, run one training step prior to loading state dict.\n        \"\"\"", "\n", "old_history", "=", "model", ".", "history_", ".", "copy", "(", ")", "\n", "model", ".", "train", "(", "max_steps", "=", "1", ",", "**", "self", ".", "on_load_kwargs", ")", "\n", "model", ".", "history_", "=", "old_history", "\n", "pyro", ".", "clear_param_store", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.create_predictive": [[322, 371], ["_pyro.AutoMoveDataPredictive", "_pyro.AutoMoveDataPredictive.eval"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval"], ["", "def", "create_predictive", "(", "\n", "self", ",", "\n", "model", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "posterior_samples", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "guide", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "num_samples", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_sites", ":", "Tuple", "[", "str", "]", "=", "(", ")", ",", "\n", "parallel", ":", "bool", "=", "False", ",", "\n", ")", "->", "Predictive", ":", "\n", "        ", "\"\"\"\n        Creates a :class:`~pyro.infer.Predictive` object.\n\n        Parameters\n        ----------\n        model\n            Python callable containing Pyro primitives. Defaults to ``self.model``.\n        posterior_samples\n            Dictionary of samples from the posterior\n        guide\n            Optional guide to get posterior samples of sites not present\n            in ``posterior_samples``. Defaults to ``self.guide``\n        num_samples\n            Number of samples to draw from the predictive distribution.\n            This argument has no effect if ``posterior_samples`` is non-empty, in which case,\n            the leading dimension size of samples in ``posterior_samples`` is used.\n        return_sites\n            Sites to return; by default only sample sites not present\n            in ``posterior_samples`` are returned.\n        parallel\n            predict in parallel by wrapping the existing model\n            in an outermost ``plate`` messenger. Note that this requires that the model has\n            all batch dims correctly annotated via :class:`~pyro.plate`.\n        \"\"\"", "\n", "if", "model", "is", "None", ":", "\n", "            ", "model", "=", "self", ".", "model", "\n", "", "if", "guide", "is", "None", ":", "\n", "            ", "guide", "=", "self", ".", "guide", "\n", "", "predictive", "=", "AutoMoveDataPredictive", "(", "\n", "model", "=", "model", ",", "\n", "posterior_samples", "=", "posterior_samples", ",", "\n", "guide", "=", "guide", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "return_sites", "=", "return_sites", ",", "\n", "parallel", "=", "parallel", ",", "\n", ")", "\n", "# necessary to comply with auto_move_data decorator", "\n", "predictive", ".", "eval", "(", ")", "\n", "\n", "return", "predictive", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.forward": [[372, 375], ["_base_module.PyroBaseModuleClass.model"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.model"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Passthrough to Pyro model.\"\"\"", "\n", "return", "self", ".", "model", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.setup": [[380, 392], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "setup", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Flax setup method.\n\n        With scvi-tools we prefer to use the setup parameterization of\n        flax.linen Modules. This lends the interface to be more like\n        PyTorch. More about this can be found here:\n\n        https://flax.readthedocs.io/en/latest/design_notes/setup_or_nncompact.html\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.required_rngs": [[393, 398], ["tuple"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "required_rngs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns a tuple of rng sequence names required for this Flax module.\"\"\"", "\n", "return", "tuple", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.__call__": [[399, 442], ["_base_module._generic_forward"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._generic_forward"], ["", "def", "__call__", "(", "\n", "self", ",", "\n", "tensors", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "get_inference_input_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "get_generative_input_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "inference_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "generative_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "loss_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "compute_loss", "=", "True", ",", "\n", ")", "->", "Union", "[", "\n", "Tuple", "[", "jnp", ".", "ndarray", ",", "jnp", ".", "ndarray", "]", ",", "\n", "Tuple", "[", "jnp", ".", "ndarray", ",", "jnp", ".", "ndarray", ",", "LossRecorder", "]", ",", "\n", "]", ":", "\n", "        ", "\"\"\"\n        Forward pass through the network.\n\n        Parameters\n        ----------\n        tensors\n            tensors to pass through\n        get_inference_input_kwargs\n            Keyword args for ``_get_inference_input()``\n        get_generative_input_kwargs\n            Keyword args for ``_get_generative_input()``\n        inference_kwargs\n            Keyword args for ``inference()``\n        generative_kwargs\n            Keyword args for ``generative()``\n        loss_kwargs\n            Keyword args for ``loss()``\n        compute_loss\n            Whether to compute loss on forward pass. This adds\n            another return value.\n        \"\"\"", "\n", "return", "_generic_forward", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_kwargs", ",", "\n", "generative_kwargs", ",", "\n", "loss_kwargs", ",", "\n", "get_inference_input_kwargs", ",", "\n", "get_generative_input_kwargs", ",", "\n", "compute_loss", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass._get_inference_input": [[444, 447], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_inference_input", "(", "self", ",", "tensors", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Parse tensors dictionary for inference related values.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass._get_generative_input": [[448, 456], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_get_generative_input", "(", "\n", "self", ",", "\n", "tensors", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "inference_outputs", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Parse tensors dictionary for generative related values.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.inference": [[457, 473], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "inference", "(", "\n", "self", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "jnp", ".", "ndarray", ",", "Distribution", "]", "]", ":", "\n", "        ", "\"\"\"\n        Run the inference (recognition) model.\n\n        In the case of variational inference, this function will perform steps related to\n        computing variational distribution parameters. In a VAE, this will involve running\n        data through encoder networks.\n\n        This function should return a dictionary with str keys and :class:`~jnp.ndarray` values.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.generative": [[474, 487], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "generative", "(", "\n", "self", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "jnp", ".", "ndarray", ",", "Distribution", "]", "]", ":", "\n", "        ", "\"\"\"\n        Run the generative model.\n\n        This function should return the parameters associated with the likelihood of the data.\n        This is typically written as :math:`p(x|z)`.\n\n        This function should return a dictionary with str keys and :class:`~jnp.ndarray` values.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.loss": [[488, 499], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "loss", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "->", "LossRecorder", ":", "\n", "        ", "\"\"\"\n        Compute the loss for a minibatch of data.\n\n        This function uses the outputs of the inference and generative functions to compute\n        a loss. This many optionally include other penalty terms, which should be computed here.\n\n        This function should return an object of type :class:`~scvi.module.base.LossRecorder`.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.JaxBaseModuleClass.eval": [[500, 503], ["None"], "methods", ["None"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"No-op for PyTorch compatibility.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none": [[232, 236], ["isinstance"], "function", ["None"], ["", "", "def", "_get_dict_if_none", "(", "param", ")", ":", "\n", "    ", "param", "=", "{", "}", "if", "not", "isinstance", "(", "param", ",", "dict", ")", "else", "param", "\n", "\n", "return", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._generic_forward": [[505, 537], ["_base_module._get_dict_if_none", "_base_module._get_dict_if_none", "_base_module._get_dict_if_none", "_base_module._get_dict_if_none", "_base_module._get_dict_if_none", "module._get_inference_input", "module.inference", "module._get_generative_input", "module.generative", "module.loss"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module._get_dict_if_none", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.generative", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss"], ["", "", "def", "_generic_forward", "(", "\n", "module", ",", "\n", "tensors", ",", "\n", "inference_kwargs", ",", "\n", "generative_kwargs", ",", "\n", "loss_kwargs", ",", "\n", "get_inference_input_kwargs", ",", "\n", "get_generative_input_kwargs", ",", "\n", "compute_loss", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Core of the forward call shared by PyTorch- and Jax-based modules.\"\"\"", "\n", "inference_kwargs", "=", "_get_dict_if_none", "(", "inference_kwargs", ")", "\n", "generative_kwargs", "=", "_get_dict_if_none", "(", "generative_kwargs", ")", "\n", "loss_kwargs", "=", "_get_dict_if_none", "(", "loss_kwargs", ")", "\n", "get_inference_input_kwargs", "=", "_get_dict_if_none", "(", "get_inference_input_kwargs", ")", "\n", "get_generative_input_kwargs", "=", "_get_dict_if_none", "(", "get_generative_input_kwargs", ")", "\n", "\n", "inference_inputs", "=", "module", ".", "_get_inference_input", "(", "\n", "tensors", ",", "**", "get_inference_input_kwargs", "\n", ")", "\n", "inference_outputs", "=", "module", ".", "inference", "(", "**", "inference_inputs", ",", "**", "inference_kwargs", ")", "\n", "generative_inputs", "=", "module", ".", "_get_generative_input", "(", "\n", "tensors", ",", "inference_outputs", ",", "**", "get_generative_input_kwargs", "\n", ")", "\n", "generative_outputs", "=", "module", ".", "generative", "(", "**", "generative_inputs", ",", "**", "generative_kwargs", ")", "\n", "if", "compute_loss", ":", "\n", "        ", "losses", "=", "module", ".", "loss", "(", "\n", "tensors", ",", "inference_outputs", ",", "generative_outputs", ",", "**", "loss_kwargs", "\n", ")", "\n", "return", "inference_outputs", ",", "generative_outputs", ",", "losses", "\n", "", "else", ":", "\n", "        ", "return", "inference_outputs", ",", "generative_outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators.auto_move_data": [[9, 44], ["functools.wraps", "list", "_decorators._move_data_to_device", "_decorators._move_data_to_device", "fn", "isinstance", "fn", "fn", "set", "len", "RuntimeError", "_decorators..parameters"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._move_data_to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._move_data_to_device"], ["def", "auto_move_data", "(", "fn", ":", "Callable", ")", "->", "Callable", ":", "\n", "    ", "\"\"\"\n    Decorator for :class:`~torch.nn.Module` methods to move data to correct device.\n\n    Input arguments are moved automatically to the correct device.\n    It has no effect if applied to a method of an object that is not an instance of\n    :class:`~torch.nn.Module` and is typically applied to ``__call__``\n    or ``forward``.\n\n    Parameters\n    ----------\n    fn\n        A nn.Module method for which the arguments should be moved to the device\n        the parameters are on.\n    \"\"\"", "\n", "\n", "@", "wraps", "(", "fn", ")", "\n", "def", "auto_transfer_args", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "self", ",", "Module", ")", ":", "\n", "            ", "return", "fn", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# decorator only necessary after training", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "return", "fn", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "device", "=", "list", "(", "set", "(", "p", ".", "device", "for", "p", "in", "self", ".", "parameters", "(", ")", ")", ")", "\n", "if", "len", "(", "device", ")", ">", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Module tensors on multiple devices.\"", ")", "\n", "", "else", ":", "\n", "            ", "device", "=", "device", "[", "0", "]", "\n", "", "args", "=", "_move_data_to_device", "(", "args", ",", "device", ")", "\n", "kwargs", "=", "_move_data_to_device", "(", "kwargs", ",", "device", ")", "\n", "return", "fn", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "auto_transfer_args", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._move_data_to_device": [[46, 71], ["_decorators._apply_to_collection", "data.to", "isinstance", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._apply_to_collection", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "def", "_move_data_to_device", "(", "batch", ":", "Any", ",", "device", ":", "torch", ".", "device", ")", ":", "\n", "    ", "\"\"\"\n    Transfers a collection of data to the given device.\n\n    Any object that defines a method ``to(device)`` will be moved and all other objects\n    in the collection will be left untouched.\n\n    Parameters\n    ----------\n    batch\n        A tensor or collection of tensors or anything that has a method `.to(...)`.\n        See :func:`apply_to_collection` for a list of supported collection types.\n    device\n        The device to which the data should be moved\n\n    Returns\n    -------\n        The same collection but with all contained tensors residing on the new device.\n    \"\"\"", "\n", "\n", "def", "batch_to", "(", "data", ")", ":", "\n", "        ", "kwargs", "=", "dict", "(", "non_blocking", "=", "True", ")", "if", "isinstance", "(", "data", ",", "torch", ".", "Tensor", ")", "else", "{", "}", "\n", "return", "data", ".", "to", "(", "device", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "_apply_to_collection", "(", "batch", ",", "dtype", "=", "torch", ".", "Tensor", ",", "function", "=", "batch_to", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._apply_to_collection": [[73, 121], ["type", "isinstance", "function", "isinstance", "type.", "isinstance", "hasattr", "type.", "_decorators._apply_to_collection", "isinstance", "type.", "data.items", "isinstance", "_decorators._apply_to_collection", "_decorators._apply_to_collection"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._apply_to_collection", "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._apply_to_collection", "home.repos.pwc.inspect_result.YosefLab_scVI.base._decorators._apply_to_collection"], ["", "def", "_apply_to_collection", "(", "\n", "data", ":", "Any", ",", "dtype", ":", "Union", "[", "type", ",", "tuple", "]", ",", "function", ":", "Callable", ",", "*", "args", ",", "**", "kwargs", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"\n    Recursively applies a function to all elements of a certain dtype.\n\n    Parameters\n    ----------\n    data\n        The collection to apply the function to\n    dtype\n        The given function will be applied to all elements of this dtype\n    function\n        The function to apply\n    *args\n        positional arguments (will be forwarded to calls of ``function``)\n    **kwargs\n        keyword arguments (will be forwarded to calls of ``function``)\n\n    Returns\n    -------\n    The resulting collection\n    \"\"\"", "\n", "elem_type", "=", "type", "(", "data", ")", "\n", "\n", "# Breaking condition", "\n", "if", "isinstance", "(", "data", ",", "dtype", ")", ":", "\n", "        ", "return", "function", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "# Recursively apply to collection items", "\n", "", "elif", "isinstance", "(", "data", ",", "Mapping", ")", ":", "\n", "        ", "return", "elem_type", "(", "\n", "{", "\n", "k", ":", "_apply_to_collection", "(", "v", ",", "dtype", ",", "function", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "\n", "}", "\n", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "tuple", ")", "and", "hasattr", "(", "data", ",", "\"_fields\"", ")", ":", "# named tuple", "\n", "        ", "return", "elem_type", "(", "\n", "*", "(", "_apply_to_collection", "(", "d", ",", "dtype", ",", "function", ",", "*", "args", ",", "**", "kwargs", ")", "for", "d", "in", "data", ")", "\n", ")", "\n", "", "elif", "isinstance", "(", "data", ",", "Sequence", ")", "and", "not", "isinstance", "(", "data", ",", "str", ")", ":", "\n", "        ", "return", "elem_type", "(", "\n", "[", "_apply_to_collection", "(", "d", ",", "dtype", ",", "function", ",", "*", "args", ",", "**", "kwargs", ")", "for", "d", "in", "data", "]", "\n", ")", "\n", "\n", "# data is neither of dtype, nor a collection", "\n", "", "return", "data", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyro.AutoMoveDataPredictive.forward": [[7, 10], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["    ", "@", "auto_move_data", "\n", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "forward", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.__init__": [[40, 56], ["_jax_module_wrapper.JaxModuleWrapper._get_module", "scvi.utils._jax.device_selecting_PRNGKey", "_jax_module_wrapper.JaxModuleWrapper.key_fn", "_jax_module_wrapper.JaxModuleWrapper._set_rngs"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._get_module", "home.repos.pwc.inspect_result.YosefLab_scVI.utils._jax.device_selecting_PRNGKey", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._set_rngs"], ["def", "__init__", "(", "\n", "self", ",", "\n", "module_cls", ":", "JaxBaseModuleClass", ",", "\n", "seed", ":", "int", "=", "0", ",", "# switch to using a global scvi.settings seed that gets forked everytime a modulewrapper is initialized by default", "\n", "**", "module_kwargs", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "module_cls", "=", "module_cls", "\n", "self", ".", "module_kwargs", "=", "module_kwargs", "\n", "self", ".", "_module", "=", "self", ".", "_get_module", "(", ")", "\n", "self", ".", "_train_module", "=", "None", "\n", "self", ".", "_eval_module", "=", "None", "\n", "self", ".", "_train_state", "=", "None", "\n", "\n", "self", ".", "key_fn", "=", "device_selecting_PRNGKey", "(", ")", "\n", "self", ".", "seed_rng", "=", "self", ".", "key_fn", "(", "seed", ")", "\n", "self", ".", "_set_rngs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.on_load": [[57, 67], ["model.history_.copy", "model.train"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "@", "staticmethod", "\n", "def", "on_load", "(", "model", ")", ":", "\n", "        ", "\"\"\"\n        Callback function run in :method:`~scvi.model.base.BaseModelClass.load` prior to loading module state dict.\n\n        For some Pyro modules with AutoGuides, run one training step prior to loading state dict.\n        \"\"\"", "\n", "old_history", "=", "model", ".", "history_", ".", "copy", "(", ")", "\n", "model", ".", "train", "(", "max_steps", "=", "1", ")", "\n", "model", ".", "history_", "=", "old_history", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.device": [[68, 71], ["_jax_module_wrapper.JaxModuleWrapper.seed_rng.device"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "seed_rng", ".", "device", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module": [[72, 75], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "module", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_module", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._get_module": [[76, 82], ["_jax_module_wrapper.JaxModuleWrapper.module_cls"], "methods", ["None"], ["", "def", "_get_module", "(", "self", ",", "kwargs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Helper function to get or reinitialize the module with ``kwargs``.\"\"\"", "\n", "kwargs", "=", "(", "\n", "self", ".", "module_kwargs", "if", "kwargs", "is", "None", "else", "{", "**", "self", ".", "module_kwargs", ",", "**", "kwargs", "}", "\n", ")", "\n", "return", "self", ".", "module_cls", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval": [[83, 88], ["_jax_module_wrapper.JaxModuleWrapper._get_module", "dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._get_module"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"Switch to evaluation mode. Emulates Pytorch's interface.\"\"\"", "\n", "if", "self", ".", "_eval_module", "is", "None", ":", "\n", "            ", "self", ".", "_eval_module", "=", "self", ".", "_get_module", "(", "dict", "(", "is_training", "=", "False", ")", ")", "\n", "", "self", ".", "_module", "=", "self", ".", "_eval_module", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.train": [[89, 94], ["_jax_module_wrapper.JaxModuleWrapper._get_module", "dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._get_module"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Switch to train mode. Emulates Pytorch's interface.\"\"\"", "\n", "if", "self", ".", "_train_module", "is", "None", ":", "\n", "            ", "self", ".", "_train_module", "=", "self", ".", "_get_module", "(", "dict", "(", "is_training", "=", "True", ")", ")", "\n", "", "self", ".", "_module", "=", "self", ".", "_train_module", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._bound_module": [[95, 101], ["_jax_module_wrapper.JaxModuleWrapper.module.bind"], "methods", ["None"], ["", "@", "property", "\n", "def", "_bound_module", "(", "self", ")", ":", "\n", "        ", "\"\"\"Module bound with parameters learned from training.\"\"\"", "\n", "return", "self", ".", "module", ".", "bind", "(", "\n", "{", "\"params\"", ":", "self", ".", "params", ",", "\"batch_stats\"", ":", "self", ".", "batch_stats", "}", ",", "\n", "rngs", "=", "self", ".", "rngs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.get_inference_fn": [[103, 121], ["bound_module._get_inference_input", "bound_module.inference"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "def", "get_inference_fn", "(", "self", ",", "mc_samples", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Returns a method to run inference using the bound module.\n\n        Parameters\n        ----------\n        mc_samples\n            Number of Monte Carlo samples to run for each input.\n        \"\"\"", "\n", "bound_module", "=", "self", ".", "_bound_module", "\n", "\n", "@", "jax", ".", "jit", "\n", "def", "_run_inference", "(", "array_dict", ")", ":", "\n", "            ", "inference_input", "=", "bound_module", ".", "_get_inference_input", "(", "array_dict", ")", "\n", "out", "=", "bound_module", ".", "inference", "(", "**", "inference_input", ",", "n_samples", "=", "mc_samples", ")", "\n", "return", "out", "\n", "\n", "", "return", "_run_inference", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.apply": [[122, 126], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "apply", "(", "self", ")", ":", "\n", "        ", "\"\"\"Apply function of the Flax module.\"\"\"", "\n", "return", "self", ".", "module", ".", "apply", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.loss": [[127, 131], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "loss", "(", "self", ")", ":", "\n", "        ", "\"\"\"Loss function of the Flax module.\"\"\"", "\n", "return", "self", ".", "module", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.init": [[132, 136], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "init", "(", "self", ")", ":", "\n", "        ", "\"\"\"Init function of the Flax module.\"\"\"", "\n", "return", "self", ".", "module", ".", "init", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.rngs": [[137, 146], ["_jax_module_wrapper.JaxModuleWrapper._split_rngs"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._split_rngs"], ["", "@", "property", "\n", "def", "rngs", "(", "self", ")", "->", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Dictionary of RNGs mapping required RNG name to RNG values.\n\n        Calls ``self._split_rngs()`` resulting in newly generated RNGs on\n        every reference to ``self.rngs``.\n        \"\"\"", "\n", "return", "self", ".", "_split_rngs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._set_rngs": [[147, 153], ["jax.random.split", "jax.random.split", "enumerate", "len"], "methods", ["None"], ["", "def", "_set_rngs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates RNGs split off of the seed RNG for each RNG required by the module.\"\"\"", "\n", "required_rngs", "=", "self", ".", "module", ".", "required_rngs", "\n", "rng_keys", "=", "random", ".", "split", "(", "self", ".", "seed_rng", ",", "num", "=", "len", "(", "required_rngs", ")", "+", "1", ")", "\n", "self", ".", "seed", ",", "module_rngs", "=", "rng_keys", "[", "0", "]", ",", "rng_keys", "[", "1", ":", "]", "\n", "self", ".", "_rngs", "=", "{", "k", ":", "module_rngs", "[", "i", "]", "for", "i", ",", "k", "in", "enumerate", "(", "required_rngs", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper._split_rngs": [[154, 166], ["_jax_module_wrapper.JaxModuleWrapper._rngs.items", "jax.random.split", "jax.random.split"], "methods", ["None"], ["", "def", "_split_rngs", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Regenerates the current set of RNGs and returns newly split RNGs.\n\n        Importantly, this method does not reuse RNGs in future references to ``self.rngs``.\n        \"\"\"", "\n", "new_rngs", "=", "{", "}", "\n", "ret_rngs", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "_rngs", ".", "items", "(", ")", ":", "\n", "            ", "new_rngs", "[", "k", "]", ",", "ret_rngs", "[", "k", "]", "=", "random", ".", "split", "(", "v", ")", "\n", "", "self", ".", "_rngs", "=", "new_rngs", "\n", "return", "ret_rngs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.train_state": [[172, 175], ["None"], "methods", ["None"], ["", "@", "train_state", ".", "setter", "\n", "def", "train_state", "(", "self", ",", "train_state", ":", "TrainStateWithBatchNorm", ")", ":", "\n", "        ", "self", ".", "_train_state", "=", "train_state", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.params": [[176, 179], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "params", "(", "self", ")", "->", "flax", ".", "core", ".", "FrozenDict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "self", ".", "train_state", ".", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.batch_stats": [[180, 183], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "batch_stats", "(", "self", ")", "->", "FrozenDict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "return", "self", ".", "train_state", ".", "batch_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict": [[184, 187], ["flax.serialization.to_state_dict"], "methods", ["None"], ["", "def", "state_dict", "(", "self", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"Returns a serialized version of the train state as a dictionary.\"\"\"", "\n", "return", "flax", ".", "serialization", ".", "to_state_dict", "(", "self", ".", "train_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict": [[188, 196], ["flax.serialization.from_state_dict", "RuntimeError"], "methods", ["None"], ["", "def", "load_state_dict", "(", "self", ",", "state_dict", ":", "Dict", "[", "str", ",", "Any", "]", ")", ":", "\n", "        ", "\"\"\"Load a state dictionary into a train state.\"\"\"", "\n", "if", "self", ".", "train_state", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"Train state is not set. Train for one iteration prior to loading state dict.\"", "\n", ")", "\n", "", "self", ".", "train_state", "=", "flax", ".", "serialization", ".", "from_state_dict", "(", "\n", "self", ".", "train_state", ",", "state_dict", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to": [[198, 211], ["jax.device_put", "jax.device_put", "jax.device_put", "jax.device_put", "jax.device_put", "jax.device_put", "jax.device_put", "jax.device_put", "NotImplementedError"], "methods", ["None"], ["", "def", "to", "(", "self", ",", "device", ":", "Device", ")", ":", "\n", "        ", "\"\"\"Move module to device.\"\"\"", "\n", "# TODO: move params and other state as well", "\n", "# TODO: be able to run device_get to get to CPU", "\n", "if", "device", "is", "not", "self", ".", "device", ":", "\n", "            ", "if", "self", ".", "train_state", "is", "not", "None", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"Currently unable to move module across devices with an \"", "\n", "\"existing train state.\"", "\n", ")", "\n", "\n", "", "self", ".", "seed_rng", "=", "jax", ".", "device_put", "(", "self", ".", "seed_rng", ",", "device", ")", "\n", "self", ".", "_rngs", "=", "jax", ".", "device_put", "(", "self", ".", "_rngs", ",", "device", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data": [[30, 153], ["scvi.model._utils.parse_use_gpu_arg", "_archesmixin._get_loaded_data", "_utils._validate_var_names", "attr_dict.pop", "cls.setup_anndata", "_utils._initialize_model", "_utils._initialize_model.get_anndata_manager", "_utils._initialize_model.get_anndata_manager.registry[].split", "_utils._initialize_model.to_device", "_utils._initialize_model.module.state_dict", "load_state_dict.items", "_utils._initialize_model.module.load_state_dict", "_utils._initialize_model.module.eval", "_archesmixin._set_params_online_update", "logger.debug", "adata._inplace_subset_var", "ValueError", "ValueError", "NotImplementedError", "warnings.warn", "int", "int", "new_ten.size", "load_ten.size", "torch.cat", "new_ten.size", "load_ten.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin._get_loaded_data", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._validate_var_names", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._initialize_model", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin._set_params_online_update"], ["@", "classmethod", "\n", "def", "load_query_data", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "reference_model", ":", "Union", "[", "str", ",", "BaseModelClass", "]", ",", "\n", "inplace_subset_query_vars", ":", "bool", "=", "False", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "unfrozen", ":", "bool", "=", "False", ",", "\n", "freeze_dropout", ":", "bool", "=", "False", ",", "\n", "freeze_expression", ":", "bool", "=", "True", ",", "\n", "freeze_decoder_first_layer", ":", "bool", "=", "True", ",", "\n", "freeze_batchnorm_encoder", ":", "bool", "=", "True", ",", "\n", "freeze_batchnorm_decoder", ":", "bool", "=", "False", ",", "\n", "freeze_classifier", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Online update of a reference model with scArches algorithm [Lotfollahi21]_.\n\n        Parameters\n        ----------\n        adata\n            AnnData organized in the same way as data used to train model.\n            It is not necessary to run setup_anndata,\n            as AnnData is validated against the ``registry``.\n        reference_model\n            Either an already instantiated model of the same class, or a path to\n            saved outputs for reference model.\n        inplace_subset_query_vars\n            Whether to subset and rearrange query vars inplace based on vars used to\n            train reference model.\n        use_gpu\n            Load model on default GPU if available (if None or True),\n            or index of GPU to use (if int), or name of GPU (if str), or use CPU (if False).\n        unfrozen\n            Override all other freeze options for a fully unfrozen model\n        freeze_dropout\n            Whether to freeze dropout during training\n        freeze_expression\n            Freeze neurons corersponding to expression in first layer\n        freeze_decoder_first_layer\n            Freeze neurons corersponding to first layer in decoder\n        freeze_batchnorm_encoder\n            Whether to freeze batchnorm weight and bias during training for encoder\n        freeze_batchnorm_decoder\n            Whether to freeze batchnorm weight and bias during training for decoder\n        freeze_classifier\n            Whether to freeze classifier completely. Only applies to `SCANVI`.\n        \"\"\"", "\n", "use_gpu", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "attr_dict", ",", "var_names", ",", "load_state_dict", "=", "_get_loaded_data", "(", "\n", "reference_model", ",", "device", "=", "device", "\n", ")", "\n", "\n", "if", "inplace_subset_query_vars", ":", "\n", "            ", "logger", ".", "debug", "(", "\"Subsetting query vars to reference vars.\"", ")", "\n", "adata", ".", "_inplace_subset_var", "(", "var_names", ")", "\n", "", "_validate_var_names", "(", "adata", ",", "var_names", ")", "\n", "\n", "registry", "=", "attr_dict", ".", "pop", "(", "\"registry_\"", ")", "\n", "if", "_MODEL_NAME_KEY", "in", "registry", "and", "registry", "[", "_MODEL_NAME_KEY", "]", "!=", "cls", ".", "__name__", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"It appears you are loading a model from a different class.\"", "\n", ")", "\n", "\n", "", "if", "_SETUP_ARGS_KEY", "not", "in", "registry", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Saved model does not contain original setup inputs. \"", "\n", "\"Cannot load the original setup.\"", "\n", ")", "\n", "\n", "", "cls", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "source_registry", "=", "registry", ",", "\n", "extend_categories", "=", "True", ",", "\n", "allow_missing_labels", "=", "True", ",", "\n", "**", "registry", "[", "_SETUP_ARGS_KEY", "]", ",", "\n", ")", "\n", "\n", "model", "=", "_initialize_model", "(", "cls", ",", "adata", ",", "attr_dict", ")", "\n", "adata_manager", "=", "model", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "adata_manager", ".", "data_registry", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"scArches currently does not support models with extra categorical covariates.\"", "\n", ")", "\n", "\n", "", "version_split", "=", "adata_manager", ".", "registry", "[", "_constants", ".", "_SCVI_VERSION_KEY", "]", ".", "split", "(", "\".\"", ")", "\n", "if", "int", "(", "version_split", "[", "1", "]", ")", "<", "8", "and", "int", "(", "version_split", "[", "0", "]", ")", "==", "0", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Query integration should be performed using models trained with version >= 0.8\"", "\n", ")", "\n", "\n", "", "model", ".", "to_device", "(", "device", ")", "\n", "\n", "# model tweaking", "\n", "new_state_dict", "=", "model", ".", "module", ".", "state_dict", "(", ")", "\n", "for", "key", ",", "load_ten", "in", "load_state_dict", ".", "items", "(", ")", ":", "\n", "            ", "new_ten", "=", "new_state_dict", "[", "key", "]", "\n", "if", "new_ten", ".", "size", "(", ")", "==", "load_ten", ".", "size", "(", ")", ":", "\n", "                ", "continue", "\n", "# new categoricals changed size", "\n", "", "else", ":", "\n", "                ", "dim_diff", "=", "new_ten", ".", "size", "(", ")", "[", "-", "1", "]", "-", "load_ten", ".", "size", "(", ")", "[", "-", "1", "]", "\n", "fixed_ten", "=", "torch", ".", "cat", "(", "[", "load_ten", ",", "new_ten", "[", "...", ",", "-", "dim_diff", ":", "]", "]", ",", "dim", "=", "-", "1", ")", "\n", "load_state_dict", "[", "key", "]", "=", "fixed_ten", "\n", "\n", "", "", "model", ".", "module", ".", "load_state_dict", "(", "load_state_dict", ")", "\n", "model", ".", "module", ".", "eval", "(", ")", "\n", "\n", "_set_params_online_update", "(", "\n", "model", ".", "module", ",", "\n", "unfrozen", "=", "unfrozen", ",", "\n", "freeze_decoder_first_layer", "=", "freeze_decoder_first_layer", ",", "\n", "freeze_batchnorm_encoder", "=", "freeze_batchnorm_encoder", ",", "\n", "freeze_batchnorm_decoder", "=", "freeze_batchnorm_decoder", ",", "\n", "freeze_dropout", "=", "freeze_dropout", ",", "\n", "freeze_expression", "=", "freeze_expression", ",", "\n", "freeze_classifier", "=", "freeze_classifier", ",", "\n", ")", "\n", "model", ".", "is_trained_", "=", "False", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata": [[154, 238], ["_archesmixin._get_loaded_data", "pandas.Index", "adata.var_names.intersection", "len", "logger.info", "pandas.Index.difference", "ValueError", "len", "warnings.warn", "len", "scipy.sparse.csr_matrix", "anndata.AnnData", "anndata.concat", "pandas.Index.equals", "anndata.concat._inplace_subset_var", "numpy.zeros", "adata._init_as_actual", "scipy.sparse.csr_matrix.copy", "len", "scipy.sparse.csr_matrix.copy"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin._get_loaded_data"], ["", "@", "staticmethod", "\n", "def", "prepare_query_anndata", "(", "\n", "adata", ":", "AnnData", ",", "\n", "reference_model", ":", "Union", "[", "str", ",", "BaseModelClass", "]", ",", "\n", "return_reference_var_names", ":", "bool", "=", "False", ",", "\n", "inplace", ":", "bool", "=", "True", ",", "\n", ")", "->", "Optional", "[", "Union", "[", "AnnData", ",", "pd", ".", "Index", "]", "]", ":", "\n", "        ", "\"\"\"\n        Prepare data for query integration.\n\n        This function will return a new AnnData object with padded zeros\n        for missing features, as well as correctly sorted features.\n\n        Parameters\n        ----------\n        adata\n            AnnData organized in the same way as data used to train model.\n            It is not necessary to run setup_anndata,\n            as AnnData is validated against the ``registry``.\n        reference_model\n            Either an already instantiated model of the same class, or a path to\n            saved outputs for reference model.\n        return_reference_var_names\n            Only load and return reference var names if True.\n        inplace\n            Whether to subset and rearrange query vars inplace or return new AnnData.\n\n        Returns\n        -------\n        Query adata ready to use in `load_query_data` unless `return_reference_var_names`\n        in which case a pd.Index of reference var names is returned.\n        \"\"\"", "\n", "_", ",", "var_names", ",", "_", "=", "_get_loaded_data", "(", "reference_model", ",", "device", "=", "\"cpu\"", ")", "\n", "var_names", "=", "pd", ".", "Index", "(", "var_names", ")", "\n", "\n", "if", "return_reference_var_names", ":", "\n", "            ", "return", "var_names", "\n", "\n", "", "intersection", "=", "adata", ".", "var_names", ".", "intersection", "(", "var_names", ")", "\n", "inter_len", "=", "len", "(", "intersection", ")", "\n", "if", "inter_len", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"No reference var names found in query data. \"", "\n", "\"Please rerun with return_reference_var_names=True \"", "\n", "\"to see reference var names.\"", "\n", ")", "\n", "\n", "", "ratio", "=", "inter_len", "/", "len", "(", "var_names", ")", "\n", "logger", ".", "info", "(", "\"Found {}% reference vars in query data.\"", ".", "format", "(", "ratio", "*", "100", ")", ")", "\n", "if", "ratio", "<", "MIN_VAR_NAME_RATIO", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "f\"Query data contains less than {MIN_VAR_NAME_RATIO:.0f}% of reference var names. \"", "\n", "\"This may result in poor performance.\"", "\n", ")", "\n", "", "genes_to_add", "=", "var_names", ".", "difference", "(", "adata", ".", "var_names", ")", "\n", "needs_padding", "=", "len", "(", "genes_to_add", ")", ">", "0", "\n", "if", "needs_padding", ":", "\n", "            ", "padding_mtx", "=", "csr_matrix", "(", "np", ".", "zeros", "(", "(", "adata", ".", "n_obs", ",", "len", "(", "genes_to_add", ")", ")", ")", ")", "\n", "adata_padding", "=", "AnnData", "(", "\n", "X", "=", "padding_mtx", ".", "copy", "(", ")", ",", "\n", "layers", "=", "{", "layer", ":", "padding_mtx", ".", "copy", "(", ")", "for", "layer", "in", "adata", ".", "layers", "}", ",", "\n", ")", "\n", "adata_padding", ".", "var_names", "=", "genes_to_add", "\n", "adata_padding", ".", "obs_names", "=", "adata", ".", "obs_names", "\n", "# Concatenate object", "\n", "adata_out", "=", "anndata", ".", "concat", "(", "\n", "[", "adata", ",", "adata_padding", "]", ",", "\n", "axis", "=", "1", ",", "\n", "join", "=", "\"outer\"", ",", "\n", "index_unique", "=", "None", ",", "\n", "merge", "=", "\"unique\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "adata_out", "=", "adata", "\n", "\n", "# also covers the case when new adata has more var names than old", "\n", "", "if", "not", "var_names", ".", "equals", "(", "adata_out", ".", "var_names", ")", ":", "\n", "            ", "adata_out", ".", "_inplace_subset_var", "(", "var_names", ")", "\n", "\n", "", "if", "inplace", ":", "\n", "            ", "if", "adata_out", "is", "not", "adata", ":", "\n", "                ", "adata", ".", "_init_as_actual", "(", "adata_out", ",", "dtype", "=", "adata", ".", "_X", ".", "dtype", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "adata_out", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin._set_params_online_update": [[240, 313], ["set", "set", "set", "module.named_modules", "module.named_parameters", "set.add", "isinstance", "isinstance", "_archesmixin._set_params_online_update.requires_grad"], "function", ["None"], ["", "", "", "def", "_set_params_online_update", "(", "\n", "module", ",", "\n", "unfrozen", ",", "\n", "freeze_decoder_first_layer", ",", "\n", "freeze_batchnorm_encoder", ",", "\n", "freeze_batchnorm_decoder", ",", "\n", "freeze_dropout", ",", "\n", "freeze_expression", ",", "\n", "freeze_classifier", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Freeze parts of network for scArches.\"\"\"", "\n", "# do nothing if unfrozen", "\n", "if", "unfrozen", ":", "\n", "        ", "return", "\n", "\n", "", "mod_no_grad", "=", "set", "(", "[", "\"encoder_z2_z1\"", ",", "\"decoder_z1_z2\"", "]", ")", "\n", "mod_no_hooks_yes_grad", "=", "set", "(", "[", "\"l_encoder\"", "]", ")", "\n", "if", "not", "freeze_classifier", ":", "\n", "        ", "mod_no_hooks_yes_grad", ".", "add", "(", "\"classifier\"", ")", "\n", "", "parameters_yes_grad", "=", "set", "(", "[", "\"background_pro_alpha\"", ",", "\"background_pro_log_beta\"", "]", ")", "\n", "\n", "def", "no_hook_cond", "(", "key", ")", ":", "\n", "        ", "one", "=", "(", "not", "freeze_expression", ")", "and", "\"encoder\"", "in", "key", "\n", "two", "=", "(", "not", "freeze_decoder_first_layer", ")", "and", "\"px_decoder\"", "in", "key", "\n", "return", "one", "or", "two", "\n", "\n", "", "def", "requires_grad", "(", "key", ")", ":", "\n", "        ", "mod_name", "=", "key", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "# linear weights and bias that need grad", "\n", "one", "=", "\"fc_layers\"", "in", "key", "and", "\".0.\"", "in", "key", "and", "mod_name", "not", "in", "mod_no_grad", "\n", "# modules that need grad", "\n", "two", "=", "mod_name", "in", "mod_no_hooks_yes_grad", "\n", "three", "=", "sum", "(", "[", "p", "in", "key", "for", "p", "in", "parameters_yes_grad", "]", ")", ">", "0", "\n", "# batch norm option", "\n", "four", "=", "(", "\n", "\"fc_layers\"", "in", "key", "\n", "and", "\".1.\"", "in", "key", "\n", "and", "\"encoder\"", "in", "key", "\n", "and", "(", "not", "freeze_batchnorm_encoder", ")", "\n", ")", "\n", "five", "=", "(", "\n", "\"fc_layers\"", "in", "key", "\n", "and", "\".1.\"", "in", "key", "\n", "and", "\"decoder\"", "in", "key", "\n", "and", "(", "not", "freeze_batchnorm_decoder", ")", "\n", ")", "\n", "if", "one", "or", "two", "or", "three", "or", "four", "or", "five", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "for", "key", ",", "mod", "in", "module", ".", "named_modules", "(", ")", ":", "\n", "# skip over protected modules", "\n", "        ", "if", "key", ".", "split", "(", "\".\"", ")", "[", "0", "]", "in", "mod_no_hooks_yes_grad", ":", "\n", "            ", "continue", "\n", "", "if", "isinstance", "(", "mod", ",", "FCLayers", ")", ":", "\n", "            ", "hook_first_layer", "=", "False", "if", "no_hook_cond", "(", "key", ")", "else", "True", "\n", "mod", ".", "set_online_update_hooks", "(", "hook_first_layer", ")", "\n", "", "if", "isinstance", "(", "mod", ",", "torch", ".", "nn", ".", "Dropout", ")", ":", "\n", "            ", "if", "freeze_dropout", ":", "\n", "                ", "mod", ".", "p", "=", "0", "\n", "# momentum freezes the running stats of batchnorm", "\n", "", "", "freeze_batchnorm", "=", "(", "\"decoder\"", "in", "key", "and", "freeze_batchnorm_decoder", ")", "or", "(", "\n", "\"encoder\"", "in", "key", "and", "freeze_batchnorm_encoder", "\n", ")", "\n", "if", "isinstance", "(", "mod", ",", "torch", ".", "nn", ".", "BatchNorm1d", ")", "and", "freeze_batchnorm", ":", "\n", "            ", "mod", ".", "momentum", "=", "0", "\n", "\n", "", "", "for", "key", ",", "par", "in", "module", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "requires_grad", "(", "key", ")", ":", "\n", "            ", "par", ".", "requires_grad", "=", "True", "\n", "", "else", ":", "\n", "            ", "par", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin._get_loaded_data": [[315, 327], ["isinstance", "_utils._load_saved_files", "reference_model._get_user_attributes", "copy.deepcopy", "reference_model.module.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_saved_files", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_user_attributes", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "", "", "def", "_get_loaded_data", "(", "reference_model", ",", "device", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "reference_model", ",", "str", ")", ":", "\n", "        ", "attr_dict", ",", "var_names", ",", "load_state_dict", ",", "_", "=", "_load_saved_files", "(", "\n", "reference_model", ",", "load_adata", "=", "False", ",", "map_location", "=", "device", "\n", ")", "\n", "", "else", ":", "\n", "        ", "attr_dict", "=", "reference_model", ".", "_get_user_attributes", "(", ")", "\n", "attr_dict", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "attr_dict", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "var_names", "=", "reference_model", ".", "adata", ".", "var_names", "\n", "load_state_dict", "=", "deepcopy", "(", "reference_model", ".", "module", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "return", "attr_dict", ",", "var_names", ",", "load_state_dict", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelMetaClass.__init__": [[53, 61], ["dict", "dict", "abc.ABCMeta.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "cls", ",", "name", ",", "bases", ",", "dct", ")", ":", "\n", "        ", "cls", ".", "_setup_adata_manager_store", ":", "Dict", "[", "\n", "str", ",", "Type", "[", "AnnDataManager", "]", "\n", "]", "=", "dict", "(", ")", "# Maps adata id to AnnDataManager instances.", "\n", "cls", ".", "_per_instance_manager_store", ":", "Dict", "[", "\n", "str", ",", "Dict", "[", "str", ",", "Type", "[", "AnnDataManager", "]", "]", "\n", "]", "=", "dict", "(", ")", "# Maps model instance id to AnnDataManager mappings.", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "bases", ",", "dct", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.__init__": [[66, 85], ["str", "uuid.uuid4", "_base_model.BaseModelClass._get_most_recent_anndata_manager", "_base_model.BaseModelClass._register_manager_for_instance"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_most_recent_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._register_manager_for_instance"], ["def", "__init__", "(", "self", ",", "adata", ":", "Optional", "[", "AnnOrMuData", "]", "=", "None", ")", ":", "\n", "        ", "self", ".", "id", "=", "str", "(", "uuid4", "(", ")", ")", "# Used for cls._manager_store keys.", "\n", "if", "adata", "is", "not", "None", ":", "\n", "            ", "self", ".", "_adata", "=", "adata", "\n", "self", ".", "_adata_manager", "=", "self", ".", "_get_most_recent_anndata_manager", "(", "\n", "adata", ",", "required", "=", "True", "\n", ")", "\n", "self", ".", "_register_manager_for_instance", "(", "self", ".", "adata_manager", ")", "\n", "# Suffix registry instance variable with _ to include it when saving the model.", "\n", "self", ".", "registry_", "=", "self", ".", "_adata_manager", ".", "registry", "\n", "self", ".", "summary_stats", "=", "self", ".", "_adata_manager", ".", "summary_stats", "\n", "\n", "", "self", ".", "is_trained_", "=", "False", "\n", "self", ".", "_model_summary_string", "=", "\"\"", "\n", "self", ".", "train_indices_", "=", "None", "\n", "self", ".", "test_indices_", "=", "None", "\n", "self", ".", "validation_indices_", "=", "None", "\n", "self", ".", "history_", "=", "None", "\n", "self", ".", "_data_loader_cls", "=", "AnnDataLoader", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.adata": [[91, 100], ["_base_model.BaseModelClass._validate_anndata", "_base_model.BaseModelClass.get_anndata_manager", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "@", "adata", ".", "setter", "\n", "def", "adata", "(", "self", ",", "adata", ":", "AnnOrMuData", ")", ":", "\n", "        ", "if", "adata", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"adata cannot be None.\"", ")", "\n", "", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "self", ".", "_adata", "=", "adata", "\n", "self", ".", "_adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "self", ".", "registry_", "=", "self", ".", "_adata_manager", ".", "registry", "\n", "self", ".", "summary_stats", "=", "self", ".", "_adata_manager", ".", "summary_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.adata_manager": [[101, 105], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "adata_manager", "(", "self", ")", "->", "AnnDataManager", ":", "\n", "        ", "\"\"\"Manager instance associated with self.adata.\"\"\"", "\n", "return", "self", ".", "_adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.to_device": [[106, 126], ["torch.device", "_base_model.BaseModelClass.module.to"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "def", "to_device", "(", "self", ",", "device", ":", "Union", "[", "str", ",", "int", "]", ")", ":", "\n", "        ", "\"\"\"\n        Move model to device.\n\n        Parameters\n        ----------\n        device\n            Device to move model to. Options: 'cpu' for CPU, integer GPU index (eg. 0),\n            or 'cuda:X' where X is the GPU index (eg. 'cuda:0'). See torch.device for more info.\n\n        Examples\n        --------\n        >>> adata = scvi.data.synthetic_iid()\n        >>> model = scvi.model.SCVI(adata)\n        >>> model.to_device('cpu')      # moves model to CPU\n        >>> model.to_device('cuda:0')   # moves model to GPU 0\n        >>> model.to_device(0)          # also moves model to GPU 0\n        \"\"\"", "\n", "my_device", "=", "torch", ".", "device", "(", "device", ")", "\n", "self", ".", "module", ".", "to", "(", "my_device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.device": [[127, 131], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"The current device that the module's params are on.\"\"\"", "\n", "return", "self", ".", "module", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_setup_method_args": [[132, 156], ["setup_locals.pop", "dict", "setup_locals.items"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_setup_method_args", "(", "**", "setup_locals", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a dictionary organizing the arguments used to call ``setup_anndata``.\n\n        Must be called with ``**locals()`` at the start of the ``setup_anndata`` method\n        to avoid the inclusion of any extraneous variables.\n        \"\"\"", "\n", "cls", "=", "setup_locals", ".", "pop", "(", "\"cls\"", ")", "\n", "method_name", "=", "None", "\n", "if", "\"adata\"", "in", "setup_locals", ":", "\n", "            ", "method_name", "=", "\"setup_anndata\"", "\n", "", "elif", "\"mdata\"", "in", "setup_locals", ":", "\n", "            ", "method_name", "=", "\"setup_mudata\"", "\n", "\n", "", "model_name", "=", "cls", ".", "__name__", "\n", "setup_args", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "setup_locals", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "_SETUP_INPUTS_EXCLUDED_PARAMS", ":", "\n", "                ", "setup_args", "[", "k", "]", "=", "v", "\n", "", "", "return", "{", "\n", "_MODEL_NAME_KEY", ":", "model_name", ",", "\n", "_SETUP_METHOD_NAME", ":", "method_name", ",", "\n", "_SETUP_ARGS_KEY", ":", "setup_args", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._create_modalities_attr_dict": [[158, 185], ["scvi.utils.attrdict", "modalities.get", "set", "set", "len", "ValueError", "setup_args.keys"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_create_modalities_attr_dict", "(", "\n", "modalities", ":", "Dict", "[", "str", ",", "str", "]", ",", "setup_method_args", ":", "dict", "\n", ")", "->", "attrdict", ":", "\n", "        ", "\"\"\"\n        Preprocesses a ``modalities`` dictionary used in ``setup_mudata()`` to map modality names.\n\n        Ensures each field key has a respective modality key, defaulting to ``None``.\n        Raises a ``UserWarning`` if extraneous modality mappings are detected.\n\n        Parameters\n        ----------\n        modalities\n            Dictionary mapping ``setup_mudata()`` argument name to modality name.\n        setup_method_args\n            Output of  ``_get_setup_method_args()``.\n        \"\"\"", "\n", "setup_args", "=", "setup_method_args", "[", "_SETUP_ARGS_KEY", "]", "\n", "filtered_modalities", "=", "{", "\n", "arg_name", ":", "modalities", ".", "get", "(", "arg_name", ",", "None", ")", "for", "arg_name", "in", "setup_args", ".", "keys", "(", ")", "\n", "}", "\n", "extra_modalities", "=", "set", "(", "modalities", ")", "-", "set", "(", "filtered_modalities", ")", "\n", "if", "len", "(", "extra_modalities", ")", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Extraneous modality mapping(s) detected: {extra_modalities}\"", "\n", ")", "\n", "", "return", "attrdict", "(", "filtered_modalities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager": [[186, 203], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "register_manager", "(", "cls", ",", "adata_manager", ":", "AnnDataManager", ")", ":", "\n", "        ", "\"\"\"\n        Registers an :class:`~scvi.data.AnnDataManager` instance with this model class.\n\n        Stores the :class:`~scvi.data.AnnDataManager` reference in a class-specific manager store.\n        Intended for use in the ``setup_anndata()`` class method followed up by retrieval of the\n        :class:`~scvi.data.AnnDataManager` via the ``_get_most_recent_anndata_manager()`` method in\n        the model init method.\n\n        Notes\n        -----\n        Subsequent calls to this method with an :class:`~scvi.data.AnnDataManager` instance referring to the same\n        underlying AnnData object will overwrite the reference to previous :class:`~scvi.data.AnnDataManager`.\n        \"\"\"", "\n", "adata_id", "=", "adata_manager", ".", "adata_uuid", "\n", "cls", ".", "_setup_adata_manager_store", "[", "adata_id", "]", "=", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._register_manager_for_instance": [[204, 217], ["dict"], "methods", ["None"], ["", "def", "_register_manager_for_instance", "(", "self", ",", "adata_manager", ":", "AnnDataManager", ")", ":", "\n", "        ", "\"\"\"\n        Registers an :class:`~scvi.data.AnnDataManager` instance with this model instance.\n\n        Creates a model-instance specific mapping in ``cls._per_instance_manager_store`` for this\n        :class:`~scvi.data.AnnDataManager` instance.\n        \"\"\"", "\n", "if", "self", ".", "id", "not", "in", "self", ".", "_per_instance_manager_store", ":", "\n", "            ", "self", ".", "_per_instance_manager_store", "[", "self", ".", "id", "]", "=", "dict", "(", ")", "\n", "\n", "", "adata_id", "=", "adata_manager", ".", "adata_uuid", "\n", "instance_manager_store", "=", "self", ".", "_per_instance_manager_store", "[", "self", ".", "id", "]", "\n", "instance_manager_store", "[", "adata_id", "]", "=", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_most_recent_anndata_manager": [[218, 261], ["ValueError", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_get_most_recent_anndata_manager", "(", "\n", "cls", ",", "adata", ":", "AnnOrMuData", ",", "required", ":", "bool", "=", "False", "\n", ")", "->", "Optional", "[", "AnnDataManager", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the :class:`~scvi.data.AnnDataManager` for a given AnnData object specific to this model class.\n\n        Checks for the most recent :class:`~scvi.data.AnnDataManager` created for the given AnnData object via\n        ``setup_anndata()`` on model initialization. Unlike :meth:`scvi.model.base.BaseModelClass.get_anndata_manager`,\n        this method is not model instance specific and can be called before a model is fully initialized.\n\n        Parameters\n        ----------\n        adata\n            AnnData object to find manager instance for.\n        required\n            If True, errors on missing manager. Otherwise, returns None when manager is missing.\n        \"\"\"", "\n", "if", "_SCVI_UUID_KEY", "not", "in", "adata", ".", "uns", ":", "\n", "            ", "if", "required", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Please set up your AnnData with {cls.__name__}.setup_anndata first.\"", "\n", ")", "\n", "", "return", "None", "\n", "\n", "", "adata_id", "=", "adata", ".", "uns", "[", "_SCVI_UUID_KEY", "]", "\n", "\n", "if", "adata_id", "not", "in", "cls", ".", "_setup_adata_manager_store", ":", "\n", "            ", "if", "required", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Please set up your AnnData with {cls.__name__}.setup_anndata first. \"", "\n", "\"It appears the AnnData object has been setup with a different model.\"", "\n", ")", "\n", "", "return", "None", "\n", "\n", "", "adata_manager", "=", "cls", ".", "_setup_adata_manager_store", "[", "adata_id", "]", "\n", "if", "adata_manager", ".", "adata", "is", "not", "adata", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The provided AnnData object does not match the AnnData object \"", "\n", "\"previously provided for setup. Did you make a copy?\"", "\n", ")", "\n", "\n", "", "return", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager": [[262, 311], ["logger.info", "scvi.data._utils._assign_adata_uuid", "_base_model.BaseModelClass.adata_manager.transfer_fields", "_base_model.BaseModelClass._register_manager_for_instance", "ValueError", "AssertionError", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._assign_adata_uuid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._register_manager_for_instance"], ["", "def", "get_anndata_manager", "(", "\n", "self", ",", "adata", ":", "AnnOrMuData", ",", "required", ":", "bool", "=", "False", "\n", ")", "->", "Optional", "[", "AnnDataManager", "]", ":", "\n", "        ", "\"\"\"\n        Retrieves the :class:`~scvi.data.AnnDataManager` for a given AnnData object specific to this model instance.\n\n        Requires ``self.id`` has been set. Checks for an :class:`~scvi.data.AnnDataManager`\n        specific to this model instance.\n\n        Parameters\n        ----------\n        adata\n            AnnData object to find manager instance for.\n        required\n            If True, errors on missing manager. Otherwise, returns None when manager is missing.\n        \"\"\"", "\n", "cls", "=", "self", ".", "__class__", "\n", "if", "_SCVI_UUID_KEY", "not", "in", "adata", ".", "uns", ":", "\n", "            ", "if", "required", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"Please set up your AnnData with {cls.__name__}.setup_anndata first.\"", "\n", ")", "\n", "", "return", "None", "\n", "\n", "", "adata_id", "=", "adata", ".", "uns", "[", "_SCVI_UUID_KEY", "]", "\n", "if", "self", ".", "id", "not", "in", "cls", ".", "_per_instance_manager_store", ":", "\n", "            ", "if", "required", ":", "\n", "                ", "raise", "AssertionError", "(", "\n", "\"Unable to find instance specific manager store. \"", "\n", "\"The model has likely not been initialized with an AnnData object.\"", "\n", ")", "\n", "", "return", "None", "\n", "", "elif", "adata_id", "not", "in", "cls", ".", "_per_instance_manager_store", "[", "self", ".", "id", "]", ":", "\n", "            ", "if", "required", ":", "\n", "                ", "raise", "AssertionError", "(", "\n", "\"Please call ``self._validate_anndata`` on this AnnData object.\"", "\n", ")", "\n", "", "return", "None", "\n", "\n", "", "adata_manager", "=", "cls", ".", "_per_instance_manager_store", "[", "self", ".", "id", "]", "[", "adata_id", "]", "\n", "if", "adata_manager", ".", "adata", "is", "not", "adata", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "\"AnnData object appears to be a copy. Attempting to transfer setup.\"", "\n", ")", "\n", "_assign_adata_uuid", "(", "adata", ",", "overwrite", "=", "True", ")", "\n", "adata_manager", "=", "self", ".", "adata_manager", ".", "transfer_fields", "(", "adata", ")", "\n", "self", ".", "_register_manager_for_instance", "(", "adata_manager", ")", "\n", "\n", "", "return", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_from_registry": [[312, 341], ["_base_model.BaseModelClass.get_anndata_manager", "_base_model.BaseModelClass.get_from_registry", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "get_from_registry", "(", "\n", "self", ",", "\n", "adata", ":", "AnnOrMuData", ",", "\n", "registry_key", ":", "str", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Returns the object in AnnData associated with the key in the data registry.\n\n        AnnData object should be registered with the model prior to calling this function\n        via the ``self._validate_anndata`` method.\n\n        Parameters\n        ----------\n        registry_key\n            key of object to get from data registry.\n        adata\n            AnnData to pull data from.\n\n        Returns\n        -------\n        The requested data as a NumPy array.\n        \"\"\"", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ")", "\n", "if", "adata_manager", "is", "None", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "\"AnnData not registered with model. Call `self._validate_anndata` \"", "\n", "\"prior to calling this function.\"", "\n", ")", "\n", "", "return", "adata_manager", ".", "get_from_registry", "(", "registry_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader": [[342, 395], ["_base_model.BaseModelClass.get_anndata_manager", "data_loader_class", "AssertionError", "numpy.arange", "data_loader_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "_make_data_loader", "(", "\n", "self", ",", "\n", "adata", ":", "AnnOrMuData", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "shuffle", ":", "bool", "=", "False", ",", "\n", "data_loader_class", "=", "None", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create a AnnDataLoader object for data iteration.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        shuffle\n            Whether observations are shuffled each iteration though\n        data_loader_class\n            Class to use for data loader\n        data_loader_kwargs\n            Kwargs to the class-specific data loader class\n        \"\"\"", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ")", "\n", "if", "adata_manager", "is", "None", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "\"AnnDataManager not found. Call `self._validate_anndata` prior to calling this function.\"", "\n", ")", "\n", "\n", "", "adata", "=", "adata_manager", ".", "adata", "\n", "\n", "if", "batch_size", "is", "None", ":", "\n", "            ", "batch_size", "=", "settings", ".", "batch_size", "\n", "", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "data_loader_class", "is", "None", ":", "\n", "            ", "data_loader_class", "=", "self", ".", "_data_loader_cls", "\n", "\n", "", "if", "\"num_workers\"", "not", "in", "data_loader_kwargs", ":", "\n", "            ", "data_loader_kwargs", ".", "update", "(", "{", "\"num_workers\"", ":", "settings", ".", "dl_num_workers", "}", ")", "\n", "\n", "", "dl", "=", "data_loader_class", "(", "\n", "adata_manager", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "indices", "=", "indices", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", "\n", "return", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._validate_anndata": [[396, 419], ["scvi.data._utils._check_if_view", "_base_model.BaseModelClass.get_anndata_manager", "logger.info", "_base_model.BaseModelClass._register_manager_for_instance", "_base_model.BaseModelClass.validate", "_base_model.BaseModelClass.adata_manager.transfer_fields"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_if_view", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._register_manager_for_instance", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.validate", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "_validate_anndata", "(", "\n", "self", ",", "adata", ":", "Optional", "[", "AnnOrMuData", "]", "=", "None", ",", "copy_if_view", ":", "bool", "=", "True", "\n", ")", "->", "AnnData", ":", "\n", "        ", "\"\"\"Validate anndata has been properly registered, transfer if necessary.\"\"\"", "\n", "if", "adata", "is", "None", ":", "\n", "            ", "adata", "=", "self", ".", "adata", "\n", "\n", "", "_check_if_view", "(", "adata", ",", "copy_if_view", "=", "copy_if_view", ")", "\n", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ")", "\n", "if", "adata_manager", "is", "None", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Input AnnData not setup with scvi-tools. \"", "\n", "+", "\"attempting to transfer AnnData setup\"", "\n", ")", "\n", "self", ".", "_register_manager_for_instance", "(", "\n", "self", ".", "adata_manager", ".", "transfer_fields", "(", "adata", ")", "\n", ")", "\n", "", "else", ":", "\n", "# Case where correct AnnDataManager is found, replay registration as necessary.", "\n", "            ", "adata_manager", ".", "validate", "(", ")", "\n", "\n", "", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained": [[420, 433], ["warnings.warn", "RuntimeError"], "methods", ["None"], ["", "def", "_check_if_trained", "(", "\n", "self", ",", "warn", ":", "bool", "=", "True", ",", "message", ":", "str", "=", "_UNTRAINED_WARNING_MESSAGE", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Check if the model is trained.\n\n        If not trained and `warn` is True, raise a warning, else raise a RuntimeError.\n        \"\"\"", "\n", "if", "not", "self", ".", "is_trained_", ":", "\n", "            ", "if", "warn", ":", "\n", "                ", "warnings", ".", "warn", "(", "message", ")", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.is_trained": [[466, 469], ["None"], "methods", ["None"], ["", "@", "is_trained", ".", "setter", "\n", "def", "is_trained", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "is_trained_", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.test_indices": [[458, 461], ["None"], "methods", ["None"], ["", "@", "test_indices", ".", "setter", "\n", "def", "test_indices", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "test_indices_", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.train_indices": [[454, 457], ["None"], "methods", ["None"], ["", "@", "train_indices", ".", "setter", "\n", "def", "train_indices", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "train_indices_", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.validation_indices": [[462, 465], ["None"], "methods", ["None"], ["", "@", "validation_indices", ".", "setter", "\n", "def", "validation_indices", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "validation_indices_", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.history": [[470, 474], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "history", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns computed metrics during training.\"\"\"", "\n", "return", "self", ".", "history_", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_user_attributes": [[475, 483], ["inspect.getmembers", "inspect.isroutine", "a[].startswith", "a[].startswith", "a[].endswith"], "methods", ["None"], ["", "def", "_get_user_attributes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns all the self attributes defined in a model class, e.g., self.is_trained_.\"\"\"", "\n", "attributes", "=", "inspect", ".", "getmembers", "(", "self", ",", "lambda", "a", ":", "not", "(", "inspect", ".", "isroutine", "(", "a", ")", ")", ")", "\n", "attributes", "=", "[", "\n", "a", "for", "a", "in", "attributes", "if", "not", "(", "a", "[", "0", "]", ".", "startswith", "(", "\"__\"", ")", "and", "a", "[", "0", "]", ".", "endswith", "(", "\"__\"", ")", ")", "\n", "]", "\n", "attributes", "=", "[", "a", "for", "a", "in", "attributes", "if", "not", "a", "[", "0", "]", ".", "startswith", "(", "\"_abc_\"", ")", "]", "\n", "return", "attributes", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params": [[484, 511], ["inspect.signature", "inspect.signature.parameters.values", "all_params.items", "all_params.items", "all_params.items", "isinstance", "isinstance"], "methods", ["None"], ["", "def", "_get_init_params", "(", "self", ",", "locals", ")", ":", "\n", "        ", "\"\"\"\n        Returns the model init signature with associated passed in values.\n\n        Ignores the initial AnnData.\n        \"\"\"", "\n", "init", "=", "self", ".", "__init__", "\n", "sig", "=", "inspect", ".", "signature", "(", "init", ")", "\n", "parameters", "=", "sig", ".", "parameters", ".", "values", "(", ")", "\n", "\n", "init_params", "=", "[", "p", ".", "name", "for", "p", "in", "parameters", "]", "\n", "all_params", "=", "{", "p", ":", "locals", "[", "p", "]", "for", "p", "in", "locals", "if", "p", "in", "init_params", "}", "\n", "all_params", "=", "{", "\n", "k", ":", "v", "\n", "for", "(", "k", ",", "v", ")", "in", "all_params", ".", "items", "(", ")", "\n", "if", "not", "isinstance", "(", "v", ",", "AnnData", ")", "and", "not", "isinstance", "(", "v", ",", "MuData", ")", "\n", "}", "\n", "# not very efficient but is explicit", "\n", "# seperates variable params (**kwargs) from non variable params into two dicts", "\n", "non_var_params", "=", "[", "p", ".", "name", "for", "p", "in", "parameters", "if", "p", ".", "kind", "!=", "p", ".", "VAR_KEYWORD", "]", "\n", "non_var_params", "=", "{", "k", ":", "v", "for", "(", "k", ",", "v", ")", "in", "all_params", ".", "items", "(", ")", "if", "k", "in", "non_var_params", "}", "\n", "var_params", "=", "[", "p", ".", "name", "for", "p", "in", "parameters", "if", "p", ".", "kind", "==", "p", ".", "VAR_KEYWORD", "]", "\n", "var_params", "=", "{", "k", ":", "v", "for", "(", "k", ",", "v", ")", "in", "all_params", ".", "items", "(", ")", "if", "k", "in", "var_params", "}", "\n", "\n", "user_params", "=", "{", "\"kwargs\"", ":", "var_params", ",", "\"non_kwargs\"", ":", "non_var_params", "}", "\n", "\n", "return", "user_params", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.train": [[512, 515], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Trains the model.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.save": [[516, 587], ["os.path.join", "_base_model.BaseModelClass.module.state_dict", "_base_model.BaseModelClass.adata.var_names.astype", "var_names.to_numpy.to_numpy.to_numpy", "_base_model.BaseModelClass._get_user_attributes", "torch.save", "os.makedirs", "ValueError", "isinstance", "_base_model.BaseModelClass.adata.write", "dict", "os.path.exists", "isinstance", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_user_attributes", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save"], ["", "def", "save", "(", "\n", "self", ",", "\n", "dir_path", ":", "str", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", "save_anndata", ":", "bool", "=", "False", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Save the state of the model.\n\n        Neither the trainer optimizer state nor the trainer history are saved.\n        Model files are not expected to be reproducibly saved and loaded across versions\n        until we reach version 1.0.\n\n        Parameters\n        ----------\n        dir_path\n            Path to a directory.\n        prefix\n            Prefix to prepend to saved file names.\n        overwrite\n            Overwrite existing data or not. If `False` and directory\n            already exists at `dir_path`, error will be raised.\n        save_anndata\n            If True, also saves the anndata\n        anndata_write_kwargs\n            Kwargs for :meth:`~anndata.AnnData.write`\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n", "dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "\n", "if", "save_anndata", ":", "\n", "            ", "file_suffix", "=", "\"\"", "\n", "if", "isinstance", "(", "self", ".", "adata", ",", "AnnData", ")", ":", "\n", "                ", "file_suffix", "=", "\"adata.h5ad\"", "\n", "", "elif", "isinstance", "(", "self", ".", "adata", ",", "MuData", ")", ":", "\n", "                ", "file_suffix", "=", "\"mdata.h5mu\"", "\n", "", "self", ".", "adata", ".", "write", "(", "\n", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}{file_suffix}\"", ")", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", "\n", "\n", "", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}model.pt\"", ")", "\n", "\n", "# save the model state dict and the trainer state dict only", "\n", "model_state_dict", "=", "self", ".", "module", ".", "state_dict", "(", ")", "\n", "\n", "var_names", "=", "self", ".", "adata", ".", "var_names", ".", "astype", "(", "str", ")", "\n", "var_names", "=", "var_names", ".", "to_numpy", "(", ")", "\n", "\n", "# get all the user attributes", "\n", "user_attributes", "=", "self", ".", "_get_user_attributes", "(", ")", "\n", "# only save the public attributes with _ at the very end", "\n", "user_attributes", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "user_attributes", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "\n", "torch", ".", "save", "(", "\n", "dict", "(", "\n", "model_state_dict", "=", "model_state_dict", ",", "\n", "var_names", "=", "var_names", ",", "\n", "attr_dict", "=", "user_attributes", ",", "\n", ")", ",", "\n", "model_save_path", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.load": [[589, 668], ["scvi.model._utils.parse_use_gpu_arg", "_utils._load_saved_files", "_utils._validate_var_names", "attr_dict.pop", "attr_dict.pop.get", "_utils._initialize_model", "_utils._initialize_model.module.on_load", "_utils._initialize_model.module.load_state_dict", "_utils._initialize_model.to_device", "_utils._initialize_model.module.eval", "_utils._initialize_model._validate_anndata", "ValueError", "ValueError", "getattr"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_saved_files", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._validate_var_names", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._initialize_model", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.on_load", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata"], ["", "@", "classmethod", "\n", "def", "load", "(", "\n", "cls", ",", "\n", "dir_path", ":", "str", ",", "\n", "adata", ":", "Optional", "[", "AnnOrMuData", "]", "=", "None", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "backup_url", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Instantiate a model from the saved output.\n\n        Parameters\n        ----------\n        dir_path\n            Path to saved outputs.\n        adata\n            AnnData organized in the same way as data used to train model.\n            It is not necessary to run setup_anndata,\n            as AnnData is validated against the saved `scvi` setup dictionary.\n            If None, will check for and load anndata saved with the model.\n        use_gpu\n            Load model on default GPU if available (if None or True),\n            or index of GPU to use (if int), or name of GPU (if str), or use CPU (if False).\n        prefix\n            Prefix of saved file names.\n        backup_url\n            URL to retrieve saved outputs from if not present on disk.\n\n        Returns\n        -------\n        Model with loaded state dictionaries.\n\n        Examples\n        --------\n        >>> model = ModelClass.load(save_path, adata) # use the name of the model class used to save\n        >>> model.get_....\n        \"\"\"", "\n", "load_adata", "=", "adata", "is", "None", "\n", "use_gpu", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "(", "attr_dict", ",", "var_names", ",", "model_state_dict", ",", "new_adata", ",", ")", "=", "_load_saved_files", "(", "\n", "dir_path", ",", "\n", "load_adata", ",", "\n", "map_location", "=", "device", ",", "\n", "prefix", "=", "prefix", ",", "\n", "backup_url", "=", "backup_url", ",", "\n", ")", "\n", "adata", "=", "new_adata", "if", "new_adata", "is", "not", "None", "else", "adata", "\n", "_validate_var_names", "(", "adata", ",", "var_names", ")", "\n", "\n", "registry", "=", "attr_dict", ".", "pop", "(", "\"registry_\"", ")", "\n", "if", "_MODEL_NAME_KEY", "in", "registry", "and", "registry", "[", "_MODEL_NAME_KEY", "]", "!=", "cls", ".", "__name__", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"It appears you are loading a model from a different class.\"", "\n", ")", "\n", "\n", "", "if", "_SETUP_ARGS_KEY", "not", "in", "registry", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Saved model does not contain original setup inputs. \"", "\n", "\"Cannot load the original setup.\"", "\n", ")", "\n", "\n", "# Calling ``setup_anndata`` method with the original arguments passed into", "\n", "# the saved model. This enables simple backwards compatibility in the case of", "\n", "# newly introduced fields or parameters.", "\n", "", "method_name", "=", "registry", ".", "get", "(", "_SETUP_METHOD_NAME", ",", "\"setup_anndata\"", ")", "\n", "getattr", "(", "cls", ",", "method_name", ")", "(", "\n", "adata", ",", "source_registry", "=", "registry", ",", "**", "registry", "[", "_SETUP_ARGS_KEY", "]", "\n", ")", "\n", "\n", "model", "=", "_initialize_model", "(", "cls", ",", "adata", ",", "attr_dict", ")", "\n", "model", ".", "module", ".", "on_load", "(", "model", ")", "\n", "model", ".", "module", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "\n", "model", ".", "to_device", "(", "device", ")", "\n", "model", ".", "module", ".", "eval", "(", ")", "\n", "model", ".", "_validate_anndata", "(", "adata", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.convert_legacy_save": [[669, 722], ["scvi.model.base._utils._load_legacy_saved_files", "os.path.join", "torch.save", "os.makedirs", "ValueError", "attr_dict.pop", "attr_dict.get", "scvi.data._compat.registry_from_setup_dict", "dict", "os.path.exists"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_legacy_saved_files", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat.registry_from_setup_dict"], ["", "@", "classmethod", "\n", "def", "convert_legacy_save", "(", "\n", "cls", ",", "\n", "dir_path", ":", "str", ",", "\n", "output_dir_path", ":", "str", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Converts a legacy saved model (<v0.15.0) to the updated save format.\n\n        Parameters\n        ----------\n        dir_path\n            Path to directory where legacy model is saved.\n        output_dir_path\n            Path to save converted save files.\n        overwrite\n            Overwrite existing data or not. If ``False`` and directory\n            already exists at ``output_dir_path``, error will be raised.\n        prefix\n            Prefix of saved file names.\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"{output_dir_path} already exists. Please provide an unexisting directory for saving.\"", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "model_state_dict", ",", "var_names", ",", "attr_dict", ",", "_", "=", "_load_legacy_saved_files", "(", "\n", "dir_path", ",", "file_name_prefix", ",", "load_adata", "=", "False", "\n", ")", "\n", "\n", "if", "\"scvi_setup_dict_\"", "in", "attr_dict", ":", "\n", "            ", "scvi_setup_dict", "=", "attr_dict", ".", "pop", "(", "\"scvi_setup_dict_\"", ")", "\n", "unlabeled_category_key", "=", "\"unlabeled_category_\"", "\n", "unlabeled_category", "=", "attr_dict", ".", "get", "(", "unlabeled_category_key", ",", "None", ")", "\n", "attr_dict", "[", "\"registry_\"", "]", "=", "registry_from_setup_dict", "(", "\n", "cls", ",", "\n", "scvi_setup_dict", ",", "\n", "unlabeled_category", "=", "unlabeled_category", ",", "\n", ")", "\n", "\n", "", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "output_dir_path", ",", "f\"{file_name_prefix}model.pt\"", ")", "\n", "torch", ".", "save", "(", "\n", "dict", "(", "\n", "model_state_dict", "=", "model_state_dict", ",", "\n", "var_names", "=", "var_names", ",", "\n", "attr_dict", "=", "attr_dict", ",", "\n", ")", ",", "\n", "model_save_path", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.__repr__": [[724, 734], ["rich.print"], "methods", ["None"], ["", "def", "__repr__", "(", "\n", "self", ",", "\n", ")", ":", "\n", "        ", "summary_string", "=", "self", ".", "_model_summary_string", "\n", "summary_string", "+=", "\"\\nTraining status: {}\"", ".", "format", "(", "\n", "\"Trained\"", "if", "self", ".", "is_trained_", "else", "\"Not Trained\"", "\n", ")", "\n", "rich", ".", "print", "(", "summary_string", ")", "\n", "\n", "return", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.setup_anndata": [[735, 752], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Each model class deriving from this class provides parameters to this method\n        according to its needs. To operate correctly with the model initialization,\n        the implementation must call :meth:`~scvi.model.base.BaseModelClass.register_manager`\n        on a model-specific instance of :class:`~scvi.data.AnnDataManager`.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_setup_args": [[753, 776], ["attr_dict.pop", "scvi.data.AnnDataManager.view_setup_method_args", "_utils._load_saved_files", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_saved_files"], ["", "@", "staticmethod", "\n", "def", "view_setup_args", "(", "dir_path", ":", "str", ",", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Print args used to setup a saved model.\n\n        Parameters\n        ----------\n        dir_path\n            Path to saved outputs.\n        prefix\n            Prefix of saved file names.\n        \"\"\"", "\n", "attr_dict", "=", "_load_saved_files", "(", "dir_path", ",", "False", ",", "prefix", "=", "prefix", ")", "[", "0", "]", "\n", "\n", "# Legacy support for old setup dict format.", "\n", "if", "\"scvi_setup_dict_\"", "in", "attr_dict", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Viewing setup args for pre v0.15.0 models is unsupported. \"", "\n", "\"Update your save files with ``convert_legacy_save`` first.\"", "\n", ")", "\n", "\n", "", "registry", "=", "attr_dict", ".", "pop", "(", "\"registry_\"", ")", "\n", "AnnDataManager", ".", "view_setup_method_args", "(", "registry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup": [[777, 801], ["_base_model.BaseModelClass.view_registry", "_base_model.BaseModelClass.get_anndata_manager", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "def", "view_anndata_setup", "(", "\n", "self", ",", "adata", ":", "Optional", "[", "AnnOrMuData", "]", "=", "None", ",", "hide_state_registries", ":", "bool", "=", "False", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Print summary of the setup for the initial AnnData or a given AnnData object.\n\n        Parameters\n        ----------\n        adata\n            AnnData object setup with ``setup_anndata`` or\n            :meth:`~scvi.data.AnnDataManager.transfer_fields`.\n        hide_state_registries\n            If True, prints a shortened summary without details of each state registry.\n        \"\"\"", "\n", "if", "adata", "is", "None", ":", "\n", "            ", "adata", "=", "self", ".", "adata", "\n", "", "try", ":", "\n", "            ", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Given AnnData not setup with {self.__class__.__name__}. \"", "\n", "\"Cannot view setup summary.\"", "\n", ")", "\n", "", "adata_manager", ".", "view_registry", "(", "hide_state_registries", "=", "hide_state_registries", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._log_likelihood.compute_elbo": [[5, 29], ["len", "vae", "torch.sum().item", "torch.sum"], "function", ["None"], ["def", "compute_elbo", "(", "vae", ",", "data_loader", ",", "feed_labels", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Computes the ELBO.\n\n    The ELBO is the reconstruction error + the KL divergences\n    between the variational distributions and the priors.\n    It differs from the marginal log likelihood.\n    Specifically, it is a lower bound on the marginal log likelihood\n    plus a term that is constant with respect to the variational distribution.\n    It still gives good insights on the modeling of the data, and is fast to compute.\n    \"\"\"", "\n", "# Iterate once over the data and compute the elbo", "\n", "elbo", "=", "0", "\n", "for", "tensors", "in", "data_loader", ":", "\n", "        ", "_", ",", "_", ",", "scvi_loss", "=", "vae", "(", "tensors", ",", "**", "kwargs", ")", "\n", "\n", "recon_loss", "=", "scvi_loss", ".", "reconstruction_loss", "\n", "kl_local", "=", "scvi_loss", ".", "kl_local", "\n", "elbo", "+=", "torch", ".", "sum", "(", "recon_loss", "+", "kl_local", ")", ".", "item", "(", ")", "\n", "\n", "", "kl_global", "=", "scvi_loss", ".", "kl_global", "\n", "n_samples", "=", "len", "(", "data_loader", ".", "indices", ")", "\n", "elbo", "+=", "kl_global", "\n", "return", "elbo", "/", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._log_likelihood.compute_reconstruction_error": [[32, 55], ["len", "log_lkl.items", "dict", "vae", "losses._reconstruction_loss.items", "torch.sum().item", "torch.sum"], "function", ["None"], ["", "def", "compute_reconstruction_error", "(", "vae", ",", "data_loader", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Computes log p(x/z), which is the reconstruction error.\n\n    Differs from the marginal log likelihood, but still gives good\n    insights on the modeling of the data, and is fast to compute.\n    \"\"\"", "\n", "# Iterate once over the data and computes the reconstruction error", "\n", "log_lkl", "=", "{", "}", "\n", "for", "tensors", "in", "data_loader", ":", "\n", "        ", "loss_kwargs", "=", "dict", "(", "kl_weight", "=", "1", ")", "\n", "_", ",", "_", ",", "losses", "=", "vae", "(", "tensors", ",", "loss_kwargs", "=", "loss_kwargs", ")", "\n", "for", "key", ",", "value", "in", "losses", ".", "_reconstruction_loss", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", "in", "log_lkl", ":", "\n", "                ", "log_lkl", "[", "key", "]", "+=", "torch", ".", "sum", "(", "value", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                ", "log_lkl", "[", "key", "]", "=", "0.0", "\n", "\n", "", "", "", "n_samples", "=", "len", "(", "data_loader", ".", "indices", ")", "\n", "for", "key", ",", "value", "in", "log_lkl", ".", "items", "(", ")", ":", "\n", "        ", "log_lkl", "[", "key", "]", "=", "log_lkl", "[", "key", "]", "/", "n_samples", "\n", "log_lkl", "[", "key", "]", "=", "-", "log_lkl", "[", "key", "]", "\n", "", "return", "log_lkl", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._training_mixin.UnsupervisedTrainingMixin.train": [[12, 78], ["scvi.dataloaders.DataSplitter", "scvi.train.TrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "numpy.min", "isinstance", "dict", "trainer_kwargs.keys", "round"], "methods", ["None"], ["def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "early_stopping", ":", "bool", "=", "False", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        early_stopping\n            Perform early stopping. Additional arguments can be passed in `**kwargs`.\n            See :class:`~scvi.train.Trainer` for further options.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.TrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **trainer_kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "if", "max_epochs", "is", "None", ":", "\n", "            ", "n_cells", "=", "self", ".", "adata", ".", "n_obs", "\n", "max_epochs", "=", "np", ".", "min", "(", "[", "round", "(", "(", "20000", "/", "n_cells", ")", "*", "400", ")", ",", "400", "]", ")", "\n", "\n", "", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "\n", "data_splitter", "=", "DataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "training_plan", "=", "TrainingPlan", "(", "self", ".", "module", ",", "**", "plan_kwargs", ")", "\n", "\n", "es", "=", "\"early_stopping\"", "\n", "trainer_kwargs", "[", "es", "]", "=", "(", "\n", "early_stopping", "if", "es", "not", "in", "trainer_kwargs", ".", "keys", "(", ")", "else", "trainer_kwargs", "[", "es", "]", "\n", ")", "\n", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", "\n", "return", "runner", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_legacy_saved_files": [[25, 53], ["os.path.join", "os.path.join", "os.path.join", "torch.load", "numpy.genfromtxt", "open", "pickle.load", "os.path.join", "os.path.exists", "anndata.read", "os.path.exists", "ValueError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._load_saved_files": [[55, 101], ["os.path.join", "os.path.join", "scvi.data._download._download", "torch.load", "registry.get", "os.path.exists", "ValueError", "ValueError", "mudata.read", "anndata.read"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._initialize_model": [[103, 139], ["attr_dict.pop", "cls", "attr_dict.items", "attr_dict.keys", "ValueError", "attr_dict.pop.keys", "non_kwargs.pop", "non_kwargs.keys", "non_kwargs.pop", "non_kwargs.keys", "non_kwargs.pop", "setattr", "kwargs.items", "j.items", "attr_dict.pop.items", "attr_dict.pop.items", "isinstance", "kwargs.items", "j.items", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._validate_var_names": [[141, 147], ["adata.var_names.astype", "numpy.array_equal", "warnings.warn"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._prepare_obs": [[152, 198], ["_utils._prepare_obs.ravel_idx"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core": [[200, 288], ["_differential.DifferentialComputation", "scvi.utils.track", "pandas.concat", "adata.obs[].astype().cat.categories.tolist", "isinstance", "_utils._prepare_obs", "_differential.DifferentialComputation.get_bayes_factors", "pandas.DataFrame", "res.sort_values.sort_values", "df_results.append", "len", "ValueError", "isinstance", "all_stats_fn", "_utils._fdr_de_prediction", "adata.obs[].astype"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._prepare_obs", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._fdr_de_prediction"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._fdr_de_prediction": [[290, 302], ["numpy.argsort", "numpy.zeros_like().astype", "ValueError", "numpy.arange", "numpy.zeros_like", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin._get_transform_batch_gen_kwargs": [[27, 33], ["dict", "NotImplementedError", "inspect.signature"], "methods", ["None"], ["def", "_get_transform_batch_gen_kwargs", "(", "self", ",", "batch", ")", ":", "\n", "        ", "if", "\"transform_batch\"", "in", "inspect", ".", "signature", "(", "self", ".", "module", ".", "generative", ")", ".", "parameters", ":", "\n", "            ", "return", "dict", "(", "transform_batch", "=", "batch", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Transforming batches is not implemented for this model.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.get_normalized_expression": [[35, 161], ["torch.no_grad", "_rnamixin.RNASeqMixin._validate_anndata", "_rnamixin.RNASeqMixin._make_data_loader", "_utils._get_batch_code_from_category", "numpy.arange", "numpy.random.choice", "_rnamixin.RNASeqMixin.get_anndata_manager", "slice", "numpy.stack", "numpy.concatenate", "numpy.concatenate", "exprs.mean.mean.mean", "pandas.DataFrame", "warnings.warn", "_rnamixin.RNASeqMixin._get_transform_batch_gen_kwargs", "dict", "_rnamixin.RNASeqMixin.module.forward", "getattr", "output.cpu().numpy.cpu().numpy.cpu().numpy", "numpy.stack.append", "numpy.stack.mean", "output.cpu().numpy.cpu().numpy.cpu"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin._get_transform_batch_gen_kwargs", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_normalized_expression", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "gene_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "library_size", ":", "Union", "[", "float", ",", "Literal", "[", "\"latent\"", "]", "]", "=", "1", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "n_samples_overall", ":", "int", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_mean", ":", "bool", "=", "True", ",", "\n", "return_numpy", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "r\"\"\"\n        Returns the normalized (decoded) gene expression.\n\n        This is denoted as :math:`\\rho_n` in the scVI paper.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used.\n            - int, then batch transform_batch is used.\n        gene_list\n            Return frequencies of expression for a subset of genes.\n            This can save memory when working with large datasets and few genes are\n            of interest.\n        library_size\n            Scale the expression frequencies to a common library size.\n            This allows gene expression levels to be interpreted on a common scale of relevant\n            magnitude. If set to `\"latent\"`, use the latent libary size.\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        return_mean\n            Whether to return the mean of the samples.\n        return_numpy\n            Return a :class:`~numpy.ndarray` instead of a :class:`~pandas.DataFrame`. DataFrame includes\n            gene names as columns. If either `n_samples=1` or `return_mean=True`, defaults to `False`.\n            Otherwise, it defaults to `True`.\n\n        Returns\n        -------\n        If `n_samples` > 1 and `return_mean` is False, then the shape is `(samples, cells, genes)`.\n        Otherwise, shape is `(cells, genes)`. In this case, return type is :class:`~pandas.DataFrame` unless `return_numpy` is True.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "n_samples_overall", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "n_samples_overall", ")", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "transform_batch", "=", "_get_batch_code_from_category", "(", "\n", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "transform_batch", "\n", ")", "\n", "\n", "if", "gene_list", "is", "None", ":", "\n", "            ", "gene_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_genes", "=", "adata", ".", "var_names", "\n", "gene_mask", "=", "[", "True", "if", "gene", "in", "gene_list", "else", "False", "for", "gene", "in", "all_genes", "]", "\n", "\n", "", "if", "n_samples", ">", "1", "and", "return_mean", "is", "False", ":", "\n", "            ", "if", "return_numpy", "is", "False", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"return_numpy must be True if n_samples > 1 and return_mean is False, returning np.ndarray\"", "\n", ")", "\n", "", "return_numpy", "=", "True", "\n", "", "if", "library_size", "==", "\"latent\"", ":", "\n", "            ", "generative_output_key", "=", "\"mu\"", "\n", "scaling", "=", "1", "\n", "", "else", ":", "\n", "            ", "generative_output_key", "=", "\"scale\"", "\n", "scaling", "=", "library_size", "\n", "\n", "", "exprs", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "per_batch_exprs", "=", "[", "]", "\n", "for", "batch", "in", "transform_batch", ":", "\n", "                ", "generative_kwargs", "=", "self", ".", "_get_transform_batch_gen_kwargs", "(", "batch", ")", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "output", "=", "getattr", "(", "generative_outputs", "[", "\"px\"", "]", ",", "generative_output_key", ")", "\n", "output", "=", "output", "[", "...", ",", "gene_mask", "]", "\n", "output", "*=", "scaling", "\n", "output", "=", "output", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "per_batch_exprs", ".", "append", "(", "output", ")", "\n", "", "per_batch_exprs", "=", "np", ".", "stack", "(", "\n", "per_batch_exprs", "\n", ")", "# shape is (len(transform_batch) x batch_size x n_var)", "\n", "exprs", "+=", "[", "per_batch_exprs", ".", "mean", "(", "0", ")", "]", "\n", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "# The -2 axis correspond to cells.", "\n", "            ", "exprs", "=", "np", ".", "concatenate", "(", "exprs", ",", "axis", "=", "-", "2", ")", "\n", "", "else", ":", "\n", "            ", "exprs", "=", "np", ".", "concatenate", "(", "exprs", ",", "axis", "=", "0", ")", "\n", "", "if", "n_samples", ">", "1", "and", "return_mean", ":", "\n", "            ", "exprs", "=", "exprs", ".", "mean", "(", "0", ")", "\n", "\n", "", "if", "return_numpy", "is", "None", "or", "return_numpy", "is", "False", ":", "\n", "            ", "return", "pd", ".", "DataFrame", "(", "\n", "exprs", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", "gene_mask", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "exprs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.differential_expression": [[162, 230], ["scvi._utils._doc_params", "_rnamixin.RNASeqMixin._validate_anndata", "functools.partial", "_utils._de_core", "_rnamixin.RNASeqMixin.get_anndata_manager"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "", "@", "_doc_params", "(", "\n", "doc_differential_expression", "=", "doc_differential_expression", ",", "\n", ")", "\n", "def", "differential_expression", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "groupby", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "group1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "group2", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "idx1", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "idx2", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"change\"", ",", "\n", "delta", ":", "float", "=", "0.25", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "all_stats", ":", "bool", "=", "True", ",", "\n", "batch_correction", ":", "bool", "=", "False", ",", "\n", "batchid1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "fdr_target", ":", "float", "=", "0.05", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential expression analysis.\n\n        Implements `\"vanilla\"` DE [Lopez18]_ and `\"change\"` mode DE [Boyeau19]_.\n\n        Parameters\n        ----------\n        {doc_differential_expression}\n        **kwargs\n            Keyword args for :meth:`scvi.model.base.DifferentialComputation.get_bayes_factors`\n\n        Returns\n        -------\n        Differential expression DataFrame.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "col_names", "=", "adata", ".", "var_names", "\n", "model_fn", "=", "partial", "(", "\n", "self", ".", "get_normalized_expression", ",", "\n", "return_numpy", "=", "True", ",", "\n", "n_samples", "=", "1", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", ")", "\n", "result", "=", "_de_core", "(", "\n", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "\n", "model_fn", ",", "\n", "groupby", ",", "\n", "group1", ",", "\n", "group2", ",", "\n", "idx1", ",", "\n", "idx2", ",", "\n", "all_stats", ",", "\n", "scrna_raw_counts_properties", ",", "\n", "col_names", ",", "\n", "mode", ",", "\n", "batchid1", ",", "\n", "batchid2", ",", "\n", "delta", ",", "\n", "batch_correction", ",", "\n", "fdr_target", ",", "\n", "silent", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.posterior_predictive_sample": [[231, 291], ["torch.no_grad", "_rnamixin.RNASeqMixin._validate_anndata", "_rnamixin.RNASeqMixin._make_data_loader", "torch.cat", "torch.cat.numpy", "ValueError", "numpy.arange", "slice", "_rnamixin.RNASeqMixin.module.sample", "torch.cat.append"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "posterior_predictive_sample", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "gene_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Generate observation samples from the posterior predictive distribution.\n\n        The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of samples for each cell.\n        gene_list\n            Names of genes of interest.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        x_new : :py:class:`torch.Tensor`\n            tensor with shape (n_cells, n_genes, n_samples)\n        \"\"\"", "\n", "if", "self", ".", "module", ".", "gene_likelihood", "not", "in", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid gene_likelihood.\"", ")", "\n", "\n", "", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "if", "gene_list", "is", "None", ":", "\n", "            ", "gene_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_genes", "=", "adata", ".", "var_names", "\n", "gene_mask", "=", "[", "True", "if", "gene", "in", "gene_list", "else", "False", "for", "gene", "in", "all_genes", "]", "\n", "\n", "", "x_new", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "samples", "=", "self", ".", "module", ".", "sample", "(", "tensors", ",", "n_samples", "=", "n_samples", ")", "\n", "if", "gene_list", "is", "not", "None", ":", "\n", "                ", "samples", "=", "samples", "[", ":", ",", "gene_mask", ",", "...", "]", "\n", "", "x_new", ".", "append", "(", "samples", ")", "\n", "\n", "", "x_new", "=", "torch", ".", "cat", "(", "x_new", ")", "# Shape (n_cells, n_genes, n_samples)", "\n", "\n", "return", "x_new", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin._get_denoised_samples": [[292, 365], ["torch.no_grad", "_rnamixin.RNASeqMixin._validate_anndata", "_rnamixin.RNASeqMixin._make_data_loader", "numpy.concatenate", "_rnamixin.RNASeqMixin._get_transform_batch_gen_kwargs", "dict", "_rnamixin.RNASeqMixin.module.forward", "torch.distributions.Gamma().sample", "torch.distributions.Gamma().sample.cpu().numpy", "numpy.transpose", "len", "px_r.size", "torch.ones_like().to", "torch.distributions.Gamma", "torch.distributions.Gamma().sample.cpu", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin._get_transform_batch_gen_kwargs", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_get_denoised_samples", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "batch_size", ":", "int", "=", "64", ",", "\n", "rna_size_factor", ":", "int", "=", "1000", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return samples from an adjusted posterior predictive.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        rna_size_factor\n            size factor for RNA prior to sampling gamma distribution.\n        transform_batch\n            int of which batch to condition on for all cells.\n\n        Returns\n        -------\n        denoised_samples\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "data_loader_list", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "generative_kwargs", "=", "self", ".", "_get_transform_batch_gen_kwargs", "(", "transform_batch", ")", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "px_scale", "=", "generative_outputs", "[", "\"px\"", "]", ".", "scale", "\n", "px_r", "=", "generative_outputs", "[", "\"px\"", "]", ".", "theta", "\n", "device", "=", "px_r", ".", "device", "\n", "\n", "rate", "=", "rna_size_factor", "*", "px_scale", "\n", "if", "len", "(", "px_r", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "                ", "px_dispersion", "=", "px_r", "\n", "", "else", ":", "\n", "                ", "px_dispersion", "=", "torch", ".", "ones_like", "(", "x", ")", ".", "to", "(", "device", ")", "*", "px_r", "\n", "\n", "# This gamma is really l*w using scVI manuscript notation", "\n", "", "p", "=", "rate", "/", "(", "rate", "+", "px_dispersion", ")", "\n", "r", "=", "px_dispersion", "\n", "l_train", "=", "torch", ".", "distributions", ".", "Gamma", "(", "r", ",", "(", "1", "-", "p", ")", "/", "p", ")", ".", "sample", "(", ")", "\n", "data", "=", "l_train", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# \"\"\"", "\n", "# In numpy (shape, scale) => (concentration, rate), with scale = p /(1 - p)", "\n", "# rate = (1 - p) / p  # = 1/scale # used in pytorch", "\n", "# \"\"\"", "\n", "data_loader_list", "+=", "[", "data", "]", "\n", "\n", "data_loader_list", "[", "-", "1", "]", "=", "np", ".", "transpose", "(", "data_loader_list", "[", "-", "1", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n", "", "return", "np", ".", "concatenate", "(", "data_loader_list", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.get_feature_correlation_matrix": [[366, 444], ["torch.no_grad", "_rnamixin.RNASeqMixin._validate_anndata", "_utils._get_batch_code_from_category", "numpy.mean", "pandas.DataFrame", "_rnamixin.RNASeqMixin.get_anndata_manager", "_rnamixin.RNASeqMixin._get_denoised_samples", "numpy.zeros", "range", "corr_mats.append", "numpy.stack", "numpy.corrcoef", "spearmanr", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._get_denoised_samples"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_feature_correlation_matrix", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "10", ",", "\n", "batch_size", ":", "int", "=", "64", ",", "\n", "rna_size_factor", ":", "int", "=", "1000", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "correlation_type", ":", "Literal", "[", "\"spearman\"", ",", "\"pearson\"", "]", "=", "\"spearman\"", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "\"\"\"\n        Generate gene-gene correlation matrix using scvi uncertainty and expression.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        rna_size_factor\n            size factor for RNA prior to sampling gamma distribution.\n        transform_batch\n            Batches to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used.\n            - int, then batch transform_batch is used.\n            - list of int, then values are averaged over provided batches.\n        correlation_type\n            One of \"pearson\", \"spearman\".\n\n        Returns\n        -------\n        Gene-gene correlation matrix\n        \"\"\"", "\n", "from", "scipy", ".", "stats", "import", "spearmanr", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "transform_batch", "=", "_get_batch_code_from_category", "(", "\n", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "transform_batch", "\n", ")", "\n", "\n", "corr_mats", "=", "[", "]", "\n", "for", "b", "in", "transform_batch", ":", "\n", "            ", "denoised_data", "=", "self", ".", "_get_denoised_samples", "(", "\n", "adata", "=", "adata", ",", "\n", "indices", "=", "indices", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "rna_size_factor", "=", "rna_size_factor", ",", "\n", "transform_batch", "=", "b", ",", "\n", ")", "\n", "flattened", "=", "np", ".", "zeros", "(", "\n", "(", "denoised_data", ".", "shape", "[", "0", "]", "*", "n_samples", ",", "denoised_data", ".", "shape", "[", "1", "]", ")", "\n", ")", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "                ", "flattened", "[", "\n", "denoised_data", ".", "shape", "[", "0", "]", "*", "(", "i", ")", ":", "denoised_data", ".", "shape", "[", "0", "]", "*", "(", "i", "+", "1", ")", "\n", "]", "=", "denoised_data", "[", ":", ",", ":", ",", "i", "]", "\n", "", "if", "correlation_type", "==", "\"pearson\"", ":", "\n", "                ", "corr_matrix", "=", "np", ".", "corrcoef", "(", "flattened", ",", "rowvar", "=", "False", ")", "\n", "", "elif", "correlation_type", "==", "\"spearman\"", ":", "\n", "                ", "corr_matrix", ",", "_", "=", "spearmanr", "(", "flattened", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Unknown correlation type. Choose one of 'spearman', 'pearson'.\"", "\n", ")", "\n", "", "corr_mats", ".", "append", "(", "corr_matrix", ")", "\n", "", "corr_matrix", "=", "np", ".", "mean", "(", "np", ".", "stack", "(", "corr_mats", ")", ",", "axis", "=", "0", ")", "\n", "var_names", "=", "adata", ".", "var_names", "\n", "return", "pd", ".", "DataFrame", "(", "corr_matrix", ",", "index", "=", "var_names", ",", "columns", "=", "var_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.get_likelihood_parameters": [[445, 518], ["torch.no_grad", "_rnamixin.RNASeqMixin._validate_anndata", "_rnamixin.RNASeqMixin._make_data_loader", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "dict", "_rnamixin.RNASeqMixin.module.forward", "px_r.cpu().numpy.cpu().numpy.cpu().numpy", "dropout.mean.mean.mean", "means.mean.mean.mean", "px_rate.size", "px_rate.size", "len", "px_rate.cpu().numpy", "px_dropout.cpu().numpy", "px_r.cpu().numpy.cpu().numpy.cpu", "numpy.repeat", "px_rate.cpu", "px_dropout.cpu"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_likelihood_parameters", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "Optional", "[", "int", "]", "=", "1", ",", "\n", "give_mean", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "r\"\"\"\n        Estimates for the parameters of the likelihood :math:`p(x \\mid z)`\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of posterior samples to use for estimation.\n        give_mean\n            Return expected value of parameters or a samples\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "dropout_list", "=", "[", "]", "\n", "mean_list", "=", "[", "]", "\n", "dispersion_list", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "px", "=", "generative_outputs", "[", "\"px\"", "]", "\n", "px_r", "=", "px", ".", "theta", "\n", "px_rate", "=", "px", ".", "mu", "\n", "px_dropout", "=", "px", ".", "zi_probs", "\n", "\n", "n_batch", "=", "px_rate", ".", "size", "(", "0", ")", "if", "n_samples", "==", "1", "else", "px_rate", ".", "size", "(", "1", ")", "\n", "\n", "px_r", "=", "px_r", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "px_r", ".", "shape", ")", "==", "1", ":", "\n", "                ", "dispersion_list", "+=", "[", "np", ".", "repeat", "(", "px_r", "[", "np", ".", "newaxis", ",", ":", "]", ",", "n_batch", ",", "axis", "=", "0", ")", "]", "\n", "", "else", ":", "\n", "                ", "dispersion_list", "+=", "[", "px_r", "]", "\n", "", "mean_list", "+=", "[", "px_rate", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", "\n", "dropout_list", "+=", "[", "px_dropout", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", "\n", "\n", "", "dropout", "=", "np", ".", "concatenate", "(", "dropout_list", ",", "axis", "=", "-", "2", ")", "\n", "means", "=", "np", ".", "concatenate", "(", "mean_list", ",", "axis", "=", "-", "2", ")", "\n", "dispersions", "=", "np", ".", "concatenate", "(", "dispersion_list", ",", "axis", "=", "-", "2", ")", "\n", "if", "give_mean", "and", "n_samples", ">", "1", ":", "\n", "            ", "dropout", "=", "dropout", ".", "mean", "(", "0", ")", "\n", "means", "=", "means", ".", "mean", "(", "0", ")", "\n", "\n", "", "return_dict", "=", "{", "}", "\n", "return_dict", "[", "\"mean\"", "]", "=", "means", "\n", "\n", "if", "self", ".", "module", ".", "gene_likelihood", "==", "\"zinb\"", ":", "\n", "            ", "return_dict", "[", "\"dropout\"", "]", "=", "dropout", "\n", "return_dict", "[", "\"dispersions\"", "]", "=", "dispersions", "\n", "", "if", "self", ".", "module", ".", "gene_likelihood", "==", "\"nb\"", ":", "\n", "            ", "return_dict", "[", "\"dispersions\"", "]", "=", "dispersions", "\n", "\n", "", "return", "return_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._rnamixin.RNASeqMixin.get_latent_library_size": [[519, 569], ["torch.no_grad", "_rnamixin.RNASeqMixin._check_if_trained", "_rnamixin.RNASeqMixin._validate_anndata", "_rnamixin.RNASeqMixin._make_data_loader", "torch.cat().numpy", "_rnamixin.RNASeqMixin.module._get_inference_input", "_rnamixin.RNASeqMixin.module.inference", "torch.exp", "torch.exp.cpu", "torch.cat", "RuntimeError", "torch.distributions.LogNormal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_library_size", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "give_mean", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Returns the latent library size for each cell.\n\n        This is denoted as :math:`\\ell_n` in the scVI paper.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        give_mean\n            Return the mean or a sample from the posterior distribution.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", "warn", "=", "False", ")", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "libraries", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "\n", "library", "=", "outputs", "[", "\"library\"", "]", "\n", "if", "not", "give_mean", ":", "\n", "                ", "library", "=", "torch", ".", "exp", "(", "library", ")", "\n", "", "else", ":", "\n", "                ", "ql", "=", "outputs", "[", "\"ql\"", "]", "\n", "if", "ql", "is", "None", ":", "\n", "\n", "                    ", "raise", "RuntimeError", "(", "\n", "\"The module for this model does not compute the posterior distribution \"", "\n", "\"for the library size. Set `give_mean` to False to use the observed library size instead.\"", "\n", ")", "\n", "", "library", "=", "torch", ".", "distributions", ".", "LogNormal", "(", "ql", ".", "loc", ",", "ql", ".", "scale", ")", ".", "mean", "\n", "", "libraries", "+=", "[", "library", ".", "cpu", "(", ")", "]", "\n", "", "return", "torch", ".", "cat", "(", "libraries", ")", ".", "numpy", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.__init__": [[35, 39], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model_fn", ",", "adata_manager", ")", ":", "\n", "        ", "self", ".", "adata_manager", "=", "adata_manager", "\n", "self", ".", "adata", "=", "adata_manager", ".", "adata", "\n", "self", ".", "model_fn", "=", "model_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors": [[40, 344], ["_differential.DifferentialComputation.scale_sampler", "_differential.DifferentialComputation.scale_sampler", "scales_batches_1[].mean", "scales_batches_2[].mean", "numpy.unique", "numpy.unique", "logger.debug", "logger.debug", "len", "logger.debug", "set", "numpy.concatenate", "numpy.concatenate", "logger.debug", "_differential.pairs_sampler", "logger.debug", "_differential.DifferentialComputation.adata_manager.get_from_registry", "_differential.estimate_pseudocounts_offset", "logger.debug", "numpy.mean", "dict", "set", "set", "set", "_differential.pairs_sampler", "numpy.concatenate.append", "numpy.concatenate.append", "len", "warnings.warn", "_differential.densify", "_differential.densify", "logger.debug", "inspect.getfullargspec", "inspect.getfullargspec", "numpy.mean", "_differential.describe_continuous_distrib", "dict", "NotImplementedError", "set().intersection", "numpy.max", "numpy.max", "ValueError", "change_fn", "_differential.DifferentialComputation.get_bayes_factors.m1_domain_fn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.scale_sampler", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.scale_sampler", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.pairs_sampler", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.estimate_pseudocounts_offset", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.pairs_sampler", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.densify", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.densify", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.describe_continuous_distrib"], ["", "def", "get_bayes_factors", "(", "\n", "self", ",", "\n", "idx1", ":", "Union", "[", "List", "[", "bool", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "idx2", ":", "Union", "[", "List", "[", "bool", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"vanilla\"", ",", "\n", "batchid1", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "use_observed_batches", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "n_samples", ":", "int", "=", "5000", ",", "\n", "use_permutation", ":", "bool", "=", "False", ",", "\n", "m_permutation", ":", "int", "=", "10000", ",", "\n", "change_fn", ":", "Optional", "[", "Union", "[", "str", ",", "Callable", "]", "]", "=", "None", ",", "\n", "m1_domain_fn", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "delta", ":", "Optional", "[", "float", "]", "=", "0.5", ",", "\n", "pseudocounts", ":", "Union", "[", "float", ",", "None", "]", "=", "0.0", ",", "\n", "cred_interval_lvls", ":", "Optional", "[", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", "]", "]", "=", "None", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential expression inference.\n\n        Two modes coexist:\n\n        - the `\"vanilla\"` mode follows protocol described in [Lopez18]_ and [Xu21]_\n        In this case, we perform hypothesis testing based on the hypotheses\n\n        .. math::\n            M_1: h_1 > h_2 ~\\text{and}~ M_2: h_1 \\leq h_2.\n\n        DE can then be based on the study of the Bayes factors\n\n        .. math::\n            \\log p(M_1\u00a0| x_1, x_2) / p(M_2 | x_1, x_2).\n\n        - the `\"change\"` mode (described in [Boyeau19]_)\n        This mode consists of estimating an effect size random variable (e.g., log fold-change) and\n        performing Bayesian hypothesis testing on this variable.\n        The `change_fn` function computes the effect size variable :math:`r` based on two inputs\n        corresponding to the posterior quantities (e.g., normalized expression) in both populations.\n\n        Hypotheses:\n\n        .. math::\n            M_1: r \\in R_1 ~\\text{(effect size r in region inducing differential expression)}\n\n        .. math::\n            M_2: r  \\notin R_1 ~\\text{(no differential expression)}\n\n        To characterize the region :math:`R_1`, which induces DE, the user has two choices.\n\n        1. A common case is when the region :math:`[-\\delta, \\delta]` does not induce differential\n           expression. If the user specifies a threshold delta, we suppose that :math:`R_1 = \\mathbb{R} \\setminus [-\\delta, \\delta]`\n        2. Specify an specific indicator function:\n\n        .. math::\n            f: \\mathbb{R} \\mapsto \\{0, 1\\} ~\\text{s.t.}~ r \\in R_1 ~\\text{iff.}~ f(r) = 1.\n\n        Decision-making can then be based on the estimates of\n\n        .. math::\n            p(M_1 \\mid x_1, x_2).\n\n        Both modes require to sample the posterior distributions.\n        To that purpose, we sample the posterior in the following way:\n\n        1. The posterior is sampled `n_samples` times for each subpopulation.\n        2. For computational efficiency (posterior sampling is quite expensive), instead of\n           comparing the obtained samples element-wise, we can permute posterior samples.\n           Remember that computing the Bayes Factor requires sampling :math:`q(z_A \\mid x_A)` and :math:`q(z_B \\mid x_B)`.\n\n        Currently, the code covers several batch handling configurations:\n\n        1. If ``use_observed_batches=True``, then batch are considered as observations\n           and cells' normalized means are conditioned on real batch observations.\n        2. If case (cell group 1) and control (cell group 2) are conditioned on the same\n           batch ids. This requires ``set(batchid1) == set(batchid2)`` or ``batchid1 == batchid2 === None``.\n        3. If case and control are conditioned on different batch ids that do not intersect\n           i.e., ``set(batchid1) != set(batchid2)`` and ``len(set(batchid1).intersection(set(batchid2))) == 0``.\n\n        This function does not cover other cases yet and will warn users in such cases.\n\n        Parameters\n        ----------\n        mode\n            one of [\"vanilla\", \"change\"]\n        idx1\n            bool array masking subpopulation cells 1. Should be True where cell is\n            from associated population\n        idx2\n            bool array masking subpopulation cells 2. Should be True where cell is\n            from associated population\n        batchid1\n            List of batch ids for which you want to perform DE Analysis for\n            subpopulation 1. By default, all ids are taken into account\n        batchid2\n            List of batch ids for which you want to perform DE Analysis for\n            subpopulation 2. By default, all ids are taken into account\n        use_observed_batches\n            Whether posterior values are conditioned on observed\n            batches\n        n_samples\n            Number of posterior samples\n        use_permutation\n            Activates step 2 described above.\n            Simply formulated, pairs obtained from posterior sampling\n            will be randomly permuted so that the number of pairs used\n            to compute Bayes Factors becomes `m_permutation`.\n        m_permutation\n            Number of times we will \"mix\" posterior samples in step 2.\n            Only makes sense when `use_permutation=True`\n        change_fn\n            function computing effect size based on both posterior values\n        m1_domain_fn\n            custom indicator function of effect size regions\n            inducing differential expression\n        delta\n            specific case of region inducing differential expression.\n            In this case, we suppose that :math:`R \\setminus [-\\delta, \\delta]` does not induce differential expression\n            (LFC case). If the provided value is `None`, then a proper threshold is determined\n            from the distribution of LFCs accross genes.\n        pseudocounts\n            pseudocount offset used for the mode `change`.\n            When None, observations from non-expressed genes are used to estimate its value.\n        cred_interval_lvls\n            List of credible interval levels to compute for the posterior\n            LFC distribution\n\n        Returns\n        -------\n        Differential expression properties\n\n        \"\"\"", "\n", "# if not np.array_equal(self.indices, np.arange(len(self.dataset))):", "\n", "#     warnings.warn(", "\n", "#         \"Differential expression requires a Posterior object created with all indices.\"", "\n", "#     )", "\n", "eps", "=", "1e-8", "\n", "# Normalized means sampling for both populations", "\n", "scales_batches_1", "=", "self", ".", "scale_sampler", "(", "\n", "selection", "=", "idx1", ",", "\n", "batchid", "=", "batchid1", ",", "\n", "use_observed_batches", "=", "use_observed_batches", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", ")", "\n", "scales_batches_2", "=", "self", ".", "scale_sampler", "(", "\n", "selection", "=", "idx2", ",", "\n", "batchid", "=", "batchid2", ",", "\n", "use_observed_batches", "=", "use_observed_batches", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", ")", "\n", "\n", "px_scale_mean1", "=", "scales_batches_1", "[", "\"scale\"", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "px_scale_mean2", "=", "scales_batches_2", "[", "\"scale\"", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "# Sampling pairs", "\n", "# The objective of code section below is to ensure than the samples of normalized", "\n", "# means we consider are conditioned on the same batch id", "\n", "batchid1_vals", "=", "np", ".", "unique", "(", "scales_batches_1", "[", "\"batch\"", "]", ")", "\n", "batchid2_vals", "=", "np", ".", "unique", "(", "scales_batches_2", "[", "\"batch\"", "]", ")", "\n", "\n", "create_pairs_from_same_batches", "=", "(", "\n", "set", "(", "batchid1_vals", ")", "==", "set", "(", "batchid2_vals", ")", "\n", ")", "and", "not", "use_observed_batches", "\n", "if", "create_pairs_from_same_batches", ":", "\n", "# First case: same batch normalization in two groups", "\n", "            ", "logger", ".", "debug", "(", "\"Same batches in both cell groups\"", ")", "\n", "n_batches", "=", "len", "(", "set", "(", "batchid1_vals", ")", ")", "\n", "n_samples_per_batch", "=", "(", "\n", "m_permutation", "//", "n_batches", "if", "m_permutation", "is", "not", "None", "else", "None", "\n", ")", "\n", "logger", ".", "debug", "(", "\n", "\"Using {} samples per batch for pair matching\"", ".", "format", "(", "\n", "n_samples_per_batch", "\n", ")", "\n", ")", "\n", "scales_1", "=", "[", "]", "\n", "scales_2", "=", "[", "]", "\n", "for", "batch_val", "in", "set", "(", "batchid1_vals", ")", ":", "\n", "# Select scale samples that originate from the same batch id", "\n", "                ", "scales_1_batch", "=", "scales_batches_1", "[", "\"scale\"", "]", "[", "\n", "scales_batches_1", "[", "\"batch\"", "]", "==", "batch_val", "\n", "]", "\n", "scales_2_batch", "=", "scales_batches_2", "[", "\"scale\"", "]", "[", "\n", "scales_batches_2", "[", "\"batch\"", "]", "==", "batch_val", "\n", "]", "\n", "\n", "# Create more pairs", "\n", "scales_1_local", ",", "scales_2_local", "=", "pairs_sampler", "(", "\n", "scales_1_batch", ",", "\n", "scales_2_batch", ",", "\n", "use_permutation", "=", "use_permutation", ",", "\n", "m_permutation", "=", "n_samples_per_batch", ",", "\n", ")", "\n", "scales_1", ".", "append", "(", "scales_1_local", ")", "\n", "scales_2", ".", "append", "(", "scales_2_local", ")", "\n", "", "scales_1", "=", "np", ".", "concatenate", "(", "scales_1", ",", "axis", "=", "0", ")", "\n", "scales_2", "=", "np", ".", "concatenate", "(", "scales_2", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "debug", "(", "\"Ignoring batch conditionings to compare means\"", ")", "\n", "if", "len", "(", "set", "(", "batchid1_vals", ")", ".", "intersection", "(", "set", "(", "batchid2_vals", ")", ")", ")", ">=", "1", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Batchids of cells groups 1 and 2 are different but have an non-null \"", "\n", "\"intersection. Specific handling of such situations is not implemented \"", "\n", "\"yet and batch correction is not trustworthy.\"", "\n", ")", "\n", "", "scales_1", ",", "scales_2", "=", "pairs_sampler", "(", "\n", "scales_batches_1", "[", "\"scale\"", "]", ",", "\n", "scales_batches_2", "[", "\"scale\"", "]", ",", "\n", "use_permutation", "=", "use_permutation", ",", "\n", "m_permutation", "=", "m_permutation", ",", "\n", ")", "\n", "\n", "# Adding pseudocounts to the scales", "\n", "", "if", "pseudocounts", "is", "None", ":", "\n", "            ", "logger", ".", "debug", "(", "\"Estimating pseudocounts offet from the data\"", ")", "\n", "x", "=", "self", ".", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", "\n", "where_zero_a", "=", "densify", "(", "np", ".", "max", "(", "x", "[", "idx1", "]", ",", "0", ")", ")", "==", "0", "\n", "where_zero_b", "=", "densify", "(", "np", ".", "max", "(", "x", "[", "idx2", "]", ",", "0", ")", ")", "==", "0", "\n", "pseudocounts", "=", "estimate_pseudocounts_offset", "(", "\n", "scales_a", "=", "scales_1", ",", "\n", "scales_b", "=", "scales_2", ",", "\n", "where_zero_a", "=", "where_zero_a", ",", "\n", "where_zero_b", "=", "where_zero_b", ",", "\n", ")", "\n", "", "logger", ".", "debug", "(", "\"Using pseudocounts ~ {}\"", ".", "format", "(", "pseudocounts", ")", ")", "\n", "# Core of function: hypotheses testing based on the posterior samples we obtained above", "\n", "if", "mode", "==", "\"vanilla\"", ":", "\n", "            ", "logger", ".", "debug", "(", "\"Differential expression using vanilla mode\"", ")", "\n", "proba_m1", "=", "np", ".", "mean", "(", "scales_1", ">", "scales_2", ",", "0", ")", "\n", "proba_m2", "=", "1.0", "-", "proba_m1", "\n", "res", "=", "dict", "(", "\n", "proba_m1", "=", "proba_m1", ",", "\n", "proba_m2", "=", "proba_m2", ",", "\n", "bayes_factor", "=", "np", ".", "log", "(", "proba_m1", "+", "eps", ")", "-", "np", ".", "log", "(", "proba_m2", "+", "eps", ")", ",", "\n", "scale1", "=", "px_scale_mean1", ",", "\n", "scale2", "=", "px_scale_mean2", ",", "\n", ")", "\n", "\n", "", "elif", "mode", "==", "\"change\"", ":", "\n", "            ", "logger", ".", "debug", "(", "\"Differential expression using change mode\"", ")", "\n", "\n", "# step 1: Construct the change function", "\n", "def", "lfc", "(", "x", ",", "y", ")", ":", "\n", "                ", "return", "np", ".", "log2", "(", "x", "+", "pseudocounts", ")", "-", "np", ".", "log2", "(", "y", "+", "pseudocounts", ")", "\n", "\n", "", "if", "change_fn", "==", "\"log-fold\"", "or", "change_fn", "is", "None", ":", "\n", "                ", "change_fn", "=", "lfc", "\n", "", "elif", "not", "callable", "(", "change_fn", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"'change_fn' attribute not understood\"", ")", "\n", "\n", "# step2: Construct the DE area function", "\n", "", "if", "m1_domain_fn", "is", "None", ":", "\n", "\n", "                ", "def", "m1_domain_fn", "(", "samples", ")", ":", "\n", "                    ", "delta_", "=", "(", "\n", "delta", "\n", "if", "delta", "is", "not", "None", "\n", "else", "estimate_delta", "(", "lfc_means", "=", "samples", ".", "mean", "(", "0", ")", ")", "\n", ")", "\n", "logger", ".", "debug", "(", "\"Using delta ~ {:.2f}\"", ".", "format", "(", "delta_", ")", ")", "\n", "return", "np", ".", "abs", "(", "samples", ")", ">=", "delta_", "\n", "\n", "", "", "change_fn_specs", "=", "inspect", ".", "getfullargspec", "(", "change_fn", ")", "\n", "domain_fn_specs", "=", "inspect", ".", "getfullargspec", "(", "m1_domain_fn", ")", "\n", "if", "(", "len", "(", "change_fn_specs", ".", "args", ")", "!=", "2", ")", "|", "(", "len", "(", "domain_fn_specs", ".", "args", ")", "!=", "1", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"change_fn should take exactly two parameters as inputs; m1_domain_fn one parameter.\"", "\n", ")", "\n", "", "try", ":", "\n", "                ", "change_distribution", "=", "change_fn", "(", "scales_1", ",", "scales_2", ")", "\n", "is_de", "=", "m1_domain_fn", "(", "change_distribution", ")", "\n", "delta_", "=", "(", "\n", "estimate_delta", "(", "lfc_means", "=", "change_distribution", ".", "mean", "(", "0", ")", ")", "\n", "if", "delta", "is", "None", "\n", "else", "delta", "\n", ")", "\n", "", "except", "TypeError", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "\"change_fn or m1_domain_fn have has wrong properties.\"", "\n", "\"Please ensure that these functions have the right signatures and\"", "\n", "\"outputs and that they can process numpy arrays\"", "\n", ")", "\n", "", "proba_m1", "=", "np", ".", "mean", "(", "is_de", ",", "0", ")", "\n", "change_distribution_props", "=", "describe_continuous_distrib", "(", "\n", "samples", "=", "change_distribution", ",", "\n", "credible_intervals_levels", "=", "cred_interval_lvls", ",", "\n", ")", "\n", "change_distribution_props", "=", "{", "\n", "\"lfc_\"", "+", "key", ":", "val", "for", "(", "key", ",", "val", ")", "in", "change_distribution_props", ".", "items", "(", ")", "\n", "}", "\n", "\n", "res", "=", "dict", "(", "\n", "proba_de", "=", "proba_m1", ",", "\n", "proba_not_de", "=", "1.0", "-", "proba_m1", ",", "\n", "bayes_factor", "=", "np", ".", "log", "(", "proba_m1", "+", "eps", ")", "-", "np", ".", "log", "(", "1.0", "-", "proba_m1", "+", "eps", ")", ",", "\n", "scale1", "=", "px_scale_mean1", ",", "\n", "scale2", "=", "px_scale_mean2", ",", "\n", "pseudocounts", "=", "pseudocounts", ",", "\n", "delta", "=", "delta_", ",", "\n", "**", "change_distribution_props", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Mode {mode} not recognized\"", ".", "format", "(", "mode", "=", "mode", ")", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.scale_sampler": [[345, 448], ["torch.no_grad", "int", "numpy.asarray", "numpy.concatenate", "numpy.concatenate().reshape", "dict", "_differential.DifferentialComputation.adata_manager.get_state_registry", "warnings.warn", "warnings.warn", "ValueError", "numpy.dtype", "numpy.asarray", "px_scales.mean.mean.append", "numpy.concatenate().reshape.append", "ValueError", "px_scales.mean.mean.mean", "ValueError", "len", "len", "ValueError", "[].ravel", "numpy.arange", "_differential.DifferentialComputation.model_fn", "numpy.concatenate", "len", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "scale_sampler", "(", "\n", "self", ",", "\n", "selection", ":", "Union", "[", "List", "[", "bool", "]", ",", "np", ".", "ndarray", "]", ",", "\n", "n_samples", ":", "Optional", "[", "int", "]", "=", "5000", ",", "\n", "n_samples_per_cell", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "batchid", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "use_observed_batches", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "give_mean", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Samples the posterior scale using the variational posterior distribution.\n\n        Parameters\n        ----------\n        selection\n            Mask or list of cell ids to select\n        n_samples\n            Number of samples in total per batch (fill either `n_samples_total`\n            or `n_samples_per_cell`)\n        n_samples_per_cell\n            Number of time we sample from each observation per batch\n            (fill either `n_samples_total` or `n_samples_per_cell`)\n        batchid\n            Biological batch for which to sample from.\n            Default (None) sample from all batches\n        use_observed_batches\n            Whether normalized means are conditioned on observed\n            batches or if observed batches are to be used\n        give_mean\n            Return mean of values\n\n\n        Returns\n        -------\n        type\n            Dictionary containing:\n            `scale`\n            Posterior aggregated scale samples of shape (n_samples, n_vars)\n            where n_samples correspond to either:\n            - n_bio_batches * n_cells * n_samples_per_cell\n            or\n            - n_samples_total\n            `batch`\n            associated batch ids\n\n        \"\"\"", "\n", "# Get overall number of desired samples and desired batches", "\n", "if", "batchid", "is", "None", "and", "not", "use_observed_batches", ":", "\n", "            ", "batch_registry", "=", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "BATCH_KEY", "\n", ")", "\n", "batchid", "=", "batch_registry", ".", "categorical_mapping", "\n", "", "if", "use_observed_batches", ":", "\n", "            ", "if", "batchid", "is", "not", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unconsistent batch policy\"", ")", "\n", "", "batchid", "=", "[", "None", "]", "\n", "", "if", "n_samples", "is", "None", "and", "n_samples_per_cell", "is", "None", ":", "\n", "            ", "n_samples", "=", "5000", "\n", "", "elif", "n_samples_per_cell", "is", "not", "None", "and", "n_samples", "is", "None", ":", "\n", "            ", "n_samples", "=", "n_samples_per_cell", "*", "len", "(", "selection", ")", "\n", "", "if", "(", "n_samples_per_cell", "is", "not", "None", ")", "and", "(", "n_samples", "is", "not", "None", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"n_samples and n_samples_per_cell were provided. Ignoring n_samples_per_cell\"", "\n", ")", "\n", "", "n_samples", "=", "int", "(", "n_samples", "/", "len", "(", "batchid", ")", ")", "\n", "if", "n_samples", "==", "0", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"very small sample size, please consider increasing `n_samples`\"", "\n", ")", "\n", "n_samples", "=", "2", "\n", "\n", "# Selection of desired cells for sampling", "\n", "", "if", "selection", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"selections should be a list of cell subsets indices\"", ")", "\n", "", "selection", "=", "np", ".", "asarray", "(", "selection", ")", "\n", "if", "selection", ".", "dtype", "is", "np", ".", "dtype", "(", "\"bool\"", ")", ":", "\n", "            ", "if", "len", "(", "selection", ")", "<", "self", ".", "adata", ".", "shape", "[", "0", "]", ":", "\n", "                ", "raise", "ValueError", "(", "\"Mask must be same length as adata.\"", ")", "\n", "", "selection", "=", "np", ".", "asarray", "(", "np", ".", "where", "(", "selection", ")", "[", "0", "]", ".", "ravel", "(", ")", ")", "\n", "\n", "# Sampling loop", "\n", "", "px_scales", "=", "[", "]", "\n", "batch_ids", "=", "[", "]", "\n", "for", "batch_idx", "in", "batchid", ":", "\n", "            ", "idx_selected", "=", "np", ".", "arange", "(", "self", ".", "adata", ".", "shape", "[", "0", "]", ")", "[", "selection", "]", "\n", "px_scales", ".", "append", "(", "\n", "self", ".", "model_fn", "(", "\n", "self", ".", "adata", ",", "\n", "indices", "=", "idx_selected", ",", "\n", "transform_batch", "=", "batch_idx", ",", "\n", "n_samples_overall", "=", "n_samples", ",", "\n", ")", "\n", ")", "\n", "batch_idx", "=", "batch_idx", "if", "batch_idx", "is", "not", "None", "else", "np", ".", "nan", "\n", "batch_ids", ".", "append", "(", "[", "batch_idx", "]", "*", "px_scales", "[", "-", "1", "]", ".", "shape", "[", "0", "]", ")", "\n", "", "px_scales", "=", "np", ".", "concatenate", "(", "px_scales", ")", "\n", "batch_ids", "=", "np", ".", "concatenate", "(", "batch_ids", ")", ".", "reshape", "(", "-", "1", ")", "\n", "if", "px_scales", ".", "shape", "[", "0", "]", "!=", "batch_ids", ".", "shape", "[", "0", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"sampled scales and batches have inconsistent shapes\"", ")", "\n", "", "if", "give_mean", ":", "\n", "            ", "px_scales", "=", "px_scales", ".", "mean", "(", "0", ")", "\n", "", "return", "dict", "(", "scale", "=", "px_scales", ",", "batch", "=", "batch_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.estimate_delta": [[450, 472], ["logger.debug", "sklearn.mixture.GaussianMixture", "sklearn.mixture.GaussianMixture.fit", "numpy.sort", "numpy.maximum", "ValueError", "sklearn.mixture.GaussianMixture.means_.squeeze", "numpy.abs().mean", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "", "def", "estimate_delta", "(", "lfc_means", ":", "List", "[", "np", ".", "ndarray", "]", ",", "coef", "=", "0.6", ",", "min_thres", "=", "0.3", ")", ":", "\n", "    ", "\"\"\"\n    Computes a threshold LFC value based on means of LFCs.\n\n    Parameters\n    ----------\n    lfc_means\n        LFC means for each gene, should be 1d.\n    coef\n        Tunable hyperparameter to choose the threshold based on estimated modes, defaults to 0.6\n    min_thres\n        Minimum returned threshold value, defaults to 0.3\n    \"\"\"", "\n", "logger", ".", "debug", "(", "\"Estimating delta from effect size samples\"", ")", "\n", "if", "lfc_means", ".", "ndim", ">=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"lfc_means should be 1-dimensional of shape: (n_genes,).\"", ")", "\n", "", "gmm", "=", "GaussianMixture", "(", "n_components", "=", "3", ")", "\n", "gmm", ".", "fit", "(", "lfc_means", "[", ":", ",", "None", "]", ")", "\n", "vals", "=", "np", ".", "sort", "(", "gmm", ".", "means_", ".", "squeeze", "(", ")", ")", "\n", "res", "=", "coef", "*", "np", ".", "abs", "(", "vals", "[", "[", "0", ",", "-", "1", "]", "]", ")", ".", "mean", "(", ")", "\n", "res", "=", "np", ".", "maximum", "(", "min_thres", ",", "res", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.estimate_pseudocounts_offset": [[474, 520], ["numpy.max", "numpy.max", "numpy.maximum", "ValueError", "where_zero_a.sum", "numpy.percentile", "where_zero_b.sum", "numpy.percentile"], "function", ["None"], ["", "def", "estimate_pseudocounts_offset", "(", "\n", "scales_a", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "scales_b", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "where_zero_a", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "where_zero_b", ":", "List", "[", "np", ".", "ndarray", "]", ",", "\n", "percentile", ":", "Optional", "[", "float", "]", "=", "0.9", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Determines pseudocount offset.\n\n    This shrinks LFCs asssociated with non-expressed genes to zero.\n\n    Parameters\n    ----------\n    scales_a\n        Scales in first population\n    scales_b\n        Scales in second population\n    where_zero_a\n        mask where no observed counts\n    where_zero_b\n        mask where no observed counts\n    \"\"\"", "\n", "max_scales_a", "=", "np", ".", "max", "(", "scales_a", ",", "0", ")", "\n", "max_scales_b", "=", "np", ".", "max", "(", "scales_b", ",", "0", ")", "\n", "asserts", "=", "(", "\n", "(", "max_scales_a", ".", "shape", "==", "where_zero_a", ".", "shape", ")", "\n", "and", "(", "max_scales_b", ".", "shape", "==", "where_zero_b", ".", "shape", ")", "\n", ")", "and", "(", "where_zero_a", ".", "shape", "==", "where_zero_b", ".", "shape", ")", "\n", "if", "not", "asserts", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Dimension mismatch between scales and/or masks to compute the pseudocounts offset.\"", "\n", ")", "\n", "", "if", "where_zero_a", ".", "sum", "(", ")", ">=", "1", ":", "\n", "        ", "artefact_scales_a", "=", "max_scales_a", "[", "where_zero_a", "]", "\n", "eps_a", "=", "np", ".", "percentile", "(", "artefact_scales_a", ",", "q", "=", "percentile", ")", "\n", "", "else", ":", "\n", "        ", "eps_a", "=", "1e-10", "\n", "\n", "", "if", "where_zero_b", ".", "sum", "(", ")", ">=", "1", ":", "\n", "        ", "artefact_scales_b", "=", "max_scales_b", "[", "where_zero_b", "]", "\n", "eps_b", "=", "np", ".", "percentile", "(", "artefact_scales_b", ",", "q", "=", "percentile", ")", "\n", "", "else", ":", "\n", "        ", "eps_b", "=", "1e-10", "\n", "", "res", "=", "np", ".", "maximum", "(", "eps_a", ",", "eps_b", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.pairs_sampler": [[522, 585], ["numpy.concatenate", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice"], "function", ["None"], ["", "def", "pairs_sampler", "(", "\n", "arr1", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "\n", "arr2", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "\n", "use_permutation", ":", "bool", "=", "True", ",", "\n", "m_permutation", ":", "int", "=", "None", ",", "\n", "sanity_check_perm", ":", "bool", "=", "False", ",", "\n", "weights1", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "weights2", ":", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "tuple", ":", "\n", "    ", "\"\"\"\n    Creates more pairs.\n\n    In a context where we want to estimate a double sum, virtually increases the number\n    of samples by considering more pairs so as to better estimate the double summation operation\n\n    Parameters\n    ----------\n    arr1\n        samples from population 1\n    arr2\n        samples from population 2\n    use_permutation\n        Whether to mix samples from both populations\n    m_permutation\n        param sanity_check_perm: If True, resulting mixed arrays arr1 and arr2 are mixed together\n        In most cases, this parameter should remain False\n    sanity_check_perm\n        TODO\n    weights1\n        probabilities associated to array 1 for random sampling\n    weights2\n        probabilities associated to array 2 for random sampling\n\n    Returns\n    -------\n    type\n        new_arr1, new_arr2\n    \"\"\"", "\n", "if", "use_permutation", "is", "True", ":", "\n", "# prepare the pairs for sampling", "\n", "        ", "n_arr1", "=", "arr1", ".", "shape", "[", "0", "]", "\n", "n_arr2", "=", "arr2", ".", "shape", "[", "0", "]", "\n", "if", "not", "sanity_check_perm", ":", "\n", "# case1: no permutation, sample from A and then from B", "\n", "            ", "u", ",", "v", "=", "(", "\n", "np", ".", "random", ".", "choice", "(", "n_arr1", ",", "size", "=", "m_permutation", ",", "p", "=", "weights1", ")", ",", "\n", "np", ".", "random", ".", "choice", "(", "n_arr2", ",", "size", "=", "m_permutation", ",", "p", "=", "weights2", ")", ",", "\n", ")", "\n", "first_set", "=", "arr1", "[", "u", "]", "\n", "second_set", "=", "arr2", "[", "v", "]", "\n", "", "else", ":", "\n", "# case2: permutation, sample from A+B twice (sanity check)", "\n", "            ", "u", ",", "v", "=", "(", "\n", "np", ".", "random", ".", "choice", "(", "n_arr1", "+", "n_arr2", ",", "size", "=", "m_permutation", ")", ",", "\n", "np", ".", "random", ".", "choice", "(", "n_arr1", "+", "n_arr2", ",", "size", "=", "m_permutation", ")", ",", "\n", ")", "\n", "concat_arr", "=", "np", ".", "concatenate", "(", "(", "arr1", ",", "arr2", ")", ")", "\n", "first_set", "=", "concat_arr", "[", "u", "]", "\n", "second_set", "=", "concat_arr", "[", "v", "]", "\n", "", "", "else", ":", "\n", "        ", "first_set", "=", "arr1", "\n", "second_set", "=", "arr2", "\n", "", "return", "first_set", ",", "second_set", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.credible_intervals": [[587, 634], ["np.sort.copy", "len", "numpy.sort", "int", "numpy.argmin", "numpy.array", "numpy.array", "numpy.floor", "len", "ValueError", "_differential.credible_intervals"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.credible_intervals"], ["", "def", "credible_intervals", "(", "\n", "ary", ":", "np", ".", "ndarray", ",", "confidence_level", ":", "Union", "[", "float", ",", "List", "[", "float", "]", ",", "np", ".", "ndarray", "]", "=", "0.94", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate highest posterior density (HPD) of array for given credible_interval.\n\n    Taken from the arviz package\n    The HPD is the minimum width Bayesian credible interval (BCI). This implementation works only\n    for unimodal distributions.\n\n    Parameters\n    ----------\n    ary\n        posterior samples\n    confidence_level\n        confidence level\n\n    Returns\n    -------\n    type\n        intervals minima, intervals maxima\n    \"\"\"", "\n", "if", "ary", ".", "ndim", ">", "1", ":", "\n", "        ", "hpd", "=", "np", ".", "array", "(", "\n", "[", "\n", "credible_intervals", "(", "row", ",", "confidence_level", "=", "confidence_level", ")", "\n", "for", "row", "in", "ary", ".", "T", "\n", "]", "\n", ")", "\n", "return", "hpd", "\n", "# Make a copy of trace", "\n", "", "ary", "=", "ary", ".", "copy", "(", ")", "\n", "n", "=", "len", "(", "ary", ")", "\n", "ary", "=", "np", ".", "sort", "(", "ary", ")", "\n", "interval_idx_inc", "=", "int", "(", "np", ".", "floor", "(", "confidence_level", "*", "n", ")", ")", "\n", "n_intervals", "=", "n", "-", "interval_idx_inc", "\n", "interval_width", "=", "ary", "[", "interval_idx_inc", ":", "]", "-", "ary", "[", ":", "n_intervals", "]", "\n", "\n", "if", "len", "(", "interval_width", ")", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Too few elements for interval calculation. \"", "\n", "\"Check that credible_interval meets condition 0 =< credible_interval < 1\"", "\n", ")", "\n", "", "min_idx", "=", "np", ".", "argmin", "(", "interval_width", ")", "\n", "hdi_min", "=", "ary", "[", "min_idx", "]", "\n", "hdi_max", "=", "ary", "[", "min_idx", "+", "interval_idx_inc", "]", "\n", "return", "np", ".", "array", "(", "[", "hdi_min", ",", "hdi_max", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.describe_continuous_distrib": [[636, 674], ["dict", "_differential.credible_intervals", "samples.mean", "numpy.median", "samples.std", "samples.min", "samples.max", "str"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.credible_intervals", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "describe_continuous_distrib", "(", "\n", "samples", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "\n", "credible_intervals_levels", ":", "Optional", "[", "Union", "[", "List", "[", "float", "]", ",", "np", ".", "ndarray", "]", "]", "=", "None", ",", "\n", ")", "->", "dict", ":", "\n", "    ", "\"\"\"\n    Computes properties of distribution based on its samples.\n\n    Parameters\n    ----------\n    samples\n        samples of shape (n_samples, n_features)\n    credible_intervals_levels\n        Confidence in (0, 1)\n        of credible intervals to be computed\n\n    Returns\n    -------\n    type\n        properties of distribution\n    \"\"\"", "\n", "dist_props", "=", "dict", "(", "\n", "mean", "=", "samples", ".", "mean", "(", "0", ")", ",", "\n", "median", "=", "np", ".", "median", "(", "samples", ",", "0", ")", ",", "\n", "std", "=", "samples", ".", "std", "(", "0", ")", ",", "\n", "min", "=", "samples", ".", "min", "(", "0", ")", ",", "\n", "max", "=", "samples", ".", "max", "(", "0", ")", ",", "\n", ")", "\n", "credible_intervals_levels", "=", "(", "\n", "[", "]", "if", "credible_intervals_levels", "is", "None", "else", "credible_intervals_levels", "\n", ")", "\n", "for", "confidence", "in", "credible_intervals_levels", ":", "\n", "        ", "intervals", "=", "credible_intervals", "(", "samples", ",", "confidence_level", "=", "confidence", ")", "\n", "interval_min", ",", "interval_max", "=", "intervals", "[", ":", ",", "0", "]", ",", "intervals", "[", ":", ",", "1", "]", "\n", "conf_str", "=", "str", "(", "confidence", ")", "[", ":", "5", "]", "\n", "dist_props", "[", "\"confidence_interval_{}_min\"", ".", "format", "(", "conf_str", ")", "]", "=", "interval_min", "\n", "dist_props", "[", "\"confidence_interval_{}_max\"", ".", "format", "(", "conf_str", ")", "]", "=", "interval_max", "\n", "\n", "", "return", "dist_props", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.save_cluster_xlsx": [[676, 696], ["pandas.ExcelWriter", "enumerate", "pd.ExcelWriter.close", "de_results[].to_excel", "str"], "function", ["None"], ["", "def", "save_cluster_xlsx", "(", "\n", "filepath", ":", "str", ",", "de_results", ":", "List", "[", "pd", ".", "DataFrame", "]", ",", "cluster_names", ":", "List", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Saves multi-clusters DE in an xlsx sheet.\n\n    Parameters\n    ----------\n    filepath\n        xslx save path\n    de_results\n        list of pandas Dataframes for each cluster\n    cluster_names\n        list of cluster names\n\n    \"\"\"", "\n", "writer", "=", "pd", ".", "ExcelWriter", "(", "filepath", ",", "engine", "=", "\"xlsxwriter\"", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "cluster_names", ")", ":", "\n", "        ", "de_results", "[", "i", "]", ".", "to_excel", "(", "writer", ",", "sheet_name", "=", "str", "(", "x", ")", ")", "\n", "", "writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.densify": [[698, 702], ["scipy.sparse.issparse", "numpy.asarray().squeeze", "numpy.asarray", "arr.todense"], "function", ["None"], ["", "def", "densify", "(", "arr", ")", ":", "\n", "    ", "if", "issparse", "(", "arr", ")", ":", "\n", "        ", "return", "np", ".", "asarray", "(", "arr", ".", "todense", "(", ")", ")", ".", "squeeze", "(", ")", "\n", "", "return", "arr", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroJitGuideWarmup.__init__": [[26, 29], ["pytorch_lightning.callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "dataloader", ":", "AnnDataLoader", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataloader", "=", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroJitGuideWarmup.on_train_start": [[30, 47], ["trainer.datamodule.train_dataloader", "pl_module.module._get_fn_args_from_batch", "pyro_guide", "t.to", "tensors.items"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "def", "on_train_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "\"\"\"\n        Way to warmup Pyro Guide in an automated way.\n\n        Also device agnostic.\n        \"\"\"", "\n", "# warmup guide for JIT", "\n", "pyro_guide", "=", "pl_module", ".", "module", ".", "guide", "\n", "if", "self", ".", "dataloader", "is", "None", ":", "\n", "            ", "dl", "=", "trainer", ".", "datamodule", ".", "train_dataloader", "(", ")", "\n", "", "else", ":", "\n", "            ", "dl", "=", "self", ".", "dataloader", "\n", "", "for", "tensors", "in", "dl", ":", "\n", "            ", "tens", "=", "{", "k", ":", "t", ".", "to", "(", "pl_module", ".", "device", ")", "for", "k", ",", "t", "in", "tensors", ".", "items", "(", ")", "}", "\n", "args", ",", "kwargs", "=", "pl_module", ".", "module", ".", "_get_fn_args_from_batch", "(", "tens", ")", "\n", "pyro_guide", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSviTrainMixin.train": [[56, 147], ["training_plan.", "trainer_kwargs[].append", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "numpy.min", "isinstance", "dict", "plan_kwargs.update", "scvi.dataloaders.DeviceBackedDataSplitter", "scvi.dataloaders.DataSplitter", "trainer_kwargs.keys", "_pyromixin.PyroJitGuideWarmup", "plan_kwargs.keys", "trainer_kwargs.keys", "round"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "early_stopping", ":", "bool", "=", "False", ",", "\n", "lr", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "training_plan", ":", "PyroTrainingPlan", "=", "PyroTrainingPlan", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training. If `None`, no minibatching occurs and all\n            data is copied to device (e.g., GPU).\n        early_stopping\n            Perform early stopping. Additional arguments can be passed in `**kwargs`.\n            See :class:`~scvi.train.Trainer` for further options.\n        lr\n            Optimiser learning rate (default optimiser is :class:`~pyro.optim.ClippedAdam`).\n            Specifying optimiser via plan_kwargs overrides this choice of lr.\n        training_plan\n            Training plan :class:`~scvi.train.PyroTrainingPlan`.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.PyroTrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **trainer_kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "if", "max_epochs", "is", "None", ":", "\n", "            ", "n_obs", "=", "self", ".", "adata", ".", "n_obs", "\n", "max_epochs", "=", "np", ".", "min", "(", "[", "round", "(", "(", "20000", "/", "n_obs", ")", "*", "1000", ")", ",", "1000", "]", ")", "\n", "\n", "", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "if", "lr", "is", "not", "None", "and", "\"optim\"", "not", "in", "plan_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "{", "\"optim_kwargs\"", ":", "{", "\"lr\"", ":", "lr", "}", "}", ")", "\n", "\n", "", "if", "batch_size", "is", "None", ":", "\n", "# use data splitter which moves data to GPU once", "\n", "            ", "data_splitter", "=", "DeviceBackedDataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "data_splitter", "=", "DataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "", "training_plan", "=", "training_plan", "(", "self", ".", "module", ",", "**", "plan_kwargs", ")", "\n", "\n", "es", "=", "\"early_stopping\"", "\n", "trainer_kwargs", "[", "es", "]", "=", "(", "\n", "early_stopping", "if", "es", "not", "in", "trainer_kwargs", ".", "keys", "(", ")", "else", "trainer_kwargs", "[", "es", "]", "\n", ")", "\n", "\n", "if", "\"callbacks\"", "not", "in", "trainer_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "trainer_kwargs", "[", "\"callbacks\"", "]", "=", "[", "]", "\n", "", "trainer_kwargs", "[", "\"callbacks\"", "]", ".", "append", "(", "PyroJitGuideWarmup", "(", ")", ")", "\n", "\n", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", "\n", "return", "runner", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_one_posterior_sample": [[156, 213], ["torch.no_grad", "isinstance", "_pyromixin.PyroSampleMixin.module.guide", "pyro.poutine.trace().get_trace", "pyro.poutine.trace().get_trace", "site.cpu().numpy", "_pyromixin.PyroSampleMixin.items", "pyro.poutine.trace", "pyro.poutine.trace", "pyro.poutine.trace().get_trace.nodes.items", "site.cpu", "pyro.poutine.replay", "site.get().get", "isinstance", "site.get", "site.get", "site.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_get_one_posterior_sample", "(", "\n", "self", ",", "\n", "args", ",", "\n", "kwargs", ",", "\n", "return_sites", ":", "Optional", "[", "list", "]", "=", "None", ",", "\n", "return_observed", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Get one sample from posterior distribution.\n\n        Parameters\n        ----------\n        args\n            arguments to model and guide\n        kwargs\n            arguments to model and guide\n        return_sites\n            List of variables for which to generate posterior samples, defaults to all variables.\n        return_observed\n            Record samples of observed variables.\n\n        Returns\n        -------\n        Dictionary with a sample for each variable\n        \"\"\"", "\n", "if", "isinstance", "(", "self", ".", "module", ".", "guide", ",", "poutine", ".", "messenger", ".", "Messenger", ")", ":", "\n", "# This already includes trace-replay behavior.", "\n", "            ", "sample", "=", "self", ".", "module", ".", "guide", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "guide_trace", "=", "poutine", ".", "trace", "(", "self", ".", "module", ".", "guide", ")", ".", "get_trace", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "model_trace", "=", "poutine", ".", "trace", "(", "\n", "poutine", ".", "replay", "(", "self", ".", "module", ".", "model", ",", "guide_trace", ")", "\n", ")", ".", "get_trace", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "sample", "=", "{", "\n", "name", ":", "site", "[", "\"value\"", "]", "\n", "for", "name", ",", "site", "in", "model_trace", ".", "nodes", ".", "items", "(", ")", "\n", "if", "(", "\n", "(", "site", "[", "\"type\"", "]", "==", "\"sample\"", ")", "# sample statement", "\n", "and", "(", "\n", "(", "return_sites", "is", "None", ")", "or", "(", "name", "in", "return_sites", ")", "\n", ")", "# selected in return_sites list", "\n", "and", "(", "\n", "(", "\n", "(", "not", "site", ".", "get", "(", "\"is_observed\"", ",", "True", ")", ")", "or", "return_observed", "\n", ")", "# don't save observed unless requested", "\n", "or", "(", "site", ".", "get", "(", "\"infer\"", ",", "False", ")", ".", "get", "(", "\"_deterministic\"", ",", "False", ")", ")", "\n", ")", "# unless it is deterministic", "\n", "and", "not", "isinstance", "(", "\n", "site", ".", "get", "(", "\"fn\"", ",", "None", ")", ",", "poutine", ".", "subsample_messenger", ".", "_Subsample", "\n", ")", "# don't save plates", "\n", ")", "\n", "}", "\n", "\n", "", "sample", "=", "{", "name", ":", "site", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "name", ",", "site", "in", "sample", ".", "items", "(", ")", "}", "\n", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_posterior_samples": [[214, 265], ["_pyromixin.PyroSampleMixin._get_one_posterior_sample", "scvi.utils.track", "range", "_pyromixin.PyroSampleMixin._get_one_posterior_sample", "numpy.array", "_pyromixin.PyroSampleMixin.items", "_pyromixin.PyroSampleMixin.items", "_pyromixin.PyroSampleMixin.keys"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_one_posterior_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_one_posterior_sample"], ["", "def", "_get_posterior_samples", "(", "\n", "self", ",", "\n", "args", ",", "\n", "kwargs", ",", "\n", "num_samples", ":", "int", "=", "1000", ",", "\n", "return_sites", ":", "Optional", "[", "list", "]", "=", "None", ",", "\n", "return_observed", ":", "bool", "=", "False", ",", "\n", "show_progress", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Get many (num_samples=N) samples from posterior distribution.\n\n        Parameters\n        ----------\n        args\n            arguments to model and guide\n        kwargs\n            keyword arguments to model and guide\n        return_sites\n            List of variables for which to generate posterior samples, defaults to all variables.\n        return_observed\n            Record samples of observed variables.\n        show_progress\n            show progress bar\n\n        Returns\n        -------\n        Dictionary with array of samples for each variable\n        dictionary {variable_name: [array with samples in 0 dimension]}\n        \"\"\"", "\n", "samples", "=", "self", ".", "_get_one_posterior_sample", "(", "\n", "args", ",", "kwargs", ",", "return_sites", "=", "return_sites", ",", "return_observed", "=", "return_observed", "\n", ")", "\n", "samples", "=", "{", "k", ":", "[", "v", "]", "for", "k", ",", "v", "in", "samples", ".", "items", "(", ")", "}", "\n", "\n", "for", "_", "in", "track", "(", "\n", "range", "(", "1", ",", "num_samples", ")", ",", "\n", "style", "=", "\"tqdm\"", ",", "\n", "description", "=", "\"Sampling global variables, sample: \"", ",", "\n", "disable", "=", "not", "show_progress", ",", "\n", ")", ":", "\n", "\n", "# generate new sample", "\n", "            ", "samples_", "=", "self", ".", "_get_one_posterior_sample", "(", "\n", "args", ",", "kwargs", ",", "return_sites", "=", "return_sites", ",", "return_observed", "=", "return_observed", "\n", ")", "\n", "\n", "# add new sample", "\n", "samples", "=", "{", "k", ":", "samples", "[", "k", "]", "+", "[", "samples_", "[", "k", "]", "]", "for", "k", "in", "samples", ".", "keys", "(", ")", "}", "\n", "\n", "", "return", "{", "k", ":", "np", ".", "array", "(", "v", ")", "for", "k", ",", "v", "in", "samples", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_obs_plate_return_sites": [[266, 278], ["numpy.array", "len", "list", "numpy.isin"], "methods", ["None"], ["", "def", "_get_obs_plate_return_sites", "(", "self", ",", "return_sites", ",", "obs_plate_sites", ")", ":", "\n", "        ", "\"\"\"Check return_sites for overlap with observation/minibatch plate sites.\"\"\"", "\n", "# check whether any variable requested in return_sites are in obs_plate", "\n", "if", "return_sites", "is", "not", "None", ":", "\n", "            ", "return_sites", "=", "np", ".", "array", "(", "return_sites", ")", "\n", "return_sites", "=", "return_sites", "[", "np", ".", "isin", "(", "return_sites", ",", "obs_plate_sites", ")", "]", "\n", "if", "len", "(", "return_sites", ")", "==", "0", ":", "\n", "                ", "return", "[", "return_sites", "]", "\n", "", "else", ":", "\n", "                ", "return", "list", "(", "return_sites", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "obs_plate_sites", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_obs_plate_sites": [[279, 326], ["pyro.poutine.trace().get_trace", "pyro.poutine.trace", "pyro.poutine.trace().get_trace.nodes.items", "any", "site.get().get", "isinstance", "site.get", "site.get", "site.get"], "methods", ["None"], ["", "", "def", "_get_obs_plate_sites", "(", "\n", "self", ",", "\n", "args", ":", "list", ",", "\n", "kwargs", ":", "dict", ",", "\n", "return_observed", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Automatically guess which model sites belong to observation/minibatch plate.\n\n        This function requires minibatch plate name specified in `self.module.list_obs_plate_vars[\"name\"]`.\n\n        Parameters\n        ----------\n        args\n            Arguments to the model.\n        kwargs\n            Keyword arguments to the model.\n        return_observed\n            Record samples of observed variables.\n\n        Returns\n        -------\n        Dictionary with keys corresponding to site names and values to plate dimension.\n        \"\"\"", "\n", "plate_name", "=", "self", ".", "module", ".", "list_obs_plate_vars", "[", "\"name\"", "]", "\n", "\n", "# find plate dimension", "\n", "trace", "=", "poutine", ".", "trace", "(", "self", ".", "module", ".", "model", ")", ".", "get_trace", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "obs_plate", "=", "{", "\n", "name", ":", "site", "[", "\"cond_indep_stack\"", "]", "[", "0", "]", ".", "dim", "\n", "for", "name", ",", "site", "in", "trace", ".", "nodes", ".", "items", "(", ")", "\n", "if", "(", "\n", "(", "site", "[", "\"type\"", "]", "==", "\"sample\"", ")", "# sample statement", "\n", "and", "(", "\n", "(", "\n", "(", "not", "site", ".", "get", "(", "\"is_observed\"", ",", "True", ")", ")", "or", "return_observed", "\n", ")", "# don't save observed unless requested", "\n", "or", "(", "site", ".", "get", "(", "\"infer\"", ",", "False", ")", ".", "get", "(", "\"_deterministic\"", ",", "False", ")", ")", "\n", ")", "# unless it is deterministic", "\n", "and", "not", "isinstance", "(", "\n", "site", ".", "get", "(", "\"fn\"", ",", "None", ")", ",", "poutine", ".", "subsample_messenger", ".", "_Subsample", "\n", ")", "# don't save plates", "\n", ")", "\n", "if", "any", "(", "f", ".", "name", "==", "plate_name", "for", "f", "in", "site", "[", "\"cond_indep_stack\"", "]", ")", "\n", "}", "\n", "\n", "return", "obs_plate", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._posterior_samples_minibatch": [[327, 425], ["dict", "scvi.model._utils.parse_use_gpu_arg", "scvi.dataloaders.AnnDataLoader", "scvi.utils.track", "_pyromixin.PyroSampleMixin._get_posterior_samples", "_pyromixin.PyroSampleMixin.keys", "_pyromixin.PyroSampleMixin.module.to", "_pyromixin.PyroSampleMixin.module._get_fn_args_from_batch", "_pyromixin.PyroSampleMixin.to_device", "a.to", "v.to", "getattr", "_pyromixin.PyroSampleMixin._get_obs_plate_sites", "sample_kwargs.copy", "_pyromixin.PyroSampleMixin._get_obs_plate_return_sites", "_pyromixin.PyroSampleMixin._get_posterior_samples", "_pyromixin.PyroSampleMixin._get_posterior_samples", "_pyromixin.PyroSampleMixin.items", "kwargs.items", "len", "list", "list", "numpy.array", "list", "_pyromixin.PyroSampleMixin.values", "_pyromixin.PyroSampleMixin.keys", "_pyromixin.PyroSampleMixin.keys", "_pyromixin.PyroSampleMixin.keys", "numpy.concatenate", "range", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_posterior_samples", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_obs_plate_sites", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_obs_plate_return_sites", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_posterior_samples", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._get_posterior_samples"], ["", "def", "_posterior_samples_minibatch", "(", "\n", "self", ",", "use_gpu", ":", "bool", "=", "None", ",", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "**", "sample_kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Generate samples of the posterior distribution in minibatches.\n\n        Generate samples of the posterior distribution of each parameter, separating local (minibatch) variables\n        and global variables, which is necessary when performing minibatch inference.\n\n        Parameters\n        ----------\n        use_gpu\n            Load model on default GPU if available (if None or True),\n            or index of GPU to use (if int), or name of GPU (if str), or use CPU (if False).\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        dictionary {variable_name: [array with samples in 0 dimension]}\n        \"\"\"", "\n", "samples", "=", "dict", "(", ")", "\n", "\n", "_", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "batch_size", "=", "batch_size", "if", "batch_size", "is", "not", "None", "else", "settings", ".", "batch_size", "\n", "\n", "train_dl", "=", "AnnDataLoader", "(", "\n", "self", ".", "adata_manager", ",", "shuffle", "=", "False", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "# sample local parameters", "\n", "i", "=", "0", "\n", "for", "tensor_dict", "in", "track", "(", "\n", "train_dl", ",", "\n", "style", "=", "\"tqdm\"", ",", "\n", "description", "=", "\"Sampling local variables, batch: \"", ",", "\n", ")", ":", "\n", "            ", "args", ",", "kwargs", "=", "self", ".", "module", ".", "_get_fn_args_from_batch", "(", "tensor_dict", ")", "\n", "args", "=", "[", "a", ".", "to", "(", "device", ")", "for", "a", "in", "args", "]", "\n", "kwargs", "=", "{", "k", ":", "v", ".", "to", "(", "device", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", "self", ".", "to_device", "(", "device", ")", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                ", "return_observed", "=", "getattr", "(", "sample_kwargs", ",", "\"return_observed\"", ",", "False", ")", "\n", "obs_plate_sites", "=", "self", ".", "_get_obs_plate_sites", "(", "\n", "args", ",", "kwargs", ",", "return_observed", "=", "return_observed", "\n", ")", "\n", "if", "len", "(", "obs_plate_sites", ")", "==", "0", ":", "\n", "# if no local variables - don't sample", "\n", "                    ", "break", "\n", "", "obs_plate_dim", "=", "list", "(", "obs_plate_sites", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "\n", "sample_kwargs_obs_plate", "=", "sample_kwargs", ".", "copy", "(", ")", "\n", "sample_kwargs_obs_plate", "[", "\n", "\"return_sites\"", "\n", "]", "=", "self", ".", "_get_obs_plate_return_sites", "(", "\n", "sample_kwargs", "[", "\"return_sites\"", "]", ",", "list", "(", "obs_plate_sites", ".", "keys", "(", ")", ")", "\n", ")", "\n", "sample_kwargs_obs_plate", "[", "\"show_progress\"", "]", "=", "False", "\n", "\n", "samples", "=", "self", ".", "_get_posterior_samples", "(", "\n", "args", ",", "kwargs", ",", "**", "sample_kwargs_obs_plate", "\n", ")", "\n", "", "else", ":", "\n", "                ", "samples_", "=", "self", ".", "_get_posterior_samples", "(", "\n", "args", ",", "kwargs", ",", "**", "sample_kwargs_obs_plate", "\n", ")", "\n", "\n", "samples", "=", "{", "\n", "k", ":", "np", ".", "array", "(", "\n", "[", "\n", "np", ".", "concatenate", "(", "\n", "[", "samples", "[", "k", "]", "[", "j", "]", ",", "samples_", "[", "k", "]", "[", "j", "]", "]", ",", "\n", "axis", "=", "obs_plate_dim", ",", "\n", ")", "\n", "for", "j", "in", "range", "(", "\n", "len", "(", "samples", "[", "k", "]", ")", "\n", ")", "# for each sample (in 0 dimension", "\n", "]", "\n", ")", "\n", "for", "k", "in", "samples", ".", "keys", "(", ")", "# for each variable", "\n", "}", "\n", "", "i", "+=", "1", "\n", "\n", "# sample global parameters", "\n", "", "global_samples", "=", "self", ".", "_get_posterior_samples", "(", "args", ",", "kwargs", ",", "**", "sample_kwargs", ")", "\n", "global_samples", "=", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "global_samples", ".", "items", "(", ")", "\n", "if", "k", "not", "in", "list", "(", "obs_plate_sites", ".", "keys", "(", ")", ")", "\n", "}", "\n", "\n", "for", "k", "in", "global_samples", ".", "keys", "(", ")", ":", "\n", "            ", "samples", "[", "k", "]", "=", "global_samples", "[", "k", "]", "\n", "\n", "", "self", ".", "module", ".", "to", "(", "device", ")", "\n", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin.sample_posterior": [[426, 509], ["_pyromixin.PyroSampleMixin._posterior_samples_minibatch", "list", "dict", "summary_fun.items", "_pyromixin.PyroSampleMixin.keys", "fun", "numpy.quantile", "numpy.quantile"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin._posterior_samples_minibatch"], ["", "def", "sample_posterior", "(", "\n", "self", ",", "\n", "num_samples", ":", "int", "=", "1000", ",", "\n", "return_sites", ":", "Optional", "[", "list", "]", "=", "None", ",", "\n", "use_gpu", ":", "bool", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_observed", ":", "bool", "=", "False", ",", "\n", "return_samples", ":", "bool", "=", "False", ",", "\n", "summary_fun", ":", "Optional", "[", "Dict", "[", "str", ",", "Callable", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Summarise posterior distribution.\n\n        Generate samples from posterior distribution for each parameter\n        and compute mean, 5%/95% quantiles, standard deviation.\n\n        Parameters\n        ----------\n        num_samples\n            Number of posterior samples to generate.\n        return_sites\n            List of variables for which to generate posterior samples, defaults to all variables.\n        use_gpu\n            Load model on default GPU if available (if None or True),\n            or index of GPU to use (if int), or name of GPU (if str), or use CPU (if False).\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        return_observed\n            Return observed sites/variables? Observed count matrix can be very large so not returned by default.\n        return_samples\n            Return all generated posterior samples in addition to sample mean, 5%/95% quantile and SD?\n        summary_fun\n             a dict in the form {\"means\": np.mean, \"std\": np.std} which specifies posterior distribution\n             summaries to compute and which names to use. See below for default returns.\n\n        Returns\n        -------\n        post_sample_means: Dict[str, :class:`np.ndarray`]\n            Mean of the posterior distribution for each variable, a dictionary of numpy arrays for each variable;\n        post_sample_q05: Dict[str, :class:`np.ndarray`]\n            5% quantile of the posterior distribution for each variable;\n        post_sample_q05: Dict[str, :class:`np.ndarray`]\n            95% quantile of the posterior distribution for each variable;\n        post_sample_q05: Dict[str, :class:`np.ndarray`]\n            Standard deviation of the posterior distribution for each variable;\n        posterior_samples: Optional[Dict[str, :class:`np.ndarray`]]\n            Posterior distribution samples for each variable as numpy arrays of shape `(n_samples, ...)` (Optional).\n\n        Notes\n        -----\n        Note for developers: requires overwritten :attr:`~scvi.module.base.PyroBaseModuleClass.list_obs_plate_vars` property.\n        which lists observation/minibatch plate name and variables.\n        See :attr:`~scvi.module.base.PyroBaseModuleClass.list_obs_plate_vars` for details of the variables it should contain.\n        This dictionary can be returned by model class property `self.module.model.list_obs_plate_vars`\n        to keep all model-specific variables in one place.\n        \"\"\"", "\n", "# sample using minibatches (if full data, data is moved to GPU only once anyway)", "\n", "samples", "=", "self", ".", "_posterior_samples_minibatch", "(", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "num_samples", "=", "num_samples", ",", "\n", "return_sites", "=", "return_sites", ",", "\n", "return_observed", "=", "return_observed", ",", "\n", ")", "\n", "\n", "param_names", "=", "list", "(", "samples", ".", "keys", "(", ")", ")", "\n", "results", "=", "dict", "(", ")", "\n", "if", "return_samples", ":", "\n", "            ", "results", "[", "\"posterior_samples\"", "]", "=", "samples", "\n", "\n", "", "if", "summary_fun", "is", "None", ":", "\n", "            ", "summary_fun", "=", "{", "\n", "\"means\"", ":", "np", ".", "mean", ",", "\n", "\"stds\"", ":", "np", ".", "std", ",", "\n", "\"q05\"", ":", "lambda", "x", ",", "axis", ":", "np", ".", "quantile", "(", "x", ",", "0.05", ",", "axis", "=", "axis", ")", ",", "\n", "\"q95\"", ":", "lambda", "x", ",", "axis", ":", "np", ".", "quantile", "(", "x", ",", "0.95", ",", "axis", "=", "axis", ")", ",", "\n", "}", "\n", "", "for", "k", ",", "fun", "in", "summary_fun", ".", "items", "(", ")", ":", "\n", "            ", "results", "[", "f\"post_sample_{k}\"", "]", "=", "{", "\n", "v", ":", "fun", "(", "samples", "[", "v", "]", ",", "axis", "=", "0", ")", "for", "v", "in", "param_names", "\n", "}", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_elbo": [[16, 45], ["torch.no_grad", "_vaemixin.VAEMixin._validate_anndata", "_vaemixin.VAEMixin._make_data_loader", "_log_likelihood.compute_elbo"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._log_likelihood.compute_elbo"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_elbo", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Return the ELBO for the data.\n\n        The ELBO is a lower bound on the log likelihood of the data used for optimization\n        of VAEs. Note, this is not the negative ELBO, higher is better.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "elbo", "=", "compute_elbo", "(", "self", ".", "module", ",", "scdl", ")", "\n", "return", "-", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_marginal_ll": [[46, 89], ["torch.no_grad", "_vaemixin.VAEMixin._validate_anndata", "_vaemixin.VAEMixin._make_data_loader", "hasattr", "len", "numpy.arange", "NotImplementedError", "_vaemixin.VAEMixin.module.marginal_ll"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.marginal_ll"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_marginal_ll", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_mc_samples", ":", "int", "=", "1000", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Return the marginal LL for the data.\n\n        The computation here is a biased estimator of the marginal log likelihood of the data.\n        Note, this is not the negative log likelihood, higher is better.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_mc_samples\n            Number of Monte Carlo samples to use for marginal LL estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "if", "hasattr", "(", "self", ".", "module", ",", "\"marginal_ll\"", ")", ":", "\n", "            ", "log_lkl", "=", "0", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "log_lkl", "+=", "self", ".", "module", ".", "marginal_ll", "(", "tensors", ",", "n_mc_samples", "=", "n_mc_samples", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"marginal_ll is not implemented for current model. \"", "\n", "\"Please raise an issue on github if you need it.\"", "\n", ")", "\n", "", "n_samples", "=", "len", "(", "indices", ")", "\n", "return", "log_lkl", "/", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error": [[90, 119], ["torch.no_grad", "_vaemixin.VAEMixin._validate_anndata", "_vaemixin.VAEMixin._make_data_loader", "_log_likelihood.compute_reconstruction_error"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._log_likelihood.compute_reconstruction_error"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_reconstruction_error", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "float", ",", "Dict", "[", "str", ",", "float", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Return the reconstruction error for the data.\n\n        This is typically written as :math:`p(x \\mid z)`, the likelihood term given one posterior sample.\n        Note, this is not the negative likelihood, higher is better.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "reconstruction_error", "=", "compute_reconstruction_error", "(", "self", ".", "module", ",", "scdl", ")", "\n", "return", "reconstruction_error", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_latent_representation": [[120, 178], ["torch.no_grad", "_vaemixin.VAEMixin._check_if_trained", "_vaemixin.VAEMixin._validate_anndata", "_vaemixin.VAEMixin._make_data_loader", "torch.cat().numpy", "_vaemixin.VAEMixin.module._get_inference_input", "_vaemixin.VAEMixin.module.inference", "z.mean.mean.cpu", "torch.cat", "qz.sample", "torch.nn.functional.softmax", "z.mean.mean.mean"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "give_mean", ":", "bool", "=", "True", ",", "\n", "mc_samples", ":", "int", "=", "5000", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Return the latent representation for each cell.\n\n        This is denoted as :math:`z_n` in our manuscripts.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        give_mean\n            Give mean of distribution or sample from it.\n        mc_samples\n            For distributions with no closed-form mean (e.g., `logistic normal`), how many Monte Carlo\n            samples to take for computing mean.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        latent_representation : np.ndarray\n            Low-dimensional representation for each cell\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", "warn", "=", "False", ")", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "latent", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "qz", "=", "outputs", "[", "\"qz\"", "]", "\n", "z", "=", "outputs", "[", "\"z\"", "]", "\n", "\n", "if", "give_mean", ":", "\n", "# does each model need to have this latent distribution param?", "\n", "                ", "if", "self", ".", "module", ".", "latent_distribution", "==", "\"ln\"", ":", "\n", "                    ", "samples", "=", "qz", ".", "sample", "(", "[", "mc_samples", "]", ")", "\n", "z", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "samples", ",", "dim", "=", "-", "1", ")", "\n", "z", "=", "z", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                    ", "z", "=", "qz", ".", "loc", "\n", "\n", "", "", "latent", "+=", "[", "z", ".", "cpu", "(", ")", "]", "\n", "", "return", "torch", ".", "cat", "(", "latent", ")", ".", "numpy", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.base._jaxmixin.JaxTrainingMixin.train": [[17, 101], ["scvi.dataloaders.DataSplitter", "scvi.train.JaxTrainingPlan", "trainer_kwargs[].append", "_jaxmixin.JaxTrainingMixin.module.eval", "numpy.min", "_jaxmixin.JaxTrainingMixin.module.to", "logger.info", "trainer_kwargs.keys", "scvi.train.JaxModuleInit", "warnings.catch_warnings", "warnings.filterwarnings", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "_jaxmixin.JaxTrainingMixin.module.to", "logger.info", "jax.devices", "dict", "round", "logger.debug", "jax.devices"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "use_gpu", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "lr", ":", "float", "=", "1e-3", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Whether or not to use GPU resources. If None, will use GPU if available.\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        lr\n            Learning rate to use during training.\n        **trainer_kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "if", "max_epochs", "is", "None", ":", "\n", "            ", "n_cells", "=", "self", ".", "adata", ".", "n_obs", "\n", "max_epochs", "=", "np", ".", "min", "(", "[", "round", "(", "(", "20000", "/", "n_cells", ")", "*", "400", ")", ",", "400", "]", ")", "\n", "\n", "", "if", "use_gpu", "is", "None", "or", "use_gpu", "is", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "module", ".", "to", "(", "jax", ".", "devices", "(", "\"gpu\"", ")", "[", "0", "]", ")", "\n", "logger", ".", "info", "(", "\n", "\"Jax module moved to GPU. \"", "\n", "\"Note: Pytorch lightning will show GPU is not being used for the Trainer.\"", "\n", ")", "\n", "", "except", "RuntimeError", ":", "\n", "                ", "logger", ".", "debug", "(", "\"No GPU available to Jax.\"", ")", "\n", "", "", "else", ":", "\n", "            ", "cpu_device", "=", "jax", ".", "devices", "(", "\"cpu\"", ")", "[", "0", "]", "\n", "self", ".", "module", ".", "to", "(", "cpu_device", ")", "\n", "logger", ".", "info", "(", "\"Jax module moved to CPU.\"", ")", "\n", "\n", "", "data_splitter", "=", "DataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "# for pinning memory only", "\n", "use_gpu", "=", "False", ",", "\n", "iter_ndarray", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "training_plan", "=", "JaxTrainingPlan", "(", "\n", "self", ".", "module", ",", "optim_kwargs", "=", "dict", "(", "learning_rate", "=", "lr", ")", "\n", ")", "\n", "if", "\"callbacks\"", "not", "in", "trainer_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "trainer_kwargs", "[", "\"callbacks\"", "]", "=", "[", "]", "\n", "", "trainer_kwargs", "[", "\"callbacks\"", "]", ".", "append", "(", "JaxModuleInit", "(", ")", ")", "\n", "\n", "# Ignore Pytorch Lightning warnings for Jax workarounds.", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "filterwarnings", "(", "\n", "\"ignore\"", ",", "category", "=", "UserWarning", ",", "module", "=", "r\"pytorch_lightning.*\"", "\n", ")", "\n", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "self", ".", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "False", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", "\n", "runner", "(", ")", "\n", "\n", "", "self", ".", "is_trained_", "=", "True", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI.__init__": [[89, 160], ["base.RNASeqMixin.__init__", "dict", "_scanvi.SCANVI._set_indices_and_labels", "scvi.module.SCANVAE", "_scanvi.SCANVI._get_init_params", "scvi.model._utils._init_library_size", "locals", "_scanvi.SCANVI.adata_manager.get_state_registry", "_scanvi.SCANVI.summary_stats.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI._set_indices_and_labels", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "Literal", "[", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "]", "=", "\"gene\"", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "SCANVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "scanvae_model_kwargs", "=", "dict", "(", "model_kwargs", ")", "\n", "\n", "self", ".", "_set_indices_and_labels", "(", ")", "\n", "\n", "# ignores unlabeled catgegory", "\n", "n_labels", "=", "self", ".", "summary_stats", ".", "n_labels", "-", "1", "\n", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", ")", ".", "n_cats_per_key", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", "else", "None", "\n", ")", "\n", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "use_size_factor_key", "=", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", ")", "\n", "library_log_means", ",", "library_log_vars", "=", "None", ",", "None", "\n", "if", "not", "use_size_factor_key", ":", "\n", "            ", "library_log_means", ",", "library_log_vars", "=", "_init_library_size", "(", "\n", "self", ".", "adata_manager", ",", "n_batch", "\n", ")", "\n", "\n", "", "self", ".", "module", "=", "SCANVAE", "(", "\n", "n_input", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_labels", "=", "n_labels", ",", "\n", "n_continuous_cov", "=", "self", ".", "summary_stats", ".", "get", "(", "\"n_extra_continuous_covs\"", ",", "0", ")", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "use_size_factor_key", "=", "use_size_factor_key", ",", "\n", "library_log_means", "=", "library_log_means", ",", "\n", "library_log_vars", "=", "library_log_vars", ",", "\n", "**", "scanvae_model_kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "unsupervised_history_", "=", "None", "\n", "self", ".", "semisupervised_history_", "=", "None", "\n", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"ScanVI Model with the following params: \\nunlabeled_category: {}, n_hidden: {}, n_latent: {}\"", "\n", "\", n_layers: {}, dropout_rate: {}, dispersion: {}, gene_likelihood: {}\"", "\n", ")", ".", "format", "(", "\n", "self", ".", "unlabeled_category_", ",", "\n", "n_hidden", ",", "\n", "n_latent", ",", "\n", "n_layers", ",", "\n", "dropout_rate", ",", "\n", "dispersion", ",", "\n", "gene_likelihood", ",", "\n", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "self", ".", "was_pretrained", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI.from_scvi_model": [[161, 230], ["scvi_model._check_if_trained", "dict", "copy.deepcopy", "cls.setup_anndata", "cls", "scvi_model.module.state_dict", "cls.module.load_state_dict", "scvi_model._validate_anndata", "ValueError", "copy.deepcopy.update", "kwargs.items", "j.items", "dict.keys", "warnings.warn", "dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "@", "classmethod", "\n", "def", "from_scvi_model", "(", "\n", "cls", ",", "\n", "scvi_model", ":", "SCVI", ",", "\n", "unlabeled_category", ":", "str", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "**", "scanvi_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize scanVI model with weights from pretrained :class:`~scvi.model.SCVI` model.\n\n        Parameters\n        ----------\n        scvi_model\n            Pretrained scvi model\n        labels_key\n            key in `adata.obs` for label information. Label categories can not be different if\n            labels_key was used to setup the SCVI model. If None, uses the `labels_key` used to\n            setup the SCVI model. If that was None, and error is raised.\n        unlabeled_category\n            Value used for unlabeled cells in `labels_key` used to setup AnnData with scvi.\n        adata\n            AnnData object that has been registered via :meth:`~scvi.model.SCANVI.setup_anndata`.\n        scanvi_kwargs\n            kwargs for scANVI model\n        \"\"\"", "\n", "scvi_model", ".", "_check_if_trained", "(", "\n", "message", "=", "\"Passed in scvi model hasn't been trained yet.\"", "\n", ")", "\n", "\n", "scanvi_kwargs", "=", "dict", "(", "scanvi_kwargs", ")", "\n", "init_params", "=", "scvi_model", ".", "init_params_", "\n", "non_kwargs", "=", "init_params", "[", "\"non_kwargs\"", "]", "\n", "kwargs", "=", "init_params", "[", "\"kwargs\"", "]", "\n", "kwargs", "=", "{", "k", ":", "v", "for", "(", "i", ",", "j", ")", "in", "kwargs", ".", "items", "(", ")", "for", "(", "k", ",", "v", ")", "in", "j", ".", "items", "(", ")", "}", "\n", "for", "k", ",", "v", "in", "{", "**", "non_kwargs", ",", "**", "kwargs", "}", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "in", "scanvi_kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Ignoring param '{}' as it was already passed in to \"", ".", "format", "(", "k", ")", "\n", "+", "\"pretrained scvi model with value {}.\"", ".", "format", "(", "v", ")", "\n", ")", "\n", "del", "scanvi_kwargs", "[", "k", "]", "\n", "\n", "", "", "if", "adata", "is", "None", ":", "\n", "            ", "adata", "=", "scvi_model", ".", "adata", "\n", "", "else", ":", "\n", "# validate new anndata against old model", "\n", "            ", "scvi_model", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "", "scvi_setup_args", "=", "deepcopy", "(", "scvi_model", ".", "adata_manager", ".", "registry", "[", "_SETUP_ARGS_KEY", "]", ")", "\n", "scvi_labels_key", "=", "scvi_setup_args", "[", "\"labels_key\"", "]", "\n", "if", "labels_key", "is", "None", "and", "scvi_labels_key", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"A `labels_key` is necessary as the SCVI model was initialized without one.\"", "\n", ")", "\n", "", "if", "scvi_labels_key", "is", "None", ":", "\n", "            ", "scvi_setup_args", ".", "update", "(", "dict", "(", "labels_key", "=", "labels_key", ")", ")", "\n", "", "cls", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "unlabeled_category", "=", "unlabeled_category", ",", "\n", "**", "scvi_setup_args", ",", "\n", ")", "\n", "scanvi_model", "=", "cls", "(", "adata", ",", "**", "non_kwargs", ",", "**", "kwargs", ",", "**", "scanvi_kwargs", ")", "\n", "scvi_state_dict", "=", "scvi_model", ".", "module", ".", "state_dict", "(", ")", "\n", "scanvi_model", ".", "module", ".", "load_state_dict", "(", "scvi_state_dict", ",", "strict", "=", "False", ")", "\n", "scanvi_model", ".", "was_pretrained", "=", "True", "\n", "\n", "return", "scanvi_model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI._set_indices_and_labels": [[231, 254], ["_scanvi.SCANVI.adata_manager.get_state_registry", "scvi.data._utils.get_anndata_attribute().ravel", "numpy.argwhere().ravel", "numpy.argwhere().ravel", "scvi.data._utils.get_anndata_attribute", "numpy.argwhere", "numpy.argwhere", "enumerate"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["", "def", "_set_indices_and_labels", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Set indices for labeled and unlabeled cells.\n        \"\"\"", "\n", "labels_state_registry", "=", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", "\n", ")", "\n", "self", ".", "original_label_key", "=", "labels_state_registry", ".", "original_key", "\n", "self", ".", "unlabeled_category_", "=", "labels_state_registry", ".", "unlabeled_category", "\n", "\n", "labels", "=", "get_anndata_attribute", "(", "\n", "self", ".", "adata", ",", "\n", "self", ".", "adata_manager", ".", "data_registry", ".", "labels", ".", "attr_name", ",", "\n", "self", ".", "original_label_key", ",", "\n", ")", ".", "ravel", "(", ")", "\n", "self", ".", "_label_mapping", "=", "labels_state_registry", ".", "categorical_mapping", "\n", "\n", "# set unlabeled and labeled indices", "\n", "self", ".", "_unlabeled_indices", "=", "np", ".", "argwhere", "(", "\n", "labels", "==", "self", ".", "unlabeled_category_", "\n", ")", ".", "ravel", "(", ")", "\n", "self", ".", "_labeled_indices", "=", "np", ".", "argwhere", "(", "labels", "!=", "self", ".", "unlabeled_category_", ")", ".", "ravel", "(", ")", "\n", "self", ".", "_code_to_label", "=", "{", "i", ":", "l", "for", "i", ",", "l", "in", "enumerate", "(", "self", ".", "_label_mapping", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI.predict": [[255, 319], ["_scanvi.SCANVI._validate_anndata", "_scanvi.SCANVI._make_data_loader", "enumerate", "torch.cat().numpy", "numpy.arange", "_scanvi.SCANVI.module.classify", "torch.cat().numpy.append", "numpy.array", "len", "pandas.DataFrame", "pred.argmax.argmax.argmax", "pred.argmax.argmax.detach().cpu", "torch.cat", "predictions.append", "tensors.keys", "tensors.keys", "pred.argmax.argmax.detach"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.module._scanvae.SCANVAE.classify"], ["", "def", "predict", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "soft", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "\"\"\"\n        Return cell label predictions.\n\n        Parameters\n        ----------\n        adata\n            AnnData object that has been registered via :meth:`~scvi.model.SCANVI.setup_anndata`.\n        indices\n            Return probabilities for each class label.\n        soft\n            If True, returns per class probabilities\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "\n", "indices", "=", "indices", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", ")", "\n", "y_pred", "=", "[", "]", "\n", "for", "_", ",", "tensors", "in", "enumerate", "(", "scdl", ")", ":", "\n", "            ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "cont_key", "=", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", "\n", "cont_covs", "=", "tensors", "[", "cont_key", "]", "if", "cont_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "cat_key", "=", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", "cat_covs", "=", "tensors", "[", "cat_key", "]", "if", "cat_key", "in", "tensors", ".", "keys", "(", ")", "else", "None", "\n", "\n", "pred", "=", "self", ".", "module", ".", "classify", "(", "\n", "x", ",", "batch_index", "=", "batch", ",", "cat_covs", "=", "cat_covs", ",", "cont_covs", "=", "cont_covs", "\n", ")", "\n", "if", "not", "soft", ":", "\n", "                ", "pred", "=", "pred", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "", "y_pred", ".", "append", "(", "pred", ".", "detach", "(", ")", ".", "cpu", "(", ")", ")", "\n", "\n", "", "y_pred", "=", "torch", ".", "cat", "(", "y_pred", ")", ".", "numpy", "(", ")", "\n", "if", "not", "soft", ":", "\n", "            ", "predictions", "=", "[", "]", "\n", "for", "p", "in", "y_pred", ":", "\n", "                ", "predictions", ".", "append", "(", "self", ".", "_code_to_label", "[", "p", "]", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "predictions", ")", "\n", "", "else", ":", "\n", "            ", "n_labels", "=", "len", "(", "pred", "[", "0", "]", ")", "\n", "pred", "=", "pd", ".", "DataFrame", "(", "\n", "y_pred", ",", "\n", "columns", "=", "self", ".", "_label_mapping", "[", ":", "n_labels", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI.train": [[320, 403], ["logger.info", "scvi.dataloaders.SemiSupervisedDataSplitter", "scvi.train.SemiSupervisedTrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "numpy.min", "trainer_kwargs.keys", "trainer_kwargs[].concatenate", "int", "len", "scvi.train._callbacks.SubSampleLabels", "round", "numpy.min", "numpy.max", "round"], "methods", ["None"], ["", "", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_samples_per_label", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "check_val_every_n_epoch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset for semisupervised training.\n        n_samples_per_label\n            Number of subsamples for each label class to sample per epoch. By default, there\n            is no label subsampling.\n        check_val_every_n_epoch\n            Frequency with which metrics are computed on the data for validation set for both\n            the unsupervised and semisupervised trainers. If you'd like a different frequency for\n            the semisupervised trainer, set check_val_every_n_epoch in semisupervised_train_kwargs.\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.SemiSupervisedTrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **trainer_kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "\n", "if", "max_epochs", "is", "None", ":", "\n", "            ", "n_cells", "=", "self", ".", "adata", ".", "n_obs", "\n", "max_epochs", "=", "np", ".", "min", "(", "[", "round", "(", "(", "20000", "/", "n_cells", ")", "*", "400", ")", ",", "400", "]", ")", "\n", "\n", "if", "self", ".", "was_pretrained", ":", "\n", "                ", "max_epochs", "=", "int", "(", "np", ".", "min", "(", "[", "10", ",", "np", ".", "max", "(", "[", "2", ",", "round", "(", "max_epochs", "/", "3.0", ")", "]", ")", "]", ")", ")", "\n", "\n", "", "", "logger", ".", "info", "(", "\"Training for {} epochs.\"", ".", "format", "(", "max_epochs", ")", ")", "\n", "\n", "plan_kwargs", "=", "{", "}", "if", "plan_kwargs", "is", "None", "else", "plan_kwargs", "\n", "\n", "# if we have labeled cells, we want to subsample labels each epoch", "\n", "sampler_callback", "=", "(", "\n", "[", "SubSampleLabels", "(", ")", "]", "if", "len", "(", "self", ".", "_labeled_indices", ")", "!=", "0", "else", "[", "]", "\n", ")", "\n", "\n", "data_splitter", "=", "SemiSupervisedDataSplitter", "(", "\n", "adata_manager", "=", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "n_samples_per_label", "=", "n_samples_per_label", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "training_plan", "=", "SemiSupervisedTrainingPlan", "(", "self", ".", "module", ",", "**", "plan_kwargs", ")", "\n", "if", "\"callbacks\"", "in", "trainer_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "trainer_kwargs", "[", "\"callbacks\"", "]", ".", "concatenate", "(", "sampler_callback", ")", "\n", "", "else", ":", "\n", "            ", "trainer_kwargs", "[", "\"callbacks\"", "]", "=", "sampler_callback", "\n", "\n", "", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "check_val_every_n_epoch", "=", "check_val_every_n_epoch", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", "\n", "return", "runner", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scanvi.SCANVI.setup_anndata": [[404, 452], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.LabelsWithUnlabeledObsField", "scvi.data.fields.NumericalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "labels_key", ":", "str", ",", "\n", "unlabeled_category", ":", "Union", "[", "str", ",", "int", ",", "float", "]", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "size_factor_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_layer)s\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_size_factor_key)s\n        %(param_cat_cov_keys)s\n        %(param_cont_cov_keys)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "LabelsWithUnlabeledObsField", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ",", "unlabeled_category", "\n", ")", ",", "\n", "NumericalObsField", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", ",", "size_factor_key", ",", "required", "=", "False", "\n", ")", ",", "\n", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "NumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.__init__": [[55, 82], ["base.JaxTrainingMixin.__init__", "scvi.module.base.JaxModuleWrapper", "_jaxscvi.JaxSCVI._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"nb\"", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "\n", "self", ".", "module", "=", "JaxModuleWrapper", "(", "\n", "JaxVAE", ",", "\n", "n_input", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "is_training", "=", "False", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "_model_summary_string", "=", "\"\"", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.setup_anndata": [[83, 110], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_layer)s\n        %(param_batch_key)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.get_latent_representation": [[111, 160], ["_jaxscvi.JaxSCVI._check_if_trained", "_jaxscvi.JaxSCVI._validate_anndata", "_jaxscvi.JaxSCVI._make_data_loader", "_jaxscvi.JaxSCVI.module.get_inference_fn", "jax.concatenate", "jax.concatenate", "numpy.array", "_jaxscvi.JaxSCVI.", "jax.concatenate.append", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.get_inference_fn"], ["", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "give_mean", ":", "bool", "=", "True", ",", "\n", "mc_samples", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Return the latent representation for each cell.\n\n        This is denoted as :math:`z_n` in our manuscripts.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        latent_representation : np.ndarray\n            Low-dimensional representation for each cell\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", "warn", "=", "False", ")", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", ",", "iter_ndarray", "=", "True", "\n", ")", "\n", "\n", "run_inference", "=", "self", ".", "module", ".", "get_inference_fn", "(", "mc_samples", "=", "mc_samples", ")", "\n", "\n", "latent", "=", "[", "]", "\n", "for", "array_dict", "in", "scdl", ":", "\n", "            ", "out", "=", "run_inference", "(", "array_dict", ")", "\n", "if", "give_mean", ":", "\n", "                ", "z", "=", "out", "[", "\"qz\"", "]", ".", "mean", "\n", "", "else", ":", "\n", "                ", "z", "=", "out", "[", "\"z\"", "]", "\n", "", "latent", ".", "append", "(", "z", ")", "\n", "", "concat_axis", "=", "0", "if", "(", "(", "mc_samples", "==", "1", ")", "or", "give_mean", ")", "else", "1", "\n", "latent", "=", "jnp", ".", "concatenate", "(", "latent", ",", "axis", "=", "concat_axis", ")", "\n", "\n", "return", "np", ".", "array", "(", "jax", ".", "device_get", "(", "latent", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device": [[161, 163], ["None"], "methods", ["None"], ["", "def", "to_device", "(", "self", ",", "device", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device": [[164, 167], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "module", ".", "device", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.__init__": [[65, 97], ["scvi.model.base.UnsupervisedTrainingMixin.__init__", "scvi.module.MRDeconv", "_destvi.DestVI._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "st_adata", ":", "AnnData", ",", "\n", "cell_type_mapping", ":", "np", ".", "ndarray", ",", "\n", "decoder_state_dict", ":", "OrderedDict", ",", "\n", "px_decoder_state_dict", ":", "OrderedDict", ",", "\n", "px_r", ":", "np", ".", "ndarray", ",", "\n", "n_hidden", ":", "int", ",", "\n", "n_latent", ":", "int", ",", "\n", "n_layers", ":", "int", ",", "\n", "dropout_decoder", ":", "float", ",", "\n", "l1_reg", ":", "float", ",", "\n", "**", "module_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "DestVI", ",", "self", ")", ".", "__init__", "(", "st_adata", ")", "\n", "self", ".", "module", "=", "MRDeconv", "(", "\n", "n_spots", "=", "st_adata", ".", "n_obs", ",", "\n", "n_labels", "=", "cell_type_mapping", ".", "shape", "[", "0", "]", ",", "\n", "decoder_state_dict", "=", "decoder_state_dict", ",", "\n", "px_decoder_state_dict", "=", "px_decoder_state_dict", ",", "\n", "px_r", "=", "px_r", ",", "\n", "n_genes", "=", "st_adata", ".", "n_vars", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_decoder", "=", "dropout_decoder", ",", "\n", "l1_reg", "=", "l1_reg", ",", "\n", "**", "module_kwargs", ",", "\n", ")", "\n", "self", ".", "cell_type_mapping", "=", "cell_type_mapping", "\n", "self", ".", "_model_summary_string", "=", "\"DestVI Model\"", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.from_rna_model": [[98, 154], ["sc_model.module.decoder.state_dict", "sc_model.module.px_decoder.state_dict", "sc_model.module.px_r.detach().cpu().numpy", "cls", "sc_model.adata_manager.get_state_registry", "sc_model.get_vamp_prior", "sc_model.module.px_r.detach().cpu", "sc_model.module.px_r.detach"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.get_vamp_prior"], ["", "@", "classmethod", "\n", "def", "from_rna_model", "(", "\n", "cls", ",", "\n", "st_adata", ":", "AnnData", ",", "\n", "sc_model", ":", "CondSCVI", ",", "\n", "vamp_prior_p", ":", "int", "=", "15", ",", "\n", "l1_reg", ":", "float", "=", "0.0", ",", "\n", "**", "module_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Alternate constructor for exploiting a pre-trained model on a RNA-seq dataset.\n\n        Parameters\n        ----------\n        st_adata\n            registered anndata object\n        sc_model\n            trained CondSCVI model\n        vamp_prior_p\n            number of mixture parameter for VampPrior calculations\n        l1_reg\n            Scalar parameter indicating the strength of L1 regularization on cell type proportions.\n            A value of 50 leads to sparser results.\n        **model_kwargs\n            Keyword args for :class:`~scvi.model.DestVI`\n        \"\"\"", "\n", "decoder_state_dict", "=", "sc_model", ".", "module", ".", "decoder", ".", "state_dict", "(", ")", "\n", "px_decoder_state_dict", "=", "sc_model", ".", "module", ".", "px_decoder", ".", "state_dict", "(", ")", "\n", "px_r", "=", "sc_model", ".", "module", ".", "px_r", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mapping", "=", "sc_model", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", "\n", ")", ".", "categorical_mapping", "\n", "dropout_decoder", "=", "sc_model", ".", "module", ".", "dropout_rate", "\n", "if", "vamp_prior_p", "is", "None", ":", "\n", "            ", "mean_vprior", "=", "None", "\n", "var_vprior", "=", "None", "\n", "", "else", ":", "\n", "            ", "mean_vprior", ",", "var_vprior", ",", "mp_vprior", "=", "sc_model", ".", "get_vamp_prior", "(", "\n", "sc_model", ".", "adata", ",", "p", "=", "vamp_prior_p", "\n", ")", "\n", "\n", "", "return", "cls", "(", "\n", "st_adata", ",", "\n", "mapping", ",", "\n", "decoder_state_dict", ",", "\n", "px_decoder_state_dict", ",", "\n", "px_r", ",", "\n", "sc_model", ".", "module", ".", "n_hidden", ",", "\n", "sc_model", ".", "module", ".", "n_latent", ",", "\n", "sc_model", ".", "module", ".", "n_layers", ",", "\n", "mean_vprior", "=", "mean_vprior", ",", "\n", "var_vprior", "=", "var_vprior", ",", "\n", "mp_vprior", "=", "mp_vprior", ",", "\n", "dropout_decoder", "=", "dropout_decoder", ",", "\n", "l1_reg", "=", "l1_reg", ",", "\n", "**", "module_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_proportions": [[156, 208], ["_destvi.DestVI._check_if_trained", "pandas.DataFrame", "numpy.append", "_destvi.DestVI._make_data_loader", "torch.cat().numpy", "_destvi.DestVI.module.get_proportions", "_destvi.DestVI.module._get_generative_input", "_destvi.DestVI.module.get_proportions", "logger.info", "_destvi.DestVI.cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions"], ["", "def", "get_proportions", "(", "\n", "self", ",", "\n", "keep_noise", ":", "bool", "=", "False", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "\"\"\"\n        Returns the estimated cell type proportion for the spatial data.\n\n        Shape is n_cells x n_labels OR n_cells x (n_labels + 1) if keep_noise.\n\n        Parameters\n        ----------\n        keep_noise\n            whether to account for the noise term as a standalone cell type in the proportion estimate.\n        indices\n            Indices of cells in adata to use. Only used if amortization. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Only used if amortization. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", ")", "\n", "\n", "column_names", "=", "self", ".", "cell_type_mapping", "\n", "index_names", "=", "self", ".", "adata", ".", "obs", ".", "index", "\n", "if", "keep_noise", ":", "\n", "            ", "column_names", "=", "np", ".", "append", "(", "column_names", ",", "\"noise_term\"", ")", "\n", "\n", "", "if", "self", ".", "module", ".", "amortization", "in", "[", "\"both\"", ",", "\"proportion\"", "]", ":", "\n", "            ", "stdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "self", ".", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "prop_", "=", "[", "]", "\n", "for", "tensors", "in", "stdl", ":", "\n", "                ", "generative_inputs", "=", "self", ".", "module", ".", "_get_generative_input", "(", "tensors", ",", "None", ")", "\n", "prop_local", "=", "self", ".", "module", ".", "get_proportions", "(", "\n", "x", "=", "generative_inputs", "[", "\"x\"", "]", ",", "keep_noise", "=", "keep_noise", "\n", ")", "\n", "prop_", "+=", "[", "prop_local", ".", "cpu", "(", ")", "]", "\n", "", "data", "=", "torch", ".", "cat", "(", "prop_", ")", ".", "numpy", "(", ")", "\n", "if", "indices", ":", "\n", "                ", "index_names", "=", "index_names", "[", "indices", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "indices", "is", "not", "None", ":", "\n", "                ", "logger", ".", "info", "(", "\n", "\"No amortization for proportions, ignoring indices and returning results for the full data\"", "\n", ")", "\n", "", "data", "=", "self", ".", "module", ".", "get_proportions", "(", "keep_noise", "=", "keep_noise", ")", "\n", "\n", "", "return", "pd", ".", "DataFrame", "(", "\n", "data", "=", "data", ",", "\n", "columns", "=", "column_names", ",", "\n", "index", "=", "index_names", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_gamma": [[210, 262], ["_destvi.DestVI._check_if_trained", "numpy.arange", "numpy.transpose", "_destvi.DestVI._make_data_loader", "torch.cat().numpy", "_destvi.DestVI.module.get_gamma", "enumerate", "_destvi.DestVI.module._get_generative_input", "_destvi.DestVI.module.get_gamma", "logger.info", "pandas.DataFrame", "_destvi.DestVI.cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_gamma", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input", "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_gamma"], ["", "def", "get_gamma", "(", "\n", "self", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_numpy", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "Dict", "[", "str", ",", "pd", ".", "DataFrame", "]", "]", ":", "\n", "        ", "\"\"\"\n        Returns the estimated cell-type specific latent space for the spatial data.\n\n        Parameters\n        ----------\n        indices\n            Indices of cells in adata to use. Only used if amortization. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Only used if amortization. Defaults to `scvi.settings.batch_size`.\n        return_numpy\n            if activated, will return a numpy array of shape is n_spots x n_latent x n_labels.\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", ")", "\n", "\n", "column_names", "=", "np", ".", "arange", "(", "self", ".", "module", ".", "n_latent", ")", "\n", "index_names", "=", "self", ".", "adata", ".", "obs", ".", "index", "\n", "\n", "if", "self", ".", "module", ".", "amortization", "in", "[", "\"both\"", ",", "\"latent\"", "]", ":", "\n", "            ", "stdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "self", ".", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "gamma_", "=", "[", "]", "\n", "for", "tensors", "in", "stdl", ":", "\n", "                ", "generative_inputs", "=", "self", ".", "module", ".", "_get_generative_input", "(", "tensors", ",", "None", ")", "\n", "gamma_local", "=", "self", ".", "module", ".", "get_gamma", "(", "x", "=", "generative_inputs", "[", "\"x\"", "]", ")", "\n", "gamma_", "+=", "[", "gamma_local", ".", "cpu", "(", ")", "]", "\n", "", "data", "=", "torch", ".", "cat", "(", "gamma_", ",", "dim", "=", "-", "1", ")", ".", "numpy", "(", ")", "\n", "if", "indices", "is", "not", "None", ":", "\n", "                ", "index_names", "=", "index_names", "[", "indices", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "indices", "is", "not", "None", ":", "\n", "                ", "logger", ".", "info", "(", "\n", "\"No amortization for latent values, ignoring adata and returning results for the full data\"", "\n", ")", "\n", "", "data", "=", "self", ".", "module", ".", "get_gamma", "(", ")", "\n", "\n", "", "data", "=", "np", ".", "transpose", "(", "data", ",", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "if", "return_numpy", ":", "\n", "            ", "return", "data", "\n", "", "else", ":", "\n", "            ", "res", "=", "{", "}", "\n", "for", "i", ",", "ct", "in", "enumerate", "(", "self", ".", "cell_type_mapping", ")", ":", "\n", "                ", "res", "[", "ct", "]", "=", "pd", ".", "DataFrame", "(", "\n", "data", "=", "data", "[", ":", ",", ":", ",", "i", "]", ",", "columns", "=", "column_names", ",", "index", "=", "index_names", "\n", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_scale_for_ct": [[263, 310], ["_destvi.DestVI._check_if_trained", "_destvi.DestVI._make_data_loader", "torch.cat().numpy", "pandas.DataFrame", "ValueError", "_destvi.DestVI.module._get_generative_input", "_destvi.DestVI.module.get_ct_specific_expression", "numpy.where", "_destvi.DestVI.cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.get_ct_specific_expression"], ["", "", "def", "get_scale_for_ct", "(", "\n", "self", ",", "\n", "label", ":", "str", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        Return the scaled parameter of the NB for every spot in queried cell types.\n\n        Parameters\n        ----------\n        label\n            cell type of interest\n        indices\n            Indices of cells in self.adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        Pandas dataframe of gene_expression\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", ")", "\n", "\n", "if", "label", "not", "in", "self", ".", "cell_type_mapping", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown cell type\"", ")", "\n", "", "y", "=", "np", ".", "where", "(", "label", "==", "self", ".", "cell_type_mapping", ")", "[", "0", "]", "[", "0", "]", "\n", "\n", "stdl", "=", "self", ".", "_make_data_loader", "(", "\n", "self", ".", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "scale", "=", "[", "]", "\n", "for", "tensors", "in", "stdl", ":", "\n", "            ", "generative_inputs", "=", "self", ".", "module", ".", "_get_generative_input", "(", "tensors", ",", "None", ")", "\n", "x", ",", "ind_x", "=", "(", "\n", "generative_inputs", "[", "\"x\"", "]", ",", "\n", "generative_inputs", "[", "\"ind_x\"", "]", ",", "\n", ")", "\n", "px_scale", "=", "self", ".", "module", ".", "get_ct_specific_expression", "(", "x", ",", "ind_x", ",", "y", ")", "\n", "scale", "+=", "[", "px_scale", ".", "cpu", "(", ")", "]", "\n", "\n", "", "data", "=", "torch", ".", "cat", "(", "scale", ")", ".", "numpy", "(", ")", "\n", "column_names", "=", "self", ".", "adata", ".", "var", ".", "index", "\n", "index_names", "=", "self", ".", "adata", ".", "obs", ".", "index", "\n", "if", "indices", "is", "not", "None", ":", "\n", "            ", "index_names", "=", "index_names", "[", "indices", "]", "\n", "", "return", "pd", ".", "DataFrame", "(", "data", "=", "data", ",", "columns", "=", "column_names", ",", "index", "=", "index_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.train": [[311, 366], ["super().train", "plan_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "2000", ",", "\n", "lr", ":", "float", "=", "0.003", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "1.0", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "n_epochs_kl_warmup", ":", "int", "=", "200", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model using MAP inference.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of epochs to train for\n        lr\n            Learning rate for optimization.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        n_epochs_kl_warmup\n            number of epochs needed to reach unit kl weight in the elbo\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.TrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "update_dict", "=", "{", "\n", "\"lr\"", ":", "lr", ",", "\n", "\"n_epochs_kl_warmup\"", ":", "n_epochs_kl_warmup", ",", "\n", "}", "\n", "if", "plan_kwargs", "is", "not", "None", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "update_dict", ")", "\n", "", "else", ":", "\n", "            ", "plan_kwargs", "=", "update_dict", "\n", "", "super", "(", ")", ".", "train", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "plan_kwargs", "=", "plan_kwargs", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.setup_anndata": [[368, 395], ["cls._get_setup_method_args", "numpy.arange", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.NumericalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_layer)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "# add index for each cell (provided to pyro plate for correct minibatching)", "\n", "adata", ".", "obs", "[", "\"_indices\"", "]", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "NumericalObsField", "(", "REGISTRY_KEYS", ".", "INDICES_KEY", ",", "\"_indices\"", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg": [[17, 57], ["torch.cuda.is_available", "torch.device", "torch.cuda.current_device", "torch.device", "isinstance", "torch.device", "isinstance", "torch.device", "ValueError", "use_gpu.split"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.device"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.scrna_raw_counts_properties": [[59, 125], ["adata_manager.get_from_registry", "numpy.asarray().ravel", "numpy.asarray().ravel", "numpy.asarray().ravel", "numpy.asarray().ravel", "issubclass", "numpy.asarray().ravel", "numpy.asarray().ravel", "dict", "adata.obs.keys", "adata.obs[].to_numpy().ravel().reshape.ravel", "adata.obs[].to_numpy().ravel().reshape", "type", "data1.multiply", "data2.multiply", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray().ravel().reshape", "numpy.asarray", "numpy.asarray", "data1.mean", "data2.mean", "adata.obs[].to_numpy().ravel", "data1.multiply.mean", "data2.multiply.mean", "numpy.asarray().ravel", "adata.obs[].to_numpy", "numpy.asarray", "adata_manager.get_from_registry.sum"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.cite_seq_raw_counts_properties": [[127, 169], ["_utils.scrna_raw_counts_properties", "adata_manager.get_from_registry", "numpy.array", "adata_manager.get_from_registry", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "dict", "protein_exp[].mean", "protein_exp[].mean", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.scrna_raw_counts_properties", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.scatac_raw_counts_properties": [[171, 206], ["adata_manager.get_from_registry", "numpy.asarray().ravel", "numpy.asarray().ravel", "dict", "numpy.asarray", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category": [[208, 227], ["isinstance", "adata_manager.get_state_registry", "isinstance", "batch_code.append", "ValueError", "batch_code.append", "numpy.where"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size": [[229, 276], ["adata_manager.get_from_registry", "adata_manager.get_from_registry", "numpy.zeros", "numpy.ones", "numpy.unique", "numpy.squeeze", "batch_data.sum", "numpy.ma.log", "numpy.ma.is_masked", "np.ma.log.filled", "numpy.mean().astype", "numpy.var().astype", "np.zeros.reshape", "np.ones.reshape", "warnings.warn", "numpy.mean", "numpy.var", "np.squeeze.nonzero"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager": [[278, 282], ["numpy.asarray", "adata_manager.get_state_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.model._metrics.nearest_neighbor_overlap": [[13, 44], ["len", "min", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.fit", "set", "set", "len", "len", "ValueError", "sklearn.neighbors.NearestNeighbors.kneighbors_graph", "scipy.sparse.identity", "sklearn.neighbors.NearestNeighbors.kneighbors_graph", "scipy.sparse.identity", "scipy.stats.spearmanr", "kmatrix_1.A.flatten", "kmatrix_2.A.flatten", "numpy.where", "numpy.where", "len", "float", "len", "set.intersection", "len", "kmatrix_1.A.flatten", "kmatrix_2.A.flatten"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.identity", "home.repos.pwc.inspect_result.YosefLab_scVI.module._mrdeconv.identity"], ["def", "nearest_neighbor_overlap", "(", "x1", ",", "x2", ",", "k", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Compute the overlap between the k-nearest neighbor graph of x1 and x2.\n\n    Using Spearman correlation of the adjacency matrices.\n    Compute the overlap fold enrichment between the protein and mRNA-based cell 100-nearest neighbor\n        graph and the Spearman correlation of the adjacency matrices.\n    \"\"\"", "\n", "if", "len", "(", "x1", ")", "!=", "len", "(", "x2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"len(x1) != len(x2)\"", ")", "\n", "", "n_samples", "=", "len", "(", "x1", ")", "\n", "k", "=", "min", "(", "k", ",", "n_samples", "-", "1", ")", "\n", "nne", "=", "NearestNeighbors", "(", "n_neighbors", "=", "k", "+", "1", ")", "# \"n_jobs=8", "\n", "nne", ".", "fit", "(", "x1", ")", "\n", "kmatrix_1", "=", "nne", ".", "kneighbors_graph", "(", "x1", ")", "-", "scipy", ".", "sparse", ".", "identity", "(", "n_samples", ")", "\n", "nne", ".", "fit", "(", "x2", ")", "\n", "kmatrix_2", "=", "nne", ".", "kneighbors_graph", "(", "x2", ")", "-", "scipy", ".", "sparse", ".", "identity", "(", "n_samples", ")", "\n", "\n", "# 1 - spearman correlation from knn graphs", "\n", "spearman_correlation", "=", "scipy", ".", "stats", ".", "spearmanr", "(", "\n", "kmatrix_1", ".", "A", ".", "flatten", "(", ")", ",", "kmatrix_2", ".", "A", ".", "flatten", "(", ")", "\n", ")", "[", "0", "]", "\n", "# 2 - fold enrichment", "\n", "set_1", "=", "set", "(", "np", ".", "where", "(", "kmatrix_1", ".", "A", ".", "flatten", "(", ")", "==", "1", ")", "[", "0", "]", ")", "\n", "set_2", "=", "set", "(", "np", ".", "where", "(", "kmatrix_2", ".", "A", ".", "flatten", "(", ")", "==", "1", ")", "[", "0", "]", ")", "\n", "fold_enrichment", "=", "(", "\n", "len", "(", "set_1", ".", "intersection", "(", "set_2", ")", ")", "\n", "*", "n_samples", "**", "2", "\n", "/", "(", "float", "(", "len", "(", "set_1", ")", ")", "*", "len", "(", "set_2", ")", ")", "\n", ")", "\n", "return", "spearman_correlation", ",", "fold_enrichment", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._metrics.unsupervised_clustering_accuracy": [[46, 69], ["numpy.unique", "len", "dict", "numpy.zeros", "zip", "scipy.optimize.linear_sum_assignment", "row_assign.reshape.reshape", "col_assign.reshape.reshape", "numpy.concatenate", "len", "len", "ValueError", "numpy.concatenate", "zip", "np.zeros.max", "reward_matrix[].sum", "range"], "function", ["None"], ["", "def", "unsupervised_clustering_accuracy", "(", "\n", "y", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "y_pred", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", "\n", ")", "->", "tuple", ":", "\n", "    ", "\"\"\"Unsupervised Clustering Accuracy.\"\"\"", "\n", "if", "len", "(", "y_pred", ")", "!=", "len", "(", "y", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"len(y_pred) != len(y)\"", ")", "\n", "", "u", "=", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "(", "y", ",", "y_pred", ")", ")", ")", "\n", "n_clusters", "=", "len", "(", "u", ")", "\n", "mapping", "=", "dict", "(", "zip", "(", "u", ",", "range", "(", "n_clusters", ")", ")", ")", "\n", "reward_matrix", "=", "np", ".", "zeros", "(", "(", "n_clusters", ",", "n_clusters", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "for", "y_pred_", ",", "y_", "in", "zip", "(", "y_pred", ",", "y", ")", ":", "\n", "        ", "if", "y_", "in", "mapping", ":", "\n", "            ", "reward_matrix", "[", "mapping", "[", "y_pred_", "]", ",", "mapping", "[", "y_", "]", "]", "+=", "1", "\n", "", "", "cost_matrix", "=", "reward_matrix", ".", "max", "(", ")", "-", "reward_matrix", "\n", "row_assign", ",", "col_assign", "=", "linear_sum_assignment", "(", "cost_matrix", ")", "\n", "\n", "# Construct optimal assignments matrix", "\n", "row_assign", "=", "row_assign", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "# (n,) to (n, 1) reshape", "\n", "col_assign", "=", "col_assign", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "# (n,) to (n, 1) reshape", "\n", "assignments", "=", "np", ".", "concatenate", "(", "(", "row_assign", ",", "col_assign", ")", ",", "axis", "=", "1", ")", "\n", "\n", "optimal_reward", "=", "reward_matrix", "[", "row_assign", ",", "col_assign", "]", ".", "sum", "(", ")", "*", "1.0", "\n", "return", "optimal_reward", "/", "y_pred", ".", "size", ",", "assignments", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._metrics.knn_purity": [[71, 83], ["sklearn.neighbors.NearestNeighbors().fit", "numpy.mean", "NearestNeighbors().fit.kneighbors", "numpy.vectorize", "numpy.mean", "sklearn.neighbors.NearestNeighbors", "numpy.unique", "label.reshape"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "knn_purity", "(", "latent", ",", "label", ",", "n_neighbors", "=", "30", ")", ":", "\n", "    ", "nbrs", "=", "NearestNeighbors", "(", "n_neighbors", "=", "n_neighbors", "+", "1", ")", ".", "fit", "(", "latent", ")", "\n", "indices", "=", "nbrs", ".", "kneighbors", "(", "latent", ",", "return_distance", "=", "False", ")", "[", ":", ",", "1", ":", "]", "\n", "neighbors_labels", "=", "np", ".", "vectorize", "(", "lambda", "i", ":", "label", "[", "i", "]", ")", "(", "indices", ")", "\n", "\n", "# pre cell purity scores", "\n", "scores", "=", "(", "(", "neighbors_labels", "-", "label", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "==", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "res", "=", "[", "\n", "np", ".", "mean", "(", "scores", "[", "label", "==", "i", "]", ")", "for", "i", "in", "np", ".", "unique", "(", "label", ")", "\n", "]", "# per cell-type purity", "\n", "\n", "return", "np", ".", "mean", "(", "res", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.__init__": [[49, 98], ["pyro.clear_param_store", "base.PyroSviTrainMixin.__init__", "scvi.module.AmortizedLDAPyroModule", "_amortizedlda.AmortizedLDA._get_init_params", "ValueError", "ValueError", "locals", "isinstance", "isinstance", "isinstance", "len", "isinstance", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_topics", ":", "int", ",", "\n", "cell_topic_prior", ":", "torch", ".", "Tensor", ",", "\n", "topic_feature_prior", ":", "torch", ".", "Tensor", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "_AMORTIZED_LDA_PYRO_MODULE_NAME", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "# Populated by PyroTrainingPlan.", "\n", "self", ".", "n_obs", "=", "None", "\n", "\n", "cell_topic_prior_mu", ",", "cell_topic_prior_sigma", "=", "logistic_normal_approximation", "(", "\n", "cell_topic_prior", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"cell_topic_prior_mu\"", ",", "\n", "cell_topic_prior_mu", ",", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "\"cell_topic_prior_sigma\"", ",", "\n", "cell_topic_prior_sigma", ",", "\n", ")", "\n", "(", "\n", "topic_feature_prior_mu", ",", "\n", "topic_feature_prior_sigma", ",", "\n", ")", "=", "logistic_normal_approximation", "(", "topic_feature_prior", ")", "\n", "self", ".", "register_buffer", "(", "\"topic_feature_prior_mu\"", ",", "topic_feature_prior_mu", ")", "\n", "self", ".", "register_buffer", "(", "\"topic_feature_prior_sigma\"", ",", "topic_feature_prior_sigma", ")", "\n", "\n", "# Hack: to allow auto_move_data to infer device.", "\n", "self", ".", "_dummy", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "", "@", "staticmethod", "\n", "def", "_get_fn_args_from_batch", "(", "\n", "tensor_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.setup_anndata": [[99, 124], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], [")", "->", "Union", "[", "Iterable", ",", "dict", "]", ":", "\n", "\n", "        ", "x", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "library", "=", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", "\n", "return", "(", "x", ",", "library", ")", ",", "{", "}", "\n", "\n", "", "@", "auto_move_data", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "library", ":", "torch", ".", "Tensor", ",", "\n", "n_obs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "# Topic feature distributions.", "\n", "        ", "with", "pyro", ".", "plate", "(", "\"topics\"", ",", "self", ".", "n_topics", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "log_topic_feature_dist", "=", "pyro", ".", "sample", "(", "\n", "\"log_topic_feature_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "topic_feature_prior_mu", ",", "self", ".", "topic_feature_prior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "topic_feature_dist", "=", "F", ".", "softmax", "(", "log_topic_feature_dist", ",", "dim", "=", "1", ")", "\n", "\n", "# Cell counts generation.", "\n", "", "max_library_size", "=", "int", "(", "torch", ".", "max", "(", "library", ")", ".", "item", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_feature_by_topic": [[125, 149], ["_amortizedlda.AmortizedLDA._check_if_trained", "_amortizedlda.AmortizedLDA.module.topic_by_feature", "pandas.DataFrame", "_amortizedlda.AmortizedLDA.numpy", "range"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.topic_by_feature"], ["with", "pyro", ".", "plate", "(", "\"cells\"", ",", "size", "=", "n_obs", "or", "self", ".", "n_obs", ",", "subsample_size", "=", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "with", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "                ", "log_cell_topic_dist", "=", "pyro", ".", "sample", "(", "\n", "\"log_cell_topic_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "cell_topic_prior_mu", ",", "self", ".", "cell_topic_prior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "", "cell_topic_dist", "=", "F", ".", "softmax", "(", "log_cell_topic_dist", ",", "dim", "=", "1", ")", "\n", "\n", "pyro", ".", "sample", "(", "\n", "\"feature_counts\"", ",", "\n", "CategoricalBoW", "(", "max_library_size", ",", "cell_topic_dist", "@", "topic_feature_dist", ")", ",", "\n", "obs", "=", "x", ",", "\n", ")", "\n", "\n", "\n", "", "", "", "class", "AmortizedLDAPyroGuide", "(", "PyroModule", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_latent_representation": [[151, 195], ["_amortizedlda.AmortizedLDA._check_if_trained", "_amortizedlda.AmortizedLDA._validate_anndata", "_amortizedlda.AmortizedLDA._make_data_loader", "torch.cat().numpy", "pandas.DataFrame", "transformed_xs.append", "_amortizedlda.AmortizedLDA.module.get_topic_distribution", "torch.cat", "range"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.module._amortizedlda.AmortizedLDAPyroModule.get_topic_distribution"], ["\n", "\n", "def", "__init__", "(", "self", ",", "n_input", ":", "int", ",", "n_topics", ":", "int", ",", "n_hidden", ":", "int", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "_AMORTIZED_LDA_PYRO_MODULE_NAME", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "# Populated by PyroTrainingPlan.", "\n", "self", ".", "n_obs", "=", "None", "\n", "\n", "self", ".", "encoder", "=", "Encoder", "(", "n_input", ",", "n_topics", ",", "distribution", "=", "\"ln\"", ",", "return_dist", "=", "True", ")", "\n", "(", "\n", "topic_feature_posterior_mu", ",", "\n", "topic_feature_posterior_sigma", ",", "\n", ")", "=", "logistic_normal_approximation", "(", "torch", ".", "ones", "(", "self", ".", "n_input", ")", ")", "\n", "self", ".", "topic_feature_posterior_mu", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "topic_feature_posterior_mu", ".", "repeat", "(", "self", ".", "n_topics", ",", "1", ")", "\n", ")", "\n", "self", ".", "unconstrained_topic_feature_posterior_sigma", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "topic_feature_posterior_sigma", ".", "repeat", "(", "self", ".", "n_topics", ",", "1", ")", "\n", ")", "\n", "\n", "", "@", "property", "\n", "def", "topic_feature_posterior_sigma", "(", "self", ")", ":", "\n", "        ", "return", "F", ".", "softplus", "(", "self", ".", "unconstrained_topic_feature_posterior_sigma", ")", "\n", "\n", "", "@", "auto_move_data", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "_library", ":", "torch", ".", "Tensor", ",", "\n", "n_obs", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "kl_weight", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "# Topic feature distributions.", "\n", "        ", "with", "pyro", ".", "plate", "(", "\"topics\"", ",", "self", ".", "n_topics", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "pyro", ".", "sample", "(", "\n", "\"log_topic_feature_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "self", ".", "topic_feature_posterior_mu", ",", "\n", "self", ".", "topic_feature_posterior_sigma", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo": [[197, 234], ["_amortizedlda.AmortizedLDA._check_if_trained", "_amortizedlda.AmortizedLDA._validate_anndata", "_amortizedlda.AmortizedLDA._make_data_loader", "numpy.mean", "x.sum", "elbos.append", "_amortizedlda.AmortizedLDA.module.get_elbo", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], [")", "\n", "\n", "# Cell topic distributions guide.", "\n", "", "with", "pyro", ".", "plate", "(", "\n", "\"cells\"", ",", "size", "=", "n_obs", "or", "self", ".", "n_obs", ",", "subsample_size", "=", "x", ".", "shape", "[", "0", "]", "\n", ")", ",", "poutine", ".", "scale", "(", "None", ",", "kl_weight", ")", ":", "\n", "            ", "cell_topic_posterior", ",", "_", "=", "self", ".", "encoder", "(", "x", ")", "\n", "cell_topic_posterior_mu", "=", "cell_topic_posterior", ".", "loc", "\n", "cell_topic_posterior_sigma", "=", "cell_topic_posterior", ".", "scale", "**", "2", "\n", "pyro", ".", "sample", "(", "\n", "\"log_cell_topic_dist\"", ",", "\n", "dist", ".", "Normal", "(", "\n", "cell_topic_posterior_mu", ",", "cell_topic_posterior_sigma", "\n", ")", ".", "to_event", "(", "1", ")", ",", "\n", ")", "\n", "\n", "\n", "", "", "", "class", "AmortizedLDAPyroModule", "(", "PyroBaseModuleClass", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_perplexity": [[235, 269], ["_amortizedlda.AmortizedLDA._check_if_trained", "_amortizedlda.AmortizedLDA._validate_anndata", "_amortizedlda.AmortizedLDA._make_data_loader", "sum", "numpy.exp", "tensors[].sum().item", "_amortizedlda.AmortizedLDA.get_elbo", "tensors[].sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "n_input", ":", "int", ",", "\n", "n_topics", ":", "int", ",", "\n", "n_hidden", ":", "int", ",", "\n", "cell_topic_prior", ":", "Optional", "[", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", "]", "=", "None", ",", "\n", "topic_feature_prior", ":", "Optional", "[", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_topics", "=", "n_topics", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "\n", "if", "cell_topic_prior", "is", "None", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "full", "(", "(", "n_topics", ",", ")", ",", "1", "/", "self", ".", "n_topics", ")", "\n", "", "elif", "isinstance", "(", "cell_topic_prior", ",", "float", ")", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "full", "(", "(", "n_topics", ",", ")", ",", "cell_topic_prior", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cell_topic_prior", "=", "torch", ".", "tensor", "(", "cell_topic_prior", ")", "\n", "\n", "", "if", "topic_feature_prior", "is", "None", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "full", "(", "(", "n_input", ",", ")", ",", "1", "/", "self", ".", "n_topics", ")", "\n", "", "elif", "isinstance", "(", "topic_feature_prior", ",", "float", ")", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "full", "(", "(", "n_input", ",", ")", ",", "topic_feature_prior", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "topic_feature_prior", "=", "torch", ".", "tensor", "(", "topic_feature_prior", ")", "\n", "\n", "", "self", ".", "_model", "=", "AmortizedLDAPyroModel", "(", "\n", "self", ".", "n_input", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._linear_scvi.LinearSCVI.__init__": [[73, 120], ["base.RNASeqMixin.__init__", "scvi.model._utils._init_library_size", "scvi.module.LDVAE", "_linear_scvi.LinearSCVI._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "Literal", "[", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "]", "=", "\"gene\"", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"nb\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "LinearSCVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "library_log_means", ",", "library_log_vars", "=", "_init_library_size", "(", "\n", "self", ".", "adata_manager", ",", "n_batch", "\n", ")", "\n", "\n", "self", ".", "module", "=", "LDVAE", "(", "\n", "n_input", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers_encoder", "=", "n_layers", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "library_log_means", "=", "library_log_means", ",", "\n", "library_log_vars", "=", "library_log_vars", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"LinearSCVI Model with the following params: \\nn_hidden: {}, n_latent: {}, n_layers: {}, dropout_rate: \"", "\n", "\"{}, dispersion: {}, gene_likelihood: {}, latent_distribution: {}\"", "\n", ")", ".", "format", "(", "\n", "n_hidden", ",", "\n", "n_latent", ",", "\n", "n_layers", ",", "\n", "dropout_rate", ",", "\n", "dispersion", ",", "\n", "gene_likelihood", ",", "\n", "latent_distribution", ",", "\n", ")", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._linear_scvi.LinearSCVI.get_loadings": [[121, 135], ["pandas.DataFrame", "_linear_scvi.LinearSCVI.module.get_loadings", "range"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._linear_scvi.LinearSCVI.get_loadings"], ["", "def", "get_loadings", "(", "self", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "\"\"\"\n        Extract per-gene weights in the linear decoder.\n\n        Shape is genes by `n_latent`.\n\n        \"\"\"", "\n", "cols", "=", "[", "\"Z_{}\"", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_latent", ")", "]", "\n", "var_names", "=", "self", ".", "adata", ".", "var_names", "\n", "loadings", "=", "pd", ".", "DataFrame", "(", "\n", "self", ".", "module", ".", "get_loadings", "(", ")", ",", "index", "=", "var_names", ",", "columns", "=", "cols", "\n", ")", "\n", "\n", "return", "loadings", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._linear_scvi.LinearSCVI.setup_anndata": [[136, 166], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_layer)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.__init__": [[108, 184], ["base.VAEMixin.__init__", "scvi.module.MULTIVAE", "_multivi.MULTIVI._get_init_params", "locals", "_multivi.MULTIVI.adata_manager.get_state_registry", "_multivi.MULTIVI.summary_stats.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_genes", ":", "int", ",", "\n", "n_regions", ":", "int", ",", "\n", "n_hidden", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_latent", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_layers_encoder", ":", "int", "=", "2", ",", "\n", "n_layers_decoder", ":", "int", "=", "2", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "region_factors", ":", "bool", "=", "True", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "deeply_inject_covariates", ":", "bool", "=", "False", ",", "\n", "encode_covariates", ":", "bool", "=", "False", ",", "\n", "fully_paired", ":", "bool", "=", "False", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", ")", ".", "n_cats_per_key", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", "else", "[", "]", "\n", ")", "\n", "\n", "use_size_factor_key", "=", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", ")", "\n", "\n", "self", ".", "module", "=", "MULTIVAE", "(", "\n", "n_input_genes", "=", "n_genes", ",", "\n", "n_input_regions", "=", "n_regions", ",", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers_encoder", "=", "n_layers_encoder", ",", "\n", "n_layers_decoder", "=", "n_layers_decoder", ",", "\n", "n_continuous_cov", "=", "self", ".", "summary_stats", ".", "get", "(", "\"n_extra_continuous_covs\"", ",", "0", ")", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "region_factors", "=", "region_factors", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "use_size_factor_key", "=", "use_size_factor_key", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "deeply_inject_covariates", "=", "deeply_inject_covariates", ",", "\n", "encode_covariates", "=", "encode_covariates", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"MultiVI Model with INPUTS: n_genes:{}, n_regions:{}\\n\"", "\n", "\"n_hidden: {}, n_latent: {}, n_layers_encoder: {}, \"", "\n", "\"n_layers_decoder: {} , dropout_rate: {}, latent_distribution: {}, deep injection: {}, \"", "\n", "\"gene_likelihood: {}\"", "\n", ")", ".", "format", "(", "\n", "n_genes", ",", "\n", "n_regions", ",", "\n", "self", ".", "module", ".", "n_hidden", ",", "\n", "self", ".", "module", ".", "n_latent", ",", "\n", "n_layers_encoder", ",", "\n", "n_layers_decoder", ",", "\n", "dropout_rate", ",", "\n", "latent_distribution", ",", "\n", "deeply_inject_covariates", ",", "\n", "gene_likelihood", ",", "\n", ")", "\n", "self", ".", "fully_paired", "=", "fully_paired", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "self", ".", "n_genes", "=", "n_genes", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.train": [[185, 293], ["dict", "scvi.dataloaders.DataSplitter", "scvi.train.AdversarialTrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "plan_kwargs.update", "kwargs[].append", "kwargs.keys", "scvi.train._callbacks.SaveBestState"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "500", ",", "\n", "lr", ":", "float", "=", "1e-4", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "weight_decay", ":", "float", "=", "1e-3", ",", "\n", "eps", ":", "float", "=", "1e-08", ",", "\n", "early_stopping", ":", "bool", "=", "True", ",", "\n", "save_best", ":", "bool", "=", "True", ",", "\n", "check_val_every_n_epoch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_steps_kl_warmup", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Optional", "[", "int", "]", "=", "50", ",", "\n", "adversarial_mixing", ":", "bool", "=", "True", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model using amortized variational inference.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset.\n        lr\n            Learning rate for optimization.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        weight_decay\n            weight decay regularization term for optimization\n        eps\n            Optimizer eps\n        early_stopping\n            Whether to perform early stopping with respect to the validation set.\n        save_best\n            Save the best model state with respect to the validation loss, or use the final\n            state in the training procedure\n        check_val_every_n_epoch\n            Check val every n train epochs. By default, val is not checked, unless `early_stopping` is `True`.\n            If so, val is checked every epoch.\n        n_steps_kl_warmup\n            Number of training steps (minibatches) to scale weight on KL divergences from 0 to 1.\n            Only activated when `n_epochs_kl_warmup` is set to None. If `None`, defaults\n            to `floor(0.75 * adata.n_obs)`.\n        n_epochs_kl_warmup\n            Number of epochs to scale weight on KL divergences from 0 to 1.\n            Overrides `n_steps_kl_warmup` when both are not `None`.\n        adversarial_mixing\n            Whether to use adversarial training to penalize the model for umbalanced mixing of modalities.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.TrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "update_dict", "=", "dict", "(", "\n", "lr", "=", "lr", ",", "\n", "adversarial_classifier", "=", "adversarial_mixing", ",", "\n", "weight_decay", "=", "weight_decay", ",", "\n", "eps", "=", "eps", ",", "\n", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", ",", "\n", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", ",", "\n", "optimizer", "=", "\"AdamW\"", ",", "\n", "scale_adversarial_loss", "=", "1", ",", "\n", ")", "\n", "if", "plan_kwargs", "is", "not", "None", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "update_dict", ")", "\n", "", "else", ":", "\n", "            ", "plan_kwargs", "=", "update_dict", "\n", "\n", "", "if", "save_best", ":", "\n", "            ", "if", "\"callbacks\"", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "kwargs", "[", "\"callbacks\"", "]", "=", "[", "]", "\n", "", "kwargs", "[", "\"callbacks\"", "]", ".", "append", "(", "\n", "SaveBestState", "(", "monitor", "=", "\"reconstruction_loss_validation\"", ")", "\n", ")", "\n", "\n", "", "data_splitter", "=", "DataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "training_plan", "=", "AdversarialTrainingPlan", "(", "self", ".", "module", ",", "**", "plan_kwargs", ")", "\n", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "early_stopping", "=", "early_stopping", ",", "\n", "check_val_every_n_epoch", "=", "check_val_every_n_epoch", ",", "\n", "early_stopping_monitor", "=", "\"reconstruction_loss_validation\"", ",", "\n", "early_stopping_patience", "=", "50", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "return", "runner", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.get_library_size_factors": [[294, 333], ["torch.no_grad", "_multivi.MULTIVI._validate_anndata", "_multivi.MULTIVI._make_data_loader", "_multivi.MULTIVI.module.inference", "lib_exp.append", "lib_acc.append", "torch.cat().numpy().squeeze", "torch.cat().numpy().squeeze", "outputs[].cpu", "outputs[].cpu", "_multivi.MULTIVI.module._get_inference_input", "torch.cat().numpy", "torch.cat().numpy", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_library_size_factors", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return library size factors.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        Library size factor for expression and accessibility\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "lib_exp", "=", "[", "]", "\n", "lib_acc", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", ")", "\n", "lib_exp", ".", "append", "(", "outputs", "[", "\"libsize_expr\"", "]", ".", "cpu", "(", ")", ")", "\n", "lib_acc", ".", "append", "(", "outputs", "[", "\"libsize_acc\"", "]", ".", "cpu", "(", ")", ")", "\n", "\n", "", "return", "{", "\n", "\"expression\"", ":", "torch", ".", "cat", "(", "lib_exp", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", ",", "\n", "\"accessibility\"", ":", "torch", ".", "cat", "(", "lib_acc", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.get_region_factors": [[335, 341], ["torch.no_grad", "torch.sigmoid().cpu().numpy", "RuntimeError", "torch.sigmoid().cpu", "torch.sigmoid"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_region_factors", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"Return region-specific factors.\"\"\"", "\n", "if", "self", ".", "module", ".", "region_factors", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"region factors were not included in this model\"", ")", "\n", "", "return", "torch", ".", "sigmoid", "(", "self", ".", "module", ".", "region_factors", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.get_latent_representation": [[342, 414], ["torch.no_grad", "_multivi.MULTIVI._validate_anndata", "_multivi.MULTIVI._make_data_loader", "torch.cat().numpy", "RuntimeError", "RuntimeError", "_multivi.MULTIVI.module._get_inference_input", "_multivi.MULTIVI.module.inference", "z.mean.mean.cpu", "torch.cat", "RuntimeError", "torch.distributions.Normal().sample", "torch.nn.functional.softmax", "z.mean.mean.mean", "torch.distributions.Normal", "qz_v.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "modality", ":", "Literal", "[", "\"joint\"", ",", "\"expression\"", ",", "\"accessibility\"", "]", "=", "\"joint\"", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "give_mean", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Return the latent representation for each cell.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        modality\n            Return modality specific or joint latent representation.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        give_mean\n            Give mean of distribution or sample from it.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        latent_representation : np.ndarray\n            Low-dimensional representation for each cell\n        \"\"\"", "\n", "if", "not", "self", ".", "is_trained_", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Please train the model first.\"", ")", "\n", "\n", "", "keys", "=", "{", "\"z\"", ":", "\"z\"", ",", "\"qz_m\"", ":", "\"qz_m\"", ",", "\"qz_v\"", ":", "\"qz_v\"", "}", "\n", "if", "self", ".", "fully_paired", "and", "modality", "!=", "\"joint\"", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"A fully paired model only has a joint latent representation.\"", "\n", ")", "\n", "", "if", "not", "self", ".", "fully_paired", "and", "modality", "!=", "\"joint\"", ":", "\n", "            ", "if", "modality", "==", "\"expression\"", ":", "\n", "                ", "keys", "=", "{", "\"z\"", ":", "\"z_expr\"", ",", "\"qz_m\"", ":", "\"qzm_expr\"", ",", "\"qz_v\"", ":", "\"qzv_expr\"", "}", "\n", "", "elif", "modality", "==", "\"accessibility\"", ":", "\n", "                ", "keys", "=", "{", "\"z\"", ":", "\"z_acc\"", ",", "\"qz_m\"", ":", "\"qzm_acc\"", ",", "\"qz_v\"", ":", "\"qzv_acc\"", "}", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "\"modality must be 'joint', 'expression', or 'accessibility'.\"", "\n", ")", "\n", "\n", "", "", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "latent", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "qz_m", "=", "outputs", "[", "keys", "[", "\"qz_m\"", "]", "]", "\n", "qz_v", "=", "outputs", "[", "keys", "[", "\"qz_v\"", "]", "]", "\n", "z", "=", "outputs", "[", "keys", "[", "\"z\"", "]", "]", "\n", "\n", "if", "give_mean", ":", "\n", "# does each model need to have this latent distribution param?", "\n", "                ", "if", "self", ".", "module", ".", "latent_distribution", "==", "\"ln\"", ":", "\n", "                    ", "samples", "=", "Normal", "(", "qz_m", ",", "qz_v", ".", "sqrt", "(", ")", ")", ".", "sample", "(", "[", "1", "]", ")", "\n", "z", "=", "torch", ".", "nn", ".", "functional", ".", "softmax", "(", "samples", ",", "dim", "=", "-", "1", ")", "\n", "z", "=", "z", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                    ", "z", "=", "qz_m", "\n", "\n", "", "", "latent", "+=", "[", "z", ".", "cpu", "(", ")", "]", "\n", "", "return", "torch", ".", "cat", "(", "latent", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.get_accessibility_estimates": [[415, 531], ["torch.no_grad", "_multivi.MULTIVI._validate_anndata", "_multivi.MULTIVI.get_anndata_manager", "_multivi.MULTIVI._make_data_loader", "scvi.model._utils._get_batch_code_from_category", "numpy.arange", "numpy.random.choice", "slice", "ValueError", "dict", "dict", "_multivi.MULTIVI.module.forward", "generative_outputs[].cpu", "torch.cat().numpy.append", "scipy.sparse.vstack", "torch.cat().numpy", "inference_outputs[].cpu", "torch.sigmoid().cpu", "scipy.sparse.csr_matrix", "pandas.DataFrame.sparse.from_spmatrix", "pandas.DataFrame", "scipy.sparse.csr_matrix.numpy", "torch.cat", "torch.sigmoid"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_accessibility_estimates", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", "n_samples_overall", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "region_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Union", "[", "str", ",", "int", "]", "]", "=", "None", ",", "\n", "use_z_mean", ":", "bool", "=", "True", ",", "\n", "threshold", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "normalize_cells", ":", "bool", "=", "False", ",", "\n", "normalize_regions", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "return_numpy", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "csr_matrix", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "\"\"\"\n        Impute the full accessibility matrix.\n\n        Returns a matrix of accessibility probabilities for each cell and genomic region in the input\n        (for return matrix A, A[i,j] is the probability that region j is accessible in cell i).\n\n        Parameters\n        ----------\n        adata\n            AnnData object that has been registered with scvi. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples_overall\n            Number of samples to return in total\n        region_indices\n            Indices of regions to use. if `None`, all regions are used.\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used\n            - int, then batch transform_batch is used\n        use_z_mean\n            If True (default), use the distribution mean. Otherwise, sample from the distribution.\n        threshold\n            If provided, values below the threshold are replaced with 0 and a sparse matrix\n            is returned instead. This is recommended for very large matrices. Must be between 0 and 1.\n        normalize_cells\n            Whether to reintroduce library size factors to scale the normalized probabilities.\n            This makes the estimates closer to the input, but removes the library size correction.\n            False by default.\n        normalize_regions\n            Whether to reintroduce region factors to scale the normalized probabilities. This makes\n            the estimates closer to the input, but removes the region-level bias correction. False by\n            default.\n        batch_size\n            Minibatch size for data loading into model\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "n_samples_overall", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "n_samples_overall", ")", "\n", "", "post", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "transform_batch", "=", "_get_batch_code_from_category", "(", "adata_manager", ",", "transform_batch", ")", "\n", "\n", "if", "region_list", "is", "None", ":", "\n", "            ", "region_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "region_mask", "=", "[", "\n", "region", "in", "region_list", "for", "region", "in", "adata", ".", "var_names", "[", "self", ".", "n_genes", ":", "]", "\n", "]", "\n", "\n", "", "if", "threshold", "is", "not", "None", "and", "(", "threshold", "<", "0", "or", "threshold", ">", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"the provided threshold must be between 0 and 1\"", ")", "\n", "\n", "", "imputed", "=", "[", "]", "\n", "for", "tensors", "in", "post", ":", "\n", "            ", "get_generative_input_kwargs", "=", "dict", "(", "transform_batch", "=", "transform_batch", "[", "0", "]", ")", "\n", "generative_kwargs", "=", "dict", "(", "use_z_mean", "=", "use_z_mean", ")", "\n", "inference_outputs", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "get_generative_input_kwargs", "=", "get_generative_input_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "p", "=", "generative_outputs", "[", "\"p\"", "]", ".", "cpu", "(", ")", "\n", "\n", "if", "normalize_cells", ":", "\n", "                ", "p", "*=", "inference_outputs", "[", "\"libsize_acc\"", "]", ".", "cpu", "(", ")", "\n", "", "if", "normalize_regions", ":", "\n", "                ", "p", "*=", "torch", ".", "sigmoid", "(", "self", ".", "module", ".", "region_factors", ")", ".", "cpu", "(", ")", "\n", "", "if", "threshold", ":", "\n", "                ", "p", "[", "p", "<", "threshold", "]", "=", "0", "\n", "p", "=", "csr_matrix", "(", "p", ".", "numpy", "(", ")", ")", "\n", "", "if", "region_mask", "is", "not", "None", ":", "\n", "                ", "p", "=", "p", "[", ":", ",", "region_mask", "]", "\n", "", "imputed", ".", "append", "(", "p", ")", "\n", "\n", "", "if", "threshold", ":", "# imputed is a list of csr_matrix objects", "\n", "            ", "imputed", "=", "vstack", "(", "imputed", ",", "format", "=", "\"csr\"", ")", "\n", "", "else", ":", "# imputed is a list of tensors", "\n", "            ", "imputed", "=", "torch", ".", "cat", "(", "imputed", ")", ".", "numpy", "(", ")", "\n", "\n", "", "if", "return_numpy", ":", "\n", "            ", "return", "imputed", "\n", "", "elif", "threshold", ":", "\n", "            ", "return", "pd", ".", "DataFrame", ".", "sparse", ".", "from_spmatrix", "(", "\n", "imputed", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", "self", ".", "n_genes", ":", "]", "[", "region_mask", "]", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "pd", ".", "DataFrame", "(", "\n", "imputed", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", "self", ".", "n_genes", ":", "]", "[", "region_mask", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.get_normalized_expression": [[533, 644], ["torch.no_grad", "_multivi.MULTIVI._validate_anndata", "_multivi.MULTIVI.get_anndata_manager", "_multivi.MULTIVI._make_data_loader", "scvi.model._utils._get_batch_code_from_category", "numpy.arange", "numpy.random.choice", "slice", "numpy.stack", "numpy.concatenate", "numpy.concatenate", "exprs.mean.mean.mean", "pandas.DataFrame", "_multivi.MULTIVI.module.forward", "output.cpu().numpy.cpu().numpy.cpu().numpy", "numpy.stack.append", "numpy.stack.mean", "torch.ones_like", "dict", "dict", "output.cpu().numpy.cpu().numpy.cpu"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_normalized_expression", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples_overall", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "gene_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "use_z_mean", ":", "bool", "=", "True", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_mean", ":", "bool", "=", "True", ",", "\n", "return_numpy", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "r\"\"\"\n        Returns the normalized (decoded) gene expression.\n\n        This is denoted as :math:`\\rho_n` in the scVI paper.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used.\n            - int, then batch transform_batch is used.\n        gene_list\n            Return frequencies of expression for a subset of genes.\n            This can save memory when working with large datasets and few genes are\n            of interest.\n        library_size\n            Scale the expression frequencies to a common library size.\n            This allows gene expression levels to be interpreted on a common scale of relevant\n            magnitude. If set to `\"latent\"`, use the latent libary size.\n        use_z_mean\n            If True, use the mean of the latent distribution, otherwise sample from it\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        return_mean\n            Whether to return the mean of the samples.\n\n        Returns\n        -------\n        If `n_samples` > 1 and `return_mean` is False, then the shape is `(samples, cells, genes)`.\n        Otherwise, shape is `(cells, genes)`. In this case, return type is :class:`~pandas.DataFrame` unless `return_numpy` is True.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "n_samples_overall", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "n_samples_overall", ")", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "transform_batch", "=", "_get_batch_code_from_category", "(", "adata_manager", ",", "transform_batch", ")", "\n", "\n", "if", "gene_list", "is", "None", ":", "\n", "            ", "gene_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_genes", "=", "adata", ".", "var_names", "[", ":", "self", ".", "n_genes", "]", "\n", "gene_mask", "=", "[", "gene", "in", "gene_list", "for", "gene", "in", "all_genes", "]", "\n", "\n", "", "exprs", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "per_batch_exprs", "=", "[", "]", "\n", "for", "batch", "in", "transform_batch", ":", "\n", "                ", "if", "batch", "is", "not", "None", ":", "\n", "                    ", "batch_indices", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "=", "(", "\n", "torch", ".", "ones_like", "(", "batch_indices", ")", "*", "batch", "\n", ")", "\n", "", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", ",", "\n", "generative_kwargs", "=", "dict", "(", "use_z_mean", "=", "use_z_mean", ")", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "output", "=", "generative_outputs", "[", "\"px_scale\"", "]", "\n", "output", "=", "output", "[", "...", ",", "gene_mask", "]", "\n", "output", "=", "output", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "per_batch_exprs", ".", "append", "(", "output", ")", "\n", "", "per_batch_exprs", "=", "np", ".", "stack", "(", "\n", "per_batch_exprs", "\n", ")", "# shape is (len(transform_batch) x batch_size x n_var)", "\n", "exprs", "+=", "[", "per_batch_exprs", ".", "mean", "(", "0", ")", "]", "\n", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "# The -2 axis correspond to cells.", "\n", "            ", "exprs", "=", "np", ".", "concatenate", "(", "exprs", ",", "axis", "=", "-", "2", ")", "\n", "", "else", ":", "\n", "            ", "exprs", "=", "np", ".", "concatenate", "(", "exprs", ",", "axis", "=", "0", ")", "\n", "", "if", "n_samples", ">", "1", "and", "return_mean", ":", "\n", "            ", "exprs", "=", "exprs", ".", "mean", "(", "0", ")", "\n", "\n", "", "if", "return_numpy", ":", "\n", "            ", "return", "exprs", "\n", "", "else", ":", "\n", "            ", "return", "pd", ".", "DataFrame", "(", "\n", "exprs", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", ":", "self", ".", "n_genes", "]", "[", "gene_mask", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.differential_accessibility": [[646, 769], ["scvi._utils._doc_params", "_multivi.MULTIVI._validate_anndata", "functools.partial", "functools.partial", "base._utils._de_core", "pandas.DataFrame", "_multivi.MULTIVI.get_anndata_manager", "numpy.abs", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "", "@", "_doc_params", "(", "doc_differential_expression", "=", "doc_differential_expression", ")", "\n", "def", "differential_accessibility", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "groupby", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "group1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "group2", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "idx1", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", "]", "]", "=", "None", ",", "\n", "idx2", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", "]", "]", "=", "None", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"change\"", ",", "\n", "delta", ":", "float", "=", "0.05", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "all_stats", ":", "bool", "=", "True", ",", "\n", "batch_correction", ":", "bool", "=", "False", ",", "\n", "batchid1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "fdr_target", ":", "float", "=", "0.05", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "two_sided", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential accessibility analysis.\n\n        Implements `\"vanilla\"` DE [Lopez18]_ and `\"change\"` mode DE [Boyeau19]_.\n\n        Parameters\n        ----------\n        {doc_differential_expression}\n        two_sided\n            Whether to perform a two-sided test, or a one-sided test.\n        **kwargs\n            Keyword args for :meth:`scvi.model.base.DifferentialComputation.get_bayes_factors`\n\n        Returns\n        -------\n        Differential accessibility DataFrame with the following columns:\n        prob_da\n            the probability of the region being differentially accessible\n        is_da_fdr\n            whether the region passes a multiple hypothesis correction procedure with the target_fdr\n            threshold\n        bayes_factor\n            Bayes Factor indicating the level of significance of the analysis\n        effect_size\n            the effect size, computed as (accessibility in population 2) - (accessibility in population 1)\n        emp_effect\n            the empirical effect, based on observed detection rates instead of the estimated accessibility\n            scores from the PeakVI model\n        est_prob1\n            the estimated probability of accessibility in population 1\n        est_prob2\n            the estimated probability of accessibility in population 2\n        emp_prob1\n            the empirical (observed) probability of accessibility in population 1\n        emp_prob2\n            the empirical (observed) probability of accessibility in population 2\n\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "col_names", "=", "adata", ".", "var_names", "[", "self", ".", "n_genes", ":", "]", "\n", "model_fn", "=", "partial", "(", "\n", "self", ".", "get_accessibility_estimates", ",", "use_z_mean", "=", "False", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "# TODO check if change_fn in kwargs and raise error if so", "\n", "def", "change_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "return", "a", "-", "b", "\n", "\n", "", "if", "two_sided", ":", "\n", "\n", "            ", "def", "m1_domain_fn", "(", "samples", ")", ":", "\n", "                ", "return", "np", ".", "abs", "(", "samples", ")", ">=", "delta", "\n", "\n", "", "", "else", ":", "\n", "\n", "            ", "def", "m1_domain_fn", "(", "samples", ")", ":", "\n", "                ", "return", "samples", ">=", "delta", "\n", "\n", "", "", "all_stats_fn", "=", "partial", "(", "\n", "scatac_raw_counts_properties", ",", "\n", "var_idx", "=", "np", ".", "arange", "(", "adata", ".", "shape", "[", "1", "]", ")", "[", "self", ".", "n_genes", ":", "]", ",", "\n", ")", "\n", "\n", "result", "=", "_de_core", "(", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "\n", "model_fn", "=", "model_fn", ",", "\n", "groupby", "=", "groupby", ",", "\n", "group1", "=", "group1", ",", "\n", "group2", "=", "group2", ",", "\n", "idx1", "=", "idx1", ",", "\n", "idx2", "=", "idx2", ",", "\n", "all_stats", "=", "all_stats", ",", "\n", "all_stats_fn", "=", "all_stats_fn", ",", "\n", "col_names", "=", "col_names", ",", "\n", "mode", "=", "mode", ",", "\n", "batchid1", "=", "batchid1", ",", "\n", "batchid2", "=", "batchid2", ",", "\n", "delta", "=", "delta", ",", "\n", "batch_correction", "=", "batch_correction", ",", "\n", "fdr", "=", "fdr_target", ",", "\n", "change_fn", "=", "change_fn", ",", "\n", "m1_domain_fn", "=", "m1_domain_fn", ",", "\n", "silent", "=", "silent", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "# manually change the results DataFrame to fit a PeakVI differential accessibility results", "\n", "result", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\n", "\"prob_da\"", ":", "result", ".", "proba_de", ",", "\n", "\"is_da_fdr\"", ":", "result", ".", "loc", "[", ":", ",", "f\"is_de_fdr_{fdr_target}\"", "]", ",", "\n", "\"bayes_factor\"", ":", "result", ".", "bayes_factor", ",", "\n", "\"effect_size\"", ":", "result", ".", "scale2", "-", "result", ".", "scale1", ",", "\n", "\"emp_effect\"", ":", "result", ".", "emp_mean2", "-", "result", ".", "emp_mean1", ",", "\n", "\"est_prob1\"", ":", "result", ".", "scale1", ",", "\n", "\"est_prob2\"", ":", "result", ".", "scale2", ",", "\n", "\"emp_prob1\"", ":", "result", ".", "emp_mean1", ",", "\n", "\"emp_prob2\"", ":", "result", ".", "emp_mean2", ",", "\n", "}", ",", "\n", "index", "=", "col_names", ",", "\n", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.differential_expression": [[770, 838], ["scvi._utils._doc_params", "_multivi.MULTIVI._validate_anndata", "functools.partial", "functools.partial", "base._utils._de_core", "_multivi.MULTIVI.get_anndata_manager", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "@", "_doc_params", "(", "doc_differential_expression", "=", "doc_differential_expression", ")", "\n", "def", "differential_expression", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "groupby", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "group1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "group2", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "idx1", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", "]", "]", "=", "None", ",", "\n", "idx2", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", "]", "]", "=", "None", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"change\"", ",", "\n", "delta", ":", "float", "=", "0.25", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "all_stats", ":", "bool", "=", "True", ",", "\n", "batch_correction", ":", "bool", "=", "False", ",", "\n", "batchid1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "fdr_target", ":", "float", "=", "0.05", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential expression analysis.\n\n        Implements `\"vanilla\"` DE [Lopez18]_ and `\"change\"` mode DE [Boyeau19]_.\n\n        Parameters\n        ----------\n        {doc_differential_expression}\n        **kwargs\n            Keyword args for :meth:`scvi.model.base.DifferentialComputation.get_bayes_factors`\n\n        Returns\n        -------\n        Differential expression DataFrame.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "col_names", "=", "adata", ".", "var_names", "[", ":", "self", ".", "n_genes", "]", "\n", "model_fn", "=", "partial", "(", "\n", "self", ".", "get_normalized_expression", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", ")", "\n", "all_stats_fn", "=", "partial", "(", "\n", "scrna_raw_counts_properties", ",", "\n", "var_idx", "=", "np", ".", "arange", "(", "adata", ".", "shape", "[", "1", "]", ")", "[", ":", "self", ".", "n_genes", "]", ",", "\n", ")", "\n", "result", "=", "_de_core", "(", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "\n", "model_fn", "=", "model_fn", ",", "\n", "groupby", "=", "groupby", ",", "\n", "group1", "=", "group1", ",", "\n", "group2", "=", "group2", ",", "\n", "idx1", "=", "idx1", ",", "\n", "idx2", "=", "idx2", ",", "\n", "all_stats", "=", "all_stats", ",", "\n", "all_stats_fn", "=", "all_stats_fn", ",", "\n", "col_names", "=", "col_names", ",", "\n", "mode", "=", "mode", ",", "\n", "batchid1", "=", "batchid1", ",", "\n", "batchid2", "=", "batchid2", ",", "\n", "delta", "=", "delta", ",", "\n", "batch_correction", "=", "batch_correction", ",", "\n", "fdr", "=", "fdr_target", ",", "\n", "silent", "=", "silent", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._multivi.MULTIVI.setup_anndata": [[839, 881], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.NumericalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "size_factor_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_layer)s\n        %(param_batch_key)s\n        %(param_size_factor_key)s\n        %(param_cat_cov_keys)s\n        %(param_cont_cov_keys)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "NumericalObsField", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", ",", "size_factor_key", ",", "required", "=", "False", "\n", ")", ",", "\n", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "NumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.__init__": [[96, 192], ["base.RNASeqMixin.__init__", "_totalvi.TOTALVI.adata_manager.get_state_registry", "scvi.module.TOTALVAE", "_totalvi.TOTALVI._get_init_params", "warnings.warn", "_totalvi.TOTALVI._get_totalvi_protein_priors", "scvi.model._utils._init_library_size", "locals", "_totalvi.TOTALVI.adata_manager.get_state_registry", "_totalvi.TOTALVI.summary_stats.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._get_totalvi_protein_priors", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_latent", ":", "int", "=", "20", ",", "\n", "gene_dispersion", ":", "Literal", "[", "\n", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "\n", "]", "=", "\"gene\"", ",", "\n", "protein_dispersion", ":", "Literal", "[", "\n", "\"protein\"", ",", "\"protein-batch\"", ",", "\"protein-label\"", "\n", "]", "=", "\"protein\"", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", "]", "=", "\"nb\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "empirical_protein_background_prior", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", "override_missing_proteins", ":", "bool", "=", "False", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "TOTALVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "self", ".", "protein_state_registry", "=", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "\n", ")", "\n", "if", "(", "\n", "fields", ".", "ProteinObsmField", ".", "PROTEIN_BATCH_MASK", "in", "self", ".", "protein_state_registry", "\n", "and", "not", "override_missing_proteins", "\n", ")", ":", "\n", "            ", "batch_mask", "=", "self", ".", "protein_state_registry", ".", "protein_batch_mask", "\n", "msg", "=", "(", "\n", "\"Some proteins have all 0 counts in some batches. \"", "\n", "+", "\"These proteins will be treated as missing measurements; however, \"", "\n", "+", "\"this can occur due to experimental design/biology. \"", "\n", "+", "\"Reinitialize the model with `override_missing_proteins=True`,\"", "\n", "+", "\"to override this behavior.\"", "\n", ")", "\n", "warnings", ".", "warn", "(", "msg", ",", "UserWarning", ")", "\n", "self", ".", "_use_adversarial_classifier", "=", "True", "\n", "", "else", ":", "\n", "            ", "batch_mask", "=", "None", "\n", "self", ".", "_use_adversarial_classifier", "=", "False", "\n", "\n", "", "emp_prior", "=", "(", "\n", "empirical_protein_background_prior", "\n", "if", "empirical_protein_background_prior", "is", "not", "None", "\n", "else", "(", "self", ".", "summary_stats", ".", "n_proteins", ">", "10", ")", "\n", ")", "\n", "if", "emp_prior", ":", "\n", "            ", "prior_mean", ",", "prior_scale", "=", "self", ".", "_get_totalvi_protein_priors", "(", "adata", ")", "\n", "", "else", ":", "\n", "            ", "prior_mean", ",", "prior_scale", "=", "None", ",", "None", "\n", "\n", "", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", "[", "\n", "fields", ".", "CategoricalJointObsField", ".", "N_CATS_PER_KEY", "\n", "]", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", "else", "None", "\n", ")", "\n", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "use_size_factor_key", "=", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", ")", "\n", "library_log_means", ",", "library_log_vars", "=", "None", ",", "None", "\n", "if", "not", "use_size_factor_key", ":", "\n", "            ", "library_log_means", ",", "library_log_vars", "=", "_init_library_size", "(", "\n", "self", ".", "adata_manager", ",", "n_batch", "\n", ")", "\n", "\n", "", "self", ".", "module", "=", "TOTALVAE", "(", "\n", "n_input_genes", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_input_proteins", "=", "self", ".", "summary_stats", ".", "n_proteins", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_continuous_cov", "=", "self", ".", "summary_stats", ".", "get", "(", "\"n_extra_continuous_covs\"", ",", "0", ")", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "gene_dispersion", "=", "gene_dispersion", ",", "\n", "protein_dispersion", "=", "protein_dispersion", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "protein_batch_mask", "=", "batch_mask", ",", "\n", "protein_background_prior_mean", "=", "prior_mean", ",", "\n", "protein_background_prior_scale", "=", "prior_scale", ",", "\n", "use_size_factor_key", "=", "use_size_factor_key", ",", "\n", "library_log_means", "=", "library_log_means", ",", "\n", "library_log_vars", "=", "library_log_vars", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"TotalVI Model with the following params: \\nn_latent: {}, \"", "\n", "\"gene_dispersion: {}, protein_dispersion: {}, gene_likelihood: {}, latent_distribution: {}\"", "\n", ")", ".", "format", "(", "\n", "n_latent", ",", "\n", "gene_dispersion", ",", "\n", "protein_dispersion", ",", "\n", "gene_likelihood", ",", "\n", "latent_distribution", ",", "\n", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.train": [[193, 301], ["scvi.dataloaders.DataSplitter", "scvi.train.AdversarialTrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "int", "plan_kwargs.update", "numpy.min", "isinstance", "dict", "round"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "Optional", "[", "int", "]", "=", "400", ",", "\n", "lr", ":", "float", "=", "4e-3", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "256", ",", "\n", "early_stopping", ":", "bool", "=", "True", ",", "\n", "check_val_every_n_epoch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "reduce_lr_on_plateau", ":", "bool", "=", "True", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "adversarial_classifier", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model using amortized variational inference.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset.\n        lr\n            Learning rate for optimization.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        early_stopping\n            Whether to perform early stopping with respect to the validation set.\n        check_val_every_n_epoch\n            Check val every n train epochs. By default, val is not checked, unless `early_stopping` is `True`\n            or `reduce_lr_on_plateau` is `True`. If either of the latter conditions are met, val is checked\n            every epoch.\n        reduce_lr_on_plateau\n            Reduce learning rate on plateau of validation metric (default is ELBO).\n        n_steps_kl_warmup\n            Number of training steps (minibatches) to scale weight on KL divergences from 0 to 1.\n            Only activated when `n_epochs_kl_warmup` is set to None. If `None`, defaults\n            to `floor(0.75 * adata.n_obs)`.\n        n_epochs_kl_warmup\n            Number of epochs to scale weight on KL divergences from 0 to 1.\n            Overrides `n_steps_kl_warmup` when both are not `None`.\n        adversarial_classifier\n            Whether to use adversarial classifier in the latent space. This helps mixing when\n            there are missing proteins in any of the batches. Defaults to `True` is missing proteins\n            are detected.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.AdversarialTrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "if", "adversarial_classifier", "is", "None", ":", "\n", "            ", "adversarial_classifier", "=", "self", ".", "_use_adversarial_classifier", "\n", "", "n_steps_kl_warmup", "=", "(", "\n", "n_steps_kl_warmup", "\n", "if", "n_steps_kl_warmup", "is", "not", "None", "\n", "else", "int", "(", "0.75", "*", "self", ".", "adata", ".", "n_obs", ")", "\n", ")", "\n", "if", "reduce_lr_on_plateau", ":", "\n", "            ", "check_val_every_n_epoch", "=", "1", "\n", "\n", "", "update_dict", "=", "{", "\n", "\"lr\"", ":", "lr", ",", "\n", "\"adversarial_classifier\"", ":", "adversarial_classifier", ",", "\n", "\"reduce_lr_on_plateau\"", ":", "reduce_lr_on_plateau", ",", "\n", "\"n_epochs_kl_warmup\"", ":", "n_epochs_kl_warmup", ",", "\n", "\"n_steps_kl_warmup\"", ":", "n_steps_kl_warmup", ",", "\n", "}", "\n", "if", "plan_kwargs", "is", "not", "None", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "update_dict", ")", "\n", "", "else", ":", "\n", "            ", "plan_kwargs", "=", "update_dict", "\n", "\n", "", "if", "max_epochs", "is", "None", ":", "\n", "            ", "n_cells", "=", "self", ".", "adata", ".", "n_obs", "\n", "max_epochs", "=", "np", ".", "min", "(", "[", "round", "(", "(", "20000", "/", "n_cells", ")", "*", "400", ")", ",", "400", "]", ")", "\n", "\n", "", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "\n", "data_splitter", "=", "DataSplitter", "(", "\n", "self", ".", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "training_plan", "=", "AdversarialTrainingPlan", "(", "self", ".", "module", ",", "**", "plan_kwargs", ")", "\n", "runner", "=", "TrainRunner", "(", "\n", "self", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "data_splitter", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "early_stopping", "=", "early_stopping", ",", "\n", "check_val_every_n_epoch", "=", "check_val_every_n_epoch", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "return", "runner", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size": [[302, 345], ["torch.no_grad", "_totalvi.TOTALVI._check_if_trained", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI._make_data_loader", "torch.cat().numpy", "_totalvi.TOTALVI.module._get_inference_input", "_totalvi.TOTALVI.module.inference", "torch.exp", "torch.exp.cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_library_size", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "give_mean", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Returns the latent library size for each cell.\n\n        This is denoted as :math:`\\ell_n` in the totalVI paper.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        give_mean\n            Return the mean or a sample from the posterior distribution.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "self", ".", "_check_if_trained", "(", "warn", "=", "False", ")", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "post", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "libraries", "=", "[", "]", "\n", "for", "tensors", "in", "post", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "if", "give_mean", ":", "\n", "                ", "ql", "=", "outputs", "[", "\"ql\"", "]", "\n", "library", "=", "torch", ".", "exp", "(", "ql", ".", "loc", "+", "0.5", "*", "(", "ql", ".", "scale", "**", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "library", "=", "outputs", "[", "\"library_gene\"", "]", "\n", "", "libraries", "+=", "[", "library", ".", "cpu", "(", ")", "]", "\n", "", "return", "torch", ".", "cat", "(", "libraries", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression": [[346, 538], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI.get_anndata_manager", "_totalvi.TOTALVI._make_data_loader", "scvi.model._utils._get_batch_code_from_category", "torch.mean.cpu().numpy", "torch.mean.cpu().numpy", "numpy.arange", "numpy.random.choice", "slice", "scvi.model._utils._get_var_names_from_manager", "slice", "numpy.arange", "isinstance", "len", "len", "torch.mean.append", "torch.mean.append", "torch.cat", "torch.cat", "torch.mean.permute", "torch.mean.permute", "torch.cat", "torch.cat", "torch.mean", "torch.mean", "pandas.DataFrame", "pandas.DataFrame", "warnings.warn", "torch.zeros_like", "torch.zeros_like", "torch.stack", "torch.stack", "dict", "dict", "_totalvi.TOTALVI.module.forward", "torch.mean.cpu", "torch.mean.cpu", "torch.distributions.Bernoulli().sample", "py_[].cpu", "torch.nn.functional.normalize", "[].cpu", "[].cpu", "torch.exp", "py_[].cpu", "scvi.model._utils._get_var_names_from_manager", "torch.distributions.Bernoulli", "py_[].cpu"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_normalized_expression", "(", "\n", "self", ",", "\n", "adata", "=", "None", ",", "\n", "indices", "=", "None", ",", "\n", "n_samples_overall", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "gene_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "protein_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "library_size", ":", "Optional", "[", "Union", "[", "float", ",", "Literal", "[", "\"latent\"", "]", "]", "]", "=", "1", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "sample_protein_mixing", ":", "bool", "=", "False", ",", "\n", "scale_protein", ":", "bool", "=", "False", ",", "\n", "include_protein_background", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_mean", ":", "bool", "=", "True", ",", "\n", "return_numpy", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ",", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Returns the normalized gene expression and protein expression.\n\n        This is denoted as :math:`\\rho_n` in the totalVI paper for genes, and TODO\n        for proteins, :math:`(1-\\pi_{nt})\\alpha_{nt}\\beta_{nt}`.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples_overall\n            Number of samples to use in total\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used\n            - int, then batch transform_batch is used\n            - List[int], then average over batches in list\n        gene_list\n            Return frequencies of expression for a subset of genes.\n            This can save memory when working with large datasets and few genes are\n            of interest.\n        protein_list\n            Return protein expression for a subset of genes.\n            This can save memory when working with large datasets and few genes are\n            of interest.\n        library_size\n            Scale the expression frequencies to a common library size.\n            This allows gene expression levels to be interpreted on a common scale of relevant\n            magnitude.\n        n_samples\n            Get sample scale from multiple samples.\n        sample_protein_mixing\n            Sample mixing bernoulli, setting background to zero\n        scale_protein\n            Make protein expression sum to 1\n        include_protein_background\n            Include background component for protein expression\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        return_mean\n            Whether to return the mean of the samples.\n        return_numpy\n            Return a `np.ndarray` instead of a `pd.DataFrame`. Includes gene\n            names as columns. If either n_samples=1 or return_mean=True, defaults to False.\n            Otherwise, it defaults to True.\n\n        Returns\n        -------\n        - **gene_normalized_expression** - normalized expression for RNA\n        - **protein_normalized_expression** - normalized expression for proteins\n\n        If ``n_samples`` > 1 and ``return_mean`` is False, then the shape is ``(samples, cells, genes)``.\n        Otherwise, shape is ``(cells, genes)``. Return type is ``pd.DataFrame`` unless ``return_numpy`` is True.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "n_samples_overall", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "n_samples_overall", ")", "\n", "", "post", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "if", "gene_list", "is", "None", ":", "\n", "            ", "gene_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_genes", "=", "_get_var_names_from_manager", "(", "adata_manager", ")", "\n", "gene_mask", "=", "[", "True", "if", "gene", "in", "gene_list", "else", "False", "for", "gene", "in", "all_genes", "]", "\n", "", "if", "protein_list", "is", "None", ":", "\n", "            ", "protein_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_proteins", "=", "self", ".", "protein_state_registry", ".", "column_names", "\n", "protein_mask", "=", "[", "True", "if", "p", "in", "protein_list", "else", "False", "for", "p", "in", "all_proteins", "]", "\n", "", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "if", "n_samples", ">", "1", "and", "return_mean", "is", "False", ":", "\n", "            ", "if", "return_numpy", "is", "False", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"return_numpy must be True if n_samples > 1 and return_mean is False, returning np.ndarray\"", "\n", ")", "\n", "", "return_numpy", "=", "True", "\n", "\n", "", "if", "not", "isinstance", "(", "transform_batch", ",", "IterableClass", ")", ":", "\n", "            ", "transform_batch", "=", "[", "transform_batch", "]", "\n", "\n", "", "transform_batch", "=", "_get_batch_code_from_category", "(", "adata_manager", ",", "transform_batch", ")", "\n", "\n", "scale_list_gene", "=", "[", "]", "\n", "scale_list_pro", "=", "[", "]", "\n", "\n", "for", "tensors", "in", "post", ":", "\n", "            ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "]", "\n", "px_scale", "=", "torch", ".", "zeros_like", "(", "x", ")", "[", "...", ",", "gene_mask", "]", "\n", "py_scale", "=", "torch", ".", "zeros_like", "(", "y", ")", "[", "...", ",", "protein_mask", "]", "\n", "if", "n_samples", ">", "1", ":", "\n", "                ", "px_scale", "=", "torch", ".", "stack", "(", "n_samples", "*", "[", "px_scale", "]", ")", "\n", "py_scale", "=", "torch", ".", "stack", "(", "n_samples", "*", "[", "py_scale", "]", ")", "\n", "", "for", "b", "in", "transform_batch", ":", "\n", "                ", "generative_kwargs", "=", "dict", "(", "transform_batch", "=", "b", ")", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "if", "library_size", "==", "\"latent\"", ":", "\n", "                    ", "px_scale", "+=", "generative_outputs", "[", "\"px_\"", "]", "[", "\"rate\"", "]", ".", "cpu", "(", ")", "[", "...", ",", "gene_mask", "]", "\n", "", "else", ":", "\n", "                    ", "px_scale", "+=", "generative_outputs", "[", "\"px_\"", "]", "[", "\"scale\"", "]", ".", "cpu", "(", ")", "[", "...", ",", "gene_mask", "]", "\n", "\n", "", "py_", "=", "generative_outputs", "[", "\"py_\"", "]", "\n", "# probability of background", "\n", "protein_mixing", "=", "1", "/", "(", "1", "+", "torch", ".", "exp", "(", "-", "py_", "[", "\"mixing\"", "]", ".", "cpu", "(", ")", ")", ")", "\n", "if", "sample_protein_mixing", "is", "True", ":", "\n", "                    ", "protein_mixing", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "\n", "protein_mixing", "\n", ")", ".", "sample", "(", ")", "\n", "", "protein_val", "=", "py_", "[", "\"rate_fore\"", "]", ".", "cpu", "(", ")", "*", "(", "1", "-", "protein_mixing", ")", "\n", "if", "include_protein_background", "is", "True", ":", "\n", "                    ", "protein_val", "+=", "py_", "[", "\"rate_back\"", "]", ".", "cpu", "(", ")", "*", "protein_mixing", "\n", "\n", "", "if", "scale_protein", "is", "True", ":", "\n", "                    ", "protein_val", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "\n", "protein_val", ",", "p", "=", "1", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "protein_val", "=", "protein_val", "[", "...", ",", "protein_mask", "]", "\n", "py_scale", "+=", "protein_val", "\n", "", "px_scale", "/=", "len", "(", "transform_batch", ")", "\n", "py_scale", "/=", "len", "(", "transform_batch", ")", "\n", "scale_list_gene", ".", "append", "(", "px_scale", ")", "\n", "scale_list_pro", ".", "append", "(", "py_scale", ")", "\n", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "# concatenate along batch dimension -> result shape = (samples, cells, features)", "\n", "            ", "scale_list_gene", "=", "torch", ".", "cat", "(", "scale_list_gene", ",", "dim", "=", "1", ")", "\n", "scale_list_pro", "=", "torch", ".", "cat", "(", "scale_list_pro", ",", "dim", "=", "1", ")", "\n", "# (cells, features, samples)", "\n", "scale_list_gene", "=", "scale_list_gene", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "scale_list_pro", "=", "scale_list_pro", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "scale_list_gene", "=", "torch", ".", "cat", "(", "scale_list_gene", ",", "dim", "=", "0", ")", "\n", "scale_list_pro", "=", "torch", ".", "cat", "(", "scale_list_pro", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "return_mean", "is", "True", "and", "n_samples", ">", "1", ":", "\n", "            ", "scale_list_gene", "=", "torch", ".", "mean", "(", "scale_list_gene", ",", "dim", "=", "-", "1", ")", "\n", "scale_list_pro", "=", "torch", ".", "mean", "(", "scale_list_pro", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "scale_list_gene", "=", "scale_list_gene", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scale_list_pro", "=", "scale_list_pro", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "return_numpy", "is", "None", "or", "return_numpy", "is", "False", ":", "\n", "            ", "gene_df", "=", "pd", ".", "DataFrame", "(", "\n", "scale_list_gene", ",", "\n", "columns", "=", "_get_var_names_from_manager", "(", "adata_manager", ")", "[", "gene_mask", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n", "protein_names", "=", "self", ".", "protein_state_registry", ".", "column_names", "\n", "pro_df", "=", "pd", ".", "DataFrame", "(", "\n", "scale_list_pro", ",", "\n", "columns", "=", "protein_names", "[", "protein_mask", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n", "\n", "return", "gene_df", ",", "pro_df", "\n", "", "else", ":", "\n", "            ", "return", "scale_list_gene", ",", "scale_list_pro", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability": [[539, 661], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI._make_data_loader", "scvi.model._utils._get_batch_code_from_category", "torch.mean.cpu().numpy", "slice", "numpy.arange", "isinstance", "torch.zeros_like", "len", "torch.cat", "torch.mean.permute", "torch.cat", "torch.mean", "pandas.DataFrame", "warnings.warn", "torch.stack", "dict", "dict", "_totalvi.TOTALVI.module.forward", "[].cpu", "torch.mean.cpu", "torch.sigmoid"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_protein_foreground_probability", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "protein_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "return_mean", ":", "bool", "=", "True", ",", "\n", "return_numpy", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Returns the foreground probability for proteins.\n\n        This is denoted as :math:`(1 - \\pi_{nt})` in the totalVI paper.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used\n            - int, then batch transform_batch is used\n            - List[int], then average over batches in list\n        protein_list\n            Return protein expression for a subset of genes.\n            This can save memory when working with large datasets and few genes are\n            of interest.\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        return_mean\n            Whether to return the mean of the samples.\n        return_numpy\n            Return a :class:`~numpy.ndarray` instead of a :class:`~pandas.DataFrame`. DataFrame includes\n            gene names as columns. If either `n_samples=1` or `return_mean=True`, defaults to `False`.\n            Otherwise, it defaults to `True`.\n\n        Returns\n        -------\n        - **foreground_probability** - probability foreground for each protein\n\n        If `n_samples` > 1 and `return_mean` is False, then the shape is `(samples, cells, genes)`.\n        Otherwise, shape is `(cells, genes)`. In this case, return type is :class:`~pandas.DataFrame` unless `return_numpy` is True.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "post", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "if", "protein_list", "is", "None", ":", "\n", "            ", "protein_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_proteins", "=", "self", ".", "protein_state_registry", ".", "column_names", "\n", "protein_mask", "=", "[", "True", "if", "p", "in", "protein_list", "else", "False", "for", "p", "in", "all_proteins", "]", "\n", "\n", "", "if", "n_samples", ">", "1", "and", "return_mean", "is", "False", ":", "\n", "            ", "if", "return_numpy", "is", "False", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"return_numpy must be True if n_samples > 1 and return_mean is False, returning np.ndarray\"", "\n", ")", "\n", "", "return_numpy", "=", "True", "\n", "", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "py_mixings", "=", "[", "]", "\n", "if", "not", "isinstance", "(", "transform_batch", ",", "IterableClass", ")", ":", "\n", "            ", "transform_batch", "=", "[", "transform_batch", "]", "\n", "\n", "", "transform_batch", "=", "_get_batch_code_from_category", "(", "\n", "self", ".", "adata_manager", ",", "transform_batch", "\n", ")", "\n", "for", "tensors", "in", "post", ":", "\n", "            ", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "]", "\n", "py_mixing", "=", "torch", ".", "zeros_like", "(", "y", "[", "...", ",", "protein_mask", "]", ")", "\n", "if", "n_samples", ">", "1", ":", "\n", "                ", "py_mixing", "=", "torch", ".", "stack", "(", "n_samples", "*", "[", "py_mixing", "]", ")", "\n", "", "for", "b", "in", "transform_batch", ":", "\n", "                ", "generative_kwargs", "=", "dict", "(", "transform_batch", "=", "b", ")", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "_", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "py_mixing", "+=", "torch", ".", "sigmoid", "(", "generative_outputs", "[", "\"py_\"", "]", "[", "\"mixing\"", "]", ")", "[", "\n", "...", ",", "protein_mask", "\n", "]", ".", "cpu", "(", ")", "\n", "", "py_mixing", "/=", "len", "(", "transform_batch", ")", "\n", "py_mixings", "+=", "[", "py_mixing", "]", "\n", "", "if", "n_samples", ">", "1", ":", "\n", "# concatenate along batch dimension -> result shape = (samples, cells, features)", "\n", "            ", "py_mixings", "=", "torch", ".", "cat", "(", "py_mixings", ",", "dim", "=", "1", ")", "\n", "# (cells, features, samples)", "\n", "py_mixings", "=", "py_mixings", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "py_mixings", "=", "torch", ".", "cat", "(", "py_mixings", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "return_mean", "is", "True", "and", "n_samples", ">", "1", ":", "\n", "            ", "py_mixings", "=", "torch", ".", "mean", "(", "py_mixings", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "py_mixings", "=", "py_mixings", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "if", "return_numpy", "is", "True", ":", "\n", "            ", "return", "1", "-", "py_mixings", "\n", "", "else", ":", "\n", "            ", "pro_names", "=", "self", ".", "protein_state_registry", ".", "column_names", "\n", "foreground_prob", "=", "pd", ".", "DataFrame", "(", "\n", "1", "-", "py_mixings", ",", "\n", "columns", "=", "pro_names", "[", "protein_mask", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", ")", "\n", "return", "foreground_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._expression_for_de": [[662, 690], ["_totalvi.TOTALVI.get_normalized_expression", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression"], ["", "", "def", "_expression_for_de", "(", "\n", "self", ",", "\n", "adata", "=", "None", ",", "\n", "indices", "=", "None", ",", "\n", "n_samples_overall", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "scale_protein", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "sample_protein_mixing", "=", "False", ",", "\n", "include_protein_background", "=", "False", ",", "\n", "protein_prior_count", "=", "0.5", ",", "\n", ")", ":", "\n", "        ", "rna", ",", "protein", "=", "self", ".", "get_normalized_expression", "(", "\n", "adata", "=", "adata", ",", "\n", "indices", "=", "indices", ",", "\n", "n_samples_overall", "=", "n_samples_overall", ",", "\n", "transform_batch", "=", "transform_batch", ",", "\n", "return_numpy", "=", "True", ",", "\n", "n_samples", "=", "1", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "scale_protein", "=", "scale_protein", ",", "\n", "sample_protein_mixing", "=", "sample_protein_mixing", ",", "\n", "include_protein_background", "=", "include_protein_background", ",", "\n", ")", "\n", "protein", "+=", "protein_prior_count", "\n", "\n", "joint", "=", "np", ".", "concatenate", "(", "[", "rna", ",", "protein", "]", ",", "axis", "=", "1", ")", "\n", "return", "joint", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression": [[691, 779], ["scvi._utils._doc_params", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI.get_anndata_manager", "functools.partial", "numpy.concatenate", "scvi.model.base._utils._de_core", "numpy.asarray", "scvi.model._utils._get_var_names_from_manager"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager"], ["", "@", "_doc_params", "(", "\n", "doc_differential_expression", "=", "doc_differential_expression", ",", "\n", ")", "\n", "def", "differential_expression", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "groupby", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "group1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "group2", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "idx1", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "idx2", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"change\"", ",", "\n", "delta", ":", "float", "=", "0.25", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "all_stats", ":", "bool", "=", "True", ",", "\n", "batch_correction", ":", "bool", "=", "False", ",", "\n", "batchid1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "fdr_target", ":", "float", "=", "0.05", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "protein_prior_count", ":", "float", "=", "0.1", ",", "\n", "scale_protein", ":", "bool", "=", "False", ",", "\n", "sample_protein_mixing", ":", "bool", "=", "False", ",", "\n", "include_protein_background", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential expression analysis.\n\n        Implements `\"vanilla\"` DE [Lopez18]_ and `\"change\"` mode DE [Boyeau19]_.\n\n        Parameters\n        ----------\n        {doc_differential_expression}\n        protein_prior_count\n            Prior count added to protein expression before LFC computation\n        scale_protein\n            Force protein values to sum to one in every single cell (post-hoc normalization)\n        sample_protein_mixing\n            Sample the protein mixture component, i.e., use the parameter to sample a Bernoulli\n            that determines if expression is from foreground/background.\n        include_protein_background\n            Include the protein background component as part of the protein expression\n        **kwargs\n            Keyword args for :meth:`scvi.model.base.DifferentialComputation.get_bayes_factors`\n\n        Returns\n        -------\n        Differential expression DataFrame.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "model_fn", "=", "partial", "(", "\n", "self", ".", "_expression_for_de", ",", "\n", "scale_protein", "=", "scale_protein", ",", "\n", "sample_protein_mixing", "=", "sample_protein_mixing", ",", "\n", "include_protein_background", "=", "include_protein_background", ",", "\n", "protein_prior_count", "=", "protein_prior_count", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", ")", "\n", "col_names", "=", "np", ".", "concatenate", "(", "\n", "[", "\n", "np", ".", "asarray", "(", "_get_var_names_from_manager", "(", "adata_manager", ")", ")", ",", "\n", "self", ".", "protein_state_registry", ".", "column_names", ",", "\n", "]", "\n", ")", "\n", "result", "=", "_de_core", "(", "\n", "adata_manager", ",", "\n", "model_fn", ",", "\n", "groupby", ",", "\n", "group1", ",", "\n", "group2", ",", "\n", "idx1", ",", "\n", "idx2", ",", "\n", "all_stats", ",", "\n", "cite_seq_raw_counts_properties", ",", "\n", "col_names", ",", "\n", "mode", ",", "\n", "batchid1", ",", "\n", "batchid2", ",", "\n", "delta", ",", "\n", "batch_correction", ",", "\n", "fdr_target", ",", "\n", "silent", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample": [[780, 851], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI.get_anndata_manager", "_totalvi.TOTALVI._make_data_loader", "numpy.concatenate", "ValueError", "slice", "scvi.model._utils._get_var_names_from_manager", "slice", "_totalvi.TOTALVI.module.sample", "torch.cat().numpy", "numpy.transpose", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "posterior_predictive_sample", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "1", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "gene_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "protein_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Generate observation samples from the posterior predictive distribution.\n\n        The posterior predictive distribution is written as :math:`p(\\hat{x}, \\hat{y} \\mid x, y)`.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of required samples for each cell\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        gene_list\n            Names of genes of interest\n        protein_list\n            Names of proteins of interest\n\n        Returns\n        -------\n        x_new : :class:`~numpy.ndarray`\n            tensor with shape (n_cells, n_genes, n_samples)\n        \"\"\"", "\n", "if", "self", ".", "module", ".", "gene_likelihood", "not", "in", "[", "\"nb\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid gene_likelihood\"", ")", "\n", "\n", "", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "if", "gene_list", "is", "None", ":", "\n", "            ", "gene_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_genes", "=", "_get_var_names_from_manager", "(", "adata_manager", ")", "\n", "gene_mask", "=", "[", "True", "if", "gene", "in", "gene_list", "else", "False", "for", "gene", "in", "all_genes", "]", "\n", "", "if", "protein_list", "is", "None", ":", "\n", "            ", "protein_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_proteins", "=", "self", ".", "protein_state_registry", ".", "column_names", "\n", "protein_mask", "=", "[", "True", "if", "p", "in", "protein_list", "else", "False", "for", "p", "in", "all_proteins", "]", "\n", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "scdl_list", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "rna_sample", ",", "protein_sample", "=", "self", ".", "module", ".", "sample", "(", "\n", "tensors", ",", "n_samples", "=", "n_samples", "\n", ")", "\n", "rna_sample", "=", "rna_sample", "[", "...", ",", "gene_mask", "]", "\n", "protein_sample", "=", "protein_sample", "[", "...", ",", "protein_mask", "]", "\n", "data", "=", "torch", ".", "cat", "(", "[", "rna_sample", ",", "protein_sample", "]", ",", "dim", "=", "-", "1", ")", ".", "numpy", "(", ")", "\n", "\n", "scdl_list", "+=", "[", "data", "]", "\n", "if", "n_samples", ">", "1", ":", "\n", "                ", "scdl_list", "[", "-", "1", "]", "=", "np", ".", "transpose", "(", "scdl_list", "[", "-", "1", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "", "scdl_list", "=", "np", ".", "concatenate", "(", "scdl_list", ",", "axis", "=", "0", ")", "\n", "\n", "return", "scdl_list", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._get_denoised_samples": [[852, 933], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI._make_data_loader", "numpy.concatenate", "dict", "dict", "torch.distributions.Bernoulli().sample", "torch.cat", "torch.cat", "torch.distributions.Gamma().sample", "torch.distributions.Gamma().sample.cpu().numpy", "numpy.transpose", "torch.no_grad", "_totalvi.TOTALVI.module.forward", "len", "len", "torch.exp", "torch.distributions.Bernoulli", "px_[].size", "torch.ones_like().to", "py_[].size", "torch.ones_like().to", "torch.distributions.Gamma", "torch.distributions.Gamma().sample.cpu", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_get_denoised_samples", "(", "\n", "self", ",", "\n", "adata", "=", "None", ",", "\n", "indices", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "batch_size", ":", "int", "=", "64", ",", "\n", "rna_size_factor", ":", "int", "=", "1000", ",", "\n", "transform_batch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n        Return samples from an adjusted posterior predictive.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            indices of `adata` to use\n        n_samples\n            How may samples per cell\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        rna_size_factor\n            size factor for RNA prior to sampling gamma distribution\n        transform_batch\n            int of which batch to condition on for all cells\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "scdl_list", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "]", "\n", "\n", "generative_kwargs", "=", "dict", "(", "transform_batch", "=", "transform_batch", ")", "\n", "inference_kwargs", "=", "dict", "(", "n_samples", "=", "n_samples", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "inference_outputs", ",", "generative_outputs", ",", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "", "px_", "=", "generative_outputs", "[", "\"px_\"", "]", "\n", "py_", "=", "generative_outputs", "[", "\"py_\"", "]", "\n", "device", "=", "px_", "[", "\"r\"", "]", ".", "device", "\n", "\n", "pi", "=", "1", "/", "(", "1", "+", "torch", ".", "exp", "(", "-", "py_", "[", "\"mixing\"", "]", ")", ")", "\n", "mixing_sample", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "pi", ")", ".", "sample", "(", ")", "\n", "protein_rate", "=", "py_", "[", "\"rate_fore\"", "]", "\n", "rate", "=", "torch", ".", "cat", "(", "(", "rna_size_factor", "*", "px_", "[", "\"scale\"", "]", ",", "protein_rate", ")", ",", "dim", "=", "-", "1", ")", "\n", "if", "len", "(", "px_", "[", "\"r\"", "]", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "                ", "px_dispersion", "=", "px_", "[", "\"r\"", "]", "\n", "", "else", ":", "\n", "                ", "px_dispersion", "=", "torch", ".", "ones_like", "(", "x", ")", ".", "to", "(", "device", ")", "*", "px_", "[", "\"r\"", "]", "\n", "", "if", "len", "(", "py_", "[", "\"r\"", "]", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "                ", "py_dispersion", "=", "py_", "[", "\"r\"", "]", "\n", "", "else", ":", "\n", "                ", "py_dispersion", "=", "torch", ".", "ones_like", "(", "y", ")", ".", "to", "(", "device", ")", "*", "py_", "[", "\"r\"", "]", "\n", "\n", "", "dispersion", "=", "torch", ".", "cat", "(", "(", "px_dispersion", ",", "py_dispersion", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# This gamma is really l*w using scVI manuscript notation", "\n", "p", "=", "rate", "/", "(", "rate", "+", "dispersion", ")", "\n", "r", "=", "dispersion", "\n", "l_train", "=", "torch", ".", "distributions", ".", "Gamma", "(", "r", ",", "(", "1", "-", "p", ")", "/", "p", ")", ".", "sample", "(", ")", "\n", "data", "=", "l_train", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# make background 0", "\n", "data", "[", ":", ",", ":", ",", "x", ".", "shape", "[", "1", "]", ":", "]", "=", "(", "\n", "data", "[", ":", ",", ":", ",", "x", ".", "shape", "[", "1", "]", ":", "]", "*", "(", "1", "-", "mixing_sample", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", ")", "\n", "scdl_list", "+=", "[", "data", "]", "\n", "\n", "scdl_list", "[", "-", "1", "]", "=", "np", ".", "transpose", "(", "scdl_list", "[", "-", "1", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n", "", "return", "np", ".", "concatenate", "(", "scdl_list", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix": [[934, 1025], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI.get_anndata_manager", "scvi.model._utils._get_batch_code_from_category", "numpy.mean", "scvi.model._utils._get_var_names_from_manager", "numpy.concatenate", "pandas.DataFrame", "isinstance", "_totalvi.TOTALVI.get_anndata_manager", "_totalvi.TOTALVI._get_denoised_samples", "numpy.zeros", "range", "corr_mats.append", "numpy.stack", "numpy.log", "numpy.log1p", "numpy.corrcoef", "spearmanr", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_var_names_from_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._get_denoised_samples"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_feature_correlation_matrix", "(", "\n", "self", ",", "\n", "adata", "=", "None", ",", "\n", "indices", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "10", ",", "\n", "batch_size", ":", "int", "=", "64", ",", "\n", "rna_size_factor", ":", "int", "=", "1000", ",", "\n", "transform_batch", ":", "Optional", "[", "Sequence", "[", "Union", "[", "Number", ",", "str", "]", "]", "]", "=", "None", ",", "\n", "correlation_type", ":", "Literal", "[", "\"spearman\"", ",", "\"pearson\"", "]", "=", "\"spearman\"", ",", "\n", "log_transform", ":", "bool", "=", "False", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "\"\"\"\n        Generate gene-gene correlation matrix using scvi uncertainty and expression.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of posterior samples to use for estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        rna_size_factor\n            size factor for RNA prior to sampling gamma distribution\n        transform_batch\n            Batches to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used\n            - int, then batch transform_batch is used\n            - list of int, then values are averaged over provided batches.\n        correlation_type\n            One of \"pearson\", \"spearman\".\n        log_transform\n            Whether to log transform denoised values prior to correlation calculation.\n\n        Returns\n        -------\n        Gene-protein-gene-protein correlation matrix\n        \"\"\"", "\n", "from", "scipy", ".", "stats", "import", "spearmanr", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "\n", "if", "not", "isinstance", "(", "transform_batch", ",", "IterableClass", ")", ":", "\n", "            ", "transform_batch", "=", "[", "transform_batch", "]", "\n", "\n", "", "transform_batch", "=", "_get_batch_code_from_category", "(", "\n", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "transform_batch", "\n", ")", "\n", "\n", "corr_mats", "=", "[", "]", "\n", "for", "b", "in", "transform_batch", ":", "\n", "            ", "denoised_data", "=", "self", ".", "_get_denoised_samples", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "rna_size_factor", "=", "rna_size_factor", ",", "\n", "transform_batch", "=", "b", ",", "\n", ")", "\n", "flattened", "=", "np", ".", "zeros", "(", "\n", "(", "denoised_data", ".", "shape", "[", "0", "]", "*", "n_samples", ",", "denoised_data", ".", "shape", "[", "1", "]", ")", "\n", ")", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "                ", "flattened", "[", "\n", "denoised_data", ".", "shape", "[", "0", "]", "*", "(", "i", ")", ":", "denoised_data", ".", "shape", "[", "0", "]", "*", "(", "i", "+", "1", ")", "\n", "]", "=", "denoised_data", "[", ":", ",", ":", ",", "i", "]", "\n", "", "if", "log_transform", "is", "True", ":", "\n", "                ", "flattened", "[", ":", ",", ":", "self", ".", "n_genes", "]", "=", "np", ".", "log", "(", "\n", "flattened", "[", ":", ",", ":", "self", ".", "n_genes", "]", "+", "1e-8", "\n", ")", "\n", "flattened", "[", ":", ",", "self", ".", "n_genes", ":", "]", "=", "np", ".", "log1p", "(", "flattened", "[", ":", ",", "self", ".", "n_genes", ":", "]", ")", "\n", "", "if", "correlation_type", "==", "\"pearson\"", ":", "\n", "                ", "corr_matrix", "=", "np", ".", "corrcoef", "(", "flattened", ",", "rowvar", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "corr_matrix", ",", "_", "=", "spearmanr", "(", "flattened", ",", "axis", "=", "0", ")", "\n", "", "corr_mats", ".", "append", "(", "corr_matrix", ")", "\n", "\n", "", "corr_matrix", "=", "np", ".", "mean", "(", "np", ".", "stack", "(", "corr_mats", ")", ",", "axis", "=", "0", ")", "\n", "var_names", "=", "_get_var_names_from_manager", "(", "adata_manager", ")", "\n", "names", "=", "np", ".", "concatenate", "(", "\n", "[", "\n", "np", ".", "asarray", "(", "var_names", ")", ",", "\n", "self", ".", "protein_state_registry", ".", "column_names", ",", "\n", "]", "\n", ")", "\n", "return", "pd", ".", "DataFrame", "(", "corr_matrix", ",", "index", "=", "names", ",", "columns", "=", "names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters": [[1026, 1053], ["torch.no_grad"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_likelihood_parameters", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "Optional", "[", "int", "]", "=", "1", ",", "\n", "give_mean", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "r\"\"\"\n        Estimates for the parameters of the likelihood :math:`p(x, y \\mid z)`.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples\n            Number of posterior samples to use for estimation.\n        give_mean\n            Return expected value of parameters or a samples\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata": [[1054, 1072], ["super()._validate_anndata", "_totalvi.TOTALVI.adata_manager.data_registry.keys", "_totalvi.TOTALVI.get_from_registry", "scvi.data._utils._check_nonnegative_integers", "ValueError", "ValueError", "warnings.warn", "error_msg.format"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_nonnegative_integers"], ["", "def", "_validate_anndata", "(", "\n", "self", ",", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "copy_if_view", ":", "bool", "=", "True", "\n", ")", ":", "\n", "        ", "adata", "=", "super", "(", ")", ".", "_validate_anndata", "(", "adata", "=", "adata", ",", "copy_if_view", "=", "copy_if_view", ")", "\n", "error_msg", "=", "\"Number of {} in anndata different from when setup_anndata was run. Please rerun setup_anndata.\"", "\n", "if", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", ".", "keys", "(", ")", ":", "\n", "            ", "pro_exp", "=", "self", ".", "get_from_registry", "(", "adata", ",", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", "\n", "if", "self", ".", "summary_stats", ".", "n_proteins", "!=", "pro_exp", ".", "shape", "[", "1", "]", ":", "\n", "                ", "raise", "ValueError", "(", "error_msg", ".", "format", "(", "\"proteins\"", ")", ")", "\n", "", "is_nonneg_int", "=", "_check_nonnegative_integers", "(", "pro_exp", ")", "\n", "if", "not", "is_nonneg_int", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Make sure the registered protein expression in anndata contains unnormalized count data.\"", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"No protein data found, please setup or transfer anndata\"", ")", "\n", "\n", "", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._get_totalvi_protein_priors": [[1073, 1169], ["warnings.catch_warnings", "warnings.filterwarnings", "logger.info", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI.get_anndata_manager", "_totalvi.TOTALVI.get_from_registry", "_totalvi.TOTALVI.get_state_registry().get", "_totalvi.TOTALVI.get_from_registry().ravel", "numpy.arange", "numpy.unique", "numpy.array().reshape", "numpy.array().reshape", "numpy.tile", "numpy.tile", "isinstance", "_totalvi.TOTALVI.get_from_registry.to_numpy", "_totalvi.TOTALVI.get_state_registry", "len", "numpy.sum", "numpy.random.choice", "GaussianMixture", "numpy.mean", "numpy.sqrt", "numpy.tile.append", "numpy.tile.append", "_totalvi.TOTALVI.get_state_registry", "_totalvi.TOTALVI.get_from_registry", "numpy.tile.append", "numpy.tile.append", "numpy.tile.append", "numpy.tile.append", "numpy.arange", "GaussianMixture.means_.ravel", "numpy.argsort", "numpy.sqrt", "mus.append", "scales.append", "numpy.array", "numpy.array", "logger.debug", "numpy.tile.append", "numpy.tile.append", "GaussianMixture.fit", "means[].ravel", "GaussianMixture.covariances_[].ravel", "numpy.sum", "numpy.log1p", "mus.append", "scales.append", "numpy.square", "c.reshape"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit"], ["", "def", "_get_totalvi_protein_priors", "(", "self", ",", "adata", ",", "n_cells", "=", "100", ")", ":", "\n", "        ", "\"\"\"Compute an empirical prior for protein background.\"\"\"", "\n", "\n", "from", "sklearn", ".", "exceptions", "import", "ConvergenceWarning", "\n", "from", "sklearn", ".", "mixture", "import", "GaussianMixture", "\n", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "filterwarnings", "(", "\"error\"", ")", "\n", "logger", ".", "info", "(", "\n", "\"Computing empirical prior initialization for protein background.\"", "\n", ")", "\n", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ")", "\n", "pro_exp", "=", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", "\n", "pro_exp", "=", "(", "\n", "pro_exp", ".", "to_numpy", "(", ")", "if", "isinstance", "(", "pro_exp", ",", "pd", ".", "DataFrame", ")", "else", "pro_exp", "\n", ")", "\n", "batch_mask", "=", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", "\n", ")", ".", "get", "(", "fields", ".", "ProteinObsmField", ".", "PROTEIN_BATCH_MASK", ")", "\n", "batch", "=", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ".", "ravel", "(", ")", "\n", "cats", "=", "adata_manager", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", "[", "\n", "fields", ".", "CategoricalObsField", ".", "CATEGORICAL_MAPPING_KEY", "\n", "]", "\n", "codes", "=", "np", ".", "arange", "(", "len", "(", "cats", ")", ")", "\n", "\n", "batch_avg_mus", ",", "batch_avg_scales", "=", "[", "]", ",", "[", "]", "\n", "for", "b", "in", "np", ".", "unique", "(", "codes", ")", ":", "\n", "# can happen during online updates", "\n", "# the values of these batches will not be used", "\n", "                ", "num_in_batch", "=", "np", ".", "sum", "(", "batch", "==", "b", ")", "\n", "if", "num_in_batch", "==", "0", ":", "\n", "                    ", "batch_avg_mus", ".", "append", "(", "0", ")", "\n", "batch_avg_scales", ".", "append", "(", "1", ")", "\n", "continue", "\n", "", "batch_pro_exp", "=", "pro_exp", "[", "batch", "==", "b", "]", "\n", "\n", "# non missing", "\n", "if", "batch_mask", "is", "not", "None", ":", "\n", "                    ", "batch_pro_exp", "=", "batch_pro_exp", "[", ":", ",", "batch_mask", "[", "b", "]", "]", "\n", "if", "batch_pro_exp", ".", "shape", "[", "1", "]", "<", "5", ":", "\n", "                        ", "logger", ".", "debug", "(", "\n", "f\"Batch {b} has too few proteins to set prior, setting randomly.\"", "\n", ")", "\n", "batch_avg_mus", ".", "append", "(", "0.0", ")", "\n", "batch_avg_scales", ".", "append", "(", "0.05", ")", "\n", "continue", "\n", "\n", "# a batch is missing because it's in the reference but not query data", "\n", "# for scarches case, these values will be replaced by original state dict", "\n", "", "", "if", "batch_pro_exp", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                    ", "batch_avg_mus", ".", "append", "(", "0.0", ")", "\n", "batch_avg_scales", ".", "append", "(", "0.05", ")", "\n", "continue", "\n", "\n", "", "cells", "=", "np", ".", "random", ".", "choice", "(", "\n", "np", ".", "arange", "(", "batch_pro_exp", ".", "shape", "[", "0", "]", ")", ",", "size", "=", "n_cells", "\n", ")", "\n", "batch_pro_exp", "=", "batch_pro_exp", "[", "cells", "]", "\n", "gmm", "=", "GaussianMixture", "(", "n_components", "=", "2", ")", "\n", "mus", ",", "scales", "=", "[", "]", ",", "[", "]", "\n", "# fit per cell GMM", "\n", "for", "c", "in", "batch_pro_exp", ":", "\n", "                    ", "try", ":", "\n", "                        ", "gmm", ".", "fit", "(", "np", ".", "log1p", "(", "c", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ")", "\n", "# when cell is all 0", "\n", "", "except", "ConvergenceWarning", ":", "\n", "                        ", "mus", ".", "append", "(", "0", ")", "\n", "scales", ".", "append", "(", "0.05", ")", "\n", "continue", "\n", "\n", "", "means", "=", "gmm", ".", "means_", ".", "ravel", "(", ")", "\n", "sorted_fg_bg", "=", "np", ".", "argsort", "(", "means", ")", "\n", "mu", "=", "means", "[", "sorted_fg_bg", "]", ".", "ravel", "(", ")", "[", "0", "]", "\n", "covariances", "=", "gmm", ".", "covariances_", "[", "sorted_fg_bg", "]", ".", "ravel", "(", ")", "[", "0", "]", "\n", "scale", "=", "np", ".", "sqrt", "(", "covariances", ")", "\n", "mus", ".", "append", "(", "mu", ")", "\n", "scales", ".", "append", "(", "scale", ")", "\n", "\n", "# average distribution over cells", "\n", "", "batch_avg_mu", "=", "np", ".", "mean", "(", "mus", ")", "\n", "batch_avg_scale", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "scales", ")", ")", "/", "(", "n_cells", "**", "2", ")", ")", "\n", "\n", "batch_avg_mus", ".", "append", "(", "batch_avg_mu", ")", "\n", "batch_avg_scales", ".", "append", "(", "batch_avg_scale", ")", "\n", "\n", "# repeat prior for each protein", "\n", "", "batch_avg_mus", "=", "np", ".", "array", "(", "batch_avg_mus", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "batch_avg_scales", "=", "np", ".", "array", "(", "batch_avg_scales", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "\n", "1", ",", "-", "1", "\n", ")", "\n", "batch_avg_mus", "=", "np", ".", "tile", "(", "batch_avg_mus", ",", "(", "pro_exp", ".", "shape", "[", "1", "]", ",", "1", ")", ")", "\n", "batch_avg_scales", "=", "np", ".", "tile", "(", "batch_avg_scales", ",", "(", "pro_exp", ".", "shape", "[", "1", "]", ",", "1", ")", ")", "\n", "\n", "", "return", "batch_avg_mus", ",", "batch_avg_scales", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_background_mean": [[1170, 1182], ["torch.no_grad", "_totalvi.TOTALVI._validate_anndata", "_totalvi.TOTALVI._make_data_loader", "numpy.concatenate", "_totalvi.TOTALVI.module.forward", "b_mean.cpu().numpy", "b_mean.cpu"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_protein_background_mean", "(", "self", ",", "adata", ",", "indices", ",", "batch_size", ")", ":", "\n", "        ", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "background_mean", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "_", ",", "inference_outputs", ",", "_", "=", "self", ".", "module", ".", "forward", "(", "tensors", ")", "\n", "b_mean", "=", "inference_outputs", "[", "\"py_\"", "]", "[", "\"rate_back\"", "]", "\n", "background_mean", "+=", "[", "b_mean", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", "\n", "", "return", "np", ".", "concatenate", "(", "background_mean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_anndata": [[1183, 1250], ["cls._get_setup_method_args", "scvi.CategoricalObsField", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.LayerField", "scvi.CategoricalObsField", "scvi.NumericalObsField", "scvi.CategoricalJointObsField", "scvi.NumericalJointObsField", "scvi.ProteinObsmField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "protein_expression_obsm_key", ":", "str", ",", "\n", "protein_names_uns_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "size_factor_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Optional", "[", "AnnData", "]", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_adata)s\n        protein_expression_obsm_key\n            key in `adata.obsm` for protein expression data.\n        protein_names_uns_key\n            key in `adata.uns` for protein names. If None, will use the column names of `adata.obsm[protein_expression_obsm_key]`\n            if it is a DataFrame, else will assign sequential names to proteins.\n        %(param_batch_key)s\n        %(param_layer)s\n        %(param_size_factor_key)s\n        %(param_cat_cov_keys)s\n        %(param_cont_cov_keys)s\n        %(param_copy)s\n\n        Returns\n        -------\n        %(returns)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "batch_field", "=", "fields", ".", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", "\n", "anndata_fields", "=", "[", "\n", "fields", ".", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "fields", ".", "CategoricalObsField", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "None", "\n", ")", ",", "# Default labels field for compatibility with TOTALVAE", "\n", "batch_field", ",", "\n", "fields", ".", "NumericalObsField", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", ",", "size_factor_key", ",", "required", "=", "False", "\n", ")", ",", "\n", "fields", ".", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "fields", ".", "NumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", "\n", ")", ",", "\n", "fields", ".", "ProteinObsmField", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ",", "\n", "protein_expression_obsm_key", ",", "\n", "use_batch_mask", "=", "True", ",", "\n", "batch_field", "=", "batch_field", ",", "\n", "colnames_uns_key", "=", "protein_names_uns_key", ",", "\n", "is_count_data", "=", "True", ",", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata": [[1251, 1320], ["cls._get_setup_method_args", "cls._create_modalities_attr_dict", "scvi.MuDataCategoricalObsField", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "ValueError", "scvi.MuDataLayerField", "scvi.MuDataCategoricalObsField", "scvi.MuDataNumericalObsField", "scvi.MuDataCategoricalJointObsField", "scvi.MuDataNumericalJointObsField", "scvi.MuDataProteinLayerField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._create_modalities_attr_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "def", "setup_mudata", "(", "\n", "cls", ",", "\n", "mdata", ":", "MuData", ",", "\n", "rna_layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "protein_layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "size_factor_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "modalities", ":", "Optional", "[", "Dict", "[", "str", ",", "str", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Optional", "[", "AnnData", "]", ":", "\n", "        ", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "\n", "if", "modalities", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Modalities cannot be None.\"", ")", "\n", "", "modalities", "=", "cls", ".", "_create_modalities_attr_dict", "(", "modalities", ",", "setup_method_args", ")", "\n", "\n", "batch_field", "=", "fields", ".", "MuDataCategoricalObsField", "(", "\n", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "\n", "batch_key", ",", "\n", "mod_key", "=", "modalities", ".", "batch_key", ",", "\n", ")", "\n", "mudata_fields", "=", "[", "\n", "fields", ".", "MuDataLayerField", "(", "\n", "REGISTRY_KEYS", ".", "X_KEY", ",", "\n", "rna_layer", ",", "\n", "mod_key", "=", "modalities", ".", "rna_layer", ",", "\n", "is_count_data", "=", "True", ",", "\n", "mod_required", "=", "True", ",", "\n", ")", ",", "\n", "fields", ".", "MuDataCategoricalObsField", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "\n", "None", ",", "\n", "mod_key", "=", "None", ",", "\n", ")", ",", "# Default labels field for compatibility with TOTALVAE", "\n", "batch_field", ",", "\n", "fields", ".", "MuDataNumericalObsField", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", ",", "\n", "size_factor_key", ",", "\n", "mod_key", "=", "modalities", ".", "size_factor_key", ",", "\n", "required", "=", "False", ",", "\n", ")", ",", "\n", "fields", ".", "MuDataCategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "\n", "categorical_covariate_keys", ",", "\n", "mod_key", "=", "modalities", ".", "categorical_covariate_keys", ",", "\n", ")", ",", "\n", "fields", ".", "MuDataNumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "\n", "continuous_covariate_keys", ",", "\n", "mod_key", "=", "modalities", ".", "continuous_covariate_keys", ",", "\n", ")", ",", "\n", "fields", ".", "MuDataProteinLayerField", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ",", "\n", "protein_layer", ",", "\n", "mod_key", "=", "modalities", ".", "protein_layer", ",", "\n", "use_batch_mask", "=", "True", ",", "\n", "batch_field", "=", "batch_field", ",", "\n", "is_count_data", "=", "True", ",", "\n", "mod_required", "=", "True", ",", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "mudata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "mdata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.__init__": [[94, 154], ["base.VAEMixin.__init__", "scvi.model._utils._init_library_size", "scvi.module.AutoZIVAE", "_autozi.AUTOZI._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "Literal", "[", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "]", "=", "\"gene\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "alpha_prior", ":", "Optional", "[", "float", "]", "=", "0.5", ",", "\n", "beta_prior", ":", "Optional", "[", "float", "]", "=", "0.5", ",", "\n", "minimal_dropout", ":", "float", "=", "0.01", ",", "\n", "zero_inflation", ":", "str", "=", "\"gene\"", ",", "\n", "use_observed_lib_size", ":", "bool", "=", "True", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "AUTOZI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "self", ".", "use_observed_lib_size", "=", "use_observed_lib_size", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "library_log_means", ",", "library_log_vars", "=", "_init_library_size", "(", "\n", "self", ".", "adata_manager", ",", "n_batch", "\n", ")", "\n", "\n", "self", ".", "module", "=", "AutoZIVAE", "(", "\n", "n_input", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_labels", "=", "self", ".", "summary_stats", ".", "n_labels", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "zero_inflation", "=", "zero_inflation", ",", "\n", "alpha_prior", "=", "alpha_prior", ",", "\n", "beta_prior", "=", "beta_prior", ",", "\n", "minimal_dropout", "=", "minimal_dropout", ",", "\n", "use_observed_lib_size", "=", "use_observed_lib_size", ",", "\n", "library_log_means", "=", "library_log_means", ",", "\n", "library_log_vars", "=", "library_log_vars", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "model_summary_string", "=", "(", "\n", "\"AutoZI Model with the following params: \\nn_hidden: {}, n_latent: {}, \"", "\n", "\"n_layers: {}, dropout_rate: {}, dispersion: {}, latent_distribution: \"", "\n", "\"{}, alpha_prior: {}, beta_prior: {}, minimal_dropout: {}, zero_inflation:{}\"", "\n", ")", ".", "format", "(", "\n", "n_hidden", ",", "\n", "n_latent", ",", "\n", "n_layers", ",", "\n", "dropout_rate", ",", "\n", "dispersion", ",", "\n", "latent_distribution", ",", "\n", "alpha_prior", ",", "\n", "beta_prior", ",", "\n", "minimal_dropout", ",", "\n", "zero_inflation", ",", "\n", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas": [[155, 160], ["_autozi.AUTOZI.module.get_alphas_betas"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas"], ["", "def", "get_alphas_betas", "(", "\n", "self", ",", "as_numpy", ":", "bool", "=", "True", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "torch", ".", "Tensor", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "        ", "\"\"\"Return parameters of Bernoulli Beta distributions in a dictionary.\"\"\"", "\n", "return", "self", ".", "module", ".", "get_alphas_betas", "(", "as_numpy", "=", "as_numpy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll": [[161, 267], ["torch.no_grad", "_autozi.AUTOZI._validate_anndata", "_autozi.AUTOZI._make_data_loader", "torch.zeros().to", "_autozi.AUTOZI.module.get_alphas_betas", "range", "len", "numpy.arange", "_autozi.AUTOZI.module.sample_from_beta_distribution", "torch.distributions.Beta().log_prob().sum", "torch.distributions.Beta().log_prob().sum", "torch.logsumexp().item", "numpy.log", "torch.zeros", "tensors[].to", "tensors[].to", "tensors[].to", "_autozi.AUTOZI.module.forward", "_autozi.AUTOZI.module.reshape_bernoulli", "_autozi.AUTOZI.module.get_reconstruction_loss", "gen_outputs[].log_prob().sum", "qz.log_prob().sum", "torch.sum", "_autozi.AUTOZI.module._compute_local_library_params", "gen_outputs[].log_prob().sum", "ql.log_prob().sum", "torch.distributions.Beta().log_prob", "torch.distributions.Beta().log_prob", "torch.logsumexp", "gen_outputs[].log_prob", "qz.log_prob", "gen_outputs[].log_prob", "ql.log_prob", "torch.distributions.Beta", "torch.distributions.Beta"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.sample_from_beta_distribution", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.module._autozivae.AutoZIVAE.reshape_bernoulli", "home.repos.pwc.inspect_result.YosefLab_scVI.module._totalvae.TOTALVAE.get_reconstruction_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.module._vae.VAE._compute_local_library_params", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_marginal_ll", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "Sequence", "[", "int", "]", "]", "=", "None", ",", "\n", "n_mc_samples", ":", "int", "=", "1000", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n        Return the marginal LL for the data.\n\n        The computation here is a biased estimator of the marginal log likelihood of the data.\n        Note, this is not the negative log likelihood, higher is better.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_mc_samples\n            Number of Monte Carlo samples to use for marginal LL estimation.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "log_lkl", "=", "0", "\n", "to_sum", "=", "torch", ".", "zeros", "(", "(", "n_mc_samples", ",", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "alphas_betas", "=", "self", ".", "module", ".", "get_alphas_betas", "(", "as_numpy", "=", "False", ")", "\n", "alpha_prior", "=", "alphas_betas", "[", "\"alpha_prior\"", "]", "\n", "alpha_posterior", "=", "alphas_betas", "[", "\"alpha_posterior\"", "]", "\n", "beta_prior", "=", "alphas_betas", "[", "\"beta_prior\"", "]", "\n", "beta_posterior", "=", "alphas_betas", "[", "\"beta_posterior\"", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_mc_samples", ")", ":", "\n", "            ", "bernoulli_params", "=", "self", ".", "module", ".", "sample_from_beta_distribution", "(", "\n", "alpha_posterior", ",", "beta_posterior", "\n", ")", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "sample_batch", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# Distribution parameters and sampled variables", "\n", "inf_outputs", ",", "gen_outputs", ",", "_", "=", "self", ".", "module", ".", "forward", "(", "tensors", ")", "\n", "\n", "px", "=", "gen_outputs", "[", "\"px\"", "]", "\n", "px_r", "=", "px", ".", "theta", "\n", "px_rate", "=", "px", ".", "mu", "\n", "px_dropout", "=", "px", ".", "zi_logits", "\n", "qz", "=", "inf_outputs", "[", "\"qz\"", "]", "\n", "z", "=", "inf_outputs", "[", "\"z\"", "]", "\n", "\n", "# Reconstruction Loss", "\n", "bernoulli_params_batch", "=", "self", ".", "module", ".", "reshape_bernoulli", "(", "\n", "bernoulli_params", ",", "\n", "batch_index", ",", "\n", "labels", ",", "\n", ")", "\n", "reconst_loss", "=", "self", ".", "module", ".", "get_reconstruction_loss", "(", "\n", "sample_batch", ",", "\n", "px_rate", ",", "\n", "px_r", ",", "\n", "px_dropout", ",", "\n", "bernoulli_params_batch", ",", "\n", ")", "\n", "\n", "# Log-probabilities", "\n", "p_z", "=", "gen_outputs", "[", "\"pz\"", "]", ".", "log_prob", "(", "z", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "p_x_zld", "=", "-", "reconst_loss", "\n", "q_z_x", "=", "qz", ".", "log_prob", "(", "z", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "log_prob_sum", "=", "p_z", "+", "p_x_zld", "-", "q_z_x", "\n", "\n", "if", "not", "self", ".", "use_observed_lib_size", ":", "\n", "                    ", "ql", "=", "inf_outputs", "[", "\"ql\"", "]", "\n", "library", "=", "inf_outputs", "[", "\"library\"", "]", "\n", "(", "\n", "local_library_log_means", ",", "\n", "local_library_log_vars", ",", "\n", ")", "=", "self", ".", "module", ".", "_compute_local_library_params", "(", "batch_index", ")", "\n", "\n", "p_l", "=", "gen_outputs", "[", "\"pl\"", "]", ".", "log_prob", "(", "library", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "q_l_x", "=", "ql", ".", "log_prob", "(", "library", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "log_prob_sum", "+=", "p_l", "-", "q_l_x", "\n", "\n", "", "batch_log_lkl", "=", "torch", ".", "sum", "(", "log_prob_sum", ",", "dim", "=", "0", ")", "\n", "to_sum", "[", "i", "]", "+=", "batch_log_lkl", "\n", "\n", "", "p_d", "=", "Beta", "(", "alpha_prior", ",", "beta_prior", ")", ".", "log_prob", "(", "bernoulli_params", ")", ".", "sum", "(", ")", "\n", "q_d", "=", "Beta", "(", "alpha_posterior", ",", "beta_posterior", ")", ".", "log_prob", "(", "bernoulli_params", ")", ".", "sum", "(", ")", "\n", "\n", "to_sum", "[", "i", "]", "+=", "p_d", "-", "q_d", "\n", "\n", "", "log_lkl", "=", "logsumexp", "(", "to_sum", ",", "dim", "=", "-", "1", ")", ".", "item", "(", ")", "-", "np", ".", "log", "(", "n_mc_samples", ")", "\n", "n_samples", "=", "len", "(", "scdl", ".", "indices", ")", "\n", "return", "log_lkl", "/", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.setup_anndata": [[268, 298], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_layer)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scvi.SCVI.__init__": [[84, 146], ["base.RNASeqMixin.__init__", "scvi.module.VAE", "_scvi.SCVI._get_init_params", "scvi.model._utils._init_library_size", "locals", "_scvi.SCVI.adata_manager.get_state_registry", "_scvi.SCVI.summary_stats.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "Literal", "[", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "]", "=", "\"gene\"", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "SCVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", ")", ".", "n_cats_per_key", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", "else", "None", "\n", ")", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", "\n", "use_size_factor_key", "=", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", ")", "\n", "library_log_means", ",", "library_log_vars", "=", "None", ",", "None", "\n", "if", "not", "use_size_factor_key", ":", "\n", "            ", "library_log_means", ",", "library_log_vars", "=", "_init_library_size", "(", "\n", "self", ".", "adata_manager", ",", "n_batch", "\n", ")", "\n", "\n", "", "self", ".", "module", "=", "VAE", "(", "\n", "n_input", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "n_batch", ",", "\n", "n_labels", "=", "self", ".", "summary_stats", ".", "n_labels", ",", "\n", "n_continuous_cov", "=", "self", ".", "summary_stats", ".", "get", "(", "\"n_extra_continuous_covs\"", ",", "0", ")", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "dispersion", "=", "dispersion", ",", "\n", "gene_likelihood", "=", "gene_likelihood", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "use_size_factor_key", "=", "use_size_factor_key", ",", "\n", "library_log_means", "=", "library_log_means", ",", "\n", "library_log_vars", "=", "library_log_vars", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"SCVI Model with the following params: \\nn_hidden: {}, n_latent: {}, n_layers: {}, dropout_rate: \"", "\n", "\"{}, dispersion: {}, gene_likelihood: {}, latent_distribution: {}\"", "\n", ")", ".", "format", "(", "\n", "n_hidden", ",", "\n", "n_latent", ",", "\n", "n_layers", ",", "\n", "dropout_rate", ",", "\n", "dispersion", ",", "\n", "gene_likelihood", ",", "\n", "latent_distribution", ",", "\n", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._scvi.SCVI.setup_anndata": [[147, 192], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.NumericalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "size_factor_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_layer)s\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_size_factor_key)s\n        %(param_cat_cov_keys)s\n        %(param_cont_cov_keys)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "NumericalObsField", "(", "\n", "REGISTRY_KEYS", ".", "SIZE_FACTOR_KEY", ",", "size_factor_key", ",", "required", "=", "False", "\n", ")", ",", "\n", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "NumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.__init__": [[55, 93], ["scvi.model.base.RNASeqMixin.__init__", "scvi.module.VAEC", "_condscvi.CondSCVI._get_init_params", "module_kwargs.update", "locals", "numpy.unique", "numpy.sum", "numpy.sum", "_condscvi.CondSCVI.get_from_registry"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "5", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "weight_obs", ":", "bool", "=", "False", ",", "\n", "dropout_rate", ":", "float", "=", "0.05", ",", "\n", "**", "module_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "CondSCVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_labels", "=", "self", ".", "summary_stats", ".", "n_labels", "\n", "n_vars", "=", "self", ".", "summary_stats", ".", "n_vars", "\n", "if", "weight_obs", ":", "\n", "            ", "ct_counts", "=", "np", ".", "unique", "(", "\n", "self", ".", "get_from_registry", "(", "adata", ",", "REGISTRY_KEYS", ".", "LABELS_KEY", ")", ",", "\n", "return_counts", "=", "True", ",", "\n", ")", "[", "1", "]", "\n", "ct_prop", "=", "ct_counts", "/", "np", ".", "sum", "(", "ct_counts", ")", "\n", "ct_prop", "[", "ct_prop", "<", "0.05", "]", "=", "0.05", "\n", "ct_prop", "=", "ct_prop", "/", "np", ".", "sum", "(", "ct_prop", ")", "\n", "ct_weight", "=", "1.0", "/", "ct_prop", "\n", "module_kwargs", ".", "update", "(", "{", "\"ct_weight\"", ":", "ct_weight", "}", ")", "\n", "\n", "", "self", ".", "module", "=", "VAEC", "(", "\n", "n_input", "=", "n_vars", ",", "\n", "n_labels", "=", "n_labels", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "**", "module_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"Conditional SCVI Model with the following params: \\nn_hidden: {}, n_latent: {}, n_layers: {}, dropout_rate: {}, weight_obs: {}\"", "\n", ")", ".", "format", "(", "n_hidden", ",", "n_latent", ",", "n_layers", ",", "dropout_rate", ",", "weight_obs", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.get_vamp_prior": [[94, 195], ["torch.no_grad", "_condscvi.CondSCVI._validate_anndata", "numpy.zeros", "numpy.ones", "numpy.zeros", "_condscvi.CondSCVI.adata_manager.get_state_registry", "_condscvi.CondSCVI._make_data_loader", "range", "warnings.warn", "_condscvi.CondSCVI.module.inference", "torch.cat().numpy", "torch.cat().numpy", "len", "numpy.unique", "len", "numpy.ones", "numpy.zeros_like", "enumerate", "slice", "mean_.cpu", "var_.cpu", "numpy.where", "ValueError", "numpy.mean", "sum", "torch.cat", "torch.cat", "sklearn.cluster.KMeans().fit_predict", "numpy.arange", "numpy.mean", "numpy.var", "sklearn.cluster.KMeans", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_vamp_prior", "(", "\n", "self", ",", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "p", ":", "int", "=", "10", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "r\"\"\"\n        Return an empirical prior over the cell-type specific latent space (vamp prior) that may be used for deconvolution.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        p\n            number of clusters in kmeans clustering for cell-type sub-clustering for empirical prior\n\n        Returns\n        -------\n        mean_vprior: np.ndarray\n            (n_labels, p, D) array\n        var_vprior\n            (n_labels, p, D) array\n        \"\"\"", "\n", "if", "self", ".", "is_trained_", "is", "False", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Trying to query inferred values from an untrained model. Please train the model first.\"", "\n", ")", "\n", "\n", "", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "\n", "# Extracting latent representation of adata including variances.", "\n", "mean_vprior", "=", "np", ".", "zeros", "(", "(", "self", ".", "summary_stats", ".", "n_labels", ",", "p", ",", "self", ".", "module", ".", "n_latent", ")", ")", "\n", "var_vprior", "=", "np", ".", "ones", "(", "(", "self", ".", "summary_stats", ".", "n_labels", ",", "p", ",", "self", ".", "module", ".", "n_latent", ")", ")", "\n", "mp_vprior", "=", "np", ".", "zeros", "(", "(", "self", ".", "summary_stats", ".", "n_labels", ",", "p", ")", ")", "\n", "\n", "labels_state_registry", "=", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", "\n", ")", "\n", "key", "=", "labels_state_registry", ".", "original_key", "\n", "mapping", "=", "labels_state_registry", ".", "categorical_mapping", "\n", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "adata", "=", "adata", ",", "batch_size", "=", "p", ")", "\n", "\n", "mean", "=", "[", "]", "\n", "var", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "out", "=", "self", ".", "module", ".", "inference", "(", "x", ",", "y", ")", "\n", "mean_", ",", "var_", "=", "out", "[", "\"qz\"", "]", ".", "loc", ",", "(", "out", "[", "\"qz\"", "]", ".", "scale", "**", "2", ")", "\n", "mean", "+=", "[", "mean_", ".", "cpu", "(", ")", "]", "\n", "var", "+=", "[", "var_", ".", "cpu", "(", ")", "]", "\n", "\n", "", "mean_cat", ",", "var_cat", "=", "torch", ".", "cat", "(", "mean", ")", ".", "numpy", "(", ")", ",", "torch", ".", "cat", "(", "var", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "ct", "in", "range", "(", "self", ".", "summary_stats", "[", "\"n_labels\"", "]", ")", ":", "\n", "            ", "local_indices", "=", "np", ".", "where", "(", "adata", ".", "obs", "[", "key", "]", "==", "mapping", "[", "ct", "]", ")", "[", "0", "]", "\n", "n_local_indices", "=", "len", "(", "local_indices", ")", "\n", "if", "\"overclustering_vamp\"", "not", "in", "adata", ".", "obs", ".", "columns", ":", "\n", "                ", "if", "p", "<", "n_local_indices", "and", "p", ">", "0", ":", "\n", "                    ", "overclustering_vamp", "=", "KMeans", "(", "n_clusters", "=", "p", ",", "n_init", "=", "30", ")", ".", "fit_predict", "(", "\n", "mean_cat", "[", "local_indices", "]", "\n", ")", "\n", "", "else", ":", "\n", "# Every cell is its own cluster", "\n", "                    ", "overclustering_vamp", "=", "np", ".", "arange", "(", "n_local_indices", ")", "\n", "", "", "else", ":", "\n", "                ", "overclustering_vamp", "=", "adata", "[", "local_indices", ",", ":", "]", ".", "obs", "[", "\"overclustering_vamp\"", "]", "\n", "\n", "", "keys", ",", "counts", "=", "np", ".", "unique", "(", "overclustering_vamp", ",", "return_counts", "=", "True", ")", "\n", "\n", "n_labels_overclustering", "=", "len", "(", "keys", ")", "\n", "if", "n_labels_overclustering", ">", "p", ":", "\n", "                ", "error_mess", "=", "\"\"\"\n                    Given cell type specific clustering contains more clusters than vamp_prior_p.\n                    Increase value of vamp_prior_p to largest number of cell type specific clusters.\"\"\"", "\n", "\n", "raise", "ValueError", "(", "error_mess", ")", "\n", "\n", "", "var_cluster", "=", "np", ".", "ones", "(", "\n", "[", "\n", "n_labels_overclustering", ",", "\n", "self", ".", "module", ".", "n_latent", ",", "\n", "]", "\n", ")", "\n", "mean_cluster", "=", "np", ".", "zeros_like", "(", "var_cluster", ")", "\n", "\n", "for", "index", ",", "cluster", "in", "enumerate", "(", "keys", ")", ":", "\n", "                ", "indices_curr", "=", "local_indices", "[", "\n", "np", ".", "where", "(", "overclustering_vamp", "==", "cluster", ")", "[", "0", "]", "\n", "]", "\n", "var_cluster", "[", "index", ",", ":", "]", "=", "np", ".", "mean", "(", "var_cat", "[", "indices_curr", "]", ",", "axis", "=", "0", ")", "+", "np", ".", "var", "(", "\n", "mean_cat", "[", "indices_curr", "]", ",", "axis", "=", "0", "\n", ")", "\n", "mean_cluster", "[", "index", ",", ":", "]", "=", "np", ".", "mean", "(", "mean_cat", "[", "indices_curr", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "slicing", "=", "slice", "(", "n_labels_overclustering", ")", "\n", "mean_vprior", "[", "ct", ",", "slicing", ",", ":", "]", "=", "mean_cluster", "\n", "var_vprior", "[", "ct", ",", "slicing", ",", ":", "]", "=", "var_cluster", "\n", "mp_vprior", "[", "ct", ",", "slicing", "]", "=", "counts", "/", "sum", "(", "counts", ")", "\n", "\n", "", "return", "mean_vprior", ",", "var_vprior", ",", "mp_vprior", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.train": [[196, 247], ["super().train", "plan_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "300", ",", "\n", "lr", ":", "float", "=", "0.001", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "1", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model using MAP inference.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of epochs to train for\n        lr\n            Learning rate for optimization.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.TrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "update_dict", "=", "{", "\n", "\"lr\"", ":", "lr", ",", "\n", "}", "\n", "if", "plan_kwargs", "is", "not", "None", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "update_dict", ")", "\n", "", "else", ":", "\n", "            ", "plan_kwargs", "=", "update_dict", "\n", "", "super", "(", ")", ".", "train", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "plan_kwargs", "=", "plan_kwargs", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.setup_anndata": [[249, 276], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_labels_key)s\n        %(param_layer)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.__init__": [[85, 147], ["base.ArchesMixin.__init__", "scvi.module.PEAKVAE", "_peakvi.PEAKVI._get_init_params", "locals", "_peakvi.PEAKVI.adata_manager.get_state_registry", "_peakvi.PEAKVI.summary_stats.get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_latent", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_layers_encoder", ":", "int", "=", "2", ",", "\n", "n_layers_decoder", ":", "int", "=", "2", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "model_depth", ":", "bool", "=", "True", ",", "\n", "region_factors", ":", "bool", "=", "True", ",", "\n", "use_batch_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"none\"", ",", "\n", "use_layer_norm", ":", "Literal", "[", "\"encoder\"", ",", "\"decoder\"", ",", "\"none\"", ",", "\"both\"", "]", "=", "\"both\"", ",", "\n", "latent_distribution", ":", "Literal", "[", "\"normal\"", ",", "\"ln\"", "]", "=", "\"normal\"", ",", "\n", "deeply_inject_covariates", ":", "bool", "=", "False", ",", "\n", "encode_covariates", ":", "bool", "=", "False", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PEAKVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "\n", ")", ".", "n_cats_per_key", "\n", "if", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", "in", "self", ".", "adata_manager", ".", "data_registry", "\n", "else", "[", "]", "\n", ")", "\n", "\n", "self", ".", "module", "=", "PEAKVAE", "(", "\n", "n_input_regions", "=", "self", ".", "summary_stats", ".", "n_vars", ",", "\n", "n_batch", "=", "self", ".", "summary_stats", ".", "n_batch", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers_encoder", "=", "n_layers_encoder", ",", "\n", "n_layers_decoder", "=", "n_layers_decoder", ",", "\n", "n_continuous_cov", "=", "self", ".", "summary_stats", ".", "get", "(", "\"n_extra_continuous_covs\"", ",", "0", ")", ",", "\n", "n_cats_per_cov", "=", "n_cats_per_cov", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "\n", "model_depth", "=", "model_depth", ",", "\n", "region_factors", "=", "region_factors", ",", "\n", "use_batch_norm", "=", "use_batch_norm", ",", "\n", "use_layer_norm", "=", "use_layer_norm", ",", "\n", "latent_distribution", "=", "latent_distribution", ",", "\n", "deeply_inject_covariates", "=", "deeply_inject_covariates", ",", "\n", "encode_covariates", "=", "encode_covariates", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"PeakVI Model with params: \\nn_hidden: {}, n_latent: {}, n_layers_encoder: {}, \"", "\n", "\"n_layers_decoder: {} , dropout_rate: {}, latent_distribution: {}, deep injection: {}, \"", "\n", "\"encode_covariates: {}\"", "\n", ")", ".", "format", "(", "\n", "self", ".", "module", ".", "n_hidden", ",", "\n", "self", ".", "module", ".", "n_latent", ",", "\n", "n_layers_encoder", ",", "\n", "n_layers_decoder", ",", "\n", "dropout_rate", ",", "\n", "latent_distribution", ",", "\n", "deeply_inject_covariates", ",", "\n", "encode_covariates", ",", "\n", ")", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.train": [[148, 244], ["dict", "super().train", "plan_kwargs.update", "kwargs[].append", "kwargs.keys", "scvi.train._callbacks.SaveBestState"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "500", ",", "\n", "lr", ":", "float", "=", "1e-4", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "weight_decay", ":", "float", "=", "1e-3", ",", "\n", "eps", ":", "float", "=", "1e-08", ",", "\n", "early_stopping", ":", "bool", "=", "True", ",", "\n", "early_stopping_patience", ":", "int", "=", "50", ",", "\n", "save_best", ":", "bool", "=", "True", ",", "\n", "check_val_every_n_epoch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "50", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model using amortized variational inference.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset.\n        lr\n            Learning rate for optimization.\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        weight_decay\n            weight decay regularization term for optimization\n        eps\n            Optimizer eps\n        early_stopping\n            Whether to perform early stopping with respect to the validation set.\n        early_stopping_patience\n            How many epochs to wait for improvement before early stopping\n        save_best\n            Save the best model state with respect to the validation loss (default), or use the final\n            state in the training procedure\n        check_val_every_n_epoch\n            Check val every n train epochs. By default, val is not checked, unless `early_stopping` is `True`.\n            If so, val is checked every epoch.\n        n_steps_kl_warmup\n            Number of training steps (minibatches) to scale weight on KL divergences from 0 to 1.\n            Only activated when `n_epochs_kl_warmup` is set to None. If `None`, defaults\n            to `floor(0.75 * adata.n_obs)`.\n        n_epochs_kl_warmup\n            Number of epochs to scale weight on KL divergences from 0 to 1.\n            Overrides `n_steps_kl_warmup` when both are not `None`.\n        plan_kwargs\n            Keyword args for :class:`~scvi.train.TrainingPlan`. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "update_dict", "=", "dict", "(", "\n", "lr", "=", "lr", ",", "\n", "weight_decay", "=", "weight_decay", ",", "\n", "eps", "=", "eps", ",", "\n", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", ",", "\n", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", ",", "\n", "optimizer", "=", "\"AdamW\"", ",", "\n", ")", "\n", "if", "plan_kwargs", "is", "not", "None", ":", "\n", "            ", "plan_kwargs", ".", "update", "(", "update_dict", ")", "\n", "", "else", ":", "\n", "            ", "plan_kwargs", "=", "update_dict", "\n", "", "if", "save_best", ":", "\n", "            ", "if", "\"callbacks\"", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                ", "kwargs", "[", "\"callbacks\"", "]", "=", "[", "]", "\n", "", "kwargs", "[", "\"callbacks\"", "]", ".", "append", "(", "\n", "SaveBestState", "(", "monitor", "=", "\"reconstruction_loss_validation\"", ")", "\n", ")", "\n", "\n", "", "super", "(", ")", ".", "train", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "train_size", "=", "train_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "early_stopping", "=", "early_stopping", ",", "\n", "early_stopping_monitor", "=", "\"reconstruction_loss_validation\"", ",", "\n", "early_stopping_patience", "=", "early_stopping_patience", ",", "\n", "plan_kwargs", "=", "plan_kwargs", ",", "\n", "check_val_every_n_epoch", "=", "check_val_every_n_epoch", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_library_size_factors": [[246, 282], ["torch.no_grad", "_peakvi.PEAKVI._validate_anndata", "_peakvi.PEAKVI._make_data_loader", "torch.cat().numpy().squeeze", "_peakvi.PEAKVI.module._get_inference_input", "_peakvi.PEAKVI.module.inference", "library_sizes.append", "outputs[].cpu", "torch.cat().numpy", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_library_size_factors", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return library size factors.\n\n        Parameters\n        ----------\n        adata\n            AnnData object with equivalent structure to initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        batch_size\n            Minibatch size for data loading into model. Defaults to `scvi.settings.batch_size`.\n\n        Returns\n        -------\n        Library size factor for expression and accessibility\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "scdl", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "library_sizes", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "library_sizes", ".", "append", "(", "outputs", "[", "\"d\"", "]", ".", "cpu", "(", ")", ")", "\n", "\n", "", "return", "torch", ".", "cat", "(", "library_sizes", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_region_factors": [[283, 289], ["torch.no_grad", "torch.sigmoid().cpu().numpy", "RuntimeError", "torch.sigmoid().cpu", "torch.sigmoid"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_region_factors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return region-specific factors.\"\"\"", "\n", "if", "self", ".", "module", ".", "region_factors", "is", "None", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"region factors were not included in this model\"", ")", "\n", "", "return", "torch", ".", "sigmoid", "(", "self", ".", "module", ".", "region_factors", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates": [[290, 410], ["torch.no_grad", "_peakvi.PEAKVI._validate_anndata", "_peakvi.PEAKVI.get_anndata_manager", "_peakvi.PEAKVI._make_data_loader", "scvi.model._utils._get_batch_code_from_category", "numpy.arange", "numpy.random.choice", "slice", "ValueError", "dict", "dict", "_peakvi.PEAKVI.module.forward", "generative_outputs[].cpu", "torch.cat().numpy.append", "scipy.sparse.vstack", "torch.cat().numpy", "inference_outputs[].cpu", "torch.sigmoid().cpu", "scipy.sparse.csr_matrix", "pandas.DataFrame.sparse.from_spmatrix", "pandas.DataFrame", "scipy.sparse.csr_matrix.numpy", "torch.cat", "torch.sigmoid"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._get_batch_code_from_category", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_accessibility_estimates", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "indices", ":", "Sequence", "[", "int", "]", "=", "None", ",", "\n", "n_samples_overall", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "region_list", ":", "Optional", "[", "Sequence", "[", "str", "]", "]", "=", "None", ",", "\n", "transform_batch", ":", "Optional", "[", "Union", "[", "str", ",", "int", "]", "]", "=", "None", ",", "\n", "use_z_mean", ":", "bool", "=", "True", ",", "\n", "threshold", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "normalize_cells", ":", "bool", "=", "False", ",", "\n", "normalize_regions", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "return_numpy", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "pd", ".", "DataFrame", ",", "np", ".", "ndarray", ",", "csr_matrix", "]", ":", "\n", "        ", "\"\"\"\n        Impute the full accessibility matrix.\n\n        Returns a matrix of accessibility probabilities for each cell and genomic region in the input\n        (for return matrix A, A[i,j] is the probability that region j is accessible in cell i).\n\n        Parameters\n        ----------\n        adata\n            AnnData object that has been registered with scvi. If `None`, defaults to the\n            AnnData object used to initialize the model.\n        indices\n            Indices of cells in adata to use. If `None`, all cells are used.\n        n_samples_overall\n            Number of samples to return in total\n        region_list\n            Return accessibility estimates for this subset of regions. if `None`, all regions are used.\n            This can save memory when dealing with large datasets.\n        transform_batch\n            Batch to condition on.\n            If transform_batch is:\n\n            - None, then real observed batch is used\n            - int, then batch transform_batch is used\n        use_z_mean\n            If True (default), use the distribution mean. Otherwise, sample from the distribution.\n        threshold\n            If provided, values below the threshold are replaced with 0 and a sparse matrix\n            is returned instead. This is recommended for very large matrices. Must be between 0 and 1.\n        normalize_cells\n            Whether to reintroduce library size factors to scale the normalized probabilities.\n            This makes the estimates closer to the input, but removes the library size correction.\n            False by default.\n        normalize_regions\n            Whether to reintroduce region factors to scale the normalized probabilities. This makes\n            the estimates closer to the input, but removes the region-level bias correction. False by\n            default.\n        batch_size\n            Minibatch size for data loading into model\n        return_numpy\n            If `True` and `threshold=None`, return :class:`~numpy.ndarray`. If `True` and `threshold` is\n            given, return :class:`~scipy.sparse.csr_matrix`. If `False`, return :class:`~pandas.DataFrame`.\n            DataFrame includes regions names as columns.\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "", "if", "n_samples_overall", "is", "not", "None", ":", "\n", "            ", "indices", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "n_samples_overall", ")", "\n", "", "post", "=", "self", ".", "_make_data_loader", "(", "\n", "adata", "=", "adata", ",", "indices", "=", "indices", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "transform_batch", "=", "_get_batch_code_from_category", "(", "adata_manager", ",", "transform_batch", ")", "\n", "\n", "if", "region_list", "is", "None", ":", "\n", "            ", "region_mask", "=", "slice", "(", "None", ")", "\n", "", "else", ":", "\n", "            ", "all_regions", "=", "adata", ".", "var_names", "\n", "region_mask", "=", "[", "region", "in", "region_list", "for", "region", "in", "all_regions", "]", "\n", "\n", "", "if", "threshold", "is", "not", "None", "and", "(", "threshold", "<", "0", "or", "threshold", ">", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"the provided threshold must be between 0 and 1\"", ")", "\n", "\n", "", "imputed", "=", "[", "]", "\n", "for", "tensors", "in", "post", ":", "\n", "            ", "get_generative_input_kwargs", "=", "dict", "(", "transform_batch", "=", "transform_batch", "[", "0", "]", ")", "\n", "generative_kwargs", "=", "dict", "(", "use_z_mean", "=", "use_z_mean", ")", "\n", "inference_outputs", ",", "generative_outputs", "=", "self", ".", "module", ".", "forward", "(", "\n", "tensors", "=", "tensors", ",", "\n", "get_generative_input_kwargs", "=", "get_generative_input_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", "compute_loss", "=", "False", ",", "\n", ")", "\n", "p", "=", "generative_outputs", "[", "\"p\"", "]", ".", "cpu", "(", ")", "\n", "\n", "if", "normalize_cells", ":", "\n", "                ", "p", "*=", "inference_outputs", "[", "\"d\"", "]", ".", "cpu", "(", ")", "\n", "", "if", "normalize_regions", ":", "\n", "                ", "p", "*=", "torch", ".", "sigmoid", "(", "self", ".", "module", ".", "region_factors", ")", ".", "cpu", "(", ")", "\n", "", "if", "threshold", ":", "\n", "                ", "p", "[", "p", "<", "threshold", "]", "=", "0", "\n", "p", "=", "csr_matrix", "(", "p", ".", "numpy", "(", ")", ")", "\n", "", "if", "region_list", "is", "not", "None", ":", "\n", "                ", "p", "=", "p", "[", ":", ",", "region_mask", "]", "\n", "", "imputed", ".", "append", "(", "p", ")", "\n", "\n", "", "if", "threshold", ":", "# imputed is a list of csr_matrix objects", "\n", "            ", "imputed", "=", "vstack", "(", "imputed", ",", "format", "=", "\"csr\"", ")", "\n", "", "else", ":", "# imputed is a list of tensors", "\n", "            ", "imputed", "=", "torch", ".", "cat", "(", "imputed", ")", ".", "numpy", "(", ")", "\n", "\n", "", "if", "return_numpy", ":", "\n", "            ", "return", "imputed", "\n", "", "elif", "threshold", ":", "\n", "            ", "return", "pd", ".", "DataFrame", ".", "sparse", ".", "from_spmatrix", "(", "\n", "imputed", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", "region_mask", "]", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "pd", ".", "DataFrame", "(", "\n", "imputed", ",", "\n", "index", "=", "adata", ".", "obs_names", "[", "indices", "]", ",", "\n", "columns", "=", "adata", ".", "var_names", "[", "region_mask", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.differential_accessibility": [[412, 531], ["scvi._utils._doc_params", "_peakvi.PEAKVI._validate_anndata", "functools.partial", "base._utils._de_core", "pandas.DataFrame", "_peakvi.PEAKVI.get_anndata_manager", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.scvi._utils._doc_params", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._de_core", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager"], ["", "", "@", "_doc_params", "(", "\n", "doc_differential_expression", "=", "doc_differential_expression", ",", "\n", ")", "\n", "def", "differential_accessibility", "(", "\n", "self", ",", "\n", "adata", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "groupby", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "group1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "group2", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "idx1", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "idx2", ":", "Optional", "[", "Union", "[", "Sequence", "[", "int", "]", ",", "Sequence", "[", "bool", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "mode", ":", "Literal", "[", "\"vanilla\"", ",", "\"change\"", "]", "=", "\"change\"", ",", "\n", "delta", ":", "float", "=", "0.05", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "all_stats", ":", "bool", "=", "True", ",", "\n", "batch_correction", ":", "bool", "=", "False", ",", "\n", "batchid1", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "batchid2", ":", "Optional", "[", "Iterable", "[", "str", "]", "]", "=", "None", ",", "\n", "fdr_target", ":", "float", "=", "0.05", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "two_sided", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "pd", ".", "DataFrame", ":", "\n", "        ", "r\"\"\"\n        A unified method for differential accessibility analysis.\n\n        Implements `\"vanilla\"` DE [Lopez18]_ and `\"change\"` mode DE [Boyeau19]_.\n\n        Parameters\n        ----------\n        {doc_differential_expression}\n        two_sided\n            Whether to perform a two-sided test, or a one-sided test.\n        **kwargs\n            Keyword args for :meth:`scvi.model.base.DifferentialComputation.get_bayes_factors`\n\n        Returns\n        -------\n        Differential accessibility DataFrame with the following columns:\n        prob_da\n            the probability of the region being differentially accessible\n        is_da_fdr\n            whether the region passes a multiple hypothesis correction procedure with the target_fdr\n            threshold\n        bayes_factor\n            Bayes Factor indicating the level of significance of the analysis\n        effect_size\n            the effect size, computed as (accessibility in population 2) - (accessibility in population 1)\n        emp_effect\n            the empirical effect, based on observed detection rates instead of the estimated accessibility\n            scores from the PeakVI model\n        est_prob1\n            the estimated probability of accessibility in population 1\n        est_prob2\n            the estimated probability of accessibility in population 2\n        emp_prob1\n            the empirical (observed) probability of accessibility in population 1\n        emp_prob2\n            the empirical (observed) probability of accessibility in population 2\n\n        \"\"\"", "\n", "adata", "=", "self", ".", "_validate_anndata", "(", "adata", ")", "\n", "col_names", "=", "adata", ".", "var_names", "\n", "model_fn", "=", "partial", "(", "\n", "self", ".", "get_accessibility_estimates", ",", "use_z_mean", "=", "False", ",", "batch_size", "=", "batch_size", "\n", ")", "\n", "\n", "# TODO check if change_fn in kwargs and raise error if so", "\n", "def", "change_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "return", "a", "-", "b", "\n", "\n", "", "if", "two_sided", ":", "\n", "\n", "            ", "def", "m1_domain_fn", "(", "samples", ")", ":", "\n", "                ", "return", "np", ".", "abs", "(", "samples", ")", ">=", "delta", "\n", "\n", "", "", "else", ":", "\n", "\n", "            ", "def", "m1_domain_fn", "(", "samples", ")", ":", "\n", "                ", "return", "samples", ">=", "delta", "\n", "\n", "", "", "result", "=", "_de_core", "(", "\n", "adata_manager", "=", "self", ".", "get_anndata_manager", "(", "adata", ",", "required", "=", "True", ")", ",", "\n", "model_fn", "=", "model_fn", ",", "\n", "groupby", "=", "groupby", ",", "\n", "group1", "=", "group1", ",", "\n", "group2", "=", "group2", ",", "\n", "idx1", "=", "idx1", ",", "\n", "idx2", "=", "idx2", ",", "\n", "all_stats", "=", "all_stats", ",", "\n", "all_stats_fn", "=", "scatac_raw_counts_properties", ",", "\n", "col_names", "=", "col_names", ",", "\n", "mode", "=", "mode", ",", "\n", "batchid1", "=", "batchid1", ",", "\n", "batchid2", "=", "batchid2", ",", "\n", "delta", "=", "delta", ",", "\n", "batch_correction", "=", "batch_correction", ",", "\n", "fdr", "=", "fdr_target", ",", "\n", "change_fn", "=", "change_fn", ",", "\n", "m1_domain_fn", "=", "m1_domain_fn", ",", "\n", "silent", "=", "silent", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "# manually change the results DataFrame to fit a PeakVI differential accessibility results", "\n", "result", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\n", "\"prob_da\"", ":", "result", ".", "proba_de", ",", "\n", "\"is_da_fdr\"", ":", "result", ".", "loc", "[", ":", ",", "\"is_de_fdr_{}\"", ".", "format", "(", "fdr_target", ")", "]", ",", "\n", "\"bayes_factor\"", ":", "result", ".", "bayes_factor", ",", "\n", "\"effect_size\"", ":", "result", ".", "scale2", "-", "result", ".", "scale1", ",", "\n", "\"emp_effect\"", ":", "result", ".", "emp_mean2", "-", "result", ".", "emp_mean1", ",", "\n", "\"est_prob1\"", ":", "result", ".", "scale1", ",", "\n", "\"est_prob2\"", ":", "result", ".", "scale2", ",", "\n", "\"emp_prob1\"", ":", "result", ".", "emp_mean1", ",", "\n", "\"emp_prob2\"", ":", "result", ".", "emp_mean2", ",", "\n", "}", ",", "\n", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.setup_anndata": [[532, 572], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_layer)s\n        %(param_cat_cov_keys)s\n        %(param_cont_cov_keys)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "NumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_cellassign.test_cellassign": [[8, 24], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.sum", "scvi.external.CellAssign.setup_anndata", "pandas.DataFrame", "pd.DataFrame.index.map", "scvi.external.CellAssign", "scvi.external.CellAssign.train", "scvi.external.CellAssign.predict", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict"], ["def", "test_cellassign", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", "\n", "n_labels", "=", "5", ",", "\n", ")", "\n", "adata", ".", "obs", "[", "\"size_factor\"", "]", "=", "adata", ".", "X", ".", "sum", "(", "1", ")", "\n", "CellAssign", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "\"size_factor\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "marker_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "np", ".", "random", ".", "randint", "(", "2", ",", "size", "=", "(", "100", ",", "5", ")", ")", ")", "\n", "marker_df", ".", "index", "=", "marker_df", ".", "index", ".", "map", "(", "str", ")", "\n", "\n", "model", "=", "CellAssign", "(", "adata", ",", "marker_df", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model", ".", "predict", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_stereoscope.test_stereoscope": [[7, 40], ["scvi.data.synthetic_iid", "scvi.external.RNAStereoscope.setup_anndata", "scvi.external.RNAStereoscope", "RNAStereoscope.load.train", "scvi.external.RNAStereoscope", "RNAStereoscope.load.train", "RNAStereoscope.load.save", "scvi.external.RNAStereoscope.load", "scvi.external.SpatialStereoscope.from_rna_model", "SpatialStereoscope.load.train", "SpatialStereoscope.load.get_proportions", "SpatialStereoscope.load.save", "scvi.external.SpatialStereoscope.load", "SpatialStereoscope.load.get_proportions", "numpy.array", "SpatialStereoscope.load.get_scale_for_ct", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.from_rna_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_scale_for_ct"], ["def", "test_stereoscope", "(", "save_path", ")", ":", "\n", "    ", "dataset", "=", "synthetic_iid", "(", "\n", "n_labels", "=", "5", ",", "\n", ")", "\n", "RNAStereoscope", ".", "setup_anndata", "(", "\n", "dataset", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "\n", "# train with no proportions", "\n", "sc_model", "=", "RNAStereoscope", "(", "dataset", ")", "\n", "sc_model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "\n", "# train again with proportions", "\n", "sc_model", "=", "RNAStereoscope", "(", "dataset", ",", "ct_weights", "=", "np", ".", "ones", "(", "(", "5", ",", ")", ")", ")", "\n", "sc_model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "# test save/load", "\n", "sc_model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ")", "\n", "sc_model", "=", "RNAStereoscope", ".", "load", "(", "save_path", ")", "\n", "\n", "st_model", "=", "SpatialStereoscope", ".", "from_rna_model", "(", "\n", "dataset", ",", "sc_model", ",", "prior_weight", "=", "\"minibatch\"", "\n", ")", "\n", "st_model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "st_model", ".", "get_proportions", "(", ")", "\n", "# test save/load", "\n", "st_model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ")", "\n", "st_model", "=", "SpatialStereoscope", ".", "load", "(", "save_path", ")", "\n", "st_model", ".", "get_proportions", "(", ")", "\n", "\n", "# try imputation code", "\n", "y", "=", "np", ".", "array", "(", "50", "*", "[", "\"label_0\"", "]", ")", "\n", "st_model", ".", "get_scale_for_ct", "(", "y", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_gimvi.test_saving_and_loading": [[13, 121], ["scvi.data.synthetic_iid", "scvi.external.GIMVI.setup_anndata", "scvi.data.synthetic_iid", "scvi.external.GIMVI.setup_anndata", "scvi.external.GIMVI", "GIMVI.load.train", "GIMVI.load.get_latent_representation", "GIMVI.load.get_latent_representation", "numpy.testing.assert_array_equal", "GIMVI.load.save", "scvi.external.GIMVI.load", "GIMVI.load.get_latent_representation", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "scvi.external.GIMVI.load", "GIMVI.load.get_latent_representation", "numpy.testing.assert_array_equal", "scvi.external.GIMVI.load", "GIMVI.load.get_latent_representation", "numpy.testing.assert_almost_equal", "os.path.join", "test_gimvi.test_saving_and_loading.legacy_save"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["def", "test_saving_and_loading", "(", "save_path", ")", ":", "\n", "    ", "def", "legacy_save", "(", "\n", "model", ",", "\n", "dir_path", ",", "\n", "prefix", "=", "None", ",", "\n", "overwrite", "=", "False", ",", "\n", "save_anndata", "=", "False", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", ":", "\n", "# get all the user attributes", "\n", "        ", "user_attributes", "=", "model", ".", "_get_user_attributes", "(", ")", "\n", "# only save the public attributes with _ at the very end", "\n", "user_attributes", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "user_attributes", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "# save the model state dict and the trainer state dict only", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n", "dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "\n", "if", "save_anndata", ":", "\n", "            ", "dataset_names", "=", "[", "\"seq\"", ",", "\"spatial\"", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "model", ".", "adatas", ")", ")", ":", "\n", "                ", "dataset_name", "=", "dataset_names", "[", "i", "]", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "\n", "dir_path", ",", "f\"{file_name_prefix}adata_{dataset_name}.h5ad\"", "\n", ")", "\n", "model", ".", "adatas", "[", "i", "]", ".", "write", "(", "save_path", ")", "\n", "varnames_save_path", "=", "os", ".", "path", ".", "join", "(", "\n", "dir_path", ",", "f\"{file_name_prefix}var_names_{dataset_name}.csv\"", "\n", ")", "\n", "\n", "var_names", "=", "model", ".", "adatas", "[", "i", "]", ".", "var_names", ".", "astype", "(", "str", ")", "\n", "var_names", "=", "var_names", ".", "to_numpy", "(", ")", "\n", "np", ".", "savetxt", "(", "varnames_save_path", ",", "var_names", ",", "fmt", "=", "\"%s\"", ")", "\n", "\n", "", "", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}model_params.pt\"", ")", "\n", "attr_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}attr.pkl\"", ")", "\n", "\n", "torch", ".", "save", "(", "model", ".", "module", ".", "state_dict", "(", ")", ",", "model_save_path", ")", "\n", "with", "open", "(", "attr_save_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "user_attributes", ",", "f", ")", "\n", "\n", "", "", "prefix", "=", "\"GIMVI_\"", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata2", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "\n", "# GIMVI", "\n", "model", "=", "GIMVI", "(", "adata", ",", "adata2", ")", "\n", "model", ".", "train", "(", "3", ",", "train_size", "=", "0.5", ")", "\n", "z1", "=", "model", ".", "get_latent_representation", "(", "[", "adata", "]", ")", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", "[", "adata", "]", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "z1", ",", "z2", ")", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", ")", "\n", "model", "=", "GIMVI", ".", "load", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "tmp_adata", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", "n_genes", "=", "200", ")", "\n", "tmp_adata2", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", "n_genes", "=", "200", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "GIMVI", ".", "load", "(", "\n", "save_path", ",", "adata_seq", "=", "tmp_adata", ",", "adata_spatial", "=", "tmp_adata2", ",", "prefix", "=", "prefix", "\n", ")", "\n", "", "model", "=", "GIMVI", ".", "load", "(", "save_path", ",", "adata_seq", "=", "adata", ",", "adata_spatial", "=", "adata2", ",", "prefix", "=", "prefix", ")", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", "[", "adata", "]", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "z1", ",", "z2", ")", "\n", "model", "=", "GIMVI", ".", "load", "(", "\n", "save_path", ",", "\n", "adata_seq", "=", "adata", ",", "\n", "adata_spatial", "=", "adata2", ",", "\n", "use_gpu", "=", "False", ",", "\n", "prefix", "=", "prefix", ",", "\n", ")", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", "[", "adata", "]", ")", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "z1", ",", "z2", ",", "decimal", "=", "3", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "# Test legacy loading", "\n", "legacy_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"legacy/\"", ")", "\n", "legacy_save", "(", "\n", "model", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "GIMVI", ".", "load", "(", "\n", "legacy_save_path", ",", "adata_seq", "=", "adata", ",", "adata_spatial", "=", "adata2", ",", "prefix", "=", "prefix", "\n", ")", "\n", "", "GIMVI", ".", "convert_legacy_save", "(", "\n", "legacy_save_path", ",", "\n", "legacy_save_path", ",", "\n", "overwrite", "=", "True", ",", "\n", "prefix", "=", "prefix", ",", "\n", ")", "\n", "m", "=", "GIMVI", ".", "load", "(", "\n", "legacy_save_path", ",", "adata_seq", "=", "adata", ",", "adata_spatial", "=", "adata2", ",", "prefix", "=", "prefix", "\n", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_gimvi.test_gimvi": [[123, 152], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "scvi.external.GIMVI.setup_anndata", "scvi.external.GIMVI.setup_anndata", "scvi.external.GIMVI", "scvi.external.GIMVI.train", "scvi.external.GIMVI.get_latent_representation", "scvi.external.GIMVI.get_imputed_values", "scvi.external.GIMVI.setup_anndata", "hasattr", "pytest.raises", "scvi.external.GIMVI", "hasattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_imputed_values", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata"], ["", "def", "test_gimvi", "(", ")", ":", "\n", "    ", "adata_seq", "=", "synthetic_iid", "(", ")", "\n", "adata_spatial", "=", "synthetic_iid", "(", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata_seq", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata_spatial", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "GIMVI", "(", "adata_seq", ",", "adata_spatial", ",", "n_latent", "=", "10", ")", "\n", "assert", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means_0\"", ")", "and", "not", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_means_1\"", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "get_imputed_values", "(", ")", "\n", "\n", "adata_spatial", ".", "var_names", "+=", "\"asdf\"", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata_spatial", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", "=", "GIMVI", "(", "adata_seq", ",", "adata_spatial", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_gimvi.test_gimvi_model_library_size": [[154, 176], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "scvi.external.GIMVI.setup_anndata", "scvi.external.GIMVI.setup_anndata", "scvi.external.GIMVI", "scvi.external.GIMVI.train", "scvi.external.GIMVI.get_latent_representation", "scvi.external.GIMVI.get_imputed_values", "hasattr", "hasattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_imputed_values"], ["", "", "def", "test_gimvi_model_library_size", "(", ")", ":", "\n", "    ", "adata_seq", "=", "synthetic_iid", "(", ")", "\n", "adata_spatial", "=", "synthetic_iid", "(", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata_seq", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "GIMVI", ".", "setup_anndata", "(", "\n", "adata_spatial", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "GIMVI", "(", "\n", "adata_seq", ",", "adata_spatial", ",", "model_library_size", "=", "[", "True", ",", "True", "]", ",", "n_latent", "=", "10", "\n", ")", "\n", "assert", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means_0\"", ")", "and", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_means_1\"", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "get_imputed_values", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_solo.test_solo": [[6, 23], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.external.SOLO.from_scvi_model", "SOLO.from_scvi_model.train", "SOLO.from_scvi_model.predict", "scvi.data.synthetic_iid", "scvi.external.SOLO.from_scvi_model", "SOLO.from_scvi_model.train", "SOLO.from_scvi_model.predict", "SOLO.from_scvi_model.history.keys", "SOLO.from_scvi_model.history.keys"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict"], ["def", "test_solo", "(", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "solo", "=", "SOLO", ".", "from_scvi_model", "(", "model", ")", "\n", "solo", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.9", ")", "\n", "assert", "\"validation_loss\"", "in", "solo", ".", "history", ".", "keys", "(", ")", "\n", "solo", ".", "predict", "(", ")", "\n", "\n", "bdata", "=", "synthetic_iid", "(", ")", "\n", "solo", "=", "SOLO", ".", "from_scvi_model", "(", "model", ",", "bdata", ")", "\n", "solo", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.9", ")", "\n", "assert", "\"validation_loss\"", "in", "solo", ".", "history", ".", "keys", "(", ")", "\n", "solo", ".", "predict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_solo.test_solo_multiple_batch": [[25, 37], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.copy", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.external.SOLO.from_scvi_model", "SOLO.from_scvi_model.train", "SOLO.from_scvi_model.predict", "SOLO.from_scvi_model.history.keys"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict"], ["", "def", "test_solo_multiple_batch", "(", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "layers", "[", "\"my_layer\"", "]", "=", "adata", ".", "X", ".", "copy", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "layer", "=", "\"my_layer\"", ",", "batch_key", "=", "\"batch\"", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "solo", "=", "SOLO", ".", "from_scvi_model", "(", "model", ",", "restrict_to_batch", "=", "\"batch_0\"", ")", "\n", "solo", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.9", ")", "\n", "assert", "\"validation_loss\"", "in", "solo", ".", "history", ".", "keys", "(", ")", "\n", "solo", ".", "predict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.external.test_solo.test_solo_scvi_labels": [[39, 50], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.external.SOLO.from_scvi_model", "SOLO.from_scvi_model.train", "SOLO.from_scvi_model.predict", "SOLO.from_scvi_model.history.keys"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict"], ["", "def", "test_solo_scvi_labels", "(", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "solo", "=", "SOLO", ".", "from_scvi_model", "(", "model", ")", "\n", "solo", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.9", ")", "\n", "assert", "\"validation_loss\"", "in", "solo", ".", "history", ".", "keys", "(", ")", "\n", "solo", ".", "predict", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.__init__": [[79, 174], ["scvi.module.base.BaseModuleClass.__init__", "range", "scvi.nn.MultiEncoder", "torch.nn.ModuleList", "torch.nn.ModuleList", "scvi.nn.MultiDecoder", "len", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "_module.JVAE.register_buffer", "_module.JVAE.register_buffer", "len", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "scvi.nn.Encoder", "range", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "len", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dim_input_list", ":", "List", "[", "int", "]", ",", "\n", "total_genes", ":", "int", ",", "\n", "indices_mappings", ":", "List", "[", "Union", "[", "np", ".", "ndarray", ",", "slice", "]", "]", ",", "\n", "gene_likelihoods", ":", "List", "[", "str", "]", ",", "\n", "model_library_bools", ":", "List", "[", "bool", "]", ",", "\n", "library_log_means", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "library_log_vars", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers_encoder_individual", ":", "int", "=", "1", ",", "\n", "n_layers_encoder_shared", ":", "int", "=", "1", ",", "\n", "dim_hidden_encoder", ":", "int", "=", "64", ",", "\n", "n_layers_decoder_individual", ":", "int", "=", "0", ",", "\n", "n_layers_decoder_shared", ":", "int", "=", "0", ",", "\n", "dim_hidden_decoder_individual", ":", "int", "=", "64", ",", "\n", "dim_hidden_decoder_shared", ":", "int", "=", "64", ",", "\n", "dropout_rate_encoder", ":", "float", "=", "0.2", ",", "\n", "dropout_rate_decoder", ":", "float", "=", "0.2", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "dispersion", ":", "str", "=", "\"gene-batch\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input_list", "=", "dim_input_list", "\n", "self", ".", "total_genes", "=", "total_genes", "\n", "self", ".", "indices_mappings", "=", "indices_mappings", "\n", "self", ".", "gene_likelihoods", "=", "gene_likelihoods", "\n", "self", ".", "model_library_bools", "=", "model_library_bools", "\n", "for", "mode", "in", "range", "(", "len", "(", "dim_input_list", ")", ")", ":", "\n", "            ", "if", "self", ".", "model_library_bools", "[", "mode", "]", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n", "f\"library_log_means_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_means", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "f\"library_log_vars_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_vars", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "\n", "", "", "self", ".", "n_latent", "=", "n_latent", "\n", "\n", "self", ".", "n_batch", "=", "n_batch", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "\n", "self", ".", "dispersion", "=", "dispersion", "\n", "self", ".", "log_variational", "=", "log_variational", "\n", "\n", "self", ".", "z_encoder", "=", "MultiEncoder", "(", "\n", "n_heads", "=", "len", "(", "dim_input_list", ")", ",", "\n", "n_input_list", "=", "dim_input_list", ",", "\n", "n_output", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "dim_hidden_encoder", ",", "\n", "n_layers_individual", "=", "n_layers_encoder_individual", ",", "\n", "n_layers_shared", "=", "n_layers_encoder_shared", ",", "\n", "dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "self", ".", "l_encoders", "=", "ModuleList", "(", "\n", "[", "\n", "Encoder", "(", "\n", "self", ".", "n_input_list", "[", "i", "]", ",", "\n", "1", ",", "\n", "n_layers", "=", "1", ",", "\n", "dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "if", "self", ".", "model_library_bools", "[", "i", "]", "\n", "else", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "n_input_list", ")", ")", "\n", "]", "\n", ")", "\n", "\n", "self", ".", "decoder", "=", "MultiDecoder", "(", "\n", "self", ".", "n_latent", ",", "\n", "self", ".", "total_genes", ",", "\n", "n_hidden_conditioned", "=", "dim_hidden_decoder_individual", ",", "\n", "n_hidden_shared", "=", "dim_hidden_decoder_shared", ",", "\n", "n_layers_conditioned", "=", "n_layers_decoder_individual", ",", "\n", "n_layers_shared", "=", "n_layers_decoder_shared", ",", "\n", "n_cat_list", "=", "[", "self", ".", "n_batch", "]", ",", "\n", "dropout_rate", "=", "dropout_rate_decoder", ",", "\n", ")", "\n", "\n", "if", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_batch", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_labels", ")", ")", "\n", "", "else", ":", "# gene-cell", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_from_posterior_z": [[175, 207], ["_module.JVAE.inference", "len", "Exception"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "", "def", "sample_from_posterior_z", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Sample tensor of latent values from the posterior.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n        mode\n            head id to use in the encoder\n        deterministic\n            bool - whether to sample or not\n\n        Returns\n        -------\n        type\n            tensor of shape ``(batch_size, n_latent)``\n\n        \"\"\"", "\n", "if", "mode", "is", "None", ":", "\n", "            ", "if", "len", "(", "self", ".", "n_input_list", ")", "==", "1", ":", "\n", "                ", "mode", "=", "0", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Must provide a mode when having multiple datasets\"", ")", "\n", "", "", "outputs", "=", "self", ".", "inference", "(", "x", ",", "mode", ")", "\n", "qz_m", "=", "outputs", "[", "\"qz\"", "]", ".", "loc", "\n", "z", "=", "outputs", "[", "\"z\"", "]", "\n", "if", "deterministic", ":", "\n", "            ", "z", "=", "qz_m", "\n", "", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_from_posterior_l": [[208, 234], ["_module.JVAE.encode"], "methods", ["None"], ["", "def", "sample_from_posterior_l", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Sample the tensor of library sizes from the posterior.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n            or ``(batch_size, n_input_fish)`` depending on the mode\n        mode\n            head id to use in the encoder\n        deterministic\n            bool - whether to sample or not\n\n        Returns\n        -------\n        type\n            tensor of shape ``(batch_size, 1)``\n\n        \"\"\"", "\n", "_", ",", "_", ",", "_", ",", "ql_m", ",", "_", ",", "library", "=", "self", ".", "encode", "(", "x", ",", "mode", ")", "\n", "if", "deterministic", "and", "ql_m", "is", "not", "None", ":", "\n", "            ", "library", "=", "ql_m", "\n", "", "return", "library", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_scale": [[235, 284], ["_module.JVAE.inference", "_module.JVAE.generative"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.generative"], ["", "def", "sample_scale", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "mode", ":", "int", ",", "\n", "batch_index", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "False", ",", "\n", "decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Return the tensor of predicted frequencies of expression.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n            or ``(batch_size, n_input_fish)`` depending on the mode\n        mode\n            int encode mode (which input head to use in the model)\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        y\n            tensor of cell-types labels with shape ``(batch_size, n_labels)``\n        deterministic\n            bool - whether to sample or not\n        decode_mode\n            int use to a decode mode different from encoding mode\n\n        Returns\n        -------\n        type\n            tensor of predicted expression\n\n        \"\"\"", "\n", "if", "decode_mode", "is", "None", ":", "\n", "            ", "decode_mode", "=", "mode", "\n", "", "inference_out", "=", "self", ".", "inference", "(", "x", ",", "mode", ")", "\n", "if", "deterministic", ":", "\n", "            ", "z", "=", "inference_out", "[", "\"qz\"", "]", ".", "loc", "\n", "if", "inference_out", "[", "\"ql\"", "]", "is", "not", "None", ":", "\n", "                ", "library", "=", "inference_out", "[", "\"ql\"", "]", ".", "loc", "\n", "", "else", ":", "\n", "                ", "library", "=", "inference_out", "[", "\"library\"", "]", "\n", "", "", "else", ":", "\n", "            ", "z", "=", "inference_out", "[", "\"z\"", "]", "\n", "library", "=", "inference_out", "[", "\"library\"", "]", "\n", "", "gen_out", "=", "self", ".", "generative", "(", "z", ",", "library", ",", "batch_index", ",", "y", ",", "decode_mode", ")", "\n", "\n", "return", "gen_out", "[", "\"px_scale\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.get_sample_rate": [[286, 288], ["_module.JVAE.sample_rate"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_rate"], ["", "def", "get_sample_rate", "(", "self", ",", "x", ",", "batch_index", ",", "*", "_", ",", "**", "__", ")", ":", "\n", "        ", "return", "self", ".", "sample_rate", "(", "x", ",", "0", ",", "batch_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_rate": [[289, 335], ["_module.JVAE.encode", "_module.JVAE.decode"], "methods", ["None"], ["", "def", "sample_rate", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "mode", ":", "int", ",", "\n", "batch_index", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "False", ",", "\n", "decode_mode", ":", "int", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Returns the tensor of scaled frequencies of expression.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n            or ``(batch_size, n_input_fish)`` depending on the mode\n        y\n            tensor of cell-types labels with shape ``(batch_size, n_labels)``\n        mode\n            int encode mode (which input head to use in the model)\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        deterministic\n            bool - whether to sample or not\n        decode_mode\n            int use to a decode mode different from encoding mode\n\n        Returns\n        -------\n        type\n            tensor of means of the scaled frequencies\n\n        \"\"\"", "\n", "if", "decode_mode", "is", "None", ":", "\n", "            ", "decode_mode", "=", "mode", "\n", "", "qz_m", ",", "qz_v", ",", "z", ",", "ql_m", ",", "ql_v", ",", "library", "=", "self", ".", "encode", "(", "x", ",", "mode", ")", "\n", "if", "deterministic", ":", "\n", "            ", "z", "=", "qz_m", "\n", "if", "ql_m", "is", "not", "None", ":", "\n", "                ", "library", "=", "ql_m", "\n", "", "", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "=", "self", ".", "decode", "(", "\n", "z", ",", "decode_mode", ",", "library", ",", "batch_index", ",", "y", "\n", ")", "\n", "\n", "return", "px_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.reconstruction_loss": [[336, 360], ["scvi.distributions.ZeroInflatedNegativeBinomial().log_prob().sum", "scvi.distributions.NegativeBinomial().log_prob().sum", "scvi.distributions.ZeroInflatedNegativeBinomial().log_prob", "torch.distributions.Poisson().log_prob().sum", "torch.distributions.Poisson().log_prob().sum", "scvi.distributions.NegativeBinomial().log_prob", "scvi.distributions.ZeroInflatedNegativeBinomial", "torch.distributions.Poisson().log_prob", "torch.distributions.Poisson().log_prob", "scvi.distributions.NegativeBinomial", "torch.distributions.Poisson", "torch.distributions.Poisson"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["", "def", "reconstruction_loss", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "px_rate", ":", "torch", ".", "Tensor", ",", "\n", "px_r", ":", "torch", ".", "Tensor", ",", "\n", "px_dropout", ":", "torch", ".", "Tensor", ",", "\n", "mode", ":", "int", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "reconstruction_loss", "=", "None", "\n", "if", "self", ".", "gene_likelihoods", "[", "mode", "]", "==", "\"zinb\"", ":", "\n", "            ", "reconstruction_loss", "=", "(", "\n", "-", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ",", "zi_logits", "=", "px_dropout", "\n", ")", "\n", ".", "log_prob", "(", "x", ")", "\n", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "", "elif", "self", ".", "gene_likelihoods", "[", "mode", "]", "==", "\"nb\"", ":", "\n", "            ", "reconstruction_loss", "=", "(", "\n", "-", "NegativeBinomial", "(", "mu", "=", "px_rate", ",", "theta", "=", "px_r", ")", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", ")", "\n", "", "elif", "self", ".", "gene_likelihoods", "[", "mode", "]", "==", "\"poisson\"", ":", "\n", "            ", "reconstruction_loss", "=", "-", "Poisson", "(", "px_rate", ")", ".", "log_prob", "(", "x", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "return", "reconstruction_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE._get_inference_input": [[361, 363], ["dict"], "methods", ["None"], ["", "def", "_get_inference_input", "(", "self", ",", "tensors", ")", ":", "\n", "        ", "return", "dict", "(", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE._get_generative_input": [[364, 370], ["dict"], "methods", ["None"], ["", "def", "_get_generative_input", "(", "self", ",", "tensors", ",", "inference_outputs", ")", ":", "\n", "        ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "library", "=", "inference_outputs", "[", "\"library\"", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "return", "dict", "(", "z", "=", "z", ",", "library", "=", "library", ",", "batch_index", "=", "batch_index", ",", "y", "=", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.inference": [[371, 385], ["_module.JVAE.z_encoder", "dict", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log().view", "torch.log().view", "torch.log().view", "torch.log().view", "torch.log", "torch.log", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "@", "auto_move_data", "\n", "def", "inference", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "dict", ":", "\n", "        ", "x_", "=", "x", "\n", "if", "self", ".", "log_variational", ":", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x_", ")", "\n", "\n", "", "qz", ",", "z", "=", "self", ".", "z_encoder", "(", "x_", ",", "mode", ")", "\n", "ql", ",", "library", "=", "None", ",", "None", "\n", "if", "self", ".", "model_library_bools", "[", "mode", "]", ":", "\n", "            ", "ql", ",", "library", "=", "self", ".", "l_encoders", "[", "mode", "]", "(", "x_", ")", "\n", "", "else", ":", "\n", "            ", "library", "=", "torch", ".", "log", "(", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "", "return", "dict", "(", "qz", "=", "qz", ",", "z", "=", "z", ",", "ql", "=", "ql", ",", "library", "=", "library", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.generative": [[386, 413], ["_module.JVAE.decoder", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "dict", "torch.linear", "torch.linear", "torch.sum().view", "torch.sum().view", "torch.sum().view", "torch.sum().view", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "scvi.nn.one_hot", "torch.linear", "torch.linear", "scvi.nn.one_hot", "_module.JVAE.px_r.view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "_module.JVAE.px_r.size"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "@", "auto_move_data", "\n", "def", "generative", "(", "\n", "self", ",", "\n", "z", ":", "torch", ".", "Tensor", ",", "\n", "library", ":", "torch", ".", "Tensor", ",", "\n", "batch_index", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "px_scale", ",", "px_r", ",", "px_rate", ",", "px_dropout", "=", "self", ".", "decoder", "(", "\n", "z", ",", "mode", ",", "library", ",", "self", ".", "dispersion", ",", "batch_index", ",", "y", "\n", ")", "\n", "if", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "y", ",", "self", ".", "n_labels", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "px_r", "=", "F", ".", "linear", "(", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "self", ".", "px_r", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "px_r", "=", "self", ".", "px_r", ".", "view", "(", "1", ",", "self", ".", "px_r", ".", "size", "(", "0", ")", ")", "\n", "", "px_r", "=", "torch", ".", "exp", "(", "px_r", ")", "\n", "\n", "px_scale", "=", "px_scale", "/", "torch", ".", "sum", "(", "\n", "px_scale", "[", ":", ",", "self", ".", "indices_mappings", "[", "mode", "]", "]", ",", "dim", "=", "1", "\n", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "px_rate", "=", "px_scale", "*", "torch", ".", "exp", "(", "library", ")", "\n", "\n", "return", "dict", "(", "\n", "px_scale", "=", "px_scale", ",", "px_r", "=", "px_r", ",", "px_rate", "=", "px_rate", ",", "px_dropout", "=", "px_dropout", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.loss": [[415, 496], ["_module.JVAE.reconstruction_loss", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "scvi.module.base.LossRecorder", "getattr", "getattr", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.distributions.kl_divergence.sum", "torch.distributions.kl_divergence.sum", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "x.size", "len", "Exception", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "scvi.nn.one_hot", "scvi.nn.one_hot", "torch.distributions.Normal", "torch.distributions.Normal", "torch.distributions.kl_divergence", "torch.distributions.kl_divergence", "torch.distributions.Normal", "torch.distributions.Normal", "torch.linear.sqrt"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.reconstruction_loss", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["", "def", "loss", "(", "\n", "self", ",", "\n", "tensors", ",", "\n", "inference_outputs", ",", "\n", "generative_outputs", ",", "\n", "mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "kl_weight", "=", "1.0", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Return the reconstruction loss and the Kullback divergences.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n            or ``(batch_size, n_input_fish)`` depending on the mode\n        batch_index\n            array that indicates which batch the cells belong to with shape ``batch_size``\n        y\n            tensor of cell-types labels with shape (batch_size, n_labels)\n        mode\n            indicates which head/tail to use in the joint network\n\n\n        Returns\n        -------\n        the reconstruction loss and the Kullback divergences\n\n        \"\"\"", "\n", "if", "mode", "is", "None", ":", "\n", "            ", "if", "len", "(", "self", ".", "n_input_list", ")", "==", "1", ":", "\n", "                ", "mode", "=", "0", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Must provide a mode\"", ")", "\n", "", "", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "\n", "qz", "=", "inference_outputs", "[", "\"qz\"", "]", "\n", "ql", "=", "inference_outputs", "[", "\"ql\"", "]", "\n", "px_rate", "=", "generative_outputs", "[", "\"px_rate\"", "]", "\n", "px_r", "=", "generative_outputs", "[", "\"px_r\"", "]", "\n", "px_dropout", "=", "generative_outputs", "[", "\"px_dropout\"", "]", "\n", "\n", "# mask loss to observed genes", "\n", "mapping_indices", "=", "self", ".", "indices_mappings", "[", "mode", "]", "\n", "reconstruction_loss", "=", "self", ".", "reconstruction_loss", "(", "\n", "x", ",", "\n", "px_rate", "[", ":", ",", "mapping_indices", "]", ",", "\n", "px_r", "[", ":", ",", "mapping_indices", "]", ",", "\n", "px_dropout", "[", ":", ",", "mapping_indices", "]", ",", "\n", "mode", ",", "\n", ")", "\n", "\n", "# KL Divergence", "\n", "mean", "=", "torch", ".", "zeros_like", "(", "qz", ".", "loc", ")", "\n", "scale", "=", "torch", ".", "ones_like", "(", "qz", ".", "scale", ")", "\n", "kl_divergence_z", "=", "kl", "(", "qz", ",", "Normal", "(", "mean", ",", "scale", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "if", "self", ".", "model_library_bools", "[", "mode", "]", ":", "\n", "            ", "library_log_means", "=", "getattr", "(", "self", ",", "f\"library_log_means_{mode}\"", ")", "\n", "library_log_vars", "=", "getattr", "(", "self", ",", "f\"library_log_vars_{mode}\"", ")", "\n", "\n", "local_library_log_means", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "library_log_means", "\n", ")", "\n", "local_library_log_vars", "=", "F", ".", "linear", "(", "\n", "one_hot", "(", "batch_index", ",", "self", ".", "n_batch", ")", ",", "library_log_vars", "\n", ")", "\n", "kl_divergence_l", "=", "kl", "(", "\n", "ql", ",", "\n", "Normal", "(", "local_library_log_means", ",", "local_library_log_vars", ".", "sqrt", "(", ")", ")", ",", "\n", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "kl_divergence_l", "=", "torch", ".", "zeros_like", "(", "kl_divergence_z", ")", "\n", "\n", "", "kl_local", "=", "kl_divergence_l", "+", "kl_divergence_z", "\n", "kl_global", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "\n", "loss", "=", "torch", ".", "mean", "(", "reconstruction_loss", "+", "kl_weight", "*", "kl_local", ")", "*", "x", ".", "size", "(", "0", ")", "\n", "\n", "return", "LossRecorder", "(", "loss", ",", "reconstruction_loss", ",", "kl_local", ",", "kl_global", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._utils._load_legacy_saved_gimvi_files": [[13, 61], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "torch.load", "numpy.genfromtxt", "numpy.genfromtxt", "open", "pickle.load", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "anndata.read", "anndata.read", "os.path.exists", "ValueError", "os.path.exists", "ValueError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], ["\n", "", "return", "dec", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._utils._load_saved_gimvi_files": [[64, 120], ["os.path.join", "scvi.data._download._download", "torch.load", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "ValueError", "anndata.read", "anndata.read", "os.path.exists", "ValueError", "os.path.exists", "ValueError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.__init__": [[76, 157], ["scvi.model.base.VAEMixin.__init__", "_model.GIMVI.adata_managers.values", "numpy.concatenate", "sum", "_model.GIMVI.adata_managers.values", "_module.JVAE", "_model.GIMVI._get_init_params", "ValueError", "_model.GIMVI._get_most_recent_anndata_manager", "_model.GIMVI._get_most_recent_anndata_manager", "_model.GIMVI._register_manager_for_instance", "_model.GIMVI.registries_.append", "ValueError", "slice", "scvi.model._utils._init_library_size", "library_log_means.append", "library_log_vars.append", "locals", "set", "set", "numpy.argwhere", "_model.GIMVI.adata_managers.values"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_most_recent_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_most_recent_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._register_manager_for_instance", "home.repos.pwc.inspect_result.YosefLab_scVI.model._utils._init_library_size"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_seq", ":", "AnnData", ",", "\n", "adata_spatial", ":", "AnnData", ",", "\n", "generative_distributions", ":", "List", "=", "[", "\"zinb\"", ",", "\"nb\"", "]", ",", "\n", "model_library_size", ":", "List", "=", "[", "True", ",", "False", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "GIMVI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "adata_seq", "is", "adata_spatial", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`adata_seq` and `adata_spatial` cannot point to the same object. \"", "\n", "\"If you would really like to do this, make a copy of the object and pass it in as `adata_spatial`.\"", "\n", ")", "\n", "", "self", ".", "adatas", "=", "[", "adata_seq", ",", "adata_spatial", "]", "\n", "self", ".", "adata_managers", "=", "{", "\n", "\"seq\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "adata_seq", ",", "required", "=", "True", ")", ",", "\n", "\"spatial\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "\n", "adata_spatial", ",", "required", "=", "True", "\n", ")", ",", "\n", "}", "\n", "self", ".", "registries_", "=", "[", "]", "\n", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "_register_manager_for_instance", "(", "adm", ")", "\n", "self", ".", "registries_", ".", "append", "(", "adm", ".", "registry", ")", "\n", "\n", "", "seq_var_names", "=", "adata_seq", ".", "var_names", "\n", "spatial_var_names", "=", "adata_spatial", ".", "var_names", "\n", "\n", "if", "not", "set", "(", "spatial_var_names", ")", "<=", "set", "(", "seq_var_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"spatial genes needs to be subset of seq genes\"", ")", "\n", "\n", "", "spatial_gene_loc", "=", "[", "\n", "np", ".", "argwhere", "(", "seq_var_names", "==", "g", ")", "[", "0", "]", "for", "g", "in", "spatial_var_names", "\n", "]", "\n", "spatial_gene_loc", "=", "np", ".", "concatenate", "(", "spatial_gene_loc", ")", "\n", "gene_mappings", "=", "[", "slice", "(", "None", ")", ",", "spatial_gene_loc", "]", "\n", "sum_stats", "=", "[", "adm", ".", "summary_stats", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", "]", "\n", "n_inputs", "=", "[", "s", "[", "\"n_vars\"", "]", "for", "s", "in", "sum_stats", "]", "\n", "\n", "total_genes", "=", "n_inputs", "[", "0", "]", "\n", "\n", "# since we are combining datasets, we need to increment the batch_idx", "\n", "# of one of the datasets", "\n", "adata_seq_n_batches", "=", "sum_stats", "[", "0", "]", "[", "\"n_batch\"", "]", "\n", "adata_spatial", ".", "obs", "[", "\n", "self", ".", "adata_managers", "[", "\"spatial\"", "]", "\n", ".", "data_registry", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", ".", "attr_key", "\n", "]", "+=", "adata_seq_n_batches", "\n", "\n", "n_batches", "=", "sum", "(", "s", "[", "\"n_batch\"", "]", "for", "s", "in", "sum_stats", ")", "\n", "\n", "library_log_means", "=", "[", "]", "\n", "library_log_vars", "=", "[", "]", "\n", "for", "adata_manager", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "adata_library_log_means", ",", "adata_library_log_vars", "=", "_init_library_size", "(", "\n", "adata_manager", ",", "n_batches", "\n", ")", "\n", "library_log_means", ".", "append", "(", "adata_library_log_means", ")", "\n", "library_log_vars", ".", "append", "(", "adata_library_log_vars", ")", "\n", "\n", "", "self", ".", "module", "=", "JVAE", "(", "\n", "n_inputs", ",", "\n", "total_genes", ",", "\n", "gene_mappings", ",", "\n", "generative_distributions", ",", "\n", "model_library_size", ",", "\n", "library_log_means", ",", "\n", "library_log_vars", ",", "\n", "n_batch", "=", "n_batches", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"GimVI Model with the following params: \\nn_latent: {}, n_inputs: {}, n_genes: {}, \"", "\n", "+", "\"n_batch: {}, generative distributions: {}\"", "\n", ")", ".", "format", "(", "n_latent", ",", "n_inputs", ",", "total_genes", ",", "n_batches", ",", "generative_distributions", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.train": [[158, 245], ["scvi.model._utils.parse_use_gpu_arg", "scvi.train.Trainer", "enumerate", "_model.TrainDL", "_task.GIMVITrainingPlan", "_model.GIMVI.module.eval", "_model.GIMVI.to_device", "_model.GIMVI.adata_managers.values", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "train_dls.append", "test_dls.append", "scvi.dataloaders.DataSplitter.val_dataloader", "val_dls.append", "_model.GIMVI.train_indices_.append", "_model.GIMVI.test_indices_.append", "_model.GIMVI.validation_indices_.append", "isinstance", "dict", "_model.GIMVI.trainer.fit", "_model.GIMVI.trainer.fit", "scvi.dataloaders.DataSplitter.train_dataloader", "scvi.dataloaders.DataSplitter.test_dataloader"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader"], ["", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "200", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "kappa", ":", "int", "=", "5", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        kappa\n            Scaling parameter for the discriminator loss.\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        plan_kwargs\n            Keyword args for model-specific Pytorch Lightning task. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "gpus", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "self", ".", "trainer", "=", "Trainer", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "gpus", "=", "gpus", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "train_indices_", ",", "self", ".", "test_indices_", ",", "self", ".", "validation_indices_", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "train_dls", ",", "test_dls", ",", "val_dls", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "adm", "in", "enumerate", "(", "self", ".", "adata_managers", ".", "values", "(", ")", ")", ":", "\n", "            ", "ds", "=", "DataSplitter", "(", "\n", "adm", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "train_dls", ".", "append", "(", "ds", ".", "train_dataloader", "(", ")", ")", "\n", "test_dls", ".", "append", "(", "ds", ".", "test_dataloader", "(", ")", ")", "\n", "val", "=", "ds", ".", "val_dataloader", "(", ")", "\n", "val_dls", ".", "append", "(", "val", ")", "\n", "val", ".", "mode", "=", "i", "\n", "self", ".", "train_indices_", ".", "append", "(", "ds", ".", "train_idx", ")", "\n", "self", ".", "test_indices_", ".", "append", "(", "ds", ".", "test_idx", ")", "\n", "self", ".", "validation_indices_", ".", "append", "(", "ds", ".", "val_idx", ")", "\n", "", "train_dl", "=", "TrainDL", "(", "train_dls", ")", "\n", "\n", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "self", ".", "_training_plan", "=", "GIMVITrainingPlan", "(", "\n", "self", ".", "module", ",", "\n", "adversarial_classifier", "=", "True", ",", "\n", "scale_adversarial_loss", "=", "kappa", ",", "\n", "**", "plan_kwargs", ",", "\n", ")", "\n", "\n", "if", "train_size", "==", "1.0", ":", "\n", "# circumvent the empty data loader problem if all dataset used for training", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ")", "\n", "", "else", ":", "\n", "# accepts list of val dataloaders", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ",", "val_dls", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "history_", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "history_", "=", "None", "\n", "", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "self", ".", "to_device", "(", "device", ")", "\n", "self", ".", "is_trained_", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI._make_scvi_dls": [[246, 254], ["enumerate", "_model.GIMVI._make_data_loader"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader"], ["", "def", "_make_scvi_dls", "(", "self", ",", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "batch_size", "=", "128", ")", ":", "\n", "        ", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "post_list", "=", "[", "self", ".", "_make_data_loader", "(", "ad", ")", "for", "ad", "in", "adatas", "]", "\n", "for", "i", ",", "dl", "in", "enumerate", "(", "post_list", ")", ":", "\n", "            ", "dl", ".", "mode", "=", "i", "\n", "\n", "", "return", "post_list", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation": [[255, 296], ["torch.no_grad", "_model.GIMVI._make_scvi_dls", "_model.GIMVI.module.eval", "enumerate", "torch.cat().cpu().detach().numpy", "latents.append", "_model._unpack_tensors", "torch.cat().cpu().detach().numpy.append", "_model.GIMVI.module.sample_from_posterior_z", "torch.cat().cpu().detach", "torch.cat().cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI._make_scvi_dls", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model._unpack_tensors", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_from_posterior_z"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return the latent space embedding for each dataset.\n\n        Parameters\n        ----------\n        adatas\n            List of adata seq and adata spatial.\n        deterministic\n            If true, use the mean of the encoder instead of a Gaussian sample.\n        batch_size\n            Minibatch size for data loading into model.\n        \"\"\"", "\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "latents", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "latent", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "latent", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_from_posterior_z", "(", "\n", "sample_batch", ",", "mode", ",", "deterministic", "=", "deterministic", "\n", ")", "\n", ")", "\n", "\n", "", "latent", "=", "torch", ".", "cat", "(", "latent", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "latents", ".", "append", "(", "latent", ")", "\n", "\n", "", "return", "latents", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_imputed_values": [[297, 366], ["torch.no_grad", "_model.GIMVI.module.eval", "_model.GIMVI._make_scvi_dls", "enumerate", "torch.cat().cpu().detach().numpy", "imputed_values.append", "_model._unpack_tensors", "torch.cat().cpu().detach().numpy.append", "torch.cat().cpu().detach().numpy.append", "torch.cat().cpu().detach", "_model.GIMVI.module.sample_scale", "_model.GIMVI.module.sample_rate", "torch.cat().cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI._make_scvi_dls", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model._unpack_tensors", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_scale", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._module.JVAE.sample_rate"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_imputed_values", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "normalized", ":", "bool", "=", "True", ",", "\n", "decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return imputed values for all genes for each dataset.\n\n        Parameters\n        ----------\n        adatas\n            List of adata seq and adata spatial\n        deterministic\n            If true, use the mean of the encoder instead of a Gaussian sample for the latent vector.\n        normalized\n            Return imputed normalized values or not.\n        decode_mode\n            If a `decode_mode` is given, use the encoder specific to each dataset as usual but use\n            the decoder of the dataset of id `decode_mode` to impute values.\n        batch_size\n            Minibatch size for data loading into model.\n        \"\"\"", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "imputed_values", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "imputed_value", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "if", "normalized", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_scale", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_rate", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n", "\n", "", "", "imputed_value", "=", "torch", ".", "cat", "(", "imputed_value", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "imputed_values", ".", "append", "(", "imputed_value", ")", "\n", "\n", "", "return", "imputed_values", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.save": [[367, 439], ["_model.GIMVI.module.state_dict", "seq_adata.var_names.astype().to_numpy", "spatial_adata.var_names.astype().to_numpy", "_model.GIMVI._get_user_attributes", "os.path.join", "torch.save", "os.makedirs", "ValueError", "os.path.join", "seq_adata.write", "os.path.join", "spatial_adata.write", "dict", "os.path.exists", "seq_adata.var_names.astype", "spatial_adata.var_names.astype"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_user_attributes", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save"], ["", "def", "save", "(", "\n", "self", ",", "\n", "dir_path", ":", "str", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", "save_anndata", ":", "bool", "=", "False", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Save the state of the model.\n\n        Neither the trainer optimizer state nor the trainer history are saved.\n        Model files are not expected to be reproducibly saved and loaded across versions\n        until we reach version 1.0.\n\n        Parameters\n        ----------\n        dir_path\n            Path to a directory.\n        prefix\n            Prefix to prepend to saved file names.\n        overwrite\n            Overwrite existing data or not. If `False` and directory\n            already exists at `dir_path`, error will be raised.\n        save_anndata\n            If True, also saves the anndata\n        anndata_write_kwargs\n            Kwargs for anndata write function\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n", "dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "\n", "seq_adata", "=", "self", ".", "adatas", "[", "0", "]", "\n", "spatial_adata", "=", "self", ".", "adatas", "[", "1", "]", "\n", "if", "save_anndata", ":", "\n", "            ", "seq_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}adata_seq.h5ad\"", ")", "\n", "seq_adata", ".", "write", "(", "seq_save_path", ")", "\n", "\n", "spatial_save_path", "=", "os", ".", "path", ".", "join", "(", "\n", "dir_path", ",", "f\"{file_name_prefix}adata_spatial.h5ad\"", "\n", ")", "\n", "spatial_adata", ".", "write", "(", "spatial_save_path", ")", "\n", "\n", "# save the model state dict and the trainer state dict only", "\n", "", "model_state_dict", "=", "self", ".", "module", ".", "state_dict", "(", ")", "\n", "\n", "seq_var_names", "=", "seq_adata", ".", "var_names", ".", "astype", "(", "str", ")", ".", "to_numpy", "(", ")", "\n", "spatial_var_names", "=", "spatial_adata", ".", "var_names", ".", "astype", "(", "str", ")", ".", "to_numpy", "(", ")", "\n", "\n", "# get all the user attributes", "\n", "user_attributes", "=", "self", ".", "_get_user_attributes", "(", ")", "\n", "# only save the public attributes with _ at the very end", "\n", "user_attributes", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "user_attributes", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "\n", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}model.pt\"", ")", "\n", "\n", "torch", ".", "save", "(", "\n", "dict", "(", "\n", "model_state_dict", "=", "model_state_dict", ",", "\n", "seq_var_names", "=", "seq_var_names", ",", "\n", "spatial_var_names", "=", "spatial_var_names", ",", "\n", "attr_dict", "=", "user_attributes", ",", "\n", ")", ",", "\n", "model_save_path", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load": [[441, 562], ["scvi.model._utils.parse_use_gpu_arg", "_utils._load_saved_gimvi_files", "enumerate", "attr_dict.pop", "zip", "attr_dict.pop", "cls", "attr_dict.items", "cls.module.load_state_dict", "cls.module.eval", "cls.to_device", "adata.var_names.astype", "cls.setup_anndata", "attr_dict.pop.keys", "setattr", "numpy.array_equal", "warnings.warn", "ValueError", "ValueError", "kwargs.items", "j.items", "attr_dict.pop.items", "attr_dict.pop.items", "isinstance", "kwargs.items", "j.items", "isinstance"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._utils._load_saved_gimvi_files", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata"], ["", "@", "classmethod", "\n", "def", "load", "(", "\n", "cls", ",", "\n", "dir_path", ":", "str", ",", "\n", "adata_seq", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "adata_spatial", ":", "Optional", "[", "AnnData", "]", "=", "None", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "backup_url", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Instantiate a model from the saved output.\n\n        Parameters\n        ----------\n        dir_path\n            Path to saved outputs.\n        adata_seq\n            AnnData organized in the same way as data used to train model.\n            It is not necessary to run :meth:`~scvi.external.GIMVI.setup_anndata`,\n            as AnnData is validated against the saved `scvi` setup dictionary.\n            AnnData must be registered via :meth:`~scvi.external.GIMVI.setup_anndata`.\n        adata_spatial\n            AnnData organized in the same way as data used to train model.\n            If None, will check for and load anndata saved with the model.\n        use_gpu\n            Load model on default GPU if available (if None or True),\n            or index of GPU to use (if int), or name of GPU (if str), or use CPU (if False).\n        prefix\n            Prefix of saved file names.\n        backup_url\n            URL to retrieve saved outputs from if not present on disk.\n\n        Returns\n        -------\n        Model with loaded state dictionaries.\n\n        Examples\n        --------\n        >>> vae = GIMVI.load(adata_seq, adata_spatial, save_path)\n        >>> vae.get_latent_representation()\n        \"\"\"", "\n", "_", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "(", "\n", "attr_dict", ",", "\n", "seq_var_names", ",", "\n", "spatial_var_names", ",", "\n", "model_state_dict", ",", "\n", "loaded_adata_seq", ",", "\n", "loaded_adata_spatial", ",", "\n", ")", "=", "_load_saved_gimvi_files", "(", "\n", "dir_path", ",", "\n", "adata_seq", "is", "None", ",", "\n", "adata_spatial", "is", "None", ",", "\n", "prefix", "=", "prefix", ",", "\n", "map_location", "=", "device", ",", "\n", "backup_url", "=", "backup_url", ",", "\n", ")", "\n", "adata_seq", "=", "loaded_adata_seq", "or", "adata_seq", "\n", "adata_spatial", "=", "loaded_adata_spatial", "or", "adata_spatial", "\n", "adatas", "=", "[", "adata_seq", ",", "adata_spatial", "]", "\n", "var_names", "=", "[", "seq_var_names", ",", "spatial_var_names", "]", "\n", "\n", "for", "i", ",", "adata", "in", "enumerate", "(", "adatas", ")", ":", "\n", "            ", "saved_var_names", "=", "var_names", "[", "i", "]", "\n", "user_var_names", "=", "adata", ".", "var_names", ".", "astype", "(", "str", ")", "\n", "if", "not", "np", ".", "array_equal", "(", "saved_var_names", ",", "user_var_names", ")", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"var_names for adata passed in does not match var_names of \"", "\n", "\"adata used to train the model. For valid results, the vars \"", "\n", "\"need to be the same and in the same order as the adata used to train the model.\"", "\n", ")", "\n", "\n", "", "", "registries", "=", "attr_dict", ".", "pop", "(", "\"registries_\"", ")", "\n", "for", "adata", ",", "registry", "in", "zip", "(", "adatas", ",", "registries", ")", ":", "\n", "            ", "if", "(", "\n", "_MODEL_NAME_KEY", "in", "registry", "\n", "and", "registry", "[", "_MODEL_NAME_KEY", "]", "!=", "cls", ".", "__name__", "\n", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"It appears you are loading a model from a different class.\"", "\n", ")", "\n", "\n", "", "if", "_SETUP_ARGS_KEY", "not", "in", "registry", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Saved model does not contain original setup inputs. \"", "\n", "\"Cannot load the original setup.\"", "\n", ")", "\n", "\n", "", "cls", ".", "setup_anndata", "(", "\n", "adata", ",", "source_registry", "=", "registry", ",", "**", "registry", "[", "_SETUP_ARGS_KEY", "]", "\n", ")", "\n", "\n", "# get the parameters for the class init signiture", "\n", "", "init_params", "=", "attr_dict", ".", "pop", "(", "\"init_params_\"", ")", "\n", "\n", "# new saving and loading, enable backwards compatibility", "\n", "if", "\"non_kwargs\"", "in", "init_params", ".", "keys", "(", ")", ":", "\n", "# grab all the parameters execept for kwargs (is a dict)", "\n", "            ", "non_kwargs", "=", "init_params", "[", "\"non_kwargs\"", "]", "\n", "kwargs", "=", "init_params", "[", "\"kwargs\"", "]", "\n", "\n", "# expand out kwargs", "\n", "kwargs", "=", "{", "k", ":", "v", "for", "(", "i", ",", "j", ")", "in", "kwargs", ".", "items", "(", ")", "for", "(", "k", ",", "v", ")", "in", "j", ".", "items", "(", ")", "}", "\n", "", "else", ":", "\n", "# grab all the parameters execept for kwargs (is a dict)", "\n", "            ", "non_kwargs", "=", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "init_params", ".", "items", "(", ")", "if", "not", "isinstance", "(", "v", ",", "dict", ")", "\n", "}", "\n", "kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "init_params", ".", "items", "(", ")", "if", "isinstance", "(", "v", ",", "dict", ")", "}", "\n", "kwargs", "=", "{", "k", ":", "v", "for", "(", "i", ",", "j", ")", "in", "kwargs", ".", "items", "(", ")", "for", "(", "k", ",", "v", ")", "in", "j", ".", "items", "(", ")", "}", "\n", "", "model", "=", "cls", "(", "adata_seq", ",", "adata_spatial", ",", "**", "non_kwargs", ",", "**", "kwargs", ")", "\n", "\n", "for", "attr", ",", "val", "in", "attr_dict", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "model", ",", "attr", ",", "val", ")", "\n", "\n", "", "model", ".", "module", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "model", ".", "module", ".", "eval", "(", ")", "\n", "model", ".", "to_device", "(", "device", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.convert_legacy_save": [[563, 625], ["_utils._load_legacy_saved_gimvi_files", "os.path.join", "torch.save", "os.makedirs", "ValueError", "attr_dict.pop", "dict", "os.path.exists", "registries.append", "scvi.data._compat.registry_from_setup_dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._utils._load_legacy_saved_gimvi_files", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat.registry_from_setup_dict"], ["", "@", "classmethod", "\n", "def", "convert_legacy_save", "(", "\n", "cls", ",", "\n", "dir_path", ":", "str", ",", "\n", "output_dir_path", ":", "str", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Converts a legacy saved GIMVI model (<v0.15.0) to the updated save format.\n\n        Parameters\n        ----------\n        dir_path\n            Path to directory where legacy model is saved.\n        output_dir_path\n            Path to save converted save files.\n        overwrite\n            Overwrite existing data or not. If ``False`` and directory\n            already exists at ``output_dir_path``, error will be raised.\n        prefix\n            Prefix of saved file names.\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n", "dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "(", "\n", "model_state_dict", ",", "\n", "seq_var_names", ",", "\n", "spatial_var_names", ",", "\n", "attr_dict", ",", "\n", "_", ",", "\n", "_2", ",", "\n", ")", "=", "_load_legacy_saved_gimvi_files", "(", "\n", "dir_path", ",", "\n", "file_name_prefix", ",", "\n", "load_seq_adata", "=", "False", ",", "\n", "load_spatial_adata", "=", "False", ",", "\n", ")", "\n", "if", "\"scvi_setup_dicts_\"", "in", "attr_dict", ":", "\n", "            ", "scvi_setup_dicts", "=", "attr_dict", ".", "pop", "(", "\"scvi_setup_dicts_\"", ")", "\n", "registries", "=", "[", "]", "\n", "for", "scvi_setup_dict", "in", "scvi_setup_dicts", ":", "\n", "                ", "registries", ".", "append", "(", "registry_from_setup_dict", "(", "cls", ",", "scvi_setup_dict", ")", ")", "\n", "", "attr_dict", "[", "\"registries_\"", "]", "=", "registries", "\n", "\n", "", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "output_dir_path", ",", "f\"{file_name_prefix}model.pt\"", ")", "\n", "torch", ".", "save", "(", "\n", "dict", "(", "\n", "model_state_dict", "=", "model_state_dict", ",", "\n", "seq_var_names", "=", "seq_var_names", ",", "\n", "spatial_var_names", "=", "spatial_var_names", ",", "\n", "attr_dict", "=", "attr_dict", ",", "\n", ")", ",", "\n", "model_save_path", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.setup_anndata": [[627, 657], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "@", "setup_anndata_dsp", ".", "dedent", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        %(summary)s.\n\n        Parameters\n        ----------\n        %(param_batch_key)s\n        %(param_labels_key)s\n        %(param_layer)s\n        \"\"\"", "\n", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.TrainDL.__init__": [[660, 667], ["numpy.argmax", "torch.utils.data.DataLoader.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "data_loader_list", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "data_loader_list", "=", "data_loader_list", "\n", "self", ".", "largest_train_dl_idx", "=", "np", ".", "argmax", "(", "\n", "[", "len", "(", "dl", ".", "indices", ")", "for", "dl", "in", "data_loader_list", "]", "\n", ")", "\n", "self", ".", "largest_dl", "=", "self", ".", "data_loader_list", "[", "self", ".", "largest_train_dl_idx", "]", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "largest_dl", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.TrainDL.__len__": [[668, 670], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "largest_dl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.TrainDL.__iter__": [[671, 677], ["zip", "itertools.cycle", "enumerate"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "train_dls", "=", "[", "\n", "dl", "if", "i", "==", "self", ".", "largest_train_dl_idx", "else", "cycle", "(", "dl", ")", "\n", "for", "i", ",", "dl", "in", "enumerate", "(", "self", ".", "data_loader_list", ")", "\n", "]", "\n", "return", "zip", "(", "*", "train_dls", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model._unpack_tensors": [[30, 35], ["tensors[].squeeze_", "tensors[].squeeze_", "tensors[].squeeze_"], "function", ["None"], ["def", "_unpack_tensors", "(", "tensors", ")", ":", "\n", "    ", "x", "=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "squeeze_", "(", "0", ")", "\n", "batch_index", "=", "tensors", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", ".", "squeeze_", "(", "0", ")", "\n", "y", "=", "tensors", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", ".", "squeeze_", "(", "0", ")", "\n", "return", "x", ",", "batch_index", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._task.GIMVITrainingPlan.__init__": [[9, 22], ["scvi.train.AdversarialTrainingPlan.__init__", "scvi.module.Classifier"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "kwargs", "[", "\"adversarial_classifier\"", "]", "is", "True", ":", "\n", "            ", "self", ".", "n_output_classifier", "=", "2", "\n", "self", ".", "adversarial_classifier", "=", "Classifier", "(", "\n", "n_input", "=", "self", ".", "module", ".", "n_latent", ",", "\n", "n_hidden", "=", "32", ",", "\n", "n_labels", "=", "self", ".", "n_output_classifier", ",", "\n", "n_layers", "=", "3", ",", "\n", "logits", "=", "True", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "adversarial_classifier", "=", "kwargs", "[", "\"adversarial_classifier\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._task.GIMVITrainingPlan.training_step": [[23, 92], ["enumerate", "sum", "sum", "sum", "enumerate", "_task.GIMVITrainingPlan.loss_adversarial_classifier", "_task.GIMVITrainingPlan.loss_kwargs.update", "dict", "dict", "_task.GIMVITrainingPlan.forward", "zs.append", "scvi_loss_objs.append", "_task.GIMVITrainingPlan.loss_adversarial_classifier", "_task.GIMVITrainingPlan.module._get_inference_input", "_task.GIMVITrainingPlan.update", "_task.GIMVITrainingPlan.module.inference", "zs.append", "torch.cat().detach", "torch.cat", "dict", "scl.reconstruction_loss.sum", "scl.kl_local.sum", "torch.zeros", "enumerate", "torch.cat", "torch.cat", "torch.zeros", "enumerate", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference"], ["", "", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "        ", "kappa", "=", "(", "\n", "1", "-", "self", ".", "kl_weight", "\n", "if", "self", ".", "scale_adversarial_loss", "==", "\"auto\"", "\n", "else", "self", ".", "scale_adversarial_loss", "\n", ")", "\n", "if", "optimizer_idx", "==", "0", ":", "\n", "# batch contains both data loader outputs", "\n", "            ", "scvi_loss_objs", "=", "[", "]", "\n", "n_obs", "=", "0", "\n", "zs", "=", "[", "]", "\n", "for", "(", "i", ",", "tensors", ")", "in", "enumerate", "(", "batch", ")", ":", "\n", "                ", "n_obs", "+=", "tensors", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "loss_kwargs", ".", "update", "(", "dict", "(", "kl_weight", "=", "self", ".", "kl_weight", ",", "mode", "=", "i", ")", ")", "\n", "inference_kwargs", "=", "dict", "(", "mode", "=", "i", ")", "\n", "generative_kwargs", "=", "dict", "(", "mode", "=", "i", ")", "\n", "inference_outputs", ",", "_", ",", "scvi_loss", "=", "self", ".", "forward", "(", "\n", "tensors", ",", "\n", "loss_kwargs", "=", "self", ".", "loss_kwargs", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", ")", "\n", "zs", ".", "append", "(", "inference_outputs", "[", "\"z\"", "]", ")", "\n", "scvi_loss_objs", ".", "append", "(", "scvi_loss", ")", "\n", "\n", "", "loss", "=", "sum", "(", "[", "scl", ".", "loss", "for", "scl", "in", "scvi_loss_objs", "]", ")", "\n", "loss", "/=", "n_obs", "\n", "rec_loss", "=", "sum", "(", "[", "scl", ".", "reconstruction_loss", ".", "sum", "(", ")", "for", "scl", "in", "scvi_loss_objs", "]", ")", "\n", "kl", "=", "sum", "(", "[", "scl", ".", "kl_local", ".", "sum", "(", ")", "for", "scl", "in", "scvi_loss_objs", "]", ")", "\n", "\n", "# fool classifier if doing adversarial training", "\n", "batch_tensor", "=", "[", "\n", "torch", ".", "zeros", "(", "(", "z", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "device", "=", "z", ".", "device", ")", "+", "i", "\n", "for", "i", ",", "z", "in", "enumerate", "(", "zs", ")", "\n", "]", "\n", "if", "kappa", ">", "0", "and", "self", ".", "adversarial_classifier", "is", "not", "False", ":", "\n", "                ", "fool_loss", "=", "self", ".", "loss_adversarial_classifier", "(", "\n", "torch", ".", "cat", "(", "zs", ")", ",", "torch", ".", "cat", "(", "batch_tensor", ")", ",", "False", "\n", ")", "\n", "loss", "+=", "fool_loss", "*", "kappa", "\n", "\n", "", "return", "{", "\n", "\"loss\"", ":", "loss", ",", "\n", "\"reconstruction_loss_sum\"", ":", "rec_loss", ",", "\n", "\"kl_local_sum\"", ":", "kl", ",", "\n", "\"kl_global\"", ":", "0.0", ",", "\n", "\"n_obs\"", ":", "n_obs", ",", "\n", "}", "\n", "\n", "# train adversarial classifier", "\n", "# this condition will not be met unless self.adversarial_classifier is not False", "\n", "", "if", "optimizer_idx", "==", "1", ":", "\n", "            ", "zs", "=", "[", "]", "\n", "for", "(", "i", ",", "tensors", ")", "in", "enumerate", "(", "batch", ")", ":", "\n", "                ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "tensors", ")", "\n", "inference_inputs", ".", "update", "(", "{", "\"mode\"", ":", "i", "}", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "zs", ".", "append", "(", "outputs", "[", "\"z\"", "]", ")", "\n", "\n", "", "batch_tensor", "=", "[", "\n", "torch", ".", "zeros", "(", "(", "z", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "device", "=", "z", ".", "device", ")", "+", "i", "\n", "for", "i", ",", "z", "in", "enumerate", "(", "zs", ")", "\n", "]", "\n", "loss", "=", "self", ".", "loss_adversarial_classifier", "(", "\n", "torch", ".", "cat", "(", "zs", ")", ".", "detach", "(", ")", ",", "torch", ".", "cat", "(", "batch_tensor", ")", ",", "True", "\n", ")", "\n", "loss", "*=", "kappa", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._task.GIMVITrainingPlan.validation_step": [[93, 109], ["_task.GIMVITrainingPlan.loss_kwargs.update", "dict", "dict", "_task.GIMVITrainingPlan.forward", "dict", "reconstruction_loss.sum", "scvi_loss.kl_local.sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "dataloader_idx", ")", ":", "\n", "        ", "self", ".", "loss_kwargs", ".", "update", "(", "dict", "(", "kl_weight", "=", "self", ".", "kl_weight", ",", "mode", "=", "dataloader_idx", ")", ")", "\n", "inference_kwargs", "=", "dict", "(", "mode", "=", "dataloader_idx", ")", "\n", "generative_kwargs", "=", "dict", "(", "mode", "=", "dataloader_idx", ")", "\n", "_", ",", "_", ",", "scvi_loss", "=", "self", ".", "forward", "(", "\n", "batch", ",", "\n", "loss_kwargs", "=", "self", ".", "loss_kwargs", ",", "\n", "inference_kwargs", "=", "inference_kwargs", ",", "\n", "generative_kwargs", "=", "generative_kwargs", ",", "\n", ")", "\n", "reconstruction_loss", "=", "scvi_loss", ".", "reconstruction_loss", "\n", "return", "{", "\n", "\"reconstruction_loss_sum\"", ":", "reconstruction_loss", ".", "sum", "(", ")", ",", "\n", "\"kl_local_sum\"", ":", "scvi_loss", ".", "kl_local", ".", "sum", "(", ")", ",", "\n", "\"kl_global\"", ":", "scvi_loss", ".", "kl_global", ",", "\n", "\"n_obs\"", ":", "reconstruction_loss", ".", "shape", "[", "0", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._task.GIMVITrainingPlan.validation_epoch_end": [[111, 125], ["_task.GIMVITrainingPlan.log", "_task.GIMVITrainingPlan.log", "_task.GIMVITrainingPlan.log", "_task.GIMVITrainingPlan.log"], "methods", ["None"], ["", "def", "validation_epoch_end", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"Aggregate validation step information.\"\"\"", "\n", "n_obs", ",", "elbo", ",", "rec_loss", ",", "kl_local", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "for", "dl_out", "in", "outputs", ":", "\n", "            ", "for", "tensors", "in", "dl_out", ":", "\n", "                ", "elbo", "+=", "tensors", "[", "\"reconstruction_loss_sum\"", "]", "+", "tensors", "[", "\"kl_local_sum\"", "]", "\n", "rec_loss", "+=", "tensors", "[", "\"reconstruction_loss_sum\"", "]", "\n", "kl_local", "+=", "tensors", "[", "\"kl_local_sum\"", "]", "\n", "n_obs", "+=", "tensors", "[", "\"n_obs\"", "]", "\n", "# kl global same for each minibatch", "\n", "", "", "self", ".", "log", "(", "\"elbo_validation\"", ",", "elbo", "/", "n_obs", ")", "\n", "self", ".", "log", "(", "\"reconstruction_loss_validation\"", ",", "rec_loss", "/", "n_obs", ")", "\n", "self", ".", "log", "(", "\"kl_local_validation\"", ",", "kl_local", "/", "n_obs", ")", "\n", "self", ".", "log", "(", "\"kl_global_validation\"", ",", "0.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.__init__": [[76, 93], ["scvi.model.base.BaseModelClass.__init__", "scvi.module.Classifier", "_model.SOLO._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_seq", ":", "AnnData", ",", "\n", "adata_spatial", ":", "AnnData", ",", "\n", "generative_distributions", ":", "List", "=", "[", "\"zinb\"", ",", "\"nb\"", "]", ",", "\n", "model_library_size", ":", "List", "=", "[", "True", ",", "False", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "GIMVI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "adata_seq", "is", "adata_spatial", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`adata_seq` and `adata_spatial` cannot point to the same object. \"", "\n", "\"If you would really like to do this, make a copy of the object and pass it in as `adata_spatial`.\"", "\n", ")", "\n", "", "self", ".", "adatas", "=", "[", "adata_seq", ",", "adata_spatial", "]", "\n", "self", ".", "adata_managers", "=", "{", "\n", "\"seq\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "adata_seq", ",", "required", "=", "True", ")", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model": [[94, 209], ["_model._validate_scvi_model", "cls.create_doublets", "scvi_model.get_latent_representation", "scvi_model.get_latent_library_size", "anndata.AnnData", "logger.info", "io.StringIO", "cls", "orig_adata_manager.get_state_registry", "orig_adata_manager.get_state_registry", "orig_adata_manager.transfer_fields", "cls.register_manager", "numpy.concatenate", "contextlib.redirect_stdout", "scvi_model.get_latent_representation", "scvi_model.get_latent_library_size", "anndata.AnnData", "anndata.AnnData.concatenate", "cls.setup_anndata", "numpy.sum", "ValueError", "numpy.where", "orig_adata_manager.get_state_registry", "numpy.concatenate", "numpy.log", "numpy.log", "adata.obs[].astype"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.solo._model._validate_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.create_doublets", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["\"spatial\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "\n", "adata_spatial", ",", "required", "=", "True", "\n", ")", ",", "\n", "}", "\n", "self", ".", "registries_", "=", "[", "]", "\n", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "_register_manager_for_instance", "(", "adm", ")", "\n", "self", ".", "registries_", ".", "append", "(", "adm", ".", "registry", ")", "\n", "\n", "", "seq_var_names", "=", "adata_seq", ".", "var_names", "\n", "spatial_var_names", "=", "adata_spatial", ".", "var_names", "\n", "\n", "if", "not", "set", "(", "spatial_var_names", ")", "<=", "set", "(", "seq_var_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"spatial genes needs to be subset of seq genes\"", ")", "\n", "\n", "", "spatial_gene_loc", "=", "[", "\n", "np", ".", "argwhere", "(", "seq_var_names", "==", "g", ")", "[", "0", "]", "for", "g", "in", "spatial_var_names", "\n", "]", "\n", "spatial_gene_loc", "=", "np", ".", "concatenate", "(", "spatial_gene_loc", ")", "\n", "gene_mappings", "=", "[", "slice", "(", "None", ")", ",", "spatial_gene_loc", "]", "\n", "sum_stats", "=", "[", "adm", ".", "summary_stats", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", "]", "\n", "n_inputs", "=", "[", "s", "[", "\"n_vars\"", "]", "for", "s", "in", "sum_stats", "]", "\n", "\n", "total_genes", "=", "n_inputs", "[", "0", "]", "\n", "\n", "# since we are combining datasets, we need to increment the batch_idx", "\n", "# of one of the datasets", "\n", "adata_seq_n_batches", "=", "sum_stats", "[", "0", "]", "[", "\"n_batch\"", "]", "\n", "adata_spatial", ".", "obs", "[", "\n", "self", ".", "adata_managers", "[", "\"spatial\"", "]", "\n", ".", "data_registry", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", ".", "attr_key", "\n", "]", "+=", "adata_seq_n_batches", "\n", "\n", "n_batches", "=", "sum", "(", "s", "[", "\"n_batch\"", "]", "for", "s", "in", "sum_stats", ")", "\n", "\n", "library_log_means", "=", "[", "]", "\n", "library_log_vars", "=", "[", "]", "\n", "for", "adata_manager", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "adata_library_log_means", ",", "adata_library_log_vars", "=", "_init_library_size", "(", "\n", "adata_manager", ",", "n_batches", "\n", ")", "\n", "library_log_means", ".", "append", "(", "adata_library_log_means", ")", "\n", "library_log_vars", ".", "append", "(", "adata_library_log_vars", ")", "\n", "\n", "", "self", ".", "module", "=", "JVAE", "(", "\n", "n_inputs", ",", "\n", "total_genes", ",", "\n", "gene_mappings", ",", "\n", "generative_distributions", ",", "\n", "model_library_size", ",", "\n", "library_log_means", ",", "\n", "library_log_vars", ",", "\n", "n_batch", "=", "n_batches", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"GimVI Model with the following params: \\nn_latent: {}, n_inputs: {}, n_genes: {}, \"", "\n", "+", "\"n_batch: {}, generative distributions: {}\"", "\n", ")", ".", "format", "(", "n_latent", ",", "n_inputs", ",", "total_genes", ",", "n_batches", ",", "generative_distributions", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n", "", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "200", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "kappa", ":", "int", "=", "5", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        kappa\n            Scaling parameter for the discriminator loss.\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        plan_kwargs\n            Keyword args for model-specific Pytorch Lightning task. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "gpus", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "self", ".", "trainer", "=", "Trainer", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "gpus", "=", "gpus", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "train_indices_", ",", "self", ".", "test_indices_", ",", "self", ".", "validation_indices_", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "train_dls", ",", "test_dls", ",", "val_dls", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "adm", "in", "enumerate", "(", "self", ".", "adata_managers", ".", "values", "(", ")", ")", ":", "\n", "            ", "ds", "=", "DataSplitter", "(", "\n", "adm", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.create_doublets": [[210, 257], ["adata_manager.get_from_registry", "numpy.random.RandomState", "numpy.random.RandomState.choice", "anndata.AnnData", "len", "range"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "train_dls", ".", "append", "(", "ds", ".", "train_dataloader", "(", ")", ")", "\n", "test_dls", ".", "append", "(", "ds", ".", "test_dataloader", "(", ")", ")", "\n", "val", "=", "ds", ".", "val_dataloader", "(", ")", "\n", "val_dls", ".", "append", "(", "val", ")", "\n", "val", ".", "mode", "=", "i", "\n", "self", ".", "train_indices_", ".", "append", "(", "ds", ".", "train_idx", ")", "\n", "self", ".", "test_indices_", ".", "append", "(", "ds", ".", "test_idx", ")", "\n", "self", ".", "validation_indices_", ".", "append", "(", "ds", ".", "val_idx", ")", "\n", "", "train_dl", "=", "TrainDL", "(", "train_dls", ")", "\n", "\n", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "self", ".", "_training_plan", "=", "GIMVITrainingPlan", "(", "\n", "self", ".", "module", ",", "\n", "adversarial_classifier", "=", "True", ",", "\n", "scale_adversarial_loss", "=", "kappa", ",", "\n", "**", "plan_kwargs", ",", "\n", ")", "\n", "\n", "if", "train_size", "==", "1.0", ":", "\n", "# circumvent the empty data loader problem if all dataset used for training", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ")", "\n", "", "else", ":", "\n", "# accepts list of val dataloaders", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ",", "val_dls", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "history_", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "history_", "=", "None", "\n", "", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "self", ".", "to_device", "(", "device", ")", "\n", "self", ".", "is_trained_", "=", "True", "\n", "\n", "", "def", "_make_scvi_dls", "(", "self", ",", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "batch_size", "=", "128", ")", ":", "\n", "        ", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "post_list", "=", "[", "self", ".", "_make_data_loader", "(", "ad", ")", "for", "ad", "in", "adatas", "]", "\n", "for", "i", ",", "dl", "in", "enumerate", "(", "post_list", ")", ":", "\n", "            ", "dl", ".", "mode", "=", "i", "\n", "\n", "", "return", "post_list", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.train": [[258, 349], ["scvi.dataloaders.DataSplitter", "scvi.train.ClassifierTrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "plan_kwargs.update", "numpy.min", "isinstance", "dict", "scvi.train.LoudEarlyStopping", "round"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return the latent space embedding for each dataset.\n\n        Parameters\n        ----------\n        adatas\n            List of adata seq and adata spatial.\n        deterministic\n            If true, use the mean of the encoder instead of a Gaussian sample.\n        batch_size\n            Minibatch size for data loading into model.\n        \"\"\"", "\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "latents", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "latent", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "latent", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_from_posterior_z", "(", "\n", "sample_batch", ",", "mode", ",", "deterministic", "=", "deterministic", "\n", ")", "\n", ")", "\n", "\n", "", "latent", "=", "torch", ".", "cat", "(", "latent", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "latents", ".", "append", "(", "latent", ")", "\n", "\n", "", "return", "latents", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_imputed_values", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "normalized", ":", "bool", "=", "True", ",", "\n", "decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return imputed values for all genes for each dataset.\n\n        Parameters\n        ----------\n        adatas\n            List of adata seq and adata spatial\n        deterministic\n            If true, use the mean of the encoder instead of a Gaussian sample for the latent vector.\n        normalized\n            Return imputed normalized values or not.\n        decode_mode\n            If a `decode_mode` is given, use the encoder specific to each dataset as usual but use\n            the decoder of the dataset of id `decode_mode` to impute values.\n        batch_size\n            Minibatch size for data loading into model.\n        \"\"\"", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "imputed_values", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "imputed_value", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "if", "normalized", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_scale", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.predict": [[350, 400], ["torch.no_grad", "_model.SOLO._validate_anndata", "_model.SOLO._make_data_loader", "enumerate", "torch.cat().numpy", "_model.SOLO.adata.obs[].values.ravel", "pandas.DataFrame", "module", "_model.SOLO.predict.auto_forward"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module"], ["", "else", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_rate", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n", "\n", "", "", "imputed_value", "=", "torch", ".", "cat", "(", "imputed_value", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "imputed_values", ".", "append", "(", "imputed_value", ")", "\n", "\n", "", "return", "imputed_values", "\n", "\n", "", "def", "save", "(", "\n", "self", ",", "\n", "dir_path", ":", "str", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "overwrite", ":", "bool", "=", "False", ",", "\n", "save_anndata", ":", "bool", "=", "False", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Save the state of the model.\n\n        Neither the trainer optimizer state nor the trainer history are saved.\n        Model files are not expected to be reproducibly saved and loaded across versions\n        until we reach version 1.0.\n\n        Parameters\n        ----------\n        dir_path\n            Path to a directory.\n        prefix\n            Prefix to prepend to saved file names.\n        overwrite\n            Overwrite existing data or not. If `False` and directory\n            already exists at `dir_path`, error will be raised.\n        save_anndata\n            If True, also saves the anndata\n        anndata_write_kwargs\n            Kwargs for anndata write function\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.setup_anndata": [[401, 428], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "\n", "seq_adata", "=", "self", ".", "adatas", "[", "0", "]", "\n", "spatial_adata", "=", "self", ".", "adatas", "[", "1", "]", "\n", "if", "save_anndata", ":", "\n", "            ", "seq_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}adata_seq.h5ad\"", ")", "\n", "seq_adata", ".", "write", "(", "seq_save_path", ")", "\n", "\n", "spatial_save_path", "=", "os", ".", "path", ".", "join", "(", "\n", "dir_path", ",", "f\"{file_name_prefix}adata_spatial.h5ad\"", "\n", ")", "\n", "spatial_adata", ".", "write", "(", "spatial_save_path", ")", "\n", "\n", "# save the model state dict and the trainer state dict only", "\n", "", "model_state_dict", "=", "self", ".", "module", ".", "state_dict", "(", ")", "\n", "\n", "seq_var_names", "=", "seq_adata", ".", "var_names", ".", "astype", "(", "str", ")", ".", "to_numpy", "(", ")", "\n", "spatial_var_names", "=", "spatial_adata", ".", "var_names", ".", "astype", "(", "str", ")", ".", "to_numpy", "(", ")", "\n", "\n", "# get all the user attributes", "\n", "user_attributes", "=", "self", ".", "_get_user_attributes", "(", ")", "\n", "# only save the public attributes with _ at the very end", "\n", "user_attributes", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "user_attributes", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model._validate_scvi_model": [[430, 435], ["warnings.warn"], "function", ["None"], ["\n", "torch", ".", "save", "(", "\n", "dict", "(", "\n", "model_state_dict", "=", "model_state_dict", ",", "\n", "seq_var_names", "=", "seq_var_names", ",", "\n", "spatial_var_names", "=", "spatial_var_names", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.__init__": [[29, 50], ["scvi.module.base.BaseModuleClass.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "_module.RNADeconv.register_buffer", "torch.randn", "torch.randn", "torch.tensor", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.get_params": [[51, 62], ["torch.no_grad", "_module.RNADeconv.W.cpu().numpy", "_module.RNADeconv.px_o.cpu().numpy", "_module.RNADeconv.W.cpu", "_module.RNADeconv.px_o.cpu"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv._get_inference_input": [[63, 66], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv._get_generative_input": [[67, 73], ["dict"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.inference": [[74, 77], ["None"], "methods", ["None"], ["\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.generative": [[78, 94], ["torch.sum", "dict", "torch.nn.functional.softplus", "y.long().ravel", "y.long().ravel", "y.long", "y.long"], "methods", ["None"], ["\n", "def", "__init__", "(", "\n", "self", ",", "\n", "dim_input_list", ":", "List", "[", "int", "]", ",", "\n", "total_genes", ":", "int", ",", "\n", "indices_mappings", ":", "List", "[", "Union", "[", "np", ".", "ndarray", ",", "slice", "]", "]", ",", "\n", "gene_likelihoods", ":", "List", "[", "str", "]", ",", "\n", "model_library_bools", ":", "List", "[", "bool", "]", ",", "\n", "library_log_means", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "library_log_vars", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers_encoder_individual", ":", "int", "=", "1", ",", "\n", "n_layers_encoder_shared", ":", "int", "=", "1", ",", "\n", "dim_hidden_encoder", ":", "int", "=", "64", ",", "\n", "n_layers_decoder_individual", ":", "int", "=", "0", ",", "\n", "n_layers_decoder_shared", ":", "int", "=", "0", ",", "\n", "dim_hidden_decoder_individual", ":", "int", "=", "64", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.loss": [[96, 112], ["torch.sum", "scvi.module.base.LossRecorder", "torch.distributions.NegativeBinomial().log_prob().sum", "torch.zeros", "torch.tensor", "torch.distributions.NegativeBinomial().log_prob", "torch.distributions.NegativeBinomial"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["dropout_rate_encoder", ":", "float", "=", "0.2", ",", "\n", "dropout_rate_decoder", ":", "float", "=", "0.2", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "dispersion", ":", "str", "=", "\"gene-batch\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input_list", "=", "dim_input_list", "\n", "self", ".", "total_genes", "=", "total_genes", "\n", "self", ".", "indices_mappings", "=", "indices_mappings", "\n", "self", ".", "gene_likelihoods", "=", "gene_likelihoods", "\n", "self", ".", "model_library_bools", "=", "model_library_bools", "\n", "for", "mode", "in", "range", "(", "len", "(", "dim_input_list", ")", ")", ":", "\n", "            ", "if", "self", ".", "model_library_bools", "[", "mode", "]", ":", "\n", "                ", "self", ".", "register_buffer", "(", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.sample": [[113, 121], ["torch.no_grad", "NotImplementedError"], "methods", ["None"], ["f\"library_log_means_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_means", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "f\"library_log_vars_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_vars", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "\n", "", "", "self", ".", "n_latent", "=", "n_latent", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.__init__": [[140, 163], ["scvi.module.base.BaseModuleClass.__init__", "_module.SpatialDeconv.register_buffer", "_module.SpatialDeconv.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["self", ".", "l_encoders", "=", "ModuleList", "(", "\n", "[", "\n", "Encoder", "(", "\n", "self", ".", "n_input_list", "[", "i", "]", ",", "\n", "1", ",", "\n", "n_layers", "=", "1", ",", "\n", "dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "if", "self", ".", "model_library_bools", "[", "i", "]", "\n", "else", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "n_input_list", ")", ")", "\n", "]", "\n", ")", "\n", "\n", "self", ".", "decoder", "=", "MultiDecoder", "(", "\n", "self", ".", "n_latent", ",", "\n", "self", ".", "total_genes", ",", "\n", "n_hidden_conditioned", "=", "dim_hidden_decoder_individual", ",", "\n", "n_hidden_shared", "=", "dim_hidden_decoder_shared", ",", "\n", "n_layers_conditioned", "=", "n_layers_decoder_individual", ",", "\n", "n_layers_shared", "=", "n_layers_decoder_shared", ",", "\n", "n_cat_list", "=", "[", "self", ".", "n_batch", "]", ",", "\n", "dropout_rate", "=", "dropout_rate_decoder", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.get_proportions": [[164, 177], ["torch.no_grad", "torch.nn.functional.softplus().cpu().numpy", "res.sum().reshape", "torch.nn.functional.softplus().cpu", "res.sum", "torch.nn.functional.softplus"], "methods", ["None"], [")", "\n", "\n", "if", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_batch", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_labels", ")", ")", "\n", "", "else", ":", "# gene-cell", "\n", "            ", "pass", "\n", "\n", "", "", "def", "sample_from_posterior_z", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv._get_inference_input": [[178, 181], ["None"], "methods", ["None"], ["        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv._get_generative_input": [[182, 188], ["tensors[].long().ravel", "dict", "tensors[].long"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.inference": [[189, 192], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.generative": [[193, 212], ["torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.cat", "torch.transpose", "dict", "torch.matmul", "torch.nn.functional.softplus.unsqueeze", "torch.nn.functional.softplus.unsqueeze"], "methods", ["None"], ["\n", "if", "mode", "is", "None", ":", "\n", "            ", "if", "len", "(", "self", ".", "n_input_list", ")", "==", "1", ":", "\n", "                ", "mode", "=", "0", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Must provide a mode when having multiple datasets\"", ")", "\n", "", "", "outputs", "=", "self", ".", "inference", "(", "x", ",", "mode", ")", "\n", "qz_m", "=", "outputs", "[", "\"qz\"", "]", ".", "loc", "\n", "z", "=", "outputs", "[", "\"z\"", "]", "\n", "if", "deterministic", ":", "\n", "            ", "z", "=", "qz_m", "\n", "", "return", "z", "\n", "\n", "", "def", "sample_from_posterior_l", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.loss": [[213, 239], ["torch.zeros_like", "torch.ones_like", "scvi.module.base.LossRecorder", "torch.distributions.NegativeBinomial().log_prob().sum", "torch.distributions.Normal().log_prob().sum", "torch.zeros", "torch.sum", "torch.distributions.NegativeBinomial().log_prob", "torch.distributions.Normal().log_prob", "torch.mean", "torch.distributions.NegativeBinomial", "torch.distributions.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["\n", "_", ",", "_", ",", "_", ",", "ql_m", ",", "_", ",", "library", "=", "self", ".", "encode", "(", "x", ",", "mode", ")", "\n", "if", "deterministic", "and", "ql_m", "is", "not", "None", ":", "\n", "            ", "library", "=", "ql_m", "\n", "", "return", "library", "\n", "\n", "", "def", "sample_scale", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "mode", ":", "int", ",", "\n", "batch_index", ":", "torch", ".", "Tensor", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.sample": [[241, 249], ["torch.no_grad", "NotImplementedError"], "methods", ["None"], ["deterministic", ":", "bool", "=", "False", ",", "\n", "decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.get_ct_specific_expression": [[250, 267], ["torch.no_grad", "torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.exp().unsqueeze", "torch.nn.functional.softplus.unsqueeze", "torch.exp", "y.long().ravel", "y.long"], "methods", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.RNAStereoscope.__init__": [[41, 62], ["scvi.model.base.UnsupervisedTrainingMixin.__init__", "scvi.external.stereoscope._module.RNADeconv", "_model.RNAStereoscope._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.RNAStereoscope.train": [[63, 114], ["super().train", "plan_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "adata_seq", ":", "AnnData", ",", "\n", "adata_spatial", ":", "AnnData", ",", "\n", "generative_distributions", ":", "List", "=", "[", "\"zinb\"", ",", "\"nb\"", "]", ",", "\n", "model_library_size", ":", "List", "=", "[", "True", ",", "False", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "GIMVI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "adata_seq", "is", "adata_spatial", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`adata_seq` and `adata_spatial` cannot point to the same object. \"", "\n", "\"If you would really like to do this, make a copy of the object and pass it in as `adata_spatial`.\"", "\n", ")", "\n", "", "self", ".", "adatas", "=", "[", "adata_seq", ",", "adata_spatial", "]", "\n", "self", ".", "adata_managers", "=", "{", "\n", "\"seq\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "adata_seq", ",", "required", "=", "True", ")", ",", "\n", "\"spatial\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "\n", "adata_spatial", ",", "required", "=", "True", "\n", ")", ",", "\n", "}", "\n", "self", ".", "registries_", "=", "[", "]", "\n", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "_register_manager_for_instance", "(", "adm", ")", "\n", "self", ".", "registries_", ".", "append", "(", "adm", ".", "registry", ")", "\n", "\n", "", "seq_var_names", "=", "adata_seq", ".", "var_names", "\n", "spatial_var_names", "=", "adata_spatial", ".", "var_names", "\n", "\n", "if", "not", "set", "(", "spatial_var_names", ")", "<=", "set", "(", "seq_var_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"spatial genes needs to be subset of seq genes\"", ")", "\n", "\n", "", "spatial_gene_loc", "=", "[", "\n", "np", ".", "argwhere", "(", "seq_var_names", "==", "g", ")", "[", "0", "]", "for", "g", "in", "spatial_var_names", "\n", "]", "\n", "spatial_gene_loc", "=", "np", ".", "concatenate", "(", "spatial_gene_loc", ")", "\n", "gene_mappings", "=", "[", "slice", "(", "None", ")", ",", "spatial_gene_loc", "]", "\n", "sum_stats", "=", "[", "adm", ".", "summary_stats", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.RNAStereoscope.setup_anndata": [[116, 143], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["\n", "total_genes", "=", "n_inputs", "[", "0", "]", "\n", "\n", "# since we are combining datasets, we need to increment the batch_idx", "\n", "# of one of the datasets", "\n", "adata_seq_n_batches", "=", "sum_stats", "[", "0", "]", "[", "\"n_batch\"", "]", "\n", "adata_spatial", ".", "obs", "[", "\n", "self", ".", "adata_managers", "[", "\"spatial\"", "]", "\n", ".", "data_registry", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", ".", "attr_key", "\n", "]", "+=", "adata_seq_n_batches", "\n", "\n", "n_batches", "=", "sum", "(", "s", "[", "\"n_batch\"", "]", "for", "s", "in", "sum_stats", ")", "\n", "\n", "library_log_means", "=", "[", "]", "\n", "library_log_vars", "=", "[", "]", "\n", "for", "adata_manager", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "adata_library_log_means", ",", "adata_library_log_vars", "=", "_init_library_size", "(", "\n", "adata_manager", ",", "n_batches", "\n", ")", "\n", "library_log_means", ".", "append", "(", "adata_library_log_means", ")", "\n", "library_log_vars", ".", "append", "(", "adata_library_log_vars", ")", "\n", "\n", "", "self", ".", "module", "=", "JVAE", "(", "\n", "n_inputs", ",", "\n", "total_genes", ",", "\n", "gene_mappings", ",", "\n", "generative_distributions", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.__init__": [[184, 206], ["scvi.model.base.UnsupervisedTrainingMixin.__init__", "scvi.external.stereoscope._module.SpatialDeconv", "_model.SpatialStereoscope._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["\n", "gpus", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "self", ".", "trainer", "=", "Trainer", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "gpus", "=", "gpus", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "train_indices_", ",", "self", ".", "test_indices_", ",", "self", ".", "validation_indices_", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "train_dls", ",", "test_dls", ",", "val_dls", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "adm", "in", "enumerate", "(", "self", ".", "adata_managers", ".", "values", "(", ")", ")", ":", "\n", "            ", "ds", "=", "DataSplitter", "(", "\n", "adm", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.from_rna_model": [[207, 242], ["cls.setup_anndata", "cls", "sc_model.module.get_params", "sc_model.adata_manager.get_state_registry"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.RNADeconv.get_params", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "train_dls", ".", "append", "(", "ds", ".", "train_dataloader", "(", ")", ")", "\n", "test_dls", ".", "append", "(", "ds", ".", "test_dataloader", "(", ")", ")", "\n", "val", "=", "ds", ".", "val_dataloader", "(", ")", "\n", "val_dls", ".", "append", "(", "val", ")", "\n", "val", ".", "mode", "=", "i", "\n", "self", ".", "train_indices_", ".", "append", "(", "ds", ".", "train_idx", ")", "\n", "self", ".", "test_indices_", ".", "append", "(", "ds", ".", "test_idx", ")", "\n", "self", ".", "validation_indices_", ".", "append", "(", "ds", ".", "val_idx", ")", "\n", "", "train_dl", "=", "TrainDL", "(", "train_dls", ")", "\n", "\n", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "self", ".", "_training_plan", "=", "GIMVITrainingPlan", "(", "\n", "self", ".", "module", ",", "\n", "adversarial_classifier", "=", "True", ",", "\n", "scale_adversarial_loss", "=", "kappa", ",", "\n", "**", "plan_kwargs", ",", "\n", ")", "\n", "\n", "if", "train_size", "==", "1.0", ":", "\n", "# circumvent the empty data loader problem if all dataset used for training", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ")", "\n", "", "else", ":", "\n", "# accepts list of val dataloaders", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ",", "val_dls", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "history_", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "history_", "=", "None", "\n", "", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions": [[244, 264], ["_model.SpatialStereoscope._check_if_trained", "pandas.DataFrame", "column_names.append.append.append", "_model.SpatialStereoscope.module.get_proportions"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions"], ["self", ".", "is_trained_", "=", "True", "\n", "\n", "", "def", "_make_scvi_dls", "(", "self", ",", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "batch_size", "=", "128", ")", ":", "\n", "        ", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "post_list", "=", "[", "self", ".", "_make_data_loader", "(", "ad", ")", "for", "ad", "in", "adatas", "]", "\n", "for", "i", ",", "dl", "in", "enumerate", "(", "post_list", ")", ":", "\n", "            ", "dl", ".", "mode", "=", "i", "\n", "\n", "", "return", "post_list", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_scale_for_ct": [[266, 289], ["_model.SpatialStereoscope._check_if_trained", "numpy.array", "_model.SpatialStereoscope.module.get_ct_specific_expression", "numpy.array", "ValueError", "_model.SpatialStereoscope.cpu", "torch.tensor", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._check_if_trained", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._module.SpatialDeconv.get_ct_specific_expression"], ["\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "latents", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "latent", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "latent", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_from_posterior_z", "(", "\n", "sample_batch", ",", "mode", ",", "deterministic", "=", "deterministic", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.train": [[290, 334], ["super().train", "plan_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], [")", "\n", "\n", "", "latent", "=", "torch", ".", "cat", "(", "latent", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "latents", ".", "append", "(", "latent", ")", "\n", "\n", "", "return", "latents", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_imputed_values", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "normalized", ":", "bool", "=", "True", ",", "\n", "decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Return imputed values for all genes for each dataset.\n\n        Parameters\n        ----------\n        adatas\n            List of adata seq and adata spatial\n        deterministic\n            If true, use the mean of the encoder instead of a Gaussian sample for the latent vector.\n        normalized\n            Return imputed normalized values or not.\n        decode_mode\n            If a `decode_mode` is given, use the encoder specific to each dataset as usual but use\n            the decoder of the dataset of id `decode_mode` to impute values.\n        batch_size\n            Minibatch size for data loading into model.\n        \"\"\"", "\n", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n", "\n", "imputed_values", "=", "[", "]", "\n", "for", "mode", ",", "scdl", "in", "enumerate", "(", "scdls", ")", ":", "\n", "            ", "imputed_value", "=", "[", "]", "\n", "for", "tensors", "in", "scdl", ":", "\n", "                ", "(", "\n", "sample_batch", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.setup_anndata": [[336, 363], ["cls._get_setup_method_args", "numpy.arange", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.NumericalObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["label", ",", "\n", "*", "_", ",", "\n", ")", "=", "_unpack_tensors", "(", "tensors", ")", "\n", "if", "normalized", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_scale", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "imputed_value", ".", "append", "(", "\n", "self", ".", "module", ".", "sample_rate", "(", "\n", "sample_batch", ",", "\n", "mode", ",", "\n", "batch_index", ",", "\n", "label", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "decode_mode", "=", "decode_mode", ",", "\n", ")", "\n", ")", "\n", "\n", "", "", "imputed_value", "=", "torch", ".", "cat", "(", "imputed_value", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "imputed_values", ".", "append", "(", "imputed_value", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.__init__": [[45, 108], ["scvi.module.base.BaseModuleClass.__init__", "_module.CellAssignModule.register_buffer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "_module.CellAssignModule.register_buffer", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "_module.CellAssignModule.register_buffer", "sum", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.FloatTensor().uniform_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "sum", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "dim_input_list", ":", "List", "[", "int", "]", ",", "\n", "total_genes", ":", "int", ",", "\n", "indices_mappings", ":", "List", "[", "Union", "[", "np", ".", "ndarray", ",", "slice", "]", "]", ",", "\n", "gene_likelihoods", ":", "List", "[", "str", "]", ",", "\n", "model_library_bools", ":", "List", "[", "bool", "]", ",", "\n", "library_log_means", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "library_log_vars", ":", "List", "[", "Optional", "[", "np", ".", "ndarray", "]", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers_encoder_individual", ":", "int", "=", "1", ",", "\n", "n_layers_encoder_shared", ":", "int", "=", "1", ",", "\n", "dim_hidden_encoder", ":", "int", "=", "64", ",", "\n", "n_layers_decoder_individual", ":", "int", "=", "0", ",", "\n", "n_layers_decoder_shared", ":", "int", "=", "0", ",", "\n", "dim_hidden_decoder_individual", ":", "int", "=", "64", ",", "\n", "dim_hidden_decoder_shared", ":", "int", "=", "64", ",", "\n", "dropout_rate_encoder", ":", "float", "=", "0.2", ",", "\n", "dropout_rate_decoder", ":", "float", "=", "0.2", ",", "\n", "n_batch", ":", "int", "=", "0", ",", "\n", "n_labels", ":", "int", "=", "0", ",", "\n", "dispersion", ":", "str", "=", "\"gene-batch\"", ",", "\n", "log_variational", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_input_list", "=", "dim_input_list", "\n", "self", ".", "total_genes", "=", "total_genes", "\n", "self", ".", "indices_mappings", "=", "indices_mappings", "\n", "self", ".", "gene_likelihoods", "=", "gene_likelihoods", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input": [[109, 111], ["None"], "methods", ["None"], ["self", ".", "model_library_bools", "=", "model_library_bools", "\n", "for", "mode", "in", "range", "(", "len", "(", "dim_input_list", ")", ")", ":", "\n", "            ", "if", "self", ".", "model_library_bools", "[", "mode", "]", ":", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input": [[112, 135], ["dict", "to_cat.append", "tensors.keys", "to_cat.append", "tensors.keys", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "scvi.module._utils.one_hot", "torch.split", "torch.split", "torch.split", "torch.split", "to_cat.append", "len", "scvi.module._utils.one_hot"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot"], ["                ", "self", ".", "register_buffer", "(", "\n", "f\"library_log_means_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_means", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "self", ".", "register_buffer", "(", "\n", "f\"library_log_vars_{mode}\"", ",", "\n", "torch", ".", "from_numpy", "(", "library_log_vars", "[", "mode", "]", ")", ".", "float", "(", ")", ",", "\n", ")", "\n", "\n", "", "", "self", ".", "n_latent", "=", "n_latent", "\n", "\n", "self", ".", "n_batch", "=", "n_batch", "\n", "self", ".", "n_labels", "=", "n_labels", "\n", "\n", "self", ".", "dispersion", "=", "dispersion", "\n", "self", ".", "log_variational", "=", "log_variational", "\n", "\n", "self", ".", "z_encoder", "=", "MultiEncoder", "(", "\n", "n_heads", "=", "len", "(", "dim_input_list", ")", ",", "\n", "n_input_list", "=", "dim_input_list", ",", "\n", "n_output", "=", "self", ".", "n_latent", ",", "\n", "n_hidden", "=", "dim_hidden_encoder", ",", "\n", "n_layers_individual", "=", "n_layers_encoder_individual", ",", "\n", "n_layers_shared", "=", "n_layers_encoder_shared", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference": [[136, 139], ["None"], "methods", ["None"], ["dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.generative": [[140, 203], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.log_softmax", "torch.log_softmax", "torch.log", "torch.log", "torch.log", "torch.log", "base_mean.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "_module.CellAssignModule.b_g_0.unsqueeze().expand", "delta_rho.expand.expand.expand", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "a.expand.expand.expand", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "b.expand.expand.expand", "torch.exp.unsqueeze().expand", "torch.exp.unsqueeze().expand", "_module.CellAssignModule.basis_means.expand", "scvi.distributions.NegativeBinomial", "x.unsqueeze().expand", "scvi.distributions.NegativeBinomial.log_prob", "theta_log.expand.expand.expand", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "normalizer_over_c.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "dict", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.transpose().unsqueeze", "torch.transpose().unsqueeze", "torch.transpose().unsqueeze", "torch.transpose().unsqueeze", "covariates.expand.expand.expand", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "base_mean.unsqueeze().expand.unsqueeze().expand.unsqueeze", "_module.CellAssignModule.b_g_0.unsqueeze", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.exp.unsqueeze", "torch.exp.unsqueeze", "x.unsqueeze", "normalizer_over_c.unsqueeze().expand.unsqueeze().expand.unsqueeze", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.log", "torch.log", "torch.log", "torch.log", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.square", "torch.square", "torch.square", "torch.square"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob"], ["self", ".", "l_encoders", "=", "ModuleList", "(", "\n", "[", "\n", "Encoder", "(", "\n", "self", ".", "n_input_list", "[", "i", "]", ",", "\n", "1", ",", "\n", "n_layers", "=", "1", ",", "\n", "dropout_rate", "=", "dropout_rate_encoder", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "if", "self", ".", "model_library_bools", "[", "i", "]", "\n", "else", "None", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "n_input_list", ")", ")", "\n", "]", "\n", ")", "\n", "\n", "self", ".", "decoder", "=", "MultiDecoder", "(", "\n", "self", ".", "n_latent", ",", "\n", "self", ".", "total_genes", ",", "\n", "n_hidden_conditioned", "=", "dim_hidden_decoder_individual", ",", "\n", "n_hidden_shared", "=", "dim_hidden_decoder_shared", ",", "\n", "n_layers_conditioned", "=", "n_layers_decoder_individual", ",", "\n", "n_layers_shared", "=", "n_layers_decoder_shared", ",", "\n", "n_cat_list", "=", "[", "self", ".", "n_batch", "]", ",", "\n", "dropout_rate", "=", "dropout_rate_decoder", ",", "\n", ")", "\n", "\n", "if", "self", ".", "dispersion", "==", "\"gene\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-batch\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_batch", ")", ")", "\n", "", "elif", "self", ".", "dispersion", "==", "\"gene-label\"", ":", "\n", "            ", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "total_genes", ",", "n_labels", ")", ")", "\n", "", "else", ":", "# gene-cell", "\n", "            ", "pass", "\n", "\n", "", "", "def", "sample_from_posterior_z", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Sample tensor of latent values from the posterior.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n        mode\n            head id to use in the encoder\n        deterministic\n            bool - whether to sample or not\n\n        Returns\n        -------\n        type\n            tensor of shape ``(batch_size, n_latent)``\n\n        \"\"\"", "\n", "if", "mode", "is", "None", ":", "\n", "            ", "if", "len", "(", "self", ".", "n_input_list", ")", "==", "1", ":", "\n", "                ", "mode", "=", "0", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\"Must provide a mode when having multiple datasets\"", ")", "\n", "", "", "outputs", "=", "self", ".", "inference", "(", "x", ",", "mode", ")", "\n", "qz_m", "=", "outputs", "[", "\"qz\"", "]", ".", "loc", "\n", "z", "=", "outputs", "[", "\"z\"", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss": [[205, 240], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.log_softmax", "torch.log_softmax", "torch.distributions.Dirichlet", "torch.distributions.Dirichlet", "torch.distributions.Normal", "torch.distributions.Normal", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "scvi.module.base.LossRecorder", "torch.distributions.Dirichlet.log_prob", "torch.distributions.Dirichlet.log_prob", "_module.CellAssignModule.delta_log_log_scale.exp().sqrt", "torch.distributions.Normal.log_prob", "torch.distributions.Normal.log_prob", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "_module.CellAssignModule.delta_log_log_scale.exp", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["            ", "z", "=", "qz_m", "\n", "", "return", "z", "\n", "\n", "", "def", "sample_from_posterior_l", "(", "\n", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "mode", ":", "int", "=", "None", ",", "deterministic", ":", "bool", "=", "False", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Sample the tensor of library sizes from the posterior.\n\n        Parameters\n        ----------\n        x\n            tensor of values with shape ``(batch_size, n_input)``\n            or ``(batch_size, n_input_fish)`` depending on the mode\n        mode\n            head id to use in the encoder\n        deterministic\n            bool - whether to sample or not\n\n        Returns\n        -------\n        type\n            tensor of shape ``(batch_size, 1)``\n\n        \"\"\"", "\n", "_", ",", "_", ",", "_", ",", "ql_m", ",", "_", ",", "library", "=", "self", ".", "encode", "(", "x", ",", "mode", ")", "\n", "if", "deterministic", "and", "ql_m", "is", "not", "None", ":", "\n", "            ", "library", "=", "ql_m", "\n", "", "return", "library", "\n", "\n", "", "def", "sample_scale", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "mode", ":", "int", ",", "\n", "batch_index", ":", "torch", ".", "Tensor", ",", "\n", "y", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.sample": [[242, 250], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "NotImplementedError"], "methods", ["None"], ["decode_mode", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.__init__": [[63, 114], ["scvi.model.base.UnsupervisedTrainingMixin.__init__", "torch.Tensor", "_model.CellAssign._validate_anndata", "_model.CellAssign.get_from_registry", "numpy.asarray().ravel", "torch.Tensor", "numpy.linspace", "scvi.external.cellassign._module.CellAssignModule", "_model.CellAssign._get_init_params", "cell_type_markers.to_numpy", "numpy.mean", "numpy.std", "numpy.min", "numpy.max", "locals", "KeyError", "_model.CellAssign.adata_manager.get_state_registry", "numpy.asarray", "_model.CellAssign.summary_stats.get", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "adata_seq", ":", "AnnData", ",", "\n", "adata_spatial", ":", "AnnData", ",", "\n", "generative_distributions", ":", "List", "=", "[", "\"zinb\"", ",", "\"nb\"", "]", ",", "\n", "model_library_size", ":", "List", "=", "[", "True", ",", "False", "]", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "GIMVI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "adata_seq", "is", "adata_spatial", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`adata_seq` and `adata_spatial` cannot point to the same object. \"", "\n", "\"If you would really like to do this, make a copy of the object and pass it in as `adata_spatial`.\"", "\n", ")", "\n", "", "self", ".", "adatas", "=", "[", "adata_seq", ",", "adata_spatial", "]", "\n", "self", ".", "adata_managers", "=", "{", "\n", "\"seq\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "adata_seq", ",", "required", "=", "True", ")", ",", "\n", "\"spatial\"", ":", "self", ".", "_get_most_recent_anndata_manager", "(", "\n", "adata_spatial", ",", "required", "=", "True", "\n", ")", ",", "\n", "}", "\n", "self", ".", "registries_", "=", "[", "]", "\n", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "self", ".", "_register_manager_for_instance", "(", "adm", ")", "\n", "self", ".", "registries_", ".", "append", "(", "adm", ".", "registry", ")", "\n", "\n", "", "seq_var_names", "=", "adata_seq", ".", "var_names", "\n", "spatial_var_names", "=", "adata_spatial", ".", "var_names", "\n", "\n", "if", "not", "set", "(", "spatial_var_names", ")", "<=", "set", "(", "seq_var_names", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"spatial genes needs to be subset of seq genes\"", ")", "\n", "\n", "", "spatial_gene_loc", "=", "[", "\n", "np", ".", "argwhere", "(", "seq_var_names", "==", "g", ")", "[", "0", "]", "for", "g", "in", "spatial_var_names", "\n", "]", "\n", "spatial_gene_loc", "=", "np", ".", "concatenate", "(", "spatial_gene_loc", ")", "\n", "gene_mappings", "=", "[", "slice", "(", "None", ")", ",", "spatial_gene_loc", "]", "\n", "sum_stats", "=", "[", "adm", ".", "summary_stats", "for", "adm", "in", "self", ".", "adata_managers", ".", "values", "(", ")", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict": [[115, 128], ["torch.no_grad", "_model.CellAssign._validate_anndata", "_model.CellAssign._make_data_loader", "pandas.DataFrame", "_model.CellAssign.module._get_generative_input", "_model.CellAssign.module.generative", "torch.cat().numpy", "gamma.cpu", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_generative_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.generative"], ["n_inputs", "=", "[", "s", "[", "\"n_vars\"", "]", "for", "s", "in", "sum_stats", "]", "\n", "\n", "total_genes", "=", "n_inputs", "[", "0", "]", "\n", "\n", "# since we are combining datasets, we need to increment the batch_idx", "\n", "# of one of the datasets", "\n", "adata_seq_n_batches", "=", "sum_stats", "[", "0", "]", "[", "\"n_batch\"", "]", "\n", "adata_spatial", ".", "obs", "[", "\n", "self", ".", "adata_managers", "[", "\"spatial\"", "]", "\n", ".", "data_registry", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", ".", "attr_key", "\n", "]", "+=", "adata_seq_n_batches", "\n", "\n", "n_batches", "=", "sum", "(", "s", "[", "\"n_batch\"", "]", "for", "s", "in", "sum_stats", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train": [[130, 224], ["scvi.dataloaders.DataSplitter", "scvi.train.TrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "plan_kwargs.update", "numpy.min", "isinstance", "dict", "_model.ClampCallback", "_model.ClampCallback", "scvi.train.LoudEarlyStopping", "round"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["library_log_means", "=", "[", "]", "\n", "library_log_vars", "=", "[", "]", "\n", "for", "adata_manager", "in", "self", ".", "adata_managers", ".", "values", "(", ")", ":", "\n", "            ", "adata_library_log_means", ",", "adata_library_log_vars", "=", "_init_library_size", "(", "\n", "adata_manager", ",", "n_batches", "\n", ")", "\n", "library_log_means", ".", "append", "(", "adata_library_log_means", ")", "\n", "library_log_vars", ".", "append", "(", "adata_library_log_vars", ")", "\n", "\n", "", "self", ".", "module", "=", "JVAE", "(", "\n", "n_inputs", ",", "\n", "total_genes", ",", "\n", "gene_mappings", ",", "\n", "generative_distributions", ",", "\n", "model_library_size", ",", "\n", "library_log_means", ",", "\n", "library_log_vars", ",", "\n", "n_batch", "=", "n_batches", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "**", "model_kwargs", ",", "\n", ")", "\n", "\n", "self", ".", "_model_summary_string", "=", "(", "\n", "\"GimVI Model with the following params: \\nn_latent: {}, n_inputs: {}, n_genes: {}, \"", "\n", "+", "\"n_batch: {}, generative distributions: {}\"", "\n", ")", ".", "format", "(", "n_latent", ",", "n_inputs", ",", "total_genes", ",", "n_batches", ",", "generative_distributions", ")", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n", "", "def", "train", "(", "\n", "self", ",", "\n", "max_epochs", ":", "int", "=", "200", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "kappa", ":", "int", "=", "5", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "plan_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the model.\n\n        Parameters\n        ----------\n        max_epochs\n            Number of passes through the dataset. If `None`, defaults to\n            `np.min([round((20000 / n_cells) * 400), 400])`\n        use_gpu\n            Use default GPU if available (if None or True), or index of GPU to use (if int),\n            or name of GPU (if str, e.g., `'cuda:0'`), or use CPU (if False).\n        kappa\n            Scaling parameter for the discriminator loss.\n        train_size\n            Size of training set in the range [0.0, 1.0].\n        validation_size\n            Size of the test set. If `None`, defaults to 1 - `train_size`. If\n            `train_size + validation_size < 1`, the remaining cells belong to a test set.\n        batch_size\n            Minibatch size to use during training.\n        plan_kwargs\n            Keyword args for model-specific Pytorch Lightning task. Keyword arguments passed to\n            `train()` will overwrite values present in `plan_kwargs`, when appropriate.\n        **kwargs\n            Other keyword args for :class:`~scvi.train.Trainer`.\n        \"\"\"", "\n", "gpus", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "\n", "self", ".", "trainer", "=", "Trainer", "(", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "gpus", "=", "gpus", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "train_indices_", ",", "self", ".", "test_indices_", ",", "self", ".", "validation_indices_", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "train_dls", ",", "test_dls", ",", "val_dls", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "adm", "in", "enumerate", "(", "self", ".", "adata_managers", ".", "values", "(", ")", ")", ":", "\n", "            ", "ds", "=", "DataSplitter", "(", "\n", "adm", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "train_dls", ".", "append", "(", "ds", ".", "train_dataloader", "(", ")", ")", "\n", "test_dls", ".", "append", "(", "ds", ".", "test_dataloader", "(", ")", ")", "\n", "val", "=", "ds", ".", "val_dataloader", "(", ")", "\n", "val_dls", ".", "append", "(", "val", ")", "\n", "val", ".", "mode", "=", "i", "\n", "self", ".", "train_indices_", ".", "append", "(", "ds", ".", "train_idx", ")", "\n", "self", ".", "test_indices_", ".", "append", "(", "ds", ".", "test_idx", ")", "\n", "self", ".", "validation_indices_", ".", "append", "(", "ds", ".", "val_idx", ")", "\n", "", "train_dl", "=", "TrainDL", "(", "train_dls", ")", "\n", "\n", "plan_kwargs", "=", "plan_kwargs", "if", "isinstance", "(", "plan_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "self", ".", "_training_plan", "=", "GIMVITrainingPlan", "(", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.setup_anndata": [[225, 266], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.NumericalObsField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["self", ".", "module", ",", "\n", "adversarial_classifier", "=", "True", ",", "\n", "scale_adversarial_loss", "=", "kappa", ",", "\n", "**", "plan_kwargs", ",", "\n", ")", "\n", "\n", "if", "train_size", "==", "1.0", ":", "\n", "# circumvent the empty data loader problem if all dataset used for training", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ")", "\n", "", "else", ":", "\n", "# accepts list of val dataloaders", "\n", "            ", "self", ".", "trainer", ".", "fit", "(", "self", ".", "_training_plan", ",", "train_dl", ",", "val_dls", ")", "\n", "", "try", ":", "\n", "            ", "self", ".", "history_", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "", "except", "AttributeError", ":", "\n", "            ", "self", ".", "history_", "=", "None", "\n", "", "self", ".", "module", ".", "eval", "(", ")", "\n", "\n", "self", ".", "to_device", "(", "device", ")", "\n", "self", ".", "is_trained_", "=", "True", "\n", "\n", "", "def", "_make_scvi_dls", "(", "self", ",", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "batch_size", "=", "128", ")", ":", "\n", "        ", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "post_list", "=", "[", "self", ".", "_make_data_loader", "(", "ad", ")", "for", "ad", "in", "adatas", "]", "\n", "for", "i", ",", "dl", "in", "enumerate", "(", "post_list", ")", ":", "\n", "            ", "dl", ".", "mode", "=", "i", "\n", "\n", "", "return", "post_list", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_latent_representation", "(", "\n", "self", ",", "\n", "adatas", ":", "List", "[", "AnnData", "]", "=", "None", ",", "\n", "deterministic", ":", "bool", "=", "True", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.ClampCallback.__init__": [[269, 271], ["pytorch_lightning.callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.ClampCallback.on_batch_end": [[272, 276], ["super().on_batch_end", "torch.no_grad", "pl_module.module.delta_log.clamp_", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.ClampCallback.on_batch_end"], ["\n", "if", "adatas", "is", "None", ":", "\n", "            ", "adatas", "=", "self", ".", "adatas", "\n", "", "scdls", "=", "self", ".", "_make_scvi_dls", "(", "adatas", ",", "batch_size", "=", "batch_size", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.Poisson.__init__": [[258, 266], ["torch.distributions.Poisson.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "rate", ":", "torch", ".", "Tensor", ",", "\n", "validate_args", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", "scale", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "rate", "=", "rate", ",", "validate_args", "=", "validate_args", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial.__init__": [[306, 336], ["torch.distributions.Distribution.__init__", "ValueError", "total_count.type_as.type_as.type_as", "torch.distributions.utils.broadcast_all", "torch.distributions.utils.broadcast_all", "_negative_binomial._convert_counts_logits_to_mean_disp", "torch.distributions.utils.broadcast_all", "torch.distributions.utils.broadcast_all", "torch.distributions.utils.probs_to_logits", "torch.distributions.utils.probs_to_logits"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._convert_counts_logits_to_mean_disp"], ["def", "__init__", "(", "\n", "self", ",", "\n", "total_count", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "probs", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "logits", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "mu", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "theta", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "scale", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "validate_args", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "self", ".", "_eps", "=", "1e-8", "\n", "if", "(", "mu", "is", "None", ")", "==", "(", "total_count", "is", "None", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Please use one of the two possible parameterizations. Refer to the documentation for more information.\"", "\n", ")", "\n", "\n", "", "using_param_1", "=", "total_count", "is", "not", "None", "and", "(", "\n", "logits", "is", "not", "None", "or", "probs", "is", "not", "None", "\n", ")", "\n", "if", "using_param_1", ":", "\n", "            ", "logits", "=", "logits", "if", "logits", "is", "not", "None", "else", "probs_to_logits", "(", "probs", ")", "\n", "total_count", "=", "total_count", ".", "type_as", "(", "logits", ")", "\n", "total_count", ",", "logits", "=", "broadcast_all", "(", "total_count", ",", "logits", ")", "\n", "mu", ",", "theta", "=", "_convert_counts_logits_to_mean_disp", "(", "total_count", ",", "logits", ")", "\n", "", "else", ":", "\n", "            ", "mu", ",", "theta", "=", "broadcast_all", "(", "mu", ",", "theta", ")", "\n", "", "self", ".", "mu", "=", "mu", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "scale", "=", "scale", "\n", "super", "(", ")", ".", "__init__", "(", "validate_args", "=", "validate_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial.mean": [[337, 340], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial.variance": [[341, 344], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "mean", "+", "(", "self", ".", "mean", "**", "2", ")", "/", "self", ".", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial.sample": [[345, 359], ["torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "_negative_binomial.NegativeBinomial._gamma", "_negative_binomial.NegativeBinomial.sample", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.distributions.Poisson.sample", "torch.distributions.Poisson.sample", "torch.distributions.Poisson", "torch.distributions.Poisson"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._gamma", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "sample", "(", "\n", "self", ",", "sample_shape", ":", "Union", "[", "torch", ".", "Size", ",", "Tuple", "]", "=", "torch", ".", "Size", "(", ")", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "gamma_d", "=", "self", ".", "_gamma", "(", ")", "\n", "p_means", "=", "gamma_d", ".", "sample", "(", "sample_shape", ")", "\n", "\n", "# Clamping as distributions objects can have buggy behaviors when", "\n", "# their parameters are too high", "\n", "l_train", "=", "torch", ".", "clamp", "(", "p_means", ",", "max", "=", "1e8", ")", "\n", "counts", "=", "PoissonTorch", "(", "\n", "l_train", "\n", ")", ".", "sample", "(", ")", "# Shape : (n_samples, n_cells_batch, n_vars)", "\n", "return", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial.log_prob": [[360, 371], ["_negative_binomial.log_nb_positive", "_negative_binomial.NegativeBinomial._validate_sample", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive"], ["", "", "def", "log_prob", "(", "self", ",", "value", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "if", "self", ".", "_validate_args", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "_validate_sample", "(", "value", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"The value argument must be within the support of the distribution\"", ",", "\n", "UserWarning", ",", "\n", ")", "\n", "\n", "", "", "return", "log_nb_positive", "(", "value", ",", "mu", "=", "self", ".", "mu", ",", "theta", "=", "self", ".", "theta", ",", "eps", "=", "self", ".", "_eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomial._gamma": [[372, 374], ["_negative_binomial.NegativeBinomial._gamma"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._gamma"], ["", "def", "_gamma", "(", "self", ")", ":", "\n", "        ", "return", "_gamma", "(", "self", ".", "theta", ",", "self", ".", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.__init__": [[418, 441], ["_negative_binomial.NegativeBinomial.__init__", "torch.distributions.utils.broadcast_all", "torch.distributions.utils.broadcast_all"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "total_count", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "probs", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "logits", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "mu", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "theta", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "zi_logits", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "scale", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "validate_args", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "total_count", "=", "total_count", ",", "\n", "probs", "=", "probs", ",", "\n", "logits", "=", "logits", ",", "\n", "mu", "=", "mu", ",", "\n", "theta", "=", "theta", ",", "\n", "scale", "=", "scale", ",", "\n", "validate_args", "=", "validate_args", ",", "\n", ")", "\n", "self", ".", "zi_logits", ",", "self", ".", "mu", ",", "self", ".", "theta", "=", "broadcast_all", "(", "\n", "zi_logits", ",", "self", ".", "mu", ",", "self", ".", "theta", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.mean": [[443, 447], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "pi", "=", "self", ".", "zi_probs", "\n", "return", "(", "1", "-", "pi", ")", "*", "self", ".", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.variance": [[448, 451], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "variance", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.zi_logits": [[452, 455], ["torch.distributions.utils.probs_to_logits", "torch.distributions.utils.probs_to_logits"], "methods", ["None"], ["", "@", "lazy_property", "\n", "def", "zi_logits", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "probs_to_logits", "(", "self", ".", "zi_probs", ",", "is_binary", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.zi_probs": [[456, 459], ["torch.distributions.utils.logits_to_probs", "torch.distributions.utils.logits_to_probs"], "methods", ["None"], ["", "@", "lazy_property", "\n", "def", "zi_probs", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "logits_to_probs", "(", "self", ".", "zi_logits", ",", "is_binary", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.sample": [[460, 468], ["torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "_negative_binomial.NegativeBinomial.sample", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "sample", "(", "\n", "self", ",", "sample_shape", ":", "Union", "[", "torch", ".", "Size", ",", "Tuple", "]", "=", "torch", ".", "Size", "(", ")", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "samp", "=", "super", "(", ")", ".", "sample", "(", "sample_shape", "=", "sample_shape", ")", "\n", "is_zero", "=", "torch", ".", "rand_like", "(", "samp", ")", "<=", "self", ".", "zi_probs", "\n", "samp", "[", "is_zero", "]", "=", "0.0", "\n", "return", "samp", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.ZeroInflatedNegativeBinomial.log_prob": [[469, 478], ["_negative_binomial.log_zinb_positive", "_negative_binomial.ZeroInflatedNegativeBinomial._validate_sample", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_zinb_positive"], ["", "", "def", "log_prob", "(", "self", ",", "value", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "_validate_sample", "(", "value", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"The value argument must be within the support of the distribution\"", ",", "\n", "UserWarning", ",", "\n", ")", "\n", "", "return", "log_zinb_positive", "(", "value", ",", "self", ".", "mu", ",", "self", ".", "theta", ",", "self", ".", "zi_logits", ",", "eps", "=", "1e-08", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.__init__": [[512, 535], ["torch.distributions.utils.broadcast_all", "torch.distributions.utils.broadcast_all", "torch.distributions.Distribution.__init__", "torch.distributions.utils.broadcast_all", "torch.distributions.utils.broadcast_all"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "mu1", ":", "torch", ".", "Tensor", ",", "\n", "mu2", ":", "torch", ".", "Tensor", ",", "\n", "theta1", ":", "torch", ".", "Tensor", ",", "\n", "mixture_logits", ":", "torch", ".", "Tensor", ",", "\n", "theta2", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "validate_args", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "\n", "        ", "(", "\n", "self", ".", "mu1", ",", "\n", "self", ".", "theta1", ",", "\n", "self", ".", "mu2", ",", "\n", "self", ".", "mixture_logits", ",", "\n", ")", "=", "broadcast_all", "(", "mu1", ",", "theta1", ",", "mu2", ",", "mixture_logits", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "validate_args", "=", "validate_args", ")", "\n", "\n", "if", "theta2", "is", "not", "None", ":", "\n", "            ", "self", ".", "theta2", "=", "broadcast_all", "(", "mu1", ",", "theta2", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "theta2", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.mean": [[536, 540], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "pi", "=", "self", ".", "mixture_probs", "\n", "return", "pi", "*", "self", ".", "mu1", "+", "(", "1", "-", "pi", ")", "*", "self", ".", "mu2", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.mixture_probs": [[541, 544], ["torch.distributions.utils.logits_to_probs", "torch.distributions.utils.logits_to_probs"], "methods", ["None"], ["", "@", "lazy_property", "\n", "def", "mixture_probs", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "return", "logits_to_probs", "(", "self", ".", "mixture_logits", ",", "is_binary", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample": [[545, 566], ["torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.distributions.Bernoulli().sample", "torch.distributions.Bernoulli().sample", "torch.distributions.Bernoulli().sample", "torch.distributions.Bernoulli().sample", "_negative_binomial._gamma", "_gamma.sample", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.distributions.Poisson.sample", "torch.distributions.Poisson.sample", "torch.distributions.Bernoulli", "torch.distributions.Bernoulli", "torch.distributions.Bernoulli", "torch.distributions.Bernoulli", "torch.distributions.Poisson", "torch.distributions.Poisson"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._gamma", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "sample", "(", "\n", "self", ",", "sample_shape", ":", "Union", "[", "torch", ".", "Size", ",", "Tuple", "]", "=", "torch", ".", "Size", "(", ")", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "pi", "=", "self", ".", "mixture_probs", "\n", "mixing_sample", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "pi", ")", ".", "sample", "(", ")", "\n", "mu", "=", "self", ".", "mu1", "*", "mixing_sample", "+", "self", ".", "mu2", "*", "(", "1", "-", "mixing_sample", ")", "\n", "if", "self", ".", "theta2", "is", "None", ":", "\n", "                ", "theta", "=", "self", ".", "theta1", "\n", "", "else", ":", "\n", "                ", "theta", "=", "self", ".", "theta1", "*", "mixing_sample", "+", "self", ".", "theta2", "*", "(", "1", "-", "mixing_sample", ")", "\n", "", "gamma_d", "=", "_gamma", "(", "mu", ",", "theta", ")", "\n", "p_means", "=", "gamma_d", ".", "sample", "(", "sample_shape", ")", "\n", "\n", "# Clamping as distributions objects can have buggy behaviors when", "\n", "# their parameters are too high", "\n", "l_train", "=", "torch", ".", "clamp", "(", "p_means", ",", "max", "=", "1e8", ")", "\n", "counts", "=", "PoissonTorch", "(", "\n", "l_train", "\n", ")", ".", "sample", "(", ")", "# Shape : (n_samples, n_cells_batch, n_features)", "\n", "return", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.log_prob": [[567, 583], ["_negative_binomial.log_mixture_nb", "_negative_binomial.NegativeBinomialMixture._validate_sample", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_mixture_nb"], ["", "", "def", "log_prob", "(", "self", ",", "value", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "_validate_sample", "(", "value", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"The value argument must be within the support of the distribution\"", ",", "\n", "UserWarning", ",", "\n", ")", "\n", "", "return", "log_mixture_nb", "(", "\n", "value", ",", "\n", "self", ".", "mu1", ",", "\n", "self", ".", "mu2", ",", "\n", "self", ".", "theta1", ",", "\n", "self", ".", "theta2", ",", "\n", "self", ".", "mixture_logits", ",", "\n", "eps", "=", "1e-08", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.__init__": [[595, 605], ["numpyro.distributions.util.promote_shapes", "numpyro.NegativeBinomial2.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "mean", ":", "jnp", ".", "ndarray", ",", "\n", "inverse_dispersion", ":", "jnp", ".", "ndarray", ",", "\n", "validate_args", ":", "Optional", "[", "bool", "]", "=", "None", ",", "\n", "eps", ":", "float", "=", "1e-8", ",", "\n", ")", ":", "\n", "        ", "self", ".", "_inverse_dispersion", ",", "self", ".", "_mean", "=", "promote_shapes", "(", "inverse_dispersion", ",", "mean", ")", "\n", "self", ".", "_eps", "=", "eps", "\n", "super", "(", ")", ".", "__init__", "(", "mean", ",", "inverse_dispersion", ",", "validate_args", "=", "validate_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean": [[606, 609], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.inverse_dispersion": [[610, 613], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "inverse_dispersion", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_inverse_dispersion", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob": [[614, 627], ["_negative_binomial.log_nb_positive"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive"], ["", "@", "validate_sample", "\n", "def", "log_prob", "(", "self", ",", "value", ")", ":", "\n", "# theta is inverse_dispersion", "\n", "        ", "theta", "=", "self", ".", "_inverse_dispersion", "\n", "mu", "=", "self", ".", "_mean", "\n", "eps", "=", "self", ".", "_eps", "\n", "return", "log_nb_positive", "(", "\n", "value", ",", "\n", "mu", ",", "\n", "theta", ",", "\n", "eps", "=", "eps", ",", "\n", "log_fn", "=", "jnp", ".", "log", ",", "\n", "lgamma_fn", "=", "jax", ".", "scipy", ".", "special", ".", "gammaln", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_zinb_positive": [[22, 72], ["torch.softplus", "torch.log", "torch.log", "torch.log", "torch.log", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "theta.view.ndimension", "theta.view.view", "torch.softplus", "torch.lgamma", "torch.lgamma", "theta.view.size", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.log", "torch.log"], "function", ["None"], ["def", "log_zinb_positive", "(", "\n", "x", ":", "torch", ".", "Tensor", ",", "mu", ":", "torch", ".", "Tensor", ",", "theta", ":", "torch", ".", "Tensor", ",", "pi", ":", "torch", ".", "Tensor", ",", "eps", "=", "1e-8", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Log likelihood (scalar) of a minibatch according to a zinb model.\n\n    Parameters\n    ----------\n    x\n        Data\n    mu\n        mean of the negative binomial (has to be positive support) (shape: minibatch x vars)\n    theta\n        inverse dispersion parameter (has to be positive support) (shape: minibatch x vars)\n    pi\n        logit of the dropout parameter (real support) (shape: minibatch x vars)\n    eps\n        numerical stability constant\n\n    Notes\n    -----\n    We parametrize the bernoulli using the logits, hence the softplus functions appearing.\n    \"\"\"", "\n", "# theta is the dispersion rate. If .ndimension() == 1, it is shared for all cells (regardless of batch or labels)", "\n", "if", "theta", ".", "ndimension", "(", ")", "==", "1", ":", "\n", "        ", "theta", "=", "theta", ".", "view", "(", "\n", "1", ",", "theta", ".", "size", "(", "0", ")", "\n", ")", "# In this case, we reshape theta for broadcasting", "\n", "\n", "", "softplus_pi", "=", "F", ".", "softplus", "(", "-", "pi", ")", "# \u00a0uses log(sigmoid(x)) = -softplus(-x)", "\n", "log_theta_eps", "=", "torch", ".", "log", "(", "theta", "+", "eps", ")", "\n", "log_theta_mu_eps", "=", "torch", ".", "log", "(", "theta", "+", "mu", "+", "eps", ")", "\n", "pi_theta_log", "=", "-", "pi", "+", "theta", "*", "(", "log_theta_eps", "-", "log_theta_mu_eps", ")", "\n", "\n", "case_zero", "=", "F", ".", "softplus", "(", "pi_theta_log", ")", "-", "softplus_pi", "\n", "mul_case_zero", "=", "torch", ".", "mul", "(", "(", "x", "<", "eps", ")", ".", "type", "(", "torch", ".", "float32", ")", ",", "case_zero", ")", "\n", "\n", "case_non_zero", "=", "(", "\n", "-", "softplus_pi", "\n", "+", "pi_theta_log", "\n", "+", "x", "*", "(", "torch", ".", "log", "(", "mu", "+", "eps", ")", "-", "log_theta_mu_eps", ")", "\n", "+", "torch", ".", "lgamma", "(", "x", "+", "theta", ")", "\n", "-", "torch", ".", "lgamma", "(", "theta", ")", "\n", "-", "torch", ".", "lgamma", "(", "x", "+", "1", ")", "\n", ")", "\n", "mul_case_non_zero", "=", "torch", ".", "mul", "(", "(", "x", ">", "eps", ")", ".", "type", "(", "torch", ".", "float32", ")", ",", "case_non_zero", ")", "\n", "\n", "res", "=", "mul_case_zero", "+", "mul_case_non_zero", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive": [[74, 108], ["log", "lgamma", "lgamma", "lgamma", "log", "log"], "function", ["None"], ["", "def", "log_nb_positive", "(", "\n", "x", ":", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ",", "\n", "mu", ":", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ",", "\n", "theta", ":", "Union", "[", "torch", ".", "Tensor", ",", "jnp", ".", "ndarray", "]", ",", "\n", "eps", ":", "float", "=", "1e-8", ",", "\n", "log_fn", ":", "callable", "=", "torch", ".", "log", ",", "\n", "lgamma_fn", ":", "callable", "=", "torch", ".", "lgamma", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Log likelihood (scalar) of a minibatch according to a nb model.\n\n    Parameters\n    ----------\n    x\n        data\n    mu\n        mean of the negative binomial (has to be positive support) (shape: minibatch x vars)\n    theta\n        inverse dispersion parameter (has to be positive support) (shape: minibatch x vars)\n    eps\n        numerical stability constant\n    \"\"\"", "\n", "log", "=", "log_fn", "\n", "lgamma", "=", "lgamma_fn", "\n", "log_theta_mu_eps", "=", "log", "(", "theta", "+", "mu", "+", "eps", ")", "\n", "res", "=", "(", "\n", "theta", "*", "(", "log", "(", "theta", "+", "eps", ")", "-", "log_theta_mu_eps", ")", "\n", "+", "x", "*", "(", "log", "(", "mu", "+", "eps", ")", "-", "log_theta_mu_eps", ")", "\n", "+", "lgamma", "(", "x", "+", "theta", ")", "\n", "-", "lgamma", "(", "theta", ")", "\n", "-", "lgamma", "(", "x", "+", "1", ")", "\n", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_mixture_nb": [[110, 181], ["torch.logsumexp", "torch.logsumexp", "torch.softplus", "_negative_binomial.log_nb_positive", "_negative_binomial.log_nb_positive", "torch.log", "torch.log", "torch.log", "torch.log", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.lgamma", "torch.stack", "torch.stack", "theta.view.ndimension", "theta.view.view", "theta.view.size", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive"], ["", "def", "log_mixture_nb", "(", "\n", "x", ":", "torch", ".", "Tensor", ",", "\n", "mu_1", ":", "torch", ".", "Tensor", ",", "\n", "mu_2", ":", "torch", ".", "Tensor", ",", "\n", "theta_1", ":", "torch", ".", "Tensor", ",", "\n", "theta_2", ":", "torch", ".", "Tensor", ",", "\n", "pi_logits", ":", "torch", ".", "Tensor", ",", "\n", "eps", "=", "1e-8", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Log likelihood (scalar) of a minibatch according to a mixture nb model.\n\n    pi_logits is the probability (logits) to be in the first component.\n    For totalVI, the first component should be background.\n\n    Parameters\n    ----------\n    x\n        Observed data\n    mu_1\n        Mean of the first negative binomial component (has to be positive support) (shape: minibatch x features)\n    mu_2\n        Mean of the second negative binomial (has to be positive support) (shape: minibatch x features)\n    theta_1\n        First inverse dispersion parameter (has to be positive support) (shape: minibatch x features)\n    theta_2\n        Second inverse dispersion parameter (has to be positive support) (shape: minibatch x features)\n        If None, assume one shared inverse dispersion parameter.\n    pi_logits\n        Probability of belonging to mixture component 1 (logits scale)\n    eps\n        Numerical stability constant\n    \"\"\"", "\n", "if", "theta_2", "is", "not", "None", ":", "\n", "        ", "log_nb_1", "=", "log_nb_positive", "(", "x", ",", "mu_1", ",", "theta_1", ")", "\n", "log_nb_2", "=", "log_nb_positive", "(", "x", ",", "mu_2", ",", "theta_2", ")", "\n", "# this is intended to reduce repeated computations", "\n", "", "else", ":", "\n", "        ", "theta", "=", "theta_1", "\n", "if", "theta", ".", "ndimension", "(", ")", "==", "1", ":", "\n", "            ", "theta", "=", "theta", ".", "view", "(", "\n", "1", ",", "theta", ".", "size", "(", "0", ")", "\n", ")", "# In this case, we reshape theta for broadcasting", "\n", "\n", "", "log_theta_mu_1_eps", "=", "torch", ".", "log", "(", "theta", "+", "mu_1", "+", "eps", ")", "\n", "log_theta_mu_2_eps", "=", "torch", ".", "log", "(", "theta", "+", "mu_2", "+", "eps", ")", "\n", "lgamma_x_theta", "=", "torch", ".", "lgamma", "(", "x", "+", "theta", ")", "\n", "lgamma_theta", "=", "torch", ".", "lgamma", "(", "theta", ")", "\n", "lgamma_x_plus_1", "=", "torch", ".", "lgamma", "(", "x", "+", "1", ")", "\n", "\n", "log_nb_1", "=", "(", "\n", "theta", "*", "(", "torch", ".", "log", "(", "theta", "+", "eps", ")", "-", "log_theta_mu_1_eps", ")", "\n", "+", "x", "*", "(", "torch", ".", "log", "(", "mu_1", "+", "eps", ")", "-", "log_theta_mu_1_eps", ")", "\n", "+", "lgamma_x_theta", "\n", "-", "lgamma_theta", "\n", "-", "lgamma_x_plus_1", "\n", ")", "\n", "log_nb_2", "=", "(", "\n", "theta", "*", "(", "torch", ".", "log", "(", "theta", "+", "eps", ")", "-", "log_theta_mu_2_eps", ")", "\n", "+", "x", "*", "(", "torch", ".", "log", "(", "mu_2", "+", "eps", ")", "-", "log_theta_mu_2_eps", ")", "\n", "+", "lgamma_x_theta", "\n", "-", "lgamma_theta", "\n", "-", "lgamma_x_plus_1", "\n", ")", "\n", "\n", "", "logsumexp", "=", "torch", ".", "logsumexp", "(", "torch", ".", "stack", "(", "(", "log_nb_1", ",", "log_nb_2", "-", "pi_logits", ")", ")", ",", "dim", "=", "0", ")", "\n", "softplus_pi", "=", "F", ".", "softplus", "(", "-", "pi_logits", ")", "\n", "\n", "log_mixture_nb", "=", "logsumexp", "-", "softplus_pi", "\n", "\n", "return", "log_mixture_nb", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._convert_mean_disp_to_counts_logits": [[183, 209], ["ValueError"], "function", ["None"], ["", "def", "_convert_mean_disp_to_counts_logits", "(", "mu", ",", "theta", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "r\"\"\"\n    NB parameterizations conversion.\n\n    Parameters\n    ----------\n    mu\n        mean of the NB distribution.\n    theta\n        inverse overdispersion.\n    eps\n        constant used for numerical log stability. (Default value = 1e-6)\n\n    Returns\n    -------\n    type\n        the number of failures until the experiment is stopped\n        and the success probability.\n    \"\"\"", "\n", "if", "not", "(", "mu", "is", "None", ")", "==", "(", "theta", "is", "None", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"If using the mu/theta NB parameterization, both parameters must be specified\"", "\n", ")", "\n", "", "logits", "=", "(", "mu", "+", "eps", ")", ".", "log", "(", ")", "-", "(", "theta", "+", "eps", ")", ".", "log", "(", ")", "\n", "total_count", "=", "theta", "\n", "return", "total_count", ",", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._convert_counts_logits_to_mean_disp": [[211, 231], ["logits.exp"], "function", ["None"], ["", "def", "_convert_counts_logits_to_mean_disp", "(", "total_count", ",", "logits", ")", ":", "\n", "    ", "\"\"\"\n    NB parameterizations conversion.\n\n    Parameters\n    ----------\n    total_count\n        Number of failures until the experiment is stopped.\n    logits\n        success logits.\n\n    Returns\n    -------\n    type\n        the mean and inverse overdispersion of the NB distribution.\n\n    \"\"\"", "\n", "theta", "=", "total_count", "\n", "mu", "=", "logits", ".", "exp", "(", ")", "*", "theta", "\n", "return", "mu", ",", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial._gamma": [[233, 239], ["torch.distributions.Gamma"], "function", ["None"], ["", "def", "_gamma", "(", "theta", ",", "mu", ")", ":", "\n", "    ", "concentration", "=", "theta", "\n", "rate", "=", "theta", "/", "mu", "\n", "# Important remark: Gamma is parametrized by the rate = 1/scale!", "\n", "gamma_d", "=", "Gamma", "(", "concentration", "=", "concentration", ",", "rate", "=", "rate", ")", "\n", "return", "gamma_d", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.__init__": [[21, 29], ["pytorch_lightning.callbacks.ProgressBarBase.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "refresh_rate", ":", "int", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "refresh_rate", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"scvi-tools progress bar only supports a value of 0 of 1 for `progress_bar_refresh_rate`\"", "\n", ")", "\n", "", "self", ".", "_refresh_rate", "=", "refresh_rate", "\n", "self", ".", "_enabled", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.__getstate__": [[30, 35], ["_progress.ProgressBar.__dict__.copy"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "# can't pickle the tqdm objects", "\n", "        ", "state", "=", "self", ".", "__dict__", ".", "copy", "(", ")", "\n", "state", "[", "\"main_progress_bar\"", "]", "=", "None", "\n", "return", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.is_enabled": [[36, 39], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_enabled", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "_enabled", "and", "self", ".", "refresh_rate", ">", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.refresh_rate": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "refresh_rate", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "self", ".", "_refresh_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.is_disabled": [[44, 47], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_disabled", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "not", "self", ".", "is_enabled", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.disable": [[48, 50], ["None"], "methods", ["None"], ["", "def", "disable", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.enable": [[51, 53], ["None"], "methods", ["None"], ["", "def", "enable", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_enabled", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.init_train_tqdm": [[54, 64], ["scvi.utils.track"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track"], ["", "def", "init_train_tqdm", "(", "self", ",", "trainer", ")", ":", "\n", "        ", "\"\"\"Override this to customize the tqdm bar for training.\"\"\"", "\n", "bar", "=", "track", "(", "\n", "None", ",", "\n", "total", "=", "trainer", ".", "max_epochs", ",", "\n", "description", "=", "\"Training\"", ",", "\n", "style", "=", "\"tqdm\"", ",", "\n", "disable", "=", "self", ".", "is_disabled", ",", "\n", ")", "\n", "return", "bar", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_sanity_check_start": [[65, 68], ["super().on_sanity_check_start", "logger.info"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_sanity_check_start"], ["", "def", "on_sanity_check_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "super", "(", ")", ".", "on_sanity_check_start", "(", "trainer", ",", "pl_module", ")", "\n", "logger", ".", "info", "(", "\"Running sanity check on val set...\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_train_start": [[69, 72], ["super().on_train_start", "_progress.ProgressBar.init_train_tqdm"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.JaxModuleInit.on_train_start", "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.init_train_tqdm"], ["", "def", "on_train_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "super", "(", ")", ".", "on_train_start", "(", "trainer", ",", "pl_module", ")", "\n", "self", ".", "main_progress_bar", "=", "self", ".", "init_train_tqdm", "(", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_train_epoch_start": [[73, 79], ["super().on_train_epoch_start", "_progress.ProgressBar._should_update", "_progress.ProgressBar.main_progress_bar.set_description"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SubSampleLabels.on_train_epoch_start", "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar._should_update"], ["", "def", "on_train_epoch_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "super", "(", ")", ".", "on_train_epoch_start", "(", "trainer", ",", "pl_module", ")", "\n", "if", "self", ".", "_should_update", "(", "self", ".", "trainer", ".", "current_epoch", ",", "self", ".", "trainer", ".", "max_epochs", ")", ":", "\n", "            ", "epoch", "=", "trainer", ".", "current_epoch", "+", "1", "\n", "self", ".", "main_progress_bar", ".", "set_description", "(", "\n", "f\"Epoch {epoch}/{trainer.max_epochs}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar._should_update": [[81, 84], ["None"], "methods", ["None"], ["", "", "def", "_should_update", "(", "self", ",", "current", ",", "total", ")", ":", "\n", "        ", "return", "self", ".", "is_enabled", "and", "(", "\n", "current", "%", "self", ".", "refresh_rate", "==", "0", "or", "current", "==", "total", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_train_epoch_end": [[86, 91], ["super().on_train_epoch_end", "_progress.ProgressBar._should_update", "_progress.ProgressBar.main_progress_bar.update", "_progress.ProgressBar.main_progress_bar.set_postfix", "_progress.ProgressBar.get_metrics"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_train_epoch_end", "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar._should_update", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "on_train_epoch_end", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "super", "(", ")", ".", "on_train_epoch_end", "(", "trainer", ",", "pl_module", ")", "\n", "if", "self", ".", "_should_update", "(", "self", ".", "trainer", ".", "current_epoch", ",", "self", ".", "trainer", ".", "max_epochs", ")", ":", "\n", "            ", "self", ".", "main_progress_bar", ".", "update", "(", ")", "\n", "self", ".", "main_progress_bar", ".", "set_postfix", "(", "self", ".", "get_metrics", "(", "trainer", ",", "pl_module", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.ProgressBar.on_train_end": [[92, 96], ["super().on_train_end", "_progress.ProgressBar.main_progress_bar.close"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.on_train_end"], ["", "", "def", "on_train_end", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "super", "(", ")", ".", "on_train_end", "(", "trainer", ",", "pl_module", ")", "\n", "if", "self", ".", "is_enabled", ":", "\n", "            ", "self", ".", "main_progress_bar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._progress.convert_inf": [[98, 103], ["float"], "function", ["None"], ["", "", "", "def", "convert_inf", "(", "x", ")", ":", "\n", "    ", "\"\"\"The tqdm doesn't support inf values. We have to convert it to None.\"\"\"", "\n", "if", "x", "==", "float", "(", "\"inf\"", ")", ":", "\n", "        ", "return", "None", "\n", "", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainrunner.TrainRunner.__init__": [[51, 67], ["scvi.model._utils.parse_use_gpu_arg", "scvi.train.Trainer"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "BaseModelClass", ",", "\n", "training_plan", ":", "pl", ".", "LightningModule", ",", "\n", "data_splitter", ":", "Union", "[", "SemiSupervisedDataSplitter", ",", "DataSplitter", "]", ",", "\n", "max_epochs", ":", "int", ",", "\n", "use_gpu", ":", "Optional", "[", "Union", "[", "str", ",", "int", ",", "bool", "]", "]", "=", "None", ",", "\n", "**", "trainer_kwargs", ",", "\n", ")", ":", "\n", "        ", "self", ".", "training_plan", "=", "training_plan", "\n", "self", ".", "data_splitter", "=", "data_splitter", "\n", "self", ".", "model", "=", "model", "\n", "gpus", ",", "device", "=", "parse_use_gpu_arg", "(", "use_gpu", ")", "\n", "self", ".", "gpus", "=", "gpus", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "trainer", "=", "Trainer", "(", "max_epochs", "=", "max_epochs", ",", "gpus", "=", "gpus", ",", "**", "trainer_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainrunner.TrainRunner.__call__": [[68, 86], ["hasattr", "hasattr", "_trainrunner.TrainRunner.trainer.fit", "_trainrunner.TrainRunner._update_history", "_trainrunner.TrainRunner.model.module.eval", "_trainrunner.TrainRunner.model.to_device"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainrunner.TrainRunner._update_history", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.model._jaxscvi.JaxSCVI.to_device"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ".", "data_splitter", ",", "\"n_train\"", ")", ":", "\n", "            ", "self", ".", "training_plan", ".", "n_obs_training", "=", "self", ".", "data_splitter", ".", "n_train", "\n", "", "if", "hasattr", "(", "self", ".", "data_splitter", ",", "\"n_val\"", ")", ":", "\n", "            ", "self", ".", "training_plan", ".", "n_obs_validation", "=", "self", ".", "data_splitter", ".", "n_val", "\n", "\n", "", "self", ".", "trainer", ".", "fit", "(", "self", ".", "training_plan", ",", "self", ".", "data_splitter", ")", "\n", "self", ".", "_update_history", "(", ")", "\n", "\n", "# data splitter only gets these attrs after fit", "\n", "self", ".", "model", ".", "train_indices", "=", "self", ".", "data_splitter", ".", "train_idx", "\n", "self", ".", "model", ".", "test_indices", "=", "self", ".", "data_splitter", ".", "test_idx", "\n", "self", ".", "model", ".", "validation_indices", "=", "self", ".", "data_splitter", ".", "val_idx", "\n", "\n", "self", ".", "model", ".", "module", ".", "eval", "(", ")", "\n", "self", ".", "model", ".", "is_trained_", "=", "True", "\n", "self", ".", "model", ".", "to_device", "(", "self", ".", "device", ")", "\n", "self", ".", "model", ".", "trainer", "=", "self", ".", "trainer", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainrunner.TrainRunner._update_history": [[87, 121], ["isinstance", "warnings.warn", "_trainrunner.TrainRunner.model.history_.items", "len", "len", "numpy.arange", "pandas.concat"], "methods", ["None"], ["", "def", "_update_history", "(", "self", ")", ":", "\n", "# model is being further trained", "\n", "# this was set to true during first training session", "\n", "        ", "if", "self", ".", "model", ".", "is_trained_", "is", "True", ":", "\n", "# if not using the default logger (e.g., tensorboard)", "\n", "            ", "if", "not", "isinstance", "(", "self", ".", "model", ".", "history_", ",", "dict", ")", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Training history cannot be updated. Logger can be accessed from model.trainer.logger\"", "\n", ")", "\n", "return", "\n", "", "else", ":", "\n", "                ", "new_history", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "for", "key", ",", "val", "in", "self", ".", "model", ".", "history_", ".", "items", "(", ")", ":", "\n", "# e.g., no validation loss due to training params", "\n", "                    ", "if", "key", "not", "in", "new_history", ":", "\n", "                        ", "continue", "\n", "", "prev_len", "=", "len", "(", "val", ")", "\n", "new_len", "=", "len", "(", "new_history", "[", "key", "]", ")", "\n", "index", "=", "np", ".", "arange", "(", "prev_len", ",", "prev_len", "+", "new_len", ")", "\n", "new_history", "[", "key", "]", ".", "index", "=", "index", "\n", "self", ".", "model", ".", "history_", "[", "key", "]", "=", "pd", ".", "concat", "(", "\n", "[", "\n", "val", ",", "\n", "new_history", "[", "key", "]", ",", "\n", "]", "\n", ")", "\n", "self", ".", "model", ".", "history_", "[", "key", "]", ".", "index", ".", "name", "=", "val", ".", "index", ".", "name", "\n", "", "", "", "else", ":", "\n", "# set history_ attribute if it exists", "\n", "# other pytorch lightning loggers might not have history attr", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "model", ".", "history_", "=", "self", ".", "trainer", ".", "logger", ".", "history", "\n", "", "except", "AttributeError", ":", "\n", "                ", "self", ".", "history_", "=", "None", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.__init__": [[29, 47], ["torchmetrics.Metric.__init__", "torch.tensor", "_metrics.ElboMetric.add_state", "_metrics.ElboMetric.add_state", "_metrics.ElboMetric.add_state"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["kmatrix_2", "=", "nne", ".", "kneighbors_graph", "(", "x2", ")", "-", "scipy", ".", "sparse", ".", "identity", "(", "n_samples", ")", "\n", "\n", "# 1 - spearman correlation from knn graphs", "\n", "spearman_correlation", "=", "scipy", ".", "stats", ".", "spearmanr", "(", "\n", "kmatrix_1", ".", "A", ".", "flatten", "(", ")", ",", "kmatrix_2", ".", "A", ".", "flatten", "(", ")", "\n", ")", "[", "0", "]", "\n", "# 2 - fold enrichment", "\n", "set_1", "=", "set", "(", "np", ".", "where", "(", "kmatrix_1", ".", "A", ".", "flatten", "(", ")", "==", "1", ")", "[", "0", "]", ")", "\n", "set_2", "=", "set", "(", "np", ".", "where", "(", "kmatrix_2", ".", "A", ".", "flatten", "(", ")", "==", "1", ")", "[", "0", "]", ")", "\n", "fold_enrichment", "=", "(", "\n", "len", "(", "set_1", ".", "intersection", "(", "set_2", ")", ")", "\n", "*", "n_samples", "**", "2", "\n", "/", "(", "float", "(", "len", "(", "set_1", ")", ")", "*", "len", "(", "set_2", ")", ")", "\n", ")", "\n", "return", "spearman_correlation", ",", "fold_enrichment", "\n", "\n", "\n", "", "def", "unsupervised_clustering_accuracy", "(", "\n", "y", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", ",", "y_pred", ":", "Union", "[", "np", ".", "ndarray", ",", "torch", ".", "Tensor", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.mode": [[48, 51], ["None"], "methods", ["None"], [")", "->", "tuple", ":", "\n", "    ", "\"\"\"Unsupervised Clustering Accuracy.\"\"\"", "\n", "if", "len", "(", "y_pred", ")", "!=", "len", "(", "y", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"len(y_pred) != len(y)\"", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.name": [[56, 59], ["None"], "methods", ["None"], ["for", "y_pred_", ",", "y_", "in", "zip", "(", "y_pred", ",", "y", ")", ":", "\n", "        ", "if", "y_", "in", "mapping", ":", "\n", "            ", "reward_matrix", "[", "mapping", "[", "y_pred_", "]", ",", "mapping", "[", "y_", "]", "]", "+=", "1", "\n", "", "", "cost_matrix", "=", "reward_matrix", ".", "max", "(", ")", "-", "reward_matrix", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.interval": [[60, 63], ["None"], "methods", ["None"], ["row_assign", ",", "col_assign", "=", "linear_sum_assignment", "(", "cost_matrix", ")", "\n", "\n", "# Construct optimal assignments matrix", "\n", "row_assign", "=", "row_assign", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "# (n,) to (n, 1) reshape", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.get_intervals_recorded": [[64, 70], ["ValueError"], "methods", ["None"], ["col_assign", "=", "col_assign", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "# (n,) to (n, 1) reshape", "\n", "assignments", "=", "np", ".", "concatenate", "(", "(", "row_assign", ",", "col_assign", ")", ",", "axis", "=", "1", ")", "\n", "\n", "optimal_reward", "=", "reward_matrix", "[", "row_assign", ",", "col_assign", "]", ".", "sum", "(", ")", "*", "1.0", "\n", "return", "optimal_reward", "/", "y_pred", ".", "size", ",", "assignments", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update": [[71, 94], ["kwargs[].detach", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "knn_purity", "(", "latent", ",", "label", ",", "n_neighbors", "=", "30", ")", ":", "\n", "    ", "nbrs", "=", "NearestNeighbors", "(", "n_neighbors", "=", "n_neighbors", "+", "1", ")", ".", "fit", "(", "latent", ")", "\n", "indices", "=", "nbrs", ".", "kneighbors", "(", "latent", ",", "return_distance", "=", "False", ")", "[", ":", ",", "1", ":", "]", "\n", "neighbors_labels", "=", "np", ".", "vectorize", "(", "lambda", "i", ":", "label", "[", "i", "]", ")", "(", "indices", ")", "\n", "\n", "# pre cell purity scores", "\n", "scores", "=", "(", "(", "neighbors_labels", "-", "label", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "==", "0", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "res", "=", "[", "\n", "np", ".", "mean", "(", "scores", "[", "label", "==", "i", "]", ")", "for", "i", "in", "np", ".", "unique", "(", "label", ")", "\n", "]", "# per cell-type purity", "\n", "\n", "return", "np", ".", "mean", "(", "res", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.compute": [[95, 97], ["_metrics.ElboMetric.get_intervals_recorded"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.get_intervals_recorded"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.__init__": [[103, 148], ["pytorch_lightning.LightningModule.__init__", "_trainingplans.TrainingPlan.initialize_train_metrics", "_trainingplans.TrainingPlan.initialize_val_metrics", "inspect.getfullargspec", "_trainingplans.TrainingPlan.loss_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_train_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_val_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "module", ":", "BaseModuleClass", ",", "\n", "lr", ":", "float", "=", "1e-3", ",", "\n", "weight_decay", ":", "float", "=", "1e-6", ",", "\n", "eps", ":", "float", "=", "0.01", ",", "\n", "optimizer", ":", "Literal", "[", "\"Adam\"", ",", "\"AdamW\"", "]", "=", "\"Adam\"", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "400", ",", "\n", "reduce_lr_on_plateau", ":", "bool", "=", "False", ",", "\n", "lr_factor", ":", "float", "=", "0.6", ",", "\n", "lr_patience", ":", "int", "=", "30", ",", "\n", "lr_threshold", ":", "float", "=", "0.0", ",", "\n", "lr_scheduler_metric", ":", "Literal", "[", "\n", "\"elbo_validation\"", ",", "\"reconstruction_loss_validation\"", ",", "\"kl_local_validation\"", "\n", "]", "=", "\"elbo_validation\"", ",", "\n", "lr_min", ":", "float", "=", "0", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "TrainingPlan", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "optimizer_name", "=", "optimizer", "\n", "self", ".", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", "\n", "self", ".", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", "\n", "self", ".", "reduce_lr_on_plateau", "=", "reduce_lr_on_plateau", "\n", "self", ".", "lr_factor", "=", "lr_factor", "\n", "self", ".", "lr_patience", "=", "lr_patience", "\n", "self", ".", "lr_scheduler_metric", "=", "lr_scheduler_metric", "\n", "self", ".", "lr_threshold", "=", "lr_threshold", "\n", "self", ".", "lr_min", "=", "lr_min", "\n", "self", ".", "loss_kwargs", "=", "loss_kwargs", "\n", "\n", "self", ".", "_n_obs_training", "=", "None", "\n", "self", ".", "_n_obs_validation", "=", "None", "\n", "\n", "# automatic handling of kl weight", "\n", "self", ".", "_loss_args", "=", "getfullargspec", "(", "self", ".", "module", ".", "loss", ")", "[", "0", "]", "\n", "if", "\"kl_weight\"", "in", "self", ".", "_loss_args", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "\n", "", "self", ".", "initialize_train_metrics", "(", ")", "\n", "self", ".", "initialize_val_metrics", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan._create_elbo_metric_components": [[149, 164], ["_metrics.ElboMetric", "_metrics.ElboMetric", "_metrics.ElboMetric", "torchmetrics.MetricCollection"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_create_elbo_metric_components", "(", "mode", ":", "str", ",", "n_total", ":", "Optional", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"Initialize ELBO metric and the metric collection.\"\"\"", "\n", "rec_loss", "=", "ElboMetric", "(", "\"reconstruction_loss\"", ",", "mode", ",", "\"obs\"", ")", "\n", "kl_local", "=", "ElboMetric", "(", "\"kl_local\"", ",", "mode", ",", "\"obs\"", ")", "\n", "kl_global", "=", "ElboMetric", "(", "\"kl_global\"", ",", "mode", ",", "\"obs\"", ")", "\n", "# n_total can be 0 if there is no validation set, this won't ever be used", "\n", "# in that case anyway", "\n", "n", "=", "1", "if", "n_total", "is", "None", "or", "n_total", "<", "1", "else", "n_total", "\n", "elbo", "=", "rec_loss", "+", "kl_local", "+", "(", "1", "/", "n", ")", "*", "kl_global", "\n", "elbo", ".", "name", "=", "f\"elbo_{mode}\"", "\n", "collection", "=", "MetricCollection", "(", "\n", "{", "metric", ".", "name", ":", "metric", "for", "metric", "in", "[", "elbo", ",", "rec_loss", ",", "kl_local", ",", "kl_global", "]", "}", "\n", ")", "\n", "return", "elbo", ",", "rec_loss", ",", "kl_local", ",", "kl_global", ",", "collection", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_train_metrics": [[165, 177], ["_trainingplans.TrainingPlan._create_elbo_metric_components", "_trainingplans.TrainingPlan.elbo_train.reset"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan._create_elbo_metric_components"], ["", "def", "initialize_train_metrics", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize train related metrics.\"\"\"", "\n", "(", "\n", "self", ".", "elbo_train", ",", "\n", "self", ".", "rec_loss_train", ",", "\n", "self", ".", "kl_local_train", ",", "\n", "self", ".", "kl_global_train", ",", "\n", "self", ".", "train_metrics", ",", "\n", ")", "=", "self", ".", "_create_elbo_metric_components", "(", "\n", "mode", "=", "\"train\"", ",", "n_total", "=", "self", ".", "n_obs_training", "\n", ")", "\n", "self", ".", "elbo_train", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_val_metrics": [[178, 190], ["_trainingplans.TrainingPlan._create_elbo_metric_components", "_trainingplans.TrainingPlan.elbo_val.reset"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan._create_elbo_metric_components"], ["", "def", "initialize_val_metrics", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize val related metrics.\"\"\"", "\n", "(", "\n", "self", ".", "elbo_val", ",", "\n", "self", ".", "rec_loss_val", ",", "\n", "self", ".", "kl_local_val", ",", "\n", "self", ".", "kl_global_val", ",", "\n", "self", ".", "val_metrics", ",", "\n", ")", "=", "self", ".", "_create_elbo_metric_components", "(", "\n", "mode", "=", "\"validation\"", ",", "n_total", "=", "self", ".", "n_obs_validation", "\n", ")", "\n", "self", ".", "elbo_val", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.n_obs_training": [[204, 210], ["_trainingplans.TrainingPlan.initialize_train_metrics", "_trainingplans.TrainingPlan.loss_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_train_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "@", "n_obs_training", ".", "setter", "\n", "def", "n_obs_training", "(", "self", ",", "n_obs", ":", "int", ")", ":", "\n", "        ", "if", "\"n_obs\"", "in", "self", ".", "_loss_args", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"n_obs\"", ":", "n_obs", "}", ")", "\n", "", "self", ".", "_n_obs_training", "=", "n_obs", "\n", "self", ".", "initialize_train_metrics", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.n_obs_validation": [[224, 228], ["_trainingplans.TrainingPlan.initialize_val_metrics"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.initialize_val_metrics"], ["", "@", "n_obs_validation", ".", "setter", "\n", "def", "n_obs_validation", "(", "self", ",", "n_obs", ":", "int", ")", ":", "\n", "        ", "self", ".", "_n_obs_validation", "=", "n_obs", "\n", "self", ".", "initialize_val_metrics", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.forward": [[229, 232], ["_trainingplans.TrainingPlan.module"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Passthrough to `model.forward()`.\"\"\"", "\n", "return", "self", ".", "module", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics": [[233, 287], ["torch.no_grad", "rec_loss.sum.sum.sum", "loss_recorder.kl_local.sum", "metrics.update", "_trainingplans.TrainingPlan.log_dict", "getattr", "isinstance", "_trainingplans.TrainingPlan.log", "met.detach.detach.detach", "torch.Size", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "compute_and_log_metrics", "(", "\n", "self", ",", "\n", "loss_recorder", ":", "LossRecorder", ",", "\n", "metrics", ":", "MetricCollection", ",", "\n", "mode", ":", "str", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Computes and logs metrics.\n\n        Parameters\n        ----------\n        loss_recorder\n            LossRecorder object from scvi-tools module\n        metric_attr_name\n            The name of the torch metric object to use\n        mode\n            Postfix string to add to the metric name of\n            extra metrics\n        \"\"\"", "\n", "rec_loss", "=", "loss_recorder", ".", "reconstruction_loss", "\n", "n_obs_minibatch", "=", "rec_loss", ".", "shape", "[", "0", "]", "\n", "rec_loss", "=", "rec_loss", ".", "sum", "(", ")", "\n", "kl_local", "=", "loss_recorder", ".", "kl_local", ".", "sum", "(", ")", "\n", "kl_global", "=", "loss_recorder", ".", "kl_global", "\n", "\n", "# use the torchmetric object for the ELBO", "\n", "metrics", ".", "update", "(", "\n", "reconstruction_loss", "=", "rec_loss", ",", "\n", "kl_local", "=", "kl_local", ",", "\n", "kl_global", "=", "kl_global", ",", "\n", "n_obs_minibatch", "=", "n_obs_minibatch", ",", "\n", ")", "\n", "# pytorch lightning handles everything with the torchmetric object", "\n", "self", ".", "log_dict", "(", "\n", "metrics", ",", "\n", "on_step", "=", "False", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "n_obs_minibatch", ",", "\n", ")", "\n", "\n", "# accumlate extra metrics passed to loss recorder", "\n", "for", "extra_metric", "in", "loss_recorder", ".", "extra_metric_attrs", ":", "\n", "            ", "met", "=", "getattr", "(", "loss_recorder", ",", "extra_metric", ")", "\n", "if", "isinstance", "(", "met", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "if", "met", ".", "shape", "!=", "torch", ".", "Size", "(", "[", "]", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Extra tracked metrics should be 0-d tensors.\"", ")", "\n", "", "met", "=", "met", ".", "detach", "(", ")", "\n", "", "self", ".", "log", "(", "\n", "f\"{extra_metric}_{mode}\"", ",", "\n", "met", ",", "\n", "on_step", "=", "False", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "n_obs_minibatch", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.training_step": [[289, 296], ["_trainingplans.TrainingPlan.forward", "_trainingplans.TrainingPlan.log", "_trainingplans.TrainingPlan.compute_and_log_metrics", "_trainingplans.TrainingPlan.loss_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "        ", "if", "\"kl_weight\"", "in", "self", ".", "loss_kwargs", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "", "_", ",", "_", ",", "scvi_loss", "=", "self", ".", "forward", "(", "batch", ",", "loss_kwargs", "=", "self", ".", "loss_kwargs", ")", "\n", "self", ".", "log", "(", "\"train_loss\"", ",", "scvi_loss", ".", "loss", ",", "on_epoch", "=", "True", ")", "\n", "self", ".", "compute_and_log_metrics", "(", "scvi_loss", ",", "self", ".", "train_metrics", ",", "\"train\"", ")", "\n", "return", "scvi_loss", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.validation_step": [[297, 304], ["_trainingplans.TrainingPlan.forward", "_trainingplans.TrainingPlan.log", "_trainingplans.TrainingPlan.compute_and_log_metrics"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "# loss kwargs here contains `n_obs` equal to n_training_obs", "\n", "# so when relevant, the actual loss value is rescaled to number", "\n", "# of training examples", "\n", "        ", "_", ",", "_", ",", "scvi_loss", "=", "self", ".", "forward", "(", "batch", ",", "loss_kwargs", "=", "self", ".", "loss_kwargs", ")", "\n", "self", ".", "log", "(", "\"validation_loss\"", ",", "scvi_loss", ".", "loss", ",", "on_epoch", "=", "True", ")", "\n", "self", ".", "compute_and_log_metrics", "(", "scvi_loss", ",", "self", ".", "val_metrics", ",", "\"validation\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.configure_optimizers": [[305, 334], ["filter", "optim_cls", "_trainingplans.TrainingPlan.module.parameters", "torch.optim.lr_scheduler.ReduceLROnPlateau", "config.update", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "params", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "module", ".", "parameters", "(", ")", ")", "\n", "if", "self", ".", "optimizer_name", "==", "\"Adam\"", ":", "\n", "            ", "optim_cls", "=", "torch", ".", "optim", ".", "Adam", "\n", "", "elif", "self", ".", "optimizer_name", "==", "\"AdamW\"", ":", "\n", "            ", "optim_cls", "=", "torch", ".", "optim", ".", "AdamW", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Optimizer not understood.\"", ")", "\n", "", "optimizer", "=", "optim_cls", "(", "\n", "params", ",", "lr", "=", "self", ".", "lr", ",", "eps", "=", "self", ".", "eps", ",", "weight_decay", "=", "self", ".", "weight_decay", "\n", ")", "\n", "config", "=", "{", "\"optimizer\"", ":", "optimizer", "}", "\n", "if", "self", ".", "reduce_lr_on_plateau", ":", "\n", "            ", "scheduler", "=", "ReduceLROnPlateau", "(", "\n", "optimizer", ",", "\n", "patience", "=", "self", ".", "lr_patience", ",", "\n", "factor", "=", "self", ".", "lr_factor", ",", "\n", "threshold", "=", "self", ".", "lr_threshold", ",", "\n", "min_lr", "=", "self", ".", "lr_min", ",", "\n", "threshold_mode", "=", "\"abs\"", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "config", ".", "update", "(", "\n", "{", "\n", "\"lr_scheduler\"", ":", "scheduler", ",", "\n", "\"monitor\"", ":", "self", ".", "lr_scheduler_metric", ",", "\n", "}", ",", "\n", ")", "\n", "", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.kl_weight": [[335, 343], ["_trainingplans._compute_kl_weight"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans._compute_kl_weight"], ["", "@", "property", "\n", "def", "kl_weight", "(", "self", ")", ":", "\n", "        ", "\"\"\"Scaling factor on KL divergence during training.\"\"\"", "\n", "return", "_compute_kl_weight", "(", "\n", "self", ".", "current_epoch", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "n_epochs_kl_warmup", ",", "\n", "self", ".", "n_steps_kl_warmup", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.__init__": [[388, 433], ["_trainingplans.TrainingPlan.__init__", "scvi.module.Classifier"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "module", ":", "BaseModuleClass", ",", "\n", "lr", "=", "1e-3", ",", "\n", "weight_decay", "=", "1e-6", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "400", ",", "\n", "reduce_lr_on_plateau", ":", "bool", "=", "False", ",", "\n", "lr_factor", ":", "float", "=", "0.6", ",", "\n", "lr_patience", ":", "int", "=", "30", ",", "\n", "lr_threshold", ":", "float", "=", "0.0", ",", "\n", "lr_scheduler_metric", ":", "Literal", "[", "\n", "\"elbo_validation\"", ",", "\"reconstruction_loss_validation\"", ",", "\"kl_local_validation\"", "\n", "]", "=", "\"elbo_validation\"", ",", "\n", "lr_min", ":", "float", "=", "0", ",", "\n", "adversarial_classifier", ":", "Union", "[", "bool", ",", "Classifier", "]", "=", "False", ",", "\n", "scale_adversarial_loss", ":", "Union", "[", "float", ",", "Literal", "[", "\"auto\"", "]", "]", "=", "\"auto\"", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "module", "=", "module", ",", "\n", "lr", "=", "lr", ",", "\n", "weight_decay", "=", "weight_decay", ",", "\n", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", ",", "\n", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", ",", "\n", "reduce_lr_on_plateau", "=", "reduce_lr_on_plateau", ",", "\n", "lr_factor", "=", "lr_factor", ",", "\n", "lr_patience", "=", "lr_patience", ",", "\n", "lr_threshold", "=", "lr_threshold", ",", "\n", "lr_scheduler_metric", "=", "lr_scheduler_metric", ",", "\n", "lr_min", "=", "lr_min", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", "\n", "if", "adversarial_classifier", "is", "True", ":", "\n", "            ", "self", ".", "n_output_classifier", "=", "self", ".", "module", ".", "n_batch", "\n", "self", ".", "adversarial_classifier", "=", "Classifier", "(", "\n", "n_input", "=", "self", ".", "module", ".", "n_latent", ",", "\n", "n_hidden", "=", "32", ",", "\n", "n_labels", "=", "self", ".", "n_output_classifier", ",", "\n", "n_layers", "=", "2", ",", "\n", "logits", "=", "True", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "adversarial_classifier", "=", "adversarial_classifier", "\n", "", "self", ".", "scale_adversarial_loss", "=", "scale_adversarial_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier": [[434, 452], ["torch.nn.LogSoftmax", "_trainingplans.AdversarialTrainingPlan.adversarial_classifier", "scvi.nn.one_hot", "scvi.nn.one_hot", "torch.zeros_like", "torch.zeros_like.masked_scatter_", "l_soft.sum().mean", "scvi.nn.one_hot.bool", "torch.ones_like", "l_soft.sum"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.nn._utils.one_hot", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "loss_adversarial_classifier", "(", "self", ",", "z", ",", "batch_index", ",", "predict_true_class", "=", "True", ")", ":", "\n", "        ", "n_classes", "=", "self", ".", "n_output_classifier", "\n", "cls_logits", "=", "torch", ".", "nn", ".", "LogSoftmax", "(", "dim", "=", "1", ")", "(", "self", ".", "adversarial_classifier", "(", "z", ")", ")", "\n", "\n", "if", "predict_true_class", ":", "\n", "            ", "cls_target", "=", "one_hot", "(", "batch_index", ",", "n_classes", ")", "\n", "", "else", ":", "\n", "            ", "one_hot_batch", "=", "one_hot", "(", "batch_index", ",", "n_classes", ")", "\n", "cls_target", "=", "torch", ".", "zeros_like", "(", "one_hot_batch", ")", "\n", "# place zeroes where true label is", "\n", "cls_target", ".", "masked_scatter_", "(", "\n", "~", "one_hot_batch", ".", "bool", "(", ")", ",", "torch", ".", "ones_like", "(", "one_hot_batch", ")", "/", "(", "n_classes", "-", "1", ")", "\n", ")", "\n", "\n", "", "l_soft", "=", "cls_logits", "*", "cls_target", "\n", "loss", "=", "-", "l_soft", ".", "sum", "(", "dim", "=", "1", ")", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.training_step": [[453, 487], ["_trainingplans.AdversarialTrainingPlan.loss_kwargs.update", "_trainingplans.AdversarialTrainingPlan.forward", "_trainingplans.AdversarialTrainingPlan.log", "_trainingplans.AdversarialTrainingPlan.compute_and_log_metrics", "_trainingplans.AdversarialTrainingPlan.module._get_inference_input", "_trainingplans.AdversarialTrainingPlan.module.inference", "_trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier", "_trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier", "z.detach"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule._get_inference_input", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.inference", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.loss_adversarial_classifier"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "        ", "if", "\"kl_weight\"", "in", "self", ".", "loss_kwargs", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "", "kappa", "=", "(", "\n", "1", "-", "self", ".", "kl_weight", "\n", "if", "self", ".", "scale_adversarial_loss", "==", "\"auto\"", "\n", "else", "self", ".", "scale_adversarial_loss", "\n", ")", "\n", "batch_tensor", "=", "batch", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", "]", "\n", "if", "optimizer_idx", "==", "0", ":", "\n", "            ", "inference_outputs", ",", "_", ",", "scvi_loss", "=", "self", ".", "forward", "(", "\n", "batch", ",", "loss_kwargs", "=", "self", ".", "loss_kwargs", "\n", ")", "\n", "loss", "=", "scvi_loss", ".", "loss", "\n", "# fool classifier if doing adversarial training", "\n", "if", "kappa", ">", "0", "and", "self", ".", "adversarial_classifier", "is", "not", "False", ":", "\n", "                ", "z", "=", "inference_outputs", "[", "\"z\"", "]", "\n", "fool_loss", "=", "self", ".", "loss_adversarial_classifier", "(", "z", ",", "batch_tensor", ",", "False", ")", "\n", "loss", "+=", "fool_loss", "*", "kappa", "\n", "\n", "", "self", ".", "log", "(", "\"train_loss\"", ",", "loss", ",", "on_epoch", "=", "True", ")", "\n", "self", ".", "compute_and_log_metrics", "(", "scvi_loss", ",", "self", ".", "train_metrics", ",", "\"train\"", ")", "\n", "return", "loss", "\n", "\n", "# train adversarial classifier", "\n", "# this condition will not be met unless self.adversarial_classifier is not False", "\n", "", "if", "optimizer_idx", "==", "1", ":", "\n", "            ", "inference_inputs", "=", "self", ".", "module", ".", "_get_inference_input", "(", "batch", ")", "\n", "outputs", "=", "self", ".", "module", ".", "inference", "(", "**", "inference_inputs", ")", "\n", "z", "=", "outputs", "[", "\"z\"", "]", "\n", "loss", "=", "self", ".", "loss_adversarial_classifier", "(", "z", ".", "detach", "(", ")", ",", "batch_tensor", ",", "True", ")", "\n", "loss", "*=", "kappa", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.AdversarialTrainingPlan.configure_optimizers": [[488, 530], ["filter", "torch.optim.Adam", "_trainingplans.AdversarialTrainingPlan.module.parameters", "torch.optim.lr_scheduler.ReduceLROnPlateau", "config1.update", "filter", "torch.optim.Adam", "_trainingplans.AdversarialTrainingPlan.adversarial_classifier.parameters", "config1.pop", "config1.pop"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "params1", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "module", ".", "parameters", "(", ")", ")", "\n", "optimizer1", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "params1", ",", "lr", "=", "self", ".", "lr", ",", "eps", "=", "0.01", ",", "weight_decay", "=", "self", ".", "weight_decay", "\n", ")", "\n", "config1", "=", "{", "\"optimizer\"", ":", "optimizer1", "}", "\n", "if", "self", ".", "reduce_lr_on_plateau", ":", "\n", "            ", "scheduler1", "=", "ReduceLROnPlateau", "(", "\n", "optimizer1", ",", "\n", "patience", "=", "self", ".", "lr_patience", ",", "\n", "factor", "=", "self", ".", "lr_factor", ",", "\n", "threshold", "=", "self", ".", "lr_threshold", ",", "\n", "min_lr", "=", "self", ".", "lr_min", ",", "\n", "threshold_mode", "=", "\"abs\"", ",", "\n", "verbose", "=", "True", ",", "\n", ")", "\n", "config1", ".", "update", "(", "\n", "{", "\n", "\"lr_scheduler\"", ":", "scheduler1", ",", "\n", "\"monitor\"", ":", "self", ".", "lr_scheduler_metric", ",", "\n", "}", ",", "\n", ")", "\n", "\n", "", "if", "self", ".", "adversarial_classifier", "is", "not", "False", ":", "\n", "            ", "params2", "=", "filter", "(", "\n", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "adversarial_classifier", ".", "parameters", "(", ")", "\n", ")", "\n", "optimizer2", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "params2", ",", "lr", "=", "1e-3", ",", "eps", "=", "0.01", ",", "weight_decay", "=", "self", ".", "weight_decay", "\n", ")", "\n", "config2", "=", "{", "\"optimizer\"", ":", "optimizer2", "}", "\n", "\n", "# bug in pytorch lightning requires this way to return", "\n", "opts", "=", "[", "config1", ".", "pop", "(", "\"optimizer\"", ")", ",", "config2", "[", "\"optimizer\"", "]", "]", "\n", "if", "\"lr_scheduler\"", "in", "config1", ":", "\n", "                ", "config1", "[", "\"scheduler\"", "]", "=", "config1", ".", "pop", "(", "\"lr_scheduler\"", ")", "\n", "scheds", "=", "[", "config1", "]", "\n", "return", "opts", ",", "scheds", "\n", "", "else", ":", "\n", "                ", "return", "opts", "\n", "\n", "", "", "return", "config1", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.SemiSupervisedTrainingPlan.__init__": [[568, 599], ["_trainingplans.TrainingPlan.__init__", "_trainingplans.SemiSupervisedTrainingPlan.loss_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "module", ":", "BaseModuleClass", ",", "\n", "classification_ratio", ":", "int", "=", "50", ",", "\n", "lr", "=", "1e-3", ",", "\n", "weight_decay", "=", "1e-6", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "400", ",", "\n", "reduce_lr_on_plateau", ":", "bool", "=", "False", ",", "\n", "lr_factor", ":", "float", "=", "0.6", ",", "\n", "lr_patience", ":", "int", "=", "30", ",", "\n", "lr_threshold", ":", "float", "=", "0.0", ",", "\n", "lr_scheduler_metric", ":", "Literal", "[", "\n", "\"elbo_validation\"", ",", "\"reconstruction_loss_validation\"", ",", "\"kl_local_validation\"", "\n", "]", "=", "\"elbo_validation\"", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "SemiSupervisedTrainingPlan", ",", "self", ")", ".", "__init__", "(", "\n", "module", "=", "module", ",", "\n", "lr", "=", "lr", ",", "\n", "weight_decay", "=", "weight_decay", ",", "\n", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", ",", "\n", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", ",", "\n", "reduce_lr_on_plateau", "=", "reduce_lr_on_plateau", ",", "\n", "lr_factor", "=", "lr_factor", ",", "\n", "lr_patience", "=", "lr_patience", ",", "\n", "lr_threshold", "=", "lr_threshold", ",", "\n", "lr_scheduler_metric", "=", "lr_scheduler_metric", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", "\n", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"classification_ratio\"", ":", "classification_ratio", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.SemiSupervisedTrainingPlan.training_step": [[600, 626], ["dict", "dict.update", "_trainingplans.SemiSupervisedTrainingPlan.forward", "_trainingplans.SemiSupervisedTrainingPlan.log", "_trainingplans.SemiSupervisedTrainingPlan.compute_and_log_metrics", "len", "_trainingplans.SemiSupervisedTrainingPlan.loss_kwargs.update", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "# Potentially dangerous if batch is from a single dataloader with two keys", "\n", "        ", "if", "len", "(", "batch", ")", "==", "2", ":", "\n", "            ", "full_dataset", "=", "batch", "[", "0", "]", "\n", "labelled_dataset", "=", "batch", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "full_dataset", "=", "batch", "\n", "labelled_dataset", "=", "None", "\n", "\n", "", "if", "\"kl_weight\"", "in", "self", ".", "loss_kwargs", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "", "input_kwargs", "=", "dict", "(", "\n", "feed_labels", "=", "False", ",", "\n", "labelled_tensors", "=", "labelled_dataset", ",", "\n", ")", "\n", "input_kwargs", ".", "update", "(", "self", ".", "loss_kwargs", ")", "\n", "_", ",", "_", ",", "scvi_losses", "=", "self", ".", "forward", "(", "full_dataset", ",", "loss_kwargs", "=", "input_kwargs", ")", "\n", "loss", "=", "scvi_losses", ".", "loss", "\n", "self", ".", "log", "(", "\n", "\"train_loss\"", ",", "\n", "loss", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "len", "(", "scvi_losses", ".", "reconstruction_loss", ")", ",", "\n", ")", "\n", "self", ".", "compute_and_log_metrics", "(", "scvi_losses", ",", "self", ".", "train_metrics", ",", "\"train\"", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.SemiSupervisedTrainingPlan.validation_step": [[627, 650], ["dict", "dict.update", "_trainingplans.SemiSupervisedTrainingPlan.forward", "_trainingplans.SemiSupervisedTrainingPlan.log", "_trainingplans.SemiSupervisedTrainingPlan.compute_and_log_metrics", "len", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.TrainingPlan.compute_and_log_metrics"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "# Potentially dangerous if batch is from a single dataloader with two keys", "\n", "        ", "if", "len", "(", "batch", ")", "==", "2", ":", "\n", "            ", "full_dataset", "=", "batch", "[", "0", "]", "\n", "labelled_dataset", "=", "batch", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "full_dataset", "=", "batch", "\n", "labelled_dataset", "=", "None", "\n", "\n", "", "input_kwargs", "=", "dict", "(", "\n", "feed_labels", "=", "False", ",", "\n", "labelled_tensors", "=", "labelled_dataset", ",", "\n", ")", "\n", "input_kwargs", ".", "update", "(", "self", ".", "loss_kwargs", ")", "\n", "_", ",", "_", ",", "scvi_losses", "=", "self", ".", "forward", "(", "full_dataset", ",", "loss_kwargs", "=", "input_kwargs", ")", "\n", "loss", "=", "scvi_losses", ".", "loss", "\n", "self", ".", "log", "(", "\n", "\"validation_loss\"", ",", "\n", "loss", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "len", "(", "scvi_losses", ".", "reconstruction_loss", ")", ",", "\n", ")", "\n", "self", ".", "compute_and_log_metrics", "(", "scvi_losses", ",", "self", ".", "val_metrics", ",", "\"validation\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.__init__": [[680, 728], ["pytorch_lightning.LightningModule.__init__", "isinstance", "pyro.infer.SVI", "isinstance", "dict", "optim_kwargs.keys", "optim_kwargs.update", "pyro.infer.Trace_ELBO", "pyro.optim.Adam", "callable", "pyro.poutine.scale", "_trainingplans.PyroTrainingPlan.__init__.scale"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "pyro_module", ":", "PyroBaseModuleClass", ",", "\n", "loss_fn", ":", "Optional", "[", "pyro", ".", "infer", ".", "ELBO", "]", "=", "None", ",", "\n", "optim", ":", "Optional", "[", "pyro", ".", "optim", ".", "PyroOptim", "]", "=", "None", ",", "\n", "optim_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "400", ",", "\n", "scale_elbo", ":", "float", "=", "1.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "pyro_module", "\n", "self", ".", "_n_obs_training", "=", "None", "\n", "\n", "optim_kwargs", "=", "optim_kwargs", "if", "isinstance", "(", "optim_kwargs", ",", "dict", ")", "else", "dict", "(", ")", "\n", "if", "\"lr\"", "not", "in", "optim_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "optim_kwargs", ".", "update", "(", "{", "\"lr\"", ":", "1e-3", "}", ")", "\n", "\n", "", "self", ".", "loss_fn", "=", "pyro", ".", "infer", ".", "Trace_ELBO", "(", ")", "if", "loss_fn", "is", "None", "else", "loss_fn", "\n", "self", ".", "optim", "=", "(", "\n", "pyro", ".", "optim", ".", "Adam", "(", "optim_args", "=", "optim_kwargs", ")", "if", "optim", "is", "None", "else", "optim", "\n", ")", "\n", "\n", "self", ".", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", "\n", "self", ".", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", "\n", "\n", "self", ".", "automatic_optimization", "=", "False", "\n", "\n", "self", ".", "use_kl_weight", "=", "False", "\n", "if", "isinstance", "(", "self", ".", "module", ".", "model", ",", "PyroModule", ")", ":", "\n", "            ", "self", ".", "use_kl_weight", "=", "(", "\n", "\"kl_weight\"", "in", "signature", "(", "self", ".", "module", ".", "model", ".", "forward", ")", ".", "parameters", "\n", ")", "\n", "\n", "", "elif", "callable", "(", "self", ".", "module", ".", "model", ")", ":", "\n", "            ", "self", ".", "use_kl_weight", "=", "\"kl_weight\"", "in", "signature", "(", "self", ".", "module", ".", "model", ")", ".", "parameters", "\n", "\n", "", "def", "scale", "(", "pyro_obj", ")", ":", "\n", "            ", "if", "scale_elbo", "==", "1", ":", "\n", "                ", "return", "pyro_obj", "\n", "", "else", ":", "\n", "                ", "return", "pyro", ".", "poutine", ".", "scale", "(", "pyro_obj", ",", "scale_elbo", ")", "\n", "\n", "", "", "self", ".", "svi", "=", "pyro", ".", "infer", ".", "SVI", "(", "\n", "model", "=", "scale", "(", "self", ".", "module", ".", "model", ")", ",", "\n", "guide", "=", "scale", "(", "self", ".", "module", ".", "guide", ")", ",", "\n", "optim", "=", "self", ".", "optim", ",", "\n", "loss", "=", "self", ".", "loss_fn", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.n_obs_training": [[740, 750], ["hasattr", "hasattr", "setattr", "setattr"], "methods", ["None"], ["", "@", "n_obs_training", ".", "setter", "\n", "def", "n_obs_training", "(", "self", ",", "n_obs", ":", "int", ")", ":", "\n", "# important for scaling log prob in Pyro plates", "\n", "        ", "if", "n_obs", "is", "not", "None", ":", "\n", "            ", "if", "hasattr", "(", "self", ".", "module", ".", "model", ",", "\"n_obs\"", ")", ":", "\n", "                ", "setattr", "(", "self", ".", "module", ".", "model", ",", "\"n_obs\"", ",", "n_obs", ")", "\n", "", "if", "hasattr", "(", "self", ".", "module", ".", "guide", ",", "\"n_obs\"", ")", ":", "\n", "                ", "setattr", "(", "self", ".", "module", ".", "guide", ",", "\"n_obs\"", ",", "n_obs", ")", "\n", "\n", "", "", "self", ".", "_n_obs_training", "=", "n_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.forward": [[751, 754], ["_trainingplans.PyroTrainingPlan.module"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Passthrough to `model.forward()`.\"\"\"", "\n", "return", "self", ".", "module", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.training_step": [[755, 765], ["_trainingplans.PyroTrainingPlan.module._get_fn_args_from_batch", "torch.Tensor", "kwargs.update", "_trainingplans.PyroTrainingPlan.svi.step"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "args", ",", "kwargs", "=", "self", ".", "module", ".", "_get_fn_args_from_batch", "(", "batch", ")", "\n", "# Set KL weight if necessary.", "\n", "# Note: if applied, ELBO loss in progress bar is the effective KL annealed loss, not the true ELBO.", "\n", "if", "self", ".", "use_kl_weight", ":", "\n", "            ", "kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "# pytorch lightning requires a Tensor object for loss", "\n", "", "loss", "=", "torch", ".", "Tensor", "(", "[", "self", ".", "svi", ".", "step", "(", "*", "args", ",", "**", "kwargs", ")", "]", ")", "\n", "\n", "return", "{", "\"loss\"", ":", "loss", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.training_epoch_end": [[766, 774], ["_trainingplans.PyroTrainingPlan.log"], "methods", ["None"], ["", "def", "training_epoch_end", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "elbo", "=", "0", "\n", "n", "=", "0", "\n", "for", "out", "in", "outputs", ":", "\n", "            ", "elbo", "+=", "out", "[", "\"loss\"", "]", "\n", "n", "+=", "1", "\n", "", "elbo", "/=", "n", "\n", "self", ".", "log", "(", "\"elbo_train\"", ",", "elbo", ",", "prog_bar", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.configure_optimizers": [[775, 777], ["None"], "methods", ["None"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.optimizer_step": [[778, 780], ["None"], "methods", ["None"], ["", "def", "optimizer_step", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.backward": [[781, 783], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.PyroTrainingPlan.kl_weight": [[784, 793], ["_trainingplans._compute_kl_weight"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans._compute_kl_weight"], ["", "@", "property", "\n", "def", "kl_weight", "(", "self", ")", ":", "\n", "        ", "\"\"\"Scaling factor on KL divergence during training.\"\"\"", "\n", "return", "_compute_kl_weight", "(", "\n", "self", ".", "current_epoch", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "n_epochs_kl_warmup", ",", "\n", "self", ".", "n_steps_kl_warmup", ",", "\n", "min_weight", "=", "1e-3", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.ClassifierTrainingPlan.__init__": [[820, 844], ["pytorch_lightning.LightningModule.__init__", "loss", "UserWarning"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._module.CellAssignModule.loss"], ["def", "__init__", "(", "\n", "self", ",", "\n", "classifier", ":", "BaseModuleClass", ",", "\n", "lr", ":", "float", "=", "1e-3", ",", "\n", "weight_decay", ":", "float", "=", "1e-6", ",", "\n", "eps", ":", "float", "=", "0.01", ",", "\n", "optimizer", ":", "Literal", "[", "\"Adam\"", ",", "\"AdamW\"", "]", "=", "\"Adam\"", ",", "\n", "data_key", ":", "str", "=", "REGISTRY_KEYS", ".", "X_KEY", ",", "\n", "labels_key", ":", "str", "=", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "\n", "loss", ":", "Callable", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "classifier", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "optimizer_name", "=", "optimizer", "\n", "self", ".", "data_key", "=", "data_key", "\n", "self", ".", "labels_key", "=", "labels_key", "\n", "self", ".", "loss_fn", "=", "loss", "(", ")", "\n", "\n", "if", "self", ".", "module", ".", "logits", "is", "False", "and", "loss", "==", "torch", ".", "nn", ".", "CrossEntropyLoss", ":", "\n", "            ", "raise", "UserWarning", "(", "\n", "\"classifier should return logits when using CrossEntropyLoss.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.ClassifierTrainingPlan.forward": [[846, 849], ["_trainingplans.ClassifierTrainingPlan.module"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module"], ["", "", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Passthrough to `model.forward()`.\"\"\"", "\n", "return", "self", ".", "module", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.ClassifierTrainingPlan.training_step": [[850, 856], ["_trainingplans.ClassifierTrainingPlan.forward", "_trainingplans.ClassifierTrainingPlan.loss_fn", "_trainingplans.ClassifierTrainingPlan.log", "batch[].view().long", "batch[].view"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ",", "optimizer_idx", "=", "0", ")", ":", "\n", "\n", "        ", "soft_prediction", "=", "self", ".", "forward", "(", "batch", "[", "self", ".", "data_key", "]", ")", "\n", "loss", "=", "self", ".", "loss_fn", "(", "soft_prediction", ",", "batch", "[", "self", ".", "labels_key", "]", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", ")", "\n", "self", ".", "log", "(", "\"train_loss\"", ",", "loss", ",", "on_epoch", "=", "True", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.ClassifierTrainingPlan.validation_step": [[857, 863], ["_trainingplans.ClassifierTrainingPlan.forward", "_trainingplans.ClassifierTrainingPlan.loss_fn", "_trainingplans.ClassifierTrainingPlan.log", "batch[].view().long", "batch[].view"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "soft_prediction", "=", "self", ".", "forward", "(", "batch", "[", "self", ".", "data_key", "]", ")", "\n", "loss", "=", "self", ".", "loss_fn", "(", "soft_prediction", ",", "batch", "[", "self", ".", "labels_key", "]", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", ")", "\n", "self", ".", "log", "(", "\"validation_loss\"", ",", "loss", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.ClassifierTrainingPlan.configure_optimizers": [[864, 877], ["filter", "optim_cls", "_trainingplans.ClassifierTrainingPlan.module.parameters", "ValueError"], "methods", ["None"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "params", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "module", ".", "parameters", "(", ")", ")", "\n", "if", "self", ".", "optimizer_name", "==", "\"Adam\"", ":", "\n", "            ", "optim_cls", "=", "torch", ".", "optim", ".", "Adam", "\n", "", "elif", "self", ".", "optimizer_name", "==", "\"AdamW\"", ":", "\n", "            ", "optim_cls", "=", "torch", ".", "optim", ".", "AdamW", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Optimizer not understood.\"", ")", "\n", "", "optimizer", "=", "optim_cls", "(", "\n", "params", ",", "lr", "=", "self", ".", "lr", ",", "eps", "=", "self", ".", "eps", ",", "weight_decay", "=", "self", ".", "weight_decay", "\n", ")", "\n", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.__init__": [[895, 921], ["pytorch_lightning.LightningModule.__init__", "dict", "inspect.signature", "_trainingplans.JaxTrainingPlan.loss_kwargs.update", "_trainingplans.JaxTrainingPlan.optim_kwargs.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "module", ":", "JaxModuleWrapper", ",", "\n", "n_steps_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "None", ",", "\n", "n_epochs_kl_warmup", ":", "Union", "[", "int", ",", "None", "]", "=", "400", ",", "\n", "optim_kwargs", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "loss_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "self", ".", "_n_obs_training", "=", "None", "\n", "self", ".", "loss_kwargs", "=", "loss_kwargs", "\n", "self", ".", "n_steps_kl_warmup", "=", "n_steps_kl_warmup", "\n", "self", ".", "n_epochs_kl_warmup", "=", "n_epochs_kl_warmup", "\n", "\n", "self", ".", "automatic_optimization", "=", "False", "\n", "\n", "# automatic handling of kl weight", "\n", "self", ".", "_loss_args", "=", "signature", "(", "self", ".", "module", ".", "loss", ")", ".", "parameters", "\n", "if", "\"kl_weight\"", "in", "self", ".", "_loss_args", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "\n", "# set optim kwargs", "\n", "", "self", ".", "optim_kwargs", "=", "dict", "(", "learning_rate", "=", "1e-3", ",", "eps", "=", "0.01", ",", "weight_decay", "=", "1e-6", ")", "\n", "if", "optim_kwargs", "is", "not", "None", ":", "\n", "            ", "self", ".", "optim_kwargs", ".", "update", "(", "optim_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.set_train_state": [[922, 941], ["_trainingplans.JaxTrainingPlan.module.train", "_trainingplans.JaxTrainingPlan.optim_kwargs.pop", "optax.chain", "scvi.module.base.TrainStateWithBatchNorm.create", "optax.additive_weight_decay", "optax.adam"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "", "def", "set_train_state", "(", "self", ",", "params", ",", "batch_stats", "=", "None", ")", ":", "\n", "        ", "self", ".", "module", ".", "train", "(", ")", "\n", "\n", "if", "self", ".", "module", ".", "train_state", "is", "not", "None", ":", "\n", "            ", "return", "\n", "\n", "", "weight_decay", "=", "self", ".", "optim_kwargs", ".", "pop", "(", "\"weight_decay\"", ")", "\n", "# replicates PyTorch Adam", "\n", "optimizer", "=", "optax", ".", "chain", "(", "\n", "optax", ".", "additive_weight_decay", "(", "weight_decay", "=", "weight_decay", ")", ",", "\n", "optax", ".", "adam", "(", "**", "self", ".", "optim_kwargs", ")", ",", "\n", ")", "\n", "train_state", "=", "TrainStateWithBatchNorm", ".", "create", "(", "\n", "apply_fn", "=", "self", ".", "module", ".", "apply", ",", "\n", "params", "=", "params", ",", "\n", "tx", "=", "optimizer", ",", "\n", "batch_stats", "=", "batch_stats", ",", "\n", ")", "\n", "self", ".", "module", ".", "train_state", "=", "train_state", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.jit_training_step": [[942, 968], ["state.apply_gradients", "state.apply_fn", "jax.mean", "jax.mean", "jax.value_and_grad", "jax.value_and_grad", "jax.value_and_grad", "jax.value_and_grad"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "staticmethod", "\n", "@", "jax", ".", "jit", "\n", "def", "jit_training_step", "(", "\n", "state", ":", "TrainStateWithBatchNorm", ",", "\n", "batch", ":", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ",", "\n", "rngs", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "# batch stats can't be passed here", "\n", "        ", "def", "loss_fn", "(", "params", ")", ":", "\n", "            ", "vars_in", "=", "{", "\"params\"", ":", "params", ",", "\"batch_stats\"", ":", "state", ".", "batch_stats", "}", "\n", "outputs", ",", "new_model_state", "=", "state", ".", "apply_fn", "(", "\n", "vars_in", ",", "batch", ",", "rngs", "=", "rngs", ",", "mutable", "=", "[", "\"batch_stats\"", "]", ",", "**", "kwargs", "\n", ")", "\n", "loss_recorder", "=", "outputs", "[", "2", "]", "\n", "loss", "=", "loss_recorder", ".", "loss", "\n", "elbo", "=", "jnp", ".", "mean", "(", "loss_recorder", ".", "reconstruction_loss", "+", "loss_recorder", ".", "kl_local", ")", "\n", "return", "loss", ",", "(", "elbo", ",", "new_model_state", ")", "\n", "\n", "", "(", "loss", ",", "(", "elbo", ",", "new_model_state", ")", ")", ",", "grads", "=", "jax", ".", "value_and_grad", "(", "\n", "loss_fn", ",", "has_aux", "=", "True", "\n", ")", "(", "state", ".", "params", ")", "\n", "new_state", "=", "state", ".", "apply_gradients", "(", "\n", "grads", "=", "grads", ",", "batch_stats", "=", "new_model_state", "[", "\"batch_stats\"", "]", "\n", ")", "\n", "return", "new_state", ",", "loss", ",", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.training_step": [[969, 993], ["_trainingplans.JaxTrainingPlan.module.train", "_trainingplans.JaxTrainingPlan.jit_training_step", "torch.tensor", "torch.tensor", "_trainingplans.JaxTrainingPlan.log", "_trainingplans.JaxTrainingPlan.log", "_trainingplans.JaxTrainingPlan.loss_kwargs.update", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.jit_training_step", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "if", "\"kl_weight\"", "in", "self", ".", "loss_kwargs", ":", "\n", "            ", "self", ".", "loss_kwargs", ".", "update", "(", "{", "\"kl_weight\"", ":", "self", ".", "kl_weight", "}", ")", "\n", "", "self", ".", "module", ".", "train", "(", ")", "\n", "self", ".", "module", ".", "train_state", ",", "loss", ",", "elbo", "=", "self", ".", "jit_training_step", "(", "\n", "self", ".", "module", ".", "train_state", ",", "\n", "batch", ",", "\n", "self", ".", "module", ".", "rngs", ",", "\n", "loss_kwargs", "=", "self", ".", "loss_kwargs", ",", "\n", ")", "\n", "loss", "=", "torch", ".", "tensor", "(", "jax", ".", "device_get", "(", "loss", ")", ")", "\n", "elbo", "=", "torch", ".", "tensor", "(", "jax", ".", "device_get", "(", "elbo", ")", ")", "\n", "# TODO: Better way to get batch size", "\n", "self", ".", "log", "(", "\n", "\"train_loss\"", ",", "\n", "loss", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "batch", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n", "self", ".", "log", "(", "\n", "\"elbo_train\"", ",", "\n", "elbo", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "batch", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.jit_validation_step": [[995, 1010], ["functools.partial", "_trainingplans.JaxTrainingPlan.module.apply", "jax.mean", "jax.mean"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.apply", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnums", "=", "(", "0", ",", ")", ")", "\n", "def", "jit_validation_step", "(", "\n", "self", ",", "\n", "state", ":", "TrainStateWithBatchNorm", ",", "\n", "batch", ":", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ",", "\n", "rngs", ":", "Dict", "[", "str", ",", "jnp", ".", "ndarray", "]", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "vars_in", "=", "{", "\"params\"", ":", "state", ".", "params", ",", "\"batch_stats\"", ":", "state", ".", "batch_stats", "}", "\n", "outputs", "=", "self", ".", "module", ".", "apply", "(", "vars_in", ",", "batch", ",", "rngs", "=", "rngs", ",", "**", "kwargs", ")", "\n", "loss_recorder", "=", "outputs", "[", "2", "]", "\n", "loss", "=", "loss_recorder", ".", "loss", "\n", "elbo", "=", "jnp", ".", "mean", "(", "loss_recorder", ".", "reconstruction_loss", "+", "loss_recorder", ".", "kl_local", ")", "\n", "\n", "return", "loss", ",", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.validation_step": [[1011, 1032], ["_trainingplans.JaxTrainingPlan.module.eval", "_trainingplans.JaxTrainingPlan.jit_validation_step", "torch.tensor", "torch.tensor", "_trainingplans.JaxTrainingPlan.log", "_trainingplans.JaxTrainingPlan.log", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get", "jax.device_get"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.eval", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.jit_validation_step"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "self", ".", "module", ".", "eval", "(", ")", "\n", "loss", ",", "elbo", "=", "self", ".", "jit_validation_step", "(", "\n", "self", ".", "module", ".", "train_state", ",", "\n", "batch", ",", "\n", "self", ".", "module", ".", "rngs", ",", "\n", "loss_kwargs", "=", "self", ".", "loss_kwargs", ",", "\n", ")", "\n", "loss", "=", "torch", ".", "tensor", "(", "jax", ".", "device_get", "(", "loss", ")", ")", "\n", "elbo", "=", "torch", ".", "tensor", "(", "jax", ".", "device_get", "(", "elbo", ")", ")", "\n", "self", ".", "log", "(", "\n", "\"validation_loss\"", ",", "\n", "loss", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "batch", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n", "self", ".", "log", "(", "\n", "\"elbo_validation\"", ",", "\n", "elbo", ",", "\n", "on_epoch", "=", "True", ",", "\n", "batch_size", "=", "batch", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.kl_weight": [[1034, 1042], ["_trainingplans._compute_kl_weight"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans._compute_kl_weight"], ["", "@", "property", "\n", "def", "kl_weight", "(", "self", ")", ":", "\n", "        ", "\"\"\"Scaling factor on KL divergence during training.\"\"\"", "\n", "return", "_compute_kl_weight", "(", "\n", "self", ".", "current_epoch", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "n_epochs_kl_warmup", ",", "\n", "self", ".", "n_steps_kl_warmup", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.transfer_batch_to_device": [[1044, 1048], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "transfer_batch_to_device", "(", "batch", ",", "device", ",", "dataloader_idx", ")", ":", "\n", "        ", "\"\"\"Bypass Pytorch Lightning device management.\"\"\"", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.configure_optimizers": [[1049, 1051], ["None"], "methods", ["None"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.optimizer_step": [[1052, 1054], ["None"], "methods", ["None"], ["", "def", "optimizer_step", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.backward": [[1055, 1057], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.forward": [[1058, 1060], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans._compute_kl_weight": [[31, 49], ["min", "max", "min"], "function", ["None"], ["def", "_compute_kl_weight", "(", "\n", "epoch", ":", "int", ",", "\n", "step", ":", "int", ",", "\n", "n_epochs_kl_warmup", ":", "Optional", "[", "int", "]", ",", "\n", "n_steps_kl_warmup", ":", "Optional", "[", "int", "]", ",", "\n", "min_weight", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", "->", "float", ":", "\n", "    ", "epoch_criterion", "=", "n_epochs_kl_warmup", "is", "not", "None", "\n", "step_criterion", "=", "n_steps_kl_warmup", "is", "not", "None", "\n", "if", "epoch_criterion", ":", "\n", "        ", "kl_weight", "=", "min", "(", "1.0", ",", "epoch", "/", "n_epochs_kl_warmup", ")", "\n", "", "elif", "step_criterion", ":", "\n", "        ", "kl_weight", "=", "min", "(", "1.0", ",", "step", "/", "n_steps_kl_warmup", ")", "\n", "", "else", ":", "\n", "        ", "kl_weight", "=", "1.0", "\n", "", "if", "min_weight", "is", "not", "None", ":", "\n", "        ", "kl_weight", "=", "max", "(", "kl_weight", ",", "min_weight", ")", "\n", "", "return", "kl_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SubSampleLabels.__init__": [[16, 18], ["pytorch_lightning.callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SubSampleLabels.on_train_epoch_start": [[19, 22], ["trainer.train_dataloader.loaders.resample_labels", "super().on_epoch_start"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.resample_labels"], ["", "def", "on_train_epoch_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "trainer", ".", "train_dataloader", ".", "loaders", ".", "resample_labels", "(", ")", "\n", "super", "(", ")", ".", "on_epoch_start", "(", "trainer", ",", "pl_module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.__init__": [[45, 82], ["pytorch_lightning.callbacks.Callback.__init__", "ValueError", "_callbacks.SaveBestState.monitor.startswith"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "monitor", ":", "str", "=", "\"elbo_validation\"", ",", "\n", "mode", ":", "str", "=", "\"min\"", ",", "\n", "verbose", "=", "False", ",", "\n", "period", "=", "1", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "monitor", "=", "monitor", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "period", "=", "period", "\n", "self", ".", "epochs_since_last_check", "=", "0", "\n", "self", ".", "best_module_state", "=", "None", "\n", "\n", "if", "mode", "not", "in", "[", "\"min\"", ",", "\"max\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"SaveBestState mode {mode} is unknown\"", ",", "\n", ")", "\n", "\n", "", "if", "mode", "==", "\"min\"", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best_module_metric_val", "=", "np", ".", "Inf", "\n", "self", ".", "mode", "=", "\"min\"", "\n", "", "elif", "mode", "==", "\"max\"", ":", "\n", "            ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best_module_metric_val", "=", "-", "np", ".", "Inf", "\n", "self", ".", "mode", "=", "\"max\"", "\n", "", "else", ":", "\n", "            ", "if", "\"acc\"", "in", "self", ".", "monitor", "or", "self", ".", "monitor", ".", "startswith", "(", "\"fmeasure\"", ")", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "greater", "\n", "self", ".", "best_module_metric_val", "=", "-", "np", ".", "Inf", "\n", "self", ".", "mode", "=", "\"max\"", "\n", "", "else", ":", "\n", "                ", "self", ".", "monitor_op", "=", "np", ".", "less", "\n", "self", ".", "best_module_metric_val", "=", "np", ".", "Inf", "\n", "self", ".", "mode", "=", "\"min\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.check_monitor_top": [[83, 85], ["_callbacks.SaveBestState.monitor_op"], "methods", ["None"], ["", "", "", "def", "check_monitor_top", "(", "self", ",", "current", ")", ":", "\n", "        ", "return", "self", ".", "monitor_op", "(", "current", ",", "self", ".", "best_module_metric_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.on_epoch_end": [[86, 110], ["logs.get", "warnings.warn", "isinstance", "_callbacks.SaveBestState.check_monitor_top", "current.item.item.item", "copy.deepcopy", "pl_module.module.state_dict", "pytorch_lightning.utilities.rank_zero_info"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.check_monitor_top", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "on_epoch_end", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "logs", "=", "trainer", ".", "callback_metrics", "\n", "self", ".", "epochs_since_last_check", "+=", "1", "\n", "\n", "if", "trainer", ".", "current_epoch", ">", "0", "and", "self", ".", "epochs_since_last_check", ">=", "self", ".", "period", ":", "\n", "            ", "self", ".", "epochs_since_last_check", "=", "0", "\n", "current", "=", "logs", ".", "get", "(", "self", ".", "monitor", ")", "\n", "\n", "if", "current", "is", "None", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "f\"Can save best module state only with {self.monitor} available,\"", "\n", "\" skipping.\"", ",", "\n", "RuntimeWarning", ",", "\n", ")", "\n", "", "else", ":", "\n", "                ", "if", "isinstance", "(", "current", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "current", "=", "current", ".", "item", "(", ")", "\n", "", "if", "self", ".", "check_monitor_top", "(", "current", ")", ":", "\n", "                    ", "self", ".", "best_module_state", "=", "deepcopy", "(", "pl_module", ".", "module", ".", "state_dict", "(", ")", ")", "\n", "self", ".", "best_module_metric_val", "=", "current", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                        ", "rank_zero_info", "(", "\n", "f\"\\nEpoch {trainer.current_epoch:05d}: {self.monitor} reached.\"", "\n", "f\" Module best state updated.\"", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.on_train_start": [[113, 115], ["copy.deepcopy", "pl_module.module.state_dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "", "", "", "", "def", "on_train_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "self", ".", "best_module_state", "=", "deepcopy", "(", "pl_module", ".", "module", ".", "state_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.SaveBestState.on_train_end": [[116, 118], ["pl_module.module.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict"], ["", "def", "on_train_end", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "pl_module", ".", "module", ".", "load_state_dict", "(", "self", ".", "best_module_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.LoudEarlyStopping.__init__": [[129, 132], ["pytorch_lightning.callbacks.early_stopping.EarlyStopping.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "early_stopping_reason", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.LoudEarlyStopping._evaluate_stopping_criteria": [[133, 138], ["super()._evaluate_stopping_criteria"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.LoudEarlyStopping._evaluate_stopping_criteria"], ["", "def", "_evaluate_stopping_criteria", "(", "self", ",", "current", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "bool", ",", "str", "]", ":", "\n", "        ", "should_stop", ",", "reason", "=", "super", "(", ")", ".", "_evaluate_stopping_criteria", "(", "current", ")", "\n", "if", "should_stop", ":", "\n", "            ", "self", ".", "early_stopping_reason", "=", "reason", "\n", "", "return", "should_stop", ",", "reason", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.LoudEarlyStopping.teardown": [[139, 147], ["print"], "methods", ["None"], ["", "def", "teardown", "(", "\n", "self", ",", "\n", "_trainer", ":", "pl", ".", "Trainer", ",", "\n", "_pl_module", ":", "pl", ".", "LightningModule", ",", "\n", "stage", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "if", "self", ".", "early_stopping_reason", "is", "not", "None", ":", "\n", "            ", "print", "(", "self", ".", "early_stopping_reason", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.JaxModuleInit.__init__": [[152, 155], ["pytorch_lightning.callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "dataloader", ":", "AnnDataLoader", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataloader", "=", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._callbacks.JaxModuleInit.on_train_start": [[156, 166], ["module.init", "pl_module.set_train_state", "trainer.datamodule.train_dataloader", "next", "iter"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.init", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.set_train_state", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader"], ["", "def", "on_train_start", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "module", "=", "pl_module", ".", "module", "\n", "if", "self", ".", "dataloader", "is", "None", ":", "\n", "            ", "dl", "=", "trainer", ".", "datamodule", ".", "train_dataloader", "(", ")", "\n", "", "else", ":", "\n", "            ", "dl", "=", "self", ".", "dataloader", "\n", "", "module_init", "=", "module", ".", "init", "(", "module", ".", "rngs", ",", "next", "(", "iter", "(", "dl", ")", ")", ")", "\n", "params", "=", "module_init", "[", "\"params\"", "]", "\n", "batch_stats", "=", "module_init", "[", "\"batch_stats\"", "]", "\n", "pl_module", ".", "set_train_state", "(", "params", ",", "batch_stats", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.__init__": [[11, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "data", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.log_hparams": [[14, 17], ["None"], "methods", ["None"], ["", "def", "log_hparams", "(", "self", ",", "params", ":", "Dict", "[", "str", ",", "Any", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"Record hparams.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.log_metrics": [[18, 42], ["metrics.items", "isinstance", "metrics.keys", "metrics.pop", "_logger.SimpleExperiment.log_metrics._handle_value"], "methods", ["None"], ["", "def", "log_metrics", "(", "\n", "self", ",", "metrics", ":", "Dict", "[", "str", ",", "float", "]", ",", "step", ":", "Optional", "[", "int", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"Record metrics.\"\"\"", "\n", "\n", "def", "_handle_value", "(", "value", ")", ":", "\n", "            ", "if", "isinstance", "(", "value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "return", "value", ".", "item", "(", ")", "\n", "", "return", "value", "\n", "\n", "", "if", "\"epoch\"", "in", "metrics", ".", "keys", "(", ")", ":", "\n", "            ", "time_point", "=", "metrics", ".", "pop", "(", "\"epoch\"", ")", "\n", "time_point_name", "=", "\"epoch\"", "\n", "", "elif", "\"step\"", "in", "metrics", ".", "keys", "(", ")", ":", "\n", "            ", "time_point", "=", "metrics", ".", "pop", "(", "\"step\"", ")", "\n", "time_point_name", "=", "\"step\"", "\n", "", "else", ":", "\n", "            ", "time_point", "=", "step", "\n", "time_point_name", "=", "\"step\"", "\n", "", "for", "metric", ",", "value", "in", "metrics", ".", "items", "(", ")", ":", "\n", "            ", "if", "metric", "not", "in", "self", ".", "data", ":", "\n", "                ", "self", ".", "data", "[", "metric", "]", "=", "pd", ".", "DataFrame", "(", "columns", "=", "[", "metric", "]", ")", "\n", "self", ".", "data", "[", "metric", "]", ".", "index", ".", "name", "=", "time_point_name", "\n", "", "self", ".", "data", "[", "metric", "]", ".", "loc", "[", "time_point", ",", "metric", "]", "=", "_handle_value", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save": [[43, 46], ["None"], "methods", ["None"], ["", "", "def", "save", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Save data.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.__init__": [[49, 56], ["pytorch_lightning.loggers.LightningLoggerBase.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "name", ":", "str", "=", "\"lightning_logs\"", ",", "version", ":", "Optional", "[", "Union", "[", "int", ",", "str", "]", "]", "=", "None", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_name", "=", "name", "\n", "self", ".", "_experiment", "=", "None", "\n", "self", ".", "_version", "=", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.experiment": [[57, 64], ["_logger.SimpleExperiment"], "methods", ["None"], ["", "@", "property", "\n", "@", "rank_zero_experiment", "\n", "def", "experiment", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the experiment object associated with this logger.\"\"\"", "\n", "if", "self", ".", "_experiment", "is", "None", ":", "\n", "            ", "self", ".", "_experiment", "=", "SimpleExperiment", "(", ")", "\n", "", "return", "self", ".", "_experiment", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.log_hyperparams": [[65, 70], ["None"], "methods", ["None"], ["", "@", "rank_zero_only", "\n", "def", "log_hyperparams", "(", "self", ",", "params", ")", ":", "\n", "# params is an argparse.Namespace", "\n", "# your code to record hyperparameters goes here", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.log_metrics": [[71, 75], ["_logger.SimpleLogger.experiment.log_metrics"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.log_metrics"], ["", "@", "rank_zero_only", "\n", "def", "log_metrics", "(", "self", ",", "metrics", ",", "step", ")", ":", "\n", "        ", "\"\"\"Record metrics.\"\"\"", "\n", "self", ".", "experiment", ".", "log_metrics", "(", "metrics", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.history": [[76, 79], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "history", "(", "self", ")", "->", "Dict", "[", "str", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "return", "self", ".", "experiment", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.version": [[80, 92], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "version", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"\n        Gets the version of the experiment.\n\n        Returns\n        -------\n        The version of the experiment if it is specified, else the next version.\n        \"\"\"", "\n", "if", "self", ".", "_version", "is", "None", ":", "\n", "            ", "self", ".", "_version", "=", "1", "\n", "", "return", "self", ".", "_version", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleLogger.name": [[93, 96], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.__init__": [[85, 155], ["pytorch_lightning.Trainer.__init__", "_callbacks.LoudEarlyStopping", "_progress.ProgressBar", "_logger.SimpleLogger", "kwargs.keys"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "gpus", ":", "Union", "[", "int", ",", "str", "]", "=", "1", ",", "\n", "benchmark", ":", "bool", "=", "True", ",", "\n", "flush_logs_every_n_steps", "=", "np", ".", "inf", ",", "\n", "check_val_every_n_epoch", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "max_epochs", ":", "int", "=", "400", ",", "\n", "default_root_dir", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "enable_checkpointing", ":", "bool", "=", "False", ",", "\n", "num_sanity_val_steps", ":", "int", "=", "0", ",", "\n", "enable_model_summary", ":", "bool", "=", "False", ",", "\n", "early_stopping", ":", "bool", "=", "False", ",", "\n", "early_stopping_monitor", ":", "Literal", "[", "\n", "\"elbo_validation\"", ",", "\"reconstruction_loss_validation\"", ",", "\"kl_local_validation\"", "\n", "]", "=", "\"elbo_validation\"", ",", "\n", "early_stopping_min_delta", ":", "float", "=", "0.00", ",", "\n", "early_stopping_patience", ":", "int", "=", "45", ",", "\n", "early_stopping_mode", ":", "Literal", "[", "\"min\"", ",", "\"max\"", "]", "=", "\"min\"", ",", "\n", "enable_progress_bar", ":", "bool", "=", "True", ",", "\n", "progress_bar_refresh_rate", ":", "int", "=", "1", ",", "\n", "simple_progress_bar", ":", "bool", "=", "True", ",", "\n", "logger", ":", "Union", "[", "Optional", "[", "LightningLoggerBase", "]", ",", "bool", "]", "=", "None", ",", "\n", "log_every_n_steps", ":", "int", "=", "10", ",", "\n", "replace_sampler_ddp", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "if", "default_root_dir", "is", "None", ":", "\n", "            ", "default_root_dir", "=", "settings", ".", "logging_dir", "\n", "\n", "", "kwargs", "[", "\"callbacks\"", "]", "=", "(", "\n", "[", "]", "if", "\"callbacks\"", "not", "in", "kwargs", ".", "keys", "(", ")", "else", "kwargs", "[", "\"callbacks\"", "]", "\n", ")", "\n", "if", "early_stopping", ":", "\n", "            ", "early_stopping_callback", "=", "LoudEarlyStopping", "(", "\n", "monitor", "=", "early_stopping_monitor", ",", "\n", "min_delta", "=", "early_stopping_min_delta", ",", "\n", "patience", "=", "early_stopping_patience", ",", "\n", "mode", "=", "early_stopping_mode", ",", "\n", ")", "\n", "kwargs", "[", "\"callbacks\"", "]", "+=", "[", "early_stopping_callback", "]", "\n", "check_val_every_n_epoch", "=", "1", "\n", "", "else", ":", "\n", "            ", "check_val_every_n_epoch", "=", "(", "\n", "check_val_every_n_epoch", "\n", "if", "check_val_every_n_epoch", "is", "not", "None", "\n", "# needs to be an integer, np.inf does not work", "\n", "else", "sys", ".", "maxsize", "\n", ")", "\n", "\n", "", "if", "simple_progress_bar", ":", "\n", "            ", "bar", "=", "ProgressBar", "(", "refresh_rate", "=", "progress_bar_refresh_rate", ")", "\n", "kwargs", "[", "\"callbacks\"", "]", "+=", "[", "bar", "]", "\n", "\n", "", "if", "logger", "is", "None", ":", "\n", "            ", "logger", "=", "SimpleLogger", "(", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n", "gpus", "=", "gpus", ",", "\n", "benchmark", "=", "benchmark", ",", "\n", "check_val_every_n_epoch", "=", "check_val_every_n_epoch", ",", "\n", "max_epochs", "=", "max_epochs", ",", "\n", "default_root_dir", "=", "default_root_dir", ",", "\n", "enable_checkpointing", "=", "enable_checkpointing", ",", "\n", "num_sanity_val_steps", "=", "num_sanity_val_steps", ",", "\n", "enable_model_summary", "=", "enable_model_summary", ",", "\n", "logger", "=", "logger", ",", "\n", "log_every_n_steps", "=", "log_every_n_steps", ",", "\n", "replace_sampler_ddp", "=", "replace_sampler_ddp", ",", "\n", "enable_progress_bar", "=", "enable_progress_bar", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit": [[157, 189], ["warnings.catch_warnings", "warnings.filterwarnings", "warnings.filterwarnings", "warnings.filterwarnings", "warnings.filterwarnings", "isinstance", "super().fit", "warnings.filterwarnings"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit"], ["", "def", "fit", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "filterwarnings", "(", "\n", "action", "=", "\"ignore\"", ",", "category", "=", "UserWarning", ",", "message", "=", "\"The dataloader,\"", "\n", ")", "\n", "warnings", ".", "filterwarnings", "(", "\n", "action", "=", "\"ignore\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", "message", "=", "\"you defined a validation_step but have no val_dataloader\"", ",", "\n", ")", "\n", "warnings", ".", "filterwarnings", "(", "\n", "action", "=", "\"ignore\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", "message", "=", "\"One of given dataloaders is None and it will be skipped\"", ",", "\n", ")", "\n", "# bug in pytorch lightning, assumes SequentialSampler", "\n", "# https://github.com/PyTorchLightning/pytorch-lightning/blob/", "\n", "# 48cb38ac5dd0159c8f7c5189c888dfd04a2ed34b/pytorch_lightning/", "\n", "# trainer/data_loading.py#L311-L314", "\n", "warnings", ".", "filterwarnings", "(", "\n", "action", "=", "\"ignore\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", "message", "=", "\"Your `val_dataloader` has `shuffle=True`\"", ",", "\n", ")", "\n", "if", "isinstance", "(", "args", "[", "0", "]", ",", "PyroTrainingPlan", ")", ":", "\n", "                ", "warnings", ".", "filterwarnings", "(", "\n", "action", "=", "\"ignore\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", "message", "=", "\"`LightningModule.configure_optimizers` returned `None`\"", ",", "\n", ")", "\n", "", "super", "(", ")", ".", "fit", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute": [[24, 54], ["getattr", "isinstance", "isinstance", "isinstance", "field.to_numpy().reshape.to_numpy().reshape", "ValueError", "ValueError", "ValueError", "getattr.keys", "ValueError", "field.to_numpy().reshape.to_numpy"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._set_data_in_registry": [[56, 90], ["setattr", "getattr", "isinstance", "setattr"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._verify_and_correct_data_format": [[92, 134], ["_utils.get_anndata_attribute", "scipy.isspmatrix", "warnings.warn", "pd.DataFrame.getformat", "isinstance", "logger.debug", "numpy.asarray", "_utils._set_data_in_registry", "isinstance", "logger.debug", "pd.DataFrame.to_numpy", "pandas.DataFrame", "_utils._set_data_in_registry", "numpy.ascontiguousarray", "pd.DataFrame.to_numpy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._set_data_in_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._set_data_in_registry"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._make_column_categorical": [[136, 175], ["numpy.unique", "df[].astype.cat.categories.to_numpy", "df[].astype", "df[].astype", "ValueError", "numpy.min", "warnings.warn", "df[].astype", "numpy.argmin"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._assign_adata_uuid": [[177, 185], ["str", "uuid.uuid4"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_nonnegative_integers": [[187, 210], ["isinstance", "numpy.random.choice", "jax.device_put", "jax.device_put", "_utils._is_not_count_val", "isinstance", "isinstance", "issubclass", "len", "type", "isinstance", "data.to_numpy.to_numpy", "TypeError", "jax.devices", "jax.devices"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._is_not_count_val"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._is_not_count_val": [[212, 218], ["jax.any", "jax.any"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._get_batch_mask_protein_data": [[220, 240], ["numpy.unique", "isinstance", "pro_exp.to_numpy", "pro_exp[].sum", "numpy.where", "batches.ravel"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_if_view": [[242, 255], ["isinstance", "logger.info", "adata._init_as_actual", "_utils._assign_adata_uuid", "ValueError", "adata.mod.keys", "adata.copy", "_utils._check_if_view"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._assign_adata_uuid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_if_view"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_mudata_fully_paired": [[257, 266], ["isinstance", "AssertionError", "mdata.obsm[].all", "ValueError"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._read.read_10x_atac": [[10, 45], ["scipy.io.mmread().transpose", "pandas.read_csv", "pd.read_csv.rename", "pd.read_csv.set_index", "pd.read_csv.index.astype", "pandas.read_csv", "pd.read_csv.rename", "pd.read_csv.set_index", "pd.read_csv.index.astype", "anndata.AnnData", "os.path.join", "os.path.join", "mmread().transpose.tocsr", "scipy.io.mmread", "pd.read_csv.end.astype", "os.path.join", "pd.read_csv.start.astype", "pd.read_csv.chr.astype"], "function", ["None"], ["def", "read_10x_atac", "(", "base_path", ":", "Union", "[", "str", ",", "Path", "]", ")", "->", "AnnData", ":", "\n", "    ", "\"\"\"\n    Read scATAC-seq data outputted by 10x Genomics software.\n\n    Parameters\n    ----------\n    base_path\n        Path to directory with matrix, bed file, etc.\n    \"\"\"", "\n", "data", "=", "mmread", "(", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"matrix.mtx\"", ")", ")", ".", "transpose", "(", ")", "\n", "coords", "=", "pd", ".", "read_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"peaks.bed\"", ")", ",", "\n", "sep", "=", "\"\\t\"", ",", "\n", "header", "=", "None", ",", "\n", "index_col", "=", "None", ",", "\n", ")", "\n", "coords", ".", "rename", "(", "{", "0", ":", "\"chr\"", ",", "1", ":", "\"start\"", ",", "2", ":", "\"end\"", "}", ",", "axis", "=", "\"columns\"", ",", "inplace", "=", "True", ")", "\n", "coords", ".", "set_index", "(", "\n", "coords", ".", "chr", ".", "astype", "(", "str", ")", "\n", "+", "\":\"", "\n", "+", "coords", ".", "start", ".", "astype", "(", "str", ")", "\n", "+", "\"-\"", "\n", "+", "coords", ".", "end", ".", "astype", "(", "str", ")", ",", "\n", "inplace", "=", "True", ",", "\n", ")", "\n", "coords", ".", "index", "=", "coords", ".", "index", ".", "astype", "(", "str", ")", "\n", "\n", "cell_annot", "=", "pd", ".", "read_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"barcodes.tsv\"", ")", ",", "sep", "=", "\"-\"", ",", "header", "=", "None", ",", "index_col", "=", "None", "\n", ")", "\n", "cell_annot", ".", "rename", "(", "{", "0", ":", "\"barcode\"", ",", "1", ":", "\"batch_id\"", "}", ",", "axis", "=", "\"columns\"", ",", "inplace", "=", "True", ")", "\n", "cell_annot", ".", "set_index", "(", "\"barcode\"", ",", "inplace", "=", "True", ")", "\n", "cell_annot", ".", "index", "=", "cell_annot", ".", "index", ".", "astype", "(", "str", ")", "\n", "\n", "return", "AnnData", "(", "data", ".", "tocsr", "(", ")", ",", "var", "=", "coords", ",", "obs", "=", "cell_annot", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._read.read_10x_multiome": [[47, 79], ["scipy.io.mmread().transpose", "pandas.read_csv", "pd.read_csv.rename", "pandas.read_csv", "pd.read_csv.rename", "pd.read_csv.set_index", "pd.read_csv.index.astype", "anndata.AnnData", "os.path.join", "os.path.join", "mmread().transpose.tocsr", "scipy.io.mmread", "os.path.join"], "function", ["None"], ["", "def", "read_10x_multiome", "(", "base_path", ":", "Union", "[", "str", ",", "Path", "]", ")", "->", "AnnData", ":", "\n", "    ", "\"\"\"\n    Read Multiome (scRNA + scATAC) data outputted by 10x Genomics software.\n\n    Parameters\n    ----------\n    base_path\n        Path to directory with matrix, barcodes file, etc.\n    \"\"\"", "\n", "data", "=", "mmread", "(", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"matrix.mtx\"", ")", ")", ".", "transpose", "(", ")", "\n", "\n", "features", "=", "pd", ".", "read_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"features.tsv\"", ")", ",", "\n", "sep", "=", "\"\\t\"", ",", "\n", "header", "=", "None", ",", "\n", "index_col", "=", "1", ",", "\n", ")", "\n", "features", ".", "rename", "(", "\n", "{", "0", ":", "\"ID\"", ",", "2", ":", "\"modality\"", ",", "3", ":", "\"chr\"", ",", "4", ":", "\"start\"", ",", "5", ":", "\"end\"", "}", ",", "\n", "axis", "=", "\"columns\"", ",", "\n", "inplace", "=", "True", ",", "\n", ")", "\n", "features", ".", "index", ".", "name", "=", "None", "\n", "\n", "cell_annot", "=", "pd", ".", "read_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "base_path", ",", "\"barcodes.tsv\"", ")", ",", "sep", "=", "\"-\"", ",", "header", "=", "None", ",", "index_col", "=", "None", "\n", ")", "\n", "cell_annot", ".", "rename", "(", "{", "0", ":", "\"barcode\"", ",", "1", ":", "\"batch_id\"", "}", ",", "axis", "=", "\"columns\"", ",", "inplace", "=", "True", ")", "\n", "cell_annot", ".", "set_index", "(", "\"barcode\"", ",", "inplace", "=", "True", ")", "\n", "cell_annot", ".", "index", "=", "cell_annot", ".", "index", ".", "astype", "(", "str", ")", "\n", "\n", "return", "AnnData", "(", "data", ".", "tocsr", "(", ")", ",", "var", "=", "features", ",", "obs", "=", "cell_annot", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat._infer_setup_args": [[29, 74], ["dict", "data_registry.items"], "function", ["None"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat.registry_from_setup_dict": [[77, 182], ["data_registry.items", "registry.update", "_compat._infer_setup_args", "attr_key.startswith", "dict", "dict", "field_summary_stats.update", "numpy.zeros", "setup_dict[].copy", "copy.deepcopy", "field_state_registry.update", "field_state_registry.pop", "len", "setup_dict[].copy", "len", "setup_dict[].copy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat._infer_setup_args", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmc_dataset": [[27, 60], ["_built_in_data._pbmc._load_pbmc_dataset"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._pbmc._load_pbmc_dataset"], ["def", "pbmc_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "remove_extracted_data", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads pbmc dataset.\n\n    We considered scRNA-seq data from two batches of peripheral blood mononuclear cells (PBMCs) from a healthy donor\n    (4K PBMCs and 8K PBMCs). We derived quality control metrics using the cellrangerRkit R package (v. 1.1.0).\n    Quality metrics were extracted from CellRanger throughout the molecule specific information file. After filtering,\n    we extract 12,039 cells with 10,310 sampled genes and get biologically meaningful clusters with the\n    software Seurat. We then filter genes that we could not match with the bulk data used for differential\n    expression to be left with g = 3346.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    remove_extracted_data\n        If true, will remove the folder the data was extracted to\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.pbmc_dataset()\n    \"\"\"", "\n", "return", "_load_pbmc_dataset", "(", "\n", "save_path", "=", "save_path", ",", "\n", "remove_extracted_data", "=", "remove_extracted_data", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.dataset_10x": [[63, 118], ["_built_in_data._dataset_10x._load_dataset_10x"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._load_dataset_10x"], ["", "def", "dataset_10x", "(", "\n", "dataset_name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "filename", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "save_path", ":", "str", "=", "\"data/10X\"", ",", "\n", "url", ":", "str", "=", "None", ",", "\n", "return_filtered", ":", "bool", "=", "True", ",", "\n", "remove_extracted_data", ":", "bool", "=", "False", ",", "\n", "**", "scanpy_read_10x_kwargs", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads a file from `10x <http://cf.10xgenomics.com/>`_ website.\n\n    Parameters\n    ----------\n    dataset_name\n        Name of the dataset file. Has to be one of:\n        \"frozen_pbmc_donor_a\", \"frozen_pbmc_donor_b\", \"frozen_pbmc_donor_c\", \"fresh_68k_pbmc_donor_a\",\n        \"cd14_monocytes\", \"b_cells\", \"cd34\", \"cd56_nk\", \"cd4_t_helper\", \"regulatory_t\", \"naive_t\",\n        \"memory_t\", \"cytotoxic_t\", \"naive_cytotoxic\", \"pbmc8k\", \"pbmc4k\", \"t_3k\", \"t_4k\", \"neuron_9k\",\n        \"pbmc_1k_protein_v3\", \"pbmc_10k_protein_v3\", \"malt_10k_protein_v3\", \"pbmc_1k_v2\", \"pbmc_1k_v3\",\n        \"pbmc_10k_v3\", \"hgmm_1k_v2\", \"hgmm_1k_v3\", \"hgmm_5k_v3\", \"hgmm_10k_v3\", \"neuron_1k_v2\",\n        \"neuron_1k_v3\", \"neuron_10k_v3\", \"heart_1k_v2\", \"heart_1k_v3\", \"heart_10k_v3\", 5k_pbmc_protein_v3\",\n        \"5k_pbmc_protein_v3_nextgem\", 1M_neurons\".\n    filename\n        manual override of the filename to write to.\n    save_path\n        Location to use when saving/loading the data.\n    url\n        manual override of the download remote location.\n        Note that we already provide urls for most 10X datasets,\n        which are automatically formed only using the ``dataset_name``.\n    return_filtered\n        Either `filtered` data or `raw` data.\n    remove_extracted_data\n        Whether to remove extracted archives in the case of `.tar.gz` downloads.\n    **scanpy_read_10x_kwargs\n        Kwargs for scanpy's read_10x function\n\n    Returns\n    -------\n    adata initialized with 10x data\n\n    Examples\n    --------\n    >>> import scvi\n    >>> neuron = scvi.data.dataset10X(\"neuron_9k\")\n    \"\"\"", "\n", "return", "_load_dataset_10x", "(", "\n", "dataset_name", "=", "dataset_name", ",", "\n", "filename", "=", "filename", ",", "\n", "save_path", "=", "save_path", ",", "\n", "url", "=", "url", ",", "\n", "return_filtered", "=", "return_filtered", ",", "\n", "remove_extracted_data", "=", "remove_extracted_data", ",", "\n", "**", "scanpy_read_10x_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.smfish": [[121, 150], ["_built_in_data._smfish._load_smfish"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._smfish._load_smfish"], ["", "def", "smfish", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "use_high_level_cluster", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads osmFISH data of mouse cortex cells from the Linarsson lab.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    use_high_level_cluster\n        If True, use higher-level agglomerate clusters.\n        The resulting cell types are \"Astrocytes\", \"Endothelials\", \"Inhibitory\",\n        \"Microglias\", \"Oligodendrocytes\" and \"Pyramidals\".\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['labels']``),\n    spatial info (``.obs['x_coord']``, ``.obs['y_coord']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.smfish()\n    \"\"\"", "\n", "return", "_load_smfish", "(", "\n", "save_path", "=", "save_path", ",", "\n", "use_high_level_cluster", "=", "use_high_level_cluster", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.seqfishplus": [[153, 184], ["_built_in_data._seqfish._load_seqfishplus"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfishplus"], ["", "def", "seqfishplus", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "tissue_region", "=", "\"subventricular cortex\"", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    seqFISH+ of cortex, subventricular zone and olfactory bulb of mouse brain.\n\n    seqFISH+ can image mRNAs for 10,000 genes in single cells\u2014with high accuracy and\n    sub-diffraction-limit resolution\u2014in the cortex, subventricular zone\n    and olfactory bulb of mouse brain\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    tissue_region\n        Region of the mouse brain, Either \"subventricular cortex\" or \"olfactory bulb\"\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['labels']``),\n    spatial info (``.obs['X']``, ``.obs['Y']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.seqfishplus()\n    \"\"\"", "\n", "return", "_load_seqfishplus", "(", "\n", "save_path", "=", "save_path", ",", "\n", "tissue_region", "=", "tissue_region", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.seqfish": [[187, 208], ["_built_in_data._seqfish._load_seqfish"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfish"], ["", "def", "seqfish", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Seqfish dataset.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.seqfish()\n    \"\"\"", "\n", "return", "_load_seqfish", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.purified_pbmc_dataset": [[210, 239], ["_built_in_data._pbmc._load_purified_pbmc_dataset"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._pbmc._load_purified_pbmc_dataset"], ["", "def", "purified_pbmc_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "subset_datasets", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Purified PBMC dataset from: \"Massively parallel digital transcriptional profiling of single cells\".\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    subset_datasets\n        index for subsetting the follwing list of datasets\n        which are used to form the ``PurifiedPBMCDataset``:\n        \"cd4_t_helper\", \"regulatory_t\", \"naive_t\", \"memory_t\", \"cytotoxic_t\", \"naive_cytotoxic\",\n        \"b_cells\", \"cd4_t_helper\", \"cd34\", \"cd56_nk\", \"cd14_monocytes\".\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.purified_pbmc_dataset()\n    \"\"\"", "\n", "return", "_load_purified_pbmc_dataset", "(", "\n", "save_path", "=", "save_path", ",", "\n", "subset_datasets", "=", "subset_datasets", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.prefrontalcortex_starmap": [[242, 265], ["_built_in_data._loom._load_prefrontalcortex_starmap"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_prefrontalcortex_starmap"], ["", "def", "prefrontalcortex_starmap", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads a starMAP dataset of mouse pre-frontal cortex (Wang et al., 2018).\n\n    3,704 cells and 166 genes.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['labels']``),\n    spatial info (``.obs['x_coord']``, ``.obs['y_coord']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.prefrontalcortex_starmap()\n\n    \"\"\"", "\n", "return", "_load_prefrontalcortex_starmap", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.frontalcortex_dropseq": [[267, 291], ["_built_in_data._loom._load_frontalcortex_dropseq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_frontalcortex_dropseq"], ["", "def", "frontalcortex_dropseq", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Load the cells from the mouse frontal cortex sequenced by the Dropseq technology (Saunders et al., 2018).\n\n    Load the 71639 annotated cells located in the frontal cortex of adult mouses among the 690,000 cells\n    studied by (Saunders et al., 2018) using the Drop-seq method. We have a 71639*7611 gene expression matrix\n    Among the 7611 genes, we offer the user to provide a list of genes to subsample from. If not provided,\n    all genes are kept.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.frontalcortex_dropseq()\n    \"\"\"", "\n", "return", "_load_frontalcortex_dropseq", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.annotation_simulation": [[293, 315], ["_built_in_data._loom._load_annotation_simulation"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_annotation_simulation"], ["", "def", "annotation_simulation", "(", "name", ":", "str", ",", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Simulated datasets for scANVI tutorials.\n\n    Parameters\n    ----------\n    name\n        One of \"1\", \"2\", or \"3\"\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.annontation_simulation(\"1\")\n\n    \"\"\"", "\n", "return", "_load_annotation_simulation", "(", "name", "=", "name", ",", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.retina": [[317, 339], ["_built_in_data._loom._load_retina"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_retina"], ["", "def", "retina", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads retina dataset.\n\n    The dataset of bipolar cells contains after their original pipeline for filtering 27,499 cells and\n    13,166 genes coming from two batches. We use the cluster annotation from 15 cell-types from the author.\n    We also extract their normalized data with Combat and use it for benchmarking.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> adata = retina()\n    \"\"\"", "\n", "return", "_load_retina", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.mouse_ob_dataset": [[341, 360], ["_built_in_data._csv._load_mouse_ob_dataset"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_mouse_ob_dataset"], ["", "def", "mouse_ob_dataset", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads mouse ob dataset.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.mouse_ob_dataset()\n    \"\"\"", "\n", "return", "_load_mouse_ob_dataset", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.breast_cancer_dataset": [[362, 381], ["_built_in_data._csv._load_breast_cancer_dataset"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_breast_cancer_dataset"], ["", "def", "breast_cancer_dataset", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads breast cancer dataset.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.breast_cancer_dataset()\n    \"\"\"", "\n", "return", "_load_breast_cancer_dataset", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmcs_10x_cite_seq": [[383, 415], ["_built_in_data._cite_seq._load_pbmcs_10x_cite_seq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_pbmcs_10x_cite_seq"], ["", "def", "pbmcs_10x_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "protein_join", ":", "str", "=", "\"inner\"", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Filtered PBMCs from 10x Genomics profiled with RNA and protein.\n\n    Datasets were filtered for doublets and other outliers as in\n    https://github.com/YosefLab/totalVI_reproducibility/blob/master/data/data_filtering_scripts/pbmc_10k/pbmc_10k.py\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    protein_join\n        Whether to take an inner join or outer join of proteins\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``),\n    and protein expression (``.obsm[\"protein_expression\"]``)\n\n    Missing protein values are zero, when ``protein_join == \"outer`` and are identified during ``AnnData`` setup.\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.pbmcs_10x_cite_seq()\n    \"\"\"", "\n", "return", "_load_pbmcs_10x_cite_seq", "(", "\n", "save_path", "=", "save_path", ",", "\n", "protein_join", "=", "protein_join", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.spleen_lymph_cite_seq": [[418, 453], ["_built_in_data._cite_seq._load_spleen_lymph_cite_seq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_spleen_lymph_cite_seq"], ["", "def", "spleen_lymph_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "protein_join", ":", "str", "=", "\"inner\"", ",", "\n", "remove_outliers", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Immune cells from the murine spleen and lymph nodes [GayosoSteier21]_.\n\n    This dataset was used throughout the totalVI manuscript, and named SLN-all.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    protein_join\n        Whether to take an inner join or outer join of proteins\n    remove_outliers\n        Whether to remove clusters annotated as doublet or low quality\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['cell_types']``),\n    protein expression (``.obsm[\"protein_expression\"]``), and tissue (``.obs['tissue']``).\n\n    Missing protein values are zero, when ``protein_join == \"outer`` and are identified during ``AnnData`` setup.\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.spleen_lymph_cite_seq()\n    \"\"\"", "\n", "return", "_load_spleen_lymph_cite_seq", "(", "\n", "save_path", "=", "save_path", ",", "\n", "protein_join", "=", "protein_join", ",", "\n", "remove_outliers", "=", "remove_outliers", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.brainlarge_dataset": [[456, 500], ["_built_in_data._brain_large._load_brainlarge_dataset"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._brain_large._load_brainlarge_dataset"], ["", "def", "brainlarge_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "sample_size_gene_var", ":", "int", "=", "10000", ",", "\n", "max_cells_to_keep", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "n_genes_to_keep", ":", "int", "=", "720", ",", "\n", "loading_batch_size", ":", "int", "=", "100000", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads brain-large dataset.\n\n    This dataset contains 1.3 million brain cells from\n    `10x Genomics <https://support.10xgenomics.com/single-cell-gene-expression/datasets>`_.\n    We randomly shuffle the data to get a 1M subset of cells and order genes by variance to retain first 10,000 and then 720 sampled variable genes.\n    This dataset is then sampled multiple times in cells for the runtime and goodness-of-fit analysis.\n    We report imputation scores on the 10k cells and 720 genes samples only.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    sample_size_gene_var\n        Number of cells to use to estimate gene variances.\n    max_cells_to_keep\n        Maximum number of cells to keep.\n    n_genes_to_keep\n        Number of genes to keep, ordered by decreasing variance.\n    loading_batch_size\n        Number of cells to use for each chunk loaded.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.brainlarge_dataset()\n    \"\"\"", "\n", "return", "_load_brainlarge_dataset", "(", "\n", "save_path", "=", "save_path", ",", "\n", "sample_size_gene_var", "=", "sample_size_gene_var", ",", "\n", "max_cells_to_keep", "=", "max_cells_to_keep", ",", "\n", "n_genes_to_keep", "=", "n_genes_to_keep", ",", "\n", "loading_batch_size", "=", "loading_batch_size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.cortex": [[503, 527], ["_built_in_data._cortex._load_cortex"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cortex._load_cortex"], ["", "def", "cortex", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Loads cortex dataset.\n\n    The\n    `Mouse Cortex Cells dataset <https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt>`_\n    contains 3005 mouse cortex cells and gold-standard labels for seven distinct cell types. Each cell type corresponds\n    to a cluster to recover.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``) and label info (``.obs['labels']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.cortex()\n    \"\"\"", "\n", "return", "_load_cortex", "(", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid": [[529, 572], ["_built_in_data._synthetic._generate_synthetic"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._synthetic._generate_synthetic"], ["", "def", "synthetic_iid", "(", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "200", ",", "\n", "n_genes", ":", "Optional", "[", "int", "]", "=", "100", ",", "\n", "n_proteins", ":", "Optional", "[", "int", "]", "=", "100", ",", "\n", "n_batches", ":", "Optional", "[", "int", "]", "=", "2", ",", "\n", "n_labels", ":", "Optional", "[", "int", "]", "=", "3", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Synthetic dataset with ZINB distributed RNA and NB distributed protein.\n\n    This dataset is just for testing purposed and not meant for modeling or research.\n    Each value is independently and identically distributed.\n\n    Parameters\n    ----------\n    batch_size\n        Number of cells per batch\n    n_genes\n        Number of genes\n    n_proteins\n        Number of proteins\n    n_batches\n        Number of batches\n    n_labels\n        Number of cell types\n\n    Returns\n    -------\n    AnnData with batch info (``.obs['batch']``), label info (``.obs['labels']``),\n    protein expression (``.obsm[\"protein_expression\"]``) and\n    protein names (``.obs['protein_names']``)\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.synthetic_iid()\n    \"\"\"", "\n", "return", "_generate_synthetic", "(", "\n", "batch_size", "=", "batch_size", ",", "\n", "n_genes", "=", "n_genes", ",", "\n", "n_proteins", "=", "n_proteins", ",", "\n", "n_batches", "=", "n_batches", ",", "\n", "n_labels", "=", "n_labels", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.heart_cell_atlas_subsampled": [[575, 613], ["_built_in_data._heartcellatlas._load_heart_cell_atlas_subsampled"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._heartcellatlas._load_heart_cell_atlas_subsampled"], ["", "def", "heart_cell_atlas_subsampled", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "remove_nuisance_clusters", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Combined single cell and single nuclei RNA-Seq data of 485K cardiac cells with annotations.\n\n    Dataset was filtered down randomly to 20k cells using :func:`~scanpy.pp.subsample`. The original\n    data can be downloaded from https://www.heartcellatlas.org/#DataSources.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    remove_nuisance_clusters\n        Remove doublets and unsassigned cells\n\n    Returns\n    -------\n    AnnData\n\n    Notes\n    -----\n    The data were filtered using the following sequence::\n\n        >>> adata = anndata.read_h5ad(path_to_anndata)\n        >>> bdata = sc.pp.subsample(adata, n_obs=20000, copy=True)\n        >>> sc.pp.filter_genes(bdata, min_counts=3)\n        >>> bdata.write_h5ad(path, compression=\"gzip\")\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.heart_cell_atlas_subsampled()\n    \"\"\"", "\n", "return", "_load_heart_cell_atlas_subsampled", "(", "\n", "save_path", "=", "save_path", ",", "\n", "remove_nuisance_clusters", "=", "remove_nuisance_clusters", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmc_seurat_v4_cite_seq": [[616, 674], ["_built_in_data._cite_seq._load_pbmc_seurat_v4_cite_seq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_pbmc_seurat_v4_cite_seq"], ["", "def", "pbmc_seurat_v4_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "apply_filters", ":", "bool", "=", "True", ",", "\n", "aggregate_proteins", ":", "bool", "=", "True", ",", "\n", "mask_protein_batches", ":", "int", "=", "0", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Dataset of PBMCs measured with CITE-seq (161764 cells).\n\n    This dataset was first presented in the Seurat v4 paper:\n\n    https://doi.org/10.1016/j.cell.2021.04.048\n\n    It contains 8 volunteers in an HIV vaccine trial measured\n    at 3 time points; thus, there are 24 batches in this dataset.\n\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    apply_filters\n        Apply filters at cell and protein level. At the cell level,\n        this filters on protein library size, number proteins detected,\n        percent mito, and removes cells labeled as doublets.\n    aggregate_proteins\n        Antibodies targeting the same surface protein are added together,\n        and isotype controls are removed. See the source code for full details.\n    mask_protein_subset\n        Set proteins in this many batches to be all zero (considered missing\n        for :class:`~scvi.model.TOTALVI`.). This improves transfer learning\n        with this dataset.\n\n    Returns\n    -------\n    AnnData\n\n    Notes\n    -----\n    This is not the same exact dataset as can be downloaded from:\n\n    https://satijalab.org/seurat/articles/multimodal_reference_mapping.html\n\n    This is due to the fact that the object linked in the tutorial above does\n    not contain the actual UMI count data for RNA. UMI counts had to be separately\n    downloaded from GEO (GSE164378). The counts in that object are an output of the\n    scTransform method and should not be treated like UMI counts.\n\n    Examples\n    --------\n    >>> import scvi\n    >>> adata = scvi.data.pbmc_seurat_v4_cite_seq()\n    \"\"\"", "\n", "return", "_load_pbmc_seurat_v4_cite_seq", "(", "\n", "save_path", "=", "save_path", ",", "\n", "apply_filters", "=", "apply_filters", ",", "\n", "aggregate_proteins", "=", "aggregate_proteins", ",", "\n", "mask_protein_batches", "=", "mask_protein_batches", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.poisson_gene_selection": [[16, 232], ["torch.no_grad", "numpy.unique", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "np.concatenate.argsort().argsort", "numpy.median", "numpy.median", "numpy.median", "numpy.median", "numpy.sum", "pandas.DataFrame", "_utils._check_nonnegative_integers", "ValueError", "torch.cuda.is_available", "pandas.Categorical", "numpy.asarray().ravel", "torch.from_numpy", "torch.from_numpy().to", "torch.from_numpy().to", "min", "torch.zeros", "range", "torch.exp().sum", "torch.distributions.Binomial", "torch.distributions.Binomial", "torch.zeros", "scvi.utils.track", "torch.from_numpy().to.cpu().numpy", "torch.zeros.cpu().numpy", "np.concatenate.append", "np.concatenate.append", "np.concatenate.append", "df.drop.nlargest", "logger.debug", "numpy.zeros", "scaled_means.cuda.cuda", "torch.exp().sum", "range", "torch.cuda.empty_cache", "prob_zero_enrichment.reshape", "observed_fraction_zeros.cpu().numpy.reshape", "expected_fraction_zeros.cpu().numpy.reshape", "np.concatenate.argsort", "numpy.array", "adata._inplace_subset_var", "df.drop.drop", "numpy.asarray", "np.asarray().ravel.sum", "torch.from_numpy", "torch.from_numpy", "torch.exp", "torch.distributions.Binomial.sample", "torch.distributions.Binomial.sample", "torch.from_numpy().to.cpu", "torch.zeros.cpu", "data.sum", "numpy.asarray().ravel", "numpy.asarray().ravel", "torch.exp", "torch.einsum", "numpy.asarray", "numpy.asarray", "torch.einsum", "data.sum"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_nonnegative_integers", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to", "home.repos.pwc.inspect_result.YosefLab_scVI.utils._track.track", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "poisson_gene_selection", "(", "\n", "adata", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "n_top_genes", ":", "int", "=", "4000", ",", "\n", "use_gpu", ":", "bool", "=", "True", ",", "\n", "subset", ":", "bool", "=", "False", ",", "\n", "inplace", ":", "bool", "=", "True", ",", "\n", "n_samples", ":", "int", "=", "10000", ",", "\n", "batch_key", ":", "str", "=", "None", ",", "\n", "silent", ":", "bool", "=", "False", ",", "\n", "minibatch_size", ":", "int", "=", "5000", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Optional", "[", "pd", ".", "DataFrame", "]", ":", "\n", "    ", "\"\"\"\n    Rank and select genes based on the enrichment of zero counts.\n\n    Enrichment is considered by comparing data to a Poisson count model.\n    This is based on M3Drop: https://github.com/tallulandrews/M3Drop\n    The method accounts for library size internally, a raw count matrix should be provided.\n\n    Instead of Z-test, enrichment of zeros is quantified by posterior\n    probabilites from a binomial model, computed through sampling.\n\n\n    Parameters\n    ----------\n    adata\n        AnnData object (with sparse X matrix).\n    layer\n        If provided, use `adata.layers[layer]` for expression values instead of `adata.X`.\n    n_top_genes\n        How many variable genes to select.\n    use_gpu\n        Whether to use GPU\n    subset\n        Inplace subset to highly-variable genes if `True` otherwise merely indicate\n        highly variable genes.\n    inplace\n        Whether to place calculated metrics in `.var` or return them.\n    n_samples\n        The number of Binomial samples to use to estimate posterior probability\n        of enrichment of zeros for each gene.\n    batch_key\n        key in adata.obs that contains batch info. If None, do not use batch info.\n        Defatult: ``None``.\n    silent\n        If ``True``, disables the progress bar.\n    minibatch_size\n        Size of temporary matrix for incremental calculation. Larger is faster but\n        requires more RAM or GPU memory. (The default should be fine unless\n        there are hundreds of millions cells or millions of genes.)\n\n    Returns\n    -------\n    Depending on `inplace` returns calculated metrics (:class:`~pd.DataFrame`) or\n    updates `.var` with the following fields\n\n    highly_variable : bool\n        boolean indicator of highly-variable genes\n    **observed_fraction_zeros**\n        fraction of observed zeros per gene\n    **expected_fraction_zeros**\n        expected fraction of observed zeros per gene\n    prob_zero_enrichment : float\n        Probability of zero enrichment, median across batches in the case of multiple batches\n    prob_zero_enrichment_rank : float\n        Rank of the gene according to probability of zero enrichment, median rank in the case of multiple batches\n    prob_zero_enriched_nbatches : int\n        If batch_key is given, this denotes in how many batches genes are detected as zero enriched\n\n    \"\"\"", "\n", "data", "=", "adata", ".", "layers", "[", "layer", "]", "if", "layer", "is", "not", "None", "else", "adata", ".", "X", "\n", "if", "_check_nonnegative_integers", "(", "data", ")", "is", "False", ":", "\n", "        ", "raise", "ValueError", "(", "\"`poisson_gene_selection` expects \"", "\"raw count data.\"", ")", "\n", "\n", "", "use_gpu", "=", "use_gpu", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "if", "batch_key", "is", "None", ":", "\n", "        ", "batch_info", "=", "pd", ".", "Categorical", "(", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "int", ")", ")", "\n", "", "else", ":", "\n", "        ", "batch_info", "=", "adata", ".", "obs", "[", "batch_key", "]", "\n", "\n", "", "prob_zero_enrichments", "=", "[", "]", "\n", "obs_frac_zeross", "=", "[", "]", "\n", "exp_frac_zeross", "=", "[", "]", "\n", "for", "b", "in", "np", ".", "unique", "(", "batch_info", ")", ":", "\n", "\n", "        ", "ad", "=", "adata", "[", "batch_info", "==", "b", "]", "\n", "data", "=", "ad", ".", "layers", "[", "layer", "]", "if", "layer", "is", "not", "None", "else", "ad", ".", "X", "\n", "\n", "# Calculate empirical statistics.", "\n", "sum_0", "=", "np", ".", "asarray", "(", "data", ".", "sum", "(", "0", ")", ")", ".", "ravel", "(", ")", "\n", "scaled_means", "=", "torch", ".", "from_numpy", "(", "sum_0", "/", "sum_0", ".", "sum", "(", ")", ")", "\n", "if", "use_gpu", "is", "True", ":", "\n", "            ", "scaled_means", "=", "scaled_means", ".", "cuda", "(", ")", "\n", "", "dev", "=", "scaled_means", ".", "device", "\n", "total_counts", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "data", ".", "sum", "(", "1", ")", ")", ".", "ravel", "(", ")", ")", ".", "to", "(", "dev", ")", "\n", "\n", "observed_fraction_zeros", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "asarray", "(", "1.0", "-", "(", "data", ">", "0", ")", ".", "sum", "(", "0", ")", "/", "data", ".", "shape", "[", "0", "]", ")", ".", "ravel", "(", ")", "\n", ")", ".", "to", "(", "dev", ")", "\n", "\n", "# Calculate probability of zero for a Poisson model.", "\n", "# Perform in batches to save memory.", "\n", "minibatch_size", "=", "min", "(", "total_counts", ".", "shape", "[", "0", "]", ",", "minibatch_size", ")", "\n", "n_batches", "=", "total_counts", ".", "shape", "[", "0", "]", "//", "minibatch_size", "\n", "\n", "expected_fraction_zeros", "=", "torch", ".", "zeros", "(", "scaled_means", ".", "shape", ",", "device", "=", "dev", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "total_counts_batch", "=", "total_counts", "[", "\n", "i", "*", "minibatch_size", ":", "(", "i", "+", "1", ")", "*", "minibatch_size", "\n", "]", "\n", "# Use einsum for outer product.", "\n", "expected_fraction_zeros", "+=", "torch", ".", "exp", "(", "\n", "-", "torch", ".", "einsum", "(", "\"i,j->ij\"", ",", "[", "scaled_means", ",", "total_counts_batch", "]", ")", "\n", ")", ".", "sum", "(", "1", ")", "\n", "\n", "", "total_counts_batch", "=", "total_counts", "[", "(", "i", "+", "1", ")", "*", "minibatch_size", ":", "]", "\n", "expected_fraction_zeros", "+=", "torch", ".", "exp", "(", "\n", "-", "torch", ".", "einsum", "(", "\"i,j->ij\"", ",", "[", "scaled_means", ",", "total_counts_batch", "]", ")", "\n", ")", ".", "sum", "(", "1", ")", "\n", "expected_fraction_zeros", "/=", "data", ".", "shape", "[", "0", "]", "\n", "\n", "# Compute probability of enriched zeros through sampling from Binomial distributions.", "\n", "observed_zero", "=", "torch", ".", "distributions", ".", "Binomial", "(", "probs", "=", "observed_fraction_zeros", ")", "\n", "expected_zero", "=", "torch", ".", "distributions", ".", "Binomial", "(", "probs", "=", "expected_fraction_zeros", ")", "\n", "\n", "extra_zeros", "=", "torch", ".", "zeros", "(", "expected_fraction_zeros", ".", "shape", ",", "device", "=", "dev", ")", "\n", "for", "i", "in", "track", "(", "\n", "range", "(", "n_samples", ")", ",", "\n", "description", "=", "\"Sampling from binomial...\"", ",", "\n", "disable", "=", "silent", ",", "\n", "style", "=", "\"tqdm\"", ",", "# do not change", "\n", ")", ":", "\n", "            ", "extra_zeros", "+=", "observed_zero", ".", "sample", "(", ")", ">", "expected_zero", ".", "sample", "(", ")", "\n", "\n", "", "prob_zero_enrichment", "=", "(", "extra_zeros", "/", "n_samples", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "obs_frac_zeros", "=", "observed_fraction_zeros", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "exp_frac_zeros", "=", "expected_fraction_zeros", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# Clean up memory (tensors seem to stay in GPU unless actively deleted).", "\n", "del", "scaled_means", "\n", "del", "total_counts", "\n", "del", "expected_fraction_zeros", "\n", "del", "observed_fraction_zeros", "\n", "del", "extra_zeros", "\n", "\n", "if", "use_gpu", ":", "\n", "            ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "", "prob_zero_enrichments", ".", "append", "(", "prob_zero_enrichment", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "obs_frac_zeross", ".", "append", "(", "obs_frac_zeros", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "exp_frac_zeross", ".", "append", "(", "exp_frac_zeros", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "# Combine per batch results", "\n", "\n", "", "prob_zero_enrichments", "=", "np", ".", "concatenate", "(", "prob_zero_enrichments", ",", "axis", "=", "0", ")", "\n", "obs_frac_zeross", "=", "np", ".", "concatenate", "(", "obs_frac_zeross", ",", "axis", "=", "0", ")", "\n", "exp_frac_zeross", "=", "np", ".", "concatenate", "(", "exp_frac_zeross", ",", "axis", "=", "0", ")", "\n", "\n", "ranked_prob_zero_enrichments", "=", "prob_zero_enrichments", ".", "argsort", "(", "axis", "=", "1", ")", ".", "argsort", "(", "axis", "=", "1", ")", "\n", "median_prob_zero_enrichments", "=", "np", ".", "median", "(", "prob_zero_enrichments", ",", "axis", "=", "0", ")", "\n", "\n", "median_obs_frac_zeross", "=", "np", ".", "median", "(", "obs_frac_zeross", ",", "axis", "=", "0", ")", "\n", "median_exp_frac_zeross", "=", "np", ".", "median", "(", "exp_frac_zeross", ",", "axis", "=", "0", ")", "\n", "\n", "median_ranked", "=", "np", ".", "median", "(", "ranked_prob_zero_enrichments", ",", "axis", "=", "0", ")", "\n", "\n", "num_batches_zero_enriched", "=", "np", ".", "sum", "(", "\n", "ranked_prob_zero_enrichments", ">=", "(", "adata", ".", "shape", "[", "1", "]", "-", "n_top_genes", ")", ",", "axis", "=", "0", "\n", ")", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "index", "=", "np", ".", "array", "(", "adata", ".", "var_names", ")", ")", "\n", "df", "[", "\"observed_fraction_zeros\"", "]", "=", "median_obs_frac_zeross", "\n", "df", "[", "\"expected_fraction_zeros\"", "]", "=", "median_exp_frac_zeross", "\n", "df", "[", "\"prob_zero_enriched_nbatches\"", "]", "=", "num_batches_zero_enriched", "\n", "df", "[", "\"prob_zero_enrichment\"", "]", "=", "median_prob_zero_enrichments", "\n", "df", "[", "\"prob_zero_enrichment_rank\"", "]", "=", "median_ranked", "\n", "\n", "df", "[", "\"highly_variable\"", "]", "=", "False", "\n", "sort_columns", "=", "[", "\"prob_zero_enriched_nbatches\"", ",", "\"prob_zero_enrichment_rank\"", "]", "\n", "top_genes", "=", "df", ".", "nlargest", "(", "n_top_genes", ",", "sort_columns", ")", ".", "index", "\n", "df", ".", "loc", "[", "top_genes", ",", "\"highly_variable\"", "]", "=", "True", "\n", "\n", "if", "inplace", "or", "subset", ":", "\n", "        ", "adata", ".", "uns", "[", "\"hvg\"", "]", "=", "{", "\"flavor\"", ":", "\"poisson_zeros\"", "}", "\n", "logger", ".", "debug", "(", "\n", "\"added\\n\"", "\n", "\"    'highly_variable', boolean vector (adata.var)\\n\"", "\n", "\"    'prob_zero_enrichment_rank', float vector (adata.var)\\n\"", "\n", "\"    'prob_zero_enrichment' float vector (adata.var)\\n\"", "\n", "\"    'observed_fraction_zeros', float vector (adata.var)\\n\"", "\n", "\"    'expected_fraction_zeros', float vector (adata.var)\\n\"", "\n", ")", "\n", "adata", ".", "var", "[", "\"highly_variable\"", "]", "=", "df", "[", "\"highly_variable\"", "]", ".", "values", "\n", "adata", ".", "var", "[", "\"observed_fraction_zeros\"", "]", "=", "df", "[", "\"observed_fraction_zeros\"", "]", ".", "values", "\n", "adata", ".", "var", "[", "\"expected_fraction_zeros\"", "]", "=", "df", "[", "\"expected_fraction_zeros\"", "]", ".", "values", "\n", "adata", ".", "var", "[", "\"prob_zero_enriched_nbatches\"", "]", "=", "df", "[", "\n", "\"prob_zero_enriched_nbatches\"", "\n", "]", ".", "values", "\n", "adata", ".", "var", "[", "\"prob_zero_enrichment\"", "]", "=", "df", "[", "\"prob_zero_enrichment\"", "]", ".", "values", "\n", "adata", ".", "var", "[", "\"prob_zero_enrichment_rank\"", "]", "=", "df", "[", "\"prob_zero_enrichment_rank\"", "]", ".", "values", "\n", "\n", "if", "batch_key", "is", "not", "None", ":", "\n", "            ", "adata", ".", "var", "[", "\"prob_zero_enriched_nbatches\"", "]", "=", "df", "[", "\n", "\"prob_zero_enriched_nbatches\"", "\n", "]", ".", "values", "\n", "", "if", "subset", ":", "\n", "            ", "adata", ".", "_inplace_subset_var", "(", "df", "[", "\"highly_variable\"", "]", ".", "values", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "batch_key", "is", "None", ":", "\n", "            ", "df", "=", "df", ".", "drop", "(", "[", "\"prob_zero_enriched_nbatches\"", "]", ",", "axis", "=", "1", ")", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.organize_cite_seq_10x": [[234, 281], ["numpy.array", "adata.copy._inplace_subset_var", "pandas.DataFrame", "adata.copy.copy", "adata[].X.copy"], "function", ["None"], ["", "", "def", "organize_cite_seq_10x", "(", "\n", "adata", ":", "anndata", ".", "AnnData", ",", "copy", ":", "bool", "=", "False", "\n", ")", "->", "Optional", "[", "anndata", ".", "AnnData", "]", ":", "\n", "    ", "\"\"\"\n    Organize anndata object loaded from 10x for scvi models.\n\n    Parameters\n    ----------\n    adata\n        AnnData object with RNA and protein data in `.X`\n    copy\n        Whether to copy the anndata object\n\n    Returns\n    -------\n    If copy is True, returns anndata object organized for input to scvi models\n\n    Else, updates the anndata inplace\n\n    Examples\n    --------\n    >>> adata = scanpy.read_10x_h5(<path_to_10x_h5_file>, gex_only=False)\n    >>> adata\n    AnnData object with n_obs \u00d7 n_vars = 713 \u00d7 33555\n        var: 'gene_ids', 'feature_types', 'genome'\n    >>> organize_cite_seq_10x(adata)\n    >>> adata\n    AnnData object with n_obs \u00d7 n_vars = 713 \u00d7 33538\n        var: 'gene_ids', 'feature_types', 'genome'\n        obsm: 'protein_expression'\n    \"\"\"", "\n", "if", "copy", ":", "\n", "        ", "adata", "=", "adata", ".", "copy", "(", ")", "\n", "\n", "", "pro_array", "=", "adata", "[", ":", ",", "adata", ".", "var", "[", "\"feature_types\"", "]", "==", "\"Antibody Capture\"", "]", ".", "X", ".", "copy", "(", ")", ".", "A", "\n", "pro_names", "=", "np", ".", "array", "(", "\n", "adata", ".", "var_names", "[", "adata", ".", "var", "[", "\"feature_types\"", "]", "==", "\"Antibody Capture\"", "]", "\n", ")", "\n", "\n", "genes", "=", "(", "adata", ".", "var", "[", "\"feature_types\"", "]", "!=", "\"Antibody Capture\"", ")", ".", "values", "\n", "adata", ".", "_inplace_subset_var", "(", "genes", ")", "\n", "\n", "pro_df", "=", "pd", ".", "DataFrame", "(", "pro_array", ",", "index", "=", "adata", ".", "obs_names", ",", "columns", "=", "pro_names", ")", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "pro_df", "\n", "\n", "if", "copy", ":", "\n", "        ", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.organize_multiome_anndatas": [[283, 353], ["multi_anndata.copy", "list", "multi_anndata.var.copy", "_concat_anndata.copy", "numpy.intersect1d", "multi_anndata.concatenate", "_preprocessing.organize_multiome_anndatas._concat_anndata"], "function", ["None"], ["", "", "def", "organize_multiome_anndatas", "(", "\n", "multi_anndata", ":", "anndata", ".", "AnnData", ",", "\n", "rna_anndata", ":", "Optional", "[", "anndata", ".", "AnnData", "]", "=", "None", ",", "\n", "atac_anndata", ":", "Optional", "[", "anndata", ".", "AnnData", "]", "=", "None", ",", "\n", "modality_key", ":", "str", "=", "\"modality\"", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"\n    Concatenate multiome and single-modality input anndata objects.\n    These anndata objects should already have been preprocessed so that both single-modality\n    objects use a subset of the features used in the multiome object. The feature names (index of\n    `.var`) should match between the objects.\n\n    Parameters\n    ----------\n    multi_anndata\n        AnnData object with Multiome data (Gene Expression and Chromatin Accessibility)\n    rna_anndata\n        AnnData object with gene expression data\n    atac_anndata\n        AnnData object with chromatin accessibility data\n    modality_key\n        The key to add to the resulting AnnData `.obs`, indicating the modality each cell originated\n        from. Default is \"modality\".\n\n    Notes\n    -----\n    Features that exist in either rna_anndata or atac_anndata but do not exist in multi_anndata will\n    be discarded.\n\n    Returns\n    -------\n    An AnnData object with all cells in the input objects\n    \"\"\"", "\n", "res_anndata", "=", "multi_anndata", ".", "copy", "(", ")", "\n", "\n", "modality_ann", "=", "[", "\"paired\"", "]", "*", "multi_anndata", ".", "shape", "[", "0", "]", "\n", "obs_names", "=", "list", "(", "multi_anndata", ".", "obs", ".", "index", ".", "values", ")", "\n", "\n", "def", "_concat_anndata", "(", "multi_anndata", ",", "other", ")", ":", "\n", "        ", "shared_features", "=", "np", ".", "intersect1d", "(", "\n", "other", ".", "var", ".", "index", ".", "values", ",", "multi_anndata", ".", "var", ".", "index", ".", "values", "\n", ")", "\n", "if", "not", "len", "(", "shared_features", ")", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"No shared features between Multiome and other AnnData.\"", ")", "\n", "\n", "", "other", "=", "other", "[", ":", ",", "shared_features", "]", "\n", "return", "multi_anndata", ".", "concatenate", "(", "other", ",", "join", "=", "\"outer\"", ",", "batch_key", "=", "modality_key", ")", "\n", "\n", "", "if", "rna_anndata", "is", "not", "None", ":", "\n", "        ", "res_anndata", "=", "_concat_anndata", "(", "res_anndata", ",", "rna_anndata", ")", "\n", "\n", "modality_ann", "+=", "[", "\"expression\"", "]", "*", "rna_anndata", ".", "shape", "[", "0", "]", "\n", "obs_names", "+=", "list", "(", "rna_anndata", ".", "obs", ".", "index", ".", "values", ")", "\n", "\n", "", "if", "atac_anndata", "is", "not", "None", ":", "\n", "        ", "res_anndata", "=", "_concat_anndata", "(", "res_anndata", ",", "atac_anndata", ")", "\n", "\n", "modality_ann", "+=", "[", "\"accessibility\"", "]", "*", "atac_anndata", ".", "shape", "[", "0", "]", "\n", "obs_names", "+=", "list", "(", "atac_anndata", ".", "obs", ".", "index", ".", "values", ")", "\n", "\n", "# set .obs stuff", "\n", "", "res_anndata", ".", "obs", "[", "modality_key", "]", "=", "modality_ann", "\n", "res_anndata", ".", "obs", ".", "index", "=", "(", "\n", "pd", ".", "Series", "(", "obs_names", ")", "+", "\"_\"", "+", "res_anndata", ".", "obs", "[", "modality_key", "]", ".", "values", "\n", ")", "\n", "\n", "# keep the feature order as the original order in the multiomic anndata", "\n", "res_anndata", "=", "res_anndata", "[", ":", ",", "multi_anndata", ".", "var", ".", "index", ".", "values", "]", "\n", "res_anndata", ".", "var", "=", "multi_anndata", ".", "var", ".", "copy", "(", ")", "\n", "return", "res_anndata", ".", "copy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download": [[13, 63], ["os.path.exists", "urllib.request.Request", "logger.info", "int", "numpy.rint", "os.path.join", "logger.info", "urllib.request.urlopen", "os.path.exists", "os.makedirs", "urllib.request.urlopen.getheader", "open", "_download._download.read_iter"], "function", ["None"], ["def", "_download", "(", "url", ":", "Optional", "[", "str", "]", ",", "save_path", ":", "str", ",", "filename", ":", "str", ")", ":", "\n", "    ", "\"\"\"Writes data from url to file.\"\"\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "filename", ")", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"File {os.path.join(save_path, filename)} already downloaded\"", ")", "\n", "return", "\n", "", "elif", "url", "is", "None", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "f\"No backup URL provided for missing file {os.path.join(save_path, filename)}\"", "\n", ")", "\n", "return", "\n", "", "req", "=", "urllib", ".", "request", ".", "Request", "(", "url", ",", "headers", "=", "{", "\"User-Agent\"", ":", "\"Magic Browser\"", "}", ")", "\n", "try", ":", "\n", "        ", "r", "=", "urllib", ".", "request", ".", "urlopen", "(", "req", ")", "\n", "if", "r", ".", "getheader", "(", "\"Content-Length\"", ")", "is", "None", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "\n", "f\"Found file with no content at {url}. \"", "\n", "\"This is possibly a directory rather than a file path.\"", "\n", ")", "\n", "", "", "except", "urllib", ".", "error", ".", "HTTPError", "as", "exc", ":", "\n", "        ", "if", "exc", ".", "code", "==", "\"404\"", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f\"Could not find file at {url}\"", ")", "from", "exc", "\n", "", "raise", "exc", "\n", "", "logger", ".", "info", "(", "\"Downloading file at %s\"", "%", "os", ".", "path", ".", "join", "(", "save_path", ",", "filename", ")", ")", "\n", "\n", "def", "read_iter", "(", "file", ",", "block_size", "=", "1000", ")", ":", "\n", "        ", "\"\"\"\n        Iterates through file.\n\n        Given a file 'file', returns an iterator that returns bytes of\n        size 'blocksize' from the file, using read().\n        \"\"\"", "\n", "while", "True", ":", "\n", "            ", "block", "=", "file", ".", "read", "(", "block_size", ")", "\n", "if", "not", "block", ":", "\n", "                ", "break", "\n", "", "yield", "block", "\n", "\n", "# Create the path to save the data", "\n", "", "", "if", "not", "os", ".", "path", ".", "exists", "(", "save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_path", ")", "\n", "", "block_size", "=", "1000", "\n", "\n", "filesize", "=", "int", "(", "r", ".", "getheader", "(", "\"Content-Length\"", ")", ")", "\n", "filesize", "=", "np", ".", "rint", "(", "filesize", "/", "block_size", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "filename", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "        ", "iterator", "=", "read_iter", "(", "r", ",", "block_size", "=", "block_size", ")", "\n", "for", "data", "in", "track", "(", "\n", "iterator", ",", "style", "=", "\"tqdm\"", ",", "total", "=", "filesize", ",", "description", "=", "\"Downloading...\"", "\n", ")", ":", "\n", "            ", "f", ".", "write", "(", "data", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.__init__": [[56, 72], ["str", "uuid.uuid4", "collections.defaultdict", "_manager.AnnDataManager._registry.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "fields", ":", "Optional", "[", "Sequence", "[", "AnnDataField", "]", "]", "=", "None", ",", "\n", "setup_method_args", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "id", "=", "str", "(", "uuid4", "(", ")", ")", "\n", "self", ".", "adata", "=", "None", "\n", "self", ".", "fields", "=", "fields", "or", "[", "]", "\n", "self", ".", "_registry", "=", "{", "\n", "_constants", ".", "_SCVI_VERSION_KEY", ":", "scvi", ".", "__version__", ",", "\n", "_constants", ".", "_MODEL_NAME_KEY", ":", "None", ",", "\n", "_constants", ".", "_SETUP_ARGS_KEY", ":", "None", ",", "\n", "_constants", ".", "_FIELD_REGISTRIES_KEY", ":", "defaultdict", "(", "dict", ")", ",", "\n", "}", "\n", "if", "setup_method_args", "is", "not", "None", ":", "\n", "            ", "self", ".", "_registry", ".", "update", "(", "setup_method_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered": [[73, 78], ["AssertionError"], "methods", ["None"], ["", "", "def", "_assert_anndata_registered", "(", "self", ")", ":", "\n", "        ", "\"\"\"Asserts that an AnnData object has been registered with this instance.\"\"\"", "\n", "if", "self", ".", "adata", "is", "None", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "\"AnnData object not registered. Please call register_fields.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._validate_anndata_object": [[80, 87], ["_utils._check_if_view", "isinstance", "_utils._check_mudata_fully_paired"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_if_view", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_mudata_fully_paired"], ["", "", "@", "staticmethod", "\n", "def", "_validate_anndata_object", "(", "adata", ":", "AnnOrMuData", ")", ":", "\n", "        ", "\"\"\"For a given AnnData object, runs general scvi-tools compatibility checks.\"\"\"", "\n", "_check_if_view", "(", "adata", ",", "copy_if_view", "=", "False", ")", "\n", "\n", "if", "isinstance", "(", "adata", ",", "MuData", ")", ":", "\n", "            ", "_check_mudata_fully_paired", "(", "adata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args": [[88, 100], ["_manager.AnnDataManager._registry.items"], "methods", ["None"], ["", "", "def", "_get_setup_method_args", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns the ``setup_anndata`` method arguments used to initialize this :class:`~scvi.data.AnnDataManager` instance.\n\n        Returns the ``setup_anndata`` method arguments, including the model name,\n        that were used to initialize this :class:`~scvi.data.AnnDataManager` instance\n        in the form of a dictionary.\n        \"\"\"", "\n", "return", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "self", ".", "_registry", ".", "items", "(", ")", "\n", "if", "k", "in", "{", "_constants", ".", "_MODEL_NAME_KEY", ",", "_constants", ".", "_SETUP_ARGS_KEY", "}", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assign_uuid": [[102, 110], ["_manager.AnnDataManager._assert_anndata_registered", "_utils._assign_adata_uuid"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._assign_adata_uuid"], ["", "def", "_assign_uuid", "(", "self", ")", ":", "\n", "        ", "\"\"\"Assigns a UUID unique to the AnnData object. If already present, the UUID is left alone.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "_assign_adata_uuid", "(", "self", ".", "adata", ")", "\n", "\n", "scvi_uuid", "=", "self", ".", "adata", ".", "uns", "[", "_constants", ".", "_SCVI_UUID_KEY", "]", "\n", "self", ".", "_registry", "[", "_constants", ".", "_SCVI_UUID_KEY", "]", "=", "scvi_uuid", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assign_most_recent_manager_uuid": [[111, 118], ["_manager.AnnDataManager._assert_anndata_registered"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered"], ["", "def", "_assign_most_recent_manager_uuid", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Assigns a last manager UUID to the AnnData object for future validation.\n        \"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "self", ".", "adata", ".", "uns", "[", "_constants", ".", "_MANAGER_UUID_KEY", "]", "=", "self", ".", "id", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields": [[119, 192], ["_manager.AnnDataManager._validate_anndata_object", "copy.deepcopy", "copy.deepcopy", "_manager.AnnDataManager._assign_uuid", "_manager.AnnDataManager._assign_most_recent_manager_uuid", "AssertionError", "TypeError", "field.get_summary_stats", "field.get_data_registry", "dict", "field.transfer_field", "field.register_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._validate_anndata_object", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assign_uuid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assign_most_recent_manager_uuid", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.get_summary_stats", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_data_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "def", "register_fields", "(", "\n", "self", ",", "\n", "adata", ":", "AnnOrMuData", ",", "\n", "source_registry", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "**", "transfer_kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Registers each field associated with this instance with the AnnData object.\n\n        Either registers or transfers the setup from `source_setup_dict` if passed in.\n        Sets ``self.adata``.\n\n        Parameters\n        ----------\n        adata\n            AnnData object to be registered.\n        source_registry\n            Registry created after registering an AnnData using an :class:`~scvi.data.AnnDataManager` object.\n        transfer_kwargs\n            Additional keywords which modify transfer behavior. Only applicable if ``source_registry`` is set.\n        \"\"\"", "\n", "if", "self", ".", "adata", "is", "not", "None", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "\"Existing AnnData object registered with this Manager instance.\"", "\n", ")", "\n", "\n", "", "if", "source_registry", "is", "None", "and", "transfer_kwargs", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f\"register_fields() got unexpected keyword arguments {transfer_kwargs} passed without a source_registry.\"", "\n", ")", "\n", "\n", "", "self", ".", "_validate_anndata_object", "(", "adata", ")", "\n", "field_registries", "=", "self", ".", "_registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", "\n", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "field_registries", "[", "field", ".", "registry_key", "]", "=", "{", "\n", "_constants", ".", "_DATA_REGISTRY_KEY", ":", "field", ".", "get_data_registry", "(", ")", ",", "\n", "_constants", ".", "_STATE_REGISTRY_KEY", ":", "dict", "(", ")", ",", "\n", "}", "\n", "field_registry", "=", "field_registries", "[", "field", ".", "registry_key", "]", "\n", "\n", "# A field can be empty if the model has optional fields (e.g. extra covariates).", "\n", "# If empty, we skip registering the field.", "\n", "if", "not", "field", ".", "is_empty", ":", "\n", "# Transfer case: Source registry is used for validation and/or setup.", "\n", "                ", "if", "source_registry", "is", "not", "None", ":", "\n", "                    ", "field_registry", "[", "\n", "_constants", ".", "_STATE_REGISTRY_KEY", "\n", "]", "=", "field", ".", "transfer_field", "(", "\n", "source_registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", "[", "\n", "field", ".", "registry_key", "\n", "]", "[", "_constants", ".", "_STATE_REGISTRY_KEY", "]", ",", "\n", "adata", ",", "\n", "**", "transfer_kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "field_registry", "[", "\n", "_constants", ".", "_STATE_REGISTRY_KEY", "\n", "]", "=", "field", ".", "register_field", "(", "adata", ")", "\n", "\n", "# Compute and set summary stats for the given field.", "\n", "", "", "state_registry", "=", "field_registry", "[", "_constants", ".", "_STATE_REGISTRY_KEY", "]", "\n", "field_registry", "[", "_constants", ".", "_SUMMARY_STATS_KEY", "]", "=", "field", ".", "get_summary_stats", "(", "\n", "state_registry", "\n", ")", "\n", "\n", "# Save arguments for register_fields.", "\n", "", "self", ".", "_source_registry", "=", "deepcopy", "(", "source_registry", ")", "\n", "self", ".", "_transfer_kwargs", "=", "deepcopy", "(", "transfer_kwargs", ")", "\n", "\n", "self", ".", "adata", "=", "adata", "\n", "self", ".", "_assign_uuid", "(", ")", "\n", "self", ".", "_assign_most_recent_manager_uuid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields": [[193, 216], ["_manager.AnnDataManager._assert_anndata_registered", "_manager.AnnDataManager.__class__", "_manager.AnnDataManager.register_fields", "_manager.AnnDataManager._get_setup_method_args"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args"], ["", "def", "transfer_fields", "(", "self", ",", "adata_target", ":", "AnnOrMuData", ",", "**", "kwargs", ")", "->", "AnnDataManager", ":", "\n", "        ", "\"\"\"\n        Transfers an existing setup to each field associated with this instance with the target AnnData object.\n\n        Creates a new :class:`~scvi.data.AnnDataManager` instance with the same set of fields.\n        Then, registers the fields with a target AnnData object, incorporating details of the\n        source registry where necessary (e.g. for validation or modified data setup).\n\n        Parameters\n        ----------\n        adata_target\n            AnnData object to be registered.\n        kwargs\n            Additional keywords which modify transfer behavior.\n        \"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "fields", "=", "self", ".", "fields", "\n", "new_adata_manager", "=", "self", ".", "__class__", "(", "\n", "fields", "=", "fields", ",", "setup_method_args", "=", "self", ".", "_get_setup_method_args", "(", ")", "\n", ")", "\n", "new_adata_manager", ".", "register_fields", "(", "adata_target", ",", "self", ".", "_registry", ",", "**", "kwargs", ")", "\n", "return", "new_adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.validate": [[217, 226], ["_manager.AnnDataManager._assert_anndata_registered", "_manager.AnnDataManager.register_fields"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields"], ["", "def", "validate", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Checks if AnnData was last setup with this AnnDataManager instance and reregisters it if not.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "most_recent_manager_id", "=", "self", ".", "adata", ".", "uns", "[", "_constants", ".", "_MANAGER_UUID_KEY", "]", "\n", "# Re-register fields with same arguments if this AnnData object has been", "\n", "# registered with a different AnnDataManager.", "\n", "if", "most_recent_manager_id", "!=", "self", ".", "id", ":", "\n", "            ", "adata", ",", "self", ".", "adata", "=", "self", ".", "adata", ",", "None", "# Reset self.adata.", "\n", "self", ".", "register_fields", "(", "adata", ",", "self", ".", "_source_registry", ",", "**", "self", ".", "_transfer_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.adata_uuid": [[227, 233], ["_manager.AnnDataManager._assert_anndata_registered"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered"], ["", "", "@", "property", "\n", "def", "adata_uuid", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Returns the UUID for the AnnData object registered with this instance.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "return", "self", ".", "_registry", "[", "_constants", ".", "_SCVI_UUID_KEY", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.registry": [[234, 238], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "registry", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"Returns the top-level registry dictionary for the AnnData object registered with this instance as an attrdict.\"\"\"", "\n", "return", "self", ".", "_registry", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.data_registry": [[239, 253], ["_manager.AnnDataManager._assert_anndata_registered", "dict", "_manager.AnnDataManager._registry[].items", "scvi.utils.attrdict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered"], ["", "@", "property", "\n", "def", "data_registry", "(", "self", ")", "->", "attrdict", ":", "\n", "        ", "\"\"\"Returns the data registry for the AnnData object registered with this instance.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "data_registry", "=", "dict", "(", ")", "\n", "for", "registry_key", ",", "field_registry", "in", "self", ".", "_registry", "[", "\n", "_constants", ".", "_FIELD_REGISTRIES_KEY", "\n", "]", ".", "items", "(", ")", ":", "\n", "            ", "field_data_registry", "=", "field_registry", "[", "_constants", ".", "_DATA_REGISTRY_KEY", "]", "\n", "if", "field_data_registry", ":", "\n", "                ", "data_registry", "[", "registry_key", "]", "=", "field_data_registry", "\n", "\n", "", "", "return", "attrdict", "(", "data_registry", ",", "recursive", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.summary_stats": [[254, 265], ["_manager.AnnDataManager._assert_anndata_registered", "dict", "_manager.AnnDataManager._registry[].values", "scvi.utils.attrdict", "dict.update"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["", "@", "property", "\n", "def", "summary_stats", "(", "self", ")", "->", "attrdict", ":", "\n", "        ", "\"\"\"Returns the summary stats for the AnnData object registered with this instance.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "summary_stats", "=", "dict", "(", ")", "\n", "for", "field_registry", "in", "self", ".", "_registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", ".", "values", "(", ")", ":", "\n", "            ", "field_summary_stats", "=", "field_registry", "[", "_constants", ".", "_SUMMARY_STATS_KEY", "]", "\n", "summary_stats", ".", "update", "(", "field_summary_stats", ")", "\n", "\n", "", "return", "attrdict", "(", "summary_stats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry": [[266, 287], ["_utils.get_anndata_attribute", "getattr"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["", "def", "get_from_registry", "(", "self", ",", "registry_key", ":", "str", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "\"\"\"\n        Returns the object in AnnData associated with the key in the data registry.\n\n        Parameters\n        ----------\n        registry_key\n            key of object to get from ``self.data_registry``\n\n        Returns\n        -------\n        The requested data.\n        \"\"\"", "\n", "data_loc", "=", "self", ".", "data_registry", "[", "registry_key", "]", "\n", "mod_key", ",", "attr_name", ",", "attr_key", "=", "(", "\n", "getattr", "(", "data_loc", ",", "_constants", ".", "_DR_MOD_KEY", ",", "None", ")", ",", "\n", "data_loc", "[", "_constants", ".", "_DR_ATTR_NAME", "]", ",", "\n", "data_loc", "[", "_constants", ".", "_DR_ATTR_KEY", "]", ",", "\n", ")", "\n", "\n", "return", "get_anndata_attribute", "(", "self", ".", "adata", ",", "attr_name", ",", "attr_key", ",", "mod_key", "=", "mod_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry": [[288, 295], ["_manager.AnnDataManager._assert_anndata_registered", "scvi.utils.attrdict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._assert_anndata_registered"], ["", "def", "get_state_registry", "(", "self", ",", "registry_key", ":", "str", ")", "->", "attrdict", ":", "\n", "        ", "\"\"\"Returns the state registry for the AnnDataField registered with this instance.\"\"\"", "\n", "self", ".", "_assert_anndata_registered", "(", ")", "\n", "\n", "return", "attrdict", "(", "\n", "self", ".", "_registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", "[", "registry_key", "]", "[", "\n", "_constants", ".", "_STATE_REGISTRY_KEY", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._view_summary_stats": [[298, 318], ["rich.table.Table", "rich.table.Table.add_column", "rich.table.Table.add_column", "_manager.AnnDataManager.summary_stats.items", "rich.table.Table.add_row", "str"], "methods", ["None"], ["", "def", "_view_summary_stats", "(", "self", ")", "->", "rich", ".", "table", ".", "Table", ":", "\n", "        ", "\"\"\"Prints summary stats.\"\"\"", "\n", "t", "=", "rich", ".", "table", ".", "Table", "(", "title", "=", "\"Summary Statistics\"", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Summary Stat Key\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dodger_blue1\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Value\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dark_violet\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "for", "stat_key", ",", "count", "in", "self", ".", "summary_stats", ".", "items", "(", ")", ":", "\n", "            ", "t", ".", "add_row", "(", "stat_key", ",", "str", "(", "count", ")", ")", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._view_data_registry": [[319, 351], ["rich.table.Table", "rich.table.Table.add_column", "rich.table.Table.add_column", "_manager.AnnDataManager.data_registry.items", "getattr", "rich.table.Table.add_row"], "methods", ["None"], ["", "def", "_view_data_registry", "(", "self", ")", "->", "rich", ".", "table", ".", "Table", ":", "\n", "        ", "\"\"\"Prints data registry.\"\"\"", "\n", "t", "=", "rich", ".", "table", ".", "Table", "(", "title", "=", "\"Data Registry\"", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Registry Key\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dodger_blue1\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"scvi-tools Location\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dark_violet\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "\n", "for", "registry_key", ",", "data_loc", "in", "self", ".", "data_registry", ".", "items", "(", ")", ":", "\n", "            ", "mod_key", "=", "getattr", "(", "data_loc", ",", "_constants", ".", "_DR_MOD_KEY", ",", "None", ")", "\n", "attr_name", "=", "data_loc", ".", "attr_name", "\n", "attr_key", "=", "data_loc", ".", "attr_key", "\n", "scvi_data_str", "=", "\"adata\"", "\n", "if", "mod_key", "is", "not", "None", ":", "\n", "                ", "scvi_data_str", "+=", "f\".mod['{mod_key}']\"", "\n", "", "if", "attr_key", "is", "None", ":", "\n", "                ", "scvi_data_str", "+=", "f\".{attr_name}\"", "\n", "", "else", ":", "\n", "                ", "scvi_data_str", "+=", "f\".{attr_name}['{attr_key}']\"", "\n", "", "t", ".", "add_row", "(", "registry_key", ",", "scvi_data_str", ")", "\n", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_setup_method_args": [[352, 368], ["rich.print", "rich.pretty.pprint", "rich.print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "view_setup_method_args", "(", "registry", ":", "dict", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Prints setup kwargs used to produce a given registry.\n\n        Parameters\n        ----------\n        registry\n            Registry produced by an AnnDataManager.\n        \"\"\"", "\n", "model_name", "=", "registry", "[", "_constants", ".", "_MODEL_NAME_KEY", "]", "\n", "setup_args", "=", "registry", "[", "_constants", ".", "_SETUP_ARGS_KEY", "]", "\n", "if", "model_name", "is", "not", "None", "and", "setup_args", "is", "not", "None", ":", "\n", "            ", "rich", ".", "print", "(", "f\"Setup via `{model_name}.setup_anndata` with arguments:\"", ")", "\n", "rich", ".", "pretty", ".", "pprint", "(", "setup_args", ")", "\n", "rich", ".", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry": [[369, 395], ["rich.print", "rich.print", "_manager.AnnDataManager.view_setup_method_args", "rich.console.Console", "rich.console.Console.print", "rich.console.Console.print", "_manager.AnnDataManager._view_summary_stats", "_manager.AnnDataManager._view_data_registry", "_manager.AnnDataManager.get_state_registry", "field.view_state_registry", "rich.console.Console.print"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._view_summary_stats", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._view_data_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.view_state_registry"], ["", "", "def", "view_registry", "(", "self", ",", "hide_state_registries", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Prints summary of the registry.\n\n        Parameters\n        ----------\n        hide_state_registries\n            If True, prints a shortened summary without details of each state registry.\n        \"\"\"", "\n", "version", "=", "self", ".", "_registry", "[", "_constants", ".", "_SCVI_VERSION_KEY", "]", "\n", "rich", ".", "print", "(", "f\"Anndata setup with scvi-tools version {version}.\"", ")", "\n", "rich", ".", "print", "(", ")", "\n", "self", ".", "view_setup_method_args", "(", "self", ".", "_registry", ")", "\n", "\n", "in_colab", "=", "\"google.colab\"", "in", "sys", ".", "modules", "\n", "force_jupyter", "=", "None", "if", "not", "in_colab", "else", "True", "\n", "console", "=", "rich", ".", "console", ".", "Console", "(", "force_jupyter", "=", "force_jupyter", ")", "\n", "console", ".", "print", "(", "self", ".", "_view_summary_stats", "(", ")", ")", "\n", "console", ".", "print", "(", "self", ".", "_view_data_registry", "(", ")", ")", "\n", "\n", "if", "not", "hide_state_registries", ":", "\n", "            ", "for", "field", "in", "self", ".", "fields", ":", "\n", "                ", "state_registry", "=", "self", ".", "get_state_registry", "(", "field", ".", "registry_key", ")", "\n", "t", "=", "field", ".", "view_state_registry", "(", "state_registry", ")", "\n", "if", "t", "is", "not", "None", ":", "\n", "                    ", "console", ".", "print", "(", "t", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._smfish._load_smfish": [[46, 59], ["os.path.abspath", "scvi.data._download._download", "_smfish._load_smfish_data", "numpy.zeros", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._smfish._load_smfish_data"], ["def", "_load_smfish", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "use_high_level_cluster", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"http://linnarssonlab.org/osmFISH/osmFISH_SScortex_mouse_all_cells.loom\"", "\n", "save_fn", "=", "\"osmFISH_SScortex_mouse_all_cell.loom\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_smfish_data", "(", "\n", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ",", "use_high_level_cluster", "=", "use_high_level_cluster", "\n", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._smfish._load_smfish_data": [[61, 114], ["logger.info", "loompy.connect", "loompy.connect.ra[].astype", "numpy.asarray", "anndata.AnnData", "pandas.Categorical", "_subtype_to_high_level_mapping.items", "pandas.Categorical", "numpy.where", "range"], "function", ["None"], ["", "def", "_load_smfish_data", "(", "\n", "path_to_file", ":", "str", ",", "use_high_level_cluster", ":", "bool", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "import", "loompy", "\n", "\n", "logger", ".", "info", "(", "\"Loading smFISH dataset\"", ")", "\n", "ds", "=", "loompy", ".", "connect", "(", "path_to_file", ")", "\n", "x_coord", ",", "y_coord", "=", "ds", ".", "ca", "[", "\"X\"", "]", ",", "ds", ".", "ca", "[", "\"Y\"", "]", "\n", "data", "=", "ds", "[", ":", ",", ":", "]", ".", "T", "\n", "gene_names", "=", "ds", ".", "ra", "[", "\"Gene\"", "]", ".", "astype", "(", "np", ".", "str", ")", "\n", "labels", "=", "ds", ".", "ca", "[", "\"ClusterID\"", "]", "\n", "str_labels", "=", "np", ".", "asarray", "(", "ds", ".", "ca", "[", "\"ClusterName\"", "]", ")", "\n", "labels_mapping", "=", "pd", ".", "Categorical", "(", "str_labels", ")", ".", "categories", "\n", "\n", "if", "use_high_level_cluster", ":", "\n", "        ", "for", "high_level_cluster", ",", "subtypes", "in", "_subtype_to_high_level_mapping", ".", "items", "(", ")", ":", "\n", "            ", "for", "subtype", "in", "subtypes", ":", "\n", "                ", "idx", "=", "np", ".", "where", "(", "str_labels", "==", "subtype", ")", "\n", "str_labels", "[", "idx", "]", "=", "high_level_cluster", "\n", "", "", "cell_types_to_keep", "=", "[", "\n", "\"Astrocytes\"", ",", "\n", "\"Endothelials\"", ",", "\n", "\"Inhibitory\"", ",", "\n", "\"Microglias\"", ",", "\n", "\"Oligodendrocytes\"", ",", "\n", "\"Pyramidals\"", ",", "\n", "]", "\n", "row_indices", "=", "[", "\n", "i", "\n", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "0", "]", ")", "\n", "if", "ds", ".", "ca", "[", "\"ClusterName\"", "]", "[", "i", "]", "in", "cell_types_to_keep", "\n", "]", "\n", "str_labels", "=", "str_labels", "[", "row_indices", "]", "\n", "data", "=", "data", "[", "row_indices", ",", ":", "]", "\n", "x_coord", "=", "x_coord", "[", "row_indices", "]", "\n", "y_coord", "=", "y_coord", "[", "row_indices", "]", "\n", "\n", "str_labels", "=", "pd", ".", "Categorical", "(", "str_labels", ")", "\n", "labels", "=", "str_labels", ".", "codes", "\n", "labels_mapping", "=", "str_labels", ".", "categories", "\n", "\n", "", "adata", "=", "anndata", ".", "AnnData", "(", "\n", "X", "=", "data", ",", "\n", "obs", "=", "{", "\n", "\"x_coord\"", ":", "x_coord", ",", "\n", "\"y_coord\"", ":", "y_coord", ",", "\n", "\"labels\"", ":", "labels", ",", "\n", "\"str_labels\"", ":", "str_labels", ",", "\n", "}", ",", "\n", "uns", "=", "{", "\"cell_types\"", ":", "labels_mapping", "}", ",", "\n", ")", "\n", "adata", ".", "var_names", "=", "gene_names", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_breast_cancer_dataset": [[12, 24], ["os.path.abspath", "scvi.data._download._download", "_csv._load_csv", "numpy.zeros().astype", "numpy.zeros().astype", "os.path.join", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_csv"], ["def", "_load_breast_cancer_dataset", "(", "save_path", ":", "str", "=", "\"data/\"", ")", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"http://www.spatialtranscriptomicsresearch.org/wp-content/uploads/2016/07/Layer2_BC_count_matrix-1.tsv\"", "\n", "save_fn", "=", "\"Layer2_BC_count_matrix-1.tsv\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ",", "delimiter", "=", "\"\\t\"", ",", "gene_by_cell", "=", "False", "\n", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "int", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "int", ")", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_mouse_ob_dataset": [[26, 38], ["os.path.abspath", "scvi.data._download._download", "_csv._load_csv", "numpy.zeros().astype", "numpy.zeros().astype", "os.path.join", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_csv"], ["", "def", "_load_mouse_ob_dataset", "(", "save_path", ":", "str", "=", "\"data/\"", ")", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"http://www.spatialtranscriptomicsresearch.org/wp-content/uploads/2016/07/Rep11_MOB_count_matrix-1.tsv\"", "\n", "save_fn", "=", "\"Rep11_MOB_count_matrix-1.tsv\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_csv", "(", "\n", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ",", "delimiter", "=", "\"\\t\"", ",", "gene_by_cell", "=", "False", "\n", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "int", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "int", ")", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._csv._load_csv": [[40, 54], ["logger.info", "anndata.read_csv", "logger.info"], "function", ["None"], ["", "def", "_load_csv", "(", "\n", "path_to_file", ":", "str", ",", "\n", "gene_by_cell", ":", "bool", "=", "False", ",", "\n", "delimiter", ":", "str", "=", "\",\"", ",", "\n", "first_column_names", ":", "bool", "=", "None", ",", "\n", ")", ":", "\n", "    ", "logger", ".", "info", "(", "\"Loading dataset from {}\"", ".", "format", "(", "path_to_file", ")", ")", "\n", "adata", "=", "anndata", ".", "read_csv", "(", "\n", "path_to_file", ",", "delimiter", "=", "delimiter", ",", "first_column_names", "=", "first_column_names", "\n", ")", "\n", "if", "gene_by_cell", ":", "\n", "        ", "adata", ".", "X", "=", "adata", ".", "X", ".", "T", "\n", "", "logger", ".", "info", "(", "\"Finished loading dataset\"", ")", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfishplus": [[14, 42], ["os.path.abspath", "scvi.data._download._download", "_seqfish._load_seqfishplus_data", "numpy.zeros", "numpy.zeros", "os.path.join", "ValueError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfishplus_data"], ["def", "_load_seqfishplus", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "tissue_region", ":", "str", "=", "\"subventricular cortex\"", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "\n", "    ", "if", "tissue_region", "==", "\"subventricular cortex\"", ":", "\n", "        ", "file_prefix", "=", "\"cortex_svz\"", "\n", "", "elif", "tissue_region", "==", "\"olfactory bulb\"", ":", "\n", "        ", "file_prefix", "=", "\"ob\"", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'`tissue_type` must be \"subventricular cortex\" or \"olfactory bulb\", but got {}'", ".", "format", "(", "\n", "tissue_region", "\n", ")", "\n", ")", "\n", "\n", "", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://github.com/CaiGroup/seqFISH-PLUS/raw/master/sourcedata.zip\"", "\n", "save_fn", "=", "\"seqfishplus.zip\"", "\n", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_seqfishplus_data", "(", "\n", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ",", "file_prefix", ",", "save_path", ",", "gene_by_cell", "=", "False", "\n", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfishplus_data": [[44, 67], ["os.path.join", "pandas.read_csv", "anndata.AnnData", "pandas.read_csv", "os.path.exists", "os.makedirs", "zipfile.ZipFile", "f.extract", "f.extract", "os.path.join", "os.path.join"], "function", ["None"], ["", "def", "_load_seqfishplus_data", "(", "\n", "path_to_file", ":", "str", ",", "file_prefix", ":", "str", ",", "save_path", ":", "str", ",", "gene_by_cell", ":", "bool", "=", "False", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "counts_filename", "=", "\"sourcedata/{}_counts.csv\"", ".", "format", "(", "file_prefix", ")", "\n", "coordinates_filename", "=", "\"sourcedata/{}_cellcentroids.csv\"", ".", "format", "(", "file_prefix", ")", "\n", "extract_location", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"seqfishplus\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "extract_location", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "extract_location", ")", "\n", "", "with", "zipfile", ".", "ZipFile", "(", "path_to_file", ")", "as", "f", ":", "\n", "        ", "f", ".", "extract", "(", "counts_filename", ",", "path", "=", "extract_location", ")", "\n", "f", ".", "extract", "(", "coordinates_filename", ",", "path", "=", "extract_location", ")", "\n", "\n", "", "df_counts", "=", "pd", ".", "read_csv", "(", "os", ".", "path", ".", "join", "(", "extract_location", ",", "counts_filename", ")", ")", "\n", "adata", "=", "anndata", ".", "AnnData", "(", "df_counts", ")", "\n", "adata", ".", "var_names", "=", "df_counts", ".", "columns", "\n", "df_coordinates", "=", "pd", ".", "read_csv", "(", "os", ".", "path", ".", "join", "(", "extract_location", ",", "coordinates_filename", ")", ")", "\n", "\n", "adata", ".", "obs", "[", "\"X\"", "]", "=", "df_coordinates", "[", "\"X\"", "]", ".", "values", "\n", "adata", ".", "obs", "[", "\"Y\"", "]", "=", "df_coordinates", "[", "\"Y\"", "]", ".", "values", "\n", "adata", ".", "obs", "[", "\"cell_id\"", "]", "=", "df_coordinates", "[", "\"Cell ID\"", "]", ".", "values", "\n", "adata", ".", "obs", "[", "\"field_of_view\"", "]", "=", "df_coordinates", "[", "\"Field of View\"", "]", ".", "values", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfish": [[69, 78], ["os.path.abspath", "scvi.data._download._download", "_seqfish._load_seqfish_data", "numpy.zeros", "numpy.zeros", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfish_data"], ["", "def", "_load_seqfish", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://www.cell.com/cms/attachment/2080562255/2072099886/mmc6.xlsx\"", "\n", "save_fn", "=", "\"SeqFISH.xlsx\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_seqfish_data", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._seqfish._load_seqfish_data": [[80, 92], ["logger.info", "pandas.read_excel", "pd.read_excel.values[].astype", "anndata.AnnData", "logger.info", "pd.read_excel.values[].astype", "pandas.DataFrame"], "function", ["None"], ["", "def", "_load_seqfish_data", "(", "path_to_file", ":", "str", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "logger", ".", "info", "(", "\"Loading seqfish dataset from {}\"", ".", "format", "(", "path_to_file", ")", ")", "\n", "counts", "=", "pd", ".", "read_excel", "(", "\n", "path_to_file", ",", "sheet_name", "=", "\"Hippocampus Counts\"", ",", "engine", "=", "\"openpyxl\"", "\n", ")", "\n", "data", "=", "(", "\n", "counts", ".", "values", "[", ":", ",", "1", ":", "]", ".", "astype", "(", "int", ")", ".", "T", "\n", ")", "# transpose because counts is genes X cells", "\n", "gene_names", "=", "counts", ".", "values", "[", ":", ",", "0", "]", ".", "astype", "(", "str", ")", "\n", "adata", "=", "anndata", ".", "AnnData", "(", "pd", ".", "DataFrame", "(", "data", "=", "data", ",", "columns", "=", "gene_names", ")", ")", "\n", "logger", ".", "info", "(", "\"Finished loading seqfish dataset\"", ")", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._pbmc._load_purified_pbmc_dataset": [[12, 45], ["scvi.data._download._download", "os.path.join", "anndata.read", "numpy.concatenate", "adata[].copy", "np.concatenate.append", "numpy.where"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["def", "_load_purified_pbmc_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "subset_datasets", ":", "List", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/PurifiedPBMCDataset.h5ad\"", "\n", "save_fn", "=", "\"PurifiedPBMCDataset.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "path_to_file", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "anndata", ".", "read", "(", "path_to_file", ")", "\n", "\n", "dataset_names", "=", "[", "\n", "\"cd4_t_helper\"", ",", "\n", "\"regulatory_t\"", ",", "\n", "\"naive_t\"", ",", "\n", "\"memory_t\"", ",", "\n", "\"cytotoxic_t\"", ",", "\n", "\"naive_cytotoxic\"", ",", "\n", "\"b_cells\"", ",", "\n", "\"cd4_t_helper\"", ",", "\n", "\"cd34\"", ",", "\n", "\"cd56_nk\"", ",", "\n", "\"cd14_monocytes\"", ",", "\n", "]", "\n", "if", "subset_datasets", "is", "not", "None", ":", "\n", "        ", "row_indices", "=", "[", "]", "\n", "for", "dataset", "in", "subset_datasets", ":", "\n", "            ", "assert", "dataset", "in", "dataset_names", "\n", "idx", "=", "np", ".", "where", "(", "adata", ".", "obs", "[", "\"cell_types\"", "]", "==", "dataset", ")", "[", "0", "]", "\n", "row_indices", ".", "append", "(", "idx", ")", "\n", "", "row_indices", "=", "np", ".", "concatenate", "(", "row_indices", ")", "\n", "adata", "=", "adata", "[", "row_indices", "]", ".", "copy", "(", ")", "\n", "\n", "", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._pbmc._load_pbmc_dataset": [[47, 123], ["range", "pandas.read_csv", "pandas.read_pickle", "scvi.data._built_in_data._dataset_10x._load_dataset_10x", "scvi.data._built_in_data._dataset_10x._load_dataset_10x", "numpy.concatenate", "scvi.data._built_in_data._dataset_10x._load_dataset_10x.concatenate", "dict", "pbmc_metadata[].index.values.ravel().astype", "adata[].copy", "numpy.asarray", "list", "list", "adata[].copy", "adata[].copy.obs[].astype", "numpy.squeeze", "len", "scvi.data._download._download", "os.path.join", "os.path.join", "zip", "set().difference", "list.remove", "numpy.asarray", "numpy.arange", "pbmc_metadata[].index.values.ravel", "set", "numpy.sum", "len", "barcode.endswith", "set", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._load_dataset_10x", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._load_dataset_10x", "home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["", "def", "_load_pbmc_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "remove_extracted_data", ":", "bool", "=", "True", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "urls", "=", "[", "\n", "\"https://github.com/YosefLab/scVI-data/raw/master/gene_info.csv\"", ",", "\n", "\"https://github.com/YosefLab/scVI-data/raw/master/pbmc_metadata.pickle\"", ",", "\n", "]", "\n", "save_fns", "=", "[", "\"gene_info_pbmc.csv\"", ",", "\"pbmc_metadata.pickle\"", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "urls", ")", ")", ":", "\n", "        ", "_download", "(", "urls", "[", "i", "]", ",", "save_path", ",", "save_fns", "[", "i", "]", ")", "\n", "\n", "", "de_metadata", "=", "pd", ".", "read_csv", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"gene_info_pbmc.csv\"", ")", ",", "sep", "=", "\",\"", ")", "\n", "pbmc_metadata", "=", "pd", ".", "read_pickle", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"pbmc_metadata.pickle\"", ")", ")", "\n", "pbmc8k", "=", "_load_dataset_10x", "(", "\n", "\"pbmc8k\"", ",", "\n", "save_path", "=", "save_path", ",", "\n", "var_names", "=", "\"gene_ids\"", ",", "\n", "remove_extracted_data", "=", "remove_extracted_data", ",", "\n", ")", "\n", "pbmc4k", "=", "_load_dataset_10x", "(", "\n", "\"pbmc4k\"", ",", "\n", "save_path", "=", "save_path", ",", "\n", "var_names", "=", "\"gene_ids\"", ",", "\n", "remove_extracted_data", "=", "remove_extracted_data", ",", "\n", ")", "\n", "barcodes", "=", "np", ".", "concatenate", "(", "(", "pbmc8k", ".", "obs_names", ",", "pbmc4k", ".", "obs_names", ")", ")", "\n", "\n", "adata", "=", "pbmc8k", ".", "concatenate", "(", "pbmc4k", ")", "\n", "adata", ".", "obs_names", "=", "barcodes", "\n", "\n", "dict_barcodes", "=", "dict", "(", "zip", "(", "barcodes", ",", "np", ".", "arange", "(", "len", "(", "barcodes", ")", ")", ")", ")", "\n", "subset_cells", "=", "[", "]", "\n", "barcodes_metadata", "=", "pbmc_metadata", "[", "\"barcodes\"", "]", ".", "index", ".", "values", ".", "ravel", "(", ")", ".", "astype", "(", "np", ".", "str", ")", "\n", "for", "barcode", "in", "barcodes_metadata", ":", "\n", "        ", "if", "(", "\n", "barcode", "in", "dict_barcodes", "\n", ")", ":", "# barcodes with end -11 filtered on 10X website (49 cells)", "\n", "            ", "subset_cells", "+=", "[", "dict_barcodes", "[", "barcode", "]", "]", "\n", "", "", "adata", "=", "adata", "[", "np", ".", "asarray", "(", "subset_cells", ")", ",", ":", "]", ".", "copy", "(", ")", "\n", "idx_metadata", "=", "np", ".", "asarray", "(", "\n", "[", "not", "barcode", ".", "endswith", "(", "\"11\"", ")", "for", "barcode", "in", "barcodes_metadata", "]", ",", "dtype", "=", "np", ".", "bool", "\n", ")", "\n", "genes_to_keep", "=", "list", "(", "\n", "de_metadata", "[", "\"ENSG\"", "]", ".", "values", "\n", ")", "# only keep the genes for which we have de data", "\n", "difference", "=", "list", "(", "\n", "set", "(", "genes_to_keep", ")", ".", "difference", "(", "set", "(", "adata", ".", "var_names", ")", ")", "\n", ")", "# Non empty only for unit tests", "\n", "for", "gene", "in", "difference", ":", "\n", "        ", "genes_to_keep", ".", "remove", "(", "gene", ")", "\n", "\n", "", "adata", "=", "adata", "[", ":", ",", "genes_to_keep", "]", ".", "copy", "(", ")", "\n", "design", "=", "pbmc_metadata", "[", "\"design\"", "]", "[", "idx_metadata", "]", "\n", "raw_qc", "=", "pbmc_metadata", "[", "\"raw_qc\"", "]", "[", "idx_metadata", "]", "\n", "normalized_qc", "=", "pbmc_metadata", "[", "\"normalized_qc\"", "]", "[", "idx_metadata", "]", "\n", "\n", "design", ".", "index", "=", "adata", ".", "obs_names", "\n", "raw_qc", ".", "index", "=", "adata", ".", "obs_names", "\n", "normalized_qc", ".", "index", "=", "adata", ".", "obs_names", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "adata", ".", "obs", "[", "\"batch\"", "]", ".", "astype", "(", "np", ".", "int64", ")", "\n", "adata", ".", "obsm", "[", "\"design\"", "]", "=", "design", "\n", "adata", ".", "obsm", "[", "\"raw_qc\"", "]", "=", "raw_qc", "\n", "adata", ".", "obsm", "[", "\"normalized_qc\"", "]", "=", "normalized_qc", "\n", "\n", "adata", ".", "obsm", "[", "\"qc_pc\"", "]", "=", "pbmc_metadata", "[", "\"qc_pc\"", "]", "[", "idx_metadata", "]", "\n", "labels", "=", "pbmc_metadata", "[", "\"clusters\"", "]", "[", "idx_metadata", "]", "\n", "cell_types", "=", "pbmc_metadata", "[", "\"list_clusters\"", "]", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "labels", "\n", "adata", ".", "uns", "[", "\"cell_types\"", "]", "=", "cell_types", "\n", "adata", ".", "obs", "[", "\"str_labels\"", "]", "=", "[", "cell_types", "[", "i", "]", "for", "i", "in", "labels", "]", "\n", "\n", "adata", ".", "var", "[", "\"n_counts\"", "]", "=", "np", ".", "squeeze", "(", "np", ".", "asarray", "(", "np", ".", "sum", "(", "adata", ".", "X", ",", "axis", "=", "0", ")", ")", ")", "\n", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._heartcellatlas._load_heart_cell_atlas_subsampled": [[8, 49], ["scvi.data._download._download", "anndata.read_h5ad", "os.path.join", "dataset[].copy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["def", "_load_heart_cell_atlas_subsampled", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "remove_nuisance_clusters", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Combined single cell and single nuclei RNA-Seq data of 485K cardiac cells with annotations.\n\n    Dataset was filtered down randomly to 20k cells using :func:`~scanpy.pp.subsample`. The original\n    data can be sourced from https://www.heartcellatlas.org/#DataSources.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    remove_nuisance_clusters\n        Remove doublets and unsassigned cells\n\n    Returns\n    -------\n    AnnData\n\n    Notes\n    -----\n    The data were filtered using the following sequence::\n\n        >>> adata = anndata.read_h5ad(path_to_anndata)\n        >>> bdata = sc.pp.subsample(adata, n_obs=20000, copy=True)\n        >>> sc.pp.filter_genes(bdata, min_counts=3)\n        >>> bdata.write_h5ad(path, compression=\"gzip\")\n    \"\"\"", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/blob/master/hca_subsampled_20k.h5ad?raw=true\"", "\n", "save_fn", "=", "\"hca_subsampled_20k.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "dataset", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "if", "remove_nuisance_clusters", ":", "\n", "        ", "remove", "=", "[", "\"doublets\"", ",", "\"NotAssigned\"", "]", "\n", "keep", "=", "[", "c", "not", "in", "remove", "for", "c", "in", "dataset", ".", "obs", ".", "cell_type", ".", "values", "]", "\n", "dataset", "=", "dataset", "[", "keep", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "", "return", "dataset", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._synthetic._generate_synthetic": [[10, 38], ["numpy.random.negative_binomial", "numpy.random.binomial", "numpy.random.randint", "numpy.array", "range", "anndata.AnnData", "pandas.Categorical", "pandas.Categorical", "numpy.random.negative_binomial", "numpy.arange().astype", "numpy.arange"], "function", ["None"], ["def", "_generate_synthetic", "(", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "n_genes", ":", "int", "=", "100", ",", "\n", "n_proteins", ":", "int", "=", "100", ",", "\n", "n_batches", ":", "int", "=", "2", ",", "\n", "n_labels", ":", "int", "=", "3", ",", "\n", ")", "->", "AnnData", ":", "\n", "\n", "    ", "data", "=", "np", ".", "random", ".", "negative_binomial", "(", "5", ",", "0.3", ",", "size", "=", "(", "batch_size", "*", "n_batches", ",", "n_genes", ")", ")", "\n", "mask", "=", "np", ".", "random", ".", "binomial", "(", "n", "=", "1", ",", "p", "=", "0.7", ",", "size", "=", "(", "batch_size", "*", "n_batches", ",", "n_genes", ")", ")", "\n", "data", "=", "data", "*", "mask", "# We put the batch index first", "\n", "labels", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "n_labels", ",", "size", "=", "(", "batch_size", "*", "n_batches", ",", ")", ")", "\n", "labels", "=", "np", ".", "array", "(", "[", "\"label_%d\"", "%", "i", "for", "i", "in", "labels", "]", ")", "\n", "\n", "batch", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_batches", ")", ":", "\n", "        ", "batch", "+=", "[", "\"batch_{}\"", ".", "format", "(", "i", ")", "]", "*", "batch_size", "\n", "\n", "", "adata", "=", "AnnData", "(", "data", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "pd", ".", "Categorical", "(", "batch", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "pd", ".", "Categorical", "(", "labels", ")", "\n", "\n", "# Protein measurements", "\n", "p_data", "=", "np", ".", "random", ".", "negative_binomial", "(", "5", ",", "0.3", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", "n_proteins", ")", ")", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "p_data", "\n", "adata", ".", "uns", "[", "\"protein_names\"", "]", "=", "np", ".", "arange", "(", "n_proteins", ")", ".", "astype", "(", "str", ")", "\n", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._load_dataset_10x": [[79, 142], ["scvi.data._download._download", "os.path.join", "scanpy.read_10x_h5.var_names_make_unique", "scanpy.pp.filter_cells", "scanpy.pp.filter_genes", "url_skeleton.format", "filename_skeleton.format", "os.path.join", "_dataset_10x._find_path_to_mtx", "scanpy.read_10x_mtx", "scanpy.read_10x_h5", "ImportError", "warnings.warn", "warnings.warn", "logger.info", "os.path.exists", "tarfile.is_tarfile", "path_to_data_folder[].split", "logger.info", "shutil.rmtree", "logger.info", "logger.info", "logger.info", "tarfile.open", "tarfile.open.extractall", "tarfile.open.close", "len"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._find_path_to_mtx"], ["def", "_load_dataset_10x", "(", "\n", "dataset_name", ":", "str", "=", "None", ",", "\n", "filename", ":", "str", "=", "None", ",", "\n", "save_path", ":", "str", "=", "\"data/10X\"", ",", "\n", "url", ":", "str", "=", "None", ",", "\n", "return_filtered", ":", "bool", "=", "True", ",", "\n", "remove_extracted_data", ":", "bool", "=", "False", ",", "\n", "**", "scanpy_read_10x_kwargs", ",", "\n", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "scanpy", "\n", "", "except", "ImportError", ":", "\n", "        ", "raise", "ImportError", "(", "\"Please install scanpy -- `pip install scanpy`\"", ")", "\n", "\n", "# form data url and filename unless manual override", "\n", "", "if", "dataset_name", "is", "not", "None", ":", "\n", "        ", "if", "url", "is", "not", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"dataset_name provided, manual url is disregarded.\"", ")", "\n", "", "if", "filename", "is", "not", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "\"dataset_name provided, manual filename is disregarded.\"", ")", "\n", "", "group", "=", "dataset_to_group", "[", "dataset_name", "]", "\n", "url_skeleton", "=", "group_to_url_skeleton", "[", "group", "]", "\n", "\n", "filter_type", "=", "\"filtered\"", "if", "return_filtered", "else", "\"raw\"", "\n", "url", "=", "url_skeleton", ".", "format", "(", "group", ",", "dataset_name", ",", "dataset_name", ",", "filter_type", ")", "\n", "filename_skeleton", "=", "group_to_filename_skeleton", "[", "group", "]", "\n", "filename", "=", "filename_skeleton", ".", "format", "(", "filter_type", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "dataset_name", ")", "\n", "", "elif", "filename", "is", "not", "None", "and", "url", "is", "not", "None", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading 10X dataset with custom url and filename\"", ")", "\n", "", "elif", "filename", "is", "not", "None", "and", "url", "is", "None", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading local 10X dataset with custom filename\"", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading extracted local 10X dataset with custom filename\"", ")", "\n", "", "_download", "(", "url", ",", "save_path", "=", "save_path", ",", "filename", "=", "filename", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "filename", ")", "\n", "\n", "# untar", "\n", "download_is_targz", "=", "url", "[", "-", "7", ":", "]", "==", "\".tar.gz\"", "\n", "was_extracted", "=", "False", "\n", "if", "download_is_targz", "is", "True", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "file_path", "[", ":", "-", "7", "]", ")", ":", "# nothing extracted yet", "\n", "            ", "if", "tarfile", ".", "is_tarfile", "(", "file_path", ")", ":", "\n", "                ", "logger", ".", "info", "(", "\"Extracting tar file\"", ")", "\n", "tar", "=", "tarfile", ".", "open", "(", "file_path", ",", "\"r:gz\"", ")", "\n", "tar", ".", "extractall", "(", "path", "=", "save_path", ")", "\n", "was_extracted", "=", "True", "\n", "tar", ".", "close", "(", ")", "\n", "", "", "path_to_data_folder", ",", "suffix", "=", "_find_path_to_mtx", "(", "save_path", ")", "\n", "adata", "=", "scanpy", ".", "read_10x_mtx", "(", "path_to_data_folder", ",", "**", "scanpy_read_10x_kwargs", ")", "\n", "if", "was_extracted", "and", "remove_extracted_data", ":", "\n", "            ", "folders_in_save_path", "=", "path_to_data_folder", "[", "len", "(", "save_path", ")", "+", "1", ":", "]", ".", "split", "(", "\"/\"", ")", "\n", "extracted_folder_path", "=", "save_path", "+", "\"/\"", "+", "folders_in_save_path", "[", "0", "]", "\n", "logger", ".", "info", "(", "\"Removing extracted data at {}\"", ".", "format", "(", "extracted_folder_path", ")", ")", "\n", "shutil", ".", "rmtree", "(", "extracted_folder_path", ")", "\n", "", "", "else", ":", "\n", "        ", "adata", "=", "scanpy", ".", "read_10x_h5", "(", "file_path", ",", "**", "scanpy_read_10x_kwargs", ")", "\n", "\n", "", "adata", ".", "var_names_make_unique", "(", ")", "\n", "scanpy", ".", "pp", ".", "filter_cells", "(", "adata", ",", "min_counts", "=", "1", ")", "\n", "scanpy", ".", "pp", ".", "filter_genes", "(", "adata", ",", "min_counts", "=", "1", ")", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._dataset_10x._find_path_to_mtx": [[144, 169], ["os.walk", "FileNotFoundError", "numpy.asarray().any", "numpy.asarray"], "function", ["None"], ["", "def", "_find_path_to_mtx", "(", "save_path", ":", "str", ")", "->", "Tuple", "[", "str", ",", "str", "]", ":", "\n", "    ", "\"\"\"\n    Returns exact path for the data in the archive.\n\n    This is required because 10X doesn't have a consistent way of storing their data.\n    Additionally, the function returns whether the data is stored in compressed format.\n\n    Returns\n    -------\n    path in which files are contains and their suffix if compressed.\n\n    \"\"\"", "\n", "for", "root", ",", "subdirs", ",", "files", "in", "os", ".", "walk", "(", "save_path", ")", ":", "\n", "# do not consider hidden files", "\n", "        ", "files", "=", "[", "f", "for", "f", "in", "files", "if", "not", "f", "[", "0", "]", "==", "\".\"", "]", "\n", "contains_mat", "=", "[", "\n", "filename", "==", "\"matrix.mtx\"", "or", "filename", "==", "\"matrix.mtx.gz\"", "\n", "for", "filename", "in", "files", "\n", "]", "\n", "contains_mat", "=", "np", ".", "asarray", "(", "contains_mat", ")", ".", "any", "(", ")", "\n", "if", "contains_mat", ":", "\n", "            ", "is_tar", "=", "files", "[", "0", "]", "[", "-", "3", ":", "]", "==", "\".gz\"", "\n", "suffix", "=", "\".gz\"", "if", "is_tar", "else", "\"\"", "\n", "return", "root", ",", "suffix", "\n", "", "", "raise", "FileNotFoundError", "(", "\"No matrix.mtx(.gz) found in path (%s).\"", "%", "save_path", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._brain_large._load_brainlarge_dataset": [[14, 34], ["scvi.data._download._download", "_brain_large._load_brainlarge_file", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._brain_large._load_brainlarge_file"], ["def", "_load_brainlarge_dataset", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "sample_size_gene_var", ":", "int", "=", "10000", ",", "\n", "max_cells_to_keep", ":", "int", "=", "None", ",", "\n", "n_genes_to_keep", ":", "int", "=", "720", ",", "\n", "loading_batch_size", ":", "int", "=", "100000", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"Loads brain-large dataset.\"\"\"", "\n", "url", "=", "\"http://cf.10xgenomics.com/samples/cell-exp/1.3.0/1M_neurons/1M_neurons_filtered_gene_bc_matrices_h5.h5\"", "\n", "save_fn", "=", "\"brain_large.h5\"", "\n", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_brainlarge_file", "(", "\n", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ",", "\n", "sample_size_gene_var", "=", "sample_size_gene_var", ",", "\n", "max_cells_to_keep", "=", "max_cells_to_keep", ",", "\n", "n_genes_to_keep", "=", "n_genes_to_keep", ",", "\n", "loading_batch_size", "=", "loading_batch_size", ",", "\n", ")", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._brain_large._load_brainlarge_file": [[36, 121], ["logger.info", "print", "logger.info", "logger.info", "anndata.AnnData", "numpy.zeros", "numpy.zeros", "anndata.AnnData.X.sum", "scipy.issparse", "scipy.issparse", "anndata.AnnData.copy", "h5py.File", "scipy.csc_matrix", "sp_sparse.csc_matrix.mean", "range", "sp_sparse.csc_matrix.multiply().mean", "numpy.multiply", "int", "[].astype", "[].astype", "logger.info", "[].astype", "numpy.squeeze().argsort", "len", "scipy.csr_matrix", "scipy.vstack", "sp_sparse.csc_matrix.multiply", "len", "numpy.squeeze", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "_load_brainlarge_file", "(", "\n", "path_to_file", ":", "str", ",", "\n", "sample_size_gene_var", ":", "int", ",", "\n", "max_cells_to_keep", ":", "int", ",", "\n", "n_genes_to_keep", ":", "int", ",", "\n", "loading_batch_size", ":", "int", ",", "\n", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "logger", ".", "info", "(", "\"Preprocessing Brain Large data\"", ")", "\n", "print", "(", "path_to_file", ")", "\n", "with", "h5py", ".", "File", "(", "path_to_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "f", "[", "\"mm10\"", "]", "\n", "nb_genes", ",", "nb_cells", "=", "f", "[", "\"mm10\"", "]", "[", "\"shape\"", "]", "\n", "n_cells_to_keep", "=", "(", "\n", "max_cells_to_keep", "if", "max_cells_to_keep", "is", "not", "None", "else", "nb_cells", "\n", ")", "\n", "index_partitioner", "=", "data", "[", "\"indptr\"", "]", "[", "...", "]", "\n", "# estimate gene variance using a subset of cells.", "\n", "index_partitioner_gene_var", "=", "index_partitioner", "[", ":", "(", "sample_size_gene_var", "+", "1", ")", "]", "\n", "last_index_gene_var_sample", "=", "index_partitioner_gene_var", "[", "-", "1", "]", "\n", "gene_var_sample_matrix", "=", "sp_sparse", ".", "csc_matrix", "(", "\n", "(", "\n", "data", "[", "\"data\"", "]", "[", ":", "last_index_gene_var_sample", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "\n", "data", "[", "\"indices\"", "]", "[", ":", "last_index_gene_var_sample", "]", ",", "\n", "index_partitioner_gene_var", ",", "\n", ")", ",", "\n", "shape", "=", "(", "nb_genes", ",", "len", "(", "index_partitioner_gene_var", ")", "-", "1", ")", ",", "\n", ")", "\n", "mean", "=", "gene_var_sample_matrix", ".", "mean", "(", "axis", "=", "1", ")", "\n", "var", "=", "gene_var_sample_matrix", ".", "multiply", "(", "gene_var_sample_matrix", ")", ".", "mean", "(", "\n", "axis", "=", "1", "\n", ")", "-", "np", ".", "multiply", "(", "mean", ",", "mean", ")", "\n", "subset_genes", "=", "np", ".", "squeeze", "(", "np", ".", "asarray", "(", "var", ")", ")", ".", "argsort", "(", ")", "[", "-", "n_genes_to_keep", ":", "]", "[", ":", ":", "-", "1", "]", "\n", "del", "gene_var_sample_matrix", ",", "mean", ",", "var", "\n", "\n", "n_iters", "=", "int", "(", "n_cells_to_keep", "/", "loading_batch_size", ")", "+", "(", "\n", "n_cells_to_keep", "%", "loading_batch_size", ">", "0", "\n", ")", "\n", "for", "i", "in", "range", "(", "n_iters", ")", ":", "\n", "            ", "index_partitioner_batch", "=", "index_partitioner", "[", "\n", "(", "i", "*", "loading_batch_size", ")", ":", "(", "(", "1", "+", "i", ")", "*", "loading_batch_size", "+", "1", ")", "\n", "]", "\n", "first_index_batch", "=", "index_partitioner_batch", "[", "0", "]", "\n", "last_index_batch", "=", "index_partitioner_batch", "[", "-", "1", "]", "\n", "index_partitioner_batch", "=", "(", "\n", "index_partitioner_batch", "-", "first_index_batch", "\n", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "n_cells_batch", "=", "len", "(", "index_partitioner_batch", ")", "-", "1", "\n", "data_batch", "=", "data", "[", "\"data\"", "]", "[", "first_index_batch", ":", "last_index_batch", "]", ".", "astype", "(", "\n", "np", ".", "float32", "\n", ")", "\n", "indices_batch", "=", "data", "[", "\"indices\"", "]", "[", "first_index_batch", ":", "last_index_batch", "]", ".", "astype", "(", "\n", "np", ".", "int32", "\n", ")", "\n", "matrix_batch", "=", "sp_sparse", ".", "csr_matrix", "(", "\n", "(", "data_batch", ",", "indices_batch", ",", "index_partitioner_batch", ")", ",", "\n", "shape", "=", "(", "n_cells_batch", ",", "nb_genes", ")", ",", "\n", ")", "[", ":", ",", "subset_genes", "]", "\n", "# stack on the fly to limit RAM usage", "\n", "if", "i", "==", "0", ":", "\n", "                ", "matrix", "=", "matrix_batch", "\n", "", "else", ":", "\n", "                ", "matrix", "=", "sp_sparse", ".", "vstack", "(", "[", "matrix", ",", "matrix_batch", "]", ")", "\n", "", "logger", ".", "info", "(", "\n", "\"loaded {} / {} cells\"", ".", "format", "(", "\n", "i", "*", "loading_batch_size", "+", "n_cells_batch", ",", "n_cells_to_keep", "\n", ")", "\n", ")", "\n", "", "", "logger", ".", "info", "(", "\"%d cells subsampled\"", "%", "matrix", ".", "shape", "[", "0", "]", ")", "\n", "logger", ".", "info", "(", "\"%d genes subsampled\"", "%", "matrix", ".", "shape", "[", "1", "]", ")", "\n", "adata", "=", "anndata", ".", "AnnData", "(", "matrix", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", "[", "0", "]", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "np", ".", "zeros", "(", "matrix", ".", "shape", "[", "0", "]", ")", "\n", "\n", "counts", "=", "adata", ".", "X", ".", "sum", "(", "1", ")", "\n", "if", "sp_sparse", ".", "issparse", "(", "counts", ")", ":", "\n", "        ", "counts", "=", "counts", ".", "A1", "\n", "\n", "", "gene_num", "=", "(", "adata", ".", "X", ">", "0", ")", ".", "sum", "(", "1", ")", "\n", "if", "sp_sparse", ".", "issparse", "(", "gene_num", ")", ":", "\n", "        ", "gene_num", "=", "gene_num", ".", "A1", "\n", "\n", "", "adata", "=", "adata", "[", "counts", ">", "1", "]", "\n", "adata", "=", "adata", "[", "gene_num", ">", "1", "]", "\n", "\n", "return", "adata", ".", "copy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_retina": [[14, 53], ["os.path.abspath", "scvi.data._download._download", "_loom._load_loom", "pandas.Categorical", "os.path.join", "_load_loom.obs[].values.copy", "_load_loom.obs[].values.astype().ravel", "_load_loom.obs[].values.astype"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_loom"], ["def", "_load_retina", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "AnnData", ":", "\n", "    ", "\"\"\"\\\n    Loads retina dataset\n\n    The dataset of bipolar cells contains after their original pipeline for filtering 27,499 cells and\n    13,166 genes coming from two batches. We use the cluster annotation from 15 cell-types from the author.\n    We also extract their normalized data with Combat and use it for benchmarking.\n\n    \"\"\"", "\n", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/retina.loom\"", "\n", "save_fn", "=", "\"retina.loom\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_loom", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "cell_types", "=", "[", "\n", "\"RBC\"", ",", "\n", "\"MG\"", ",", "\n", "\"BC5A\"", ",", "\n", "\"BC7\"", ",", "\n", "\"BC6\"", ",", "\n", "\"BC5C\"", ",", "\n", "\"BC1A\"", ",", "\n", "\"BC3B\"", ",", "\n", "\"BC1B\"", ",", "\n", "\"BC2\"", ",", "\n", "\"BC5D\"", ",", "\n", "\"BC3A\"", ",", "\n", "\"BC5B\"", ",", "\n", "\"BC4\"", ",", "\n", "\"BC8_9\"", ",", "\n", "]", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "[", "\n", "cell_types", "[", "i", "]", "for", "i", "in", "adata", ".", "obs", "[", "\"ClusterID\"", "]", ".", "values", ".", "astype", "(", "int", ")", ".", "ravel", "(", ")", "\n", "]", "\n", "del", "adata", ".", "obs", "[", "\"ClusterID\"", "]", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "pd", ".", "Categorical", "(", "adata", ".", "obs", "[", "\"BatchID\"", "]", ".", "values", ".", "copy", "(", ")", ")", "\n", "del", "adata", ".", "obs", "[", "\"BatchID\"", "]", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_prefrontalcortex_starmap": [[55, 74], ["os.path.abspath", "scvi.data._download._download", "_loom._load_loom", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_loom"], ["", "def", "_load_prefrontalcortex_starmap", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "AnnData", ":", "\n", "    ", "\"\"\"\\\n    Loads a starMAP dataset of 3,704 cells and 166 genes from the mouse pre-frontal cortex (Wang et al., 2018)\n    \"\"\"", "\n", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/mpfc-starmap.loom\"", "\n", "save_fn", "=", "\"mpfc-starmap.loom\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_loom", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "adata", ".", "obs", ".", "Clusters", ".", "values", "\n", "del", "adata", ".", "obs", "[", "\"Clusters\"", "]", "\n", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "adata", ".", "obs", ".", "BatchID", ".", "values", "\n", "del", "adata", ".", "obs", "[", "\"BatchID\"", "]", "\n", "adata", ".", "obs", "[", "\"x_coord\"", "]", "=", "adata", ".", "obsm", "[", "\"Spatial_coordinates\"", "]", "[", ":", ",", "0", "]", "\n", "adata", ".", "obs", "[", "\"y_coord\"", "]", "=", "adata", ".", "obsm", "[", "\"Spatial_coordinates\"", "]", "[", ":", ",", "1", "]", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_frontalcortex_dropseq": [[76, 91], ["os.path.abspath", "scvi.data._download._download", "_loom._load_loom", "numpy.zeros", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_loom"], ["", "def", "_load_frontalcortex_dropseq", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "AnnData", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/fc-dropseq.loom\"", "\n", "save_fn", "=", "\"fc-dropseq.loom\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_loom", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "adata", ".", "obs", "[", "\"Clusters\"", "]", "\n", "del", "adata", ".", "obs", "[", "\"Clusters\"", "]", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# reorder labels such that layers of the cortex are in order", "\n", "# order_labels = [5, 6, 3, 2, 4, 0, 1, 8, 7, 9, 10, 11, 12, 13]", "\n", "# self.reorder_cell_types(self.cell_types[order_labels])", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_annotation_simulation": [[93, 116], ["os.path.abspath", "scvi.data._download._download", "_loom._load_loom", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_loom"], ["", "def", "_load_annotation_simulation", "(", "name", ":", "str", ",", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "AnnData", ":", "\n", "    ", "\"\"\"\\\n    Simulated datasets for scANVI tutorials\n\n    name\n        One of \"1\", \"2\", or \"3\"\n    \"\"\"", "\n", "\n", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/simulation/simulation_{}.loom\"", ".", "format", "(", "\n", "name", "\n", ")", "\n", "save_fn", "=", "\"simulation_{}.loom\"", ".", "format", "(", "name", ")", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_loom", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "adata", ".", "obs", ".", "ClusterID", ".", "values", "\n", "del", "adata", ".", "obs", "[", "\"ClusterID\"", "]", "\n", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "=", "adata", ".", "obs", ".", "BatchID", ".", "values", "\n", "del", "adata", ".", "obs", "[", "\"BatchID\"", "]", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._loom._load_loom": [[118, 158], ["loompy.connect", "loompy.connect.close", "anndata.AnnData", "adata[].copy", "dataset[].sum", "all", "warnings.warn", "loompy.connect.ra[].astype", "type", "type", "uns_dict[].ravel", "type", "var_dict[].ravel", "len", "len", "obs_dict[].ravel", "obs_dict[].ravel"], "function", ["None"], ["", "def", "_load_loom", "(", "path_to_file", ":", "str", ",", "gene_names_attribute_name", ":", "str", "=", "\"Gene\"", ")", "->", "AnnData", ":", "\n", "    ", "import", "loompy", "\n", "\n", "dataset", "=", "loompy", ".", "connect", "(", "path_to_file", ")", "\n", "select", "=", "dataset", "[", ":", ",", ":", "]", ".", "sum", "(", "axis", "=", "0", ")", ">", "0", "# Take out cells that don't express any gene", "\n", "if", "not", "all", "(", "select", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Removing empty cells\"", ")", "\n", "\n", "", "var_dict", ",", "obs_dict", ",", "uns_dict", ",", "obsm_dict", "=", "{", "}", ",", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "for", "row_key", "in", "dataset", ".", "ra", ":", "\n", "        ", "if", "row_key", "==", "gene_names_attribute_name", ":", "\n", "            ", "gene_names", "=", "dataset", ".", "ra", "[", "gene_names_attribute_name", "]", ".", "astype", "(", "str", ")", "\n", "", "else", ":", "\n", "            ", "var_dict", "[", "row_key", "]", "=", "dataset", ".", "ra", "[", "row_key", "]", "\n", "if", "type", "(", "var_dict", "[", "row_key", "]", ")", "is", "np", ".", "ndarray", ":", "\n", "                ", "var_dict", "[", "row_key", "]", "=", "var_dict", "[", "row_key", "]", ".", "ravel", "(", ")", "\n", "\n", "", "", "", "for", "column_key", "in", "dataset", ".", "ca", ":", "\n", "        ", "obs_dict", "=", "obs_dict", "if", "obs_dict", "is", "not", "None", "else", "{", "}", "\n", "obs_dict", "[", "column_key", "]", "=", "dataset", ".", "ca", "[", "column_key", "]", "[", "select", "]", "\n", "if", "type", "(", "obs_dict", "[", "column_key", "]", ")", "is", "np", ".", "ndarray", ":", "\n", "            ", "if", "len", "(", "obs_dict", "[", "column_key", "]", ")", "==", "len", "(", "obs_dict", "[", "column_key", "]", ".", "ravel", "(", ")", ")", ":", "\n", "                ", "obs_dict", "[", "column_key", "]", "=", "obs_dict", "[", "column_key", "]", ".", "ravel", "(", ")", "\n", "", "else", ":", "\n", "                ", "obsm_dict", "[", "column_key", "]", "=", "obs_dict", "[", "column_key", "]", "\n", "del", "obs_dict", "[", "column_key", "]", "\n", "\n", "", "", "", "for", "global_key", "in", "dataset", ".", "attrs", ":", "\n", "        ", "uns_dict", "=", "uns_dict", "if", "uns_dict", "is", "not", "None", "else", "{", "}", "\n", "uns_dict", "[", "global_key", "]", "=", "dataset", ".", "attrs", "[", "global_key", "]", "\n", "if", "type", "(", "uns_dict", "[", "global_key", "]", ")", "is", "np", ".", "ndarray", ":", "\n", "            ", "uns_dict", "[", "global_key", "]", "=", "uns_dict", "[", "global_key", "]", ".", "ravel", "(", ")", "\n", "", "", "data", "=", "dataset", "[", ":", ",", ":", "]", ".", "T", "# change matrix to cells by genes", "\n", "dataset", ".", "close", "(", ")", "\n", "\n", "adata", "=", "AnnData", "(", "X", "=", "data", ",", "obs", "=", "obs_dict", ",", "var", "=", "var_dict", ",", "uns", "=", "uns_dict", ",", "obsm", "=", "obsm_dict", ")", "\n", "adata", "=", "adata", "[", "select", "]", ".", "copy", "(", ")", "\n", "adata", ".", "var_names", "=", "gene_names", "\n", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cortex._load_cortex": [[14, 23], ["os.path.abspath", "scvi.data._download._download", "_cortex._load_cortex_txt", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cortex._load_cortex_txt"], ["def", "_load_cortex", "(", "save_path", ":", "str", "=", "\"data/\"", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "\"\"\"Loads cortex dataset.\"\"\"", "\n", "save_path", "=", "os", ".", "path", ".", "abspath", "(", "save_path", ")", "\n", "url", "=", "\"https://storage.googleapis.com/linnarsson-lab-www-blobs/blobs/cortex/expression_mRNA_17-Aug-2014.txt\"", "\n", "save_fn", "=", "\"expression.bin\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "_load_cortex_txt", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "return", "adata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cortex._load_cortex_txt": [[25, 59], ["logger.info", "numpy.unique", "numpy.unique", "numpy.asarray", "numpy.concatenate().astype", "pandas.DataFrame", "anndata.AnnData", "logger.info", "open", "csv.reader", "enumerate", "slice", "numpy.asarray", "numpy.concatenate", "rows.append", "np.asarray.append", "numpy.asarray", "numpy.asarray"], "function", ["None"], ["", "def", "_load_cortex_txt", "(", "path_to_file", ":", "str", ")", "->", "anndata", ".", "AnnData", ":", "\n", "    ", "logger", ".", "info", "(", "\"Loading Cortex data from {}\"", ".", "format", "(", "path_to_file", ")", ")", "\n", "rows", "=", "[", "]", "\n", "gene_names", "=", "[", "]", "\n", "with", "open", "(", "path_to_file", ",", "\"r\"", ")", "as", "csvfile", ":", "\n", "        ", "data_reader", "=", "csv", ".", "reader", "(", "csvfile", ",", "delimiter", "=", "\"\\t\"", ")", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "data_reader", ")", ":", "\n", "            ", "if", "i", "==", "1", ":", "\n", "                ", "precise_clusters", "=", "np", ".", "asarray", "(", "row", ",", "dtype", "=", "str", ")", "[", "2", ":", "]", "\n", "", "if", "i", "==", "8", ":", "\n", "                ", "clusters", "=", "np", ".", "asarray", "(", "row", ",", "dtype", "=", "str", ")", "[", "2", ":", "]", "\n", "", "if", "i", ">=", "11", ":", "\n", "                ", "rows", ".", "append", "(", "row", "[", "1", ":", "]", ")", "\n", "gene_names", ".", "append", "(", "row", "[", "0", "]", ")", "\n", "", "", "", "cell_types", ",", "labels", "=", "np", ".", "unique", "(", "clusters", ",", "return_inverse", "=", "True", ")", "\n", "_", ",", "precise_labels", "=", "np", ".", "unique", "(", "precise_clusters", ",", "return_inverse", "=", "True", ")", "\n", "data", "=", "np", ".", "asarray", "(", "rows", ",", "dtype", "=", "np", ".", "int", ")", ".", "T", "[", "1", ":", "]", "\n", "gene_names", "=", "np", ".", "asarray", "(", "gene_names", ",", "dtype", "=", "np", ".", "str", ")", "\n", "gene_indices", "=", "[", "]", "\n", "\n", "extra_gene_indices", "=", "[", "]", "\n", "gene_indices", "=", "np", ".", "concatenate", "(", "[", "gene_indices", ",", "extra_gene_indices", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "if", "gene_indices", ".", "size", "==", "0", ":", "\n", "        ", "gene_indices", "=", "slice", "(", "None", ")", "\n", "\n", "", "data", "=", "data", "[", ":", ",", "gene_indices", "]", "\n", "gene_names", "=", "gene_names", "[", "gene_indices", "]", "\n", "data_df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "gene_names", ")", "\n", "adata", "=", "anndata", ".", "AnnData", "(", "X", "=", "data_df", ")", "\n", "adata", ".", "obs", "[", "\"labels\"", "]", "=", "labels", "\n", "adata", ".", "obs", "[", "\"precise_labels\"", "]", "=", "precise_clusters", "\n", "adata", ".", "obs", "[", "\"cell_type\"", "]", "=", "clusters", "\n", "logger", ".", "info", "(", "\"Finished loading Cortex data\"", ")", "\n", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_pbmcs_10x_cite_seq": [[11, 66], ["scvi.data._download._download", "anndata.read_h5ad", "scvi.data._download._download", "anndata.read_h5ad", "anndata.read_h5ad.var_names.intersection", "pandas.DataFrame", "pandas.DataFrame", "anndata.concat", "anndata.concat.obsm[].fillna", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["def", "_load_pbmcs_10x_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "protein_join", ":", "str", "=", "\"inner\"", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Filtered PBMCs from 10x Genomics profiled with RNA and protein.\n\n    Datasets were filtered for doublets and other outliers as in\n    https://github.com/YosefLab/totalVI_reproducibility/blob/master/data/data_filtering_scripts/pbmc_10k/pbmc_10k.py\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    protein_join\n        Whether to take an inner join or outer join of proteins\n\n    Returns\n    -------\n    `AnnData` with `.obsm[\"protein_expression\"]\n\n    Missing protein values are zero, and are identified during `AnnData` setup.\n    \"\"\"", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/pbmc_10k_protein_v3.h5ad?raw=true\"", "\n", "save_fn", "=", "\"pbmc_10k_protein_v3.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "dataset1", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "dataset1", ".", "obs", "[", "\"batch\"", "]", "=", "\"PBMC10k\"", "\n", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/pbmc_5k_protein_v3.h5ad?raw=true\"", "\n", "save_fn", "=", "\"pbmc_5k_protein_v3.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "dataset2", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"pbmc_5k_protein_v3.h5ad\"", ")", ")", "\n", "dataset2", ".", "obs", "[", "\"batch\"", "]", "=", "\"PBMC5k\"", "\n", "\n", "common_genes", "=", "dataset1", ".", "var_names", ".", "intersection", "(", "dataset2", ".", "var_names", ")", "\n", "dataset1", "=", "dataset1", "[", ":", ",", "common_genes", "]", "\n", "dataset2", "=", "dataset2", "[", ":", ",", "common_genes", "]", "\n", "dataset1", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "pd", ".", "DataFrame", "(", "\n", "dataset1", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", "columns", "=", "dataset1", ".", "uns", "[", "\"protein_names\"", "]", ",", "\n", "index", "=", "dataset1", ".", "obs_names", ",", "\n", ")", "\n", "dataset2", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "pd", ".", "DataFrame", "(", "\n", "dataset2", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", "columns", "=", "dataset2", ".", "uns", "[", "\"protein_names\"", "]", ",", "\n", "index", "=", "dataset2", ".", "obs_names", ",", "\n", ")", "\n", "del", "dataset1", ".", "uns", "[", "\"protein_names\"", "]", "\n", "del", "dataset2", ".", "uns", "[", "\"protein_names\"", "]", "\n", "\n", "dataset", "=", "anndata", ".", "concat", "(", "[", "dataset1", ",", "dataset2", "]", ",", "join", "=", "protein_join", ")", "\n", "dataset", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "dataset", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "fillna", "(", "0", ")", "\n", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_spleen_lymph_cite_seq": [[68, 126], ["scvi.data._download._download", "anndata.read_h5ad", "anndata.read_h5ad.obsm[].copy", "scvi.data._download._download", "anndata.read_h5ad", "anndata.read_h5ad.var_names.intersection", "anndata.concat", "dataset[].copy.obsm[].fillna", "os.path.join", "os.path.join", "dataset[].copy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download", "home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["", "def", "_load_spleen_lymph_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "protein_join", ":", "str", "=", "\"inner\"", ",", "\n", "remove_outliers", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Immune cells from the murine spleen and lymph nodes [GayosoSteier21]_.\n\n    This dataset was used throughout the totalVI manuscript, and named SLN-all.\n\n    Parameters\n    ----------\n    save_path\n        Location to use when saving/loading the data.\n    protein_join\n        Whether to take an inner join or outer join of proteins\n    remove_outliers\n        Whether to remove clusters annotated as doublet or low quality\n\n    Returns\n    -------\n    `AnnData` with `.obsm[\"protein_expression\"]\n\n    Missing protein values are zero, and are identified during `AnnData` setup.\n    \"\"\"", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/sln_111.h5ad?raw=true\"", "\n", "save_fn", "=", "\"sln_111.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "dataset1", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "dataset1", ".", "obsm", "[", "\"isotypes_htos\"", "]", "=", "dataset1", ".", "obsm", "[", "\"htos\"", "]", ".", "copy", "(", ")", "\n", "del", "dataset1", ".", "obsm", "[", "\"htos\"", "]", "\n", "\n", "url", "=", "\"https://github.com/YosefLab/scVI-data/raw/master/sln_208.h5ad?raw=true\"", "\n", "save_fn", "=", "\"sln_208.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "dataset2", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "common_genes", "=", "dataset1", ".", "var_names", ".", "intersection", "(", "dataset2", ".", "var_names", ")", "\n", "dataset1", "=", "dataset1", "[", ":", ",", "common_genes", "]", "\n", "dataset2", "=", "dataset2", "[", ":", ",", "common_genes", "]", "\n", "\n", "del", "dataset1", ".", "uns", "[", "\"protein_names\"", "]", "\n", "del", "dataset2", ".", "uns", "[", "\"protein_names\"", "]", "\n", "\n", "dataset", "=", "anndata", ".", "concat", "(", "\n", "[", "dataset1", ",", "dataset2", "]", ",", "\n", "join", "=", "protein_join", ",", "\n", ")", "\n", "dataset", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "dataset", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "fillna", "(", "0", ")", "\n", "\n", "if", "remove_outliers", ":", "\n", "        ", "include_cells", "=", "[", "\n", "c", "not", "in", "[", "\"16,0\"", ",", "\"17\"", ",", "\"19\"", ",", "\"21\"", ",", "\"23\"", ",", "\"24,0\"", ",", "\"24,2\"", ",", "\"25\"", ",", "\"29\"", "]", "\n", "for", "c", "in", "dataset", ".", "obs", "[", "\"leiden_subclusters\"", "]", "\n", "]", "\n", "dataset", "=", "dataset", "[", "include_cells", "]", ".", "copy", "(", ")", "\n", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI._built_in_data._cite_seq._load_pbmc_seurat_v4_cite_seq": [[128, 200], ["scvi.data._download._download", "anndata.read_h5ad", "os.path.join", "pandas.DataFrame.from_dict", "numpy.ravel", "adata[].copy.var_names.str.startswith", "numpy.ravel", "numpy.log", "numpy.log", "adata[].copy", "ValueError", "numpy.random.RandomState", "adata[].copy.obsm[].sum", "np.random.RandomState.permutation", "numpy.asarray", "adata[].copy.X.sum", "adata[].copy.X[].sum", "adata[].copy.X.sum", "p.split", "numpy.asarray", "p.split", "p.split", "numpy.asarray", "adata[].copy.obs[].astype", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._download._download"], ["", "def", "_load_pbmc_seurat_v4_cite_seq", "(", "\n", "save_path", ":", "str", "=", "\"data/\"", ",", "\n", "apply_filters", ":", "bool", "=", "True", ",", "\n", "aggregate_proteins", ":", "bool", "=", "True", ",", "\n", "mask_protein_batches", ":", "int", "=", "0", ",", "\n", ")", ":", "\n", "    ", "url", "=", "\"https://ndownloader.figshare.com/files/27458840\"", "\n", "save_fn", "=", "\"pbmc_seurat_v4.h5ad\"", "\n", "_download", "(", "url", ",", "save_path", ",", "save_fn", ")", "\n", "adata", "=", "anndata", ".", "read_h5ad", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", ")", "\n", "\n", "if", "aggregate_proteins", ":", "\n", "        ", "protein_dict", "=", "{", "}", "\n", "ref_proteins", "=", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", ".", "columns", "\n", "for", "p", "in", "ref_proteins", ":", "\n", "            ", "if", "p", ".", "split", "(", "\"-\"", ")", "[", "-", "1", "]", "==", "\"1\"", "or", "p", ".", "split", "(", "\"-\"", ")", "[", "-", "1", "]", "==", "\"2\"", ":", "\n", "                ", "root", "=", "p", ".", "split", "(", "\"-\"", ")", "[", "0", "]", "\n", "if", "root", "not", "in", "[", "\"Notch\"", ",", "\"TCR\"", "]", ":", "\n", "                    ", "try", ":", "\n", "                        ", "protein_dict", "[", "root", "]", "=", "np", ".", "asarray", "(", "\n", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "root", "+", "\"-1\"", "]", "\n", "+", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "root", "+", "\"-2\"", "]", "\n", ")", "\n", "", "except", "KeyError", ":", "\n", "                        ", "protein_dict", "[", "p", "]", "=", "np", ".", "asarray", "(", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "p", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "protein_dict", "[", "p", "]", "=", "np", ".", "asarray", "(", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "p", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "protein_dict", "[", "p", "]", "=", "np", ".", "asarray", "(", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "p", "]", ")", "\n", "", "", "protein_df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "protein_dict", ")", "\n", "protein_df", ".", "index", "=", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", ".", "index", "\n", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "=", "protein_df", "\n", "\n", "", "if", "apply_filters", ":", "\n", "        ", "adata", ".", "obs", "[", "\"total_counts\"", "]", "=", "np", ".", "ravel", "(", "adata", ".", "X", ".", "sum", "(", "axis", "=", "1", ")", ".", "A", ")", "\n", "adata", ".", "var", "[", "\"mt\"", "]", "=", "adata", ".", "var_names", ".", "str", ".", "startswith", "(", "\"MT-\"", ")", "\n", "adata", ".", "obs", "[", "\"total_counts_mt\"", "]", "=", "np", ".", "ravel", "(", "\n", "adata", ".", "X", "[", ":", ",", "adata", ".", "var", "[", "\"mt\"", "]", ".", "values", "]", ".", "sum", "(", "axis", "=", "1", ")", ".", "A", "\n", ")", "\n", "adata", ".", "obs", "[", "\"pct_counts_mt\"", "]", "=", "(", "\n", "adata", ".", "obs", "[", "\"total_counts_mt\"", "]", "/", "adata", ".", "obs", "[", "\"total_counts\"", "]", "*", "100", "\n", ")", "\n", "\n", "adata", ".", "obs", "[", "\"Protein log library size\"", "]", "=", "np", ".", "log", "(", "\n", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", ".", "sum", "(", "1", ")", "\n", ")", "\n", "adata", ".", "obs", "[", "\"Number proteins detected\"", "]", "=", "(", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", ">", "0", ")", ".", "sum", "(", "\n", "1", "\n", ")", "\n", "adata", ".", "obs", "[", "\"RNA log library size\"", "]", "=", "np", ".", "log", "(", "adata", ".", "X", ".", "sum", "(", "1", ")", ".", "A", ")", "\n", "\n", "# actually filter", "\n", "adata", "=", "adata", "[", "adata", ".", "obs", "[", "\"Protein log library size\"", "]", ">", "7.6", "]", "\n", "adata", "=", "adata", "[", "adata", ".", "obs", "[", "\"Protein log library size\"", "]", "<", "10.3", "]", "\n", "adata", "=", "adata", "[", "adata", ".", "obs", "[", "\"Number proteins detected\"", "]", ">", "150", "]", "\n", "# filter doublet", "\n", "adata", "=", "adata", "[", "adata", ".", "obs", "[", "\"celltype.l2\"", "]", "!=", "\"Doublet\"", "]", "\n", "# MT", "\n", "adata", "=", "adata", "[", "adata", ".", "obs", "[", "\"pct_counts_mt\"", "]", "<", "12", "]", ".", "copy", "(", ")", "\n", "\n", "", "if", "mask_protein_batches", ">", "24", ":", "\n", "        ", "raise", "ValueError", "(", "\"mask_protein_batches must be less than 24\"", ")", "\n", "\n", "", "if", "mask_protein_batches", ">", "0", ":", "\n", "        ", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "settings", ".", "seed", ")", "\n", "rand_cats", "=", "random_state", ".", "permutation", "(", "\n", "adata", ".", "obs", "[", "\"orig.ident\"", "]", ".", "astype", "(", "\"category\"", ")", ".", "cat", ".", "categories", "\n", ")", "[", ":", "mask_protein_batches", "]", "\n", "for", "r", "in", "rand_cats", ":", "\n", "            ", "adata", ".", "obsm", "[", "\"protein_counts\"", "]", "[", "adata", ".", "obs", "[", "\"orig.ident\"", "]", "==", "r", "]", "=", "0.0", "\n", "\n", "", "", "return", "adata", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.BaseObsField.__init__": [[34, 45], ["_base_field.BaseAnnDataField.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "registry_key", ":", "str", ",", "obs_key", ":", "Optional", "[", "str", "]", ",", "required", ":", "bool", "=", "True", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "required", "and", "obs_key", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`obs_key` cannot be `None` if `required=True`. Please provide an `obs_key`.\"", "\n", ")", "\n", "", "self", ".", "_registry_key", "=", "registry_key", "\n", "self", ".", "_attr_key", "=", "obs_key", "\n", "self", ".", "_is_empty", "=", "obs_key", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.BaseObsField.registry_key": [[46, 49], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "registry_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_registry_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.BaseObsField.attr_name": [[50, 53], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_name", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.BaseObsField.attr_key": [[54, 57], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.BaseObsField.is_empty": [[58, 61], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "_is_empty", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.NumericalObsField.validate_field": [[75, 79], ["super().validate_field", "KeyError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field"], ["def", "validate_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "validate_field", "(", "adata", ")", "\n", "if", "self", ".", "attr_key", "not", "in", "adata", ".", "obs", ":", "\n", "            ", "raise", "KeyError", "(", "f\"{self.attr_key} not found in adata.obs.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.NumericalObsField.register_field": [[80, 82], ["super().register_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "return", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.NumericalObsField.transfer_field": [[83, 91], ["super().transfer_field", "_obs_field.NumericalObsField.register_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "def", "transfer_field", "(", "\n", "self", ",", "\n", "state_registry", ":", "dict", ",", "\n", "adata_target", ":", "AnnData", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "return", "self", ".", "register_field", "(", "adata_target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.NumericalObsField.get_summary_stats": [[92, 94], ["None"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "_state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.NumericalObsField.view_state_registry": [[95, 97], ["None"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "_state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.__init__": [[117, 123], ["_obs_field.BaseObsField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "registry_key", ":", "str", ",", "obs_key", ":", "Optional", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "self", ".", "is_default", "=", "obs_key", "is", "None", "\n", "self", ".", "_original_attr_key", "=", "obs_key", "or", "registry_key", "\n", "super", "(", ")", ".", "__init__", "(", "registry_key", ",", "f\"_scvi_{registry_key}\"", ")", "\n", "\n", "self", ".", "count_stat_key", "=", "f\"n_{self.registry_key}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._setup_default_attr": [[124, 127], ["numpy.zeros"], "methods", ["None"], ["", "def", "_setup_default_attr", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "self", ".", "_original_attr_key", "=", "self", ".", "attr_key", "\n", "adata", ".", "obs", "[", "self", ".", "attr_key", "]", "=", "np", ".", "zeros", "(", "adata", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._get_original_column": [[128, 130], ["scvi.data._utils.get_anndata_attribute"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["", "def", "_get_original_column", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "return", "get_anndata_attribute", "(", "adata", ",", "self", ".", "attr_name", ",", "self", ".", "_original_attr_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.validate_field": [[131, 135], ["super().validate_field", "KeyError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field"], ["", "def", "validate_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "validate_field", "(", "adata", ")", "\n", "if", "self", ".", "_original_attr_key", "not", "in", "adata", ".", "obs", ":", "\n", "            ", "raise", "KeyError", "(", "f\"{self._original_attr_key} not found in adata.obs.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.register_field": [[136, 149], ["super().register_field", "scvi.data._utils._make_column_categorical", "_obs_field.CategoricalObsField._setup_default_attr"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._make_column_categorical", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._setup_default_attr"], ["", "", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "if", "self", ".", "is_default", ":", "\n", "            ", "self", ".", "_setup_default_attr", "(", "adata", ")", "\n", "\n", "", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "categorical_mapping", "=", "_make_column_categorical", "(", "\n", "adata", ".", "obs", ",", "\n", "self", ".", "_original_attr_key", ",", "\n", "self", ".", "attr_key", ",", "\n", ")", "\n", "return", "{", "\n", "self", ".", "CATEGORICAL_MAPPING_KEY", ":", "categorical_mapping", ",", "\n", "self", ".", "ORIGINAL_ATTR_KEY", ":", "self", ".", "_original_attr_key", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.transfer_field": [[151, 187], ["super().transfer_field", "_obs_field.CategoricalObsField.validate_field", "state_registry[].copy", "numpy.unique", "pandas.api.types.CategoricalDtype", "scvi.data._utils._make_column_categorical", "_obs_field.CategoricalObsField._setup_default_attr", "_obs_field.CategoricalObsField._get_original_column", "numpy.concatenate", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._make_column_categorical", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._setup_default_attr", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._get_original_column"], ["", "def", "transfer_field", "(", "\n", "self", ",", "\n", "state_registry", ":", "dict", ",", "\n", "adata_target", ":", "AnnData", ",", "\n", "extend_categories", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "\n", "if", "self", ".", "is_default", ":", "\n", "            ", "self", ".", "_setup_default_attr", "(", "adata_target", ")", "\n", "\n", "", "self", ".", "validate_field", "(", "adata_target", ")", "\n", "\n", "mapping", "=", "state_registry", "[", "self", ".", "CATEGORICAL_MAPPING_KEY", "]", ".", "copy", "(", ")", "\n", "\n", "# extend mapping for new categories", "\n", "for", "c", "in", "np", ".", "unique", "(", "self", ".", "_get_original_column", "(", "adata_target", ")", ")", ":", "\n", "            ", "if", "c", "not", "in", "mapping", ":", "\n", "                ", "if", "extend_categories", ":", "\n", "                    ", "mapping", "=", "np", ".", "concatenate", "(", "[", "mapping", ",", "[", "c", "]", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "f\"Category {c} not found in source registry. \"", "\n", "f\"Cannot transfer setup without `extend_categories = True`.\"", "\n", ")", "\n", "", "", "", "cat_dtype", "=", "CategoricalDtype", "(", "categories", "=", "mapping", ",", "ordered", "=", "True", ")", "\n", "new_mapping", "=", "_make_column_categorical", "(", "\n", "adata_target", ".", "obs", ",", "\n", "self", ".", "_original_attr_key", ",", "\n", "self", ".", "attr_key", ",", "\n", "categorical_dtype", "=", "cat_dtype", ",", "\n", ")", "\n", "return", "{", "\n", "self", ".", "CATEGORICAL_MAPPING_KEY", ":", "new_mapping", ",", "\n", "self", ".", "ORIGINAL_ATTR_KEY", ":", "self", ".", "_original_attr_key", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.get_summary_stats": [[189, 193], ["len", "numpy.unique"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "categorical_mapping", "=", "state_registry", "[", "self", ".", "CATEGORICAL_MAPPING_KEY", "]", "\n", "n_categories", "=", "len", "(", "np", ".", "unique", "(", "categorical_mapping", ")", ")", "\n", "return", "{", "self", ".", "count_stat_key", ":", "n_categories", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField.view_state_registry": [[194, 221], ["rich.table.Table", "rich.table.Table.add_column", "rich.table.Table.add_column", "rich.table.Table.add_column", "enumerate", "rich.table.Table.add_row", "rich.table.Table.add_row", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "source_key", "=", "state_registry", "[", "self", ".", "ORIGINAL_ATTR_KEY", "]", "\n", "mapping", "=", "state_registry", "[", "self", ".", "CATEGORICAL_MAPPING_KEY", "]", "\n", "t", "=", "rich", ".", "table", ".", "Table", "(", "title", "=", "f\"{self.registry_key} State Registry\"", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Source Location\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dodger_blue1\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Categories\"", ",", "justify", "=", "\"center\"", ",", "style", "=", "\"green\"", ",", "no_wrap", "=", "True", ",", "overflow", "=", "\"fold\"", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"scvi-tools Encoding\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dark_violet\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "for", "i", ",", "cat", "in", "enumerate", "(", "mapping", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "t", ".", "add_row", "(", "\"adata.obs['{}']\"", ".", "format", "(", "source_key", ")", ",", "str", "(", "cat", ")", ",", "str", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                ", "t", ".", "add_row", "(", "\"\"", ",", "str", "(", "cat", ")", ",", "str", "(", "i", ")", ")", "\n", "", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.__init__": [[26, 36], ["scvi.data.fields.BaseAnnDataField.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "mod_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "mod_required", ":", "bool", "=", "False", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "mod_required", "and", "mod_key", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Modality required for {self.__class__.__name__} but not provided.\"", "\n", ")", "\n", "", "self", ".", "_mod_key", "=", "mod_key", "\n", "self", ".", "_preregister", "=", "lambda", "_self", ",", "_mdata", ":", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.adata_field": [[37, 41], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "adata_field", "(", "self", ")", "->", "AnnDataField", ":", "\n", "        ", "\"\"\"AnnDataField instance that this class instance wraps.\"\"\"", "\n", "return", "self", ".", "_adata_field", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.registry_key": [[42, 46], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "registry_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"The key that is referenced by models via a data loader.\"\"\"", "\n", "return", "self", ".", "adata_field", ".", "registry_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.mod_key": [[47, 51], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mod_key", "(", "self", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "\"\"\"The modality key of the data field within the MuData (if applicable).\"\"\"", "\n", "return", "self", ".", "_mod_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.attr_name": [[52, 56], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"The name of the AnnData/MuData attribute where the data is stored.\"\"\"", "\n", "return", "self", ".", "adata_field", ".", "attr_name", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.attr_key": [[57, 61], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_key", "(", "self", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "\"\"\"The key of the data field within the relevant AnnData/MuData attribute.\"\"\"", "\n", "return", "self", ".", "adata_field", ".", "attr_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.is_empty": [[62, 65], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "adata_field", ".", "is_empty", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_modality": [[66, 76], ["isinstance", "AssertionError", "ValueError"], "methods", ["None"], ["", "def", "get_modality", "(", "self", ",", "mdata", ":", "MuData", ")", "->", "AnnOrMuData", ":", "\n", "        ", "\"\"\"Fetches the appropriate modality from the MuData object using ``self.mod_key``.\"\"\"", "\n", "if", "isinstance", "(", "mdata", ",", "AnnData", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "\"`get_modality` can only be called on MuData objects.\"", ")", "\n", "", "bdata", "=", "mdata", "\n", "if", "self", ".", "mod_key", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "mod_key", "not", "in", "mdata", ".", "mod", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Modality {self.mod_key} not found in mdata.mod.\"", ")", "\n", "", "bdata", "=", "mdata", ".", "mod", "[", "self", ".", "mod_key", "]", "\n", "", "return", "bdata", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.validate_field": [[77, 82], ["isinstance", "_mudata.BaseMuDataWrapperClass.get_modality", "_mudata.BaseMuDataWrapperClass.adata_field.validate_field", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_modality", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field"], ["", "def", "validate_field", "(", "self", ",", "mdata", ":", "MuData", ")", "->", "None", ":", "\n", "        ", "if", "isinstance", "(", "mdata", ",", "AnnData", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"`get_modality` can only be called on MuData objects.\"", ")", "\n", "", "bdata", "=", "self", ".", "get_modality", "(", "mdata", ")", "\n", "return", "self", ".", "adata_field", ".", "validate_field", "(", "bdata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.preregister": [[83, 92], ["_mudata.BaseMuDataWrapperClass._preregister"], "methods", ["None"], ["", "def", "preregister", "(", "self", ",", "mdata", ":", "MuData", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Function that is called prior to registering fields.\n\n        Function that is be called at the beginning of :func:`~scvi.data.fields.BaseMuDataWrapperClass.register_field`\n        and :func:`~scvi.data.fields.BaseMuDataWrapperClass.transfer_field`.\n        Used when data manipulation is necessary across modalities.\n        \"\"\"", "\n", "return", "self", ".", "_preregister", "(", "self", ",", "mdata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.register_field": [[93, 97], ["_mudata.BaseMuDataWrapperClass.preregister", "_mudata.BaseMuDataWrapperClass.get_modality", "_mudata.BaseMuDataWrapperClass.adata_field.register_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.preregister", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_modality", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "def", "register_field", "(", "self", ",", "mdata", ":", "MuData", ")", "->", "dict", ":", "\n", "        ", "self", ".", "preregister", "(", "mdata", ")", "\n", "bdata", "=", "self", ".", "get_modality", "(", "mdata", ")", "\n", "return", "self", ".", "adata_field", ".", "register_field", "(", "bdata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.transfer_field": [[98, 104], ["_mudata.BaseMuDataWrapperClass.preregister", "_mudata.BaseMuDataWrapperClass.get_modality", "_mudata.BaseMuDataWrapperClass.adata_field.transfer_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.preregister", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_modality", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field"], ["", "def", "transfer_field", "(", "\n", "self", ",", "state_registry", ":", "dict", ",", "mdata_target", ":", "MuData", ",", "**", "kwargs", "\n", ")", "->", "dict", ":", "\n", "        ", "self", ".", "preregister", "(", "mdata_target", ")", "\n", "bdata_target", "=", "self", ".", "get_modality", "(", "mdata_target", ")", "\n", "return", "self", ".", "adata_field", ".", "transfer_field", "(", "state_registry", ",", "bdata_target", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_summary_stats": [[105, 107], ["_mudata.BaseMuDataWrapperClass.adata_field.get_summary_stats"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.get_summary_stats"], ["", "def", "get_summary_stats", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "return", "self", ".", "adata_field", ".", "get_summary_stats", "(", "state_registry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.view_state_registry": [[108, 110], ["_mudata.BaseMuDataWrapperClass.adata_field.view_state_registry"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.view_state_registry"], ["", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "return", "self", ".", "adata_field", ".", "view_state_registry", "(", "state_registry", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.MuDataWrapper": [[112, 144], ["type", "isinstance", "ValueError", "_mudata.BaseMuDataWrapperClass.__init__", "adata_field_cls"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["", "", "def", "MuDataWrapper", "(", "\n", "adata_field_cls", ":", "AnnDataField", ",", "preregister_fn", ":", "Optional", "[", "Callable", "]", "=", "None", "\n", ")", "->", "AnnDataField", ":", "\n", "    ", "\"\"\"\n    Wraps an AnnDataField with :class:`~scvi.data.fields.BaseMuDataWrapperClass`.\n\n    Parameters\n    ----------\n    adata_field_cls\n        AnnDataField class to wrap.\n    preregister_fn\n        Function that will be called at the beginning of :func:`~scvi.data.fields.BaseMuDataWrapperClass.register_field`\n        and :func:`~scvi.data.fields.BaseMuDataWrapperClass.transfer_field`.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "adata_field_cls", ",", "type", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"`adata_field_cls` must be a class, not an instance.\"", ")", "\n", "\n", "", "def", "mudata_field_init", "(", "\n", "self", ",", "*", "args", ",", "mod_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "mod_required", ":", "bool", "=", "False", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "BaseMuDataWrapperClass", ".", "__init__", "(", "\n", "self", ",", "mod_key", "=", "mod_key", ",", "mod_required", "=", "mod_required", "\n", ")", "\n", "self", ".", "_adata_field", "=", "adata_field_cls", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "preregister_fn", "is", "not", "None", ":", "\n", "            ", "self", ".", "_preregister", "=", "preregister_fn", "\n", "\n", "", "", "return", "type", "(", "\n", "f\"MuData{adata_field_cls.__name__}\"", ",", "\n", "(", "BaseMuDataWrapperClass", ",", ")", ",", "\n", "{", "\n", "\"__init__\"", ":", "mudata_field_init", ",", "\n", "}", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField.__init__": [[32, 40], ["_obs_field.CategoricalObsField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["from", ".", "base", "import", "ArchesMixin", ",", "BaseModelClass", ",", "RNASeqMixin", ",", "VAEMixin", "\n", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "\n", "class", "SCANVI", "(", "RNASeqMixin", ",", "VAEMixin", ",", "ArchesMixin", ",", "BaseModelClass", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField._remap_unlabeled_to_final_category": [[41, 69], ["_scanvi.LabelsWithUnlabeledObsField._get_original_column", "pandas.api.types.CategoricalDtype", "scvi.data._utils._make_column_categorical", "numpy.where", "numpy.asarray", "list"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obs_field.CategoricalObsField._get_original_column", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._make_column_categorical"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField.register_field": [[71, 75], ["super().register_field", "_scanvi.LabelsWithUnlabeledObsField._remap_unlabeled_to_final_category"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField._remap_unlabeled_to_final_category"], []], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField.transfer_field": [[76, 108], ["super().transfer_field", "_scanvi.LabelsWithUnlabeledObsField._remap_unlabeled_to_final_category", "warnings.warn", "scvi.data._utils._set_data_in_registry", "kwargs.pop"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._scanvi.LabelsWithUnlabeledObsField._remap_unlabeled_to_final_category", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._set_data_in_registry"], ["\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "n_hidden", ":", "int", "=", "128", ",", "\n", "n_latent", ":", "int", "=", "10", ",", "\n", "n_layers", ":", "int", "=", "1", ",", "\n", "dropout_rate", ":", "float", "=", "0.1", ",", "\n", "dispersion", ":", "Literal", "[", "\"gene\"", ",", "\"gene-batch\"", ",", "\"gene-label\"", ",", "\"gene-cell\"", "]", "=", "\"gene\"", ",", "\n", "gene_likelihood", ":", "Literal", "[", "\"zinb\"", ",", "\"nb\"", ",", "\"poisson\"", "]", "=", "\"zinb\"", ",", "\n", "**", "model_kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", "SCANVI", ",", "self", ")", ".", "__init__", "(", "adata", ")", "\n", "scanvae_model_kwargs", "=", "dict", "(", "model_kwargs", ")", "\n", "\n", "self", ".", "_set_indices_and_labels", "(", ")", "\n", "\n", "# ignores unlabeled catgegory", "\n", "n_labels", "=", "self", ".", "summary_stats", ".", "n_labels", "-", "1", "\n", "n_cats_per_cov", "=", "(", "\n", "self", ".", "adata_manager", ".", "get_state_registry", "(", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin.__init__": [[35, 52], ["super().__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "*", "base_field_args", ",", "\n", "use_batch_mask", ":", "bool", "=", "True", ",", "\n", "batch_field", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "**", "base_field_kwargs", ",", "\n", ")", "->", "None", ":", "\n", "        ", "if", "use_batch_mask", "and", "batch_field", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"`use_batch_mask = True` requires that `batch_field is not None`. \"", "\n", "\"Please provide a `batch_field`.\"", "\n", ")", "\n", "", "self", ".", "use_batch_mask", "=", "use_batch_mask", "\n", "self", ".", "batch_field", "=", "batch_field", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "*", "base_field_args", ",", "\n", "**", "base_field_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin._get_batch_mask_protein_data": [[54, 76], ["_protein.ProteinFieldMixin.get_field_data", "_protein.ProteinFieldMixin.batch_field.get_field_data", "numpy.unique", "isinstance", "_protein.ProteinFieldMixin.to_numpy", "pro_exp[].sum", "numpy.sum", "logger.info", "numpy.where", "_protein.ProteinFieldMixin.ravel", "batch_mask.items"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data"], ["", "def", "_get_batch_mask_protein_data", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "Optional", "[", "dict", "]", ":", "\n", "        ", "\"\"\"\n        Returns a dict with length number of batches where each entry is a mask.\n\n        The mask is over cell measurement columns that are present (observed)\n        in each batch. Absence is defined by all 0 for that protein in that batch.\n        \"\"\"", "\n", "pro_exp", "=", "self", ".", "get_field_data", "(", "adata", ")", "\n", "pro_exp", "=", "pro_exp", ".", "to_numpy", "(", ")", "if", "isinstance", "(", "pro_exp", ",", "pd", ".", "DataFrame", ")", "else", "pro_exp", "\n", "batches", "=", "self", ".", "batch_field", ".", "get_field_data", "(", "adata", ")", "\n", "batch_mask", "=", "{", "}", "\n", "for", "b", "in", "np", ".", "unique", "(", "batches", ")", ":", "\n", "            ", "b_inds", "=", "np", ".", "where", "(", "batches", ".", "ravel", "(", ")", "==", "b", ")", "[", "0", "]", "\n", "batch_sum", "=", "pro_exp", "[", "b_inds", ",", ":", "]", ".", "sum", "(", "axis", "=", "0", ")", "\n", "all_zero", "=", "batch_sum", "==", "0", "\n", "batch_mask", "[", "b", "]", "=", "~", "all_zero", "\n", "\n", "", "if", "np", ".", "sum", "(", "[", "~", "b", "[", "1", "]", "for", "b", "in", "batch_mask", ".", "items", "(", ")", "]", ")", ">", "0", ":", "\n", "            ", "logger", ".", "info", "(", "\"Found batches with missing protein expression\"", ")", "\n", "return", "batch_mask", "\n", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin.register_field": [[77, 86], ["super().register_field", "_protein.ProteinFieldMixin._get_batch_mask_protein_data"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin._get_batch_mask_protein_data"], ["", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "state_registry", "=", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "\n", "if", "self", ".", "use_batch_mask", ":", "\n", "            ", "batch_mask", "=", "self", ".", "_get_batch_mask_protein_data", "(", "adata", ")", "\n", "if", "batch_mask", "is", "not", "None", ":", "\n", "                ", "state_registry", "[", "self", ".", "PROTEIN_BATCH_MASK", "]", "=", "batch_mask", "\n", "\n", "", "", "return", "state_registry", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin.transfer_field": [[87, 98], ["super().transfer_field", "_protein.ProteinFieldMixin._get_batch_mask_protein_data"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.ProteinFieldMixin._get_batch_mask_protein_data"], ["", "def", "transfer_field", "(", "\n", "self", ",", "state_registry", ":", "dict", ",", "adata_target", ":", "AnnData", ",", "**", "kwargs", "\n", ")", "->", "dict", ":", "\n", "        ", "transfer_state_registry", "=", "super", "(", ")", ".", "transfer_field", "(", "\n", "state_registry", ",", "adata_target", ",", "**", "kwargs", "\n", ")", "\n", "batch_mask", "=", "self", ".", "_get_batch_mask_protein_data", "(", "adata_target", ")", "\n", "if", "batch_mask", "is", "not", "None", ":", "\n", "            ", "transfer_state_registry", "[", "self", ".", "PROTEIN_BATCH_MASK", "]", "=", "batch_mask", "\n", "\n", "", "return", "transfer_state_registry", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._protein.copy_over_batch_attr": [[157, 169], ["isinstance", "_protein..batch_field.get_field_data", "_protein..get_modality", "getattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._mudata.BaseMuDataWrapperClass.get_modality"], ["", "def", "copy_over_batch_attr", "(", "self", ",", "mdata", ":", "MuData", ")", ":", "\n", "# Assign self.batch_field if not yet assigned to MuDataWrapped field.", "\n", "# Then, reassign self.adata_field.batch_field to the batch AnnDataField.", "\n", "    ", "if", "isinstance", "(", "self", ".", "adata_field", ".", "batch_field", ",", "BaseMuDataWrapperClass", ")", ":", "\n", "        ", "self", ".", "batch_field", "=", "self", ".", "adata_field", ".", "batch_field", "\n", "self", ".", "adata_field", ".", "batch_field", "=", "self", ".", "batch_field", ".", "adata_field", "\n", "\n", "# Copy over batch data to the protein modality.", "\n", "", "batch_data", "=", "self", ".", "batch_field", ".", "get_field_data", "(", "mdata", ")", "\n", "bdata", "=", "self", ".", "get_modality", "(", "mdata", ")", "\n", "bdata_attr", "=", "getattr", "(", "bdata", ",", "self", ".", "batch_field", ".", "attr_name", ")", "\n", "bdata_attr", "[", "self", ".", "batch_field", ".", "attr_key", "]", "=", "batch_data", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.registry_key": [[21, 25], ["None"], "methods", ["None"], ["@", "property", "\n", "@", "abstractmethod", "\n", "def", "registry_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"The key that is referenced by models via a data loader.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.attr_name": [[26, 30], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "attr_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"The name of the AnnData attribute where the data is stored.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.attr_key": [[31, 35], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "attr_key", "(", "self", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "\"\"\"The key of the data field within the relevant AnnData attribute.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.mod_key": [[36, 40], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mod_key", "(", "self", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "\"\"\"The modality key of the data field within the MuData (if applicable).\"\"\"", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.is_empty": [[41, 51], ["None"], "methods", ["None"], ["", "@", "property", "\n", "@", "abstractmethod", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Returns True if the field is empty as a function of its kwargs.\n\n        A field can be empty if it is composed of a collection of variables, and for a given\n        instance of a model, the collection is empty. If empty, the field will be omitted from\n        the registry, but included in the summary stats dictionary.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.validate_field": [[52, 55], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "validate_field", "(", "self", ",", "adata", ":", "AnnOrMuData", ")", "->", "None", ":", "\n", "        ", "\"\"\"Validates whether an AnnData/MuData object is compatible with this field definition.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.register_field": [[56, 69], ["_base_field.BaseAnnDataField.validate_field", "dict"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field"], ["", "@", "abstractmethod", "\n", "def", "register_field", "(", "self", ",", "adata", ":", "AnnOrMuData", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Sets up the AnnData/MuData object and creates a mapping for scvi-tools models to use.\n\n        Returns\n        -------\n        dict\n            A dictionary containing any additional state required for scvi-tools models not\n            stored directly on the AnnData/MuData object.\n        \"\"\"", "\n", "self", ".", "validate_field", "(", "adata", ")", "\n", "return", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.transfer_field": [[70, 96], ["dict"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "transfer_field", "(", "\n", "self", ",", "state_registry", ":", "dict", ",", "adata_target", ":", "AnnOrMuData", ",", "**", "kwargs", "\n", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Takes an existing scvi-tools setup dictionary and transfers the same setup to the target AnnData.\n\n        Used when one is running a pretrained model on a new AnnData object, which\n        requires the mapping from the original data to be applied to the new AnnData object.\n\n        Parameters\n        ----------\n        state_registry\n            state_registry dictionary created after registering an AnnData using an :class:`~scvi.data.AnnDataManager` object.\n        adata_target\n            AnnData/MuData object that is being registered.\n        **kwargs\n            Keyword arguments to modify transfer behavior.\n\n        Returns\n        -------\n        dict\n            A dictionary containing any additional state required for scvi-tools models not\n            stored directly on the AnnData object.\n        \"\"\"", "\n", "return", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_summary_stats": [[97, 115], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_summary_stats", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a dictionary comprising of summary statistics relevant to the field.\n\n        Parameters\n        ----------\n        state_registry\n            Dictionary returned by :meth:`~scvi.data.fields.BaseAnnDataField.register_field`.\n            Summary stats should always be a function of information stored in this dictionary.\n\n        Returns\n        -------\n        summary_stats_dict\n            The dictionary is of the form {summary_stat_name: summary_stat_value}.\n            This mapping is then combined with the mappings of other fields to make up\n            the summary stats mapping.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.view_state_registry": [[116, 132], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "\"\"\"\n        Returns a :class:`rich.table.Table` summarizing a state registry produced by this field.\n\n        Parameters\n        ----------\n        state_registry\n            Dictionary returned by :meth:`~scvi.data.fields.BaseAnnDataField.register_field`.\n            Printed summary should always be a function of information stored in this dictionary.\n\n        Returns\n        -------\n        state_registry_summary\n            Optional :class:`rich.table.Table` summarizing the ``state_registry``.\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data": [[133, 139], ["scvi.data._utils.get_anndata_attribute", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["", "def", "get_field_data", "(", "self", ",", "adata", ":", "AnnOrMuData", ")", "->", "Union", "[", "np", ".", "ndarray", ",", "pd", ".", "DataFrame", "]", ":", "\n", "        ", "\"\"\"Returns the requested data as determined by the field for a given AnnData/MuData object.\"\"\"", "\n", "if", "self", ".", "is_empty", ":", "\n", "            ", "raise", "AssertionError", "(", "f\"The {self.registry_key} field is empty.\"", ")", "\n", "", "return", "get_anndata_attribute", "(", "\n", "adata", ",", "self", ".", "attr_name", ",", "self", ".", "attr_key", ",", "mod_key", "=", "self", ".", "mod_key", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_data_registry": [[141, 158], ["dict"], "methods", ["None"], ["", "def", "get_data_registry", "(", "self", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Returns a nested dictionary which describes the mapping to the data field.\n\n        The dictionary is of the form {\"mod_key\": mod_key, \"attr_name\": attr_name, \"attr_key\": attr_key}.\n        This mapping is then combined with the mappings of other fields to make up the data registry.\n        \"\"\"", "\n", "if", "self", ".", "is_empty", ":", "\n", "            ", "return", "dict", "(", ")", "\n", "\n", "", "data_registry", "=", "{", "\n", "_constants", ".", "_DR_ATTR_NAME", ":", "self", ".", "attr_name", ",", "\n", "_constants", ".", "_DR_ATTR_KEY", ":", "self", ".", "attr_key", ",", "\n", "}", "\n", "if", "self", ".", "mod_key", "is", "not", "None", ":", "\n", "            ", "data_registry", "[", "_constants", ".", "_DR_MOD_KEY", "]", "=", "self", ".", "mod_key", "\n", "", "return", "data_registry", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.__init__": [[43, 64], ["_base_field.BaseAnnDataField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "registry_key", ":", "str", ",", "\n", "layer", ":", "Optional", "[", "str", "]", ",", "\n", "is_count_data", ":", "bool", "=", "True", ",", "\n", "correct_data_format", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_registry_key", "=", "registry_key", "\n", "self", ".", "_attr_name", "=", "(", "\n", "_constants", ".", "_ADATA_ATTRS", ".", "X", "\n", "if", "layer", "is", "None", "\n", "else", "_constants", ".", "_ADATA_ATTRS", ".", "LAYERS", "\n", ")", "\n", "self", ".", "_attr_key", "=", "layer", "\n", "self", ".", "is_count_data", "=", "is_count_data", "\n", "self", ".", "correct_data_format", "=", "correct_data_format", "\n", "self", ".", "count_stat_key", "=", "(", "\n", "self", ".", "N_VARS_KEY", "\n", "if", "self", ".", "registry_key", "==", "REGISTRY_KEYS", ".", "X_KEY", "\n", "else", "f\"n_{self.registry_key}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.registry_key": [[66, 69], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "registry_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_registry_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.attr_name": [[70, 73], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_name", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.attr_key": [[74, 77], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_key", "(", "self", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "return", "self", ".", "_attr_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.is_empty": [[78, 81], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.validate_field": [[82, 92], ["super().validate_field", "_layer_field.LayerField.get_field_data", "warnings.warn", "scvi.data._utils._check_nonnegative_integers"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_nonnegative_integers"], ["", "def", "validate_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "validate_field", "(", "adata", ")", "\n", "x", "=", "self", ".", "get_field_data", "(", "adata", ")", "\n", "\n", "if", "self", ".", "is_count_data", "and", "not", "_check_nonnegative_integers", "(", "x", ")", ":", "\n", "            ", "logger_data_loc", "=", "(", "\n", "\"adata.X\"", "if", "self", ".", "attr_key", "is", "None", "else", "f\"adata.layers[{self.attr_key}]\"", "\n", ")", "\n", "warnings", ".", "warn", "(", "\n", "f\"{logger_data_loc} does not contain unnormalized count data. \"", "\n", "\"Are you sure this is what you want?\"", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.register_field": [[95, 103], ["super().register_field", "scvi.data._utils._verify_and_correct_data_format", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._verify_and_correct_data_format"], ["", "", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "if", "self", ".", "correct_data_format", ":", "\n", "            ", "_verify_and_correct_data_format", "(", "adata", ",", "self", ".", "attr_name", ",", "self", ".", "attr_key", ")", "\n", "", "return", "{", "\n", "self", ".", "N_OBS_KEY", ":", "adata", ".", "n_obs", ",", "\n", "self", ".", "N_VARS_KEY", ":", "adata", ".", "n_vars", ",", "\n", "self", ".", "COLUMN_NAMES_KEY", ":", "np", ".", "asarray", "(", "adata", ".", "var_names", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.transfer_field": [[105, 118], ["super().transfer_field", "_layer_field.LayerField.register_field", "ValueError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "def", "transfer_field", "(", "\n", "self", ",", "state_registry", ":", "dict", ",", "adata_target", ":", "AnnData", ",", "**", "kwargs", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "n_vars", "=", "state_registry", "[", "self", ".", "N_VARS_KEY", "]", "\n", "target_n_vars", "=", "adata_target", ".", "n_vars", "\n", "if", "target_n_vars", "!=", "n_vars", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Number of vars in adata_target not the same as source. \"", "\n", "+", "\"Expected: {} Received: {}\"", ".", "format", "(", "target_n_vars", ",", "n_vars", ")", "\n", ")", "\n", "\n", "", "return", "self", ".", "register_field", "(", "adata_target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.get_summary_stats": [[119, 124], ["None"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "summary_stats", "=", "{", "self", ".", "count_stat_key", ":", "state_registry", "[", "self", ".", "N_VARS_KEY", "]", "}", "\n", "if", "self", ".", "registry_key", "==", "REGISTRY_KEYS", ".", "X_KEY", ":", "\n", "            ", "summary_stats", "[", "self", ".", "N_CELLS_KEY", "]", "=", "state_registry", "[", "self", ".", "N_OBS_KEY", "]", "\n", "", "return", "summary_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._layer_field.LayerField.view_state_registry": [[125, 127], ["None"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "_state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.BaseObsmField.__init__": [[29, 35], ["_base_field.BaseAnnDataField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "registry_key", ":", "str", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_registry_key", "=", "registry_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.BaseObsmField.registry_key": [[36, 39], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "registry_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_registry_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.BaseObsmField.attr_name": [[40, 43], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_name", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.__init__": [[72, 86], ["_obsm_field.BaseObsmField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "registry_key", ":", "str", ",", "\n", "obsm_key", ":", "str", ",", "\n", "colnames_uns_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "is_count_data", ":", "bool", "=", "False", ",", "\n", "correct_data_format", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "registry_key", ")", "\n", "self", ".", "_attr_key", "=", "obsm_key", "\n", "self", ".", "colnames_uns_key", "=", "colnames_uns_key", "\n", "self", ".", "is_count_data", "=", "is_count_data", "\n", "self", ".", "correct_data_format", "=", "correct_data_format", "\n", "self", ".", "count_stat_key", "=", "f\"n_{self.registry_key}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.attr_key": [[87, 90], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.is_empty": [[91, 94], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.validate_field": [[95, 105], ["super().validate_field", "_obsm_field.ObsmField.get_field_data", "KeyError", "warnings.warn", "scvi.data._utils._check_nonnegative_integers"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._check_nonnegative_integers"], ["", "def", "validate_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "validate_field", "(", "adata", ")", "\n", "if", "self", ".", "attr_key", "not", "in", "adata", ".", "obsm", ":", "\n", "            ", "raise", "KeyError", "(", "f\"{self.attr_key} not found in adata.obsm.\"", ")", "\n", "\n", "", "obsm_data", "=", "self", ".", "get_field_data", "(", "adata", ")", "\n", "\n", "if", "self", ".", "is_count_data", "and", "not", "_check_nonnegative_integers", "(", "obsm_data", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "f\"adata.obsm['{self.attr_key}'] does not contain unnormalized count data. \"", "\n", "\"Are you sure this is what you want?\"", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField._setup_column_names": [[108, 130], ["_obsm_field.ObsmField.get_field_data", "isinstance", "logger.info", "list", "logger.info", "logger.info", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data"], ["", "", "def", "_setup_column_names", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "Union", "[", "list", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Returns a list or NumPy array of column names that will be used for the relevant .obsm data.\n\n        If the ``colnames_uns_key`` was specified, then the columns stored in that\n        field will be returned. Otherwise, if the stored data is a pandas dataframe, then\n        the dataframe's colnames will be returned. In the case the stored data is a NumPy array,\n        sequential column names will be generated (e.g. 1, 2, 3, etc.)\n        \"\"\"", "\n", "obsm_data", "=", "self", ".", "get_field_data", "(", "adata", ")", "\n", "if", "self", ".", "colnames_uns_key", "is", "None", "and", "isinstance", "(", "obsm_data", ",", "pd", ".", "DataFrame", ")", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "f\"Using column names from columns of adata.obsm['{self.attr_key}']\"", "\n", ")", "\n", "column_names", "=", "list", "(", "obsm_data", ".", "columns", ")", "\n", "", "elif", "self", ".", "colnames_uns_key", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Using column names from adata.uns['{self.colnames_uns_key}']\"", ")", "\n", "column_names", "=", "adata", ".", "uns", "[", "self", ".", "colnames_uns_key", "]", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "\"Generating sequential column names\"", ")", "\n", "column_names", "=", "np", ".", "arange", "(", "obsm_data", ".", "shape", "[", "1", "]", ")", "\n", "", "return", "column_names", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.register_field": [[131, 139], ["super().register_field", "_obsm_field.ObsmField._setup_column_names", "scvi.data._utils._verify_and_correct_data_format"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField._setup_column_names", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._verify_and_correct_data_format"], ["", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "if", "self", ".", "correct_data_format", ":", "\n", "            ", "_verify_and_correct_data_format", "(", "adata", ",", "self", ".", "attr_name", ",", "self", ".", "attr_key", ")", "\n", "\n", "", "column_names", "=", "self", ".", "_setup_column_names", "(", "adata", ")", "\n", "\n", "return", "{", "self", ".", "COLUMN_NAMES_KEY", ":", "column_names", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.transfer_field": [[140, 162], ["super().transfer_field", "_obsm_field.ObsmField.validate_field", "_obsm_field.ObsmField.get_field_data", "len", "ValueError", "isinstance", "ValueError", "state_registry[].copy", "list", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._base_field.BaseAnnDataField.get_field_data"], ["", "def", "transfer_field", "(", "\n", "self", ",", "state_registry", ":", "dict", ",", "adata_target", ":", "AnnData", ",", "**", "kwargs", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "self", ".", "validate_field", "(", "adata_target", ")", "\n", "source_cols", "=", "state_registry", "[", "self", ".", "COLUMN_NAMES_KEY", "]", "\n", "target_data", "=", "self", ".", "get_field_data", "(", "adata_target", ")", "\n", "if", "len", "(", "source_cols", ")", "!=", "target_data", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Target adata.obsm['{self.attr_key}'] has {target_data.shape[1]} which does not match \"", "\n", "f\"the source adata.obsm['{self.attr_key}'] column count of {len(source_cols)}.\"", "\n", ")", "\n", "\n", "", "if", "isinstance", "(", "target_data", ",", "pd", ".", "DataFrame", ")", "and", "source_cols", "!=", "list", "(", "\n", "target_data", ".", "columns", "\n", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Target adata.obsm['{self.attr_key}'] column names do not match \"", "\n", "f\"the source adata.obsm['{self.attr_key}'] column names.\"", "\n", ")", "\n", "\n", "", "return", "{", "self", ".", "COLUMN_NAMES_KEY", ":", "state_registry", "[", "self", ".", "COLUMN_NAMES_KEY", "]", ".", "copy", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.get_summary_stats": [[163, 166], ["len"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "n_obsm_cols", "=", "len", "(", "state_registry", "[", "self", ".", "COLUMN_NAMES_KEY", "]", ")", "\n", "return", "{", "self", ".", "count_stat_key", ":", "n_obsm_cols", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.ObsmField.view_state_registry": [[167, 169], ["None"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.__init__": [[188, 193], ["_obsm_field.BaseObsmField.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "registry_key", ":", "str", ",", "obs_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "registry_key", ")", "\n", "self", ".", "_attr_key", "=", "f\"_scvi_{registry_key}\"", "\n", "self", ".", "_obs_keys", "=", "obs_keys", "if", "obs_keys", "is", "not", "None", "else", "[", "]", "\n", "self", ".", "_is_empty", "=", "len", "(", "self", ".", "obs_keys", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field": [[194, 199], ["super().validate_field", "KeyError"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field"], ["", "def", "validate_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "validate_field", "(", "adata", ")", "\n", "for", "obs_key", "in", "self", ".", "_obs_keys", ":", "\n", "            ", "if", "obs_key", "not", "in", "adata", ".", "obs", ":", "\n", "                ", "raise", "KeyError", "(", "f\"{obs_key} not found in adata.obs.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField._combine_obs_fields": [[200, 202], ["adata.obs[].copy"], "methods", ["None"], ["", "", "", "def", "_combine_obs_fields", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "None", ":", "\n", "        ", "adata", ".", "obsm", "[", "self", ".", "attr_key", "]", "=", "adata", ".", "obs", "[", "self", ".", "obs_keys", "]", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.obs_keys": [[203, 207], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "obs_keys", "(", "self", ")", "->", "List", "[", "str", "]", ":", "\n", "        ", "\"\"\"List of .obs keys that make up this joint field.\"\"\"", "\n", "return", "self", ".", "_obs_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.attr_key": [[208, 211], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "attr_key", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "_attr_key", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.is_empty": [[212, 215], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_empty", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "_is_empty", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.NumericalJointObsField.__init__": [[233, 237], ["_obsm_field.JointObsField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "registry_key", ":", "str", ",", "obs_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "registry_key", ",", "obs_keys", ")", "\n", "\n", "self", ".", "count_stat_key", "=", "f\"n_{self.registry_key}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.NumericalJointObsField.register_field": [[238, 242], ["super().register_field", "_obsm_field.NumericalJointObsField._combine_obs_fields", "adata.obsm[].columns.to_numpy"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField._combine_obs_fields"], ["", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "self", ".", "_combine_obs_fields", "(", "adata", ")", "\n", "return", "{", "self", ".", "COLUMNS_KEY", ":", "adata", ".", "obsm", "[", "self", ".", "attr_key", "]", ".", "columns", ".", "to_numpy", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.NumericalJointObsField.transfer_field": [[243, 251], ["super().transfer_field", "_obsm_field.NumericalJointObsField.register_field"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field"], ["", "def", "transfer_field", "(", "\n", "self", ",", "\n", "state_registry", ":", "dict", ",", "\n", "adata_target", ":", "AnnData", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "return", "self", ".", "register_field", "(", "adata_target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.NumericalJointObsField.get_summary_stats": [[252, 255], ["len"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "_state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "n_obs_keys", "=", "len", "(", "self", ".", "obs_keys", ")", "\n", "return", "{", "self", ".", "count_stat_key", ":", "n_obs_keys", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.NumericalJointObsField.view_state_registry": [[256, 271], ["rich.table.Table", "rich.table.Table.add_column", "rich.table.Table.add_row"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "if", "self", ".", "is_empty", ":", "\n", "            ", "return", "None", "\n", "\n", "", "t", "=", "rich", ".", "table", ".", "Table", "(", "title", "=", "f\"{self.registry_key} State Registry\"", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Source Location\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dodger_blue1\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "for", "key", "in", "state_registry", "[", "self", ".", "COLUMNS_KEY", "]", ":", "\n", "            ", "t", ".", "add_row", "(", "\"adata.obs['{}']\"", ".", "format", "(", "key", ")", ")", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.__init__": [[295, 298], ["_obsm_field.JointObsField.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "self", ",", "registry_key", ":", "str", ",", "obs_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "registry_key", ",", "obs_keys", ")", "\n", "self", ".", "count_stat_key", "=", "f\"n_{self.registry_key}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField._default_mappings_dict": [[299, 304], ["dict"], "methods", ["None"], ["", "def", "_default_mappings_dict", "(", "self", ")", "->", "dict", ":", "\n", "        ", "return", "{", "\n", "self", ".", "MAPPINGS_KEY", ":", "dict", "(", ")", ",", "\n", "self", ".", "FIELD_KEYS_KEY", ":", "[", "]", ",", "\n", "self", ".", "N_CATS_PER_KEY", ":", "[", "]", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField._make_obsm_categorical": [[306, 335], ["dict", "_obsm_field.CategoricalJointObsField._default_mappings_dict", "adata.obsm[].columns.tolist", "ValueError", "scvi.data._utils._make_column_categorical", "mappings_dict[].append", "pandas.api.types.CategoricalDtype", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField._default_mappings_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils._make_column_categorical"], ["", "def", "_make_obsm_categorical", "(", "\n", "self", ",", "adata", ":", "AnnData", ",", "category_dict", ":", "Optional", "[", "Dict", "[", "str", ",", "List", "[", "str", "]", "]", "]", "=", "None", "\n", ")", "->", "dict", ":", "\n", "        ", "if", "self", ".", "obs_keys", "!=", "adata", ".", "obsm", "[", "self", ".", "attr_key", "]", ".", "columns", ".", "tolist", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Original .obs keys do not match the columns in the generated .obsm field.\"", "\n", ")", "\n", "\n", "", "categories", "=", "dict", "(", ")", "\n", "obsm_df", "=", "adata", ".", "obsm", "[", "self", ".", "attr_key", "]", "\n", "for", "key", "in", "self", ".", "obs_keys", ":", "\n", "            ", "categorical_dtype", "=", "(", "\n", "CategoricalDtype", "(", "categories", "=", "category_dict", "[", "key", "]", ")", "\n", "if", "category_dict", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "mapping", "=", "_make_column_categorical", "(", "\n", "obsm_df", ",", "key", ",", "key", ",", "categorical_dtype", "=", "categorical_dtype", "\n", ")", "\n", "categories", "[", "key", "]", "=", "mapping", "\n", "\n", "", "store_cats", "=", "categories", "if", "category_dict", "is", "None", "else", "category_dict", "\n", "\n", "mappings_dict", "=", "self", ".", "_default_mappings_dict", "(", ")", "\n", "mappings_dict", "[", "self", ".", "MAPPINGS_KEY", "]", "=", "store_cats", "\n", "mappings_dict", "[", "self", ".", "FIELD_KEYS_KEY", "]", "=", "self", ".", "obs_keys", "\n", "for", "k", "in", "self", ".", "obs_keys", ":", "\n", "            ", "mappings_dict", "[", "self", ".", "N_CATS_PER_KEY", "]", ".", "append", "(", "len", "(", "store_cats", "[", "k", "]", ")", ")", "\n", "", "return", "mappings_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field": [[336, 340], ["super().register_field", "_obsm_field.CategoricalJointObsField._combine_obs_fields", "_obsm_field.CategoricalJointObsField._make_obsm_categorical"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.register_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField._combine_obs_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField._make_obsm_categorical"], ["", "def", "register_field", "(", "self", ",", "adata", ":", "AnnData", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "register_field", "(", "adata", ")", "\n", "self", ".", "_combine_obs_fields", "(", "adata", ")", "\n", "return", "self", ".", "_make_obsm_categorical", "(", "adata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field": [[341, 364], ["super().transfer_field", "state_registry[].copy", "_obsm_field.CategoricalJointObsField.validate_field", "_obsm_field.CategoricalJointObsField._combine_obs_fields", "_obsm_field.CategoricalJointObsField._make_obsm_categorical", "state_registry[].copy.items", "numpy.unique", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.transfer_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField.validate_field", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.JointObsField._combine_obs_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField._make_obsm_categorical"], ["", "def", "transfer_field", "(", "\n", "self", ",", "\n", "state_registry", ":", "dict", ",", "\n", "adata_target", ":", "AnnData", ",", "\n", "extend_categories", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "dict", ":", "\n", "        ", "super", "(", ")", ".", "transfer_field", "(", "state_registry", ",", "adata_target", ",", "**", "kwargs", ")", "\n", "\n", "if", "self", ".", "is_empty", ":", "\n", "            ", "return", "\n", "\n", "", "source_cat_dict", "=", "state_registry", "[", "self", ".", "MAPPINGS_KEY", "]", ".", "copy", "(", ")", "\n", "if", "extend_categories", ":", "\n", "            ", "for", "key", ",", "mapping", "in", "source_cat_dict", ".", "items", "(", ")", ":", "\n", "                ", "for", "c", "in", "np", ".", "unique", "(", "adata_target", ".", "obs", "[", "key", "]", ")", ":", "\n", "                    ", "if", "c", "not", "in", "mapping", ":", "\n", "                        ", "mapping", "=", "np", ".", "concatenate", "(", "[", "mapping", ",", "[", "c", "]", "]", ")", "\n", "", "", "source_cat_dict", "[", "key", "]", "=", "mapping", "\n", "\n", "", "", "self", ".", "validate_field", "(", "adata_target", ")", "\n", "self", ".", "_combine_obs_fields", "(", "adata_target", ")", "\n", "return", "self", ".", "_make_obsm_categorical", "(", "adata_target", ",", "category_dict", "=", "source_cat_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.get_summary_stats": [[365, 370], ["len"], "methods", ["None"], ["", "def", "get_summary_stats", "(", "self", ",", "_state_registry", ":", "dict", ")", "->", "dict", ":", "\n", "        ", "n_obs_keys", "=", "len", "(", "self", ".", "obs_keys", ")", "\n", "\n", "return", "{", "\n", "self", ".", "count_stat_key", ":", "n_obs_keys", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.fields._obsm_field.CategoricalJointObsField.view_state_registry": [[372, 402], ["rich.table.Table", "rich.table.Table.add_column", "rich.table.Table.add_column", "rich.table.Table.add_column", "state_registry[].items", "enumerate", "rich.table.Table.add_row", "rich.table.Table.add_row", "rich.table.Table.add_row", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "view_state_registry", "(", "self", ",", "state_registry", ":", "dict", ")", "->", "Optional", "[", "rich", ".", "table", ".", "Table", "]", ":", "\n", "        ", "if", "self", ".", "is_empty", ":", "\n", "            ", "return", "None", "\n", "\n", "", "t", "=", "rich", ".", "table", ".", "Table", "(", "title", "=", "f\"{self.registry_key} State Registry\"", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Source Location\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dodger_blue1\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"Categories\"", ",", "justify", "=", "\"center\"", ",", "style", "=", "\"green\"", ",", "no_wrap", "=", "True", ",", "overflow", "=", "\"fold\"", "\n", ")", "\n", "t", ".", "add_column", "(", "\n", "\"scvi-tools Encoding\"", ",", "\n", "justify", "=", "\"center\"", ",", "\n", "style", "=", "\"dark_violet\"", ",", "\n", "no_wrap", "=", "True", ",", "\n", "overflow", "=", "\"fold\"", ",", "\n", ")", "\n", "for", "key", ",", "mappings", "in", "state_registry", "[", "self", ".", "MAPPINGS_KEY", "]", ".", "items", "(", ")", ":", "\n", "            ", "for", "i", ",", "mapping", "in", "enumerate", "(", "mappings", ")", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "t", ".", "add_row", "(", "\"adata.obs['{}']\"", ".", "format", "(", "key", ")", ",", "str", "(", "mapping", ")", ",", "str", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                    ", "t", ".", "add_row", "(", "\"\"", ",", "str", "(", "mapping", ")", ",", "str", "(", "i", ")", ")", "\n", "", "", "t", ".", "add_row", "(", "\"\"", ",", "\"\"", ")", "\n", "", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._ann_dataloader.BatchSampler.__init__": [[34, 61], ["len", "ValueError", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "indices", ":", "np", ".", "ndarray", ",", "\n", "batch_size", ":", "int", ",", "\n", "shuffle", ":", "bool", ",", "\n", "drop_last", ":", "Union", "[", "bool", ",", "int", "]", "=", "False", ",", "\n", ")", ":", "\n", "        ", "self", ".", "indices", "=", "indices", "\n", "self", ".", "n_obs", "=", "len", "(", "indices", ")", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "\n", "if", "drop_last", ">", "batch_size", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"drop_last can't be greater than batch_size. \"", "\n", "+", "\"drop_last is {} but batch_size is {}.\"", ".", "format", "(", "drop_last", ",", "batch_size", ")", "\n", ")", "\n", "\n", "", "last_batch_len", "=", "self", ".", "n_obs", "%", "self", ".", "batch_size", "\n", "if", "(", "drop_last", "is", "True", ")", "or", "(", "last_batch_len", "<", "drop_last", ")", ":", "\n", "            ", "drop_last_n", "=", "last_batch_len", "\n", "", "elif", "(", "drop_last", "is", "False", ")", "or", "(", "last_batch_len", ">=", "drop_last", ")", ":", "\n", "            ", "drop_last_n", "=", "0", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid input for drop_last param. Must be bool or int.\"", ")", "\n", "\n", "", "self", ".", "drop_last_n", "=", "drop_last_n", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._ann_dataloader.BatchSampler.__iter__": [[62, 78], ["iter", "torch.randperm().tolist", "torch.arange().tolist", "torch.randperm", "torch.arange", "range", "len"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "shuffle", "is", "True", ":", "\n", "            ", "idx", "=", "torch", ".", "randperm", "(", "self", ".", "n_obs", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "torch", ".", "arange", "(", "self", ".", "n_obs", ")", ".", "tolist", "(", ")", "\n", "\n", "", "if", "self", ".", "drop_last_n", "!=", "0", ":", "\n", "            ", "idx", "=", "idx", "[", ":", "-", "self", ".", "drop_last_n", "]", "\n", "\n", "", "data_iter", "=", "iter", "(", "\n", "[", "\n", "self", ".", "indices", "[", "idx", "[", "i", ":", "i", "+", "self", ".", "batch_size", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "idx", ")", ",", "self", ".", "batch_size", ")", "\n", "]", "\n", ")", "\n", "return", "data_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._ann_dataloader.BatchSampler.__len__": [[79, 87], ["ceil"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "from", "math", "import", "ceil", "\n", "\n", "if", "self", ".", "drop_last_n", "!=", "0", ":", "\n", "            ", "length", "=", "self", ".", "n_obs", "//", "self", ".", "batch_size", "\n", "", "else", ":", "\n", "            ", "length", "=", "ceil", "(", "self", ".", "n_obs", "/", "self", ".", "batch_size", ")", "\n", "", "return", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._ann_dataloader.AnnDataLoader.__init__": [[113, 168], ["_anntorchdataset.AnnTorchDataset", "_ann_dataloader.BatchSampler", "copy.copy", "_ann_dataloader.AnnDataLoader.data_loader_kwargs.update", "torch.utils.data.DataLoader.__init__", "ValueError", "data_and_attributes.keys", "numpy.arange", "numpy.asarray", "_ann_dataloader.AnnDataLoader.data_loader_kwargs.update", "len", "hasattr", "[].ravel", "data_registry.keys", "ValueError", "numpy.dtype", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "shuffle", "=", "False", ",", "\n", "indices", "=", "None", ",", "\n", "batch_size", "=", "128", ",", "\n", "data_and_attributes", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "drop_last", ":", "Union", "[", "bool", ",", "int", "]", "=", "False", ",", "\n", "iter_ndarray", ":", "bool", "=", "False", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", ":", "\n", "\n", "        ", "if", "adata_manager", ".", "adata", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Please run register_fields() on your AnnDataManager object first.\"", "\n", ")", "\n", "\n", "", "if", "data_and_attributes", "is", "not", "None", ":", "\n", "            ", "data_registry", "=", "adata_manager", ".", "data_registry", "\n", "for", "key", "in", "data_and_attributes", ".", "keys", "(", ")", ":", "\n", "                ", "if", "key", "not", "in", "data_registry", ".", "keys", "(", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "f\"{key} required for model but not registered with AnnDataManager.\"", "\n", ")", "\n", "\n", "", "", "", "self", ".", "dataset", "=", "AnnTorchDataset", "(", "\n", "adata_manager", ",", "getitem_tensors", "=", "data_and_attributes", "\n", ")", "\n", "\n", "sampler_kwargs", "=", "{", "\n", "\"batch_size\"", ":", "batch_size", ",", "\n", "\"shuffle\"", ":", "shuffle", ",", "\n", "\"drop_last\"", ":", "drop_last", ",", "\n", "}", "\n", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "dataset", ")", ")", "\n", "sampler_kwargs", "[", "\"indices\"", "]", "=", "indices", "\n", "", "else", ":", "\n", "            ", "if", "hasattr", "(", "indices", ",", "\"dtype\"", ")", "and", "indices", ".", "dtype", "is", "np", ".", "dtype", "(", "\"bool\"", ")", ":", "\n", "                ", "indices", "=", "np", ".", "where", "(", "indices", ")", "[", "0", "]", ".", "ravel", "(", ")", "\n", "", "indices", "=", "np", ".", "asarray", "(", "indices", ")", "\n", "sampler_kwargs", "[", "\"indices\"", "]", "=", "indices", "\n", "\n", "", "self", ".", "indices", "=", "indices", "\n", "self", ".", "sampler_kwargs", "=", "sampler_kwargs", "\n", "sampler", "=", "BatchSampler", "(", "**", "self", ".", "sampler_kwargs", ")", "\n", "self", ".", "data_loader_kwargs", "=", "copy", ".", "copy", "(", "data_loader_kwargs", ")", "\n", "# do not touch batch size here, sampler gives batched indices", "\n", "self", ".", "data_loader_kwargs", ".", "update", "(", "{", "\"sampler\"", ":", "sampler", ",", "\"batch_size\"", ":", "None", "}", ")", "\n", "\n", "if", "iter_ndarray", ":", "\n", "            ", "self", ".", "data_loader_kwargs", ".", "update", "(", "{", "\"collate_fn\"", ":", "_dummy_collate", "}", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "self", ".", "dataset", ",", "**", "self", ".", "data_loader_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._ann_dataloader._dummy_collate": [[170, 173], ["None"], "function", ["None"], ["", "", "def", "_dummy_collate", "(", "b", ")", ":", "\n", "    ", "\"\"\"Dummy collate to have dataloader return numpy ndarrays.\"\"\"", "\n", "return", "b", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._concat_dataloader.ConcatDataLoader.__init__": [[34, 60], ["torch.utils.data.DataLoader.__init__", "_concat_dataloader.ConcatDataLoader.dataloaders.append", "len", "_ann_dataloader.AnnDataLoader", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "indices_list", ":", "List", "[", "List", "[", "int", "]", "]", ",", "\n", "shuffle", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "data_and_attributes", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "drop_last", ":", "Union", "[", "bool", ",", "int", "]", "=", "False", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", ":", "\n", "        ", "self", ".", "dataloaders", "=", "[", "]", "\n", "for", "indices", "in", "indices_list", ":", "\n", "            ", "self", ".", "dataloaders", ".", "append", "(", "\n", "AnnDataLoader", "(", "\n", "adata_manager", ",", "\n", "indices", "=", "indices", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "data_and_attributes", "=", "data_and_attributes", ",", "\n", "drop_last", "=", "drop_last", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", "\n", ")", "\n", "", "lens", "=", "[", "len", "(", "dl", ")", "for", "dl", "in", "self", ".", "dataloaders", "]", "\n", "self", ".", "largest_dl", "=", "self", ".", "dataloaders", "[", "np", ".", "argmax", "(", "lens", ")", "]", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "largest_dl", ",", "**", "data_loader_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._concat_dataloader.ConcatDataLoader.__len__": [[61, 63], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "largest_dl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._concat_dataloader.ConcatDataLoader.__iter__": [[64, 76], ["zip", "itertools.cycle"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Iter method for concat data loader.\n\n        Will iter over the dataloader with the most data while cycling through\n        the data in the other dataloaders. The order of data in returned iter_list\n        is the same as indices_list.\n        \"\"\"", "\n", "iter_list", "=", "[", "\n", "cycle", "(", "dl", ")", "if", "dl", "!=", "self", ".", "largest_dl", "else", "dl", "for", "dl", "in", "self", ".", "dataloaders", "\n", "]", "\n", "return", "zip", "(", "*", "iter_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.__init__": [[19, 30], ["_anntorchdataset.AnnTorchDataset.setup_getitem", "_anntorchdataset.AnnTorchDataset.setup_data_attr"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.setup_getitem", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.setup_data_attr"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "getitem_tensors", ":", "Union", "[", "List", "[", "str", "]", ",", "Dict", "[", "str", ",", "type", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "adata_manager", "=", "adata_manager", "\n", "self", ".", "is_backed", "=", "adata_manager", ".", "adata", ".", "isbacked", "\n", "self", ".", "attributes_and_types", "=", "None", "\n", "self", ".", "getitem_tensors", "=", "getitem_tensors", "\n", "self", ".", "setup_getitem", "(", ")", "\n", "self", ".", "setup_data_attr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.registered_keys": [[31, 35], ["_anntorchdataset.AnnTorchDataset.adata_manager.data_registry.keys"], "methods", ["None"], ["", "@", "property", "\n", "def", "registered_keys", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns the keys of the mappings in scvi data registry.\"\"\"", "\n", "return", "self", ".", "adata_manager", ".", "data_registry", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.setup_data_attr": [[36, 45], ["_anntorchdataset.AnnTorchDataset.adata_manager.get_from_registry", "_anntorchdataset.AnnTorchDataset.attributes_and_types.items"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "setup_data_attr", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Sets data attribute.\n\n        Reduces number of times anndata needs to be accessed\n        \"\"\"", "\n", "self", ".", "data", "=", "{", "\n", "key", ":", "self", ".", "adata_manager", ".", "get_from_registry", "(", "key", ")", "\n", "for", "key", ",", "_", "in", "self", ".", "attributes_and_types", ".", "items", "(", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.setup_getitem": [[47, 94], ["isinstance", "isinstance", "getitem_tensors.keys", "KeyError", "ValueError"], "methods", ["None"], ["", "def", "setup_getitem", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Sets up the __getitem__ function used by Pytorch.\n\n        By default, getitem will return every single item registered in the scvi data registry\n        and will attempt to infer the correct type. np.float32 for continuous values, otherwise np.int64.\n\n        If you want to specify which specific tensors to return you can pass in a List of keys from\n        the scvi data registry. If you want to speficy specific tensors to return as well as their\n        associated types, then you can pass in a dictionary with their type.\n\n        Paramaters\n        ----------\n        getitem_tensors:\n            Either a list of keys in the scvi data registry to return when getitem is called\n            or a dictionary mapping keys to numpy types.\n\n        Examples\n        --------\n        >>> sd = AnnTorchDataset(adata_manager)\n\n        # following will only return the X and batch both by default as np.float32\n        >>> sd.setup_getitem(getitem_tensors  = ['X,'batch'])\n\n        # This will return X as an integer and batch as np.float32\n        >>> sd.setup_getitem(getitem_tensors  = {'X':np.int64, 'batch':np.float32])\n        \"\"\"", "\n", "registered_keys", "=", "self", ".", "registered_keys", "\n", "getitem_tensors", "=", "self", ".", "getitem_tensors", "\n", "if", "isinstance", "(", "getitem_tensors", ",", "List", ")", ":", "\n", "            ", "keys", "=", "getitem_tensors", "\n", "keys_to_type", "=", "{", "key", ":", "np", ".", "float32", "for", "key", "in", "keys", "}", "\n", "", "elif", "isinstance", "(", "getitem_tensors", ",", "Dict", ")", ":", "\n", "            ", "keys", "=", "getitem_tensors", ".", "keys", "(", ")", "\n", "keys_to_type", "=", "getitem_tensors", "\n", "", "elif", "getitem_tensors", "is", "None", ":", "\n", "            ", "keys", "=", "registered_keys", "\n", "keys_to_type", "=", "{", "key", ":", "np", ".", "float32", "for", "key", "in", "keys", "}", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"getitem_tensors invalid type. Expected: List[str] or Dict[str, type] or None\"", "\n", ")", "\n", "", "for", "key", "in", "keys", ":", "\n", "            ", "if", "key", "not", "in", "registered_keys", ":", "\n", "                ", "raise", "KeyError", "(", "f\"{key} not in data_registry\"", ")", "\n", "\n", "", "", "self", ".", "attributes_and_types", "=", "keys_to_type", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.__getitem__": [[95, 123], ["_anntorchdataset.AnnTorchDataset.attributes_and_types.items", "hasattr", "isinstance", "isinstance", "scipy.sparse.issparse", "cur_data[].toarray().astype.astype", "isinstance", "numpy.argsort", "cur_data[].toarray().astype.toarray", "cur_data[].astype", "isinstance", "cur_data.iloc[].to_numpy().astype", "scipy.sparse.issparse", "cur_data[].toarray().astype", "TypeError", "cur_data.iloc[].to_numpy", "cur_data[].toarray"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ":", "List", "[", "int", "]", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"Get tensors in dictionary from anndata at idx.\"\"\"", "\n", "data_numpy", "=", "{", "}", "\n", "\n", "if", "self", ".", "is_backed", "and", "hasattr", "(", "idx", ",", "\"shape\"", ")", ":", "\n", "# need to sort idxs for h5py datasets", "\n", "            ", "idx", "=", "idx", "[", "np", ".", "argsort", "(", "idx", ")", "]", "\n", "", "for", "key", ",", "dtype", "in", "self", ".", "attributes_and_types", ".", "items", "(", ")", ":", "\n", "            ", "cur_data", "=", "self", ".", "data", "[", "key", "]", "\n", "# for backed anndata", "\n", "if", "isinstance", "(", "cur_data", ",", "h5py", ".", "Dataset", ")", "or", "isinstance", "(", "\n", "cur_data", ",", "SparseDataset", "\n", ")", ":", "\n", "                ", "sliced_data", "=", "cur_data", "[", "idx", "]", "\n", "if", "issparse", "(", "cur_data", ")", ":", "\n", "                    ", "sliced_data", "=", "sliced_data", ".", "toarray", "(", ")", "\n", "", "sliced_data", "=", "sliced_data", ".", "astype", "(", "dtype", ")", "\n", "", "elif", "isinstance", "(", "cur_data", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "sliced_data", "=", "cur_data", "[", "idx", "]", ".", "astype", "(", "dtype", ")", "\n", "", "elif", "isinstance", "(", "cur_data", ",", "pd", ".", "DataFrame", ")", ":", "\n", "                ", "sliced_data", "=", "cur_data", ".", "iloc", "[", "idx", ",", ":", "]", ".", "to_numpy", "(", ")", ".", "astype", "(", "dtype", ")", "\n", "", "elif", "issparse", "(", "cur_data", ")", ":", "\n", "                ", "sliced_data", "=", "cur_data", "[", "idx", "]", ".", "toarray", "(", ")", ".", "astype", "(", "dtype", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "f\"{key} is not a supported type\"", ")", "\n", "", "data_numpy", "[", "key", "]", "=", "sliced_data", "\n", "\n", "", "return", "data_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.get_data": [[124, 127], ["_anntorchdataset.AnnTorchDataset.__getitem__", "range", "_anntorchdataset.AnnTorchDataset.__len__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting._DeviceBackedDataset.__getitem__", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting._DeviceBackedDataset.__len__"], ["", "def", "get_data", "(", "self", ",", "scvi_data_key", ")", ":", "\n", "        ", "tensors", "=", "self", ".", "__getitem__", "(", "idx", "=", "[", "i", "for", "i", "in", "range", "(", "self", ".", "__len__", "(", ")", ")", "]", ")", "\n", "return", "tensors", "[", "scvi_data_key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._anntorchdataset.AnnTorchDataset.__len__": [[128, 130], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "adata_manager", ".", "adata", ".", "shape", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DataSplitter.__init__": [[88, 105], ["pytorch_lightning.LightningDataModule.__init__", "float", "_data_splitting.validate_data_split"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.validate_data_split"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "use_gpu", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "adata_manager", "=", "adata_manager", "\n", "self", ".", "train_size", "=", "float", "(", "train_size", ")", "\n", "self", ".", "validation_size", "=", "validation_size", "\n", "self", ".", "data_loader_kwargs", "=", "kwargs", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "\n", "self", ".", "n_train", ",", "self", ".", "n_val", "=", "validate_data_split", "(", "\n", "self", ".", "adata_manager", ".", "adata", ".", "n_obs", ",", "self", ".", "train_size", ",", "self", ".", "validation_size", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DataSplitter.setup": [[107, 120], ["numpy.random.RandomState", "numpy.random.RandomState.permutation", "scvi.model._utils.parse_use_gpu_arg"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg"], ["", "def", "setup", "(", "self", ",", "stage", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"Split indices in train/test/val sets.\"\"\"", "\n", "n_train", "=", "self", ".", "n_train", "\n", "n_val", "=", "self", ".", "n_val", "\n", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "settings", ".", "seed", ")", "\n", "permutation", "=", "random_state", ".", "permutation", "(", "self", ".", "adata_manager", ".", "adata", ".", "n_obs", ")", "\n", "self", ".", "val_idx", "=", "permutation", "[", ":", "n_val", "]", "\n", "self", ".", "train_idx", "=", "permutation", "[", "n_val", ":", "(", "n_val", "+", "n_train", ")", "]", "\n", "self", ".", "test_idx", "=", "permutation", "[", "(", "n_val", "+", "n_train", ")", ":", "]", "\n", "\n", "gpus", ",", "self", ".", "device", "=", "parse_use_gpu_arg", "(", "self", ".", "use_gpu", ",", "return_device", "=", "True", ")", "\n", "self", ".", "pin_memory", "=", "(", "\n", "True", "if", "(", "settings", ".", "dl_pin_memory_gpu_training", "and", "gpus", "!=", "0", ")", "else", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DataSplitter.train_dataloader": [[122, 130], ["scvi.dataloaders._ann_dataloader.AnnDataLoader"], "methods", ["None"], ["", "def", "train_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "AnnDataLoader", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "train_idx", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DataSplitter.val_dataloader": [[132, 144], ["len", "scvi.dataloaders._ann_dataloader.AnnDataLoader"], "methods", ["None"], ["", "def", "val_dataloader", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "val_idx", ")", ">", "0", ":", "\n", "            ", "return", "AnnDataLoader", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "val_idx", ",", "\n", "shuffle", "=", "False", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DataSplitter.test_dataloader": [[145, 157], ["len", "scvi.dataloaders._ann_dataloader.AnnDataLoader"], "methods", ["None"], ["", "", "def", "test_dataloader", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "test_idx", ")", ">", "0", ":", "\n", "            ", "return", "AnnDataLoader", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "test_idx", ",", "\n", "shuffle", "=", "False", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.SemiSupervisedDataSplitter.__init__": [[196, 226], ["pytorch_lightning.LightningDataModule.__init__", "float", "adata_manager.get_state_registry", "scvi.data._utils.get_anndata_attribute().ravel", "numpy.argwhere().ravel", "numpy.argwhere().ravel", "scvi.data._utils.get_anndata_attribute", "numpy.argwhere", "numpy.argwhere"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "train_size", ":", "float", "=", "0.9", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "n_samples_per_label", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "use_gpu", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "adata_manager", "=", "adata_manager", "\n", "self", ".", "train_size", "=", "float", "(", "train_size", ")", "\n", "self", ".", "validation_size", "=", "validation_size", "\n", "self", ".", "data_loader_kwargs", "=", "kwargs", "\n", "self", ".", "n_samples_per_label", "=", "n_samples_per_label", "\n", "\n", "labels_state_registry", "=", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", "\n", ")", "\n", "labels", "=", "get_anndata_attribute", "(", "\n", "adata_manager", ".", "adata", ",", "\n", "adata_manager", ".", "data_registry", ".", "labels", ".", "attr_name", ",", "\n", "labels_state_registry", ".", "original_key", ",", "\n", ")", ".", "ravel", "(", ")", "\n", "self", ".", "unlabeled_category", "=", "labels_state_registry", ".", "unlabeled_category", "\n", "self", ".", "_unlabeled_indices", "=", "np", ".", "argwhere", "(", "labels", "==", "self", ".", "unlabeled_category", ")", ".", "ravel", "(", ")", "\n", "self", ".", "_labeled_indices", "=", "np", ".", "argwhere", "(", "labels", "!=", "self", ".", "unlabeled_category", ")", ".", "ravel", "(", ")", "\n", "\n", "self", ".", "data_loader_kwargs", "=", "kwargs", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.SemiSupervisedDataSplitter.setup": [[227, 293], ["len", "len", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate.astype", "numpy.concatenate.astype", "numpy.concatenate.astype", "scvi.model._utils.parse_use_gpu_arg", "_data_splitting.SemiSupervisedDataSplitter.data_loader_kwargs.update", "_data_splitting.validate_data_split", "numpy.random.RandomState", "numpy.random.RandomState.choice", "_data_splitting.validate_data_split", "numpy.random.RandomState", "numpy.random.RandomState.choice", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._utils.parse_use_gpu_arg", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.validate_data_split", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.validate_data_split"], ["", "def", "setup", "(", "self", ",", "stage", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"Split indices in train/test/val sets.\"\"\"", "\n", "n_labeled_idx", "=", "len", "(", "self", ".", "_labeled_indices", ")", "\n", "n_unlabeled_idx", "=", "len", "(", "self", ".", "_unlabeled_indices", ")", "\n", "\n", "if", "n_labeled_idx", "!=", "0", ":", "\n", "            ", "n_labeled_train", ",", "n_labeled_val", "=", "validate_data_split", "(", "\n", "n_labeled_idx", ",", "self", ".", "train_size", ",", "self", ".", "validation_size", "\n", ")", "\n", "rs", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "settings", ".", "seed", ")", "\n", "labeled_permutation", "=", "rs", ".", "choice", "(", "\n", "self", ".", "_labeled_indices", ",", "len", "(", "self", ".", "_labeled_indices", ")", ",", "replace", "=", "False", "\n", ")", "\n", "labeled_idx_val", "=", "labeled_permutation", "[", ":", "n_labeled_val", "]", "\n", "labeled_idx_train", "=", "labeled_permutation", "[", "\n", "n_labeled_val", ":", "(", "n_labeled_val", "+", "n_labeled_train", ")", "\n", "]", "\n", "labeled_idx_test", "=", "labeled_permutation", "[", "(", "n_labeled_val", "+", "n_labeled_train", ")", ":", "]", "\n", "", "else", ":", "\n", "            ", "labeled_idx_test", "=", "[", "]", "\n", "labeled_idx_train", "=", "[", "]", "\n", "labeled_idx_val", "=", "[", "]", "\n", "\n", "", "if", "n_unlabeled_idx", "!=", "0", ":", "\n", "            ", "n_unlabeled_train", ",", "n_unlabeled_val", "=", "validate_data_split", "(", "\n", "n_unlabeled_idx", ",", "self", ".", "train_size", ",", "self", ".", "validation_size", "\n", ")", "\n", "rs", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "settings", ".", "seed", ")", "\n", "unlabeled_permutation", "=", "rs", ".", "choice", "(", "\n", "self", ".", "_unlabeled_indices", ",", "len", "(", "self", ".", "_unlabeled_indices", ")", "\n", ")", "\n", "unlabeled_idx_val", "=", "unlabeled_permutation", "[", ":", "n_unlabeled_val", "]", "\n", "unlabeled_idx_train", "=", "unlabeled_permutation", "[", "\n", "n_unlabeled_val", ":", "(", "n_unlabeled_val", "+", "n_unlabeled_train", ")", "\n", "]", "\n", "unlabeled_idx_test", "=", "unlabeled_permutation", "[", "\n", "(", "n_unlabeled_val", "+", "n_unlabeled_train", ")", ":", "\n", "]", "\n", "", "else", ":", "\n", "            ", "unlabeled_idx_train", "=", "[", "]", "\n", "unlabeled_idx_val", "=", "[", "]", "\n", "unlabeled_idx_test", "=", "[", "]", "\n", "\n", "", "indices_train", "=", "np", ".", "concatenate", "(", "(", "labeled_idx_train", ",", "unlabeled_idx_train", ")", ")", "\n", "indices_val", "=", "np", ".", "concatenate", "(", "(", "labeled_idx_val", ",", "unlabeled_idx_val", ")", ")", "\n", "indices_test", "=", "np", ".", "concatenate", "(", "(", "labeled_idx_test", ",", "unlabeled_idx_test", ")", ")", "\n", "\n", "self", ".", "train_idx", "=", "indices_train", ".", "astype", "(", "int", ")", "\n", "self", ".", "val_idx", "=", "indices_val", ".", "astype", "(", "int", ")", "\n", "self", ".", "test_idx", "=", "indices_test", ".", "astype", "(", "int", ")", "\n", "\n", "gpus", "=", "parse_use_gpu_arg", "(", "self", ".", "use_gpu", ",", "return_device", "=", "False", ")", "\n", "self", ".", "pin_memory", "=", "(", "\n", "True", "if", "(", "settings", ".", "dl_pin_memory_gpu_training", "and", "gpus", "!=", "0", ")", "else", "False", "\n", ")", "\n", "\n", "if", "len", "(", "self", ".", "_labeled_indices", ")", "!=", "0", ":", "\n", "            ", "self", ".", "data_loader_class", "=", "SemiSupervisedDataLoader", "\n", "dl_kwargs", "=", "{", "\n", "\"n_samples_per_label\"", ":", "self", ".", "n_samples_per_label", ",", "\n", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "data_loader_class", "=", "AnnDataLoader", "\n", "dl_kwargs", "=", "{", "}", "\n", "\n", "", "self", ".", "data_loader_kwargs", ".", "update", "(", "dl_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.SemiSupervisedDataSplitter.train_dataloader": [[294, 302], ["_data_splitting.SemiSupervisedDataSplitter.data_loader_class"], "methods", ["None"], ["", "def", "train_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_loader_class", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "train_idx", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.SemiSupervisedDataSplitter.val_dataloader": [[304, 316], ["len", "_data_splitting.SemiSupervisedDataSplitter.data_loader_class"], "methods", ["None"], ["", "def", "val_dataloader", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "val_idx", ")", ">", "0", ":", "\n", "            ", "return", "self", ".", "data_loader_class", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "val_idx", ",", "\n", "shuffle", "=", "False", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.SemiSupervisedDataSplitter.test_dataloader": [[317, 329], ["len", "_data_splitting.SemiSupervisedDataSplitter.data_loader_class"], "methods", ["None"], ["", "", "def", "test_dataloader", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "test_idx", ")", ">", "0", ":", "\n", "            ", "return", "self", ".", "data_loader_class", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "self", ".", "test_idx", ",", "\n", "shuffle", "=", "False", ",", "\n", "drop_last", "=", "3", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.__init__": [[365, 386], ["_data_splitting.DataSplitter.__init__"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "train_size", ":", "float", "=", "1.0", ",", "\n", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "use_gpu", ":", "bool", "=", "False", ",", "\n", "shuffle", ":", "bool", "=", "False", ",", "\n", "shuffle_test_val", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "adata_manager", "=", "adata_manager", ",", "\n", "train_size", "=", "train_size", ",", "\n", "validation_size", "=", "validation_size", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "shuffle_test_val", "=", "shuffle_test_val", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup": [[387, 404], ["_data_splitting.DataSplitter.setup", "_data_splitting.DeviceBackedDataSplitter._get_tensor_dict", "_data_splitting.DeviceBackedDataSplitter._get_tensor_dict", "_data_splitting.DeviceBackedDataSplitter._get_tensor_dict", "numpy.sort", "numpy.sort", "numpy.sort", "len", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._get_tensor_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._get_tensor_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._get_tensor_dict"], ["", "def", "setup", "(", "self", ",", "stage", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "setup", "(", ")", "\n", "\n", "if", "self", ".", "shuffle", "is", "False", ":", "\n", "            ", "self", ".", "train_idx", "=", "np", ".", "sort", "(", "self", ".", "train_idx", ")", "\n", "self", ".", "val_idx", "=", "(", "\n", "np", ".", "sort", "(", "self", ".", "val_idx", ")", "if", "len", "(", "self", ".", "val_idx", ")", ">", "0", "else", "self", ".", "val_idx", "\n", ")", "\n", "self", ".", "test_idx", "=", "(", "\n", "np", ".", "sort", "(", "self", ".", "test_idx", ")", "if", "len", "(", "self", ".", "test_idx", ")", ">", "0", "else", "self", ".", "test_idx", "\n", ")", "\n", "\n", "", "self", ".", "train_tensor_dict", "=", "self", ".", "_get_tensor_dict", "(", "\n", "self", ".", "train_idx", ",", "device", "=", "self", ".", "device", "\n", ")", "\n", "self", ".", "test_tensor_dict", "=", "self", ".", "_get_tensor_dict", "(", "self", ".", "test_idx", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "val_tensor_dict", "=", "self", ".", "_get_tensor_dict", "(", "self", ".", "val_idx", ",", "device", "=", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._get_tensor_dict": [[405, 425], ["scvi.dataloaders._ann_dataloader.AnnDataLoader", "tensor_dict.items", "len", "len", "v.to", "len"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.to"], ["", "def", "_get_tensor_dict", "(", "self", ",", "indices", ",", "device", ")", ":", "\n", "        ", "if", "len", "(", "indices", ")", "is", "not", "None", "and", "len", "(", "indices", ")", ">", "0", ":", "\n", "            ", "dl", "=", "AnnDataLoader", "(", "\n", "self", ".", "adata_manager", ",", "\n", "indices", "=", "indices", ",", "\n", "batch_size", "=", "len", "(", "indices", ")", ",", "\n", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "self", ".", "pin_memory", ",", "\n", "**", "self", ".", "data_loader_kwargs", ",", "\n", ")", "\n", "# will only have one minibatch", "\n", "for", "batch", "in", "dl", ":", "\n", "                ", "tensor_dict", "=", "batch", "\n", "\n", "", "for", "k", ",", "v", "in", "tensor_dict", ".", "items", "(", ")", ":", "\n", "                ", "tensor_dict", "[", "k", "]", "=", "v", ".", "to", "(", "device", ")", "\n", "\n", "", "return", "tensor_dict", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._make_dataloader": [[426, 434], ["_data_splitting._DeviceBackedDataset", "numpy.arange", "scvi.dataloaders._ann_dataloader.BatchSampler", "torch.utils.data.DataLoader", "len", "len"], "methods", ["None"], ["", "", "def", "_make_dataloader", "(", "self", ",", "tensor_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "shuffle", ")", ":", "\n", "        ", "if", "tensor_dict", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "dataset", "=", "_DeviceBackedDataset", "(", "tensor_dict", ")", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "dataset", ")", ")", "\n", "bs", "=", "self", ".", "batch_size", "if", "self", ".", "batch_size", "is", "not", "None", "else", "len", "(", "indices", ")", "\n", "sampler", "=", "BatchSampler", "(", "shuffle", "=", "shuffle", ",", "indices", "=", "indices", ",", "batch_size", "=", "bs", ")", "\n", "return", "DataLoader", "(", "dataset", ",", "sampler", "=", "sampler", ",", "batch_size", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader": [[435, 437], ["_data_splitting.DeviceBackedDataSplitter._make_dataloader"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._make_dataloader"], ["", "def", "train_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_make_dataloader", "(", "self", ".", "train_tensor_dict", ",", "self", ".", "shuffle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader": [[438, 440], ["_data_splitting.DeviceBackedDataSplitter._make_dataloader"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._make_dataloader"], ["", "def", "test_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_make_dataloader", "(", "self", ".", "test_tensor_dict", ",", "self", ".", "shuffle_test_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader": [[441, 443], ["_data_splitting.DeviceBackedDataSplitter._make_dataloader"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter._make_dataloader"], ["", "def", "val_dataloader", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_make_dataloader", "(", "self", ".", "val_tensor_dict", ",", "self", ".", "shuffle_test_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting._DeviceBackedDataset.__init__": [[446, 448], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "tensor_dict", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "self", ".", "data", "=", "tensor_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting._DeviceBackedDataset.__getitem__": [[449, 455], ["_data_splitting._DeviceBackedDataset.data.items"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ":", "List", "[", "int", "]", ")", "->", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "return_dict", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "self", ".", "data", ".", "items", "(", ")", ":", "\n", "            ", "return_dict", "[", "key", "]", "=", "value", "[", "idx", "]", "\n", "\n", "", "return", "return_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting._DeviceBackedDataset.__len__": [[456, 459], ["_data_splitting._DeviceBackedDataset.data.items", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "for", "_", ",", "value", "in", "self", ".", "data", ".", "items", "(", ")", ":", "\n", "            ", "return", "len", "(", "value", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.validate_data_split": [[17, 54], ["math.ceil", "ValueError", "ValueError", "ValueError", "ValueError", "math.floor"], "function", ["None"], ["def", "validate_data_split", "(", "\n", "n_samples", ":", "int", ",", "train_size", ":", "float", ",", "validation_size", ":", "Optional", "[", "float", "]", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Check data splitting parameters and return n_train and n_val.\n\n    Parameters\n    ----------\n    n_samples\n        Number of samples to split\n    train_size\n        Size of train set. Need to be: 0 < train_size <= 1.\n    validation_size\n        Size of validation set. Need to be 0 <= validation_size < 1\n    \"\"\"", "\n", "if", "train_size", ">", "1.0", "or", "train_size", "<=", "0.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Invalid train_size. Must be: 0 < train_size <= 1\"", ")", "\n", "\n", "", "n_train", "=", "ceil", "(", "train_size", "*", "n_samples", ")", "\n", "\n", "if", "validation_size", "is", "None", ":", "\n", "        ", "n_val", "=", "n_samples", "-", "n_train", "\n", "", "elif", "validation_size", ">=", "1.0", "or", "validation_size", "<", "0.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Invalid validation_size. Must be 0 <= validation_size < 1\"", ")", "\n", "", "elif", "(", "train_size", "+", "validation_size", ")", ">", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"train_size + validation_size must be between 0 and 1\"", ")", "\n", "", "else", ":", "\n", "        ", "n_val", "=", "floor", "(", "n_samples", "*", "validation_size", ")", "\n", "\n", "", "if", "n_train", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"With n_samples={}, train_size={} and validation_size={}, the \"", "\n", "\"resulting train set will be empty. Adjust any of the \"", "\n", "\"aforementioned parameters.\"", ".", "format", "(", "n_samples", ",", "train_size", ",", "validation_size", ")", "\n", ")", "\n", "\n", "", "return", "n_train", ",", "n_val", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.__init__": [[37, 85], ["numpy.asarray", "adata_manager.get_state_registry", "scvi.data._utils.get_anndata_attribute().ravel", "numpy.unique", "_semi_dataloader.SemiSupervisedDataLoader.subsample_labels", "_concat_dataloader.ConcatDataLoader.__init__", "numpy.arange", "len", "scvi.data._utils.get_anndata_attribute", "_semi_dataloader.SemiSupervisedDataLoader.labeled_locs.append", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.subsample_labels", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.data._utils.get_anndata_attribute"], ["def", "__init__", "(", "\n", "self", ",", "\n", "adata_manager", ":", "AnnDataManager", ",", "\n", "n_samples_per_label", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "indices", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "shuffle", ":", "bool", "=", "False", ",", "\n", "batch_size", ":", "int", "=", "128", ",", "\n", "data_and_attributes", ":", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "drop_last", ":", "Union", "[", "bool", ",", "int", "]", "=", "False", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", ":", "\n", "        ", "adata", "=", "adata_manager", ".", "adata", "\n", "if", "indices", "is", "None", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "\n", "\n", "", "self", ".", "indices", "=", "np", ".", "asarray", "(", "indices", ")", "\n", "\n", "if", "len", "(", "self", ".", "indices", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "self", ".", "n_samples_per_label", "=", "n_samples_per_label", "\n", "\n", "labels_state_registry", "=", "adata_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", "\n", ")", "\n", "labels", "=", "get_anndata_attribute", "(", "\n", "adata_manager", ".", "adata", ",", "\n", "adata_manager", ".", "data_registry", ".", "labels", ".", "attr_name", ",", "\n", "labels_state_registry", ".", "original_key", ",", "\n", ")", ".", "ravel", "(", ")", "\n", "\n", "# save a nested list of the indices per labeled category", "\n", "self", ".", "labeled_locs", "=", "[", "]", "\n", "for", "label", "in", "np", ".", "unique", "(", "labels", ")", ":", "\n", "            ", "if", "label", "!=", "labels_state_registry", ".", "unlabeled_category", ":", "\n", "                ", "label_loc_idx", "=", "np", ".", "where", "(", "labels", "[", "indices", "]", "==", "label", ")", "[", "0", "]", "\n", "label_loc", "=", "self", ".", "indices", "[", "label_loc_idx", "]", "\n", "self", ".", "labeled_locs", ".", "append", "(", "label_loc", ")", "\n", "", "", "labelled_idx", "=", "self", ".", "subsample_labels", "(", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "adata_manager", "=", "adata_manager", ",", "\n", "indices_list", "=", "[", "self", ".", "indices", ",", "labelled_idx", "]", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "data_and_attributes", "=", "data_and_attributes", ",", "\n", "drop_last", "=", "drop_last", ",", "\n", "**", "data_loader_kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.resample_labels": [[87, 94], ["_semi_dataloader.SemiSupervisedDataLoader.subsample_labels"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.subsample_labels"], ["", "def", "resample_labels", "(", "self", ")", ":", "\n", "        ", "\"\"\"Resamples the labeled data.\"\"\"", "\n", "labelled_idx", "=", "self", ".", "subsample_labels", "(", ")", "\n", "# self.dataloaders[0] iterates over full_indices", "\n", "# self.dataloaders[1] iterates over the labelled_indices", "\n", "# change the indices of the labelled set", "\n", "self", ".", "dataloaders", "[", "1", "]", ".", "indices", "=", "labelled_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.subsample_labels": [[95, 111], ["numpy.concatenate", "numpy.concatenate", "len", "numpy.concatenate.append", "numpy.random.choice", "numpy.concatenate.append"], "methods", ["None"], ["", "def", "subsample_labels", "(", "self", ")", ":", "\n", "        ", "\"\"\"Subsamples each label class by taking up to n_samples_per_label samples per class.\"\"\"", "\n", "if", "self", ".", "n_samples_per_label", "is", "None", ":", "\n", "            ", "return", "np", ".", "concatenate", "(", "self", ".", "labeled_locs", ")", "\n", "\n", "", "sample_idx", "=", "[", "]", "\n", "for", "loc", "in", "self", ".", "labeled_locs", ":", "\n", "            ", "if", "len", "(", "loc", ")", "<", "self", ".", "n_samples_per_label", ":", "\n", "                ", "sample_idx", ".", "append", "(", "loc", ")", "\n", "", "else", ":", "\n", "                ", "label_subset", "=", "np", ".", "random", ".", "choice", "(", "\n", "loc", ",", "self", ".", "n_samples_per_label", ",", "replace", "=", "False", "\n", ")", "\n", "sample_idx", ".", "append", "(", "label_subset", ")", "\n", "", "", "sample_idx", "=", "np", ".", "concatenate", "(", "sample_idx", ")", "\n", "return", "sample_idx", "\n", "", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_preprocessing.test_poisson_gene_selection": [[7, 26], ["scvi.data.synthetic_iid", "scvi.data.poisson_gene_selection", "scvi.data.synthetic_iid", "scipy.sparse.csr_matrix", "scvi.data.poisson_gene_selection", "numpy.sum", "numpy.sum", "scvi.data.synthetic_iid.var.keys"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.poisson_gene_selection", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.poisson_gene_selection"], ["def", "test_poisson_gene_selection", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "n_top_genes", "=", "10", "\n", "poisson_gene_selection", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "n_top_genes", "=", "n_top_genes", ")", "\n", "keys", "=", "[", "\n", "\"highly_variable\"", ",", "\n", "\"observed_fraction_zeros\"", ",", "\n", "\"expected_fraction_zeros\"", ",", "\n", "\"prob_zero_enriched_nbatches\"", ",", "\n", "\"prob_zero_enrichment\"", ",", "\n", "\"prob_zero_enrichment_rank\"", ",", "\n", "]", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "assert", "key", "in", "adata", ".", "var", ".", "keys", "(", ")", "\n", "", "assert", "np", ".", "sum", "(", "adata", ".", "var", "[", "\"highly_variable\"", "]", ")", "==", "n_top_genes", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "X", "=", "sparse", ".", "csr_matrix", "(", "adata", ".", "X", ")", "\n", "poisson_gene_selection", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "n_top_genes", "=", "n_top_genes", ")", "\n", "assert", "np", ".", "sum", "(", "adata", ".", "var", "[", "\"highly_variable\"", "]", ")", "==", "n_top_genes", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestPbmcDataset.test_populate": [[11, 18], ["scvi.data.pbmc_dataset", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmc_dataset", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_populate", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "scvi", ".", "data", ".", "pbmc_dataset", "(", "\n", "save_path", "=", "\"tests/data/10X\"", ",", "\n", "remove_extracted_data", "=", "True", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "\n", "dataset", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestLoomDataset.test_retina_load_train_one": [[22, 25], ["scvi.data.retina", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.retina", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_retina_load_train_one", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "scvi", ".", "data", ".", "retina", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ",", "batch_key", "=", "\"batch\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestLoomDataset.test_pfc_starmap_load_train_one": [[26, 29], ["scvi.data.prefrontalcortex_starmap", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.prefrontalcortex_starmap", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_pfc_starmap_load_train_one", "(", "self", ")", ":", "\n", "        ", "gene_dataset", "=", "scvi", ".", "data", ".", "prefrontalcortex_starmap", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "gene_dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestLoomDataset.test_fc_dropseq_load_train_one": [[30, 33], ["scvi.data.frontalcortex_dropseq", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.frontalcortex_dropseq", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_fc_dropseq_load_train_one", "(", "self", ")", ":", "\n", "        ", "gene_dataset", "=", "scvi", ".", "data", ".", "frontalcortex_dropseq", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "gene_dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestLoomDataset.test_smfish_load_train_one": [[34, 37], ["scvi.data.smfish", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.smfish", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_smfish_load_train_one", "(", "self", ")", ":", "\n", "        ", "gene_dataset", "=", "scvi", ".", "data", ".", "smfish", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "gene_dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestSeqfishDataset.test_populate": [[40, 43], ["scvi.data.seqfish", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.seqfish", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_populate", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "scvi", ".", "data", ".", "seqfish", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestSeqFishPlusDataset.test_populate": [[46, 52], ["scvi.data.seqfishplus", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.seqfishplus", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_populate", "(", "self", ")", ":", "\n", "        ", "for", "tissue_region", "in", "[", "\"subventricular cortex\"", ",", "\"olfactory bulb\"", "]", ":", "\n", "            ", "dataset", "=", "scvi", ".", "data", ".", "seqfishplus", "(", "\n", "tissue_region", "=", "tissue_region", ",", "save_path", "=", "\"tests/data\"", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestSyntheticDataset.test_iid": [[55, 58], ["scvi.data.synthetic_iid", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_iid", "(", "self", ")", ":", "\n", "        ", "dataset", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", "batch_size", "=", "10", ",", "n_genes", "=", "10", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestCortexDataset.test_populate": [[61, 64], ["scvi.data.cortex", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.cortex", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_populate", "(", "self", ")", ":", "\n", "        ", "adata", "=", "scvi", ".", "data", ".", "cortex", "(", "save_path", "=", "\"tests/data\"", ")", "\n", "unsupervised_training_one_epoch", "(", "adata", ",", "labels_key", "=", "\"cell_type\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestBrainLargeDataset.test_populate": [[67, 76], ["scvi.data.brainlarge_dataset", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.brainlarge_dataset", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_populate", "(", "self", ")", ":", "\n", "        ", "adata", "=", "scvi", ".", "data", ".", "brainlarge_dataset", "(", "\n", "save_path", "=", "\"tests/data\"", ",", "\n", "sample_size_gene_var", "=", "10", ",", "\n", "n_genes_to_keep", "=", "10", ",", "\n", "max_cells_to_keep", "=", "128", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "\n", "adata", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestCsvDataset.test_breast_cancer": [[80, 86], ["scvi.data.breast_cancer_dataset", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.breast_cancer_dataset", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["    ", "def", "test_breast_cancer", "(", "self", ")", ":", "\n", "        ", "adata", "=", "scvi", ".", "data", ".", "breast_cancer_dataset", "(", "\n", "save_path", "=", "\"tests/data\"", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "\n", "adata", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.TestCsvDataset.test_mouse_ob": [[88, 94], ["scvi.data.mouse_ob_dataset", "utils.unsupervised_training_one_epoch"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.mouse_ob_dataset", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_mouse_ob", "(", "self", ")", ":", "\n", "        ", "adata", "=", "scvi", ".", "data", ".", "mouse_ob_dataset", "(", "\n", "save_path", "=", "\"tests/data\"", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "\n", "adata", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.test_download_spleen_lymph_data": [[97, 101], ["scvi.data.spleen_lymph_cite_seq", "scvi.data.spleen_lymph_cite_seq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.spleen_lymph_cite_seq", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.spleen_lymph_cite_seq"], ["", "", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_download_spleen_lymph_data", "(", "save_path", ")", ":", "\n", "    ", "scvi", ".", "data", ".", "spleen_lymph_cite_seq", "(", "save_path", "=", "save_path", ")", "\n", "scvi", ".", "data", ".", "spleen_lymph_cite_seq", "(", "save_path", "=", "save_path", ",", "protein_join", "=", "\"outer\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.test_download_heart_cell_atlas": [[103, 106], ["scvi.data.heart_cell_atlas_subsampled"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.heart_cell_atlas_subsampled"], ["", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_download_heart_cell_atlas", "(", "save_path", ")", ":", "\n", "    ", "scvi", ".", "data", ".", "heart_cell_atlas_subsampled", "(", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_built_in_data.test_download_seurat_v4_pbmc": [[108, 111], ["scvi.data.pbmc_seurat_v4_cite_seq"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmc_seurat_v4_cite_seq"], ["", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_download_seurat_v4_pbmc", "(", "save_path", ")", ":", "\n", "    ", "scvi", ".", "data", ".", "pbmc_seurat_v4_cite_seq", "(", "save_path", "=", "save_path", ",", "mask_protein_batches", "=", "5", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_dataset10X.test_populate_and_train_one_v1": [[12, 20], ["os.path.join", "scvi.data.dataset_10x", "utils.unsupervised_training_one_epoch"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.dataset_10x", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["def", "test_populate_and_train_one_v1", "(", "save_path", ")", ":", "\n", "    ", "sp", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"10X\"", ")", "\n", "dataset", "=", "dataset_10x", "(", "\n", "dataset_name", "=", "\"cd4_t_helper\"", ",", "\n", "remove_extracted_data", "=", "True", ",", "\n", "save_path", "=", "sp", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_dataset10X.test_brain_small": [[22, 30], ["os.path.join", "scvi.data.dataset_10x", "utils.unsupervised_training_one_epoch"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.dataset_10x", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_brain_small", "(", "save_path", ")", ":", "\n", "    ", "sp", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"10X\"", ")", "\n", "dataset", "=", "dataset_10x", "(", "\n", "dataset_name", "=", "\"neuron_9k\"", ",", "\n", "save_path", "=", "sp", ",", "\n", "remove_extracted_data", "=", "True", ",", "\n", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_dataset10X.test_pbmc_cite": [[32, 45], ["os.path.join", "os.path.join", "tarfile.open", "tarfile.open.extractall", "tarfile.open.close", "scanpy.read_10x_mtx", "scvi.data.organize_cite_seq_10x", "utils.unsupervised_training_one_epoch", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._preprocessing.organize_cite_seq_10x", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch"], ["", "def", "test_pbmc_cite", "(", "save_path", ")", ":", "\n", "    ", "file_path", "=", "os", ".", "path", ".", "join", "(", "\n", "save_path", ",", "\"10X/pbmc_10k_protein_v3/filtered_feature_bc_matrix.tar.gz\"", "\n", ")", "\n", "sp", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"10X/pbmc_10k_protein_v3/\"", ")", "\n", "tar", "=", "tarfile", ".", "open", "(", "file_path", ",", "\"r:gz\"", ")", "\n", "tar", ".", "extractall", "(", "path", "=", "sp", ")", "\n", "tar", ".", "close", "(", ")", "\n", "dataset", "=", "sc", ".", "read_10x_mtx", "(", "\n", "os", ".", "path", ".", "join", "(", "sp", ",", "\"filtered_feature_bc_matrix\"", ")", ",", "gex_only", "=", "False", "\n", ")", "\n", "organize_cite_seq_10x", "(", "dataset", ")", "\n", "unsupervised_training_one_epoch", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_dataset10X.test_download_dataset_10x": [[47, 50], ["scvi.data.dataset_10x"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.dataset_10x"], ["", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_download_dataset_10x", "(", "save_path", ")", ":", "\n", "    ", "dataset_10x", "(", "\"hgmm_1k_v3\"", ",", "save_path", "=", "save_path", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata": [[15, 54], ["scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry", "numpy.array().reshape", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry", "numpy.array"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["def", "test_setup_mudata", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "layer", "=", "None", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "categorical_covariate_mod", "=", "\"rna\"", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", "continuous_covariate_mod", "=", "\"rna\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "protein_expression_mod", "=", "\"protein\"", ",", "\n", "protein_expression_layer", "=", "None", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ",", "adata", ".", "X", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ",", "\n", "np", ".", "array", "(", "adata", ".", "obs", "[", "\"_scvi_batch\"", "]", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ")", ",", "\n", "adata", ".", "obs", "[", "[", "\"cont1\"", ",", "\"cont2\"", "]", "]", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", ",", "\n", "adata", ".", "obs", "[", "[", "\"cat1\"", ",", "\"cat2\"", "]", "]", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", "protein_adata", ".", "X", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_view": [[57, 68], ["scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "mudata.MuData", "pytest.raises", "utils.generic_setup_mudata_manager", "pytest.raises", "utils.generic_setup_mudata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager"], ["", "def", "test_setup_mudata_view", "(", ")", ":", "\n", "# test that error is thrown if its a view:", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "[", "1", "]", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_mudata_manager", "(", "mdata", ",", "layer_mod", "=", "\"rna\"", ")", "\n", "\n", "", "adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_mudata_manager", "(", "mdata", "[", "1", "]", ",", "layer_mod", "=", "\"rna\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_unpaired": [[70, 92], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "anndata.AnnData", "anndata.concat", "mudata.MuData.update", "utils.generic_setup_mudata_manager", "pytest.raises", "utils.generic_setup_mudata_manager", "pandas.DataFrame", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.train._metrics.ElboMetric.update", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager"], ["", "", "def", "test_setup_mudata_unpaired", "(", ")", ":", "\n", "# test that error is thrown if unpaired modalities:", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "batch_size", "=", "100", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "protein_expression_mod", "=", "\"protein\"", "\n", ")", "\n", "\n", "# Pad unpaired with zeros", "\n", "", "unpaired_adata", "=", "adata", "[", "mdata", ".", "obsm", "[", "\"rna\"", "]", "&", "~", "(", "mdata", ".", "obsm", "[", "\"protein\"", "]", ")", "]", "\n", "pad_adata", "=", "anndata", ".", "AnnData", "(", "\n", "pd", ".", "DataFrame", "(", "\n", "np", ".", "zeros", "(", "(", "mdata", ".", "n_obs", "-", "protein_adata", ".", "n_obs", ",", "protein_adata", ".", "n_vars", ")", ")", ",", "\n", "index", "=", "unpaired_adata", ".", "obs_names", ",", "\n", ")", "\n", ")", "\n", "mdata", ".", "mod", "[", "\"protein\"", "]", "=", "anndata", ".", "concat", "(", "[", "protein_adata", ",", "pad_adata", "]", ")", "\n", "mdata", ".", "update", "(", ")", "\n", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "protein_expression_mod", "=", "\"protein\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_anndata": [[95, 100], ["scvi.data.synthetic_iid", "pytest.raises", "utils.generic_setup_mudata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager"], ["", "def", "test_setup_mudata_anndata", "(", ")", ":", "\n", "# test that error is thrown if an anndata is passed in:", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "generic_setup_mudata_manager", "(", "adata", ",", "layer_mod", "=", "\"rna\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_layer": [[102, 112], ["scvi.data.synthetic_iid", "numpy.ones_like", "mudata.MuData", "utils.generic_setup_mudata_manager", "numpy.testing.assert_array_equal", "utils.generic_setup_mudata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "", "def", "test_setup_mudata_layer", "(", ")", ":", "\n", "# test that layer is working properly", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "true_x", "=", "adata", ".", "X", "\n", "adata", ".", "layers", "[", "\"X\"", "]", "=", "true_x", "\n", "adata", ".", "X", "=", "np", ".", "ones_like", "(", "adata", ".", "X", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "}", ")", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "layer", "=", "\"X\"", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ",", "true_x", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_default_batch": [[115, 129], ["scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "utils.generic_setup_mudata_manager.get_from_registry", "numpy.zeros", "utils.generic_setup_mudata_manager.get_from_registry", "scvi.data.synthetic_iid.obs[].to_numpy().reshape", "scvi.data.synthetic_iid.obs[].to_numpy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_setup_mudata_default_batch", "(", ")", ":", "\n", "# test that it creates batch if no batch_key is passed", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "}", ")", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ",", "\n", "np", ".", "zeros", "(", "(", "adata", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ",", "\n", "adata", ".", "obs", "[", "\"_scvi_batch\"", "]", ".", "to_numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_setup_mudata_nan_batch": [[132, 140], ["scvi.data.synthetic_iid", "mudata.MuData", "pytest.raises", "utils.generic_setup_mudata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager"], ["", "def", "test_setup_mudata_nan_batch", "(", ")", ":", "\n", "# test error is thrown when categorical obs field contains nans", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"batch\"", "]", "[", ":", "10", "]", "=", "np", ".", "nan", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_save_setup_mudata": [[143, 155], ["scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "os.path.join", "mudata.MuData.write", "mudata.read"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager"], ["", "", "def", "test_save_setup_mudata", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", "}", ")", "\n", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "temp_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test.h5mu\"", ")", "\n", "mdata", ".", "write", "(", "temp_path", ")", "\n", "mudata", ".", "read", "(", "temp_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields": [[157, 178], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.transfer_fields", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields", "(", ")", ":", "\n", "# test transfer_fields function", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "layer", "=", "None", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_mod", "=", "\"protein\"", ",", "\n", "protein_expression_layer", "=", "None", ",", "\n", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "adata1", ".", "obs", "[", "\"_scvi_batch\"", "]", ",", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_view": [[180, 201], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "utils.generic_setup_mudata_manager", "mudata.MuData", "pytest.raises", "utils.generic_setup_mudata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_view", "(", ")", ":", "\n", "# test transfer_fields function", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "[", ":", "50", "]", "\n", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "layer", "=", "None", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_mod", "=", "\"protein\"", ",", "\n", "protein_expression_layer", "=", "None", ",", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_layer": [[203, 231], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.copy", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "numpy.zeros_like", "numpy.ones_like", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.transfer_fields", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "", "def", "test_transfer_fields_layer", "(", ")", ":", "\n", "# test if layer was used initially, again used in transfer setup", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "raw_counts", "=", "adata1", ".", "X", ".", "copy", "(", ")", "\n", "adata1", ".", "layers", "[", "\"raw\"", "]", "=", "raw_counts", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "layers", "[", "\"raw\"", "]", "=", "raw_counts", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "\n", "zeros", "=", "np", ".", "zeros_like", "(", "adata1", ".", "X", ")", "\n", "ones", "=", "np", ".", "ones_like", "(", "adata1", ".", "X", ")", "\n", "adata1", ".", "X", "=", "zeros", "\n", "adata2", ".", "X", "=", "ones", "\n", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "layer", "=", "\"raw\"", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_mod", "=", "\"protein\"", ",", "\n", "protein_expression_layer", "=", "None", ",", "\n", ")", "\n", "adata_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "adata1", ".", "obs", "[", "\"_scvi_batch\"", "]", ",", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_unknown_batch": [[233, 248], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "pytest.raises", "utils.generic_setup_mudata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_unknown_batch", "(", ")", ":", "\n", "# test that an unknown batch throws an error", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "[", "2", "]", "*", "adata2", ".", "n_obs", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_diff_batch_mapping": [[250, 270], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.transfer_fields", "print", "utils.generic_setup_mudata_manager.get_state_registry", "numpy.where"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["", "", "def", "test_transfer_fields_diff_batch_mapping", "(", ")", ":", "\n", "# test that correct mapping was applied", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "[", "\"batch_1\"", "]", "*", "adata2", ".", "n_obs", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "batch_mapping", "=", "adata1_manager", ".", "get_state_registry", "(", "\n", "REGISTRY_KEYS", ".", "BATCH_KEY", "\n", ")", ".", "categorical_mapping", "\n", "print", "(", "batch_mapping", ")", "\n", "correct_batch", "=", "np", ".", "where", "(", "batch_mapping", "==", "\"batch_1\"", ")", "[", "0", "]", "[", "0", "]", "\n", "assert", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", "[", "0", "]", "==", "correct_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_missing_batch": [[272, 287], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "pytest.raises", "utils.generic_setup_mudata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_missing_batch", "(", ")", ":", "\n", "# test that transfer_fields correctly looks for adata.obs['batch']", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "del", "adata2", ".", "obs", "[", "\"batch\"", "]", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_default_batch": [[289, 305], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "", "def", "test_transfer_fields_default_batch", "(", ")", ":", "\n", "# test that transfer_fields assigns same batch to cells", "\n", "# if the original anndata was also same batch", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "protein_adata1", "=", "synthetic_iid", "(", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", ",", "\"protein\"", ":", "protein_adata1", "}", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "del", "adata2", ".", "obs", "[", "\"batch\"", "]", "\n", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "protein_adata2", "=", "synthetic_iid", "(", ")", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata1_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "layer_mod", "=", "\"rna\"", ",", "batch_mod", "=", "\"rna\"", ",", "batch_key", "=", "None", "\n", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "assert", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", "[", "0", "]", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_transfer_fields_covariates": [[307, 340], ["scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "mudata.MuData", "utils.generic_setup_mudata_manager", "scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "mudata.MuData", "utils.generic_setup_mudata_manager.transfer_fields", "utils.generic_setup_mudata_manager.transfer_fields", "adata_manager.transfer_fields.get_state_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["", "def", "test_transfer_fields_covariates", "(", ")", ":", "\n", "    ", "adata1", "=", "synthetic_iid", "(", ")", "\n", "adata1", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "mdata1", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata1", "}", ")", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata1", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "continuous_covariate_mod", "=", "\"rna\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_mod", "=", "\"rna\"", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cat1\"", "]", "=", "0", "\n", "adata2", ".", "obs", "[", "\"cat2\"", "]", "=", "1", "\n", "mdata2", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata2", "}", ")", "\n", "\n", "adata_manager", ".", "transfer_fields", "(", "mdata2", ")", "\n", "\n", "# give it a new category", "\n", "adata2", ".", "obs", "[", "\"cat1\"", "]", "=", "6", "\n", "adata_manager2", "=", "adata_manager", ".", "transfer_fields", "(", "mdata2", ",", "extend_categories", "=", "True", ")", "\n", "assert", "(", "\n", "adata_manager2", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", ".", "mappings", "[", "\"cat1\"", "]", "[", "\n", "-", "1", "\n", "]", "\n", "==", "6", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_data_format": [[343, 395], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "numpy.asfortranarray", "numpy.asfortranarray", "utils.generic_setup_mudata_manager", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "numpy.asfortranarray", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.get_from_registry", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry", "utils.generic_setup_mudata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_data_format", "(", ")", ":", "\n", "# if data was dense np array, check after setup_anndata, data is C_CONTIGUOUS", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "\n", "old_x", "=", "adata", ".", "X", "\n", "old_pro", "=", "protein_adata", ".", "X", "\n", "old_obs", "=", "adata", ".", "obs", "\n", "adata", ".", "X", "=", "np", ".", "asfortranarray", "(", "old_x", ")", "\n", "protein_adata", ".", "X", "=", "np", ".", "asfortranarray", "(", "old_pro", ")", "\n", "assert", "adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "assert", "protein_adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "protein_expression_mod", "=", "\"protein\"", "\n", ")", "\n", "assert", "adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "assert", "protein_adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "\n", "assert", "np", ".", "array_equal", "(", "old_x", ",", "adata", ".", "X", ")", "\n", "assert", "np", ".", "array_equal", "(", "old_pro", ",", "protein_adata", ".", "X", ")", "\n", "assert", "np", ".", "array_equal", "(", "old_obs", ",", "adata", ".", "obs", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "adata", ".", "X", ",", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "\n", "protein_adata", ".", "X", ",", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", ")", "\n", "\n", "# if obsm is dataframe, make it C_CONTIGUOUS if it isnt", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "\n", "pe", "=", "np", ".", "asfortranarray", "(", "protein_adata", ".", "X", ")", "\n", "protein_adata", ".", "X", "=", "pe", "\n", "assert", "protein_adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "layer_mod", "=", "\"rna\"", ",", "protein_expression_mod", "=", "\"protein\"", "\n", ")", "\n", "new_pe", "=", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", "\n", "assert", "new_pe", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "assert", "np", ".", "array_equal", "(", "pe", ",", "new_pe", ")", "\n", "assert", "np", ".", "array_equal", "(", "adata", ".", "X", ",", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "\n", "protein_adata", ".", "X", ",", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", ")", "\n", "assert", "adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "assert", "protein_adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_mudata.test_view_registry": [[397, 412], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "utils.generic_setup_mudata_manager", "utils.generic_setup_mudata_manager.view_registry", "utils.generic_setup_mudata_manager.view_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry"], ["", "def", "test_view_registry", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", ")", "\n", "mdata", "=", "mudata", ".", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "adata_manager", "=", "generic_setup_mudata_manager", "(", "\n", "mdata", ",", "\n", "layer_mod", "=", "\"rna\"", ",", "\n", "layer", "=", "None", ",", "\n", "batch_mod", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_mod", "=", "\"protein\"", ",", "\n", "protein_expression_layer", "=", "None", ",", "\n", ")", "\n", "adata_manager", ".", "view_registry", "(", ")", "\n", "adata_manager", ".", "view_registry", "(", "hide_state_registries", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_basic": [[19, 26], ["utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.transfer_fields", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["def", "test_transfer_fields_basic", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test transfer_fields function", "\n", "    ", "adata2", ".", "X", "=", "adata1", ".", "X", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata1", ".", "obs", "[", "\"_scvi_labels\"", "]", ",", "adata2", ".", "obs", "[", "\"_scvi_labels\"", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_layer_use": [[29, 39], ["numpy.zeros_like", "numpy.ones_like", "utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.transfer_fields", "numpy.testing.assert_array_equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_layer_use", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test if layer was used initially, again used in transfer setup", "\n", "    ", "zeros", "=", "np", ".", "zeros_like", "(", "adata1", ".", "X", ")", "\n", "ones", "=", "np", ".", "ones_like", "(", "adata1", ".", "X", ")", "\n", "adata1", ".", "X", "=", "zeros", "\n", "adata2", ".", "X", "=", "ones", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ",", "layer", "=", "\"raw\"", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata1", ".", "obs", "[", "\"_scvi_labels\"", "]", ",", "adata2", ".", "obs", "[", "\"_scvi_labels\"", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_unknown_batch": [[42, 48], ["utils.generic_setup_adata_manager", "pytest.raises", "utils.generic_setup_adata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_unknown_batch", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that an unknown batch throws an error", "\n", "    ", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "[", "2", "]", "*", "adata2", ".", "n_obs", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_unknown_label": [[50, 56], ["utils.generic_setup_adata_manager", "pytest.raises", "utils.generic_setup_adata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "", "def", "test_transfer_fields_unknown_label", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that an unknown label throws an error", "\n", "    ", "adata2", ".", "obs", "[", "\"labels\"", "]", "=", "[", "\"label_123\"", "]", "*", "adata2", ".", "n_obs", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ",", "labels_key", "=", "\"labels\"", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_correct_mapping": [[58, 66], ["utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.transfer_fields", "utils.generic_setup_adata_manager.get_state_registry", "numpy.where"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["", "", "def", "test_transfer_fields_correct_mapping", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that correct mapping was applied", "\n", "    ", "adata2", ".", "obs", "[", "\"labels\"", "]", "=", "[", "\"label_1\"", "]", "*", "adata2", ".", "n_obs", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ",", "labels_key", "=", "\"labels\"", ")", "\n", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "labels_mapping", "=", "adata1_manager", ".", "get_state_registry", "(", "\"labels\"", ")", ".", "categorical_mapping", "\n", "correct_label", "=", "np", ".", "where", "(", "labels_mapping", "==", "\"label_1\"", ")", "[", "0", "]", "[", "0", "]", "\n", "adata2", ".", "obs", "[", "\"_scvi_labels\"", "]", "[", "0", "]", "==", "correct_label", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_correct_batch": [[68, 74], ["utils.generic_setup_adata_manager", "pytest.raises", "utils.generic_setup_adata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "def", "test_transfer_fields_correct_batch", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that transfer_fields correctly looks for adata.obs['batch']", "\n", "    ", "del", "adata2", ".", "obs", "[", "\"batch\"", "]", "\n", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ")", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_same_batch_and_label": [[76, 84], ["utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.transfer_fields"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "", "def", "test_transfer_fields_same_batch_and_label", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that transfer_fields assigns same batch and label to cells", "\n", "# if the original anndata was also same batch and label", "\n", "    ", "adata1_manager", "=", "generic_setup_adata_manager", "(", "adata1", ")", "\n", "del", "adata2", ".", "obs", "[", "\"batch\"", "]", "\n", "adata1_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "assert", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", "[", "0", "]", "==", "0", "\n", "assert", "adata2", ".", "obs", "[", "\"_scvi_labels\"", "]", "[", "0", "]", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_subset": [[86, 95], ["scvi.model.SCVI.setup_anndata", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_latent_representation", "adata2.obs[].all"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_transfer_fields_subset", "(", "adata1", ",", "adata2", ")", ":", "\n", "# test that if a category mapping is a subset, transfer anndata is called", "\n", "    ", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "\"batch_1\"", "\n", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata2", ",", "batch_key", "=", "\"batch\"", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCVI", "(", "adata1", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "m", ".", "get_latent_representation", "(", "adata2", ")", "\n", "assert", "adata2", ".", "obs", "[", "\"_scvi_batch\"", "]", ".", "all", "(", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_transfer_fields_wrong_kwarg": [[97, 101], ["pytest.raises", "scvi.model.SCVI.setup_anndata"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata"], ["", "def", "test_transfer_fields_wrong_kwarg", "(", "adata", ")", ":", "\n", "# test that error is thrown if an arbitrary kwarg is passed into setup_anndata", "\n", "    ", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch", "=", "\"batch\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_clobber_same_model": [[103, 134], ["scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_anndata_manager", "scvi.model.SCVI._validate_anndata", "scvi.model.SCVI.get_anndata_manager", "scvi.model.SCVI._validate_anndata", "len", "len", "len", "len", "numpy.unique", "numpy.unique", "numpy.unique", "numpy.unique", "m1.get_anndata_manager.get_from_registry", "m1.get_anndata_manager.get_from_registry", "m2.get_anndata_manager.get_from_registry", "m2.get_anndata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "", "def", "test_clobber_same_model", "(", "adata", ")", ":", "\n", "    ", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata", ")", "\n", "m1", "=", "scvi", ".", "model", ".", "SCVI", "(", "adata", ")", "\n", "m1", ".", "train", "(", "1", ")", "\n", "\n", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "m2", "=", "scvi", ".", "model", ".", "SCVI", "(", "adata", ")", "\n", "m2", ".", "train", "(", "1", ")", "\n", "\n", "adata_manager1", "=", "m1", ".", "get_anndata_manager", "(", "adata", ")", "\n", "assert", "adata_manager1", ".", "summary_stats", ".", "n_batch", "==", "1", "\n", "# The underlying data is still 2 since we have not run _validate_anndata yet", "\n", "# to re-transfer the setup of m1.", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager1", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "2", "\n", ")", "\n", "m1", ".", "_validate_anndata", "(", "adata", ")", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager1", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "1", "\n", ")", "\n", "\n", "adata_manager2", "=", "m2", ".", "get_anndata_manager", "(", "adata", ")", "\n", "assert", "adata_manager2", ".", "summary_stats", ".", "n_batch", "==", "2", "\n", "# The underlying data is still 1 since we have not run _validate_anndata yet", "\n", "# to re-transfer the setup of m2.", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager2", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "1", "\n", ")", "\n", "m2", ".", "_validate_anndata", "(", "adata", ")", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager2", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_clobber_different_models": [[137, 172], ["scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.SCVI.get_anndata_manager", "scvi.model.SCVI._validate_anndata", "scvi.model.TOTALVI.get_anndata_manager", "scvi.model.TOTALVI._validate_anndata", "len", "len", "len", "len", "numpy.unique", "numpy.unique", "numpy.unique", "numpy.unique", "m1.get_anndata_manager.get_from_registry", "m1.get_anndata_manager.get_from_registry", "m2.get_anndata_manager.get_from_registry", "m2.get_anndata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_clobber_different_models", "(", "adata", ")", ":", "\n", "    ", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "m1", "=", "scvi", ".", "model", ".", "SCVI", "(", "adata", ")", "\n", "m1", ".", "train", "(", "1", ")", "\n", "\n", "scvi", ".", "model", ".", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "m2", "=", "scvi", ".", "model", ".", "TOTALVI", "(", "adata", ")", "\n", "m2", ".", "train", "(", "1", ")", "\n", "\n", "adata_manager1", "=", "m1", ".", "get_anndata_manager", "(", "adata", ")", "\n", "assert", "adata_manager1", ".", "summary_stats", ".", "n_batch", "==", "2", "\n", "# The underlying data is still 2 since we have not run _validate_anndata yet", "\n", "# to re-transfer the setup of m1.", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager1", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "1", "\n", ")", "\n", "m1", ".", "_validate_anndata", "(", "adata", ")", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager1", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "2", "\n", ")", "\n", "\n", "adata_manager2", "=", "m2", ".", "get_anndata_manager", "(", "adata", ")", "\n", "assert", "adata_manager2", ".", "summary_stats", ".", "n_batch", "==", "1", "\n", "# The underlying data is still 1 since we have not run _validate_anndata yet", "\n", "# to re-transfer the setup of m2.", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager2", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "2", "\n", ")", "\n", "m2", ".", "_validate_anndata", "(", "adata", ")", "\n", "assert", "(", "\n", "len", "(", "np", ".", "unique", "(", "adata_manager2", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ")", ")", "==", "1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_data_format": [[175, 199], ["numpy.asfortranarray", "numpy.asfortranarray", "utils.generic_setup_adata_manager", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "utils.generic_setup_adata_manager.get_from_registry", "utils.generic_setup_adata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_data_format", "(", "adata", ")", ":", "\n", "# if data was dense np array, check after setup_anndata, data is C_CONTIGUOUS", "\n", "    ", "old_x", "=", "adata", ".", "X", "\n", "old_pro", "=", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "\n", "old_obs", "=", "adata", ".", "obs", "\n", "adata", ".", "X", "=", "np", ".", "asfortranarray", "(", "old_x", ")", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "np", ".", "asfortranarray", "(", "old_pro", ")", "\n", "assert", "adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "assert", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "assert", "adata", ".", "X", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "assert", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "\n", "assert", "np", ".", "array_equal", "(", "old_x", ",", "adata", ".", "X", ")", "\n", "assert", "np", ".", "array_equal", "(", "old_pro", ",", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "old_obs", ",", "adata", ".", "obs", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "adata", ".", "X", ",", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_data_format_c_contiguous": [[202, 217], ["numpy.asfortranarray", "pandas.DataFrame", "utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.get_from_registry", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "utils.generic_setup_adata_manager.get_from_registry", "utils.generic_setup_adata_manager.get_from_registry", "adata.obsm[].to_numpy", "adata_manager.get_from_registry.to_numpy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_data_format_c_contiguous", "(", "adata", ")", ":", "\n", "# if obsm is dataframe, make it C_CONTIGUOUS if it isnt", "\n", "    ", "pe", "=", "np", ".", "asfortranarray", "(", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ")", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "pd", ".", "DataFrame", "(", "pe", ",", "index", "=", "adata", ".", "obs_names", ")", "\n", "assert", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "to_numpy", "(", ")", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "False", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "new_pe", "=", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", "\n", "assert", "new_pe", ".", "to_numpy", "(", ")", ".", "flags", "[", "\"C_CONTIGUOUS\"", "]", "is", "True", "\n", "assert", "np", ".", "array_equal", "(", "pe", ",", "new_pe", ")", "\n", "assert", "np", ".", "array_equal", "(", "adata", ".", "X", ",", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ")", "\n", "assert", "np", ".", "array_equal", "(", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata": [[220, 247], ["utils.generic_setup_adata_manager", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "utils.generic_setup_adata_manager.get_from_registry", "numpy.array().reshape", "utils.generic_setup_adata_manager.get_from_registry", "numpy.array().reshape", "utils.generic_setup_adata_manager.get_from_registry", "utils.generic_setup_adata_manager.get_from_registry", "utils.generic_setup_adata_manager.get_state_registry", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["", "def", "test_setup_anndata", "(", "adata", ")", ":", "\n", "# test regular setup", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ",", "\n", "np", ".", "array", "(", "adata", ".", "obs", "[", "\"_scvi_batch\"", "]", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ")", ",", "\n", "np", ".", "array", "(", "adata", ".", "obs", "[", "\"labels\"", "]", ".", "cat", ".", "codes", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ",", "adata", ".", "X", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ",", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ".", "column_names", ",", "\n", "adata", ".", "uns", "[", "\"protein_names\"", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata_view_error": [[250, 254], ["pytest.raises", "utils.generic_setup_adata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_setup_anndata_view_error", "(", "adata", ")", ":", "\n", "# test that error is thrown if its a view:", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_adata_manager", "(", "adata", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata_view_error_df_protein_none": [[256, 271], ["numpy.array().astype", "pandas.DataFrame", "utils.generic_setup_adata_manager", "numpy.testing.assert_array_equal", "numpy.array", "utils.generic_setup_adata_manager.get_state_registry", "random.sample", "range"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "", "def", "test_setup_anndata_view_error_df_protein_none", "(", "adata", ")", ":", "\n", "# If obsm is a df and protein_names_uns_key is None, protein names should be grabbed from column of df", "\n", "    ", "new_protein_names", "=", "np", ".", "array", "(", "random", ".", "sample", "(", "range", "(", "100", ")", ",", "100", ")", ")", ".", "astype", "(", "\"str\"", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "\n", "index", "=", "adata", ".", "obs_names", ",", "\n", "columns", "=", "new_protein_names", ",", "\n", ")", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "df", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ")", ".", "column_names", ",", "\n", "new_protein_names", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata_layer": [[274, 282], ["numpy.ones_like", "utils.generic_setup_adata_manager", "numpy.testing.assert_array_equal", "utils.generic_setup_adata_manager.get_from_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_setup_anndata_layer", "(", "adata", ")", ":", "\n", "# test that layer is working properly", "\n", "    ", "true_x", "=", "adata", ".", "X", "\n", "adata", ".", "layers", "[", "\"X\"", "]", "=", "true_x", "\n", "adata", ".", "X", "=", "np", ".", "ones_like", "(", "adata", ".", "X", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "adata", ",", "layer", "=", "\"X\"", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "X_KEY", ")", ",", "true_x", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndat_create_label_batch": [[285, 299], ["utils.generic_setup_adata_manager", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "utils.generic_setup_adata_manager.get_from_registry", "numpy.zeros", "utils.generic_setup_adata_manager.get_from_registry", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_setup_anndat_create_label_batch", "(", "adata", ")", ":", "\n", "# test that it creates labels and batch if no layers_key is passed", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ")", ",", "\n", "np", ".", "zeros", "(", "(", "adata", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "\n", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "\n", "adata_manager", ".", "get_from_registry", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ")", ",", "\n", "np", ".", "zeros", "(", "(", "adata", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata_nan": [[302, 307], ["pytest.raises", "utils.generic_setup_adata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_setup_anndata_nan", "(", "adata", ")", ":", "\n", "# test error is thrown when categorical obs field contains nans", "\n", "    ", "adata", ".", "obs", "[", "\"batch\"", "]", "[", ":", "10", "]", "=", "np", ".", "nan", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_adata_manager", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_setup_anndata_cat": [[309, 314], ["pytest.raises", "utils.generic_setup_adata_manager"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "", "def", "test_setup_anndata_cat", "(", "adata", ")", ":", "\n", "# test error is thrown when categorical joint obsm field contains nans", "\n", "    ", "adata", ".", "obs", "[", "\"cat1\"", "]", "[", ":", "10", "]", "=", "np", ".", "nan", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "generic_setup_adata_manager", "(", "adata", ",", "categorical_covariate_keys", "=", "[", "\"cat1\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_save_setup_anndata": [[316, 325], ["utils.generic_setup_adata_manager", "adata.write", "os.path.join"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "", "def", "test_save_setup_anndata", "(", "adata", ",", "save_path", ")", ":", "\n", "    ", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "adata", ".", "write", "(", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test.h5ad\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_extra_covariates": [[327, 340], ["scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_from_registry", "pandas.testing.assert_frame_equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_from_registry"], ["", "def", "test_extra_covariates", "(", "adata", ")", ":", "\n", "    ", "scvi", ".", "model", ".", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCVI", "(", "adata", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "df1", "=", "m", ".", "get_from_registry", "(", "adata", ",", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ")", "\n", "df2", "=", "adata", ".", "obs", "[", "[", "\"cont1\"", ",", "\"cont2\"", "]", "]", "\n", "pd", ".", "testing", ".", "assert_frame_equal", "(", "df1", ",", "df2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_extra_covariates_transfer": [[342, 368], ["utils.generic_setup_adata_manager", "scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "utils.generic_setup_adata_manager.transfer_fields", "utils.generic_setup_adata_manager.transfer_fields", "adata_manager.transfer_fields.get_state_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.get_state_registry"], ["", "def", "test_extra_covariates_transfer", "(", "adata", ")", ":", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "bdata", "=", "synthetic_iid", "(", ")", "\n", "bdata", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "bdata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "bdata", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "bdata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "bdata", ".", "obs", "[", "\"cat1\"", "]", "=", "0", "\n", "bdata", ".", "obs", "[", "\"cat2\"", "]", "=", "1", "\n", "\n", "adata_manager", ".", "transfer_fields", "(", "bdata", ")", "\n", "\n", "# give it a new category", "\n", "bdata", ".", "obs", "[", "\"cat1\"", "]", "=", "6", "\n", "bdata_manager", "=", "adata_manager", ".", "transfer_fields", "(", "bdata", ",", "extend_categories", "=", "True", ")", "\n", "assert", "(", "\n", "bdata_manager", ".", "get_state_registry", "(", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ")", ".", "mappings", "[", "\"cat1\"", "]", "[", "\n", "-", "1", "\n", "]", "\n", "==", "6", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_anntorchdataset_getitem": [[371, 400], ["utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "numpy.testing.assert_array_equal", "scvi.dataloaders.AnnTorchDataset", "scvi.dataloaders.AnnTorchDataset", "list", "numpy.testing.assert_array_equal", "list", "utils.generic_setup_adata_manager.data_registry.keys", "list", "bd[].keys", "bd[].keys"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_anntorchdataset_getitem", "(", "adata", ")", ":", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "# check that we can successfully pass in a list of tensors to get", "\n", "tensors_to_get", "=", "[", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ",", "getitem_tensors", "=", "tensors_to_get", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "tensors_to_get", ",", "list", "(", "bd", "[", "1", "]", ".", "keys", "(", ")", ")", ")", "\n", "\n", "# check that we can successfully pass in a dict of tensors and their associated types", "\n", "bd", "=", "AnnTorchDataset", "(", "\n", "adata_manager", ",", "\n", "getitem_tensors", "=", "{", "\n", "REGISTRY_KEYS", ".", "X_KEY", ":", "np", ".", "int", ",", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", ":", "np", ".", "int64", ",", "\n", "}", ",", "\n", ")", "\n", "assert", "bd", "[", "1", "]", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "dtype", "==", "np", ".", "int64", "\n", "assert", "bd", "[", "1", "]", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", ".", "dtype", "==", "np", ".", "int64", "\n", "\n", "# check that by default we get all the registered tensors", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "all_registered_tensors", "=", "list", "(", "adata_manager", ".", "data_registry", ".", "keys", "(", ")", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "all_registered_tensors", ",", "list", "(", "bd", "[", "1", "]", ".", "keys", "(", ")", ")", ")", "\n", "assert", "bd", "[", "1", "]", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", ".", "shape", "[", "0", "]", "==", "bd", ".", "adata_manager", ".", "summary_stats", ".", "n_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_anntorchdataset_numpy": [[402, 408], ["utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "bd[].values", "type"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_anntorchdataset_numpy", "(", "adata", ")", ":", "\n", "# check that AnnTorchDataset returns numpy array", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "adata", ")", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "for", "value", "in", "bd", "[", "1", "]", ".", "values", "(", ")", ":", "\n", "        ", "assert", "type", "(", "value", ")", "==", "np", ".", "ndarray", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_anntorchdataset_numpy_sparse": [[410, 417], ["scipy.csr_matrix", "utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "bd[].values", "type"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "", "def", "test_anntorchdataset_numpy_sparse", "(", "adata", ")", ":", "\n", "# check AnnTorchDataset returns numpy array counts were sparse", "\n", "    ", "adata", ".", "X", "=", "sparse", ".", "csr_matrix", "(", "adata", ".", "X", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "adata", ")", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "for", "value", "in", "bd", "[", "1", "]", ".", "values", "(", ")", ":", "\n", "        ", "assert", "type", "(", "value", ")", "==", "np", ".", "ndarray", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_anntorchdataset_getitem_numpy_sparse": [[419, 430], ["scipy.csr_matrix", "utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "bd[].values", "type"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "", "def", "test_anntorchdataset_getitem_numpy_sparse", "(", "adata", ")", ":", "\n", "# check AnnTorchDataset returns numpy array if pro exp was sparse", "\n", "    ", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "sparse", ".", "csr_matrix", "(", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "\n", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "batch_key", "=", "\"batch\"", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "for", "value", "in", "bd", "[", "1", "]", ".", "values", "(", ")", ":", "\n", "        ", "assert", "type", "(", "value", ")", "==", "np", ".", "ndarray", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_anntorchdataset_getitem_pro_exp": [[432, 443], ["pandas.DataFrame", "utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "bd[].values", "type"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "", "def", "test_anntorchdataset_getitem_pro_exp", "(", "adata", ")", ":", "\n", "# check pro exp is being returned as numpy array even if its DF", "\n", "    ", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", "=", "pd", ".", "DataFrame", "(", "\n", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ",", "index", "=", "adata", ".", "obs_names", "\n", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "batch_key", "=", "\"batch\"", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "for", "value", "in", "bd", "[", "1", "]", ".", "values", "(", ")", ":", "\n", "        ", "assert", "type", "(", "value", ")", "==", "np", ".", "ndarray", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_view_registry": [[445, 457], ["utils.generic_setup_adata_manager", "utils.generic_setup_adata_manager.view_registry", "utils.generic_setup_adata_manager.view_registry"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.view_registry"], ["", "", "def", "test_view_registry", "(", "adata", ")", ":", "\n", "    ", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "adata_manager", ".", "view_registry", "(", ")", "\n", "adata_manager", ".", "view_registry", "(", "hide_state_registries", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_saving": [[459, 476], ["os.path.join", "numpy.random.randint().astype", "numpy.random.randint", "utils.generic_setup_adata_manager", "adata.write", "anndata.read", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_saving", "(", "adata", ",", "save_path", ")", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"tmp_adata.h5ad\"", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "3", ",", "adata", ".", "n_obs", ")", ".", "astype", "(", "str", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "[", "1", "]", "=", "\"asdf\"", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "[", "2", "]", "=", "\"f34\"", "\n", "adata", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "7", ",", "adata", ".", "n_obs", ")", "\n", "\n", "generic_setup_adata_manager", "(", "\n", "adata", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", ")", "\n", "adata", ".", "write", "(", "save_path", ")", "\n", "anndata", ".", "read", "(", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_backed_anndata": [[478, 487], ["os.path.join", "anndata.read_h5ad.write_h5ad", "anndata.read_h5ad", "utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_backed_anndata", "(", "adata", ",", "save_path", ")", ":", "\n", "    ", "path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test_data.h5ad\"", ")", "\n", "adata", ".", "write_h5ad", "(", "path", ")", "\n", "adata", "=", "anndata", ".", "read_h5ad", "(", "path", ",", "backed", "=", "\"r+\"", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "\n", "# test get item", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "bd", "[", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.test_anndata.test_backed_anndata_sparse": [[489, 500], ["scipy.sparse.csr.csr_matrix", "os.path.join", "anndata.read_h5ad.write_h5ad", "anndata.read_h5ad", "utils.generic_setup_adata_manager", "scvi.dataloaders.AnnTorchDataset", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_backed_anndata_sparse", "(", "adata", ",", "save_path", ")", ":", "\n", "# sparse", "\n", "    ", "adata", ".", "X", "=", "csr_matrix", "(", "adata", ".", "X", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test_data2.h5ad\"", ")", "\n", "adata", ".", "write_h5ad", "(", "path", ")", "\n", "adata", "=", "anndata", ".", "read_h5ad", "(", "path", ",", "backed", "=", "\"r+\"", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "\n", "# test get item", "\n", "bd", "=", "AnnTorchDataset", "(", "adata_manager", ")", "\n", "bd", "[", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.unsupervised_training_one_epoch": [[28, 38], ["scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.setup_anndata"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata"], ["def", "unsupervised_training_one_epoch", "(", "\n", "adata", ":", "AnnData", ",", "\n", "run_setup_anndata", ":", "bool", "=", "True", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", ":", "\n", "    ", "if", "run_setup_anndata", ":", "\n", "        ", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "batch_key", ",", "labels_key", "=", "labels_key", ")", "\n", "", "m", "=", "SCVI", "(", "adata", ")", "\n", "m", ".", "train", "(", "1", ",", "train_size", "=", "0.4", ",", "use_gpu", "=", "use_gpu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager": [[40, 80], ["locals", "locals.pop", "scvi.data.fields.CategoricalObsField", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.CategoricalJointObsField", "scvi.data.fields.NumericalJointObsField", "anndata_fields.append", "scvi.data.fields.ProteinObsmField"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields"], ["", "def", "generic_setup_adata_manager", "(", "\n", "adata", ":", "AnnData", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "protein_expression_obsm_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "protein_names_uns_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "AnnDataManager", ":", "\n", "    ", "setup_args", "=", "locals", "(", ")", "\n", "setup_args", ".", "pop", "(", "\"adata\"", ")", "\n", "setup_method_args", "=", "{", "_MODEL_NAME_KEY", ":", "\"TestModel\"", ",", "_SETUP_ARGS_KEY", ":", "setup_args", "}", "\n", "\n", "batch_field", "=", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", "\n", "anndata_fields", "=", "[", "\n", "batch_field", ",", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "layer", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ")", ",", "\n", "CategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "categorical_covariate_keys", "\n", ")", ",", "\n", "NumericalJointObsField", "(", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "continuous_covariate_keys", ")", ",", "\n", "]", "\n", "if", "protein_expression_obsm_key", "is", "not", "None", ":", "\n", "        ", "anndata_fields", ".", "append", "(", "\n", "ProteinObsmField", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ",", "\n", "protein_expression_obsm_key", ",", "\n", "use_batch_mask", "=", "True", ",", "\n", "batch_field", "=", "batch_field", ",", "\n", "colnames_uns_key", "=", "protein_names_uns_key", ",", "\n", "is_count_data", "=", "True", ",", "\n", ")", "\n", ")", "\n", "", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ")", "\n", "return", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.scanvi_setup_adata_manager": [[82, 102], ["locals", "locals.pop", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.LabelsWithUnlabeledObsField"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields"], ["", "def", "scanvi_setup_adata_manager", "(", "\n", "adata", ":", "AnnData", ",", "\n", "unlabeled_category", ":", "str", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "labels_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "AnnDataManager", ":", "\n", "    ", "setup_args", "=", "locals", "(", ")", "\n", "setup_args", ".", "pop", "(", "\"adata\"", ")", "\n", "setup_method_args", "=", "{", "_MODEL_NAME_KEY", ":", "\"TestModel\"", ",", "_SETUP_ARGS_KEY", ":", "setup_args", "}", "\n", "anndata_fields", "=", "[", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ")", ",", "\n", "LabelsWithUnlabeledObsField", "(", "\n", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "labels_key", ",", "unlabeled_category", "\n", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ")", "\n", "return", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_mudata_manager": [[104, 160], ["locals", "locals.pop", "scvi.data.fields.MuDataCategoricalObsField", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "scvi.data.fields.MuDataLayerField", "scvi.data.fields.MuDataCategoricalJointObsField", "scvi.data.fields.MuDataNumericalJointObsField", "anndata_fields.append", "scvi.data.fields.MuDataProteinLayerField"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields"], ["", "def", "generic_setup_mudata_manager", "(", "\n", "mdata", ":", "MuData", ",", "\n", "layer_mod", ",", "\n", "layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_mod", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "batch_key", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_mod", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "categorical_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "continuous_covariate_mod", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "continuous_covariate_keys", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "protein_expression_mod", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "protein_expression_layer", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "AnnDataManager", ":", "\n", "    ", "setup_args", "=", "locals", "(", ")", "\n", "setup_args", ".", "pop", "(", "\"mdata\"", ")", "\n", "setup_method_args", "=", "{", "_MODEL_NAME_KEY", ":", "\"TestModel\"", ",", "_SETUP_ARGS_KEY", ":", "setup_args", "}", "\n", "\n", "batch_field", "=", "MuDataCategoricalObsField", "(", "\n", "REGISTRY_KEYS", ".", "BATCH_KEY", ",", "batch_key", ",", "mod_key", "=", "batch_mod", "\n", ")", "\n", "anndata_fields", "=", "[", "\n", "MuDataLayerField", "(", "\n", "REGISTRY_KEYS", ".", "X_KEY", ",", "\n", "layer", ",", "\n", "mod_key", "=", "layer_mod", ",", "\n", "is_count_data", "=", "True", ",", "\n", "mod_required", "=", "True", ",", "\n", ")", ",", "\n", "batch_field", ",", "\n", "MuDataCategoricalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CAT_COVS_KEY", ",", "\n", "categorical_covariate_keys", ",", "\n", "mod_key", "=", "categorical_covariate_mod", ",", "\n", ")", ",", "\n", "MuDataNumericalJointObsField", "(", "\n", "REGISTRY_KEYS", ".", "CONT_COVS_KEY", ",", "\n", "continuous_covariate_keys", ",", "\n", "mod_key", "=", "continuous_covariate_mod", ",", "\n", ")", ",", "\n", "]", "\n", "if", "protein_expression_mod", "is", "not", "None", ":", "\n", "        ", "anndata_fields", ".", "append", "(", "\n", "MuDataProteinLayerField", "(", "\n", "REGISTRY_KEYS", ".", "PROTEIN_EXP_KEY", ",", "\n", "protein_expression_layer", ",", "\n", "mod_key", "=", "protein_expression_mod", ",", "\n", "mod_required", "=", "True", ",", "\n", "use_batch_mask", "=", "True", ",", "\n", "batch_field", "=", "batch_field", ",", "\n", ")", "\n", ")", "\n", "", "mdata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "mdata_manager", ".", "register_fields", "(", "mdata", ")", "\n", "return", "mdata_manager", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.conftest.adata": [[7, 18], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.copy", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid"], ["def", "pytest_addoption", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "addoption", "(", "\n", "\"--model_fit\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "default", "=", "False", ",", "\n", "dest", "=", "\"model_fit\"", ",", "\n", "help", "=", "\"Option to run full training model for test_model_fit\"", ",", "\n", ")", "\n", "parser", ".", "addoption", "(", "\n", "\"--internet-tests\"", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "default", "=", "False", ",", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update": [[11, 16], ["model._make_data_loader", "scvi_loss.loss.backward", "model.module", "range"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._make_data_loader", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainingplans.JaxTrainingPlan.backward", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module"], ["def", "single_pass_for_online_update", "(", "model", ")", ":", "\n", "    ", "dl", "=", "model", ".", "_make_data_loader", "(", "model", ".", "adata", ",", "indices", "=", "range", "(", "0", ",", "10", ")", ")", "\n", "for", "tensors", "in", "dl", ":", "\n", "        ", "_", ",", "_", ",", "scvi_loss", "=", "model", ".", "module", "(", "tensors", ")", "\n", "", "scvi_loss", ".", "loss", ".", "backward", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_data_prep": [[18, 52], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "os.path.join", "scvi.model.SCVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.SCVI.prepare_query_anndata", "scvi.model.SCVI.load_query_data", "scvi.model.SCVI.prepare_query_anndata", "scvi.model.SCVI.load_query_data", "scvi.data.synthetic_iid", "scvi.model.SCVI.prepare_query_anndata", "numpy.testing.assert_equal", "scvi.model.SCVI.load_query_data", "scvi.model.SCVI.prepare_query_anndata", "scvi.model.SCVI.load_query_data", "scvi.data.synthetic_iid.var_names[].to_list", "numpy.sum", "scvi.data.synthetic_iid.var_names[].to_numpy", "scvi.data.synthetic_iid.var_names[].to_numpy", "range"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data"], ["", "def", "test_data_prep", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# adata2 has more genes and a perfect subset of adata1", "\n", "adata2", "=", "synthetic_iid", "(", "n_genes", "=", "110", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "SCVI", ".", "prepare_query_anndata", "(", "adata2", ",", "dir_path", ")", "\n", "SCVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ")", "\n", "\n", "adata3", "=", "SCVI", ".", "prepare_query_anndata", "(", "adata2", ",", "dir_path", ",", "inplace", "=", "False", ")", "\n", "SCVI", ".", "load_query_data", "(", "adata3", ",", "dir_path", ")", "\n", "\n", "# adata4 has more genes and missing 10 genes from adata1", "\n", "adata4", "=", "synthetic_iid", "(", "n_genes", "=", "110", ")", "\n", "new_var_names_init", "=", "[", "f\"Random {i}\"", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "new_var_names", "=", "new_var_names_init", "+", "adata4", ".", "var_names", "[", "10", ":", "]", ".", "to_list", "(", ")", "\n", "adata4", ".", "var_names", "=", "new_var_names", "\n", "\n", "SCVI", ".", "prepare_query_anndata", "(", "adata4", ",", "dir_path", ")", "\n", "# should be padded 0s", "\n", "assert", "np", ".", "sum", "(", "adata4", "[", ":", ",", "adata4", ".", "var_names", "[", ":", "10", "]", "]", ".", "X", ")", "==", "0", "\n", "np", ".", "testing", ".", "assert_equal", "(", "\n", "adata4", ".", "var_names", "[", ":", "10", "]", ".", "to_numpy", "(", ")", ",", "adata1", ".", "var_names", "[", ":", "10", "]", ".", "to_numpy", "(", ")", "\n", ")", "\n", "SCVI", ".", "load_query_data", "(", "adata4", ",", "dir_path", ")", "\n", "\n", "adata5", "=", "SCVI", ".", "prepare_query_anndata", "(", "adata4", ",", "dir_path", ",", "inplace", "=", "False", ")", "\n", "SCVI", ".", "load_query_data", "(", "adata5", ",", "dir_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_data_prep_layer": [[54, 78], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.copy", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "os.path.join", "scvi.model.SCVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.X.copy", "scvi.model.SCVI.prepare_query_anndata", "numpy.testing.assert_equal", "scvi.model.SCVI.load_query_data", "scvi.data.synthetic_iid.var_names[].to_list", "numpy.sum", "scvi.data.synthetic_iid.var_names[].to_numpy", "scvi.data.synthetic_iid.var_names[].to_numpy", "range"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.prepare_query_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data"], ["", "def", "test_data_prep_layer", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "adata1", ".", "layers", "[", "\"counts\"", "]", "=", "adata1", ".", "X", ".", "copy", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "layer", "=", "\"counts\"", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# adata4 has more genes and missing 10 genes from adata1", "\n", "adata4", "=", "synthetic_iid", "(", "n_genes", "=", "110", ")", "\n", "adata4", ".", "layers", "[", "\"counts\"", "]", "=", "adata4", ".", "X", ".", "copy", "(", ")", "\n", "new_var_names_init", "=", "[", "f\"Random {i}\"", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "new_var_names", "=", "new_var_names_init", "+", "adata4", ".", "var_names", "[", "10", ":", "]", ".", "to_list", "(", ")", "\n", "adata4", ".", "var_names", "=", "new_var_names", "\n", "\n", "SCVI", ".", "prepare_query_anndata", "(", "adata4", ",", "dir_path", ")", "\n", "# should be padded 0s", "\n", "assert", "np", ".", "sum", "(", "adata4", "[", ":", ",", "adata4", ".", "var_names", "[", ":", "10", "]", "]", ".", "layers", "[", "\"counts\"", "]", ")", "==", "0", "\n", "np", ".", "testing", ".", "assert_equal", "(", "\n", "adata4", ".", "var_names", "[", ":", "10", "]", ".", "to_numpy", "(", ")", ",", "adata1", ".", "var_names", "[", ":", "10", "]", ".", "to_numpy", "(", ")", "\n", ")", "\n", "SCVI", ".", "load_query_data", "(", "adata4", ",", "dir_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_scvi_online_update": [[80, 185], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "os.path.join", "scvi.model.SCVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.SCVI.load_query_data", "SCVI.load_query_data.train", "SCVI.load_query_data.get_latent_representation", "numpy.testing.assert_equal", "test_scarches.single_pass_for_online_update", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "os.path.join", "scvi.model.SCVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.SCVI.load_query_data", "SCVI.load_query_data.train", "SCVI.load_query_data.get_latent_representation", "test_scarches.single_pass_for_online_update", "[].weight.grad.cpu().numpy", "[].weight.grad.cpu().numpy", "scvi.model.SCVI.load_query_data", "SCVI.load_query_data.train", "SCVI.load_query_data.get_latent_representation", "test_scarches.single_pass_for_online_update", "[].weight.grad.cpu().numpy", "[].weight.grad.cpu().numpy", "scvi.model.SCVI.load_query_data", "SCVI.load_query_data.train", "SCVI.load_query_data.get_latent_representation", "[].weight.detach().cpu().numpy", "[].weight.detach().cpu().numpy", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "dict", "dict", "[].weight.grad.cpu", "[].weight.grad.cpu", "[].weight.grad.cpu", "[].weight.grad.cpu", "[].weight.detach().cpu", "[].weight.detach().cpu", "[].weight.grad.cpu().numpy", "[].weight.detach", "[].weight.detach", "[].weight.grad.cpu"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_scvi_online_update", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# also test subset var option", "\n", "adata2", "=", "synthetic_iid", "(", "n_genes", "=", "110", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "SCVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "inplace_subset_query_vars", "=", "True", ")", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ",", "plan_kwargs", "=", "dict", "(", "weight_decay", "=", "0.0", ")", ")", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "\n", "# encoder linear layer equal", "\n", "one", "=", "(", "\n", "model", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "two", "=", "(", "\n", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "one", ",", "two", ")", "\n", "single_pass_for_online_update", "(", "model2", ")", "\n", "assert", "(", "\n", "np", ".", "sum", "(", "\n", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "grad", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "# dispersion", "\n", "assert", "model2", ".", "module", ".", "px_r", ".", "requires_grad", "is", "False", "\n", "# library encoder linear layer", "\n", "assert", "model2", ".", "module", ".", "l_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "requires_grad", "is", "True", "\n", "# 5 for n_latent, 4 for batches", "\n", "assert", "model2", ".", "module", ".", "decoder", ".", "px_decoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "shape", "[", "1", "]", "==", "9", "\n", "\n", "# test options", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "\n", "adata1", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "n_layers", "=", "2", ",", "\n", "encode_covariates", "=", "True", ",", "\n", "use_batch_norm", "=", "\"encoder\"", ",", "\n", "use_layer_norm", "=", "\"none\"", ",", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "SCVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_expression", "=", "True", ")", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ",", "plan_kwargs", "=", "dict", "(", "weight_decay", "=", "0.0", ")", ")", "\n", "# deactivate no grad decorator", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "# pytorch lightning zeros the grad, so this will get a grad to inspect", "\n", "single_pass_for_online_update", "(", "model2", ")", "\n", "grad", "=", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# expression part has zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "==", "0", "\n", "# categorical part has non-zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", "-", "4", ":", "]", ")", "!=", "0", "\n", "grad", "=", "model2", ".", "module", ".", "decoder", ".", "px_decoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# linear layer weight in decoder layer has non-zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "==", "0", "\n", "\n", "# do not freeze expression", "\n", "model3", "=", "SCVI", ".", "load_query_data", "(", "\n", "adata2", ",", "\n", "dir_path", ",", "\n", "freeze_expression", "=", "False", ",", "\n", "freeze_batchnorm_encoder", "=", "True", ",", "\n", "freeze_decoder_first_layer", "=", "False", ",", "\n", ")", "\n", "model3", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model3", ".", "get_latent_representation", "(", ")", "\n", "assert", "model3", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "1", "]", ".", "momentum", "==", "0", "\n", "# batch norm weight in encoder layer", "\n", "assert", "model3", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "1", "]", ".", "weight", ".", "requires_grad", "is", "False", "\n", "single_pass_for_online_update", "(", "model3", ")", "\n", "grad", "=", "model3", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# linear layer weight in encoder layer has non-zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "!=", "0", "\n", "grad", "=", "model3", ".", "module", ".", "decoder", ".", "px_decoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# linear layer weight in decoder layer has non-zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "!=", "0", "\n", "\n", "# do not freeze batchnorm", "\n", "model3", "=", "SCVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "False", ")", "\n", "model3", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model3", ".", "get_latent_representation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_scvi_library_size_update": [[187, 221], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "os.path.join", "scvi.model.SCVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.SCVI.load_query_data", "SCVI.load_query_data.module.library_log_means[].equal", "SCVI.load_query_data.module.library_log_vars[].equal", "getattr", "scvi.model.SCVI.module.library_log_means.count_nonzero().item", "getattr", "getattr", "SCVI.load_query_data.module.library_log_means.count_nonzero().item", "getattr", "scvi.model.SCVI.module.library_log_means.count_nonzero", "SCVI.load_query_data.module.library_log_means.count_nonzero"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data"], ["", "def", "test_scvi_library_size_update", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "False", ")", "\n", "\n", "assert", "(", "\n", "getattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ",", "None", ")", "is", "not", "None", "\n", "and", "model", ".", "module", ".", "library_log_means", ".", "shape", "==", "(", "1", ",", "2", ")", "\n", "and", "model", ".", "module", ".", "library_log_means", ".", "count_nonzero", "(", ")", ".", "item", "(", ")", "==", "2", "\n", ")", "\n", "assert", "getattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", ",", "None", "\n", ")", "is", "not", "None", "and", "model", ".", "module", ".", "library_log_vars", ".", "shape", "==", "(", "1", ",", "2", ")", "\n", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# also test subset var option", "\n", "adata2", "=", "synthetic_iid", "(", "n_genes", "=", "110", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "SCVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "inplace_subset_query_vars", "=", "True", ")", "\n", "assert", "(", "\n", "getattr", "(", "model2", ".", "module", ",", "\"library_log_means\"", ",", "None", ")", "is", "not", "None", "\n", "and", "model2", ".", "module", ".", "library_log_means", ".", "shape", "==", "(", "1", ",", "4", ")", "\n", "and", "model2", ".", "module", ".", "library_log_means", "[", ":", ",", ":", "2", "]", ".", "equal", "(", "model", ".", "module", ".", "library_log_means", ")", "\n", "and", "model2", ".", "module", ".", "library_log_means", ".", "count_nonzero", "(", ")", ".", "item", "(", ")", "==", "4", "\n", ")", "\n", "assert", "(", "\n", "getattr", "(", "model2", ".", "module", ",", "\"library_log_vars\"", ",", "None", ")", "is", "not", "None", "\n", "and", "model2", ".", "module", ".", "library_log_vars", ".", "shape", "==", "(", "1", ",", "4", ")", "\n", "and", "model2", ".", "module", ".", "library_log_vars", "[", ":", ",", ":", "2", "]", ".", "equal", "(", "model", ".", "module", ".", "library_log_vars", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_scanvi_online_update": [[224, 396], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.labels.to_numpy", "pandas.Categorical", "numpy.random.normal", "numpy.random.normal", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCANVI.train", "os.path.join", "scvi.model.SCANVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "numpy.random.normal", "numpy.random.normal", "scvi.model.SCANVI.load_query_data", "scvi.model.SCANVI.train", "scvi.model.SCANVI.get_latent_representation", "scvi.model.SCANVI.predict", "scvi.model.SCANVI.load_query_data", "scvi.model.SCANVI.train", "scvi.model.SCANVI.get_latent_representation", "scvi.model.SCANVI.predict", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "numpy.random.normal", "numpy.random.normal", "scvi.model.SCANVI.load_query_data", "scvi.model.SCANVI.train", "scvi.model.SCANVI.get_latent_representation", "scvi.model.SCANVI.predict", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.labels.to_numpy", "pandas.Categorical", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCANVI.train", "os.path.join", "scvi.model.SCANVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.labels.to_numpy", "pandas.Categorical", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCANVI.train", "os.path.join", "scvi.model.SCANVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.data.synthetic_iid.obs.labels.to_numpy", "pandas.Categorical", "scvi.model.SCANVI.load_query_data", "numpy.arange", "SCANVI.load_query_data.train", "SCANVI.load_query_data.get_latent_representation", "SCANVI.load_query_data.predict", "[].weight.detach().cpu().numpy", "[].weight.detach().cpu().numpy", "numpy.testing.assert_allclose", "scvi.model.SCANVI.load_query_data", "numpy.arange", "SCANVI.load_query_data.train", "[].weight.detach().cpu().numpy", "[].weight.detach().cpu().numpy", "scvi.data.synthetic_iid", "a[].copy", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCANVI.train", "scvi.model.SCANVI.save", "a[].copy", "scvi.data.synthetic_iid", "scvi.model.SCANVI.load_query_data", "SCANVI.load.save", "scvi.model.SCANVI.load", "SCANVI.load.predict", "SCANVI.load.get_elbo", "pytest.raises", "scvi.model.SCANVI.load_query_data", "pytest.raises", "numpy.testing.assert_allclose", "dict", "[].weight.detach().cpu", "[].weight.detach().cpu", "[].weight.detach().cpu", "[].weight.detach().cpu", "[].weight.detach", "[].weight.detach", "[].weight.detach", "[].weight.detach"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data"], ["", "def", "test_scanvi_online_update", "(", "save_path", ")", ":", "\n", "# ref has semi-observed labels", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "new_labels", "=", "adata1", ".", "obs", ".", "labels", ".", "to_numpy", "(", ")", "\n", "new_labels", "[", "0", "]", "=", "\"Unknown\"", "\n", "adata1", ".", "obs", "[", "\"labels\"", "]", "=", "pd", ".", "Categorical", "(", "new_labels", ")", "\n", "adata1", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "SCANVI", ".", "setup_anndata", "(", "\n", "adata1", ",", "\n", "\"labels\"", ",", "\n", "\"Unknown\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", ")", "\n", "model", "=", "SCANVI", "(", "\n", "adata1", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "encode_covariates", "=", "True", ",", "\n", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# query has all missing labels", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "adata2", ".", "obs", "[", "\"labels\"", "]", "=", "\"Unknown\"", "\n", "adata2", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "model", "=", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "True", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "predict", "(", ")", "\n", "\n", "# query has all missing labels and no labels key", "\n", "del", "adata2", ".", "obs", "[", "\"labels\"", "]", "\n", "\n", "model", "=", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "True", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "predict", "(", ")", "\n", "\n", "# query has no missing labels", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "adata2", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "model", "=", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "True", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "predict", "(", ")", "\n", "\n", "# Test error on extra categoricals", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "new_labels", "=", "adata1", ".", "obs", ".", "labels", ".", "to_numpy", "(", ")", "\n", "new_labels", "[", "0", "]", "=", "\"Unknown\"", "\n", "adata1", ".", "obs", "[", "\"labels\"", "]", "=", "pd", ".", "Categorical", "(", "new_labels", ")", "\n", "adata1", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata1", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata1", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "SCANVI", ".", "setup_anndata", "(", "\n", "adata1", ",", "\n", "\"labels\"", ",", "\n", "\"Unknown\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "model", "=", "SCANVI", "(", "\n", "adata1", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "encode_covariates", "=", "True", ",", "\n", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "adata2", ".", "obs", "[", "\"labels\"", "]", "=", "\"Unknown\"", "\n", "adata2", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata2", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "True", ")", "\n", "\n", "# ref has fully-observed labels", "\n", "", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "new_labels", "=", "adata1", ".", "obs", ".", "labels", ".", "to_numpy", "(", ")", "\n", "adata1", ".", "obs", "[", "\"labels\"", "]", "=", "pd", ".", "Categorical", "(", "new_labels", ")", "\n", "SCANVI", ".", "setup_anndata", "(", "adata1", ",", "\"labels\"", ",", "\"Unknown\"", ",", "batch_key", "=", "\"batch\"", ")", "\n", "model", "=", "SCANVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ",", "encode_covariates", "=", "True", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# query has one new label", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "new_labels", "=", "adata2", ".", "obs", ".", "labels", ".", "to_numpy", "(", ")", "\n", "new_labels", "[", "0", "]", "=", "\"Unknown\"", "\n", "adata2", ".", "obs", "[", "\"labels\"", "]", "=", "pd", ".", "Categorical", "(", "new_labels", ")", "\n", "\n", "model2", "=", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_batchnorm_encoder", "=", "True", ")", "\n", "model2", ".", "_unlabeled_indices", "=", "np", ".", "arange", "(", "adata2", ".", "n_obs", ")", "\n", "model2", ".", "_labeled_indices", "=", "[", "]", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ",", "plan_kwargs", "=", "dict", "(", "weight_decay", "=", "0.0", ")", ")", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "model2", ".", "predict", "(", ")", "\n", "\n", "# test classifier frozen", "\n", "class_query_weight", "=", "(", "\n", "model2", ".", "module", ".", "classifier", ".", "classifier", "[", "0", "]", "\n", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "\n", ")", "\n", "class_ref_weight", "=", "(", "\n", "model", ".", "module", ".", "classifier", ".", "classifier", "[", "0", "]", "\n", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "\n", ")", "\n", "# weight decay makes difference", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "class_query_weight", ",", "class_ref_weight", ",", "atol", "=", "1e-07", ")", "\n", "\n", "# test classifier unfrozen", "\n", "model2", "=", "SCANVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_classifier", "=", "False", ")", "\n", "model2", ".", "_unlabeled_indices", "=", "np", ".", "arange", "(", "adata2", ".", "n_obs", ")", "\n", "model2", ".", "_labeled_indices", "=", "[", "]", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "class_query_weight", "=", "(", "\n", "model2", ".", "module", ".", "classifier", ".", "classifier", "[", "0", "]", "\n", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "\n", ")", "\n", "class_ref_weight", "=", "(", "\n", "model", ".", "module", ".", "classifier", ".", "classifier", "[", "0", "]", "\n", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "np", ".", "testing", ".", "assert_allclose", "(", "class_query_weight", ",", "class_ref_weight", ",", "atol", "=", "1e-07", ")", "\n", "\n", "# test saving and loading of online scanvi", "\n", "", "a", "=", "synthetic_iid", "(", ")", "\n", "ref", "=", "a", "[", "a", ".", "obs", "[", "\"labels\"", "]", "!=", "\"label_2\"", "]", ".", "copy", "(", ")", "# only has labels 0 and 1", "\n", "SCANVI", ".", "setup_anndata", "(", "ref", ",", "\"labels\"", ",", "\"label_2\"", ",", "batch_key", "=", "\"batch\"", ")", "\n", "m", "=", "SCANVI", "(", "ref", ")", "\n", "m", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "m", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ")", "\n", "query", "=", "a", "[", "a", ".", "obs", "[", "\"labels\"", "]", "!=", "\"label_0\"", "]", ".", "copy", "(", ")", "\n", "query", "=", "synthetic_iid", "(", ")", "# has labels 0 and 2. 2 is unknown", "\n", "m_q", "=", "SCANVI", ".", "load_query_data", "(", "query", ",", "save_path", ")", "\n", "m_q", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ")", "\n", "m_q", "=", "SCANVI", ".", "load", "(", "save_path", ",", "adata", "=", "query", ")", "\n", "m_q", ".", "predict", "(", ")", "\n", "m_q", ".", "get_elbo", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_totalvi_online_update": [[398, 432], ["scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "os.path.join", "scvi.model.TOTALVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.TOTALVI.load_query_data", "TOTALVI.load_query_data.train", "TOTALVI.load_query_data.get_latent_representation", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.TOTALVI.load_query_data", "TOTALVI.load_query_data.train", "TOTALVI.load_query_data.get_latent_representation"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_totalvi_online_update", "(", "save_path", ")", ":", "\n", "# basic case", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata1", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ",", "use_batch_norm", "=", "\"decoder\"", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "TOTALVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ")", "\n", "assert", "model2", ".", "module", ".", "background_pro_alpha", ".", "requires_grad", "is", "True", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "\n", "# batch 3 has no proteins", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "adata2", ".", "obsm", "[", "\"protein_expression\"", "]", "[", "adata2", ".", "obs", ".", "batch", "==", "\"batch_3\"", "]", "=", "0", "\n", "\n", "# load from model in memory", "\n", "model3", "=", "TOTALVI", ".", "load_query_data", "(", "adata2", ",", "model", ")", "\n", "model3", ".", "module", ".", "protein_batch_mask", "[", "2", "]", "\n", "model3", ".", "module", ".", "protein_batch_mask", "[", "3", "]", "\n", "model3", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "model3", ".", "get_latent_representation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.test_peakvi_online_update": [[434, 517], ["scvi.data.synthetic_iid", "scvi.model.PEAKVI.setup_anndata", "scvi.model.PEAKVI", "scvi.model.PEAKVI.train", "os.path.join", "scvi.model.PEAKVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.PEAKVI.load_query_data", "PEAKVI.load_query_data.train", "PEAKVI.load_query_data.get_latent_representation", "numpy.testing.assert_equal", "scvi.data.synthetic_iid", "scvi.model.PEAKVI.setup_anndata", "scvi.model.PEAKVI", "scvi.model.PEAKVI.train", "os.path.join", "scvi.model.PEAKVI.save", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.PEAKVI.load_query_data", "PEAKVI.load_query_data.train", "PEAKVI.load_query_data.get_latent_representation", "test_scarches.single_pass_for_online_update", "[].weight.grad.cpu().numpy", "scvi.model.PEAKVI.load_query_data", "PEAKVI.load_query_data.train", "PEAKVI.load_query_data.get_latent_representation", "test_scarches.single_pass_for_online_update", "[].weight.grad.cpu().numpy", "[].weight.grad.cpu().numpy", "[].weight.detach().cpu().numpy", "[].weight.detach().cpu().numpy", "numpy.sum", "numpy.sum", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.count_nonzero", "[].weight.grad.cpu", "[].weight.grad.cpu", "[].weight.grad.cpu", "[].weight.detach().cpu", "[].weight.detach().cpu", "[].weight.grad.cpu().numpy", "[].weight.detach", "[].weight.detach", "[].weight.grad.cpu"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update", "home.repos.pwc.inspect_result.YosefLab_scVI.base._archesmixin.ArchesMixin.load_query_data", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_scarches.single_pass_for_online_update"], ["", "def", "test_peakvi_online_update", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "PEAKVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "PEAKVI", "(", "adata1", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "save_best", "=", "False", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "# also test subset var option", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "PEAKVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ")", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ",", "weight_decay", "=", "0.0", ",", "save_best", "=", "False", ")", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "\n", "# encoder linear layer equal for peak features", "\n", "one", "=", "(", "\n", "model", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "two", "=", "(", "\n", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "detach", "(", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "one", ",", "two", ")", "\n", "assert", "(", "\n", "np", ".", "sum", "(", "\n", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", "\n", ".", "weight", ".", "grad", ".", "cpu", "(", ")", "\n", ".", "numpy", "(", ")", "[", ":", ",", ":", "adata1", ".", "shape", "[", "1", "]", "]", "\n", ")", "\n", "==", "0", "\n", ")", "\n", "\n", "# test options", "\n", "adata1", "=", "synthetic_iid", "(", ")", "\n", "PEAKVI", ".", "setup_anndata", "(", "adata1", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "PEAKVI", "(", "\n", "adata1", ",", "\n", "n_latent", "=", "n_latent", ",", "\n", "encode_covariates", "=", "True", ",", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "save_best", "=", "False", ")", "\n", "dir_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"saved_model/\"", ")", "\n", "model", ".", "save", "(", "dir_path", ",", "overwrite", "=", "True", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", "[", "\"batch\"", "]", "=", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", ")", "\n", "\n", "model2", "=", "PEAKVI", ".", "load_query_data", "(", "adata2", ",", "dir_path", ",", "freeze_expression", "=", "True", ")", "\n", "model2", ".", "train", "(", "max_epochs", "=", "1", ",", "weight_decay", "=", "0.0", ",", "save_best", "=", "False", ")", "\n", "# deactivate no grad decorator", "\n", "model2", ".", "get_latent_representation", "(", ")", "\n", "# pytorch lightning zeros the grad, so this will get a grad to inspect", "\n", "single_pass_for_online_update", "(", "model2", ")", "\n", "grad", "=", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# expression part has zero grad", "\n", "assert", "np", ".", "sum", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "==", "0", "\n", "# categorical part has non-zero grad", "\n", "assert", "np", ".", "count_nonzero", "(", "grad", "[", ":", ",", "-", "4", ":", "]", ")", ">", "0", "\n", "\n", "# do not freeze expression", "\n", "model3", "=", "PEAKVI", ".", "load_query_data", "(", "\n", "adata2", ",", "\n", "dir_path", ",", "\n", "freeze_expression", "=", "False", ",", "\n", "freeze_decoder_first_layer", "=", "False", ",", "\n", ")", "\n", "model3", ".", "train", "(", "max_epochs", "=", "1", ",", "save_best", "=", "False", ",", "weight_decay", "=", "0.0", ")", "\n", "model3", ".", "get_latent_representation", "(", ")", "\n", "single_pass_for_online_update", "(", "model3", ")", "\n", "grad", "=", "model3", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# linear layer weight in encoder layer has non-zero grad", "\n", "assert", "np", ".", "count_nonzero", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "!=", "0", "\n", "grad", "=", "model3", ".", "module", ".", "z_decoder", ".", "px_decoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "grad", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# linear layer weight in decoder layer has non-zero grad", "\n", "assert", "np", ".", "count_nonzero", "(", "grad", "[", ":", ",", ":", "-", "4", "]", ")", "!=", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_jax_scvi": [[87, 105], ["scvi.data.synthetic_iid", "scvi.model.JaxSCVI.setup_anndata", "scvi.model.JaxSCVI", "scvi.model.JaxSCVI.train", "scvi.model.JaxSCVI.get_latent_representation", "scvi.model.JaxSCVI", "scvi.model.JaxSCVI.train", "scvi.model.JaxSCVI.get_latent_representation", "scvi.model.JaxSCVI.get_latent_representation"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["def", "test_jax_scvi", "(", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "JaxSCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "model", "=", "JaxSCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "2", ",", "train_size", "=", "0.5", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "\n", "model", "=", "JaxSCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ",", "gene_likelihood", "=", "\"poisson\"", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "z1", "=", "model", ".", "get_latent_representation", "(", "give_mean", "=", "True", ",", "mc_samples", "=", "1", ")", "\n", "assert", "z1", ".", "ndim", "==", "2", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", "give_mean", "=", "False", ",", "mc_samples", "=", "15", ")", "\n", "assert", "(", "z2", ".", "ndim", "==", "3", ")", "and", "(", "z2", ".", "shape", "[", "0", "]", "==", "15", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_jax_scvi_save_load": [[107, 147], ["scvi.data.synthetic_iid", "scvi.model.JaxSCVI.setup_anndata", "scvi.model.JaxSCVI", "JaxSCVI.load.train", "JaxSCVI.load.get_latent_representation", "JaxSCVI.load.save", "JaxSCVI.load.view_setup_args", "scvi.model.JaxSCVI.load", "JaxSCVI.load.get_latent_representation", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs[].cat.rename_categories", "scvi.model.JaxSCVI.load", "JaxSCVI.load.get_latent_representation", "numpy.testing.assert_array_equal", "pytest.raises", "scvi.model.JaxSCVI.load", "pytest.raises", "scvi.model.JaxSCVI.load", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_setup_args", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], ["", "def", "test_jax_scvi_save_load", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "JaxSCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "model", "=", "JaxSCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "2", ",", "train_size", "=", "0.5", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "z1", "=", "model", ".", "get_latent_representation", "(", "adata", ")", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ")", "\n", "model", ".", "view_setup_args", "(", "save_path", ")", "\n", "model", "=", "JaxSCVI", ".", "load", "(", "save_path", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "\n", "# Load with mismatched genes.", "\n", "tmp_adata", "=", "synthetic_iid", "(", "\n", "n_genes", "=", "200", ",", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "JaxSCVI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ")", "\n", "\n", "# Load with different batches.", "\n", "", "tmp_adata", "=", "synthetic_iid", "(", ")", "\n", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", "=", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", ".", "cat", ".", "rename_categories", "(", "\n", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "JaxSCVI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ")", "\n", "\n", "", "model", "=", "JaxSCVI", ".", "load", "(", "save_path", ",", "adata", "=", "adata", ")", "\n", "assert", "\"batch\"", "in", "model", ".", "adata_manager", ".", "data_registry", "\n", "assert", "model", ".", "adata_manager", ".", "data_registry", "[", "\"batch\"", "]", "==", "dict", "(", "\n", "attr_name", "=", "\"obs\"", ",", "attr_key", "=", "\"_scvi_batch\"", "\n", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "z1", ",", "z2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_scvi": [[149, 346], ["scvi.data.synthetic_iid", "numpy.random.randint", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.utils.mde", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.train", "print", "scvi.model.SCVI.view_anndata_setup", "scvi.model.SCVI.view_anndata_setup", "scvi.model.SCVI.get_latent_representation", "scvi.model.SCVI.get_elbo", "scvi.model.SCVI.get_marginal_ll", "scvi.model.SCVI.get_reconstruction_error", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.get_normalized_expression", "scvi.data.synthetic_iid", "scvi.model.SCVI.get_elbo", "scvi.model.SCVI.get_marginal_ll", "scvi.model.SCVI.get_reconstruction_error", "scvi.model.SCVI.get_latent_representation", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.view_anndata_setup", "scvi.model.SCVI.view_anndata_setup", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.posterior_predictive_sample", "scvi.model.SCVI.posterior_predictive_sample", "scvi.model.SCVI.posterior_predictive_sample", "scvi.model.SCVI.get_feature_correlation_matrix", "scvi.model.SCVI.get_feature_correlation_matrix", "scvi.model.SCVI.get_feature_correlation_matrix", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_latent_library_size", "scvi.model.SCVI.get_latent_library_size", "scvi.data.synthetic_iid", "scvi.model.SCVI._validate_anndata", "scvi.model.SCVI.get_elbo", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.data.synthetic_iid", "scvi.model.SCVI.get_elbo", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.data.synthetic_iid.copy", "scvi.model.SCVI.get_elbo", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.labels.cat.rename_categories", "scvi.model.SCVI.differential_expression", "scvi.model.SCVI.differential_expression", "scvi.model.SCVI.differential_expression", "scvi.model.SCVI.differential_expression", "scvi.model.SCVI.differential_expression", "scvi.data.synthetic_iid", "numpy.zeros", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_likelihood_parameters", "scvi.model.SCVI.get_likelihood_parameters", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "pytorch_lightning.callbacks.LearningRateMonitor", "scvi.model.SCVI.train", "scvi.model.SCVI.get_latent_representation", "len", "pytest.raises", "scvi.model.SCVI.view_anndata_setup", "scvi.model.SCVI.view_anndata_setup", "pytest.raises", "scvi.model.SCVI.get_elbo", "scvi.model.SCVI.history.keys", "torch.nn.Softplus", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.utils._mde.mde", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI._validate_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_likelihood_parameters", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "def", "test_scvi", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "\n", "# Test with size factor.", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "size_factor_key", "=", "\"size_factor\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "# test mde", "\n", "mde", "(", "model", ".", "get_latent_representation", "(", ")", ")", "\n", "\n", "# Test with observed lib size.", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "# Test without observed lib size.", "\n", "model", "=", "SCVI", "(", "\n", "adata", ",", "n_latent", "=", "n_latent", ",", "var_activation", "=", "Softplus", "(", ")", ",", "use_observed_lib_size", "=", "False", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "# tests __repr__", "\n", "print", "(", "model", ")", "\n", "# test view_anndata_setup", "\n", "model", ".", "view_anndata_setup", "(", ")", "\n", "model", ".", "view_anndata_setup", "(", "hide_state_registries", "=", "True", ")", "\n", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "z", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "assert", "z", ".", "shape", "==", "(", "adata", ".", "shape", "[", "0", "]", ",", "n_latent", ")", "\n", "assert", "len", "(", "model", ".", "history", "[", "\"elbo_train\"", "]", ")", "==", "2", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", "transform_batch", "=", "\"batch_1\"", ")", "\n", "model", ".", "get_normalized_expression", "(", "n_samples", "=", "2", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "# test view_anndata_setup with different anndata before transfer setup", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", ".", "view_anndata_setup", "(", "adata", "=", "adata2", ")", "\n", "model", ".", "view_anndata_setup", "(", "adata", "=", "adata2", ",", "hide_state_registries", "=", "True", ")", "\n", "# test get methods with different anndata", "\n", "", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "model", ".", "get_marginal_ll", "(", "adata2", ",", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", "adata2", ")", "\n", "latent", "=", "model", ".", "get_latent_representation", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "latent", ".", "shape", "==", "(", "3", ",", "n_latent", ")", "\n", "denoised", "=", "model", ".", "get_normalized_expression", "(", "adata2", ")", "\n", "assert", "denoised", ".", "shape", "==", "adata", ".", "shape", "\n", "# test view_anndata_setup with different anndata after transfer setup", "\n", "model", ".", "view_anndata_setup", "(", "adata", "=", "adata2", ")", "\n", "model", ".", "view_anndata_setup", "(", "adata", "=", "adata2", ",", "hide_state_registries", "=", "True", ")", "\n", "\n", "denoised", "=", "model", ".", "get_normalized_expression", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "transform_batch", "=", "\"batch_1\"", "\n", ")", "\n", "denoised", "=", "model", ".", "get_normalized_expression", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", "\n", ")", "\n", "assert", "denoised", ".", "shape", "==", "(", "3", ",", "adata2", ".", "n_vars", ")", "\n", "sample", "=", "model", ".", "posterior_predictive_sample", "(", "adata2", ")", "\n", "assert", "sample", ".", "shape", "==", "adata2", ".", "shape", "\n", "sample", "=", "model", ".", "posterior_predictive_sample", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "gene_list", "=", "[", "\"1\"", ",", "\"2\"", "]", "\n", ")", "\n", "assert", "sample", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "sample", "=", "model", ".", "posterior_predictive_sample", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "gene_list", "=", "[", "\"1\"", ",", "\"2\"", "]", ",", "n_samples", "=", "3", "\n", ")", "\n", "assert", "sample", ".", "shape", "==", "(", "3", ",", "2", ",", "3", ")", "\n", "\n", "model", ".", "get_feature_correlation_matrix", "(", "correlation_type", "=", "\"pearson\"", ")", "\n", "model", ".", "get_feature_correlation_matrix", "(", "\n", "adata2", ",", "\n", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "\n", "correlation_type", "=", "\"spearman\"", ",", "\n", "rna_size_factor", "=", "500", ",", "\n", "n_samples", "=", "5", ",", "\n", ")", "\n", "model", ".", "get_feature_correlation_matrix", "(", "\n", "adata2", ",", "\n", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "\n", "correlation_type", "=", "\"spearman\"", ",", "\n", "rna_size_factor", "=", "500", ",", "\n", "n_samples", "=", "5", ",", "\n", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ",", "\n", ")", "\n", "params", "=", "model", ".", "get_likelihood_parameters", "(", ")", "\n", "assert", "params", "[", "\"mean\"", "]", ".", "shape", "==", "adata", ".", "shape", "\n", "assert", "(", "\n", "params", "[", "\"mean\"", "]", ".", "shape", "==", "params", "[", "\"dispersions\"", "]", ".", "shape", "==", "params", "[", "\"dropout\"", "]", ".", "shape", "\n", ")", "\n", "params", "=", "model", ".", "get_likelihood_parameters", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "params", "[", "\"mean\"", "]", ".", "shape", "==", "(", "3", ",", "adata", ".", "n_vars", ")", "\n", "params", "=", "model", ".", "get_likelihood_parameters", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "n_samples", "=", "3", ",", "give_mean", "=", "True", "\n", ")", "\n", "assert", "params", "[", "\"mean\"", "]", ".", "shape", "==", "(", "3", ",", "adata", ".", "n_vars", ")", "\n", "model", ".", "get_latent_library_size", "(", ")", "\n", "model", ".", "get_latent_library_size", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "\n", "# test transfer_anndata_setup", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "model", ".", "_validate_anndata", "(", "adata2", ")", "\n", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "\n", "# test automatic transfer_anndata_setup on a view", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "model", ".", "get_elbo", "(", "adata2", "[", ":", "10", "]", ")", "\n", "\n", "# test automatic transfer_anndata_setup on a copy", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ")", "\n", "adata2", "=", "adata", ".", "copy", "(", ")", "\n", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "assert", "adata", ".", "uns", "[", "_constants", ".", "_SCVI_UUID_KEY", "]", "!=", "adata2", ".", "uns", "[", "_constants", ".", "_SCVI_UUID_KEY", "]", "\n", "\n", "# test mismatched categories raises ValueError", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", ".", "labels", ".", "cat", ".", "rename_categories", "(", "[", "\"a\"", ",", "\"b\"", ",", "\"c\"", "]", ",", "inplace", "=", "True", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "\n", "# test differential expression", "\n", "", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "model", ".", "differential_expression", "(", "\n", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ",", "group2", "=", "\"label_2\"", ",", "mode", "=", "\"change\"", "\n", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ")", "\n", "model", ".", "differential_expression", "(", "idx1", "=", "[", "0", ",", "1", ",", "2", "]", ",", "idx2", "=", "[", "3", ",", "4", ",", "5", "]", ")", "\n", "model", ".", "differential_expression", "(", "idx1", "=", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "\n", "# transform batch works with all different types", "\n", "a", "=", "synthetic_iid", "(", ")", "\n", "batch", "=", "np", ".", "zeros", "(", "a", ".", "n_obs", ")", "\n", "batch", "[", ":", "64", "]", "+=", "1", "\n", "a", ".", "obs", "[", "\"batch\"", "]", "=", "batch", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "m", "=", "SCVI", "(", "a", ")", "\n", "m", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "m", ".", "get_normalized_expression", "(", "transform_batch", "=", "1", ")", "\n", "m", ".", "get_normalized_expression", "(", "transform_batch", "=", "[", "0", ",", "1", "]", ")", "\n", "\n", "# test get_likelihood_parameters() when dispersion=='gene-cell'", "\n", "model", "=", "SCVI", "(", "adata", ",", "dispersion", "=", "\"gene-cell\"", ")", "\n", "model", ".", "get_likelihood_parameters", "(", ")", "\n", "model", ".", "get_likelihood_parameters", "(", "indices", "=", "np", ".", "arange", "(", "10", ")", ")", "\n", "model", ".", "get_likelihood_parameters", "(", "n_samples", "=", "10", ")", "\n", "model", ".", "get_likelihood_parameters", "(", "n_samples", "=", "10", ",", "indices", "=", "np", ".", "arange", "(", "10", ")", ")", "\n", "\n", "# test train callbacks work", "\n", "a", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCVI", "(", "a", ")", "\n", "lr_monitor", "=", "LearningRateMonitor", "(", ")", "\n", "m", ".", "train", "(", "\n", "callbacks", "=", "[", "lr_monitor", "]", ",", "\n", "max_epochs", "=", "10", ",", "\n", "check_val_every_n_epoch", "=", "1", ",", "\n", "log_every_n_steps", "=", "1", ",", "\n", "plan_kwargs", "=", "{", "\"reduce_lr_on_plateau\"", ":", "True", "}", ",", "\n", ")", "\n", "assert", "\"lr-Adam\"", "in", "m", ".", "history", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_scvi_sparse": [[348, 363], ["scvi.data.synthetic_iid", "scipy.sparse.csr_matrix", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_latent_representation", "scvi.model.SCVI.get_elbo", "scvi.model.SCVI.get_marginal_ll", "scvi.model.SCVI.get_reconstruction_error", "scvi.model.SCVI.get_normalized_expression", "scvi.model.SCVI.differential_expression"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression"], ["", "def", "test_scvi_sparse", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "X", "=", "csr_matrix", "(", "adata", ".", "X", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "z", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "assert", "z", ".", "shape", "==", "(", "adata", ".", "shape", "[", "0", "]", ",", "n_latent", ")", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_setting_adata_attr": [[365, 390], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.data.synthetic_iid", "scvi.model.SCVI.get_anndata_manager", "scvi.data.synthetic_iid", "pytest.raises", "scvi.model.SCVI.get_latent_representation", "scvi.model.SCVI.get_latent_representation", "numpy.testing.assert_array_equal", "pytest.raises", "scvi.model.SCVI.get_latent_representation"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.get_anndata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_setting_adata_attr", "(", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "model", ".", "adata", "=", "adata2", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "rep", "=", "model", ".", "get_latent_representation", "(", "adata", ")", "\n", "rep2", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "rep", ",", "rep2", ")", "\n", "\n", "", "orig_manager", "=", "model", ".", "get_anndata_manager", "(", "adata", ")", "\n", "assert", "model", ".", "registry_", "is", "not", "orig_manager", ".", "registry", "\n", "assert", "model", ".", "summary_stats", "is", "not", "orig_manager", ".", "summary_stats", "\n", "\n", "adata3", "=", "synthetic_iid", "(", ")", "\n", "del", "adata3", ".", "obs", "[", "\"batch\"", "]", "\n", "# validation catches no batch", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "model", ".", "adata", "=", "adata3", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_saving_and_loading": [[392, 576], ["os.path.join", "scvi.data.synthetic_iid", "scvi.model.AUTOZI.setup_anndata", "scvi.model.AUTOZI", "cls.load.train", "cls.load.get_alphas_betas", "cls.load.save", "cls.load.view_setup_args", "scvi.model.AUTOZI.load", "cls.load.get_latent_representation", "scvi.data.synthetic_iid", "scvi.model.AUTOZI.load", "cls.load.get_alphas_betas", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "os.path.join", "test_models.test_saving_and_loading.legacy_save"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_setup_args", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas"], ["", "", "def", "test_saving_and_loading", "(", "save_path", ")", ":", "\n", "    ", "def", "legacy_save", "(", "\n", "model", ",", "\n", "dir_path", ",", "\n", "prefix", "=", "None", ",", "\n", "overwrite", "=", "False", ",", "\n", "save_anndata", "=", "False", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_path", ")", "or", "overwrite", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ",", "exist_ok", "=", "overwrite", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"{} already exists. Please provide an unexisting directory for saving.\"", ".", "format", "(", "\n", "dir_path", "\n", ")", "\n", ")", "\n", "\n", "", "file_name_prefix", "=", "prefix", "or", "\"\"", "\n", "\n", "if", "save_anndata", ":", "\n", "            ", "model", ".", "adata", ".", "write", "(", "\n", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}adata.h5ad\"", ")", ",", "\n", "**", "anndata_write_kwargs", ",", "\n", ")", "\n", "\n", "", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}model_params.pt\"", ")", "\n", "attr_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}attr.pkl\"", ")", "\n", "varnames_save_path", "=", "os", ".", "path", ".", "join", "(", "dir_path", ",", "f\"{file_name_prefix}var_names.csv\"", ")", "\n", "\n", "torch", ".", "save", "(", "model", ".", "module", ".", "state_dict", "(", ")", ",", "model_save_path", ")", "\n", "\n", "var_names", "=", "model", ".", "adata", ".", "var_names", ".", "astype", "(", "str", ")", "\n", "var_names", "=", "var_names", ".", "to_numpy", "(", ")", "\n", "np", ".", "savetxt", "(", "varnames_save_path", ",", "var_names", ",", "fmt", "=", "\"%s\"", ")", "\n", "\n", "# get all the user attributes", "\n", "user_attributes", "=", "model", ".", "_get_user_attributes", "(", ")", "\n", "# only save the public attributes with _ at the very end", "\n", "user_attributes", "=", "{", "a", "[", "0", "]", ":", "a", "[", "1", "]", "for", "a", "in", "user_attributes", "if", "a", "[", "0", "]", "[", "-", "1", "]", "==", "\"_\"", "}", "\n", "\n", "with", "open", "(", "attr_save_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "user_attributes", ",", "f", ")", "\n", "\n", "", "", "def", "test_save_load_model", "(", "cls", ",", "adata", ",", "save_path", ",", "prefix", "=", "None", ")", ":", "\n", "        ", "if", "cls", "is", "TOTALVI", ":", "\n", "            ", "cls", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "cls", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "", "model", "=", "cls", "(", "adata", ",", "latent_distribution", "=", "\"normal\"", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.2", ")", "\n", "z1", "=", "model", ".", "get_latent_representation", "(", "adata", ")", "\n", "test_idx1", "=", "model", ".", "validation_indices", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "view_setup_args", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", "=", "cls", ".", "load", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "\n", "# Load with mismatched genes.", "\n", "tmp_adata", "=", "synthetic_iid", "(", "\n", "n_genes", "=", "200", ",", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "cls", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ",", "prefix", "=", "prefix", ")", "\n", "\n", "# Load with different batches.", "\n", "", "tmp_adata", "=", "synthetic_iid", "(", ")", "\n", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", "=", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", ".", "cat", ".", "rename_categories", "(", "\n", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "cls", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ",", "prefix", "=", "prefix", ")", "\n", "\n", "", "model", "=", "cls", ".", "load", "(", "save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "assert", "\"batch\"", "in", "model", ".", "adata_manager", ".", "data_registry", "\n", "assert", "model", ".", "adata_manager", ".", "data_registry", "[", "\"batch\"", "]", "==", "dict", "(", "\n", "attr_name", "=", "\"obs\"", ",", "attr_key", "=", "\"_scvi_batch\"", "\n", ")", "\n", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "test_idx2", "=", "model", ".", "validation_indices", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "z1", ",", "z2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "test_idx1", ",", "test_idx2", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "# Test legacy loading", "\n", "legacy_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"legacy/\"", ")", "\n", "legacy_save", "(", "\n", "model", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "cls", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "", "cls", ".", "convert_legacy_save", "(", "\n", "legacy_save_path", ",", "\n", "legacy_save_path", ",", "\n", "overwrite", "=", "True", ",", "\n", "prefix", "=", "prefix", ",", "\n", ")", "\n", "m", "=", "cls", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"tmp\"", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "\n", "for", "cls", "in", "[", "SCVI", ",", "LinearSCVI", ",", "TOTALVI", ",", "PEAKVI", "]", ":", "\n", "        ", "test_save_load_model", "(", "cls", ",", "adata", ",", "save_path", ",", "prefix", "=", "f\"{cls.__name__}_\"", ")", "\n", "\n", "# AUTOZI", "\n", "", "prefix", "=", "\"AUTOZI_\"", "\n", "AUTOZI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "AUTOZI", "(", "adata", ",", "latent_distribution", "=", "\"normal\"", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "ab1", "=", "model", ".", "get_alphas_betas", "(", ")", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "view_setup_args", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", "=", "AUTOZI", ".", "load", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "tmp_adata", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", "n_genes", "=", "200", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "AUTOZI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ",", "prefix", "=", "prefix", ")", "\n", "", "model", "=", "AUTOZI", ".", "load", "(", "save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "assert", "\"batch\"", "in", "model", ".", "adata_manager", ".", "data_registry", "\n", "assert", "model", ".", "adata_manager", ".", "data_registry", "[", "\"batch\"", "]", "==", "dict", "(", "\n", "attr_name", "=", "\"obs\"", ",", "attr_key", "=", "\"_scvi_batch\"", "\n", ")", "\n", "\n", "ab2", "=", "model", ".", "get_alphas_betas", "(", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "ab1", "[", "\"alpha_posterior\"", "]", ",", "ab2", "[", "\"alpha_posterior\"", "]", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "ab1", "[", "\"beta_posterior\"", "]", ",", "ab2", "[", "\"beta_posterior\"", "]", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "# Test legacy loading", "\n", "legacy_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"legacy/\"", ")", "\n", "legacy_save", "(", "\n", "model", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "AUTOZI", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "", "AUTOZI", ".", "convert_legacy_save", "(", "\n", "legacy_save_path", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "m", "=", "AUTOZI", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "# SCANVI", "\n", "prefix", "=", "\"SCANVI_\"", "\n", "SCANVI", ".", "setup_anndata", "(", "adata", ",", "\"labels\"", ",", "\"label_0\"", ",", "batch_key", "=", "\"batch\"", ")", "\n", "model", "=", "SCANVI", "(", "adata", ")", "\n", "model", ".", "train", "(", "max_epochs", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "p1", "=", "model", ".", "predict", "(", ")", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "view_setup_args", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", "=", "SCANVI", ".", "load", "(", "save_path", ",", "prefix", "=", "prefix", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "tmp_adata", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", "n_genes", "=", "200", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "SCANVI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_adata", ",", "prefix", "=", "prefix", ")", "\n", "", "model", "=", "SCANVI", ".", "load", "(", "save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "assert", "\"batch\"", "in", "model", ".", "adata_manager", ".", "data_registry", "\n", "assert", "model", ".", "adata_manager", ".", "data_registry", "[", "\"batch\"", "]", "==", "dict", "(", "\n", "attr_name", "=", "\"obs\"", ",", "attr_key", "=", "\"_scvi_batch\"", "\n", ")", "\n", "\n", "p2", "=", "model", ".", "predict", "(", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "p1", ",", "p2", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "# Test legacy loading", "\n", "legacy_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"legacy/\"", ")", "\n", "legacy_save", "(", "\n", "model", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "SCANVI", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "", "SCANVI", ".", "convert_legacy_save", "(", "\n", "legacy_save_path", ",", "legacy_save_path", ",", "overwrite", "=", "True", ",", "prefix", "=", "prefix", "\n", ")", "\n", "m", "=", "SCANVI", ".", "load", "(", "legacy_save_path", ",", "adata", "=", "adata", ",", "prefix", "=", "prefix", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.assert_dict_is_subset": [[578, 594], ["d1.items", "isinstance", "AssertionError", "isinstance", "isinstance", "AssertionError", "AssertionError", "test_models.assert_dict_is_subset", "isinstance", "numpy.testing.assert_array_equal", "AssertionError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.assert_dict_is_subset"], ["", "def", "assert_dict_is_subset", "(", "d1", ",", "d2", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "d1", ",", "dict", ")", ":", "\n", "        ", "raise", "AssertionError", "(", "f\"{d1} is not a dictionary.\"", ")", "\n", "", "elif", "not", "isinstance", "(", "d2", ",", "dict", ")", ":", "\n", "        ", "raise", "AssertionError", "(", "f\"{d2} is not a dictionary.\"", ")", "\n", "\n", "", "for", "k", ",", "v", "in", "d1", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "not", "in", "d2", ":", "\n", "            ", "raise", "AssertionError", "(", "f\"{k} missing from {d2}.\"", ")", "\n", "", "v2", "=", "d2", "[", "k", "]", "\n", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "assert_dict_is_subset", "(", "v", ",", "v2", ")", "\n", "", "elif", "isinstance", "(", "v", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "np", ".", "testing", ".", "assert_array_equal", "(", "v", ",", "v2", ")", "\n", "", "elif", "v", "!=", "v2", ":", "\n", "            ", "raise", "AssertionError", "(", "f\"Mismatch between {v} and {v2}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_new_setup_compat": [[596, 636], ["scvi.data.synthetic_iid", "numpy.random.randint", "numpy.random.randint", "numpy.random.normal", "numpy.random.normal", "scvi.data.synthetic_iid.obs.rename", "scvi.data.synthetic_iid.copy", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.view_anndata_setup", "scvi.data._compat.registry_from_setup_dict", "test_models.assert_dict_is_subset", "adata_manager.transfer_fields", "numpy.testing.assert_equal", "field_registries.items"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.data._compat.registry_from_setup_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.assert_dict_is_subset", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.transfer_fields"], ["", "", "", "def", "test_new_setup_compat", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "# Handle edge case where registry_key != obs_key.", "\n", "adata", ".", "obs", ".", "rename", "(", "\n", "columns", "=", "{", "\"batch\"", ":", "\"testbatch\"", ",", "\"labels\"", ":", "\"testlabels\"", "}", ",", "inplace", "=", "True", "\n", ")", "\n", "adata2", "=", "adata", ".", "copy", "(", ")", "\n", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"testbatch\"", ",", "\n", "labels_key", "=", "\"testlabels\"", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ")", "\n", "adata_manager", "=", "model", ".", "adata_manager", "\n", "model", ".", "view_anndata_setup", "(", "hide_state_registries", "=", "True", ")", "\n", "\n", "field_registries", "=", "adata_manager", ".", "registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", "\n", "field_registries_legacy_subset", "=", "{", "\n", "k", ":", "v", "for", "k", ",", "v", "in", "field_registries", ".", "items", "(", ")", "if", "k", "in", "LEGACY_REGISTRY_KEYS", "\n", "}", "\n", "\n", "# Backwards compatibility test.", "\n", "registry", "=", "registry_from_setup_dict", "(", "SCVI", ",", "LEGACY_SETUP_DICT", ")", "\n", "assert_dict_is_subset", "(", "\n", "registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", ",", "\n", "field_registries_legacy_subset", ",", "\n", ")", "\n", "\n", "# Test transfer.", "\n", "adata2_manager", "=", "adata_manager", ".", "transfer_fields", "(", "adata2", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "\n", "field_registries", ",", "\n", "adata2_manager", ".", "registry", "[", "_constants", ".", "_FIELD_REGISTRIES_KEY", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_backwards_compatible_loading": [[639, 678], ["test_models.test_backwards_compatible_loading.download_080_models"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_backwards_compatible_loading", "(", "save_path", ")", ":", "\n", "    ", "def", "download_080_models", "(", "save_path", ")", ":", "\n", "        ", "file_path", "=", "(", "\n", "\"https://github.com/yoseflab/scVI-data/raw/master/testing_models.tar.gz\"", "\n", ")", "\n", "save_fn", "=", "\"testing_models.tar.gz\"", "\n", "_download", "(", "file_path", ",", "save_path", ",", "save_fn", ")", "\n", "saved_file_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "save_fn", ")", "\n", "tar", "=", "tarfile", ".", "open", "(", "saved_file_path", ",", "\"r:gz\"", ")", "\n", "tar", ".", "extractall", "(", "path", "=", "save_path", ")", "\n", "tar", ".", "close", "(", ")", "\n", "\n", "", "download_080_models", "(", "save_path", ")", "\n", "pretrained_scvi_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"testing_models/080_scvi\"", ")", "\n", "pretrained_scvi_updated_path", "=", "os", ".", "path", ".", "join", "(", "\n", "save_path", ",", "\"testing_models/080_scvi_updated\"", "\n", ")", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "# Fail legacy load.", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "m", "=", "scvi", ".", "model", ".", "SCVI", ".", "load", "(", "pretrained_scvi_path", ",", "adata", "=", "a", ")", "\n", "", "scvi", ".", "model", ".", "SCVI", ".", "convert_legacy_save", "(", "\n", "pretrained_scvi_path", ",", "pretrained_scvi_updated_path", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCVI", ".", "load", "(", "pretrained_scvi_updated_path", ",", "adata", "=", "a", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "pretrained_totalvi_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"testing_models/080_totalvi\"", ")", "\n", "pretrained_totalvi_updated_path", "=", "os", ".", "path", ".", "join", "(", "\n", "save_path", ",", "\"testing_models/080_totalvi_updated\"", "\n", ")", "\n", "# Fail legacy load.", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "m", "=", "scvi", ".", "model", ".", "TOTALVI", ".", "load", "(", "pretrained_totalvi_path", ",", "adata", "=", "a", ")", "\n", "", "scvi", ".", "model", ".", "TOTALVI", ".", "convert_legacy_save", "(", "\n", "pretrained_totalvi_path", ",", "pretrained_totalvi_updated_path", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "TOTALVI", ".", "load", "(", "pretrained_totalvi_updated_path", ",", "adata", "=", "a", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_backup_url": [[680, 702], ["scvi.data.synthetic_iid", "numpy.random.randint", "numpy.random.randint", "numpy.random.normal", "numpy.random.normal", "os.path.join", "os.path.join", "scvi.model.SCVI.load", "scvi.model.TOTALVI.load.train", "os.path.join", "os.path.join", "scvi.model.TOTALVI.load", "scvi.model.TOTALVI.load.train"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "@", "pytest", ".", "mark", ".", "internet", "\n", "def", "test_backup_url", "(", "save_path", ")", ":", "\n", "    ", "backup_path", "=", "\"https://github.com/yoseflab/scVI-data/raw/master/testing_models_0150\"", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "a", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "a", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "a", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "a", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "a", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "a", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "a", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "a", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "# SCVI", "\n", "pretrained_scvi_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"testing_models/0150_scvi\"", ")", "\n", "scvi_backup_url", "=", "os", ".", "path", ".", "join", "(", "backup_path", ",", "\"0150_scvi/model.pt\"", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCVI", ".", "load", "(", "pretrained_scvi_path", ",", "adata", "=", "a", ",", "backup_url", "=", "scvi_backup_url", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "# TOTALVI", "\n", "pretrained_totalvi_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"testing_models/0150_totalvi\"", ")", "\n", "totalvi_backup_url", "=", "os", ".", "path", ".", "join", "(", "backup_path", ",", "\"0150_totalvi/model.pt\"", ")", "\n", "m", "=", "scvi", ".", "model", ".", "TOTALVI", ".", "load", "(", "\n", "pretrained_totalvi_path", ",", "adata", "=", "a", ",", "backup_url", "=", "totalvi_backup_url", "\n", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_backed_anndata_scvi": [[704, 717], ["scvi.data.synthetic_iid", "os.path.join", "anndata.read_h5ad.write_h5ad", "anndata.read_h5ad", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI.get_latent_representation", "scvi.model.SCVI.get_elbo"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "def", "test_backed_anndata_scvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test_data.h5ad\"", ")", "\n", "adata", ".", "write_h5ad", "(", "path", ")", "\n", "adata", "=", "anndata", ".", "read_h5ad", "(", "path", ",", "backed", "=", "\"r+\"", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ")", "\n", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "5", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "z", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "assert", "z", ".", "shape", "==", "(", "adata", ".", "shape", "[", "0", "]", ",", "5", ")", "\n", "model", ".", "get_elbo", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_ann_dataloader": [[719, 739], ["scvi.data.synthetic_iid", "tests.dataset.utils.generic_setup_adata_manager", "scvi.dataloaders.AnnDataLoader", "enumerate", "scvi.dataloaders.AnnDataLoader", "enumerate", "len", "len", "pytest.raises", "scvi.dataloaders.AnnDataLoader"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager"], ["", "def", "test_ann_dataloader", "(", ")", ":", "\n", "    ", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "a", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", "\n", ")", "\n", "\n", "# test that batch sampler drops the last batch if it has less than 3 cells", "\n", "assert", "a", ".", "n_obs", "==", "400", "\n", "adl", "=", "AnnDataLoader", "(", "adata_manager", ",", "batch_size", "=", "397", ",", "drop_last", "=", "3", ")", "\n", "assert", "len", "(", "adl", ")", "==", "2", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "adl", ")", ":", "\n", "        ", "pass", "\n", "", "assert", "i", "==", "1", "\n", "adl", "=", "AnnDataLoader", "(", "adata_manager", ",", "batch_size", "=", "398", ",", "drop_last", "=", "3", ")", "\n", "assert", "len", "(", "adl", ")", "==", "1", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "adl", ")", ":", "\n", "        ", "pass", "\n", "", "assert", "i", "==", "0", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "AnnDataLoader", "(", "adata_manager", ",", "batch_size", "=", "1", ",", "drop_last", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_semisupervised_dataloader": [[741, 761], ["scvi.data.synthetic_iid", "tests.dataset.utils.scanvi_setup_adata_manager", "scvi.dataloaders.SemiSupervisedDataLoader", "scvi.dataloaders.SemiSupervisedDataLoader.resample_labels", "len", "len", "numpy.sum", "len", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.scanvi_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._semi_dataloader.SemiSupervisedDataLoader.resample_labels"], ["", "", "def", "test_semisupervised_dataloader", "(", ")", ":", "\n", "# test label resampling", "\n", "    ", "n_samples_per_label", "=", "10", "\n", "a", "=", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "scanvi_setup_adata_manager", "(", "\n", "a", ",", "labels_key", "=", "\"labels\"", ",", "unlabeled_category", "=", "\"label_0\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n", "dl", "=", "SemiSupervisedDataLoader", "(", "\n", "adata_manager", ",", "\n", "indices", "=", "np", ".", "arange", "(", "a", ".", "n_obs", ")", ",", "\n", "n_samples_per_label", "=", "n_samples_per_label", ",", "\n", ")", "\n", "labeled_dl_idx", "=", "dl", ".", "dataloaders", "[", "1", "]", ".", "indices", "\n", "n_labels", "=", "2", "\n", "assert", "len", "(", "labeled_dl_idx", ")", "==", "n_samples_per_label", "*", "n_labels", "\n", "dl", ".", "resample_labels", "(", ")", "\n", "resampled_labeled_dl_idx", "=", "dl", ".", "dataloaders", "[", "1", "]", ".", "indices", "\n", "assert", "len", "(", "resampled_labeled_dl_idx", ")", "==", "n_samples_per_label", "*", "n_labels", "\n", "# check labeled indices was actually resampled", "\n", "assert", "np", ".", "sum", "(", "labeled_dl_idx", "==", "resampled_labeled_dl_idx", ")", "!=", "len", "(", "labeled_dl_idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_data_splitter": [[763, 822], ["scvi.data.synthetic_iid", "tests.dataset.utils.generic_setup_adata_manager", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "len", "numpy.isclose", "numpy.isclose", "numpy.isclose", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "len", "numpy.isclose", "numpy.isclose", "numpy.isclose", "scvi.dataloaders.DataSplitter.train_dataloader", "scvi.dataloaders.DataSplitter.val_dataloader", "scvi.dataloaders.DataSplitter.test_dataloader", "len", "len", "scvi.dataloaders.DataSplitter.train_dataloader", "scvi.dataloaders.DataSplitter.val_dataloader", "scvi.dataloaders.DataSplitter.test_dataloader", "len", "len", "pytest.raises", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "scvi.dataloaders.DataSplitter.train_dataloader", "pytest.raises", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "scvi.dataloaders.DataSplitter.train_dataloader", "pytest.raises", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "scvi.dataloaders.DataSplitter.val_dataloader", "pytest.raises", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "scvi.dataloaders.DataSplitter.val_dataloader", "pytest.raises", "scvi.dataloaders.DataSplitter", "scvi.dataloaders.DataSplitter.setup", "scvi.dataloaders.DataSplitter.train_dataloader", "scvi.dataloaders.DataSplitter.val_dataloader"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.generic_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader"], ["", "def", "test_data_splitter", "(", ")", ":", "\n", "    ", "a", "=", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "generic_setup_adata_manager", "(", "\n", "a", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", "\n", ")", "\n", "# test leaving validataion_size empty works", "\n", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "0.4", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "# check the number of indices", "\n", "_", ",", "_", ",", "_", "=", "ds", ".", "train_dataloader", "(", ")", ",", "ds", ".", "val_dataloader", "(", ")", ",", "ds", ".", "test_dataloader", "(", ")", "\n", "n_train_idx", "=", "len", "(", "ds", ".", "train_idx", ")", "\n", "n_validation_idx", "=", "len", "(", "ds", ".", "val_idx", ")", "if", "ds", ".", "val_idx", "is", "not", "None", "else", "0", "\n", "n_test_idx", "=", "len", "(", "ds", ".", "test_idx", ")", "if", "ds", ".", "test_idx", "is", "not", "None", "else", "0", "\n", "\n", "assert", "n_train_idx", "+", "n_validation_idx", "+", "n_test_idx", "==", "a", ".", "n_obs", "\n", "assert", "np", ".", "isclose", "(", "n_train_idx", "/", "a", ".", "n_obs", ",", "0.4", ")", "\n", "assert", "np", ".", "isclose", "(", "n_validation_idx", "/", "a", ".", "n_obs", ",", "0.6", ")", "\n", "assert", "np", ".", "isclose", "(", "n_test_idx", "/", "a", ".", "n_obs", ",", "0", ")", "\n", "\n", "# test test size", "\n", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "0.4", ",", "validation_size", "=", "0.3", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "# check the number of indices", "\n", "_", ",", "_", ",", "_", "=", "ds", ".", "train_dataloader", "(", ")", ",", "ds", ".", "val_dataloader", "(", ")", ",", "ds", ".", "test_dataloader", "(", ")", "\n", "n_train_idx", "=", "len", "(", "ds", ".", "train_idx", ")", "\n", "n_validation_idx", "=", "len", "(", "ds", ".", "val_idx", ")", "if", "ds", ".", "val_idx", "is", "not", "None", "else", "0", "\n", "n_test_idx", "=", "len", "(", "ds", ".", "test_idx", ")", "if", "ds", ".", "test_idx", "is", "not", "None", "else", "0", "\n", "\n", "assert", "n_train_idx", "+", "n_validation_idx", "+", "n_test_idx", "==", "a", ".", "n_obs", "\n", "assert", "np", ".", "isclose", "(", "n_train_idx", "/", "a", ".", "n_obs", ",", "0.4", ")", "\n", "assert", "np", ".", "isclose", "(", "n_validation_idx", "/", "a", ".", "n_obs", ",", "0.3", ")", "\n", "assert", "np", ".", "isclose", "(", "n_test_idx", "/", "a", ".", "n_obs", ",", "0.3", ")", "\n", "\n", "# test that 0 < train_size <= 1", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "2", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "ds", ".", "train_dataloader", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "-", "2", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "ds", ".", "train_dataloader", "(", ")", "\n", "\n", "# test that 0 <= validation_size < 1", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "0.1", ",", "validation_size", "=", "1", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "ds", ".", "val_dataloader", "(", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "0.1", ",", "validation_size", "=", "-", "1", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "ds", ".", "val_dataloader", "(", ")", "\n", "\n", "# test that train_size + validation_size <= 1", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ds", "=", "DataSplitter", "(", "adata_manager", ",", "train_size", "=", "1", ",", "validation_size", "=", "0.1", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "ds", ".", "train_dataloader", "(", ")", "\n", "ds", ".", "val_dataloader", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_device_backed_data_splitter": [[824, 847], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.dataloaders.DeviceBackedDataSplitter", "scvi.dataloaders.DeviceBackedDataSplitter.setup", "scvi.dataloaders.DeviceBackedDataSplitter.train_dataloader", "scvi.dataloaders.DeviceBackedDataSplitter.val_dataloader", "numpy.testing.assert_array_equal", "scvi.train.TrainingPlan", "scvi.train.TrainRunner", "scvi.train.TrainRunner.", "next", "len", "loaded_x.cpu().numpy", "len", "iter", "loaded_x.cpu"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader"], ["", "", "def", "test_device_backed_data_splitter", "(", ")", ":", "\n", "    ", "a", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "a", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "a", ",", "n_latent", "=", "5", ")", "\n", "adata_manager", "=", "model", ".", "adata_manager", "\n", "# test leaving validataion_size empty works", "\n", "ds", "=", "DeviceBackedDataSplitter", "(", "adata_manager", ",", "train_size", "=", "1.0", ",", "use_gpu", "=", "None", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "train_dl", "=", "ds", ".", "train_dataloader", "(", ")", "\n", "ds", ".", "val_dataloader", "(", ")", "\n", "loaded_x", "=", "next", "(", "iter", "(", "train_dl", ")", ")", "[", "\"X\"", "]", "\n", "assert", "len", "(", "loaded_x", ")", "==", "a", ".", "shape", "[", "0", "]", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "loaded_x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "a", ".", "X", ")", "\n", "\n", "training_plan", "=", "TrainingPlan", "(", "model", ".", "module", ",", "len", "(", "ds", ".", "train_idx", ")", ")", "\n", "runner", "=", "TrainRunner", "(", "\n", "model", ",", "\n", "training_plan", "=", "training_plan", ",", "\n", "data_splitter", "=", "ds", ",", "\n", "max_epochs", "=", "1", ",", "\n", "use_gpu", "=", "None", ",", "\n", ")", "\n", "runner", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_semisupervised_data_splitter": [[849, 896], ["scvi.data.synthetic_iid", "tests.dataset.utils.scanvi_setup_adata_manager", "scvi.dataloaders.SemiSupervisedDataSplitter", "scvi.dataloaders.SemiSupervisedDataSplitter.setup", "len", "numpy.isclose", "numpy.isclose", "numpy.isclose", "scvi.dataloaders.SemiSupervisedDataSplitter", "scvi.dataloaders.SemiSupervisedDataSplitter.setup", "len", "numpy.isclose", "numpy.isclose", "numpy.isclose", "len", "len", "numpy.isclose", "scvi.dataloaders.SemiSupervisedDataSplitter.train_dataloader", "scvi.dataloaders.SemiSupervisedDataSplitter.val_dataloader", "scvi.dataloaders.SemiSupervisedDataSplitter.test_dataloader", "len", "len", "scvi.dataloaders.SemiSupervisedDataSplitter.train_dataloader", "scvi.dataloaders.SemiSupervisedDataSplitter.val_dataloader", "scvi.dataloaders.SemiSupervisedDataSplitter.test_dataloader", "len", "len", "numpy.where", "numpy.where", "len", "len"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.dataset.utils.scanvi_setup_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.setup", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.train_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.val_dataloader", "home.repos.pwc.inspect_result.YosefLab_scVI.dataloaders._data_splitting.DeviceBackedDataSplitter.test_dataloader"], ["", "def", "test_semisupervised_data_splitter", "(", ")", ":", "\n", "    ", "a", "=", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "scanvi_setup_adata_manager", "(", "\n", "a", ",", "labels_key", "=", "\"labels\"", ",", "unlabeled_category", "=", "\"asdf\"", ",", "batch_key", "=", "\"batch\"", "\n", ")", "\n", "ds", "=", "SemiSupervisedDataSplitter", "(", "adata_manager", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "# check the number of indices", "\n", "_", ",", "_", ",", "_", "=", "ds", ".", "train_dataloader", "(", ")", ",", "ds", ".", "val_dataloader", "(", ")", ",", "ds", ".", "test_dataloader", "(", ")", "\n", "n_train_idx", "=", "len", "(", "ds", ".", "train_idx", ")", "\n", "n_validation_idx", "=", "len", "(", "ds", ".", "val_idx", ")", "if", "ds", ".", "val_idx", "is", "not", "None", "else", "0", "\n", "n_test_idx", "=", "len", "(", "ds", ".", "test_idx", ")", "if", "ds", ".", "test_idx", "is", "not", "None", "else", "0", "\n", "\n", "assert", "n_train_idx", "+", "n_validation_idx", "+", "n_test_idx", "==", "a", ".", "n_obs", "\n", "assert", "np", ".", "isclose", "(", "n_train_idx", "/", "a", ".", "n_obs", ",", "0.9", ")", "\n", "assert", "np", ".", "isclose", "(", "n_validation_idx", "/", "a", ".", "n_obs", ",", "0.1", ")", "\n", "assert", "np", ".", "isclose", "(", "n_test_idx", "/", "a", ".", "n_obs", ",", "0", ")", "\n", "\n", "# test mix of labeled and unlabeled data", "\n", "unknown_label", "=", "\"label_0\"", "\n", "ds", "=", "SemiSupervisedDataSplitter", "(", "adata_manager", ")", "\n", "ds", ".", "setup", "(", ")", "\n", "_", ",", "_", ",", "_", "=", "ds", ".", "train_dataloader", "(", ")", ",", "ds", ".", "val_dataloader", "(", ")", ",", "ds", ".", "test_dataloader", "(", ")", "\n", "\n", "# check the number of indices", "\n", "n_train_idx", "=", "len", "(", "ds", ".", "train_idx", ")", "\n", "n_validation_idx", "=", "len", "(", "ds", ".", "val_idx", ")", "if", "ds", ".", "val_idx", "is", "not", "None", "else", "0", "\n", "n_test_idx", "=", "len", "(", "ds", ".", "test_idx", ")", "if", "ds", ".", "test_idx", "is", "not", "None", "else", "0", "\n", "assert", "n_train_idx", "+", "n_validation_idx", "+", "n_test_idx", "==", "a", ".", "n_obs", "\n", "assert", "np", ".", "isclose", "(", "n_train_idx", "/", "a", ".", "n_obs", ",", "0.9", ",", "rtol", "=", "0.05", ")", "\n", "assert", "np", ".", "isclose", "(", "n_validation_idx", "/", "a", ".", "n_obs", ",", "0.1", ",", "rtol", "=", "0.05", ")", "\n", "assert", "np", ".", "isclose", "(", "n_test_idx", "/", "a", ".", "n_obs", ",", "0", ",", "rtol", "=", "0.05", ")", "\n", "\n", "# check that training indices have proper mix of labeled and unlabeled data", "\n", "labelled_idx", "=", "np", ".", "where", "(", "a", ".", "obs", "[", "\"labels\"", "]", "!=", "unknown_label", ")", "[", "0", "]", "\n", "unlabelled_idx", "=", "np", ".", "where", "(", "a", ".", "obs", "[", "\"labels\"", "]", "==", "unknown_label", ")", "[", "0", "]", "\n", "# labeled training idx", "\n", "labeled_train_idx", "=", "[", "i", "for", "i", "in", "ds", ".", "train_idx", "if", "i", "in", "labelled_idx", "]", "\n", "# unlabeled training idx", "\n", "unlabeled_train_idx", "=", "[", "i", "for", "i", "in", "ds", ".", "train_idx", "if", "i", "in", "unlabelled_idx", "]", "\n", "n_labeled_idx", "=", "len", "(", "labelled_idx", ")", "\n", "n_unlabeled_idx", "=", "len", "(", "unlabelled_idx", ")", "\n", "# labeled vs unlabeled ratio in adata", "\n", "adata_ratio", "=", "n_unlabeled_idx", "/", "n_labeled_idx", "\n", "# labeled vs unlabeled ratio in train set", "\n", "train_ratio", "=", "len", "(", "unlabeled_train_idx", ")", "/", "len", "(", "labeled_train_idx", ")", "\n", "assert", "np", ".", "isclose", "(", "adata_ratio", ",", "train_ratio", ",", "atol", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_scanvi": [[898, 994], ["scvi.data.synthetic_iid", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCANVI.train", "scvi.model.SCANVI.history.keys", "scvi.data.synthetic_iid", "scvi.model.SCANVI.predict", "scvi.model.SCANVI.predict", "scvi.model.SCANVI.predict", "isinstance", "scvi.model.SCANVI.predict", "scvi.model.SCANVI.get_normalized_expression", "scvi.model.SCANVI.differential_expression", "scvi.model.SCANVI.differential_expression", "scvi.data.synthetic_iid", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCVI.train", "scvi.data.synthetic_iid", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.SCVI.train", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.data.synthetic_iid", "scvi.model.SCANVI.from_scvi_model", "scvi.model.SCANVI.from_scvi_model.module.state_dict().get", "scvi.model.SCVI.module.state_dict().get", "scvi.model.SCANVI.from_scvi_model.train", "scvi.model.SCANVI.from_scvi_model", "scvi.model.SCANVI.from_scvi_model.train", "scvi.data.synthetic_iid", "numpy.random.randint", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.data.synthetic_iid", "numpy.random.randint", "scvi.model.SCANVI.from_scvi_model", "scvi.model.SCANVI.from_scvi_model.train", "len", "sum", "len", "sum", "len", "pytest.raises", "scvi.model.SCANVI.from_scvi_model", "scvi.model.SCANVI.from_scvi_model.module.state_dict", "scvi.model.SCVI.module.state_dict", "scvi.model.SCANVI.from_scvi_model.module.state_dict", "scvi.model.SCVI.module.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.predict", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.solo._model.SOLO.from_scvi_model", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "test_scanvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCANVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "\"labels\"", ",", "\n", "\"label_0\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "model", "=", "SCANVI", "(", "adata", ",", "n_latent", "=", "10", ")", "\n", "assert", "len", "(", "model", ".", "_labeled_indices", ")", "==", "sum", "(", "adata", ".", "obs", "[", "\"labels\"", "]", "!=", "\"label_0\"", ")", "\n", "assert", "len", "(", "model", ".", "_unlabeled_indices", ")", "==", "sum", "(", "adata", ".", "obs", "[", "\"labels\"", "]", "==", "\"label_0\"", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "logged_keys", "=", "model", ".", "history", ".", "keys", "(", ")", "\n", "assert", "\"elbo_validation\"", "in", "logged_keys", "\n", "assert", "\"reconstruction_loss_validation\"", "in", "logged_keys", "\n", "assert", "\"kl_local_validation\"", "in", "logged_keys", "\n", "assert", "\"elbo_train\"", "in", "logged_keys", "\n", "assert", "\"reconstruction_loss_train\"", "in", "logged_keys", "\n", "assert", "\"kl_local_train\"", "in", "logged_keys", "\n", "assert", "\"classification_loss_validation\"", "in", "logged_keys", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "predictions", "=", "model", ".", "predict", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "len", "(", "predictions", ")", "==", "3", "\n", "model", ".", "predict", "(", ")", "\n", "df", "=", "model", ".", "predict", "(", "adata2", ",", "soft", "=", "True", ")", "\n", "assert", "isinstance", "(", "df", ",", "pd", ".", "DataFrame", ")", "\n", "model", ".", "predict", "(", "adata2", ",", "soft", "=", "True", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "model", ".", "get_normalized_expression", "(", "adata2", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ",", "group2", "=", "\"label_2\"", ")", "\n", "\n", "# test that all data labeled runs", "\n", "unknown_label", "=", "\"asdf\"", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "scvi", ".", "model", ".", "SCANVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "\"labels\"", ",", "\n", "unknown_label", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCANVI", "(", "a", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "# test mix of labeled and unlabeled data", "\n", "unknown_label", "=", "\"label_0\"", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "scvi", ".", "model", ".", "SCANVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "\"labels\"", ",", "\n", "unknown_label", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "m", "=", "scvi", ".", "model", ".", "SCANVI", "(", "a", ")", "\n", "m", ".", "train", "(", "1", ",", "train_size", "=", "0.9", ")", "\n", "\n", "# test from_scvi_model", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "m", "=", "SCVI", "(", "a", ",", "use_observed_lib_size", "=", "False", ")", "\n", "a2", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "scanvi_model", "=", "scvi", ".", "model", ".", "SCANVI", ".", "from_scvi_model", "(", "\n", "m", ",", "\"label_0\"", ",", "labels_key", "=", "\"labels\"", ",", "adata", "=", "a2", "\n", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "scanvi_model", "=", "scvi", ".", "model", ".", "SCANVI", ".", "from_scvi_model", "(", "\n", "m", ",", "\"label_0\"", ",", "labels_key", "=", "None", ",", "adata", "=", "a2", "\n", ")", "\n", "\n", "# make sure the state_dicts are different objects for the two models", "\n", "", "assert", "scanvi_model", ".", "module", ".", "state_dict", "(", ")", "is", "not", "m", ".", "module", ".", "state_dict", "(", ")", "\n", "scanvi_pxr", "=", "scanvi_model", ".", "module", ".", "state_dict", "(", ")", ".", "get", "(", "\"px_r\"", ",", "None", ")", "\n", "scvi_pxr", "=", "m", ".", "module", ".", "state_dict", "(", ")", ".", "get", "(", "\"px_r\"", ",", "None", ")", "\n", "assert", "scanvi_pxr", "is", "not", "None", "and", "scvi_pxr", "is", "not", "None", "\n", "assert", "scanvi_pxr", "is", "not", "scvi_pxr", "\n", "scanvi_model", ".", "train", "(", "1", ")", "\n", "\n", "# Test without label groups", "\n", "scanvi_model", "=", "scvi", ".", "model", ".", "SCANVI", ".", "from_scvi_model", "(", "\n", "m", ",", "\"label_0\"", ",", "labels_key", "=", "\"labels\"", ",", "use_labels_groups", "=", "False", "\n", ")", "\n", "scanvi_model", ".", "train", "(", "1", ")", "\n", "\n", "# test from_scvi_model with size_factor", "\n", "a", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "a", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "a", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ",", "size_factor_key", "=", "\"size_factor\"", "\n", ")", "\n", "m", "=", "SCVI", "(", "a", ",", "use_observed_lib_size", "=", "False", ")", "\n", "a2", "=", "scvi", ".", "data", ".", "synthetic_iid", "(", ")", "\n", "a2", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "a2", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "scanvi_model", "=", "scvi", ".", "model", ".", "SCANVI", ".", "from_scvi_model", "(", "m", ",", "\"label_0\"", ",", "adata", "=", "a2", ")", "\n", "scanvi_model", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_linear_scvi": [[996, 1007], ["scvi.data.synthetic_iid", "adata[].copy", "scvi.model.LinearSCVI.setup_anndata", "scvi.model.LinearSCVI", "scvi.model.LinearSCVI.train", "scvi.model.LinearSCVI.get_loadings", "scvi.model.LinearSCVI.differential_expression", "scvi.model.LinearSCVI.differential_expression", "len", "len"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._linear_scvi.LinearSCVI.get_loadings", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression"], ["", "def", "test_linear_scvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", "=", "adata", "[", ":", ",", ":", "10", "]", ".", "copy", "(", ")", "\n", "LinearSCVI", ".", "setup_anndata", "(", "adata", ")", "\n", "model", "=", "LinearSCVI", "(", "adata", ",", "n_latent", "=", "10", ")", "\n", "model", ".", "train", "(", "1", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "len", "(", "model", ".", "history", "[", "\"elbo_train\"", "]", ")", "==", "1", "\n", "assert", "len", "(", "model", ".", "history", "[", "\"elbo_validation\"", "]", ")", "==", "1", "\n", "model", ".", "get_loadings", "(", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ",", "group2", "=", "\"label_2\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_autozi": [[1009, 1051], ["scvi.data.synthetic_iid", "scvi.model.AUTOZI.setup_anndata", "scvi.model.AUTOZI", "scvi.model.AUTOZI.train", "scvi.model.AUTOZI.get_elbo", "scvi.model.AUTOZI.get_reconstruction_error", "scvi.model.AUTOZI.get_marginal_ll", "scvi.model.AUTOZI.get_alphas_betas", "scvi.model.AUTOZI", "scvi.model.AUTOZI.train", "scvi.model.AUTOZI.get_elbo", "scvi.model.AUTOZI.get_reconstruction_error", "scvi.model.AUTOZI.get_marginal_ll", "scvi.model.AUTOZI.get_alphas_betas", "len", "len", "hasattr", "hasattr", "len", "len", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_alphas_betas"], ["", "def", "test_autozi", "(", ")", ":", "\n", "    ", "data", "=", "synthetic_iid", "(", "\n", "n_batches", "=", "1", ",", "\n", ")", "\n", "AUTOZI", ".", "setup_anndata", "(", "\n", "data", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "\n", "for", "disp_zi", "in", "[", "\"gene\"", ",", "\"gene-label\"", "]", ":", "\n", "        ", "autozivae", "=", "AUTOZI", "(", "\n", "data", ",", "\n", "dispersion", "=", "disp_zi", ",", "\n", "zero_inflation", "=", "disp_zi", ",", "\n", ")", "\n", "autozivae", ".", "train", "(", "1", ",", "plan_kwargs", "=", "dict", "(", "lr", "=", "1e-2", ")", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "assert", "len", "(", "autozivae", ".", "history", "[", "\"elbo_train\"", "]", ")", "==", "1", "\n", "assert", "len", "(", "autozivae", ".", "history", "[", "\"elbo_validation\"", "]", ")", "==", "1", "\n", "autozivae", ".", "get_elbo", "(", "indices", "=", "autozivae", ".", "validation_indices", ")", "\n", "autozivae", ".", "get_reconstruction_error", "(", "indices", "=", "autozivae", ".", "validation_indices", ")", "\n", "autozivae", ".", "get_marginal_ll", "(", "indices", "=", "autozivae", ".", "validation_indices", ",", "n_mc_samples", "=", "3", ")", "\n", "autozivae", ".", "get_alphas_betas", "(", ")", "\n", "\n", "# Model library size.", "\n", "", "for", "disp_zi", "in", "[", "\"gene\"", ",", "\"gene-label\"", "]", ":", "\n", "        ", "autozivae", "=", "AUTOZI", "(", "\n", "data", ",", "\n", "dispersion", "=", "disp_zi", ",", "\n", "zero_inflation", "=", "disp_zi", ",", "\n", "use_observed_lib_size", "=", "False", ",", "\n", ")", "\n", "autozivae", ".", "train", "(", "1", ",", "plan_kwargs", "=", "dict", "(", "lr", "=", "1e-2", ")", ",", "check_val_every_n_epoch", "=", "1", ")", "\n", "assert", "hasattr", "(", "autozivae", ".", "module", ",", "\"library_log_means\"", ")", "and", "hasattr", "(", "\n", "autozivae", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "assert", "len", "(", "autozivae", ".", "history", "[", "\"elbo_train\"", "]", ")", "==", "1", "\n", "assert", "len", "(", "autozivae", ".", "history", "[", "\"elbo_validation\"", "]", ")", "==", "1", "\n", "autozivae", ".", "get_elbo", "(", "indices", "=", "autozivae", ".", "validation_indices", ")", "\n", "autozivae", ".", "get_reconstruction_error", "(", "indices", "=", "autozivae", ".", "validation_indices", ")", "\n", "autozivae", ".", "get_marginal_ll", "(", "indices", "=", "autozivae", ".", "validation_indices", ",", "n_mc_samples", "=", "3", ")", "\n", "autozivae", ".", "get_alphas_betas", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_totalvi": [[1053, 1200], ["scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_latent_representation", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_latent_library_size", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_latent_library_size", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.get_elbo", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.get_elbo", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.TOTALVI.get_elbo", "scvi.data.synthetic_iid", "scvi.model.TOTALVI.differential_expression", "scvi.model.TOTALVI.differential_expression", "scvi.model.TOTALVI.differential_expression", "scvi.model.TOTALVI.differential_expression", "scvi.model.TOTALVI.differential_expression", "scvi.data.pbmcs_10x_cite_seq", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "pytest.raises", "scvi.model.TOTALVI.get_elbo", "pytest.raises", "scvi.model.TOTALVI.get_elbo", "scvi.data.synthetic_iid.var_names[].to_list"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmcs_10x_cite_seq", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "", "def", "test_totalvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "\n", "n_obs", "=", "adata", ".", "n_obs", "\n", "n_vars", "=", "adata", ".", "n_vars", "\n", "n_proteins", "=", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "shape", "[", "1", "]", "\n", "n_latent", "=", "10", "\n", "\n", "model", "=", "TOTALVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "z", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "assert", "z", ".", "shape", "==", "(", "n_obs", ",", "n_latent", ")", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ")", "\n", "model", ".", "get_latent_library_size", "(", ")", "\n", "model", ".", "get_protein_foreground_probability", "(", ")", "\n", "model", ".", "get_protein_foreground_probability", "(", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ")", "\n", "post_pred", "=", "model", ".", "posterior_predictive_sample", "(", "n_samples", "=", "2", ")", "\n", "assert", "post_pred", ".", "shape", "==", "(", "n_obs", ",", "n_vars", "+", "n_proteins", ",", "2", ")", "\n", "post_pred", "=", "model", ".", "posterior_predictive_sample", "(", "n_samples", "=", "1", ")", "\n", "assert", "post_pred", ".", "shape", "==", "(", "n_obs", ",", "n_vars", "+", "n_proteins", ")", "\n", "feature_correlation_matrix1", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"spearman\"", "\n", ")", "\n", "feature_correlation_matrix1", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"spearman\"", ",", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", "\n", ")", "\n", "feature_correlation_matrix2", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"pearson\"", "\n", ")", "\n", "assert", "feature_correlation_matrix1", ".", "shape", "==", "(", "\n", "n_vars", "+", "n_proteins", ",", "\n", "n_vars", "+", "n_proteins", ",", "\n", ")", "\n", "assert", "feature_correlation_matrix2", ".", "shape", "==", "(", "\n", "n_vars", "+", "n_proteins", ",", "\n", "n_vars", "+", "n_proteins", ",", "\n", ")", "\n", "\n", "model", ".", "get_elbo", "(", "indices", "=", "model", ".", "validation_indices", ")", "\n", "model", ".", "get_marginal_ll", "(", "indices", "=", "model", ".", "validation_indices", ",", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", "indices", "=", "model", ".", "validation_indices", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata2", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "norm_exp", "=", "model", ".", "get_normalized_expression", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "norm_exp", "[", "0", "]", ".", "shape", "==", "(", "3", ",", "adata2", ".", "n_vars", ")", "\n", "assert", "norm_exp", "[", "1", "]", ".", "shape", "==", "(", "3", ",", "adata2", ".", "obsm", "[", "\"protein_expression\"", "]", ".", "shape", "[", "1", "]", ")", "\n", "norm_exp", "=", "model", ".", "get_normalized_expression", "(", "\n", "adata2", ",", "\n", "gene_list", "=", "adata2", ".", "var_names", "[", ":", "5", "]", ".", "to_list", "(", ")", ",", "\n", "protein_list", "=", "adata2", ".", "uns", "[", "\"protein_names\"", "]", "[", ":", "3", "]", ",", "\n", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ",", "\n", ")", "\n", "\n", "latent_lib_size", "=", "model", ".", "get_latent_library_size", "(", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "latent_lib_size", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "\n", "pro_foreground_prob", "=", "model", ".", "get_protein_foreground_probability", "(", "\n", "adata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "protein_list", "=", "[", "\"1\"", ",", "\"2\"", "]", "\n", ")", "\n", "assert", "pro_foreground_prob", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "model", ".", "posterior_predictive_sample", "(", "adata2", ")", "\n", "model", ".", "get_feature_correlation_matrix", "(", "adata2", ")", "\n", "\n", "# test transfer_anndata_setup + view", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "model", ".", "get_elbo", "(", "adata2", "[", ":", "10", "]", ")", "\n", "\n", "# test automatic transfer_anndata_setup", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "adata", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "\n", "# test that we catch incorrect mappings", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_0\"", ",", "\"batch_10\"", "]", ",", "inplace", "=", "True", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "\n", "# test that same mapping different order is okay", "\n", "", "adata", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_1\"", ",", "\"batch_0\"", "]", ",", "inplace", "=", "True", ")", "\n", "model", ".", "get_elbo", "(", "adata2", ")", "# should automatically transfer setup", "\n", "\n", "# test that we catch missing proteins", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "del", "adata2", ".", "obsm", "[", "\"protein_expression\"", "]", "\n", "with", "pytest", ".", "raises", "(", "KeyError", ")", ":", "\n", "        ", "model", ".", "get_elbo", "(", "adata2", ")", "\n", "", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ",", "group2", "=", "\"label_2\"", ")", "\n", "model", ".", "differential_expression", "(", "idx1", "=", "[", "0", ",", "1", ",", "2", "]", ",", "idx2", "=", "[", "3", ",", "4", ",", "5", "]", ")", "\n", "model", ".", "differential_expression", "(", "idx1", "=", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ")", "\n", "\n", "# test with missing proteins", "\n", "adata", "=", "scvi", ".", "data", ".", "pbmcs_10x_cite_seq", "(", "\n", "save_path", "=", "save_path", ",", "\n", "protein_join", "=", "\"outer\"", ",", "\n", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "batch_key", "=", "\"batch\"", ",", "protein_expression_obsm_key", "=", "\"protein_expression\"", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "adata", ")", "\n", "assert", "model", ".", "module", ".", "protein_batch_mask", "is", "not", "None", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "model", "=", "TOTALVI", "(", "adata", ",", "override_missing_proteins", "=", "True", ")", "\n", "assert", "model", ".", "module", ".", "protein_batch_mask", "is", "None", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_totalvi_model_library_size": [[1202, 1221], ["scvi.data.synthetic_iid", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_latent_library_size", "hasattr", "hasattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size"], ["", "def", "test_totalvi_model_library_size", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", ")", "\n", "n_latent", "=", "10", "\n", "\n", "model", "=", "TOTALVI", "(", "adata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "False", ")", "\n", "assert", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_latent_library_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_totalvi_size_factor": [[1223, 1249], ["scvi.data.synthetic_iid", "numpy.random.randint", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "hasattr", "hasattr", "hasattr", "hasattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_totalvi_size_factor", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", "size_factor_key", "=", "\"size_factor\"", ",", "\n", ")", "\n", "n_latent", "=", "10", "\n", "\n", "# Test size_factor_key overrides use_observed_lib_size.", "\n", "model", "=", "TOTALVI", "(", "adata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "False", ")", "\n", "assert", "not", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "not", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "assert", "model", ".", "module", ".", "use_size_factor_key", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "model", "=", "TOTALVI", "(", "adata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "True", ")", "\n", "assert", "not", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "not", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "assert", "model", ".", "module", ".", "use_size_factor_key", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_multiple_covariates_scvi": [[1251, 1307], ["scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_latent_representation", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_latent_representation", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_latent_representation", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression"], ["", "def", "test_multiple_covariates_scvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "SCVI", "(", "adata", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "m", ".", "get_latent_representation", "(", ")", "\n", "m", ".", "get_elbo", "(", ")", "\n", "m", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "m", ".", "get_reconstruction_error", "(", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "1", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "2", ")", "\n", "\n", "SCANVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "\"labels\"", ",", "\n", "\"Unknown\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "SCANVI", "(", "adata", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "m", ".", "get_latent_representation", "(", ")", "\n", "m", ".", "get_elbo", "(", ")", "\n", "m", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "m", ".", "get_reconstruction_error", "(", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "1", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "2", ")", "\n", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "TOTALVI", "(", "adata", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "m", ".", "get_latent_representation", "(", ")", "\n", "m", ".", "get_elbo", "(", ")", "\n", "m", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "m", ".", "get_reconstruction_error", "(", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "1", ")", "\n", "m", ".", "get_normalized_expression", "(", "n_samples", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_multiple_encoded_covariates_scvi": [[1309, 1347], ["scvi.data.synthetic_iid", "numpy.random.normal", "numpy.random.normal", "numpy.random.randint", "numpy.random.randint", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.TOTALVI.train", "scvi.model.SCANVI.setup_anndata", "scvi.model.SCANVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.setup_anndata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_multiple_encoded_covariates_scvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"cont1\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cont2\"", "]", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat1\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "adata", ".", "obs", "[", "\"cat2\"", "]", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "SCVI", "(", "adata", ",", "encode_covariates", "=", "True", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "SCANVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "\"labels\"", ",", "\n", "\"Unknown\"", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "SCANVI", "(", "adata", ",", "encode_covariates", "=", "True", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n", "TOTALVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "protein_expression_obsm_key", "=", "\"protein_expression\"", ",", "\n", "protein_names_uns_key", "=", "\"protein_names\"", ",", "\n", "continuous_covariate_keys", "=", "[", "\"cont1\"", ",", "\"cont2\"", "]", ",", "\n", "categorical_covariate_keys", "=", "[", "\"cat1\"", ",", "\"cat2\"", "]", ",", "\n", ")", "\n", "m", "=", "TOTALVI", "(", "adata", ",", "encode_covariates", "=", "True", ")", "\n", "m", ".", "train", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_peakvi": [[1349, 1378], ["scvi.data.synthetic_iid", "scvi.model.PEAKVI.setup_anndata", "scvi.model.PEAKVI", "scvi.model.PEAKVI.train", "scvi.model.PEAKVI", "scvi.model.PEAKVI.train", "scvi.model.PEAKVI", "scvi.model.PEAKVI.train", "scvi.model.PEAKVI.get_elbo", "scvi.model.PEAKVI.get_accessibility_estimates", "scvi.model.PEAKVI.get_accessibility_estimates", "scvi.model.PEAKVI.get_accessibility_estimates", "scvi.model.PEAKVI.get_library_size_factors", "scvi.model.PEAKVI.get_region_factors", "scvi.model.PEAKVI.get_reconstruction_error", "scvi.model.PEAKVI.get_latent_representation", "scvi.model.PEAKVI.differential_accessibility"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_library_size_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_region_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.differential_accessibility"], ["", "def", "test_peakvi", "(", ")", ":", "\n", "    ", "data", "=", "synthetic_iid", "(", ")", "\n", "PEAKVI", ".", "setup_anndata", "(", "\n", "data", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "vae", "=", "PEAKVI", "(", "\n", "data", ",", "\n", "model_depth", "=", "False", ",", "\n", ")", "\n", "vae", ".", "train", "(", "1", ",", "save_best", "=", "False", ")", "\n", "vae", "=", "PEAKVI", "(", "\n", "data", ",", "\n", "region_factors", "=", "False", ",", "\n", ")", "\n", "vae", ".", "train", "(", "1", ",", "save_best", "=", "False", ")", "\n", "vae", "=", "PEAKVI", "(", "\n", "data", ",", "\n", ")", "\n", "vae", ".", "train", "(", "3", ")", "\n", "vae", ".", "get_elbo", "(", "indices", "=", "vae", ".", "validation_indices", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", "normalize_cells", "=", "True", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", "normalize_regions", "=", "True", ")", "\n", "vae", ".", "get_library_size_factors", "(", ")", "\n", "vae", ".", "get_region_factors", "(", ")", "\n", "vae", ".", "get_reconstruction_error", "(", "indices", "=", "vae", ".", "validation_indices", ")", "\n", "vae", ".", "get_latent_representation", "(", ")", "\n", "vae", ".", "differential_accessibility", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_condscvi": [[1380, 1397], ["scvi.data.synthetic_iid", "scvi.model.CondSCVI.setup_anndata", "scvi.model.CondSCVI", "scvi.model.CondSCVI.train", "scvi.model.CondSCVI.get_latent_representation", "scvi.model.CondSCVI.get_vamp_prior", "scvi.model.CondSCVI", "scvi.model.CondSCVI.train", "scvi.model.CondSCVI.get_latent_representation", "scvi.model.CondSCVI.get_vamp_prior"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.get_vamp_prior", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._condscvi.CondSCVI.get_vamp_prior"], ["", "def", "test_condscvi", "(", "save_path", ")", ":", "\n", "    ", "dataset", "=", "synthetic_iid", "(", "\n", "n_labels", "=", "5", ",", "\n", ")", "\n", "CondSCVI", ".", "setup_anndata", "(", "\n", "dataset", ",", "\n", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "CondSCVI", "(", "dataset", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "get_vamp_prior", "(", "dataset", ")", "\n", "\n", "model", "=", "CondSCVI", "(", "dataset", ",", "weight_obs", "=", "True", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "1", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "model", ".", "get_vamp_prior", "(", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_destvi": [[1399, 1445], ["scvi.data.synthetic_iid", "list", "scvi.model.CondSCVI.setup_anndata", "scvi.model.CondSCVI", "scvi.model.CondSCVI.train", "scvi.model.DestVI.setup_anndata", "scvi.model.DestVI.from_rna_model", "range", "pytest.raises", "scvi.model.DestVI.from_rna_model", "scvi.model.DestVI.setup_anndata", "scvi.model.DestVI.from_rna_model", "DestVI.from_rna_model.view_anndata_setup", "DestVI.from_rna_model.train", "numpy.isnan", "DestVI.from_rna_model.get_proportions", "DestVI.from_rna_model.get_gamma", "DestVI.from_rna_model.get_scale_for_ct", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.from_rna_model", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.from_rna_model", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.from_rna_model", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_anndata_setup", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_proportions", "home.repos.pwc.inspect_result.YosefLab_scVI.model._destvi.DestVI.get_gamma", "home.repos.pwc.inspect_result.YosefLab_scVI.stereoscope._model.SpatialStereoscope.get_scale_for_ct"], ["", "def", "test_destvi", "(", "save_path", ")", ":", "\n", "# Step1 learn CondSCVI", "\n", "    ", "n_latent", "=", "2", "\n", "n_labels", "=", "5", "\n", "n_layers", "=", "2", "\n", "dataset", "=", "synthetic_iid", "(", "n_labels", "=", "n_labels", ")", "\n", "dataset", ".", "obs", "[", "\"overclustering_vamp\"", "]", "=", "list", "(", "range", "(", "dataset", ".", "n_obs", ")", ")", "\n", "CondSCVI", ".", "setup_anndata", "(", "dataset", ",", "labels_key", "=", "\"labels\"", ")", "\n", "sc_model", "=", "CondSCVI", "(", "dataset", ",", "n_latent", "=", "n_latent", ",", "n_layers", "=", "n_layers", ")", "\n", "sc_model", ".", "train", "(", "1", ",", "train_size", "=", "1", ")", "\n", "\n", "# step 2 Check model setup", "\n", "DestVI", ".", "setup_anndata", "(", "dataset", ",", "layer", "=", "None", ")", "\n", "\n", "# Test clustering outside of get_vamp_prior", "\n", "\n", "# vamp_prior_p>n_largest_cluster to be successful.", "\n", "_", "=", "DestVI", ".", "from_rna_model", "(", "dataset", ",", "sc_model", ",", "vamp_prior_p", "=", "dataset", ".", "n_obs", ")", "\n", "# vamp_prior_p<n_largest_cluster leads to value error.", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "_", "=", "DestVI", ".", "from_rna_model", "(", "dataset", ",", "sc_model", ",", "vamp_prior_p", "=", "1", ")", "\n", "\n", "", "del", "dataset", ".", "obs", "[", "\"overclustering_vamp\"", "]", "\n", "\n", "# step 3 learn destVI with multiple amortization scheme", "\n", "\n", "for", "amor_scheme", "in", "[", "\"both\"", ",", "\"none\"", ",", "\"proportion\"", ",", "\"latent\"", "]", ":", "\n", "        ", "DestVI", ".", "setup_anndata", "(", "dataset", ",", "layer", "=", "None", ")", "\n", "# add l1_regularization to cell type proportions", "\n", "spatial_model", "=", "DestVI", ".", "from_rna_model", "(", "\n", "dataset", ",", "sc_model", ",", "amortization", "=", "amor_scheme", ",", "l1_reg", "=", "50", "\n", ")", "\n", "spatial_model", ".", "view_anndata_setup", "(", ")", "\n", "spatial_model", ".", "train", "(", "max_epochs", "=", "1", ")", "\n", "assert", "not", "np", ".", "isnan", "(", "spatial_model", ".", "history", "[", "\"elbo_train\"", "]", ".", "values", "[", "0", "]", "[", "0", "]", ")", "\n", "\n", "assert", "spatial_model", ".", "get_proportions", "(", ")", ".", "shape", "==", "(", "dataset", ".", "n_obs", ",", "n_labels", ")", "\n", "assert", "spatial_model", ".", "get_gamma", "(", "return_numpy", "=", "True", ")", ".", "shape", "==", "(", "\n", "dataset", ".", "n_obs", ",", "\n", "n_latent", ",", "\n", "n_labels", ",", "\n", ")", "\n", "\n", "assert", "spatial_model", ".", "get_scale_for_ct", "(", "\"label_0\"", ",", "np", ".", "arange", "(", "50", ")", ")", ".", "shape", "==", "(", "\n", "50", ",", "\n", "dataset", ".", "n_vars", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_multivi": [[1448, 1484], ["scvi.data.synthetic_iid", "scvi.model.MULTIVI.setup_anndata", "scvi.model.MULTIVI", "scvi.model.MULTIVI.train", "scvi.model.MULTIVI.train", "scvi.model.MULTIVI.train", "scvi.model.MULTIVI.get_elbo", "scvi.model.MULTIVI.get_accessibility_estimates", "scvi.model.MULTIVI.get_accessibility_estimates", "scvi.model.MULTIVI.get_accessibility_estimates", "scvi.model.MULTIVI.get_normalized_expression", "scvi.model.MULTIVI.get_library_size_factors", "scvi.model.MULTIVI.get_region_factors", "scvi.model.MULTIVI.get_reconstruction_error", "scvi.model.MULTIVI.get_latent_representation", "scvi.model.MULTIVI.differential_accessibility", "scvi.model.MULTIVI.differential_expression", "scvi.data.synthetic_iid", "numpy.random.randint", "scvi.model.MULTIVI.setup_anndata", "scvi.model.MULTIVI", "scvi.model.MULTIVI.train"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_accessibility_estimates", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_library_size_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.get_region_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._peakvi.PEAKVI.differential_accessibility", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "", "def", "test_multivi", "(", ")", ":", "\n", "    ", "data", "=", "synthetic_iid", "(", ")", "\n", "MULTIVI", ".", "setup_anndata", "(", "\n", "data", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", ")", "\n", "vae", "=", "MULTIVI", "(", "\n", "data", ",", "\n", "n_genes", "=", "50", ",", "\n", "n_regions", "=", "50", ",", "\n", ")", "\n", "vae", ".", "train", "(", "1", ",", "save_best", "=", "False", ")", "\n", "vae", ".", "train", "(", "1", ",", "adversarial_mixing", "=", "False", ")", "\n", "vae", ".", "train", "(", "3", ")", "\n", "vae", ".", "get_elbo", "(", "indices", "=", "vae", ".", "validation_indices", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", "normalize_cells", "=", "True", ")", "\n", "vae", ".", "get_accessibility_estimates", "(", "normalize_regions", "=", "True", ")", "\n", "vae", ".", "get_normalized_expression", "(", ")", "\n", "vae", ".", "get_library_size_factors", "(", ")", "\n", "vae", ".", "get_region_factors", "(", ")", "\n", "vae", ".", "get_reconstruction_error", "(", "indices", "=", "vae", ".", "validation_indices", ")", "\n", "vae", ".", "get_latent_representation", "(", ")", "\n", "vae", ".", "differential_accessibility", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "vae", ".", "differential_expression", "(", "groupby", "=", "\"labels\"", ",", "group1", "=", "\"label_1\"", ")", "\n", "\n", "# Test with size factor", "\n", "data", "=", "synthetic_iid", "(", ")", "\n", "data", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "data", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "MULTIVI", ".", "setup_anndata", "(", "data", ",", "batch_key", "=", "\"batch\"", ",", "size_factor_key", "=", "\"size_factor\"", ")", "\n", "vae", "=", "MULTIVI", "(", "\n", "data", ",", "\n", "n_genes", "=", "50", ",", "\n", "n_regions", "=", "50", ",", "\n", ")", "\n", "vae", ".", "train", "(", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_models.test_early_stopping": [[1486, 1498], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "len", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_early_stopping", "(", ")", ":", "\n", "    ", "n_epochs", "=", "100", "\n", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ")", "\n", "model", ".", "train", "(", "n_epochs", ",", "early_stopping", "=", "True", ",", "plan_kwargs", "=", "dict", "(", "lr", "=", "0", ")", ")", "\n", "assert", "len", "(", "model", ".", "history", "[", "\"elbo_train\"", "]", ")", "<", "n_epochs", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.__init__": [[31, 53], ["pyro.nn.PyroModule.__init__", "test_pyro.BayesianRegressionPyroModel.register_buffer", "test_pyro.BayesianRegressionPyroModel.register_buffer", "test_pyro.BayesianRegressionPyroModel.register_buffer", "pyro.nn.PyroSample", "pyro.nn.PyroSample", "pyro.nn.PyroSample", "pyro.nn.PyroSample", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "pyro.Normal().expand().to_event", "pyro.Normal().expand().to_event", "pyro.Normal().expand().to_event", "pyro.Normal().expand().to_event", "pyro.Normal().expand", "pyro.Normal().expand", "pyro.Normal().expand", "pyro.Normal().expand", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "per_cell_weight", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "n_obs", "=", "None", "\n", "\n", "self", ".", "per_cell_weight", "=", "per_cell_weight", "\n", "\n", "self", ".", "register_buffer", "(", "\"zero\"", ",", "torch", ".", "tensor", "(", "0.0", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"one\"", ",", "torch", ".", "tensor", "(", "1.0", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"ten\"", ",", "torch", ".", "tensor", "(", "10.0", ")", ")", "\n", "\n", "self", ".", "linear", "=", "PyroModule", "[", "nn", ".", "Linear", "]", "(", "in_features", ",", "out_features", ")", "\n", "self", ".", "linear", ".", "weight", "=", "PyroSample", "(", "\n", "lambda", "prior", ":", "dist", ".", "Normal", "(", "self", ".", "zero", ",", "self", ".", "one", ")", "\n", ".", "expand", "(", "[", "self", ".", "out_features", ",", "self", ".", "in_features", "]", ")", "\n", ".", "to_event", "(", "2", ")", "\n", ")", "\n", "self", ".", "linear", ".", "bias", "=", "PyroSample", "(", "\n", "lambda", "prior", ":", "dist", ".", "Normal", "(", "self", ".", "zero", ",", "self", ".", "ten", ")", "\n", ".", "expand", "(", "[", "self", ".", "out_features", "]", ")", "\n", ".", "to_event", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.create_plates": [[55, 62], ["pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate"], "methods", ["None"], ["", "def", "create_plates", "(", "self", ",", "x", ",", "y", ",", "ind_x", ")", ":", "\n", "        ", "\"\"\"\n        Function for creating plates is needed when using AutoGuides.\n\n        Should have the same call signature as model.\n        \"\"\"", "\n", "return", "pyro", ".", "plate", "(", "\"obs_plate\"", ",", "size", "=", "self", ".", "n_obs", ",", "dim", "=", "-", "2", ",", "subsample", "=", "ind_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.list_obs_plate_vars": [[63, 80], ["None"], "methods", ["None"], ["", "def", "list_obs_plate_vars", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Model annotation for minibatch training with pyro plate.\n\n        A dictionary with:\n        1. \"name\" - the name of observation/minibatch plate;\n        2. \"in\" - indexes of model args to provide to encoder network when using amortised inference;\n        3. \"sites\" - dictionary with\n            keys - names of variables that belong to the observation plate (used to recognise\n             and merge posterior samples for minibatch variables)\n            values - the dimensions in non-plate axis of each variable (used to construct output\n             layer of encoder network when using amortised inference)\n        \"\"\"", "\n", "return", "{", "\n", "\"name\"", ":", "\"obs_plate\"", ",", "\n", "\"in\"", ":", "[", "0", "]", ",", "# model args index for expression data", "\n", "\"sites\"", ":", "{", "\"per_cell_weights\"", ":", "1", "}", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel._get_fn_args_from_batch": [[82, 88], ["tensor_dict[].long().squeeze", "tensor_dict[].long"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_fn_args_from_batch", "(", "tensor_dict", ")", ":", "\n", "        ", "x", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "y", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "LABELS_KEY", "]", "\n", "ind_x", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "INDICES_KEY", "]", ".", "long", "(", ")", ".", "squeeze", "(", ")", "\n", "return", "(", "x", ",", "y", ",", "ind_x", ")", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.forward": [[89, 107], ["test_pyro.BayesianRegressionPyroModel.create_plates", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "test_pyro.BayesianRegressionPyroModel.linear().squeeze", "pyro.Exponential", "pyro.Exponential", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "test_pyro.BayesianRegressionPyroModel.linear", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.Normal", "pyro.sample.squeeze", "pyro.sample.squeeze"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionPyroModel.create_plates", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "ind_x", ")", ":", "\n", "\n", "        ", "obs_plate", "=", "self", ".", "create_plates", "(", "x", ",", "y", ",", "ind_x", ")", "\n", "\n", "sigma", "=", "pyro", ".", "sample", "(", "\"sigma\"", ",", "dist", ".", "Exponential", "(", "self", ".", "one", ")", ")", "\n", "\n", "mean", "=", "self", ".", "linear", "(", "x", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "if", "self", ".", "per_cell_weight", ":", "\n", "            ", "with", "obs_plate", ":", "\n", "                ", "per_cell_weights", "=", "pyro", ".", "sample", "(", "\n", "\"per_cell_weights\"", ",", "dist", ".", "Normal", "(", "self", ".", "zero", ",", "self", ".", "one", ")", "\n", ")", "\n", "mean", "=", "mean", "+", "per_cell_weights", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "", "", "with", "obs_plate", ":", "\n", "            ", "pyro", ".", "sample", "(", "\"obs\"", ",", "dist", ".", "Normal", "(", "mean", ",", "sigma", ")", ",", "obs", "=", "y", ")", "\n", "", "return", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModule.__init__": [[110, 118], ["scvi.module.base.PyroBaseModuleClass.__init__", "test_pyro.BayesianRegressionPyroModel", "pyro.infer.autoguide.AutoNormal", "pyro.infer.autoguide.AutoNormal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_model", "=", "BayesianRegressionPyroModel", "(", "**", "kwargs", ")", "\n", "self", ".", "_guide", "=", "AutoNormal", "(", "\n", "self", ".", "model", ",", "init_loc_fn", "=", "init_to_mean", ",", "create_plates", "=", "self", ".", "model", ".", "create_plates", "\n", ")", "\n", "self", ".", "_get_fn_args_from_batch", "=", "self", ".", "_model", ".", "_get_fn_args_from_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModule.model": [[119, 122], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "model", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_model", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModule.guide": [[123, 126], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "guide", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_guide", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModule.list_obs_plate_vars": [[127, 130], ["test_pyro.BayesianRegressionModule.model.list_obs_plate_vars"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModule.list_obs_plate_vars"], ["", "@", "property", "\n", "def", "list_obs_plate_vars", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "model", ".", "list_obs_plate_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModel.__init__": [[133, 150], ["pyro.clear_param_store", "pyro.clear_param_store", "scvi.model.base.PyroSviTrainMixin.__init__", "test_pyro.BayesianRegressionModule", "test_pyro.BayesianRegressionModel._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", "per_cell_weight", "=", "False", ",", "\n", ")", ":", "\n", "# in case any other model was created before that shares the same parameter names.", "\n", "        ", "clear_param_store", "(", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "self", ".", "module", "=", "BayesianRegressionModule", "(", "\n", "in_features", "=", "adata", ".", "shape", "[", "1", "]", ",", "\n", "out_features", "=", "1", ",", "\n", "per_cell_weight", "=", "per_cell_weight", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "\"BayesianRegressionModel\"", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.BayesianRegressionModel.setup_anndata": [[151, 171], ["cls._get_setup_method_args", "numpy.arange().astype", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.NumericalObsField", "locals", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Optional", "[", "AnnData", "]", ":", "\n", "        ", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "\n", "# add index for each cell (provided to pyro plate for correct minibatching)", "\n", "adata", ".", "obs", "[", "\"_indices\"", "]", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", ".", "astype", "(", "\"int64\"", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "None", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "None", ")", ",", "\n", "NumericalObsField", "(", "REGISTRY_KEYS", ".", "INDICES_KEY", ",", "\"_indices\"", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.__init__": [[433, 459], ["scvi.module.base.PyroBaseModuleClass.__init__", "scvi.nn.Encoder", "scvi.nn.DecoderSCVI", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_input", ":", "int", ",", "n_latent", ":", "int", ",", "n_hidden", ":", "int", ",", "n_layers", ":", "int", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_input", "=", "n_input", "\n", "self", ".", "n_latent", "=", "n_latent", "\n", "self", ".", "epsilon", "=", "5.0e-3", "\n", "# z encoder goes from the n_input-dimensional data to an n_latent-d", "\n", "# latent space representation", "\n", "self", ".", "encoder", "=", "Encoder", "(", "\n", "n_input", ",", "\n", "n_latent", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", "dropout_rate", "=", "0.1", ",", "\n", "return_dist", "=", "True", ",", "\n", ")", "\n", "\n", "# decoder goes from n_latent-dimensional space to n_input-d data", "\n", "self", ".", "decoder", "=", "DecoderSCVI", "(", "\n", "n_latent", ",", "\n", "n_input", ",", "\n", "n_layers", "=", "n_layers", ",", "\n", "n_hidden", "=", "n_hidden", ",", "\n", ")", "\n", "# This gene-level parameter modulates the variance of the observation distribution", "\n", "self", ".", "px_r", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "self", ".", "n_input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch": [[460, 465], ["torch.log", "torch.log", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_fn_args_from_batch", "(", "tensor_dict", ")", ":", "\n", "        ", "x", "=", "tensor_dict", "[", "REGISTRY_KEYS", ".", "X_KEY", "]", "\n", "log_library", "=", "torch", ".", "log", "(", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "+", "1e-6", ")", "\n", "return", "(", "x", ",", "log_library", ")", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.model": [[466, 486], ["pyro.module", "pyro.module", "pyro.module", "pyro.module", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "x.new_zeros", "x.new_ones", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "test_pyro.FunctionBasedPyroModule.decoder", "pyro.ZeroInflatedNegativeBinomial", "pyro.ZeroInflatedNegativeBinomial", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.ZeroInflatedNegativeBinomial.to_event", "test_pyro.FunctionBasedPyroModule.px_r.exp", "pyro.Normal", "pyro.Normal", "test_pyro.FunctionBasedPyroModule.px_r.exp"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "def", "model", "(", "self", ",", "x", ",", "log_library", ")", ":", "\n", "# register PyTorch module `decoder` with Pyro", "\n", "        ", "pyro", ".", "module", "(", "\"scvi\"", ",", "self", ")", "\n", "with", "pyro", ".", "plate", "(", "\"data\"", ",", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "# setup hyperparameters for prior p(z)", "\n", "            ", "z_loc", "=", "x", ".", "new_zeros", "(", "torch", ".", "Size", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "n_latent", ")", ")", ")", "\n", "z_scale", "=", "x", ".", "new_ones", "(", "torch", ".", "Size", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "n_latent", ")", ")", ")", "\n", "# sample from prior (value will be sampled by guide when computing the ELBO)", "\n", "z", "=", "pyro", ".", "sample", "(", "\"latent\"", ",", "dist", ".", "Normal", "(", "z_loc", ",", "z_scale", ")", ".", "to_event", "(", "1", ")", ")", "\n", "# decode the latent code z", "\n", "px_scale", ",", "_", ",", "px_rate", ",", "px_dropout", "=", "self", ".", "decoder", "(", "\"gene\"", ",", "z", ",", "log_library", ")", "\n", "# build count distribution", "\n", "nb_logits", "=", "(", "px_rate", "+", "self", ".", "epsilon", ")", ".", "log", "(", ")", "-", "(", "\n", "self", ".", "px_r", ".", "exp", "(", ")", "+", "self", ".", "epsilon", "\n", ")", ".", "log", "(", ")", "\n", "x_dist", "=", "dist", ".", "ZeroInflatedNegativeBinomial", "(", "\n", "gate_logits", "=", "px_dropout", ",", "total_count", "=", "self", ".", "px_r", ".", "exp", "(", ")", ",", "logits", "=", "nb_logits", "\n", ")", "\n", "# score against actual counts", "\n", "pyro", ".", "sample", "(", "\"obs\"", ",", "x_dist", ".", "to_event", "(", "1", ")", ",", "obs", "=", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide": [[487, 496], ["pyro.module", "pyro.module", "pyro.module", "pyro.module", "pyro.plate", "pyro.plate", "pyro.plate", "pyro.plate", "torch.log", "torch.log", "torch.log", "torch.log", "test_pyro.FunctionBasedPyroModule.encoder", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.sample", "pyro.Normal().to_event", "pyro.Normal().to_event", "pyro.Normal", "pyro.Normal"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.module", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample"], ["", "", "def", "guide", "(", "self", ",", "x", ",", "log_library", ")", ":", "\n", "# define the guide (i.e. variational distribution) q(z|x)", "\n", "        ", "pyro", ".", "module", "(", "\"scvi\"", ",", "self", ")", "\n", "with", "pyro", ".", "plate", "(", "\"data\"", ",", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "# use the encoder to get the parameters used to define q(z|x)", "\n", "            ", "x_", "=", "torch", ".", "log", "(", "1", "+", "x", ")", "\n", "qz", ",", "_", "=", "self", ".", "encoder", "(", "x_", ")", "\n", "# sample the latent code z", "\n", "pyro", ".", "sample", "(", "\"latent\"", ",", "dist", ".", "Normal", "(", "qz", ".", "loc", ",", "qz", ".", "scale", ")", ".", "to_event", "(", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__": [[499, 516], ["pyro.clear_param_store", "pyro.clear_param_store", "scvi.model.base.PyroSviTrainMixin.__init__", "test_pyro.FunctionBasedPyroModule", "test_pyro.FunctionBasedPyroModel._get_init_params", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.__init__", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass._get_init_params"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "adata", ":", "AnnData", ",", "\n", ")", ":", "\n", "# in case any other model was created before that shares the same parameter names.", "\n", "        ", "clear_param_store", "(", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "adata", ")", "\n", "\n", "self", ".", "module", "=", "FunctionBasedPyroModule", "(", "\n", "n_input", "=", "adata", ".", "n_vars", ",", "\n", "n_hidden", "=", "32", ",", "\n", "n_latent", "=", "5", ",", "\n", "n_layers", "=", "1", ",", "\n", ")", "\n", "self", ".", "_model_summary_string", "=", "\"FunctionBasedPyroModel\"", "\n", "self", ".", "init_params_", "=", "self", ".", "_get_init_params", "(", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata": [[517, 533], ["cls._get_setup_method_args", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "cls.register_manager", "scvi.data.fields.LayerField", "locals"], "methods", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager._get_setup_method_args", "home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.register_manager"], ["", "@", "classmethod", "\n", "def", "setup_anndata", "(", "\n", "cls", ",", "\n", "adata", ":", "AnnData", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Optional", "[", "AnnData", "]", ":", "\n", "        ", "setup_method_args", "=", "cls", ".", "_get_setup_method_args", "(", "**", "locals", "(", ")", ")", "\n", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "None", ",", "is_count_data", "=", "True", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "\n", "fields", "=", "anndata_fields", ",", "setup_method_args", "=", "setup_method_args", "\n", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ",", "**", "kwargs", ")", "\n", "cls", ".", "register_manager", "(", "adata_manager", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro._create_indices_adata_manager": [[173, 184], ["numpy.arange().astype", "scvi.data.AnnDataManager", "scvi.data.AnnDataManager.register_fields", "scvi.data.fields.LayerField", "scvi.data.fields.CategoricalObsField", "scvi.data.fields.NumericalObsField", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._manager.AnnDataManager.register_fields"], ["", "", "def", "_create_indices_adata_manager", "(", "adata", ":", "AnnData", ")", "->", "AnnDataManager", ":", "\n", "# add index for each cell (provided to pyro plate for correct minibatching)", "\n", "    ", "adata", ".", "obs", "[", "\"_indices\"", "]", "=", "np", ".", "arange", "(", "adata", ".", "n_obs", ")", ".", "astype", "(", "\"int64\"", ")", "\n", "anndata_fields", "=", "[", "\n", "LayerField", "(", "REGISTRY_KEYS", ".", "X_KEY", ",", "None", ",", "is_count_data", "=", "True", ")", ",", "\n", "CategoricalObsField", "(", "REGISTRY_KEYS", ".", "LABELS_KEY", ",", "None", ")", ",", "\n", "NumericalObsField", "(", "REGISTRY_KEYS", ".", "INDICES_KEY", ",", "\"_indices\"", ")", ",", "\n", "]", "\n", "adata_manager", "=", "AnnDataManager", "(", "fields", "=", "anndata_fields", ")", "\n", "adata_manager", ".", "register_fields", "(", "adata", ")", "\n", "return", "adata_manager", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_regression": [[186, 247], ["int", "scvi.data.synthetic_iid", "test_pyro._create_indices_adata_manager", "scvi.dataloaders.AnnDataLoader", "pyro.clear_param_store", "pyro.clear_param_store", "test_pyro.BayesianRegressionModule", "scvi.train.PyroTrainingPlan", "len", "scvi.train.Trainer", "scvi.train.Trainer.fit", "BayesianRegressionModule.create_predictive", "BayesianRegressionModule.cpu", "test_pyro.BayesianRegressionModule.guide", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "os.path.join", "torch.save", "torch.save", "pyro.clear_param_store", "pyro.clear_param_store", "test_pyro.BayesianRegressionModule", "test_pyro.BayesianRegressionModule.guide", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "torch.cuda.is_available", "torch.cuda.is_available", "BayesianRegressionModule.cuda", "BayesianRegressionModule._get_fn_args_from_batch", "BayesianRegressionModule.state_dict", "BayesianRegressionModule.load_state_dict", "v.detach().cpu().numpy", "[].detach().cpu", "[].detach().cpu", "torch.load", "torch.load", "isinstance", "[].detach().cpu", "[].detach().cpu", "model.create_predictive.items", "scvi.train.PyroTrainingPlan", "len", "scvi.train.Trainer", "scvi.train.Trainer.fit", "BayesianRegressionModule.load_state_dict", "v.detach().cpu", "[].detach", "[].detach", "torch.load", "torch.load", "[].detach", "[].detach", "model.create_predictive.", "v.detach"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro._create_indices_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.create_predictive", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.load_state_dict", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], ["", "def", "test_pyro_bayesian_regression", "(", "save_path", ")", ":", "\n", "    ", "use_gpu", "=", "int", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "_create_indices_adata_manager", "(", "adata", ")", "\n", "train_dl", "=", "AnnDataLoader", "(", "adata_manager", ",", "shuffle", "=", "True", ",", "batch_size", "=", "128", ")", "\n", "pyro", ".", "clear_param_store", "(", ")", "\n", "model", "=", "BayesianRegressionModule", "(", "in_features", "=", "adata", ".", "shape", "[", "1", "]", ",", "out_features", "=", "1", ")", "\n", "plan", "=", "PyroTrainingPlan", "(", "model", ")", "\n", "plan", ".", "n_obs_training", "=", "len", "(", "train_dl", ".", "indices", ")", "\n", "trainer", "=", "Trainer", "(", "\n", "gpus", "=", "use_gpu", ",", "\n", "max_epochs", "=", "2", ",", "\n", ")", "\n", "trainer", ".", "fit", "(", "plan", ",", "train_dl", ")", "\n", "if", "use_gpu", "==", "1", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "# test Predictive", "\n", "", "num_samples", "=", "5", "\n", "predictive", "=", "model", ".", "create_predictive", "(", "num_samples", "=", "num_samples", ")", "\n", "for", "tensor_dict", "in", "train_dl", ":", "\n", "        ", "args", ",", "kwargs", "=", "model", ".", "_get_fn_args_from_batch", "(", "tensor_dict", ")", "\n", "_", "=", "{", "\n", "k", ":", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "k", ",", "v", "in", "predictive", "(", "*", "args", ",", "**", "kwargs", ")", ".", "items", "(", ")", "\n", "if", "k", "!=", "\"obs\"", "\n", "}", "\n", "# test save and load", "\n", "# cpu/gpu has minor difference", "\n", "", "model", ".", "cpu", "(", ")", "\n", "quants", "=", "model", ".", "guide", ".", "quantiles", "(", "[", "0.5", "]", ")", "\n", "sigma_median", "=", "quants", "[", "\"sigma\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "linear_median", "=", "quants", "[", "\"linear.weight\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"model_params.pt\"", ")", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "model_save_path", ")", "\n", "\n", "pyro", ".", "clear_param_store", "(", ")", "\n", "new_model", "=", "BayesianRegressionModule", "(", "in_features", "=", "adata", ".", "shape", "[", "1", "]", ",", "out_features", "=", "1", ")", "\n", "# run model one step to get autoguide params", "\n", "try", ":", "\n", "        ", "new_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "model_save_path", ")", ")", "\n", "", "except", "RuntimeError", "as", "err", ":", "\n", "        ", "if", "isinstance", "(", "new_model", ",", "PyroBaseModuleClass", ")", ":", "\n", "            ", "plan", "=", "PyroTrainingPlan", "(", "new_model", ")", "\n", "plan", ".", "n_obs_training", "=", "len", "(", "train_dl", ".", "indices", ")", "\n", "trainer", "=", "Trainer", "(", "\n", "gpus", "=", "use_gpu", ",", "\n", "max_steps", "=", "1", ",", "\n", ")", "\n", "trainer", ".", "fit", "(", "plan", ",", "train_dl", ")", "\n", "new_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "model_save_path", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "err", "\n", "\n", "", "", "quants", "=", "new_model", ".", "guide", ".", "quantiles", "(", "[", "0.5", "]", ")", "\n", "sigma_median_new", "=", "quants", "[", "\"sigma\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "linear_median_new", "=", "quants", "[", "\"linear.weight\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "sigma_median_new", ",", "sigma_median", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "linear_median_new", ",", "linear_median", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_regression_jit": [[249, 285], ["int", "scvi.data.synthetic_iid", "test_pyro._create_indices_adata_manager", "scvi.dataloaders.AnnDataLoader", "pyro.clear_param_store", "pyro.clear_param_store", "test_pyro.BayesianRegressionModule", "scvi.train.PyroTrainingPlan", "len", "scvi.train.Trainer", "scvi.train.Trainer.fit", "BayesianRegressionModule.create_predictive", "torch.cuda.is_available", "torch.cuda.is_available", "list", "list", "BayesianRegressionModule.cuda", "BayesianRegressionModule._get_fn_args_from_batch", "pyro.infer.JitTrace_ELBO", "pyro.infer.JitTrace_ELBO", "v.detach().cpu().numpy", "scvi.model.base.PyroJitGuideWarmup", "model.create_predictive.items", "test_pyro.BayesianRegressionModule.guide", "test_pyro.BayesianRegressionModule.guide", "v.detach().cpu", "model.create_predictive.", "v.detach"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro._create_indices_adata_manager", "home.repos.pwc.inspect_result.YosefLab_scVI.train._trainer.Trainer.fit", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_module.PyroBaseModuleClass.create_predictive", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule._get_fn_args_from_batch", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModule.guide"], ["", "def", "test_pyro_bayesian_regression_jit", "(", ")", ":", "\n", "    ", "use_gpu", "=", "int", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata_manager", "=", "_create_indices_adata_manager", "(", "adata", ")", "\n", "train_dl", "=", "AnnDataLoader", "(", "adata_manager", ",", "shuffle", "=", "True", ",", "batch_size", "=", "128", ")", "\n", "pyro", ".", "clear_param_store", "(", ")", "\n", "model", "=", "BayesianRegressionModule", "(", "in_features", "=", "adata", ".", "shape", "[", "1", "]", ",", "out_features", "=", "1", ")", "\n", "plan", "=", "PyroTrainingPlan", "(", "model", ",", "loss_fn", "=", "pyro", ".", "infer", ".", "JitTrace_ELBO", "(", ")", ")", "\n", "plan", ".", "n_obs_training", "=", "len", "(", "train_dl", ".", "indices", ")", "\n", "trainer", "=", "Trainer", "(", "\n", "gpus", "=", "use_gpu", ",", "max_epochs", "=", "2", ",", "callbacks", "=", "[", "PyroJitGuideWarmup", "(", "train_dl", ")", "]", "\n", ")", "\n", "trainer", ".", "fit", "(", "plan", ",", "train_dl", ")", "\n", "\n", "# 100 features", "\n", "assert", "list", "(", "model", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.weight_unconstrained\"", "]", ".", "shape", ")", "==", "[", "\n", "1", ",", "\n", "100", ",", "\n", "]", "\n", "# 1 bias", "\n", "assert", "list", "(", "model", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.bias_unconstrained\"", "]", ".", "shape", ")", "==", "[", "\n", "1", ",", "\n", "]", "\n", "\n", "if", "use_gpu", "==", "1", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "# test Predictive", "\n", "", "num_samples", "=", "5", "\n", "predictive", "=", "model", ".", "create_predictive", "(", "num_samples", "=", "num_samples", ")", "\n", "for", "tensor_dict", "in", "train_dl", ":", "\n", "        ", "args", ",", "kwargs", "=", "model", ".", "_get_fn_args_from_batch", "(", "tensor_dict", ")", "\n", "_", "=", "{", "\n", "k", ":", "v", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "k", ",", "v", "in", "predictive", "(", "*", "args", ",", "**", "kwargs", ")", ".", "items", "(", ")", "\n", "if", "k", "!=", "\"obs\"", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_save_load": [[288, 318], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.BayesianRegressionModel.setup_anndata", "test_pyro.BayesianRegressionModel", "BayesianRegressionModel.load.train", "BayesianRegressionModel.load.module.cpu", "BayesianRegressionModel.load.module.guide.quantiles", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "os.path.join", "BayesianRegressionModel.load.save", "BayesianRegressionModel.load", "BayesianRegressionModel.load.module.guide.quantiles", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "[].detach().cpu", "[].detach().cpu", "[].detach().cpu", "[].detach().cpu", "[].detach", "[].detach", "[].detach", "[].detach"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], ["", "", "def", "test_pyro_bayesian_save_load", "(", "save_path", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "BayesianRegressionModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "BayesianRegressionModel", "(", "adata", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "2", ",", "\n", "batch_size", "=", "128", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "mod", ".", "module", ".", "cpu", "(", ")", "\n", "quants", "=", "mod", ".", "module", ".", "guide", ".", "quantiles", "(", "[", "0.5", "]", ")", "\n", "sigma_median", "=", "quants", "[", "\"sigma\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "linear_median", "=", "quants", "[", "\"linear.weight\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"test_pyro_bayesian/\"", ")", "\n", "mod", ".", "save", "(", "model_save_path", ")", "\n", "\n", "# Test setting `on_load_kwargs`", "\n", "mod", ".", "module", ".", "on_load_kwargs", "=", "{", "\"batch_size\"", ":", "8", "}", "\n", "mod", "=", "BayesianRegressionModel", ".", "load", "(", "model_save_path", ",", "adata", "=", "adata", ")", "\n", "\n", "quants", "=", "mod", ".", "module", ".", "guide", ".", "quantiles", "(", "[", "0.5", "]", ")", "\n", "sigma_median_new", "=", "quants", "[", "\"sigma\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "linear_median_new", "=", "quants", "[", "\"linear.weight\"", "]", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "sigma_median_new", ",", "sigma_median", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "linear_median_new", ",", "linear_median", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_train_sample_mixin": [[320, 343], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.BayesianRegressionModel.setup_anndata", "test_pyro.BayesianRegressionModel", "BayesianRegressionModel.train", "BayesianRegressionModel.sample_posterior", "list", "len", "BayesianRegressionModel.module.guide.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin.sample_posterior", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "test_pyro_bayesian_train_sample_mixin", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "BayesianRegressionModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "BayesianRegressionModel", "(", "adata", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "2", ",", "\n", "batch_size", "=", "128", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "# 100 features", "\n", "assert", "list", "(", "\n", "mod", ".", "module", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.weight_unconstrained\"", "]", ".", "shape", "\n", ")", "==", "[", "1", ",", "100", "]", "\n", "\n", "# test posterior sampling", "\n", "samples", "=", "mod", ".", "sample_posterior", "(", "\n", "num_samples", "=", "10", ",", "use_gpu", "=", "use_gpu", ",", "batch_size", "=", "None", ",", "return_samples", "=", "True", "\n", ")", "\n", "\n", "assert", "len", "(", "samples", "[", "\"posterior_samples\"", "]", "[", "\"sigma\"", "]", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_train_sample_mixin_full_data": [[345, 368], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.BayesianRegressionModel.setup_anndata", "test_pyro.BayesianRegressionModel", "BayesianRegressionModel.train", "BayesianRegressionModel.sample_posterior", "list", "len", "BayesianRegressionModel.module.guide.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin.sample_posterior", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "test_pyro_bayesian_train_sample_mixin_full_data", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "BayesianRegressionModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "BayesianRegressionModel", "(", "adata", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "2", ",", "\n", "batch_size", "=", "None", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "# 100 features", "\n", "assert", "list", "(", "\n", "mod", ".", "module", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.weight_unconstrained\"", "]", ".", "shape", "\n", ")", "==", "[", "1", ",", "100", "]", "\n", "\n", "# test posterior sampling", "\n", "samples", "=", "mod", ".", "sample_posterior", "(", "\n", "num_samples", "=", "10", ",", "use_gpu", "=", "use_gpu", ",", "batch_size", "=", "adata", ".", "n_obs", ",", "return_samples", "=", "True", "\n", ")", "\n", "\n", "assert", "len", "(", "samples", "[", "\"posterior_samples\"", "]", "[", "\"sigma\"", "]", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_train_sample_mixin_with_local": [[370, 398], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.BayesianRegressionModel.setup_anndata", "test_pyro.BayesianRegressionModel", "BayesianRegressionModel.train", "BayesianRegressionModel.sample_posterior", "list", "len", "BayesianRegressionModel.module.guide.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin.sample_posterior", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "test_pyro_bayesian_train_sample_mixin_with_local", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "BayesianRegressionModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "BayesianRegressionModel", "(", "adata", ",", "per_cell_weight", "=", "True", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "2", ",", "\n", "batch_size", "=", "128", ",", "\n", "lr", "=", "0.01", ",", "\n", "train_size", "=", "1", ",", "# does not work when there is a validation set.", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "# 100", "\n", "assert", "list", "(", "\n", "mod", ".", "module", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.weight_unconstrained\"", "]", ".", "shape", "\n", ")", "==", "[", "1", ",", "100", "]", "\n", "\n", "# test posterior sampling", "\n", "samples", "=", "mod", ".", "sample_posterior", "(", "\n", "num_samples", "=", "10", ",", "use_gpu", "=", "use_gpu", ",", "batch_size", "=", "None", ",", "return_samples", "=", "True", "\n", ")", "\n", "\n", "assert", "len", "(", "samples", "[", "\"posterior_samples\"", "]", "[", "\"sigma\"", "]", ")", "==", "10", "\n", "assert", "samples", "[", "\"posterior_samples\"", "]", "[", "\"per_cell_weights\"", "]", ".", "shape", "==", "(", "\n", "10", ",", "\n", "adata", ".", "n_obs", ",", "\n", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_pyro_bayesian_train_sample_mixin_with_local_full_data": [[401, 429], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.BayesianRegressionModel.setup_anndata", "test_pyro.BayesianRegressionModel", "BayesianRegressionModel.train", "BayesianRegressionModel.sample_posterior", "list", "len", "BayesianRegressionModel.module.guide.state_dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._pyromixin.PyroSampleMixin.sample_posterior", "home.repos.pwc.inspect_result.YosefLab_scVI.base._jax_module_wrapper.JaxModuleWrapper.state_dict"], ["", "def", "test_pyro_bayesian_train_sample_mixin_with_local_full_data", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "BayesianRegressionModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "BayesianRegressionModel", "(", "adata", ",", "per_cell_weight", "=", "True", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "2", ",", "\n", "batch_size", "=", "None", ",", "\n", "lr", "=", "0.01", ",", "\n", "train_size", "=", "1", ",", "# does not work when there is a validation set.", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "# 100", "\n", "assert", "list", "(", "\n", "mod", ".", "module", ".", "guide", ".", "state_dict", "(", ")", "[", "\"locs.linear.weight_unconstrained\"", "]", ".", "shape", "\n", ")", "==", "[", "1", ",", "100", "]", "\n", "\n", "# test posterior sampling", "\n", "samples", "=", "mod", ".", "sample_posterior", "(", "\n", "num_samples", "=", "10", ",", "use_gpu", "=", "use_gpu", ",", "batch_size", "=", "adata", ".", "n_obs", ",", "return_samples", "=", "True", "\n", ")", "\n", "\n", "assert", "len", "(", "samples", "[", "\"posterior_samples\"", "]", "[", "\"sigma\"", "]", ")", "==", "10", "\n", "assert", "samples", "[", "\"posterior_samples\"", "]", "[", "\"per_cell_weights\"", "]", ".", "shape", "==", "(", "\n", "10", ",", "\n", "adata", ".", "n_obs", ",", "\n", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_function_based_pyro_module": [[535, 545], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "test_pyro.FunctionBasedPyroModel.setup_anndata", "test_pyro.FunctionBasedPyroModel", "FunctionBasedPyroModel.train"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "", "def", "test_function_based_pyro_module", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "FunctionBasedPyroModel", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "FunctionBasedPyroModel", "(", "adata", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "1", ",", "\n", "batch_size", "=", "256", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_lda_model": [[548, 605], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "scvi.model.AmortizedLDA.setup_anndata", "scvi.model.AmortizedLDA", "scvi.model.AmortizedLDA.train", "scvi.model.AmortizedLDA", "scvi.model.AmortizedLDA.train", "scvi.model.AmortizedLDA", "scvi.model.AmortizedLDA.train", "scvi.model.AmortizedLDA.get_feature_by_topic().to_numpy", "numpy.allclose", "scvi.model.AmortizedLDA.get_latent_representation().to_numpy", "scvi.model.AmortizedLDA.get_elbo", "scvi.model.AmortizedLDA.get_perplexity", "scvi.data.synthetic_iid", "scvi.model.AmortizedLDA.setup_anndata", "scvi.model.AmortizedLDA.get_latent_representation().to_numpy", "scvi.model.AmortizedLDA.get_elbo", "scvi.model.AmortizedLDA.get_perplexity", "mod.get_feature_by_topic().to_numpy.sum", "numpy.all", "numpy.allclose", "numpy.all", "numpy.allclose", "scvi.model.AmortizedLDA.get_feature_by_topic", "scvi.model.AmortizedLDA.get_latent_representation", "mod.get_latent_representation().to_numpy.sum", "scvi.model.AmortizedLDA.get_latent_representation", "mod.get_latent_representation().to_numpy.sum", "range", "range"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_perplexity", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_perplexity", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_feature_by_topic", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_lda_model", "(", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "n_topics", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "\n", "# Test with float and Sequence priors.", "\n", "AmortizedLDA", ".", "setup_anndata", "(", "adata", ")", "\n", "mod1", "=", "AmortizedLDA", "(", "\n", "adata", ",", "n_topics", "=", "n_topics", ",", "cell_topic_prior", "=", "1.5", ",", "topic_feature_prior", "=", "1.5", "\n", ")", "\n", "mod1", ".", "train", "(", "\n", "max_epochs", "=", "1", ",", "\n", "batch_size", "=", "256", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "mod2", "=", "AmortizedLDA", "(", "\n", "adata", ",", "\n", "n_topics", "=", "n_topics", ",", "\n", "cell_topic_prior", "=", "[", "1.5", "for", "_", "in", "range", "(", "n_topics", ")", "]", ",", "\n", "topic_feature_prior", "=", "[", "1.5", "for", "_", "in", "range", "(", "adata", ".", "n_vars", ")", "]", ",", "\n", ")", "\n", "mod2", ".", "train", "(", "\n", "max_epochs", "=", "1", ",", "\n", "batch_size", "=", "256", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "\n", "mod", "=", "AmortizedLDA", "(", "adata", ",", "n_topics", "=", "n_topics", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "5", ",", "\n", "batch_size", "=", "256", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "adata_gbt", "=", "mod", ".", "get_feature_by_topic", "(", ")", ".", "to_numpy", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "adata_gbt", ".", "sum", "(", "axis", "=", "0", ")", ",", "1", ")", "\n", "adata_lda", "=", "mod", ".", "get_latent_representation", "(", "adata", ")", ".", "to_numpy", "(", ")", "\n", "assert", "(", "\n", "adata_lda", ".", "shape", "==", "(", "adata", ".", "n_obs", ",", "n_topics", ")", "\n", "and", "np", ".", "all", "(", "(", "adata_lda", "<=", "1", ")", "&", "(", "adata_lda", ">=", "0", ")", ")", "\n", "and", "np", ".", "allclose", "(", "adata_lda", ".", "sum", "(", "axis", "=", "1", ")", ",", "1", ")", "\n", ")", "\n", "mod", ".", "get_elbo", "(", ")", "\n", "mod", ".", "get_perplexity", "(", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "AmortizedLDA", ".", "setup_anndata", "(", "adata2", ")", "\n", "adata2_lda", "=", "mod", ".", "get_latent_representation", "(", "adata2", ")", ".", "to_numpy", "(", ")", "\n", "assert", "(", "\n", "adata2_lda", ".", "shape", "==", "(", "adata2", ".", "n_obs", ",", "n_topics", ")", "\n", "and", "np", ".", "all", "(", "(", "adata2_lda", "<=", "1", ")", "&", "(", "adata2_lda", ">=", "0", ")", ")", "\n", "and", "np", ".", "allclose", "(", "adata2_lda", ".", "sum", "(", "axis", "=", "1", ")", ",", "1", ")", "\n", ")", "\n", "mod", ".", "get_elbo", "(", "adata2", ")", "\n", "mod", ".", "get_perplexity", "(", "adata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.test_lda_model_save_load": [[607, 636], ["torch.cuda.is_available", "torch.cuda.is_available", "scvi.data.synthetic_iid", "scvi.model.AmortizedLDA.setup_anndata", "scvi.model.AmortizedLDA", "AmortizedLDA.load.train", "AmortizedLDA.load.get_feature_by_topic", "AmortizedLDA.load.get_latent_representation", "os.path.join", "AmortizedLDA.load.save", "scvi.model.AmortizedLDA.load", "numpy.testing.assert_array_equal", "AmortizedLDA.load.get_feature_by_topic", "AmortizedLDA.load.get_latent_representation", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "mod.get_feature_by_topic.to_numpy", "mod.get_feature_by_topic.to_numpy", "mod.get_latent_representation.to_numpy", "mod.get_latent_representation.to_numpy"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_feature_by_topic", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_feature_by_topic", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation"], ["", "def", "test_lda_model_save_load", "(", "save_path", ")", ":", "\n", "    ", "use_gpu", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "n_topics", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "AmortizedLDA", ".", "setup_anndata", "(", "adata", ")", "\n", "mod", "=", "AmortizedLDA", "(", "adata", ",", "n_topics", "=", "n_topics", ")", "\n", "mod", ".", "train", "(", "\n", "max_epochs", "=", "5", ",", "\n", "batch_size", "=", "256", ",", "\n", "lr", "=", "0.01", ",", "\n", "use_gpu", "=", "use_gpu", ",", "\n", ")", "\n", "hist_elbo", "=", "mod", ".", "history_", "[", "\"elbo_train\"", "]", "\n", "\n", "feature_by_topic_1", "=", "mod", ".", "get_feature_by_topic", "(", "n_samples", "=", "5000", ")", "\n", "latent_1", "=", "mod", ".", "get_latent_representation", "(", "n_samples", "=", "6000", ")", "\n", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"tmp\"", ")", "\n", "mod", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ")", "\n", "mod", "=", "AmortizedLDA", ".", "load", "(", "save_path", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "mod", ".", "history_", "[", "\"elbo_train\"", "]", ",", "hist_elbo", ")", "\n", "\n", "feature_by_topic_2", "=", "mod", ".", "get_feature_by_topic", "(", "n_samples", "=", "5000", ")", "\n", "latent_2", "=", "mod", ".", "get_latent_representation", "(", "n_samples", "=", "6000", ")", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "feature_by_topic_1", ".", "to_numpy", "(", ")", ",", "feature_by_topic_2", ".", "to_numpy", "(", ")", ",", "decimal", "=", "2", "\n", ")", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "latent_1", ".", "to_numpy", "(", ")", ",", "latent_2", ".", "to_numpy", "(", ")", ",", "decimal", "=", "2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi": [[13, 100], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_latent_representation", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_latent_library_size", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_reconstruction_error", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_normalized_expression", "scvi.model.TOTALVI.get_latent_library_size", "scvi.model.TOTALVI.get_protein_foreground_probability", "scvi.model.TOTALVI.posterior_predictive_sample", "scvi.model.TOTALVI.get_feature_correlation_matrix", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.get_elbo", "dict", "dict", "scvi.data.synthetic_iid.var_names[].to_list", "scvi.data.synthetic_iid.var_names[].to_list"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.base._vaemixin.VAEMixin.get_reconstruction_error", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_normalized_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_protein_foreground_probability", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.posterior_predictive_sample", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_feature_correlation_matrix", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["def", "test_totalvi", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "\n", "n_obs", "=", "mdata", ".", "n_obs", "\n", "n_genes", "=", "adata", ".", "n_vars", "\n", "n_proteins", "=", "protein_adata", ".", "X", ".", "shape", "[", "1", "]", "\n", "n_latent", "=", "10", "\n", "\n", "model", "=", "TOTALVI", "(", "mdata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "z", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "assert", "z", ".", "shape", "==", "(", "n_obs", ",", "n_latent", ")", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", ")", "\n", "model", ".", "get_normalized_expression", "(", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ")", "\n", "model", ".", "get_latent_library_size", "(", ")", "\n", "model", ".", "get_protein_foreground_probability", "(", ")", "\n", "model", ".", "get_protein_foreground_probability", "(", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ")", "\n", "post_pred", "=", "model", ".", "posterior_predictive_sample", "(", "n_samples", "=", "2", ")", "\n", "assert", "post_pred", ".", "shape", "==", "(", "n_obs", ",", "n_genes", "+", "n_proteins", ",", "2", ")", "\n", "post_pred", "=", "model", ".", "posterior_predictive_sample", "(", "n_samples", "=", "1", ")", "\n", "assert", "post_pred", ".", "shape", "==", "(", "n_obs", ",", "n_genes", "+", "n_proteins", ")", "\n", "feature_correlation_matrix1", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"spearman\"", "\n", ")", "\n", "feature_correlation_matrix1", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"spearman\"", ",", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", "\n", ")", "\n", "feature_correlation_matrix2", "=", "model", ".", "get_feature_correlation_matrix", "(", "\n", "correlation_type", "=", "\"pearson\"", "\n", ")", "\n", "assert", "feature_correlation_matrix1", ".", "shape", "==", "(", "\n", "n_genes", "+", "n_proteins", ",", "\n", "n_genes", "+", "n_proteins", ",", "\n", ")", "\n", "assert", "feature_correlation_matrix2", ".", "shape", "==", "(", "\n", "n_genes", "+", "n_proteins", ",", "\n", "n_genes", "+", "n_proteins", ",", "\n", ")", "\n", "\n", "model", ".", "get_elbo", "(", "indices", "=", "model", ".", "validation_indices", ")", "\n", "model", ".", "get_marginal_ll", "(", "indices", "=", "model", ".", "validation_indices", ",", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_reconstruction_error", "(", "indices", "=", "model", ".", "validation_indices", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata2", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "norm_exp", "=", "model", ".", "get_normalized_expression", "(", "mdata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "norm_exp", "[", "0", "]", ".", "shape", "==", "(", "3", ",", "adata2", ".", "n_vars", ")", "\n", "assert", "norm_exp", "[", "1", "]", ".", "shape", "==", "(", "3", ",", "protein_adata2", ".", "n_vars", ")", "\n", "norm_exp", "=", "model", ".", "get_normalized_expression", "(", "\n", "mdata2", ",", "\n", "gene_list", "=", "adata2", ".", "var_names", "[", ":", "5", "]", ".", "to_list", "(", ")", ",", "\n", "protein_list", "=", "protein_adata2", ".", "var_names", "[", ":", "3", "]", ".", "to_list", "(", ")", ",", "\n", "transform_batch", "=", "[", "\"batch_0\"", ",", "\"batch_1\"", "]", ",", "\n", ")", "\n", "\n", "latent_lib_size", "=", "model", ".", "get_latent_library_size", "(", "mdata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "assert", "latent_lib_size", ".", "shape", "==", "(", "3", ",", "1", ")", "\n", "\n", "pro_foreground_prob", "=", "model", ".", "get_protein_foreground_probability", "(", "\n", "mdata2", ",", "indices", "=", "[", "1", ",", "2", ",", "3", "]", ",", "protein_list", "=", "[", "\"1\"", ",", "\"2\"", "]", "\n", ")", "\n", "assert", "pro_foreground_prob", ".", "shape", "==", "(", "3", ",", "2", ")", "\n", "model", ".", "posterior_predictive_sample", "(", "mdata2", ")", "\n", "model", ".", "get_feature_correlation_matrix", "(", "mdata2", ")", "\n", "\n", "# test transfer_anndata_setup + view", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "model", ".", "get_elbo", "(", "mdata2", "[", ":", "10", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_auto_transfer": [[102, 117], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.get_elbo", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "def", "test_totalvi_auto_transfer", "(", "save_path", ")", ":", "\n", "# test automatic transfer_fields", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "mdata", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "model", ".", "get_elbo", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_incorrect_mapping": [[119, 136], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "pytest.raises", "scvi.model.TOTALVI.get_elbo", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "def", "test_totalvi_incorrect_mapping", "(", "save_path", ")", ":", "\n", "# test that we catch incorrect mappings", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "mdata", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_0\"", ",", "\"batch_10\"", "]", ",", "inplace", "=", "True", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", ".", "get_elbo", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_reordered_mapping": [[138, 154], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid.obs.batch.cat.rename_categories", "scvi.model.TOTALVI.get_elbo", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo"], ["", "", "def", "test_totalvi_reordered_mapping", "(", "save_path", ")", ":", "\n", "# test that same mapping different order is okay", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "mdata", ")", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "adata2", ".", "obs", ".", "batch", ".", "cat", ".", "rename_categories", "(", "[", "\"batch_1\"", ",", "\"batch_0\"", "]", ",", "inplace", "=", "True", ")", "\n", "model", ".", "get_elbo", "(", "mdata2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_missing_proteins": [[156, 176], ["scvi.data.pbmcs_10x_cite_seq", "anndata.AnnData", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.pbmcs_10x_cite_seq", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_totalvi_missing_proteins", "(", "save_path", ")", ":", "\n", "# test with missing proteins", "\n", "    ", "adata", "=", "scvi", ".", "data", ".", "pbmcs_10x_cite_seq", "(", "\n", "save_path", "=", "save_path", ",", "\n", "protein_join", "=", "\"outer\"", ",", "\n", ")", "\n", "protein_adata", "=", "AnnData", "(", "adata", ".", "obsm", "[", "\"protein_expression\"", "]", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "mdata", ")", "\n", "assert", "model", ".", "module", ".", "protein_batch_mask", "is", "not", "None", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "model", "=", "TOTALVI", "(", "mdata", ",", "override_missing_proteins", "=", "True", ")", "\n", "assert", "model", ".", "module", ".", "protein_batch_mask", "is", "None", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_model_library_size": [[178, 198], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI.get_elbo", "scvi.model.TOTALVI.get_marginal_ll", "scvi.model.TOTALVI.get_latent_library_size", "hasattr", "hasattr", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.model._amortizedlda.AmortizedLDA.get_elbo", "home.repos.pwc.inspect_result.YosefLab_scVI.model._autozi.AUTOZI.get_marginal_ll", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.get_latent_library_size"], ["", "def", "test_totalvi_model_library_size", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "\n", "n_latent", "=", "10", "\n", "model", "=", "TOTALVI", "(", "mdata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "False", ")", "\n", "assert", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "model", ".", "get_elbo", "(", ")", "\n", "model", ".", "get_marginal_ll", "(", "n_mc_samples", "=", "3", ")", "\n", "model", ".", "get_latent_library_size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_size_factor": [[200, 233], ["scvi.data.synthetic_iid", "numpy.random.randint", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "scvi.model.TOTALVI", "scvi.model.TOTALVI.train", "dict", "hasattr", "hasattr", "hasattr", "hasattr"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_totalvi_size_factor", "(", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "adata", ".", "obs", "[", "\"size_factor\"", "]", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ",", "size", "=", "(", "adata", ".", "shape", "[", "0", "]", ",", ")", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "size_factor_key", "=", "\"size_factor\"", ",", "\n", "modalities", "=", "dict", "(", "\n", "rna_layer", "=", "\"rna\"", ",", "\n", "batch_key", "=", "\"rna\"", ",", "\n", "protein_layer", "=", "\"protein\"", ",", "\n", "size_factor_key", "=", "\"rna\"", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "n_latent", "=", "10", "\n", "\n", "# Test size_factor_key overrides use_observed_lib_size.", "\n", "model", "=", "TOTALVI", "(", "mdata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "False", ")", "\n", "assert", "not", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "not", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "assert", "model", ".", "module", ".", "use_size_factor_key", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n", "model", "=", "TOTALVI", "(", "mdata", ",", "n_latent", "=", "n_latent", ",", "use_observed_lib_size", "=", "True", ")", "\n", "assert", "not", "hasattr", "(", "model", ".", "module", ",", "\"library_log_means\"", ")", "and", "not", "hasattr", "(", "\n", "model", ".", "module", ",", "\"library_log_vars\"", "\n", ")", "\n", "assert", "model", ".", "module", ".", "use_size_factor_key", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_mudata_models.test_totalvi_saving_and_loading": [[235, 295], ["scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "scvi.model.TOTALVI", "TOTALVI.load.train", "TOTALVI.load.get_latent_representation", "TOTALVI.load.save", "TOTALVI.load.view_setup_args", "scvi.model.TOTALVI.load", "TOTALVI.load.get_latent_representation", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid.obs[].cat.rename_categories", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.load", "TOTALVI.load.get_latent_representation", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "os.path.join", "scvi.data.synthetic_iid", "scvi.data.synthetic_iid", "mudata.MuData", "scvi.model.TOTALVI.setup_mudata", "pytest.raises", "scvi.model.TOTALVI.load", "pytest.raises", "scvi.model.TOTALVI.load", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.train._logger.SimpleExperiment.save", "home.repos.pwc.inspect_result.YosefLab_scVI.base._base_model.BaseModelClass.view_setup_args", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.get_latent_representation", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.setup_mudata", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load", "home.repos.pwc.inspect_result.YosefLab_scVI.gimvi._model.GIMVI.load"], ["", "def", "test_totalvi_saving_and_loading", "(", "save_path", ")", ":", "\n", "    ", "adata", "=", "synthetic_iid", "(", ")", "\n", "protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "adata", ",", "\"protein\"", ":", "protein_adata", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n", "model", "=", "TOTALVI", "(", "mdata", ")", "\n", "model", ".", "train", "(", "1", ",", "train_size", "=", "0.2", ")", "\n", "z1", "=", "model", ".", "get_latent_representation", "(", "mdata", ")", "\n", "test_idx1", "=", "model", ".", "validation_indices", "\n", "\n", "model", ".", "save", "(", "save_path", ",", "overwrite", "=", "True", ",", "save_anndata", "=", "True", ")", "\n", "model", ".", "view_setup_args", "(", "save_path", ")", "\n", "\n", "model", "=", "TOTALVI", ".", "load", "(", "save_path", ")", "\n", "model", ".", "get_latent_representation", "(", ")", "\n", "\n", "# Load with mismatched genes.", "\n", "tmp_adata", "=", "synthetic_iid", "(", "\n", "n_genes", "=", "200", ",", "\n", ")", "\n", "tmp_protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "tmp_mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "tmp_adata", ",", "\"protein\"", ":", "tmp_protein_adata", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "TOTALVI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_mdata", ")", "\n", "\n", "# Load with different batches.", "\n", "", "tmp_adata", "=", "synthetic_iid", "(", ")", "\n", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", "=", "tmp_adata", ".", "obs", "[", "\"batch\"", "]", ".", "cat", ".", "rename_categories", "(", "\n", "[", "\"batch_2\"", ",", "\"batch_3\"", "]", "\n", ")", "\n", "tmp_protein_adata", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "tmp_mdata", "=", "MuData", "(", "{", "\"rna\"", ":", "tmp_adata", ",", "\"protein\"", ":", "tmp_protein_adata", "}", ")", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "TOTALVI", ".", "load", "(", "save_path", ",", "adata", "=", "tmp_mdata", ")", "\n", "\n", "", "model", "=", "TOTALVI", ".", "load", "(", "save_path", ",", "adata", "=", "mdata", ")", "\n", "assert", "scvi", ".", "REGISTRY_KEYS", ".", "BATCH_KEY", "in", "model", ".", "adata_manager", ".", "data_registry", "\n", "assert", "model", ".", "adata_manager", ".", "data_registry", "[", "\"batch\"", "]", "==", "dict", "(", "\n", "mod_key", "=", "\"rna\"", ",", "attr_name", "=", "\"obs\"", ",", "attr_key", "=", "\"_scvi_batch\"", "\n", ")", "\n", "\n", "z2", "=", "model", ".", "get_latent_representation", "(", ")", "\n", "test_idx2", "=", "model", ".", "validation_indices", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "z1", ",", "z2", ")", "\n", "np", ".", "testing", ".", "assert_array_equal", "(", "test_idx1", ",", "test_idx2", ")", "\n", "assert", "model", ".", "is_trained", "is", "True", "\n", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"tmp\"", ")", "\n", "\n", "adata2", "=", "synthetic_iid", "(", ")", "\n", "protein_adata2", "=", "synthetic_iid", "(", "n_genes", "=", "50", ")", "\n", "mdata2", "=", "MuData", "(", "{", "\"rna\"", ":", "adata2", ",", "\"protein\"", ":", "protein_adata2", "}", ")", "\n", "TOTALVI", ".", "setup_mudata", "(", "\n", "mdata2", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "modalities", "=", "dict", "(", "rna_layer", "=", "\"rna\"", ",", "batch_key", "=", "\"rna\"", ",", "protein_layer", "=", "\"protein\"", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_lightning.test_save_best_state_callback": [[9, 16], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.train._callbacks.SaveBestState"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["def", "test_save_best_state_callback", "(", "save_path", ")", ":", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "callbacks", "=", "[", "SaveBestState", "(", "verbose", "=", "True", ")", "]", "\n", "model", ".", "train", "(", "3", ",", "check_val_every_n_epoch", "=", "1", ",", "train_size", "=", "0.5", ",", "callbacks", "=", "callbacks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_lightning.test_set_seed": [[18, 31], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "scvi.model.SCVI", "scvi.model.SCVI.train", "torch.equal"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train"], ["", "def", "test_set_seed", "(", "save_path", ")", ":", "\n", "    ", "scvi", ".", "settings", ".", "seed", "=", "1", "\n", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "adata", ",", "batch_key", "=", "\"batch\"", ",", "labels_key", "=", "\"labels\"", ")", "\n", "model1", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model1", ".", "train", "(", "1", ")", "\n", "scvi", ".", "settings", ".", "seed", "=", "1", "\n", "model2", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model2", ".", "train", "(", "1", ")", "\n", "assert", "torch", ".", "equal", "(", "\n", "model1", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ",", "\n", "model2", ".", "module", ".", "z_encoder", ".", "encoder", ".", "fc_layers", "[", "0", "]", "[", "0", "]", ".", "weight", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.core.test_differential.test_features": [[16, 50], ["numpy.random.randn", "numpy.concatenate", "scvi.model.base._differential.estimate_delta", "numpy.random.rand", "numpy.zeros", "numpy.random.rand", "numpy.zeros", "scvi.model.base._differential.estimate_pseudocounts_offset", "numpy.random.randn", "numpy.random.randn", "ValueError", "ValueError"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.estimate_delta", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.estimate_pseudocounts_offset"], ["def", "test_features", "(", ")", ":", "\n", "    ", "a", "=", "np", ".", "random", ".", "randn", "(", "\n", "100", ",", "\n", ")", "\n", "b", "=", "3", "+", "np", ".", "random", ".", "randn", "(", "\n", "100", ",", "\n", ")", "\n", "c", "=", "-", "3", "+", "np", ".", "random", ".", "randn", "(", "\n", "100", ",", "\n", ")", "\n", "alls", "=", "np", ".", "concatenate", "(", "[", "a", ",", "b", ",", "c", "]", ")", "\n", "delta", "=", "estimate_delta", "(", "alls", ")", "\n", "expected_range", "=", "(", "delta", ">=", "0.4", "*", "3", ")", "and", "(", "delta", "<=", "6", ")", "\n", "if", "not", "expected_range", ":", "\n", "        ", "raise", "ValueError", "(", "\"The effect-size threshold was not properly estimated.\"", ")", "\n", "\n", "", "scales_a", "=", "np", ".", "random", ".", "rand", "(", "100", ",", "50", ")", "\n", "where_zero_a", "=", "np", ".", "zeros", "(", "50", ",", "dtype", "=", "bool", ")", "\n", "where_zero_a", "[", ":", "10", "]", "=", "True", "\n", "scales_a", "[", ":", ",", ":", "10", "]", "=", "1e-6", "\n", "\n", "scales_b", "=", "np", ".", "random", ".", "rand", "(", "100", ",", "50", ")", "\n", "where_zero_b", "=", "np", ".", "zeros", "(", "50", ",", "dtype", "=", "bool", ")", "\n", "where_zero_b", "[", "-", "10", ":", "]", "=", "True", "\n", "scales_b", "[", ":", ",", "-", "10", ":", "]", "=", "1e-7", "\n", "offset", "=", "estimate_pseudocounts_offset", "(", "\n", "scales_a", "=", "scales_a", ",", "\n", "scales_b", "=", "scales_b", ",", "\n", "where_zero_a", "=", "where_zero_a", ",", "\n", "where_zero_b", "=", "where_zero_b", ",", "\n", ")", "\n", "expected_off_range", "=", "offset", "<=", "1e-6", "\n", "if", "not", "expected_off_range", ":", "\n", "        ", "raise", "ValueError", "(", "\"The pseudocount offset was not properly estimated.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.core.test_differential.test_differential_computation": [[52, 148], ["scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.train", "functools.partial", "scvi.model.base._differential.DifferentialComputation", "numpy.asarray", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.base._differential.DifferentialComputation.get_bayes_factors", "scvi.model.SCVI.differential_expression", "scvi.model.base._utils._prepare_obs", "scvi.model.SCVI.differential_expression", "scvi.model.SCVI.differential_expression", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.differential_expression", "scvi.data.synthetic_iid", "scvi.model.SCVI.setup_anndata", "scvi.model.SCVI", "scvi.model.SCVI.differential_expression", "pytest.raises", "scvi.model.SCVI.differential_expression", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.cellassign._model.CellAssign.train", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.base._differential.DifferentialComputation.get_bayes_factors", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.base._utils._prepare_obs", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.data._datasets.synthetic_iid", "home.repos.pwc.inspect_result.YosefLab_scVI.models.test_pyro.FunctionBasedPyroModel.setup_anndata", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression", "home.repos.pwc.inspect_result.YosefLab_scVI.model._totalvi.TOTALVI.differential_expression"], ["", "", "def", "test_differential_computation", "(", "save_path", ")", ":", "\n", "\n", "    ", "n_latent", "=", "5", "\n", "adata", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "adata", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "model", "=", "SCVI", "(", "adata", ",", "n_latent", "=", "n_latent", ")", "\n", "model", ".", "train", "(", "1", ")", "\n", "\n", "model_fn", "=", "partial", "(", "model", ".", "get_normalized_expression", ",", "return_numpy", "=", "True", ")", "\n", "dc", "=", "DifferentialComputation", "(", "model_fn", ",", "model", ".", "adata_manager", ")", "\n", "\n", "cell_idx1", "=", "np", ".", "asarray", "(", "adata", ".", "obs", ".", "labels", "==", "\"label_1\"", ")", "\n", "cell_idx2", "=", "~", "cell_idx1", "\n", "\n", "dc", ".", "get_bayes_factors", "(", "cell_idx1", ",", "cell_idx2", ",", "mode", "=", "\"vanilla\"", ",", "use_permutation", "=", "True", ")", "\n", "res", "=", "dc", ".", "get_bayes_factors", "(", "\n", "cell_idx1", ",", "cell_idx2", ",", "mode", "=", "\"change\"", ",", "use_permutation", "=", "False", "\n", ")", "\n", "assert", "(", "res", "[", "\"delta\"", "]", "==", "0.5", ")", "and", "(", "res", "[", "\"pseudocounts\"", "]", "==", "0.0", ")", "\n", "res", "=", "dc", ".", "get_bayes_factors", "(", "\n", "cell_idx1", ",", "cell_idx2", ",", "mode", "=", "\"change\"", ",", "use_permutation", "=", "False", ",", "delta", "=", "None", "\n", ")", "\n", "dc", ".", "get_bayes_factors", "(", "\n", "cell_idx1", ",", "\n", "cell_idx2", ",", "\n", "mode", "=", "\"change\"", ",", "\n", "use_permutation", "=", "False", ",", "\n", "delta", "=", "None", ",", "\n", "pseudocounts", "=", "None", ",", "\n", ")", "\n", "dc", ".", "get_bayes_factors", "(", "cell_idx1", ",", "cell_idx2", ",", "mode", "=", "\"change\"", ",", "cred_interval_lvls", "=", "[", "0.75", "]", ")", "\n", "\n", "delta", "=", "0.5", "\n", "\n", "def", "change_fn_test", "(", "x", ",", "y", ")", ":", "\n", "        ", "return", "x", "-", "y", "\n", "\n", "", "def", "m1_domain_fn_test", "(", "samples", ")", ":", "\n", "        ", "return", "np", ".", "abs", "(", "samples", ")", ">=", "delta", "\n", "\n", "", "dc", ".", "get_bayes_factors", "(", "\n", "cell_idx1", ",", "\n", "cell_idx2", ",", "\n", "mode", "=", "\"change\"", ",", "\n", "m1_domain_fn", "=", "m1_domain_fn_test", ",", "\n", "change_fn", "=", "change_fn_test", ",", "\n", ")", "\n", "\n", "# should fail if just one batch", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "model", ".", "differential_expression", "(", "adata", "[", ":", "20", "]", ",", "groupby", "=", "\"batch\"", ")", "\n", "\n", "# test view", "\n", "", "model", ".", "differential_expression", "(", "\n", "adata", "[", "adata", ".", "obs", "[", "\"labels\"", "]", "==", "\"label_1\"", "]", ",", "groupby", "=", "\"batch\"", "\n", ")", "\n", "\n", "# Test query features", "\n", "obs_col", ",", "group1", ",", "_", ",", "=", "_prepare_obs", "(", "\n", "idx1", "=", "\"(labels == 'label_1') & (batch == 'batch_1')\"", ",", "idx2", "=", "None", ",", "adata", "=", "adata", "\n", ")", "\n", "assert", "(", "obs_col", "==", "group1", ")", ".", "sum", "(", ")", "==", "adata", ".", "obs", ".", "loc", "[", "\n", "lambda", "x", ":", "(", "x", ".", "labels", "==", "\"label_1\"", ")", "&", "(", "x", ".", "batch", "==", "\"batch_1\"", ")", "\n", "]", ".", "shape", "[", "0", "]", "\n", "model", ".", "differential_expression", "(", "\n", "idx1", "=", "\"labels == 'label_1'\"", ",", "\n", ")", "\n", "model", ".", "differential_expression", "(", "\n", "idx1", "=", "\"labels == 'label_1'\"", ",", "idx2", "=", "\"(labels == 'label_2') & (batch == 'batch_1')\"", "\n", ")", "\n", "\n", "# test that ints as group work", "\n", "a", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "a", ".", "obs", "[", "\"test\"", "]", "=", "[", "0", "]", "*", "200", "+", "[", "1", "]", "*", "200", "\n", "model", "=", "SCVI", "(", "a", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"test\"", ",", "group1", "=", "0", ")", "\n", "\n", "# test that string but not as categorical work", "\n", "a", "=", "synthetic_iid", "(", ")", "\n", "SCVI", ".", "setup_anndata", "(", "\n", "a", ",", "\n", "batch_key", "=", "\"batch\"", ",", "\n", "labels_key", "=", "\"labels\"", ",", "\n", ")", "\n", "a", ".", "obs", "[", "\"test\"", "]", "=", "[", "\"0\"", "]", "*", "200", "+", "[", "\"1\"", "]", "*", "200", "\n", "model", "=", "SCVI", "(", "a", ")", "\n", "model", ".", "differential_expression", "(", "groupby", "=", "\"test\"", ",", "group1", "=", "\"0\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.YosefLab_scVI.core.test_distributions.test_deprecated_munkres": [[12, 24], ["numpy.array", "numpy.array", "scvi.model._metrics.unsupervised_clustering_accuracy", "numpy.array", "numpy.array", "scvi.model._metrics.unsupervised_clustering_accuracy", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.model._metrics.unsupervised_clustering_accuracy", "home.repos.pwc.inspect_result.YosefLab_scVI.model._metrics.unsupervised_clustering_accuracy"], ["def", "test_deprecated_munkres", "(", ")", ":", "\n", "    ", "y", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "y_pred", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "reward", ",", "assignment", "=", "unsupervised_clustering_accuracy", "(", "y", ",", "y_pred", ")", "\n", "assert", "reward", "==", "0.625", "\n", "assert", "(", "assignment", "==", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", "]", ")", ")", ".", "all", "(", ")", "\n", "\n", "y", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "2", ",", "2", ",", "0", ",", "0", ",", "3", ",", "3", "]", ")", "\n", "y_pred", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "0", ",", "0", "]", ")", "\n", "reward", ",", "assignment", "=", "unsupervised_clustering_accuracy", "(", "y", ",", "y_pred", ")", "\n", "assert", "reward", "==", "1.0", "\n", "assert", "(", "assignment", "==", "np", ".", "array", "(", "[", "[", "0", ",", "3", "]", ",", "[", "1", ",", "1", "]", ",", "[", "2", ",", "2", "]", ",", "[", "3", ",", "0", "]", "]", ")", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.YosefLab_scVI.core.test_distributions.test_zinb_distribution": [[26, 73], ["torch.randn_like", "torch.randint_like", "scvi.distributions._negative_binomial.log_zinb_positive", "scvi.distributions.ZeroInflatedNegativeBinomial", "scvi.distributions.NegativeBinomial.log_prob", "torch.manual_seed", "scvi.distributions.NegativeBinomial.sample", "scvi.distributions.NegativeBinomial.sample", "scvi.distributions._negative_binomial.log_nb_positive", "scvi.distributions.NegativeBinomial", "scvi.distributions.NegativeBinomial.log_prob", "scvi.distributions.NegativeBinomial.sample", "torch.randn_like", "torch.randint_like", "scvi.distributions.ZeroInflatedNegativeBinomial", "scvi.distributions.NegativeBinomial", "torch.rand", "torch.ones_like", "torch.rand", "torch.ones_like", "pytest.raises", "scvi.distributions.ZeroInflatedNegativeBinomial", "pytest.warns", "scvi.distributions.ZeroInflatedNegativeBinomial.log_prob", "pytest.warns", "scvi.distributions.NegativeBinomial.log_prob", "scvi.distributions.ZeroInflatedNegativeBinomial.log_prob", "scvi.distributions.NegativeBinomial.log_prob", "dist.sample.mean", "dist.sample.std"], "function", ["home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_zinb_positive", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.log_nb_positive", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.NegativeBinomialMixture.sample", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.log_prob", "home.repos.pwc.inspect_result.YosefLab_scVI.distributions._negative_binomial.JaxNegativeBinomialMeanDisp.mean"], ["", "def", "test_zinb_distribution", "(", ")", ":", "\n", "    ", "theta", "=", "100.0", "+", "torch", ".", "rand", "(", "size", "=", "(", "2", ",", ")", ")", "\n", "mu", "=", "15.0", "*", "torch", ".", "ones_like", "(", "theta", ")", "\n", "pi", "=", "torch", ".", "randn_like", "(", "theta", ")", "\n", "x", "=", "torch", ".", "randint_like", "(", "mu", ",", "high", "=", "20", ")", "\n", "log_p_ref", "=", "log_zinb_positive", "(", "x", ",", "mu", ",", "theta", ",", "pi", ")", "\n", "\n", "dist", "=", "ZeroInflatedNegativeBinomial", "(", "mu", "=", "mu", ",", "theta", "=", "theta", ",", "zi_logits", "=", "pi", ")", "\n", "log_p_zinb", "=", "dist", ".", "log_prob", "(", "x", ")", "\n", "assert", "(", "log_p_ref", "-", "log_p_zinb", ")", ".", "abs", "(", ")", ".", "max", "(", ")", ".", "item", "(", ")", "<=", "1e-8", "\n", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "s1", "=", "dist", ".", "sample", "(", "(", "100", ",", ")", ")", "\n", "assert", "s1", ".", "shape", "==", "(", "100", ",", "2", ")", "\n", "s2", "=", "dist", ".", "sample", "(", "sample_shape", "=", "(", "4", ",", "3", ")", ")", "\n", "assert", "s2", ".", "shape", "==", "(", "4", ",", "3", ",", "2", ")", "\n", "\n", "log_p_ref", "=", "log_nb_positive", "(", "x", ",", "mu", ",", "theta", ")", "\n", "dist", "=", "NegativeBinomial", "(", "mu", "=", "mu", ",", "theta", "=", "theta", ")", "\n", "log_p_nb", "=", "dist", ".", "log_prob", "(", "x", ")", "\n", "assert", "(", "log_p_ref", "-", "log_p_nb", ")", ".", "abs", "(", ")", ".", "max", "(", ")", ".", "item", "(", ")", "<=", "1e-8", "\n", "\n", "s1", "=", "dist", ".", "sample", "(", "(", "1000", ",", ")", ")", "\n", "assert", "s1", ".", "shape", "==", "(", "1000", ",", "2", ")", "\n", "assert", "(", "s1", ".", "mean", "(", "0", ")", "-", "mu", ")", ".", "abs", "(", ")", ".", "mean", "(", ")", "<=", "1e0", "\n", "assert", "(", "s1", ".", "std", "(", "0", ")", "-", "(", "mu", "+", "mu", "*", "mu", "/", "theta", ")", "**", "0.5", ")", ".", "abs", "(", ")", ".", "mean", "(", ")", "<=", "1e0", "\n", "\n", "size", "=", "(", "50", ",", "3", ")", "\n", "theta", "=", "100.0", "+", "torch", ".", "rand", "(", "size", "=", "size", ")", "\n", "mu", "=", "15.0", "*", "torch", ".", "ones_like", "(", "theta", ")", "\n", "pi", "=", "torch", ".", "randn_like", "(", "theta", ")", "\n", "x", "=", "torch", ".", "randint_like", "(", "mu", ",", "high", "=", "20", ")", "\n", "dist1", "=", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "mu", ",", "theta", "=", "theta", ",", "zi_logits", "=", "pi", ",", "validate_args", "=", "True", "\n", ")", "\n", "dist2", "=", "NegativeBinomial", "(", "mu", "=", "mu", ",", "theta", "=", "theta", ",", "validate_args", "=", "True", ")", "\n", "assert", "dist1", ".", "log_prob", "(", "x", ")", ".", "shape", "==", "size", "\n", "assert", "dist2", ".", "log_prob", "(", "x", ")", ".", "shape", "==", "size", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "ZeroInflatedNegativeBinomial", "(", "\n", "mu", "=", "-", "mu", ",", "theta", "=", "theta", ",", "zi_logits", "=", "pi", ",", "validate_args", "=", "True", "\n", ")", "\n", "", "with", "pytest", ".", "warns", "(", "UserWarning", ")", ":", "\n", "        ", "dist1", ".", "log_prob", "(", "-", "x", ")", "# ensures neg values raise warning", "\n", "", "with", "pytest", ".", "warns", "(", "UserWarning", ")", ":", "\n", "        ", "dist2", ".", "log_prob", "(", "0.5", "*", "x", ")", "# ensures float values raise warning", "\n", "", "", ""]]}