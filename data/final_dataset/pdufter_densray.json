{"home.repos.pwc.inspect_result.pdufter_densray.utils.download_data.download": [[16, 24], ["urllib.request.urlretrieve", "os.stat", "print", "print", "Exception"], "function", ["None"], ["def", "download", "(", "filename", ",", "url", ",", "expected_bytes", ")", ":", "\n", "    ", "filename", ",", "_", "=", "urllib", ".", "request", ".", "urlretrieve", "(", "url", ",", "filename", ")", "\n", "statinfo", "=", "os", ".", "stat", "(", "filename", ")", "\n", "if", "statinfo", ".", "st_size", "==", "expected_bytes", ":", "\n", "        ", "print", "(", "'Downloaded and verified {}.'", ".", "format", "(", "url", ")", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "statinfo", ".", "st_size", ")", "\n", "raise", "Exception", "(", "'Failed to verify {}.'", ".", "format", "(", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.str2bool": [[8, 15], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.dump_class": [[17, 21], ["open", "pickle.dump", "os.path.exists"], "function", ["None"], ["", "", "def", "dump_class", "(", "cls", ",", "fname", ")", ":", "\n", "    ", "assert", "not", "os", ".", "path", ".", "exists", "(", "fname", ")", ",", "\"File \"", "+", "fname", "+", "\" exists already.\"", "\n", "outfile", "=", "open", "(", "fname", ",", "'wb'", ")", "\n", "pickle", ".", "dump", "(", "cls", ",", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.load_class": [[23, 26], ["open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.load"], ["", "def", "load_class", "(", "fname", ")", ":", "\n", "    ", "infile", "=", "open", "(", "fname", ",", "'rb'", ")", "\n", "return", "pickle", ".", "load", "(", "infile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.store": [[28, 31], ["open", "os.path.exists"], "function", ["None"], ["", "def", "store", "(", "path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "path", ")", "==", "0", ",", "path", "+", "\" exists already.\"", "\n", "return", "open", "(", "path", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.read": [[33, 35], ["open"], "function", ["None"], ["", "def", "read", "(", "path", ")", ":", "\n", "    ", "return", "open", "(", "path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.dump_dict": [[37, 42], ["open", "json.dump", "open.close", "os.path.exists"], "function", ["None"], ["", "def", "dump_dict", "(", "dict_", ",", "fname", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "fname", ")", "==", "0", ",", "fname", "+", "\" exists already.\"", "\n", "outfile", "=", "open", "(", "fname", ",", "'w'", ")", "\n", "json", ".", "dump", "(", "dict_", ",", "outfile", ",", "default", "=", "lambda", "x", ":", "\"<not_serializable>\"", ")", "\n", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.invdict": [[44, 48], ["dict", "len", "len", "ValueError", "set", "dict_.values", "dict_.values", "dict_.items"], "function", ["None"], ["", "def", "invdict", "(", "dict_", ")", ":", "\n", "    ", "if", "len", "(", "set", "(", "dict_", ".", "values", "(", ")", ")", ")", "!=", "len", "(", "dict_", ".", "values", "(", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Values in dict are not unique, cannot reverse.\"", ")", "\n", "", "return", "dict", "(", "[", "(", "v", ",", "k", ")", "for", "k", ",", "v", "in", "dict_", ".", "items", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.utils.utils.get_logger": [[50, 68], ["logging.getLogger", "logging.getLogger.setLevel", "logging.FileHandler", "logging.StreamHandler", "logging.FileHandler.setLevel", "logging.StreamHandler.setLevel", "logging.Formatter", "logging.FileHandler.setFormatter", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.getLogger.addHandler"], "function", ["None"], ["", "def", "get_logger", "(", "name", ",", "filename", ",", "level", "=", "logging", ".", "DEBUG", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "level", ")", "\n", "\n", "fh", "=", "logging", ".", "FileHandler", "(", "filename", ")", "\n", "ch", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "\n", "fh", ".", "setLevel", "(", "level", ")", "\n", "ch", ".", "setLevel", "(", "level", ")", "\n", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "'%(asctime)s - %(name)s - %(levelname)s - %(message)s'", ")", "\n", "fh", ".", "setFormatter", "(", "formatter", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "return", "logger", "\n", "", ""]], "home.repos.pwc.inspect_result.pdufter_densray.debiasing.debiasing.plot_bias": [[82, 100], ["matplotlib.subplots", "ax.scatter", "ax.plot", "dict", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.savefig", "matplotlib.clf", "professions.index", "ax.annotate", "dict"], "function", ["None"], ["def", "plot_bias", "(", "simthing", ",", "outfile", ",", "annotate", ",", "professions", ")", ":", "\n", "    ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "scatter", "(", "simthing", "[", "0", "]", ",", "simthing", "[", "1", "]", ",", "c", "=", "'b'", ",", "marker", "=", "'x'", ")", "\n", "#ax.plot(np.arange(-1, 1, 0.01), np.arange(-1, 1, 0.01), color='grey')", "\n", "ax", ".", "plot", "(", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "ls", "=", "\"--\"", ",", "c", "=", "\".3\"", ")", "\n", "bbox_props", "=", "dict", "(", "boxstyle", "=", "\"round\"", ",", "fc", "=", "\"w\"", ",", "ec", "=", "\"0.5\"", ",", "alpha", "=", "0.9", ")", "\n", "\n", "for", "name", "in", "annotate", ":", "\n", "        ", "idx", "=", "professions", ".", "index", "(", "name", ")", "\n", "name", "=", "name", "+", "\"\\n({:.2f}, {:.2f})\"", ".", "format", "(", "simthing", "[", "0", "]", "[", "idx", "]", ",", "simthing", "[", "1", "]", "[", "idx", "]", ")", "\n", "ax", ".", "annotate", "(", "name", ",", "(", "simthing", "[", "0", "]", "[", "idx", "]", ",", "simthing", "[", "1", "]", "[", "idx", "]", ")", ",", "xytext", "=", "(", "3", "*", "(", "simthing", "[", "0", "]", "[", "idx", "]", "-", "0.25", ")", "+", "0.25", ",", "3", "*", "(", "simthing", "[", "1", "]", "[", "idx", "]", "-", "0.25", ")", "+", "0.25", ")", ",", "\n", "arrowprops", "=", "dict", "(", "facecolor", "=", "'black'", ",", "shrink", "=", "0.01", ",", "width", "=", "1.0", ",", "headwidth", "=", "0.5", ")", ",", "bbox", "=", "bbox_props", ")", "\n", "", "plt", ".", "xlabel", "(", "\"Similarity to 'man'\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Similarity to 'woman'\"", ")", "\n", "plt", ".", "xlim", "(", "(", "-", "0.25", ",", "0.8", ")", ")", "\n", "plt", ".", "ylim", "(", "(", "-", "0.25", ",", "0.8", ")", ")", "\n", "plt", ".", "savefig", "(", "outfile", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Densifier.__init__": [[25, 41], ["os.path.exists"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ",", "Embeddings", ",", "Ltrain", ",", "Ltest", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            log: a logger object\n            Embeddings: a embedding object\n            Ltrain: lexicon object with training dictionary\n            Ltest: lexicon object with test dictionary\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "embed", "=", "Embeddings", "\n", "self", ".", "Ltrain", "=", "Ltrain", "\n", "self", ".", "Ltest", "=", "Ltest", "\n", "self", ".", "matlab_path", "=", "\"/mounts/Users/cisintern/philipp/Dokumente/FeatureCat/\"", "\n", "assert", "os", ".", "path", ".", "exists", "(", "\n", "self", ".", "matlab_path", ")", ",", "\"No Matlab implementation for Densifer found. Please clone git@github.com:pdufter/FeatureCat.git and specify the corresponding directory in this class.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Densifier.prepare_data": [[42, 57], ["model.Densifier.embed.store", "model.Densifier.Ltrain.store", "model.Densifier.Ltest.store"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store", "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store", "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store"], ["", "def", "prepare_data", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Stores the training data on disk to make it accessible to matlab\n\n        Args:\n            path: path where to store the data\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "embedding_path", "=", "self", ".", "path", "+", "\",matlab,matlab,embeddings.txt\"", "\n", "self", ".", "ltrain_path", "=", "self", ".", "path", "+", "\",matlab,matlab,trainlexicon.txt\"", "\n", "self", ".", "ltest_path", "=", "self", ".", "path", "+", "\",matlab,matlab,testlexicon.txt\"", "\n", "self", ".", "embed", ".", "store", "(", "self", ".", "embedding_path", ")", "\n", "self", ".", "Ltrain", ".", "store", "(", "self", ".", "ltrain_path", ",", "version", "=", "'countable'", ")", "\n", "self", ".", "Ltest", ".", "store", "(", "self", ".", "ltest_path", ",", "version", "=", "self", ".", "Ltest", ".", "version", ")", "\n", "self", ".", "line_count", "=", "self", ".", "embed", ".", "X", ".", "shape", "[", "0", "]", "+", "1", "\n", "self", ".", "outfilename", "=", "self", ".", "path", "+", "\",matlab,matlab.predictions\"", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Densifier.fit_predict": [[58, 67], ["model.Densifier.log.info", "os.system"], "methods", ["None"], ["", "def", "fit_predict", "(", "self", ")", ":", "\n", "        ", "\"\"\"Calls the matlabl implementation through the command line\n\n        The output of matlab is store on disk.\n        \"\"\"", "\n", "self", ".", "log", ".", "info", "(", "\"Calling Densifier through commandline.\"", ")", "\n", "command", "=", "\"\"\"matlab -r 'addpath(\\\"{}\\\");FeatureCat(\\\"{}\\\", {}, \\\"{}\\\", \\\"{}\\\", \\\"{}\\\");quit;' \"\"\"", ".", "format", "(", "\n", "self", ".", "matlab_path", ",", "self", ".", "embedding_path", ",", "self", ".", "line_count", ",", "self", ".", "ltrain_path", ",", "self", ".", "ltest_path", ",", "self", ".", "outfilename", ")", "\n", "os", ".", "system", "(", "command", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.__init__": [[77, 88], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ",", "Embeddings", ",", "Lexicon", ")", ":", "\n", "        ", "\"\"\"Initialize DensRay\n\n        Args:\n            log: logger object\n            Embeddings: embedding object\n            Lexicon: the lexicon which is used to fit DensRay\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "embed", "=", "Embeddings", "\n", "self", ".", "lexic", "=", "Lexicon", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.fit": [[89, 110], ["model.DensRay.compute_trafo", "model.DensRay.prepare_data_binary", "model.DensRay.computeA_binary_part1", "model.DensRay.computeA_binary_part2", "model.DensRay.prepare_data_continuous", "model.DensRay.computeA_continuous"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.compute_trafo", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.prepare_data_binary", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_binary_part1", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_binary_part2", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.prepare_data_continuous", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_continuous"], ["", "def", "fit", "(", "self", ",", "weights", "=", "None", ",", "model", "=", "'binary'", ",", "normalize_D", "=", "True", ",", "normalize_labels", "=", "True", ")", ":", "\n", "        ", "\"\"\"Fit DensRay\n\n        Args:\n            weights: only for binary model; how to weight the two\n                summands; if none: apply dynamic weighting. Example input: [1.0, 1.0]\n            model: 'binary' or 'continuous'; which model version of Densray to use\n            normalize_D: bool whether to normalize the difference vectors with l2 norm\n            normalize_labels: bool whether to normalize the predicted labels.\n        \"\"\"", "\n", "if", "model", "==", "'binary'", ":", "\n", "            ", "self", ".", "prepare_data_binary", "(", ")", "\n", "self", ".", "computeA_binary_part1", "(", "normalize_D", "=", "normalize_D", ")", "\n", "self", ".", "computeA_binary_part2", "(", "weights", "=", "weights", ")", "\n", "", "elif", "model", "==", "'continuous'", ":", "\n", "            ", "self", ".", "prepare_data_continuous", "(", ")", "\n", "self", ".", "computeA_continuous", "(", "\n", "normalize_D", "=", "normalize_D", ",", "normalize_labels", "=", "normalize_labels", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "self", ".", "compute_trafo", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.prepare_data_binary": [[111, 132], ["set", "len", "indexpos.append", "indexneg.append", "model.DensRay.embed.W.index", "model.DensRay.embed.W.index"], "methods", ["None"], ["", "def", "prepare_data_binary", "(", "self", ")", ":", "\n", "        ", "\"\"\"Data preparation function for the binary model\n\n        It selects the relevant vectors from the embedding space.\n        \"\"\"", "\n", "Lrel", "=", "[", "(", "k", ",", "v", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "lexic", ".", "L", "[", "'countable'", "]", "if", "k", "in", "self", ".", "embed", ".", "Wset", "]", "\n", "values", "=", "set", "(", "[", "v", "for", "k", ",", "v", "in", "Lrel", "]", ")", "\n", "assert", "len", "(", "values", ")", "==", "2", "\n", "v1", ",", "v2", "=", "values", "\n", "indexpos", "=", "[", "]", "\n", "indexneg", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "Lrel", ":", "\n", "            ", "if", "v", "==", "v1", ":", "\n", "                ", "indexpos", ".", "append", "(", "self", ".", "embed", ".", "W", ".", "index", "(", "k", ")", ")", "\n", "", "else", ":", "\n", "                ", "indexneg", ".", "append", "(", "self", ".", "embed", ".", "W", ".", "index", "(", "k", ")", ")", "\n", "", "", "self", ".", "Xpos", "=", "self", ".", "embed", ".", "X", "[", "indexpos", ",", ":", "]", "\n", "self", ".", "Xneg", "=", "self", ".", "embed", ".", "X", "[", "indexneg", ",", ":", "]", "\n", "self", ".", "npos", "=", "self", ".", "Xpos", ".", "shape", "[", "0", "]", "\n", "self", ".", "nneg", "=", "self", ".", "Xneg", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.prepare_data_continuous": [[133, 147], ["numpy.array", "len", "model.DensRay.log.warning", "model.DensRay.embed.W.index"], "methods", ["None"], ["", "def", "prepare_data_continuous", "(", "self", ")", ":", "\n", "        ", "\"\"\"Data preparation function for the continuous model\n\n        It selects the relevant vectors from the embedding space.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "lexic", ".", "L", "[", "'continuous'", "]", ")", "==", "0", ":", "\n", "            ", "self", ".", "log", ".", "warning", "(", "\n", "\"No continuous labels available, using countable labels instead.\"", ")", "\n", "self", ".", "lexic", ".", "L", "[", "'continuous'", "]", "=", "self", ".", "lexic", ".", "L", "[", "'countable'", "]", "\n", "", "self", ".", "Wrel", "=", "[", "k", "for", "k", ",", "v", "in", "self", ".", "lexic", ".", "L", "[", "'continuous'", "]", "\n", "if", "k", "in", "self", ".", "embed", ".", "Wset", "]", "\n", "self", ".", "scoresrel", "=", "np", ".", "array", "(", "\n", "[", "v", "for", "k", ",", "v", "in", "self", ".", "lexic", ".", "L", "[", "'continuous'", "]", "if", "k", "in", "self", ".", "Wrel", "]", ")", "\n", "self", ".", "Xrel", "=", "self", ".", "embed", ".", "X", "[", "[", "self", ".", "embed", ".", "W", ".", "index", "(", "x", ")", "for", "x", "in", "self", ".", "Wrel", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_binary": [[148, 162], ["D.transpose().dot", "v.transpose", "numpy.linalg.norm", "D.transpose"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "outer_product_sub_binary", "(", "v", ",", "M", ",", "normD", ")", ":", "\n", "        ", "\"\"\"Helper function to compute the sum of outer products\n\n        While it is not very readable, it is more efficient than\n        a brute force implementation.\n        \"\"\"", "\n", "D", "=", "v", ".", "transpose", "(", ")", "-", "M", "\n", "if", "normD", ":", "\n", "            ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "D", ",", "axis", "=", "1", ")", "\n", "D", "[", "norm", "==", "0.0", "]", "=", "0.0", "\n", "norm", "[", "norm", "==", "0.0", "]", "=", "1.0", "\n", "D", "=", "D", "/", "norm", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "return", "D", ".", "transpose", "(", ")", ".", "dot", "(", "D", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_continuous": [[163, 179], ["D1.transpose().dot", "v.transpose", "numpy.linalg.norm", "D1.transpose"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "outer_product_sub_continuous", "(", "v", ",", "M", ",", "i", ",", "gammas", ",", "normD", ")", ":", "\n", "        ", "\"\"\"Helper function to compute the sum of outer products\n\n        While it is not very readable, it is more efficient than\n        a brute force implementation.\n        \"\"\"", "\n", "D", "=", "v", ".", "transpose", "(", ")", "-", "M", "\n", "gamma", "=", "gammas", "[", "i", "]", "*", "gammas", "\n", "if", "normD", ":", "\n", "            ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "D", ",", "axis", "=", "1", ")", "\n", "D", "[", "norm", "==", "0.0", "]", "=", "0.0", "\n", "norm", "[", "norm", "==", "0.0", "]", "=", "1.0", "\n", "D", "=", "D", "/", "norm", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "D1", "=", "gamma", "[", ":", ",", "np", ".", "newaxis", "]", "*", "D", "\n", "return", "D1", ".", "transpose", "(", ")", ".", "dot", "(", "D", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.store": [[180, 187], ["numpy.save"], "methods", ["None"], ["", "def", "store", "(", "self", ",", "fname", ")", ":", "\n", "        ", "\"\"\"Stores the transformation in npy format.\n\n        Args:\n            fname: path where to store the transformation.\n        \"\"\"", "\n", "np", ".", "save", "(", "fname", ",", "self", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_binary_part1": [[188, 212], ["numpy.zeros", "numpy.zeros", "tqdm.tqdm.tqdm", "tqdm.tqdm.tqdm", "range", "model.DensRay.Xpos[].transpose", "model.DensRay.outer_product_sub_binary", "model.DensRay.outer_product_sub_binary", "range", "model.DensRay.Xneg[].transpose", "model.DensRay.outer_product_sub_binary", "model.DensRay.outer_product_sub_binary"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_binary", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_binary", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_binary", "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_binary"], ["", "def", "computeA_binary_part1", "(", "self", ",", "normalize_D", "=", "True", ")", ":", "\n", "        ", "\"\"\"First part of computing the matrix A.\n\n        Args:\n            normalize_D: bool whether to normalize the difference vectors with l2 norm.\n\n        Todo:\n            can be made more efficient (dot product is symmetric and we compute both directions here)\n        \"\"\"", "\n", "dim", "=", "self", ".", "Xpos", ".", "shape", "[", "1", "]", "\n", "self", ".", "A_equal", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "self", ".", "A_unequal", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "for", "ipos", "in", "tqdm", "(", "range", "(", "self", ".", "npos", ")", ",", "desc", "=", "\"compute matrix part1\"", ",", "leave", "=", "False", ")", ":", "\n", "            ", "v", "=", "self", ".", "Xpos", "[", "ipos", ":", "ipos", "+", "1", ",", ":", "]", ".", "transpose", "(", ")", "\n", "self", ".", "A_equal", "+=", "self", ".", "outer_product_sub_binary", "(", "\n", "v", ",", "self", ".", "Xpos", ",", "normalize_D", ")", "\n", "self", ".", "A_unequal", "+=", "self", ".", "outer_product_sub_binary", "(", "\n", "v", ",", "self", ".", "Xneg", ",", "normalize_D", ")", "\n", "", "for", "ineg", "in", "tqdm", "(", "range", "(", "self", ".", "nneg", ")", ",", "desc", "=", "\"compute matrix part2\"", ",", "leave", "=", "False", ")", ":", "\n", "            ", "v", "=", "self", ".", "Xneg", "[", "ineg", ":", "ineg", "+", "1", ",", ":", "]", ".", "transpose", "(", ")", "\n", "self", ".", "A_equal", "+=", "self", ".", "outer_product_sub_binary", "(", "\n", "v", ",", "self", ".", "Xneg", ",", "normalize_D", ")", "\n", "self", ".", "A_unequal", "+=", "self", ".", "outer_product_sub_binary", "(", "\n", "v", ",", "self", ".", "Xpos", ",", "normalize_D", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_binary_part2": [[213, 229], ["model.DensRay.A_unequal.max", "model.DensRay.A_equal.max", "max", "max"], "methods", ["None"], ["", "", "def", "computeA_binary_part2", "(", "self", ",", "weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"Second part of computing the matrix A.\n\n        Args:\n            weights: only for binary model; how to weight the two \n                summands; if none: apply dynamic weighting. Example input: [1.0, 1.0]\n        \"\"\"", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "weights", "=", "[", "1", "/", "(", "2", "*", "self", ".", "npos", "*", "self", ".", "nneg", ")", ",", "1", "/", "\n", "(", "self", ".", "npos", "**", "2", "+", "self", ".", "nneg", "**", "2", ")", "]", "\n", "# normalize matrices for numerical reasons", "\n", "# note that this does not change the eigenvectors", "\n", "", "n1", "=", "self", ".", "A_unequal", ".", "max", "(", ")", "\n", "n2", "=", "self", ".", "A_equal", ".", "max", "(", ")", "\n", "weights", "=", "[", "weights", "[", "0", "]", "/", "max", "(", "n1", ",", "n2", ")", ",", "weights", "[", "1", "]", "/", "max", "(", "n1", ",", "n2", ")", "]", "\n", "self", ".", "A", "=", "weights", "[", "0", "]", "*", "self", ".", "A_unequal", "-", "weights", "[", "1", "]", "*", "self", ".", "A_equal", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.computeA_continuous": [[230, 250], ["numpy.zeros", "tqdm.tqdm.tqdm", "enumerate", "model.DensRay.Xrel[].transpose", "model.DensRay.outer_product_sub_continuous", "model.DensRay.A.max", "gammas.std", "gammas.mean"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.outer_product_sub_continuous"], ["", "def", "computeA_continuous", "(", "self", ",", "normalize_D", "=", "True", ",", "normalize_labels", "=", "True", ")", ":", "\n", "        ", "\"\"\"Compute the matrix A for the continuous case.\n\n        Args:\n            normalize_D: normalize_D: bool whether to normalize the difference vectors with l2 norm.\n            normalize_labels: bool whether to normalize the predicted labels.\n\n        Todo:\n            can be made more efficient (dot product is symmetric and we compute both directions here)\n        \"\"\"", "\n", "dim", "=", "self", ".", "Xrel", ".", "shape", "[", "1", "]", "\n", "self", ".", "A", "=", "np", ".", "zeros", "(", "(", "dim", ",", "dim", ")", ")", "\n", "gammas", "=", "self", ".", "scoresrel", "\n", "if", "normalize_labels", ":", "\n", "            ", "gammas", "=", "(", "gammas", "-", "gammas", ".", "mean", "(", ")", ")", "/", "gammas", ".", "std", "(", ")", "\n", "", "for", "i", ",", "w", "in", "tqdm", "(", "enumerate", "(", "self", ".", "Wrel", ")", ",", "desc", "=", "\"compute matrix\"", ",", "leave", "=", "False", ")", ":", "\n", "            ", "v", "=", "self", ".", "Xrel", "[", "i", ":", "i", "+", "1", ",", ":", "]", ".", "transpose", "(", ")", "\n", "self", ".", "A", "+=", "self", ".", "outer_product_sub_continuous", "(", "\n", "v", ",", "self", ".", "Xrel", ",", "i", ",", "gammas", ",", "normalize_D", ")", "\n", "", "self", ".", "A", "=", "-", "self", ".", "A", "/", "self", ".", "A", ".", "max", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.DensRay.compute_trafo": [[251, 265], ["numpy.linalg.eigh", "numpy.allclose", "model.DensRay.eigvals.argsort", "model.DensRay.T.transpose().dot", "numpy.eye", "model.DensRay.T.transpose"], "methods", ["None"], ["", "def", "compute_trafo", "(", "self", ")", ":", "\n", "        ", "\"\"\"Given A, this function computes the actual Transformation.\n\n        It essentially just does an eigenvector decomposition.\n        \"\"\"", "\n", "# note that (eigvecs(A) = eigvecs (A'A))", "\n", "# when using eigh the are always real", "\n", "self", ".", "eigvals", ",", "self", ".", "eigvecs", "=", "np", ".", "linalg", ".", "eigh", "(", "self", ".", "A", ")", "\n", "# need to sort the eigenvalues", "\n", "idx", "=", "self", ".", "eigvals", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "self", ".", "eigvals", ",", "self", ".", "eigvecs", "=", "self", ".", "eigvals", "[", "idx", "]", ",", "self", ".", "eigvecs", "[", ":", ",", "idx", "]", "\n", "self", ".", "T", "=", "self", ".", "eigvecs", "\n", "assert", "np", ".", "allclose", "(", "self", ".", "T", ".", "transpose", "(", ")", ".", "dot", "(", "self", ".", "T", ")", ",", "np", ".", "eye", "(", "\n", "self", ".", "T", ".", "shape", "[", "0", "]", ")", ")", ",", "\"self.T not orthonormal.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.__init__": [[275, 286], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ",", "Embeddings", ",", "Lexicon", ")", ":", "\n", "        ", "\"\"\"Initialize the Regression\n\n        Args:\n            log: logger object\n            Embeddings: embedding object\n            Lexicon: the lexicon which is used to fit the model\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "embed", "=", "Embeddings", "\n", "self", ".", "lexic", "=", "Lexicon", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.prepare_data": [[287, 324], ["numpy.array", "sum", "numpy.random.choice", "idxs.extend", "ys.extend", "words.extend", "ValueError", "idxs.append", "ys.append", "words.append", "len", "model.Regression.embed.W.index"], "methods", ["None"], ["", "def", "prepare_data", "(", "self", ",", "model", ",", "add_random_words", "=", "False", ")", ":", "\n", "        ", "\"\"\"Prepare the data (i.e. select vectors and create labels)\n\n        Args:\n            model: string; a value in [\"logistic\", \"svm\", \"linear\", \"svr\", \"cca\"]\n        \"\"\"", "\n", "if", "model", "in", "[", "\"logistic\"", ",", "\"svm\"", "]", ":", "\n", "            ", "version", "=", "'countable'", "\n", "", "elif", "model", "in", "[", "\"linear\"", ",", "\"svr\"", ",", "\"cca\"", "]", ":", "\n", "            ", "version", "=", "self", ".", "lexic", ".", "version", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Model unknown.\"", ")", "\n", "", "idxs", "=", "[", "]", "\n", "ys", "=", "[", "]", "\n", "words", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "self", ".", "lexic", ".", "L", "[", "version", "]", ":", "\n", "            ", "if", "k", "in", "self", ".", "embed", ".", "Wset", ":", "\n", "                ", "idxs", ".", "append", "(", "self", ".", "embed", ".", "W", ".", "index", "(", "k", ")", ")", "\n", "ys", ".", "append", "(", "v", ")", "\n", "words", ".", "append", "(", "k", ")", "\n", "", "", "if", "add_random_words", ":", "\n", "            ", "n_add", "=", "sum", "(", "[", "y", "==", "1", "for", "y", "in", "ys", "]", ")", "\n", "idx_to_add", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "embed", ".", "Wset", ")", ",", "n_add", ")", "\n", "words_to_add", "=", "[", "self", ".", "embed", ".", "W", "[", "x", "]", "for", "x", "in", "idx_to_add", "]", "\n", "ys_to_add", "=", "[", "0", "]", "*", "n_add", "\n", "\n", "idxs", ".", "extend", "(", "idx_to_add", ")", "\n", "ys", ".", "extend", "(", "ys_to_add", ")", "\n", "words", ".", "extend", "(", "words_to_add", ")", "\n", "\n", "", "self", ".", "Wrel", "=", "words", "\n", "self", ".", "Xrel", "=", "self", ".", "embed", ".", "X", "[", "idxs", ",", ":", "]", "\n", "self", ".", "Yrel", "=", "np", ".", "array", "(", "ys", ")", "\n", "if", "model", "==", "'logistic'", ":", "\n", "            ", "self", ".", "Yrel", "[", "self", ".", "Yrel", "==", "-", "1", "]", "=", "0", "\n", "", "if", "model", "==", "'svm'", ":", "\n", "            ", "self", ".", "Yrel", "[", "self", ".", "Yrel", "==", "0", "]", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.fit": [[325, 356], ["model.Regression.mod.fit", "scipy.linalg.null_space", "numpy.hstack", "numpy.allclose", "sklearn.linear_model.LinearRegression", "len", "w0.reshape.reshape.reshape", "numpy.linalg.norm", "model.Regression.T.transpose().dot", "numpy.eye", "sklearn.linear_model.LogisticRegression", "w0.reshape.reshape.transpose", "sklearn.svm.SVR", "model.Regression.T.transpose", "sklearn.svm.SVC", "sklearn.cross_decomposition.CCA"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.fit"], ["", "", "def", "fit", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Fits the model and creates a (random) orthogonal transformation.\n\n        Args:\n            model: string; a value in [\"logistic\", \"svm\", \"linear\", \"svr\", \"cca\"]\n        \"\"\"", "\n", "if", "model", "==", "'linear'", ":", "\n", "            ", "self", ".", "mod", "=", "LinearRegression", "(", ")", "\n", "", "elif", "model", "==", "'logistic'", ":", "\n", "            ", "self", ".", "mod", "=", "LogisticRegression", "(", "\n", "penalty", "=", "'none'", ",", "class_weight", "=", "'balanced'", ",", "solver", "=", "'saga'", ")", "\n", "#self.mod = LogisticRegression()", "\n", "", "elif", "model", "==", "'svr'", ":", "\n", "            ", "self", ".", "mod", "=", "SVR", "(", "kernel", "=", "'linear'", ")", "\n", "", "elif", "model", "==", "'svm'", ":", "\n", "            ", "self", ".", "mod", "=", "SVC", "(", "C", "=", "1.0", ",", "kernel", "=", "'linear'", ")", "\n", "", "elif", "model", "==", "'cca'", ":", "\n", "            ", "self", ".", "mod", "=", "CCA", "(", "n_components", "=", "1", ",", "scale", "=", "True", ",", "\n", "max_iter", "=", "500", ",", "tol", "=", "1e-06", ",", "copy", "=", "True", ")", "\n", "self", ".", "mod", ".", "intercept_", "=", "0.0", "\n", "", "self", ".", "mod", ".", "fit", "(", "self", ".", "Xrel", ",", "self", ".", "Yrel", ")", "\n", "# now compute T with a random orthogonal basis", "\n", "# todo potential bug: what to do with the intercept_?", "\n", "w0", "=", "self", ".", "mod", ".", "coef_", "# + self.mod.intercept_", "\n", "if", "len", "(", "w0", ".", "shape", ")", "<", "2", ":", "\n", "            ", "w0", "=", "w0", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "", "w0", "=", "w0", "/", "np", ".", "linalg", ".", "norm", "(", "w0", ")", "\n", "Wcompl", "=", "null_space", "(", "w0", ")", "\n", "self", ".", "T", "=", "np", ".", "hstack", "(", "(", "w0", ".", "transpose", "(", ")", ",", "Wcompl", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "self", ".", "T", ".", "transpose", "(", ")", ".", "dot", "(", "self", ".", "T", ")", ",", "np", ".", "eye", "(", "\n", "self", ".", "T", ".", "shape", "[", "0", "]", ")", ")", ",", "\"self.T not orthonormal.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.store": [[357, 364], ["numpy.save"], "methods", ["None"], ["", "def", "store", "(", "self", ",", "fname", ")", ":", "\n", "        ", "\"\"\"Stores the transformation in npy format.\n\n        Args:\n            fname: path where to store the transformation.\n        \"\"\"", "\n", "np", ".", "save", "(", "fname", ",", "self", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.LexIndPredictor.__init__": [[370, 383], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ",", "embeddings", ",", "queries", ",", "T", ")", ":", "\n", "        ", "\"\"\"Initialize the predictor.\n\n        Args:\n            log: logger object\n            embeddings: word embedding object\n            queries: list of strings with queries\n            T: np.array; linear transformation\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "embeds", "=", "embeddings", "\n", "self", ".", "queries", "=", "queries", "\n", "self", ".", "T", "=", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.LexIndPredictor.predict": [[384, 405], ["model.LexIndPredictor.embeds.X.dot", "model.LexIndPredictor.predictions.append", "len", "range", "model.LexIndPredictor.embeds.W.index", "model.LexIndPredictor.embeds.W.index"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "method", ",", "dim_weights", "=", "None", ")", ":", "\n", "        ", "\"\"\"Predict scores for the query words.\n\n        Args:\n            method: string; either \"first_dimension\", \"first_n_dimensions\"\n            dim_weights: only available if method == \"first_n_dimensions\"; how to weight the scores in the first n dimensions.\n        \"\"\"", "\n", "X_trafo", "=", "self", ".", "embeds", ".", "X", ".", "dot", "(", "self", ".", "T", ")", "\n", "self", ".", "predictions", "=", "[", "]", "\n", "for", "k", "in", "self", ".", "queries", ":", "\n", "            ", "if", "k", "not", "in", "self", ".", "embeds", ".", "Wset", ":", "\n", "                ", "continue", "\n", "", "if", "method", "==", "'first_dimension'", ":", "\n", "                ", "score", "=", "X_trafo", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "k", ")", ",", "0", "]", "\n", "", "elif", "method", "==", "'first_n_dimensions'", ":", "\n", "                ", "n", "=", "len", "(", "dim_weights", ")", "\n", "score", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                    ", "score", "+=", "dim_weights", "[", "i", "]", "*", "X_trafo", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "k", ")", ",", "i", "]", "\n", "", "", "self", ".", "predictions", ".", "append", "(", "(", "k", ",", "score", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.LexIndPredictor.store": [[406, 416], ["utils.utils.store", "utils.utils.store.close", "utils.utils.store.write"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store"], ["", "", "def", "store", "(", "self", ",", "fname", ")", ":", "\n", "        ", "\"\"\"Stores the predictions in a text file.\n\n        Args:\n            fname: path where to store the predictions.\n        \"\"\"", "\n", "outfile", "=", "store", "(", "fname", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "predictions", ":", "\n", "            ", "outfile", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.__init__": [[422, 434], ["model.AnalogyPredictor.filter_analogies"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.filter_analogies"], ["def", "__init__", "(", "self", ",", "log", ",", "embeddings", ",", "analogies", ",", "donotfilter", "=", "False", ")", ":", "\n", "        ", "\"\"\"Initialize the predictor.\n\n        Args:\n            log: logger object\n            embeddings: word embedding object\n            analogies: list of analogy pairs on which to train the predictor\n            donotfilter: if false, consider only analogy pairs where query and answer are contained in the embeddings\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "embeds", "=", "embeddings", "\n", "self", ".", "ana", "=", "self", ".", "filter_analogies", "(", "analogies", ",", "donotfilter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.get_lexicon": [[435, 453], ["set", "data.data.Lexicon", "model.AnalogyPredictor.lex.L[].append", "model.AnalogyPredictor.lex.L[].append"], "methods", ["None"], ["", "def", "get_lexicon", "(", "self", ",", "remove_words", "=", "set", "(", ")", ")", ":", "\n", "        ", "\"\"\"Prepare the training data.\n\n        Converts the analogy pairs into a lexicon\n        to enable training of an SVM, DensRay, etc.\n        \"\"\"", "\n", "self", ".", "lex", "=", "Lexicon", "(", "self", ".", "log", ")", "\n", "self", ".", "lex", ".", "version", "=", "'countable'", "\n", "self", ".", "lex", ".", "L", "[", "'countable'", "]", "=", "[", "]", "\n", "for", "tup", "in", "self", ".", "ana", ":", "\n", "            ", "if", "tup", "[", "0", "]", "not", "in", "remove_words", ":", "\n", "                ", "self", ".", "lex", ".", "L", "[", "'countable'", "]", ".", "append", "(", "(", "tup", "[", "0", "]", ",", "1", ")", ")", "\n", "\n", "# Just use the first word for training.", "\n", "", "for", "w", "in", "tup", "[", "1", "]", ":", "\n", "                ", "if", "w", "not", "in", "remove_words", ":", "\n", "                    ", "self", ".", "lex", ".", "L", "[", "'countable'", "]", ".", "append", "(", "(", "w", ",", "-", "1", ")", ")", "\n", "", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.fit_classifier": [[454, 503], ["model.AnalogyPredictor.embeds.X.dot", "model.Regression", "DensRay.prepare_data", "model.DensRay.fit", "data.data.Embeddings", "model.Regression", "model.Regression.prepare_data", "model.Regression.fit", "model.DensRay", "model.DensRay.fit", "Regression.mod.predict_proba", "model.AnalogyPredictor.embeds.W.index", "model.AnalogyPredictor.embeds.W.index", "scores.min", "scores.max", "scores.min", "DensRay.mod.predict_proba"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.prepare_data", "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.fit", "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.prepare_data", "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.fit", "home.repos.pwc.inspect_result.pdufter_densray.model.model.Regression.fit"], ["", "", "", "def", "fit_classifier", "(", "self", ",", "modeltype", ",", "model", ",", "add_lr_classifier", "=", "False", ")", ":", "\n", "        ", "\"\"\"Fit the chosen model.\n\n        Args:\n            modeltype: \"regression\" or \"densray\"\n            model: for \"densray\" one in [\"binary\", \"continuous\"]; for \"regression\" one in [\"logistic\", \"svm\", \"linear\", \"svr\", \"cca\"]\n            add_lr_classifier: whether to add an additional logistic regression to get probabilistic scores.\n        \"\"\"", "\n", "if", "modeltype", "==", "\"regression\"", ":", "\n", "            ", "trafo", "=", "Regression", "(", "self", ".", "log", ",", "self", ".", "embeds", ",", "self", ".", "lex", ")", "\n", "trafo", ".", "prepare_data", "(", "model", ")", "\n", "trafo", ".", "fit", "(", "model", ")", "\n", "T", "=", "trafo", ".", "T", "\n", "if", "model", "==", "\"logistic\"", ":", "\n", "                ", "self", ".", "scores_prob", "=", "trafo", ".", "mod", ".", "predict_proba", "(", "self", ".", "embeds", ".", "X", ")", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "scores_prob", "=", "None", "\n", "", "", "elif", "modeltype", "==", "\"densray\"", ":", "\n", "            ", "trafo", "=", "DensRay", "(", "self", ".", "log", ",", "self", ".", "embeds", ",", "self", ".", "lex", ")", "\n", "trafo", ".", "fit", "(", "weights", "=", "None", ",", "model", "=", "model", ",", "\n", "normalize_D", "=", "True", ",", "normalize_labels", "=", "False", ")", "\n", "T", "=", "trafo", ".", "T", "\n", "self", ".", "scores_prob", "=", "None", "\n", "\n", "", "X_trafo", "=", "self", ".", "embeds", ".", "X", ".", "dot", "(", "T", ")", "\n", "self", ".", "X_trafo", "=", "X_trafo", "\n", "scores", "=", "X_trafo", "[", ":", ",", "0", "]", "\n", "self", ".", "X_compl", "=", "X_trafo", "[", ":", ",", "1", ":", "]", "\n", "\n", "add_lr_classifier", "=", "True", "\n", "if", "add_lr_classifier", ":", "\n", "            ", "aux_embeds", "=", "Embeddings", "(", "self", ".", "log", ")", "\n", "aux_embeds", ".", "W", "=", "self", ".", "embeds", ".", "W", "\n", "aux_embeds", ".", "Wset", "=", "self", ".", "embeds", ".", "Wset", "\n", "aux_embeds", ".", "X", "=", "X_trafo", "[", ":", ",", "0", ":", "1", "]", "\n", "\n", "aux_trafo", "=", "Regression", "(", "self", ".", "log", ",", "aux_embeds", ",", "self", ".", "lex", ")", "\n", "aux_trafo", ".", "prepare_data", "(", "\"logistic\"", ")", "\n", "aux_trafo", ".", "fit", "(", "\"logistic\"", ")", "\n", "self", ".", "scores_prob", "=", "aux_trafo", ".", "mod", ".", "predict_proba", "(", "aux_embeds", ".", "X", ")", "[", ":", ",", "0", "]", "\n", "\n", "# potentially invert scores", "\n", "", "sc0", "=", "scores", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "self", ".", "ana", "[", "0", "]", "[", "0", "]", ")", "]", "\n", "sc1", "=", "scores", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "self", ".", "ana", "[", "0", "]", "[", "1", "]", "[", "0", "]", ")", "]", "\n", "if", "sc0", ">", "sc1", ":", "\n", "            ", "scores", "=", "-", "scores", "\n", "# normalize", "\n", "", "self", ".", "scores", "=", "(", "scores", "-", "scores", ".", "min", "(", ")", ")", "/", "(", "scores", ".", "max", "(", ")", "-", "scores", ".", "min", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.predict": [[504, 556], ["collections.defaultdict", "model.AnalogyPredictor.embeds.W.index", "len", "enumerate", "sklearn.metrics.pairwise.cosine_similarity", "sklearn.metrics.pairwise.cosine_similarity", "numpy.multiply", "numpy.multiply.argsort", "w_candidate.lower", "query.lower"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "queries", ",", "method", "=", "None", ",", "use_compl", "=", "None", ",", "use_prob", "=", "None", ")", ":", "\n", "        ", "\"\"\"Given queries, complete the analogies.\n\n        Args:\n            queries: list of strings with the query words\n            method: \"clcomp\" or \"lrcos\"; this just steers meaningful combinations of the remaining boolean parameters\n            use_compl: whether to consider distance in the complementary embedding space\n            use_prob: whether to use the probability score (only availbale for logistic regression)\n\n        Returns:\n            list of tuples [(query1, prediction1), (query2, prediction2), ...]\n        \"\"\"", "\n", "if", "method", "==", "'clcomp'", ":", "\n", "            ", "use_compl", "=", "True", "\n", "use_prob", "=", "False", "\n", "", "elif", "method", "==", "\"lrcos\"", ":", "\n", "            ", "use_compl", "=", "False", "\n", "use_prob", "=", "True", "\n", "", "elif", "method", "is", "None", ":", "\n", "            ", "assert", "use_compl", "is", "not", "None", "and", "use_prob", "is", "not", "None", ",", "\"Please provide a method to predict analogies.\"", "\n", "\n", "", "pred", "=", "defaultdict", "(", "lambda", ":", "\"<NONE>\"", ")", "\n", "rel_queries", "=", "[", "x", "for", "x", "in", "queries", "if", "x", "in", "self", ".", "embeds", ".", "Wset", "]", "\n", "queries_index", "=", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "x", ")", "for", "x", "in", "rel_queries", "]", "\n", "\n", "if", "len", "(", "rel_queries", ")", "!=", "0", ":", "\n", "            ", "if", "use_compl", ":", "\n", "                ", "queries_vec", "=", "self", ".", "X_compl", "[", "queries_index", ",", ":", "]", "\n", "sim", "=", "cosine_similarity", "(", "queries_vec", ",", "self", ".", "X_compl", ")", "\n", "", "else", ":", "\n", "                ", "queries_vec", "=", "self", ".", "embeds", ".", "X", "[", "queries_index", ",", ":", "]", "\n", "sim", "=", "cosine_similarity", "(", "queries_vec", ",", "self", ".", "embeds", ".", "X", ")", "\n", "\n", "", "if", "use_prob", ":", "\n", "                ", "assert", "self", ".", "scores_prob", "is", "not", "None", ",", "\"prob scores only available with logistics regression.\"", "\n", "scores", "=", "self", ".", "scores_prob", "\n", "", "else", ":", "\n", "                ", "scores", "=", "self", ".", "scores", "\n", "\n", "", "for", "i", ",", "query", "in", "enumerate", "(", "rel_queries", ")", ":", "\n", "# multiply both scores and get word with highest score", "\n", "                ", "new_scores", "=", "np", ".", "multiply", "(", "scores", ",", "sim", "[", "i", ",", ":", "]", ")", "\n", "new_scores_sorted", "=", "new_scores", ".", "argsort", "(", ")", "\n", "w_candidate", "=", "query", "\n", "r", "=", "0", "\n", "while", "w_candidate", ".", "lower", "(", ")", "==", "query", ".", "lower", "(", ")", ":", "\n", "                    ", "r", "+=", "1", "\n", "candidate", "=", "new_scores_sorted", "[", "-", "r", "]", "\n", "w_candidate", "=", "self", ".", "embeds", ".", "W", "[", "candidate", "]", "\n", "", "pred", "[", "query", "]", "=", "w_candidate", "\n", "\n", "", "", "return", "[", "(", "q", ",", "pred", "[", "q", "]", ")", "for", "q", "in", "queries", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.is_answerable": [[557, 569], ["None"], "methods", ["None"], ["", "def", "is_answerable", "(", "self", ",", "pair", ")", ":", "\n", "        ", "\"\"\"Decides whether a analogy pair is answerable.\n\n        A pair is answerable if both member of the analogy are contained in the wordspace\n\n        Args:\n            pair: analogy pair in the BATS format (a, (a'1, a'2, ...))\n\n        Returns:\n            bool: true if pair is answerable, else false\n        \"\"\"", "\n", "return", "pair", "[", "0", "]", "in", "self", ".", "embeds", ".", "Wset", "and", "pair", "[", "1", "]", "[", "0", "]", "in", "self", ".", "embeds", ".", "Wset", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.filter_analogies": [[570, 581], ["model.AnalogyPredictor.is_answerable"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.is_answerable"], ["", "def", "filter_analogies", "(", "self", ",", "analogies", ",", "donotfilter", ")", ":", "\n", "        ", "\"\"\"Filters a list of analogies for answerability.\n\n        Args:\n            analogies: list of analogy pairs in the BATS format\n            donotfilter: if false, consider only analogy pairs where query and answer are contained in the embeddings\n\n        Returns:\n            filtered list of analogy pairs in the BATS format\n        \"\"\"", "\n", "return", "[", "pair", "for", "pair", "in", "analogies", "if", "self", ".", "is_answerable", "(", "pair", ")", "or", "donotfilter", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.model.model.AnalogyPredictor.get_distances": [[582, 612], ["numpy.diag", "sklearn.metrics.pairwise.cosine_similarity", "sklearn.metrics.pairwise.cosine_similarity", "sklearn.metrics.pairwise.cosine_similarity", "range", "model.AnalogyPredictor.embeds.W.index", "model.AnalogyPredictor.embeds.W.index", "sklearn.metrics.pairwise.cosine_similarity", "sklearn.metrics.pairwise.cosine_similarity.argsort", "sklearn.metrics.pairwise.cosine_similarity.flatten", "sklearn.metrics.pairwise.cosine_similarity.flatten", "ranks.append", "ranks.append", "[].index", "list"], "methods", ["None"], ["", "def", "get_distances", "(", "self", ")", ":", "\n", "        ", "\"\"\"Provides some analysis for the training analogies.\n\n        Returns:\n            ranks: list of ranks (rank 3 means the answer to the analog is the third nearest neighbour to the query)\n            intersim: list of similarities between analogy pairs\n            intrasim0: list of similarities within the left class of analogy pairs\n            intrasim1: list of similarities within the right class of analogy pairs\n        \"\"\"", "\n", "q0", "=", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "x", "[", "0", "]", ")", "for", "x", "in", "self", ".", "ana", "]", "\n", "q1", "=", "[", "self", ".", "embeds", ".", "W", ".", "index", "(", "x", "[", "1", "]", "[", "0", "]", ")", "for", "x", "in", "self", ".", "ana", "]", "\n", "\n", "v0", "=", "self", ".", "embeds", ".", "X", "[", "q0", ",", ":", "]", "\n", "v1", "=", "self", ".", "embeds", ".", "X", "[", "q1", ",", ":", "]", "\n", "\n", "intersim", "=", "np", ".", "diag", "(", "cosine_similarity", "(", "v0", ",", "v1", ")", ")", "\n", "intrasim0", "=", "cosine_similarity", "(", "v0", ",", "v0", ")", "\n", "intrasim1", "=", "cosine_similarity", "(", "v1", ",", "v1", ")", "\n", "# compute ranks between query and answer", "\n", "rel_sim", "=", "cosine_similarity", "(", "v0", ",", "self", ".", "embeds", ".", "X", ")", "\n", "consider_max_n", "=", "200", "\n", "mynns", "=", "rel_sim", ".", "argsort", "(", "axis", "=", "1", ")", "[", ":", ",", "-", "consider_max_n", ":", "]", "\n", "ranks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "mynns", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "q1", "[", "i", "]", "not", "in", "mynns", "[", "i", ",", ":", "]", ":", "\n", "                ", "ranks", ".", "append", "(", "consider_max_n", ")", "\n", "", "else", ":", "\n", "                ", "ranks", ".", "append", "(", "list", "(", "mynns", "[", "i", ",", ":", "]", ")", "[", ":", ":", "-", "1", "]", ".", "index", "(", "q1", "[", "i", "]", ")", ")", "\n", "# todo return lists and not np.arrays", "\n", "", "", "return", "ranks", ",", "intersim", ",", "intrasim0", ".", "flatten", "(", ")", ",", "intrasim1", ".", "flatten", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Embeddings.__init__": [[20, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            log: a logger object\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Embeddings.load": [[28, 60], ["data.Embeddings.log.info", "open", "tqdm.tqdm.tqdm", "list", "set", "numpy.vstack", "data.Embeddings.log.info", "map", "line.rstrip().split", "list", "data.keys", "tuple", "open.readline().split", "map", "len", "line.rstrip", "open.readline"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "path", ",", "load_first_n", "=", "None", ",", "header", "=", "True", ")", ":", "\n", "        ", "\"\"\"Load word embeddings in word2vec format from a txt file.\n\n        Args:\n            path: path to the embedding file\n            load_first_n: int; how many lines to load\n            header: bool; whether the embedding file contains a header line\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "log", ".", "info", "(", "\"loading embeddings: {}\"", ".", "format", "(", "self", ".", "path", ")", ")", "\n", "\n", "fin", "=", "open", "(", "self", ".", "path", ",", "'r'", ")", "\n", "\n", "if", "header", ":", "\n", "            ", "n", ",", "d", "=", "map", "(", "int", ",", "fin", ".", "readline", "(", ")", ".", "split", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "n", ",", "d", "=", "None", ",", "None", "\n", "\n", "", "data", "=", "{", "}", "\n", "count", "=", "0", "\n", "for", "line", "in", "tqdm", "(", "fin", ")", ":", "\n", "            ", "count", "+=", "1", "\n", "if", "load_first_n", "is", "not", "None", "and", "count", ">", "load_first_n", ":", "\n", "                ", "break", "\n", "", "tokens", "=", "line", ".", "rstrip", "(", ")", ".", "split", "(", "' '", ")", "\n", "data", "[", "tokens", "[", "0", "]", "]", "=", "list", "(", "map", "(", "float", ",", "tokens", "[", "1", ":", "]", ")", ")", "\n", "\n", "", "self", ".", "W", "=", "list", "(", "data", ".", "keys", "(", ")", ")", "\n", "self", ".", "Wset", "=", "set", "(", "self", ".", "W", ")", "\n", "self", ".", "X", "=", "np", ".", "vstack", "(", "tuple", "(", "[", "data", "[", "x", "]", "for", "x", "in", "self", ".", "W", "]", ")", ")", "\n", "\n", "self", ".", "log", ".", "info", "(", "\"loaded {} / {} vectors with dimension {}.\"", ".", "format", "(", "len", "(", "self", ".", "W", ")", ",", "n", ",", "self", ".", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Embeddings.normalize": [[61, 65], ["data.Embeddings.X.transpose", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "normalize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Normalize the embeddings with l2 norm\n        \"\"\"", "\n", "self", ".", "X", "=", "(", "self", ".", "X", ".", "transpose", "(", ")", "/", "np", ".", "linalg", ".", "norm", "(", "self", ".", "X", ",", "axis", "=", "1", ")", ")", ".", "transpose", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Embeddings.filter": [[66, 84], ["set", "list", "set", "data.Embeddings.log.info", "choose.append", "choose.append", "numpy.array", "len", "len"], "methods", ["None"], ["", "def", "filter", "(", "self", ",", "relevant", ")", ":", "\n", "        ", "\"\"\"Filter the embeddings to contain only words from \"relevant\".\n\n        Args:\n            relevant: iterable of words which should be kept\n        \"\"\"", "\n", "relevant", "=", "set", "(", "relevant", ")", "\n", "choose", "=", "[", "]", "\n", "for", "word", "in", "self", ".", "W", ":", "\n", "            ", "if", "word", "in", "relevant", ":", "\n", "                ", "choose", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "                ", "choose", ".", "append", "(", "False", ")", "\n", "", "", "self", ".", "W", "=", "list", "(", "np", ".", "array", "(", "self", ".", "W", ")", "[", "choose", "]", ")", "\n", "self", ".", "Wset", "=", "set", "(", "self", ".", "W", ")", "\n", "self", ".", "X", "=", "self", ".", "X", "[", "choose", "]", "\n", "\n", "self", ".", "log", ".", "info", "(", "\"filtered for {} / {} words.\"", ".", "format", "(", "len", "(", "relevant", ")", ",", "len", "(", "self", ".", "W", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Embeddings.store": [[85, 100], ["utils.utils.store", "utils.utils.store.write", "range", "utils.utils.store.close", "utils.utils.store.write", "range", "utils.utils.store.write", "utils.utils.store.write"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store"], ["", "def", "store", "(", "self", ",", "fname", ")", ":", "\n", "        ", "\"\"\"Store the embedding space\n\n        Args:\n            fname: path to the file\n        \"\"\"", "\n", "outfile", "=", "store", "(", "fname", ")", "\n", "n", ",", "dim", "=", "self", ".", "X", ".", "shape", "\n", "outfile", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "n", ",", "dim", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "outfile", ".", "write", "(", "self", ".", "W", "[", "i", "]", ")", "\n", "for", "k", "in", "range", "(", "dim", ")", ":", "\n", "                ", "outfile", ".", "write", "(", "\" {}\"", ".", "format", "(", "self", ".", "X", "[", "i", ",", "k", "]", ")", ")", "\n", "", "outfile", ".", "write", "(", "\"\\n\"", ")", "\n", "", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.__init__": [[109, 119], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ")", ":", "\n", "        ", "\"\"\"Initalize the lexicon\n\n        Args:\n            log: a logger object\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "L", "=", "{", "\"countable\"", ":", "[", "]", ",", "\n", "\"ranked\"", ":", "[", "]", ",", "\n", "\"continuous\"", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.filter_words": [[120, 131], ["set", "data.Lexicon.log.info", "len", "len"], "methods", ["None"], ["", "def", "filter_words", "(", "self", ",", "relevant", ")", ":", "\n", "        ", "\"\"\"Filter the lexicon to contain only words from \"relevant\".\n\n        Args:\n            relevant: iterable of words which should be kept\n        \"\"\"", "\n", "relevant", "=", "set", "(", "relevant", ")", "\n", "for", "version", "in", "self", ".", "L", ":", "\n", "            ", "tmp", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "version", "]", "if", "k", "in", "relevant", "]", "\n", "self", ".", "log", ".", "info", "(", "\"Filtering lexicon: {} / {} remaining.\"", ".", "format", "(", "len", "(", "tmp", ")", ",", "len", "(", "self", ".", "L", "[", "version", "]", ")", ")", ")", "\n", "self", ".", "L", "[", "version", "]", "=", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.load": [[132, 156], ["open", "enumerate", "data.Lexicon.log.info", "line.replace.replace.replace", "line[].strip", "float", "lexicon.append", "len", "line.replace.replace.split", "data.Lexicon.log.warning", "len"], "methods", ["None"], ["", "", "def", "load", "(", "self", ",", "path", ",", "version", ")", ":", "\n", "        ", "\"\"\"Load a lexicon from a file.\n\n        Args:\n            path: input path; one line looks like \"word\\sscore\\n\"\n            version: whether the lexicon is countable, continuous or a ranking; countable has binary (integer) values, continuous float values and ranking reflects a ranking, but the actual values are irrelevant.\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "infile", "=", "open", "(", "self", ".", "path", ",", "'r'", ")", "\n", "lexicon", "=", "[", "]", "\n", "count", "=", "0", "\n", "for", "i", ",", "line", "in", "enumerate", "(", "infile", ")", ":", "\n", "            ", "count", "+=", "1", "\n", "line", "=", "line", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", "\n", "try", ":", "\n", "                ", "score", "=", "line", ".", "split", "(", ")", "[", "-", "1", "]", "\n", "word", "=", "line", "[", ":", "-", "len", "(", "score", ")", "]", ".", "strip", "(", ")", "\n", "score", "=", "float", "(", "score", ")", "\n", "lexicon", ".", "append", "(", "(", "word", ",", "score", ")", ")", "\n", "", "except", ":", "\n", "                ", "self", ".", "log", ".", "warning", "(", "\"Unexpected format in line {} from {}\"", ".", "format", "(", "i", ",", "self", ".", "path", ")", ")", "\n", "", "", "self", ".", "log", ".", "info", "(", "\"loaded {} / {} lexicon entries.\"", ".", "format", "(", "len", "(", "lexicon", ")", ",", "count", ")", ")", "\n", "self", ".", "L", "[", "version", "]", "=", "lexicon", "\n", "self", ".", "version", "=", "version", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.remove_inconsistencies": [[157, 177], ["collections.defaultdict", "set", "data.Lexicon.log.info", "data.Lexicon.log.info", "list", "values[].append", "seen.items", "len", "collections.defaultdict.items", "len", "len", "len", "set"], "methods", ["None"], ["", "def", "remove_inconsistencies", "(", "self", ",", "remove_all", "=", "False", ")", ":", "\n", "        ", "\"\"\"Remove potential inconsistencies from the lexicon.\n\n        Args:\n            remove_all: whether to remove all instances of the inconcistency or keep one instance (the first one).\n        \"\"\"", "\n", "if", "remove_all", ":", "\n", "            ", "values", "=", "defaultdict", "(", "list", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "L", "[", "self", ".", "version", "]", ":", "\n", "                ", "values", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "", "inconsistencies", "=", "set", "(", "[", "k", "for", "k", ",", "v", "in", "values", ".", "items", "(", ")", "if", "len", "(", "set", "(", "v", ")", ")", ">", "1", "]", ")", "\n", "self", ".", "log", ".", "info", "(", "\"Removed {} inconsistencies.\"", ".", "format", "(", "len", "(", "inconsistencies", ")", ")", ")", "\n", "self", ".", "L", "[", "self", ".", "version", "]", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "self", ".", "version", "]", "if", "k", "not", "in", "inconsistencies", "]", "\n", "", "else", ":", "\n", "            ", "seen", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "L", "[", "self", ".", "version", "]", ":", "\n", "                ", "if", "k", "not", "in", "seen", ":", "\n", "                    ", "seen", "[", "k", "]", "=", "v", "\n", "", "", "self", ".", "log", ".", "info", "(", "\"Removed {} inconsistencies.\"", ".", "format", "(", "len", "(", "self", ".", "L", "[", "self", ".", "version", "]", ")", "-", "len", "(", "seen", ")", ")", ")", "\n", "self", ".", "L", "[", "self", ".", "version", "]", "=", "list", "(", "seen", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.binarise": [[178, 207], ["data.Lexicon.filter_words", "int", "numpy.median", "float", "tmp.append", "float", "float", "tmp.append"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.filter_words"], ["", "", "def", "binarise", "(", "self", ",", "mymap", "=", "None", ",", "neg", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"Get a binary version of the lexicon and store it in \"countable\"\n\n        Args:\n            mymap: map from integers to binary values\n            neg: interval (e.g. [-float('inf'), 0]) which continuous scores are considered as \"-1\"; if None us identidy map.\n            pos: same as neg for \"1\"; if None use median as threshold.\n        \"\"\"", "\n", "if", "self", ".", "version", "==", "'countable'", ":", "\n", "            ", "if", "mymap", "is", "None", ":", "\n", "                ", "mymap", "=", "{", "1", ":", "1", ",", "-", "1", ":", "-", "1", "}", "\n", "# filter relevant words", "\n", "", "self", ".", "L", "[", "\"countable\"", "]", "=", "[", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "\"countable\"", "]", "if", "v", "in", "mymap", "]", "\n", "self", ".", "L", "[", "\"countable\"", "]", "=", "[", "(", "k", ",", "int", "(", "mymap", "[", "v", "]", ")", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "\"countable\"", "]", "]", "\n", "", "elif", "self", ".", "version", "==", "'continuous'", ":", "\n", "            ", "if", "neg", "is", "None", "or", "pos", "is", "None", ":", "\n", "# use median", "\n", "                ", "median", "=", "np", ".", "median", "(", "[", "v", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", "]", ")", "\n", "neg", "=", "[", "-", "float", "(", "'inf'", ")", ",", "median", "]", "\n", "pos", "=", "[", "median", ",", "float", "(", "'inf'", ")", "]", "\n", "", "relevant", "=", "[", "k", "for", "k", ",", "v", "in", "self", ".", "L", "[", "\"continuous\"", "]", "if", "(", "neg", "[", "0", "]", "<=", "v", "<", "neg", "[", "1", "]", ")", "or", "(", "pos", "[", "0", "]", "<=", "v", "<", "pos", "[", "1", "]", ")", "]", "\n", "self", ".", "filter_words", "(", "relevant", ")", "\n", "tmp", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", ":", "\n", "                ", "if", "neg", "[", "0", "]", "<=", "v", "<=", "neg", "[", "1", "]", ":", "\n", "                    ", "tmp", ".", "append", "(", "(", "k", ",", "-", "1", ")", ")", "\n", "", "elif", "pos", "[", "0", "]", "<=", "float", "(", "v", ")", "<=", "pos", "[", "1", "]", ":", "\n", "                    ", "tmp", ".", "append", "(", "(", "k", ",", "1", ")", ")", "\n", "", "", "self", ".", "L", "[", "'countable'", "]", "=", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.compute_ranks": [[208, 216], ["data.Lexicon.log.info", "sorted", "len", "len", "set", "len", "enumerate"], "methods", ["None"], ["", "", "def", "compute_ranks", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get a ranked version of the lexicon and store it in \"ranked\"\n        \"\"\"", "\n", "# check number of ties", "\n", "n_ties", "=", "len", "(", "self", ".", "L", "[", "self", ".", "version", "]", ")", "-", "len", "(", "set", "(", "[", "v", "for", "k", ",", "v", "in", "self", ".", "L", "[", "self", ".", "version", "]", "]", ")", ")", "\n", "self", ".", "log", ".", "info", "(", "\"Computing ranks. No. of ties: {} / {}\"", ".", "format", "(", "n_ties", ",", "len", "(", "self", ".", "L", "[", "self", ".", "version", "]", ")", ")", ")", "\n", "tmp", "=", "sorted", "(", "self", ".", "L", "[", "self", ".", "version", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "self", ".", "L", "[", "'ranked'", "]", "=", "[", "(", "k", ",", "i", ")", "for", "i", ",", "(", "k", ",", "_", ")", "in", "enumerate", "(", "tmp", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.store": [[217, 235], ["utils.utils.store", "utils.utils.store.close", "utils.utils.store", "utils.utils.store.close", "utils.utils.store.write", "utils.utils.store.write"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store", "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store"], ["", "def", "store", "(", "self", ",", "fname", ",", "version", "=", "None", ")", ":", "\n", "        ", "\"\"\"Store the lexicon.\n\n        Args:\n            fname: path where to store\n            version: if given, just store the specific version of the lexicon.\n        \"\"\"", "\n", "if", "version", "is", "None", ":", "\n", "            ", "for", "version", "in", "self", ".", "L", ":", "\n", "                ", "outfile", "=", "store", "(", "fname", "+", "\"_\"", "+", "version", "+", "\".txt\"", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "L", "[", "version", "]", ":", "\n", "                    ", "outfile", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "", "outfile", ".", "close", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "outfile", "=", "store", "(", "fname", ")", "\n", "for", "k", ",", "v", "in", "self", ".", "L", "[", "version", "]", ":", "\n", "                ", "outfile", ".", "write", "(", "\"{} {}\\n\"", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.normalize": [[236, 242], ["min", "max"], "methods", ["None"], ["", "", "def", "normalize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Min-Max Normalize the continuous lexicon.\n        \"\"\"", "\n", "score_min", "=", "min", "(", "[", "v", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", "]", ")", "\n", "score_max", "=", "max", "(", "[", "v", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", "]", ")", "\n", "self", ".", "L", "[", "'continuous'", "]", "=", "[", "(", "k", ",", "(", "v", "-", "score_min", ")", "/", "(", "score_max", "-", "score_min", ")", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Lexicon.invert": [[243, 247], ["None"], "methods", ["None"], ["", "def", "invert", "(", "self", ")", ":", "\n", "        ", "\"\"\"Invert the continuous lexicon.\n        \"\"\"", "\n", "self", ".", "L", "[", "'continuous'", "]", "=", "[", "(", "k", ",", "-", "v", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "'continuous'", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.GoogleAnalogy.__init__": [[253, 260], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            log: a logger object\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.GoogleAnalogy.load": [[261, 281], ["open", "collections.defaultdict", "line.replace.replace.replace", "line.replace.replace.split", "list", "[].strip", "set", "set", "line.replace.replace.split"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Load the Analogy Dataset\n\n        Args:\n            path: path to the dataset\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "infile", "=", "open", "(", "self", ".", "path", ",", "'r'", ")", "\n", "chapter", "=", "None", "\n", "self", ".", "tuples", "=", "defaultdict", "(", "set", ")", "\n", "for", "line", "in", "infile", ":", "\n", "            ", "line", "=", "line", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", "\n", "if", "line", "[", "0", "]", "==", "\":\"", ":", "\n", "                ", "chapter", "=", "line", ".", "split", "(", ")", "[", "1", "]", ".", "strip", "(", ")", "\n", "continue", "\n", "", "a1", ",", "b1", ",", "a2", ",", "b2", "=", "line", ".", "split", "(", ")", "\n", "self", ".", "tuples", "[", "chapter", "]", "=", "self", ".", "tuples", "[", "chapter", "]", "|", "set", "(", "[", "(", "a1", ",", "(", "b1", ",", ")", ")", "]", ")", "\n", "self", ".", "tuples", "[", "chapter", "]", "=", "self", ".", "tuples", "[", "chapter", "]", "|", "set", "(", "[", "(", "a2", ",", "(", "b2", ",", ")", ")", "]", ")", "\n", "", "for", "chapter", "in", "self", ".", "tuples", ":", "\n", "            ", "self", ".", "tuples", "[", "chapter", "]", "=", "list", "(", "self", ".", "tuples", "[", "chapter", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.GoogleAnalogy.get_classes": [[282, 299], ["collections.defaultdict", "data.GoogleAnalogy.L[].append", "data.GoogleAnalogy.L[].append", "data.GoogleAnalogy.L[].append"], "methods", ["None"], ["", "", "def", "get_classes", "(", "self", ",", "first_only", "=", "True", ")", ":", "\n", "        ", "\"\"\"Out of the analogy pairs create a lexion. \n\n        We consider all left/right elements of the pair to be in one class, respectively.\n\n        Args:\n            first_only: whether to consider all right elements or just the first one\n        \"\"\"", "\n", "self", ".", "L", "=", "defaultdict", "(", "list", ")", "\n", "for", "chapter", "in", "self", ".", "tuples", ":", "\n", "            ", "for", "x", "in", "self", ".", "tuples", "[", "chapter", "]", ":", "\n", "                ", "self", ".", "L", "[", "chapter", "]", ".", "append", "(", "(", "x", "[", "0", "]", ",", "1", ")", ")", "\n", "if", "first_only", ":", "\n", "                    ", "self", ".", "L", "[", "chapter", "]", ".", "append", "(", "(", "x", "[", "1", "]", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                    ", "for", "b", "in", "x", "[", "1", "]", ":", "\n", "                        ", "self", ".", "L", "[", "chapter", "]", ".", "append", "(", "(", "b", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.SingleBats.__init__": [[305, 312], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            log: a logger object\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.SingleBats.load": [[313, 329], ["open", "open.close", "line.replace.replace.replace", "line.replace.replace.split", "tuple", "data.SingleBats.tuples.append", "part2.split"], "methods", ["None"], ["", "def", "load", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Load the BATS Dataset\n\n        Args:\n            path: path to the dataset\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "infile", "=", "open", "(", "self", ".", "path", ",", "'r'", ")", "\n", "self", ".", "tuples", "=", "[", "]", "\n", "for", "line", "in", "infile", ":", "\n", "            ", "line", "=", "line", ".", "replace", "(", "\"\\n\"", ",", "\"\"", ")", "\n", "part1", ",", "part2", "=", "line", ".", "split", "(", ")", "\n", "w1", "=", "part1", "\n", "w2", "=", "tuple", "(", "part2", ".", "split", "(", "\"/\"", ")", ")", "\n", "self", ".", "tuples", ".", "append", "(", "(", "w1", ",", "w2", ")", ")", "\n", "", "infile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.SingleBats.get_classes": [[330, 346], ["data.SingleBats.L.append", "data.SingleBats.L.append", "data.SingleBats.L.append"], "methods", ["None"], ["", "def", "get_classes", "(", "self", ",", "first_only", "=", "True", ")", ":", "\n", "        ", "\"\"\"Out of the analogy pairs create a lexion.\n\n        We consider all left/right elements of the pair to be in one class, respectively.\n\n        Args:\n            first_only: whether to consider all right elements or just the first one\n        \"\"\"", "\n", "self", ".", "L", "=", "[", "]", "\n", "for", "x", "in", "self", ".", "tuples", ":", "\n", "            ", "self", ".", "L", ".", "append", "(", "(", "x", "[", "0", "]", ",", "1", ")", ")", "\n", "if", "first_only", ":", "\n", "                ", "self", ".", "L", ".", "append", "(", "(", "x", "[", "1", "]", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "for", "b", "in", "x", "[", "1", "]", ":", "\n", "                    ", "self", ".", "L", ".", "append", "(", "(", "b", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.__init__": [[354, 402], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            log: a logger object\n        \"\"\"", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "chapter_paths", "=", "[", "\n", "\"1_Inflectional_morphology/I02 [noun - plural_irreg].txt\"", ",", "\n", "\"1_Inflectional_morphology/I07 [verb_inf - Ved].txt\"", ",", "\n", "\"1_Inflectional_morphology/I10 [verb_3pSg - Ved].txt\"", ",", "\n", "\"1_Inflectional_morphology/I01 [noun - plural_reg].txt\"", ",", "\n", "\"1_Inflectional_morphology/I08 [verb_Ving - 3pSg].txt\"", ",", "\n", "\"1_Inflectional_morphology/I03 [adj - comparative].txt\"", ",", "\n", "\"1_Inflectional_morphology/I04 [adj - superlative].txt\"", ",", "\n", "\"1_Inflectional_morphology/I06 [verb_inf - Ving].txt\"", ",", "\n", "\"1_Inflectional_morphology/I05 [verb_inf - 3pSg].txt\"", ",", "\n", "\"1_Inflectional_morphology/I09 [verb_Ving - Ved].txt\"", ",", "\n", "\"2_Derivational_morphology/D02 [un+adj_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D10 [verb+ment_irreg].txt\"", ",", "\n", "\"2_Derivational_morphology/D06 [re+verb_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D07 [verb+able_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D03 [adj+ly_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D05 [adj+ness_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D09 [verb+tion_irreg].txt\"", ",", "\n", "\"2_Derivational_morphology/D01 [noun+less_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D04 [over+adj_reg].txt\"", ",", "\n", "\"2_Derivational_morphology/D08 [verb+er_irreg].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E01 [country - capital].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E06 [animal - young].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E04 [name - nationality].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E03 [UK_city - county].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E02 [country - language].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E08 [animal - shelter].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E09 [things - color].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E07 [animal - sound].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E10 [male - female].txt\"", ",", "\n", "\"3_Encyclopedic_semantics/E05 [name - occupation].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L06 [meronyms - part].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L05 [meronyms - member].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L01 [hypernyms - animals].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L07 [synonyms - intensity].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L03 [hyponyms - misc].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L04 [meronyms - substance].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L10 [antonyms - binary].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L08 [synonyms - exact].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L09 [antonyms - gradable].txt\"", ",", "\n", "\"4_Lexicographic_semantics/L02 [hypernyms - misc].txt\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.load": [[403, 422], ["dict", "dict", "data.SingleBats", "data.SingleBats.load", "data.SingleBats.get_classes", "chapter_path.split", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.load", "home.repos.pwc.inspect_result.pdufter_densray.data.data.SingleBats.get_classes"], ["", "def", "load", "(", "self", ",", "path", ",", "first_only", "=", "True", ")", ":", "\n", "        ", "\"\"\"Load the BATS Dataset\n\n        Args:\n            path: path to the dataset\n            first_only: whether to consider all right elements or just the first one\n        \"\"\"", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "tuples", "=", "dict", "(", ")", "\n", "self", ".", "L", "=", "dict", "(", ")", "\n", "for", "chapter_path", "in", "self", ".", "chapter_paths", ":", "\n", "            ", "chapter", "=", "chapter_path", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "\n", "# if chapter[0] == \"D\" or chapter[0] == \"L\" or chapter[0] == \"I\":", "\n", "#     continue", "\n", "bats", "=", "SingleBats", "(", "self", ".", "log", ")", "\n", "bats", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "chapter_path", ")", ")", "\n", "bats", ".", "get_classes", "(", "first_only", "=", "first_only", ")", "\n", "self", ".", "tuples", "[", "chapter", "]", "=", "bats", ".", "tuples", "\n", "self", ".", "L", "[", "chapter", "]", "=", "bats", ".", "L", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.adjust_capitalisation": [[423, 453], ["set", "set", "x.lower", "set", "tuple", "list", "wlower.index"], "methods", ["None"], ["", "", "def", "adjust_capitalisation", "(", "self", ",", "wordlist", ")", ":", "\n", "        ", "\"\"\"Adjust the capitalisation\n\n        BATS is lowercased, but most wordspaces are cased.\n        Lowercase vector of \"washington\" is of low quality.\n        Thus convert the case of BATS to fit the word embeddings.\n\n        Args:\n            path: path to the dataset\n            first_only: whether to consider all right elements or just the first one\n        \"\"\"", "\n", "w", "=", "wordlist", "\n", "wset", "=", "set", "(", "w", ")", "\n", "wlower", "=", "[", "x", ".", "lower", "(", ")", "for", "x", "in", "wordlist", "]", "\n", "wlowerset", "=", "set", "(", "wlower", ")", "\n", "bw2truew", "=", "{", "}", "\n", "for", "chapter", "in", "self", ".", "tuples", ":", "\n", "            ", "for", "tup", "in", "self", ".", "tuples", "[", "chapter", "]", ":", "\n", "                ", "tmp_words", "=", "set", "(", "[", "tup", "[", "0", "]", "]", "+", "list", "(", "tup", "[", "1", "]", ")", ")", "\n", "for", "word", "in", "tmp_words", ":", "\n", "                    ", "if", "word", "in", "wset", ":", "\n", "                        ", "bw2truew", "[", "word", "]", "=", "word", "\n", "", "elif", "word", "in", "wlowerset", ":", "\n", "                        ", "idx", "=", "wlower", ".", "index", "(", "word", ")", "\n", "bw2truew", "[", "word", "]", "=", "w", "[", "idx", "]", "\n", "", "else", ":", "\n", "                        ", "bw2truew", "[", "word", "]", "=", "word", "\n", "# transform the data", "\n", "", "", "", "self", ".", "tuples", "[", "chapter", "]", "=", "[", "(", "bw2truew", "[", "w1", "]", ",", "tuple", "(", "[", "bw2truew", "[", "x", "]", "for", "x", "in", "w2", "]", ")", ")", "for", "w1", ",", "w2", "in", "self", ".", "tuples", "[", "chapter", "]", "]", "\n", "self", ".", "L", "[", "chapter", "]", "=", "[", "(", "bw2truew", "[", "k", "]", ",", "v", ")", "for", "k", ",", "v", "in", "self", ".", "L", "[", "chapter", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.data.data.Bats.store": [[454, 465], ["chapter_path.split", "os.path.exists", "os.mkdir", "open", "os.path.join", "os.path.join", "os.path.join", "fout.write", "fout.write", "fout.write", "fout.write"], "methods", ["None"], ["", "", "def", "store", "(", "self", ",", "path", ")", ":", "\n", "        ", "for", "chapter_path", "in", "self", ".", "chapter_paths", ":", "\n", "            ", "subdir", ",", "chapter", "=", "chapter_path", ".", "split", "(", "\"/\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "path", ",", "subdir", ")", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "os", ".", "path", ".", "join", "(", "path", ",", "subdir", ")", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "path", ",", "subdir", ",", "chapter", ")", ",", "'w'", ")", "as", "fout", ":", "\n", "                ", "for", "data", "in", "self", ".", "tuples", "[", "chapter", "]", ":", "\n", "                    ", "fout", ".", "write", "(", "data", "[", "0", "]", ")", "\n", "fout", ".", "write", "(", "'\\t'", ")", "\n", "fout", ".", "write", "(", "'/'", ".", "join", "(", "data", "[", "1", "]", ")", ")", "\n", "fout", ".", "write", "(", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.evaluation.evaluation.LexIndEval.__init__": [[9, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gt", ",", "pred", ")", ":", "\n", "        ", "\"\"\"Initalize the wrapper\n\n        Args:\n            gt: ground truth lexicon [(word1, score2), (word2, score2), ...]\n            pred: predicted score in same format\n        \"\"\"", "\n", "self", ".", "gt", "=", "gt", "\n", "self", ".", "pred", "=", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.evaluation.evaluation.LexIndEval.prepare": [[19, 34], ["sorted", "sorted", "zip", "zip", "set", "set", "compare.append", "evaluation.LexIndEval.words.append"], "methods", ["None"], ["", "def", "prepare", "(", "self", ")", ":", "\n", "        ", "\"\"\"For the overlap of both lexicons reorder the lexicons.\n        \"\"\"", "\n", "assert", "set", "(", "[", "k", "for", "k", ",", "v", "in", "self", ".", "gt", "]", ")", "==", "set", "(", "[", "k", "for", "k", ",", "v", "in", "self", ".", "pred", "]", ")", ",", "\"Predictions and Groundtruth inconsistent.\"", "\n", "\n", "gt_sorted", "=", "sorted", "(", "self", ".", "gt", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "pred_sorted", "=", "sorted", "(", "self", ".", "pred", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "\n", "\n", "compare", "=", "[", "]", "\n", "self", ".", "words", "=", "[", "]", "\n", "for", "gtitem", ",", "preditem", "in", "zip", "(", "gt_sorted", ",", "pred_sorted", ")", ":", "\n", "            ", "assert", "gtitem", "[", "0", "]", "==", "preditem", "[", "0", "]", "\n", "compare", ".", "append", "(", "(", "gtitem", "[", "1", "]", ",", "preditem", "[", "1", "]", ")", ")", "\n", "self", ".", "words", ".", "append", "(", "gtitem", "[", "0", "]", ")", "\n", "", "self", ".", "y_pred", ",", "self", ".", "y_true", "=", "zip", "(", "*", "compare", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.evaluation.evaluation.LexIndEval.compute_kendalls": [[35, 44], ["scipy.kendalltau"], "methods", ["None"], ["", "def", "compute_kendalls", "(", "self", ")", ":", "\n", "        ", "\"\"\"Computes kendalls tau\n\n            Returns:\n                tau: float; kendalls tau\n                p_value: float;\n        \"\"\"", "\n", "tau", ",", "p_value", "=", "stats", ".", "kendalltau", "(", "self", ".", "y_pred", ",", "self", ".", "y_true", ")", "\n", "return", "tau", ",", "p_value", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.evaluation.evaluation.LexIndEval.compute_classic": [[45, 59], ["sklearn.metrics.accuracy_score", "sklearn.metrics.precision_score", "sklearn.metrics.recall_score", "sklearn.metrics.f1_score"], "methods", ["None"], ["", "def", "compute_classic", "(", "self", ")", ":", "\n", "        ", "\"\"\"Computes accuracy, precision, etc. for binary prediction only.\n\n            Returns:\n                ac: accuracy\n                pr: precision\n                re: recall\n                f1: f1-score\n        \"\"\"", "\n", "ac", "=", "accuracy_score", "(", "self", ".", "y_true", ",", "self", ".", "y_pred", ")", "\n", "pr", "=", "precision_score", "(", "self", ".", "y_true", ",", "self", ".", "y_pred", ")", "\n", "re", "=", "recall_score", "(", "self", ".", "y_true", ",", "self", ".", "y_pred", ")", "\n", "f1", "=", "f1_score", "(", "self", ".", "y_true", ",", "self", ".", "y_pred", ")", "\n", "return", "ac", ",", "pr", ",", "re", ",", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.pdufter_densray.evaluation.evaluation.LexIndEval.view_errors": [[60, 66], ["enumerate", "print"], "methods", ["None"], ["", "def", "view_errors", "(", "self", ")", ":", "\n", "        ", "\"\"\"Prints all errors.\n        \"\"\"", "\n", "for", "i", ",", "word", "in", "enumerate", "(", "self", ".", "words", ")", ":", "\n", "            ", "if", "self", ".", "y_pred", "[", "i", "]", "!=", "self", ".", "y_true", "[", "i", "]", ":", "\n", "                ", "print", "(", "word", ",", "self", ".", "y_true", "[", "i", "]", ",", "self", ".", "y_pred", "[", "i", "]", ")", "\n", "", "", "", "", ""]]}