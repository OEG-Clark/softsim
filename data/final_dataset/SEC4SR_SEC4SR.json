{"home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.natural_train.parser_args": [[17, 47], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.parse_args"], ["def", "parser_args", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-defense'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_param'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_flag'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_order'", ",", "default", "=", "'sequential'", ",", "choices", "=", "[", "'sequential'", ",", "'average'", "]", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-label_encoder'", ",", "default", "=", "'./label-encoder-audionet-Spk251_test.txt'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-aug_eps'", ",", "type", "=", "float", ",", "default", "=", "0.002", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-root'", ",", "default", "=", "'./data'", ")", "# directory where Spk251_train and Spk251_test locates", "\n", "parser", ".", "add_argument", "(", "'-num_epoches'", ",", "type", "=", "int", ",", "default", "=", "30", ")", "\n", "parser", ".", "add_argument", "(", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "128", ")", "\n", "parser", ".", "add_argument", "(", "'-num_workers'", ",", "type", "=", "int", ",", "default", "=", "4", ")", "\n", "parser", ".", "add_argument", "(", "'-wav_length'", ",", "type", "=", "int", ",", "default", "=", "80_000", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-model_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-log'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-ori_model_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-ori_opt_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-start_epoch'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-evaluate_per_epoch'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.natural_train.validation": [[49, 63], ["model.eval", "torch.no_grad", "len", "enumerate", "origin.to.to", "true.to.to", "model.make_decision", "print", "true.to.cpu().item", "decision.cpu().item", "true.to.cpu", "decision.cpu"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "validation", "(", "model", ",", "val_data", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "total_cnt", "=", "len", "(", "val_data", ")", "\n", "right_cnt", "=", "0", "\n", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "val_data", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "to", "(", "device", ")", "\n", "decision", ",", "_", "=", "model", ".", "make_decision", "(", "origin", ")", "\n", "print", "(", "(", "f'[{index}/{total_cnt}], name:{file_name[0]}, true:{true.cpu().item():.0f}, predict:{decision.cpu().item():.0f}'", ")", ",", "\n", "end", "=", "'\\r'", ")", "\n", "if", "decision", "==", "true", ":", "\n", "                ", "right_cnt", "+=", "1", "\n", "", "", "", "return", "right_cnt", "/", "total_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.natural_train.main": [[64, 197], ["defense.defense.parser_defense", "model.defended_model.defended_model", "print", "torch.optim.Adam", "print", "dataset.Spk251_train.Spk251_train", "torch.utils.data.DataLoader", "print", "torch.nn.CrossEntropyLoss", "logging.basicConfig", "print", "range", "torch.save", "print", "model.audionet_csine.audionet_csine", "model.audionet_csine.audionet_csine.train", "model.audionet_csine.audionet_csine", "model.defended_model.defended_model.parameters", "print", "torch.load", "torch.optim.Adam.load_state_dict", "dataset.Spk251_test.Spk251_test", "torch.utils.data.DataLoader", "len", "len", "model.defended_model.defended_model.train", "enumerate", "print", "print", "print", "print", "print", "logging.info", "torch.save", "torch.save", "print", "print", "print", "model.defended_model.defended_model.base_model.state_dict", "time.time", "torch.cat.to", "torch.cat.to", "range", "model.defended_model.defended_model.", "torch.nn.CrossEntropyLoss.", "torch.optim.Adam.zero_grad", "criterion.backward", "torch.optim.Adam.step", "model.defended_model.defended_model.make_decision", "time.time", "print", "all_accuracies.append", "round", "model.defended_model.defended_model.base_model.state_dict", "torch.optim.Adam.state_dict", "natural_train.validation", "print", "print", "print", "logging.info", "numpy.random.rand", "torch.rand_like", "torch.cat", "torch.cat", "round", "numpy.mean", "numpy.mean", "[].size", "predictions.size", "torch.where"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.adver_train.validation"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "# load model", "\n", "# load model", "\n", "    ", "if", "args", ".", "ori_model_ckpt", ":", "\n", "        ", "print", "(", "args", ".", "ori_model_ckpt", ")", "\n", "base_model", "=", "audionet_csine", "(", "extractor_file", "=", "args", ".", "ori_model_ckpt", ",", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "base_model", ".", "train", "(", ")", "# important!! since audionet_csine() will set to eval() if extractor_file is not None", "\n", "", "else", ":", "\n", "        ", "base_model", "=", "audionet_csine", "(", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "", "spk_ids", "=", "base_model", ".", "spk_ids", "\n", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "print", "(", "'load model done'", ")", "\n", "\n", "# load optimizer", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ")", "\n", "if", "args", ".", "ori_opt_ckpt", ":", "\n", "        ", "print", "(", "args", ".", "ori_opt_ckpt", ")", "\n", "# optimizer_state_dict = torch.load(args.ori_opt_ckpt).state_dict()", "\n", "optimizer_state_dict", "=", "torch", ".", "load", "(", "args", ".", "ori_opt_ckpt", ")", "\n", "optimizer", ".", "load_state_dict", "(", "optimizer_state_dict", ")", "\n", "", "print", "(", "'set optimizer done'", ")", "\n", "\n", "# load val data", "\n", "val_dataset", "=", "None", "\n", "val_loader", "=", "None", "\n", "if", "args", ".", "evaluate_per_epoch", ">", "0", ":", "\n", "        ", "val_dataset", "=", "Spk251_test", "(", "spk_ids", ",", "args", ".", "root", ",", "return_file_name", "=", "True", ",", "wav_length", "=", "None", ")", "\n", "test_loader_params", "=", "{", "\n", "'batch_size'", ":", "1", ",", "\n", "'shuffle'", ":", "True", ",", "\n", "'num_workers'", ":", "0", ",", "\n", "'pin_memory'", ":", "True", "\n", "}", "\n", "val_loader", "=", "DataLoader", "(", "val_dataset", ",", "**", "test_loader_params", ")", "\n", "\n", "# load train data", "\n", "", "train_dataset", "=", "Spk251_train", "(", "spk_ids", ",", "args", ".", "root", ",", "wav_length", "=", "args", ".", "wav_length", ")", "\n", "train_loader_params", "=", "{", "\n", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "True", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'pin_memory'", ":", "True", "\n", "}", "\n", "train_loader", "=", "DataLoader", "(", "train_dataset", ",", "**", "train_loader_params", ")", "\n", "print", "(", "'load train data done'", ",", "len", "(", "train_dataset", ")", ")", "\n", "\n", "# loss", "\n", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "# ", "\n", "log", "=", "args", ".", "log", "if", "args", ".", "log", "else", "(", "'./model_file/audionet-natural-{}.log'", ".", "format", "(", "defense_name", ")", "if", "defense", "is", "not", "None", "else", "'./model_file/audionet-natural.log'", ")", "\n", "logging", ".", "basicConfig", "(", "filename", "=", "log", ",", "level", "=", "logging", ".", "DEBUG", ")", "\n", "model_ckpt", "=", "args", ".", "model_ckpt", "if", "args", ".", "model_ckpt", "else", "(", "'./model_file/audionet-natural-{}'", ".", "format", "(", "defense_name", ")", "if", "defense", "is", "not", "None", "else", "'./model_file/audionet-natural'", ")", "\n", "print", "(", "log", ",", "model_ckpt", ")", "\n", "\n", "num_batches", "=", "len", "(", "train_dataset", ")", "//", "args", ".", "batch_size", "\n", "for", "i_epoch", "in", "range", "(", "args", ".", "num_epoches", ")", ":", "\n", "        ", "all_accuracies", "=", "[", "]", "\n", "model", ".", "train", "(", ")", "\n", "for", "batch_id", ",", "(", "x_batch", ",", "y_batch", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "            ", "start_t", "=", "time", ".", "time", "(", ")", "\n", "x_batch", "=", "x_batch", ".", "to", "(", "device", ")", "\n", "y_batch", "=", "y_batch", ".", "to", "(", "device", ")", "\n", "# print(x_batch.min(), x_batch.max())", "\n", "\n", "#Noise augmentation to normal samples", "\n", "all_ids", "=", "range", "(", "x_batch", ".", "shape", "[", "0", "]", ")", "\n", "normal_ids", "=", "all_ids", "\n", "\n", "if", "args", ".", "aug_eps", ">", "0.", ":", "\n", "                ", "x_batch_normal", "=", "x_batch", "[", "normal_ids", ",", "...", "]", "\n", "y_batch_normal", "=", "y_batch", "[", "normal_ids", ",", "...", "]", "\n", "\n", "a", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "noise", "=", "torch", ".", "rand_like", "(", "x_batch_normal", ",", "dtype", "=", "x_batch_normal", ".", "dtype", ",", "device", "=", "device", ")", "\n", "epsilon", "=", "args", ".", "aug_eps", "\n", "noise", "=", "2", "*", "a", "*", "epsilon", "*", "noise", "-", "a", "*", "epsilon", "\n", "x_batch_normal_noisy", "=", "x_batch_normal", "+", "noise", "\n", "x_batch", "=", "torch", ".", "cat", "(", "(", "x_batch", ",", "x_batch_normal_noisy", ")", ",", "dim", "=", "0", ")", "\n", "y_batch", "=", "torch", ".", "cat", "(", "(", "y_batch", ",", "y_batch_normal", ")", ")", "\n", "\n", "", "outputs", "=", "model", "(", "x_batch", ")", "\n", "loss", "=", "criterion", "(", "outputs", ",", "y_batch", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# print('main:', x_batch.min(), x_batch.max())", "\n", "\n", "predictions", ",", "_", "=", "model", ".", "make_decision", "(", "x_batch", ")", "\n", "acc", "=", "torch", ".", "where", "(", "predictions", "==", "y_batch", ")", "[", "0", "]", ".", "size", "(", ")", "[", "0", "]", "/", "predictions", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "end_t", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Batch\"", ",", "batch_id", ",", "\"/\"", ",", "num_batches", ",", "\": Acc = \"", ",", "round", "(", "acc", ",", "4", ")", ",", "\"\\t batch time =\"", ",", "end_t", "-", "start_t", ")", "\n", "\n", "all_accuracies", ".", "append", "(", "acc", ")", "\n", "\n", "", "print", "(", ")", "\n", "print", "(", "'--------------------------------------'", ")", "\n", "print", "(", "\"EPOCH\"", ",", "i_epoch", "+", "args", ".", "start_epoch", ",", "\"/\"", ",", "args", ".", "num_epoches", "+", "args", ".", "start_epoch", ",", "\": Acc = \"", ",", "round", "(", "np", ".", "mean", "(", "all_accuracies", ")", ",", "4", ")", ")", "\n", "print", "(", "'--------------------------------------'", ")", "\n", "print", "(", ")", "\n", "logging", ".", "info", "(", "\"EPOCH {}/{}: Acc = {:.6f}\"", ".", "format", "(", "i_epoch", "+", "args", ".", "start_epoch", ",", "args", ".", "num_epoches", "+", "args", ".", "start_epoch", ",", "np", ".", "mean", "(", "all_accuracies", ")", ")", ")", "\n", "\n", "### save ckpt", "\n", "ckpt", "=", "model_ckpt", "+", "\"_{}\"", ".", "format", "(", "i_epoch", "+", "args", ".", "start_epoch", ")", "\n", "ckpt_optim", "=", "ckpt", "+", "'.opt'", "\n", "# torch.save(model, ckpt)", "\n", "# torch.save(optimizer, ckpt_optim) ", "\n", "# torch.save(model.state_dict(), ckpt) # DO NOT save the whole defended_model", "\n", "torch", ".", "save", "(", "model", ".", "base_model", ".", "state_dict", "(", ")", ",", "ckpt", ")", "# save the base_model", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "ckpt_optim", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"Save epoch ckpt in %s\"", "%", "ckpt", ")", "\n", "print", "(", ")", "\n", "\n", "### evaluate", "\n", "if", "args", ".", "evaluate_per_epoch", ">", "0", "and", "i_epoch", "%", "args", ".", "evaluate_per_epoch", "==", "0", ":", "\n", "            ", "val_acc", "=", "validation", "(", "model", ",", "val_loader", ")", "\n", "print", "(", ")", "\n", "print", "(", "'Val Acc: %f'", "%", "(", "val_acc", ")", ")", "\n", "print", "(", ")", "\n", "logging", ".", "info", "(", "'Val Acc: {:.6f}'", ".", "format", "(", "val_acc", ")", ")", "\n", "\n", "# torch.save(model, model_ckpt)", "\n", "# torch.save(model.state_dict(), model_ckpt) # DO NOT save the whole defended_model", "\n", "", "", "torch", ".", "save", "(", "model", ".", "base_model", ".", "state_dict", "(", ")", ",", "model_ckpt", ")", "# save the base_model", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.attackMain.parse_args": [[31, 146], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_subparsers", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "system_type_parser.add_subparsers", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "system_type_parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "subparser", "=", "parser", ".", "add_subparsers", "(", "dest", "=", "'system_type'", ")", "# either iv (ivector-PLDA) or xv (xvector-PLDA)", "\n", "\n", "iv_parser", "=", "subparser", ".", "add_parser", "(", "\"iv_plda\"", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-gmm'", ",", "default", "=", "'pre-trained-models/iv_plda/final_ubm.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-extractor'", ",", "default", "=", "'pre-trained-models/iv_plda/final_ie.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-plda'", ",", "default", "=", "'pre-trained-models/iv_plda/plda.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-mean'", ",", "default", "=", "'pre-trained-models/iv_plda/mean.vec'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-transform'", ",", "default", "=", "'pre-trained-models/iv_plda/transform.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-model_file'", ",", "default", "=", "'model_file/iv_plda/speaker_model_iv_plda'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-gmm_frame_bs'", ",", "type", "=", "int", ",", "default", "=", "200", ")", "\n", "\n", "xv_parser", "=", "subparser", ".", "add_parser", "(", "\"xv_plda\"", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-extractor'", ",", "default", "=", "'pre-trained-models/xv_plda/xvecTDNN_origin.ckpt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-plda'", ",", "default", "=", "'pre-trained-models/xv_plda/plda.txt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-mean'", ",", "default", "=", "'pre-trained-models/xv_plda/mean.vec'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-transform'", ",", "default", "=", "'pre-trained-models/xv_plda/transform.txt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-model_file'", ",", "default", "=", "'model_file/xv_plda/speaker_model_xv_plda'", ")", "\n", "\n", "audionet_c_parser", "=", "subparser", ".", "add_parser", "(", "\"audionet_csine\"", ")", "\n", "audionet_c_parser", ".", "add_argument", "(", "'-extractor'", ",", "\n", "default", "=", "'pre-trained-models/audionet/cnn-natural-model-noise-0-002-50-epoch.pt.tmp8540_ckpt'", ")", "\n", "audionet_c_parser", ".", "add_argument", "(", "'-label_encoder'", ",", "default", "=", "'./label-encoder-audionet-Spk251_test.txt'", ")", "\n", "\n", "# true threshold and threshold estimation", "\n", "parser", ".", "add_argument", "(", "'-threshold'", ",", "type", "=", "float", ",", "default", "=", "None", ")", "# for SV/OSI task; real threshold of the model", "\n", "parser", ".", "add_argument", "(", "'-threshold_estimated'", ",", "type", "=", "float", ",", "default", "=", "None", ")", "# for SV/OSI task; estimated threshold by FAKEBOB", "\n", "parser", ".", "add_argument", "(", "'-thresh_est_wav_path'", ",", "type", "=", "str", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "# the audio path used to estimate the threshold, should from imposter (initially rejected)", "\n", "parser", ".", "add_argument", "(", "'-thresh_est_step'", ",", "type", "=", "float", ",", "default", "=", "0.1", ")", "# the smaller, the accurate, but the slower", "\n", "\n", "#### add a defense layer in the model", "\n", "#### Note that for white-box attack, the defense method needs to be differentiable", "\n", "parser", ".", "add_argument", "(", "'-defense'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_param'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_flag'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_order'", ",", "default", "=", "'sequential'", ",", "choices", "=", "[", "'sequential'", ",", "'average'", "]", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-root'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-name'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-des'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "# path to store adver audios", "\n", "parser", ".", "add_argument", "(", "'-task'", ",", "type", "=", "str", ",", "default", "=", "'CSI'", ",", "choices", "=", "[", "'CSI'", ",", "'SV'", ",", "'OSI'", "]", ")", "# the attack use this to set the loss function", "\n", "parser", ".", "add_argument", "(", "'-wav_length'", ",", "type", "=", "int", ",", "default", "=", "None", ")", "\n", "\n", "## common attack parameters", "\n", "parser", ".", "add_argument", "(", "'-targeted'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "'-target_label_file'", ",", "default", "=", "None", ")", "# the path of the file containing the target label; generated by set_target_label.py", "\n", "parser", ".", "add_argument", "(", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'-EOT_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'-EOT_batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'-start'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'-end'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ")", "\n", "\n", "for", "system_type_parser", "in", "[", "iv_parser", ",", "xv_parser", ",", "audionet_c_parser", "]", ":", "\n", "\n", "        ", "subparser", "=", "system_type_parser", ".", "add_subparsers", "(", "dest", "=", "'attacker'", ")", "\n", "\n", "fgsm_parser", "=", "subparser", ".", "add_parser", "(", "\"FGSM\"", ")", "\n", "fgsm_parser", ".", "add_argument", "(", "\"-epsilon\"", ",", "type", "=", "float", ",", "default", "=", "0.002", ")", "\n", "fgsm_parser", ".", "add_argument", "(", "'-loss'", ",", "type", "=", "str", ",", "choices", "=", "[", "'Entropy'", ",", "'Margin'", "]", ",", "default", "=", "'Entropy'", ")", "\n", "\n", "pgd_parser", "=", "subparser", ".", "add_parser", "(", "\"PGD\"", ")", "\n", "pgd_parser", ".", "add_argument", "(", "'-step_size'", ",", "type", "=", "float", ",", "default", "=", "0.0004", ")", "\n", "pgd_parser", ".", "add_argument", "(", "'-epsilon'", ",", "type", "=", "float", ",", "default", "=", "0.002", ")", "\n", "pgd_parser", ".", "add_argument", "(", "'-max_iter'", ",", "type", "=", "int", ",", "default", "=", "10", ")", "# PGD-10 default", "\n", "pgd_parser", ".", "add_argument", "(", "'-num_random_init'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "pgd_parser", ".", "add_argument", "(", "'-loss'", ",", "type", "=", "str", ",", "choices", "=", "[", "'Entropy'", ",", "'Margin'", "]", ",", "default", "=", "'Entropy'", ")", "\n", "\n", "cwinf_parser", "=", "subparser", ".", "add_parser", "(", "\"CWinf\"", ")", "\n", "cwinf_parser", ".", "add_argument", "(", "'-step_size'", ",", "type", "=", "float", ",", "default", "=", "0.001", ")", "\n", "cwinf_parser", ".", "add_argument", "(", "'-epsilon'", ",", "type", "=", "float", ",", "default", "=", "0.002", ")", "\n", "cwinf_parser", ".", "add_argument", "(", "'-max_iter'", ",", "type", "=", "int", ",", "default", "=", "10", ")", "# PGD-10 default", "\n", "cwinf_parser", ".", "add_argument", "(", "'-num_random_init'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "\n", "cw2_parser", "=", "subparser", ".", "add_parser", "(", "\"CW2\"", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-initial_const'", ",", "type", "=", "float", ",", "default", "=", "1e-3", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-binary_search_steps'", ",", "type", "=", "int", ",", "default", "=", "9", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-max_iter'", ",", "type", "=", "int", ",", "default", "=", "10000", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-stop_early'", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-stop_early_iter'", ",", "type", "=", "int", ",", "default", "=", "1000", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-lr'", ",", "type", "=", "float", ",", "default", "=", "1e-2", ")", "\n", "cw2_parser", ".", "add_argument", "(", "'-confidence'", ",", "type", "=", "float", ",", "default", "=", "0.", ")", "\n", "# cw2_parser.add_argument('-dist_loss', default='L2', choices=['L2', 'PMSQE', 'PESQ'])", "\n", "\n", "fakebob_parser", "=", "subparser", ".", "add_parser", "(", "\"FAKEBOB\"", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "'-confidence'", ",", "type", "=", "float", ",", "default", "=", "0.", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--epsilon\"", ",", "\"-epsilon\"", ",", "default", "=", "0.002", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--max_iter\"", ",", "\"-max_iter\"", ",", "default", "=", "1000", ",", "type", "=", "int", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--max_lr\"", ",", "\"-max_lr\"", ",", "default", "=", "0.001", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--min_lr\"", ",", "\"-min_lr\"", ",", "default", "=", "1e-6", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--samples_per_draw\"", ",", "\"-samples\"", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--samples_batch\"", ",", "\"-samples_batch\"", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--sigma\"", ",", "\"-sigma\"", ",", "default", "=", "0.001", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--momentum\"", ",", "\"-momentum\"", ",", "default", "=", "0.9", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--plateau_length\"", ",", "\"-plateau_length\"", ",", "default", "=", "5", ",", "type", "=", "int", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--plateau_drop\"", ",", "\"-plateau_drop\"", ",", "default", "=", "2.0", ",", "type", "=", "float", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--stop_early\"", ",", "\"-stop_early\"", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ")", "\n", "fakebob_parser", ".", "add_argument", "(", "\"--stop_early_iter\"", ",", "\"-stop_early_iter\"", ",", "type", "=", "int", ",", "default", "=", "100", ")", "\n", "\n", "siren_parser", "=", "subparser", ".", "add_parser", "(", "\"SirenAttack\"", ")", "\n", "siren_parser", ".", "add_argument", "(", "'-confidence'", ",", "type", "=", "float", ",", "default", "=", "0.", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-epsilon\"", ",", "default", "=", "0.002", ",", "type", "=", "float", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-max_epoch\"", ",", "default", "=", "30", ",", "type", "=", "int", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-max_iter\"", ",", "default", "=", "300", ",", "type", "=", "int", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-c1\"", ",", "type", "=", "float", ",", "default", "=", "1.4961", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-c2\"", ",", "type", "=", "float", ",", "default", "=", "1.4961", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-n_particles\"", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-w_init\"", ",", "type", "=", "float", ",", "default", "=", "0.9", ")", "\n", "siren_parser", ".", "add_argument", "(", "\"-w_end\"", ",", "type", "=", "float", ",", "default", "=", "0.1", ")", "\n", "\n", "", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.attackMain.save_audio": [[147, 156], ["zip", "os.path.join", "os.path.join", "scipy.io.wavfile.write", "name.split", "os.path.exists", "os.makedirs", "adver.detach().cpu().numpy", "adver.detach().cpu", "adver.detach"], "function", ["None"], ["", "def", "save_audio", "(", "advers", ",", "names", ",", "root", ",", "fs", "=", "16000", ")", ":", "\n", "    ", "for", "adver", ",", "name", "in", "zip", "(", "advers", "[", ":", ",", "0", ",", ":", "]", ",", "names", ")", ":", "\n", "        ", "adver", "=", "(", "adver", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "(", "2", "**", "(", "bits", "-", "1", ")", ")", ")", ".", "astype", "(", "np", ".", "int16", ")", "\n", "spk_id", "=", "name", ".", "split", "(", "\"-\"", ")", "[", "0", "]", "\n", "spk_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "spk_id", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "spk_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "spk_dir", ")", "\n", "", "adver_path", "=", "os", ".", "path", ".", "join", "(", "spk_dir", ",", "name", "+", "\".wav\"", ")", "\n", "write", "(", "adver_path", ",", "fs", ",", "adver", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.attackMain.main": [[157, 319], ["defense.defense.parser_defense", "model.defended_model.defended_model", "dataset.Dataset.Dataset", "torch.utils.data.DataLoader", "min", "min", "print", "enumerate", "len", "print", "model.iv_plda.iv_plda", "attack.FGSM.FGSM", "print", "max", "len", "len", "max", "len", "os.path.join", "os.path.exists", "origin.to.to", "true.to.to", "print", "attack.SirenAttack.SirenAttack.attack", "attackMain.save_audio", "sum", "model.xv_plda.xv_plda", "attack.PGD.PGD", "open", "pickle.load", "range", "print", "true.to.clone", "enumerate", "model.audionet_csine.audionet_csine", "NotImplementedError", "NotImplementedError", "attack.FAKEBOB.FAKEBOB", "print", "print", "attack.CWinf.CWinf", "file_name[].split", "torchaudio.load", "attack.FAKEBOB.FAKEBOB.estimate_threshold", "attack.CW2.CW2", "pickle.load.keys", "list", "numpy.random.choice", "wav.unsqueeze().to", "abs", "attack.FAKEBOB.FAKEBOB", "range", "list.append", "list.remove", "attack.SirenAttack.SirenAttack", "NotImplementedError", "NotImplementedError", "len", "wav.unsqueeze"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.attackMain.save_audio", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.estimate_threshold", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "", "def", "main", "(", "args", ")", ":", "\n", "\n", "# set up model", "\n", "    ", "if", "args", ".", "system_type", "==", "'iv_plda'", ":", "\n", "        ", "base_model", "=", "iv_plda", "(", "args", ".", "gmm", ",", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "\n", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ",", "gmm_frame_bs", "=", "args", ".", "gmm_frame_bs", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'xv_plda'", ":", "\n", "        ", "base_model", "=", "xv_plda", "(", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'audionet_csine'", ":", "\n", "        ", "base_model", "=", "audionet_csine", "(", "args", ".", "extractor", ",", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Unsupported System Type'", ")", "\n", "\n", "", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "spk_ids", "=", "base_model", ".", "spk_ids", "\n", "\n", "wav_length", "=", "None", "if", "args", ".", "batch_size", "==", "1", "else", "args", ".", "wav_length", "\n", "# dataset = getattr(sys.modules[__name__], args.name)(spk_ids, root, return_file_name=True, wav_length=wav_length)", "\n", "# # set normalize to True since adv voices generated at [-1, 1] float domain", "\n", "dataset", "=", "Dataset", "(", "spk_ids", ",", "args", ".", "root", ",", "args", ".", "name", ",", "normalize", "=", "True", ",", "return_file_name", "=", "True", ",", "wav_length", "=", "wav_length", ")", "\n", "loader", "=", "DataLoader", "(", "dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "num_workers", "=", "0", ")", "\n", "\n", "# deal with black-box threshold (in black-box attack, the attacker does not know the true threshold)", "\n", "BLACK_BOX_ATTACKS", "=", "[", "'FAKEBOB'", ",", "'SirenAttack'", "]", "\n", "if", "args", ".", "task", "==", "'SV'", "or", "args", ".", "task", "==", "'OSI'", ":", "\n", "        ", "if", "args", ".", "attacker", "in", "BLACK_BOX_ATTACKS", ":", "\n", "            ", "if", "args", ".", "attacker", "==", "'SirenAttack'", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'SirenAttack does not incorporate threshold estimation algorithm. \\\n                    Consider calling FAKEBOB to get the estimated threshold.'", ")", "\n", "", "if", "args", ".", "threshold_estimated", "is", "None", ":", "\n", "                ", "fakebob", "=", "FAKEBOB", "(", "model", ",", "threshold", "=", "args", ".", "threshold_estimated", ",", "task", "=", "args", ".", "task", ",", "targeted", "=", "args", ".", "targeted", ",", "confidence", "=", "args", ".", "confidence", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_iter", "=", "args", ".", "max_iter", ",", "max_lr", "=", "args", ".", "max_lr", ",", "\n", "min_lr", "=", "args", ".", "min_lr", ",", "samples_per_draw", "=", "args", ".", "samples_per_draw", ",", "\n", "samples_per_draw_batch_size", "=", "args", ".", "samples_batch", ",", "sigma", "=", "args", ".", "sigma", ",", "\n", "momentum", "=", "args", ".", "momentum", ",", "plateau_length", "=", "args", ".", "plateau_length", ",", "\n", "plateau_drop", "=", "args", ".", "plateau_drop", ",", "\n", "stop_early", "=", "args", ".", "stop_early", ",", "stop_early_iter", "=", "args", ".", "stop_early_iter", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "\n", "verbose", "=", "1", ")", "\n", "assert", "args", ".", "thresh_est_wav_path", "is", "not", "None", "\n", "args", ".", "threshold_estimated", "=", "0", "\n", "cnt", "=", "0", "\n", "print", "(", "'===== Estimating threshold using FAKEBOB ====='", ")", "\n", "for", "path", "in", "args", ".", "thresh_est_wav_path", ":", "\n", "                    ", "wav", ",", "_", "=", "torchaudio", ".", "load", "(", "path", ")", "\n", "ll", "=", "fakebob", ".", "estimate_threshold", "(", "wav", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "device", ")", ",", "args", ".", "thresh_est_step", ")", "\n", "if", "ll", "is", "not", "None", ":", "\n", "                        ", "args", ".", "threshold_estimated", "+=", "ll", "\n", "cnt", "+=", "1", "\n", "", "", "assert", "cnt", ">", "0", "# when cnt = 0, all the audios are not from imposter, cannot used to estimate the threshold", "\n", "args", ".", "threshold_estimated", "/=", "cnt", "\n", "print", "(", "'===== Estimated threshold: {}, differ with true threshold: {} ====='", ".", "format", "(", "args", ".", "threshold_estimated", ",", "\n", "abs", "(", "model", ".", "threshold", "-", "args", ".", "threshold_estimated", ")", ")", ")", "\n", "\n", "", "", "", "attacker", "=", "None", "\n", "if", "args", ".", "attacker", "==", "'FGSM'", ":", "\n", "        ", "attacker", "=", "FGSM", "(", "model", ",", "task", "=", "args", ".", "task", ",", "epsilon", "=", "args", ".", "epsilon", ",", "loss", "=", "args", ".", "loss", ",", "targeted", "=", "args", ".", "targeted", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "verbose", "=", "1", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'PGD'", ":", "\n", "        ", "attacker", "=", "PGD", "(", "model", ",", "task", "=", "args", ".", "task", ",", "targeted", "=", "args", ".", "targeted", ",", "step_size", "=", "args", ".", "step_size", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_iter", "=", "args", ".", "max_iter", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "num_random_init", "=", "args", ".", "num_random_init", ",", "\n", "loss", "=", "args", ".", "loss", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "verbose", "=", "1", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'CWinf'", ":", "\n", "        ", "attacker", "=", "CWinf", "(", "model", ",", "task", "=", "args", ".", "task", ",", "targeted", "=", "args", ".", "targeted", ",", "step_size", "=", "args", ".", "step_size", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_iter", "=", "args", ".", "max_iter", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "num_random_init", "=", "args", ".", "num_random_init", ",", "\n", "loss", "=", "args", ".", "loss", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "verbose", "=", "1", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'CW2'", ":", "\n", "        ", "attacker", "=", "CW2", "(", "model", ",", "task", "=", "args", ".", "task", ",", "initial_const", "=", "args", ".", "initial_const", ",", "binary_search_steps", "=", "args", ".", "binary_search_steps", ",", "\n", "max_iter", "=", "args", ".", "max_iter", ",", "stop_early", "=", "args", ".", "stop_early", ",", "stop_early_iter", "=", "args", ".", "stop_early_iter", ",", "lr", "=", "args", ".", "lr", ",", "\n", "targeted", "=", "args", ".", "targeted", ",", "confidence", "=", "args", ".", "confidence", ",", "verbose", "=", "1", ",", "batch_size", "=", "args", ".", "batch_size", "\n", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'FAKEBOB'", ":", "\n", "        ", "attacker", "=", "FAKEBOB", "(", "model", ",", "threshold", "=", "args", ".", "threshold_estimated", ",", "task", "=", "args", ".", "task", ",", "targeted", "=", "args", ".", "targeted", ",", "confidence", "=", "args", ".", "confidence", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_iter", "=", "args", ".", "max_iter", ",", "max_lr", "=", "args", ".", "max_lr", ",", "\n", "min_lr", "=", "args", ".", "min_lr", ",", "samples_per_draw", "=", "args", ".", "samples_per_draw", ",", "\n", "samples_per_draw_batch_size", "=", "args", ".", "samples_batch", ",", "sigma", "=", "args", ".", "sigma", ",", "\n", "momentum", "=", "args", ".", "momentum", ",", "plateau_length", "=", "args", ".", "plateau_length", ",", "\n", "plateau_drop", "=", "args", ".", "plateau_drop", ",", "\n", "stop_early", "=", "args", ".", "stop_early", ",", "stop_early_iter", "=", "args", ".", "stop_early_iter", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "\n", "verbose", "=", "1", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'SirenAttack'", ":", "\n", "        ", "attacker", "=", "SirenAttack", "(", "model", ",", "threshold", "=", "args", ".", "threshold_estimated", ",", "\n", "task", "=", "args", ".", "task", ",", "targeted", "=", "args", ".", "targeted", ",", "confidence", "=", "args", ".", "confidence", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_epoch", "=", "args", ".", "max_epoch", ",", "max_iter", "=", "args", ".", "max_iter", ",", "\n", "c1", "=", "args", ".", "c1", ",", "c2", "=", "args", ".", "c2", ",", "n_particles", "=", "args", ".", "n_particles", ",", "w_init", "=", "args", ".", "w_init", ",", "w_end", "=", "args", ".", "w_end", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Not Supported Attack Algorithm'", ")", "\n", "\n", "", "attacker_param", "=", "None", "\n", "if", "args", ".", "attacker", "==", "'FGSM'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "epsilon", ",", "args", ".", "EOT_size", "]", "\n", "", "elif", "args", ".", "attacker", "==", "'PGD'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "max_iter", ",", "args", ".", "epsilon", ",", "args", ".", "step_size", ",", "args", ".", "num_random_init", ",", "args", ".", "EOT_size", "]", "\n", "", "elif", "args", ".", "attacker", "==", "'CWinf'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "max_iter", ",", "args", ".", "epsilon", ",", "args", ".", "num_random_init", ",", "args", ".", "EOT_size", "]", "\n", "", "elif", "args", ".", "attacker", "==", "'CW2'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "initial_const", ",", "args", ".", "confidence", ",", "args", ".", "max_iter", ",", "args", ".", "stop_early_iter", "]", "\n", "", "elif", "args", ".", "attacker", "==", "'FAKEBOB'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "epsilon", ",", "args", ".", "confidence", ",", "args", ".", "samples_per_draw", ",", "args", ".", "max_iter", ",", "args", ".", "stop_early_iter", "]", "\n", "", "elif", "args", ".", "attacker", "==", "'SirenAttack'", ":", "\n", "        ", "attacker_param", "=", "[", "args", ".", "epsilon", ",", "args", ".", "confidence", ",", "args", ".", "max_epoch", ",", "args", ".", "max_iter", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Not Supported Attack Algorithm'", ")", "\n", "\n", "\n", "", "adver_dir", "=", "\"./adver-audio/{}-{}-{}/{}/{}/{}-{}\"", ".", "format", "(", "args", ".", "system_type", ",", "args", ".", "task", ",", "args", ".", "name", ",", "\n", "defense_name", ",", "args", ".", "attacker", ",", "\n", "args", ".", "attacker", ",", "attacker_param", ")", "\n", "if", "args", ".", "des", "is", "not", "None", ":", "\n", "        ", "adver_dir", "=", "args", ".", "des", "\n", "", "print", "(", "adver_dir", ")", ",", "\n", "\n", "# load target label", "\n", "name2target", "=", "{", "}", "\n", "if", "args", ".", "target_label_file", "is", "not", "None", ":", "\n", "        ", "with", "open", "(", "args", ".", "target_label_file", ",", "'rb'", ")", "as", "reader", ":", "\n", "            ", "name2target", "=", "pickle", ".", "load", "(", "reader", ")", "\n", "\n", "", "", "start", "=", "min", "(", "max", "(", "args", ".", "start", ",", "0", ")", ",", "len", "(", "loader", ")", ")", "\n", "end", "=", "len", "(", "loader", ")", "if", "args", ".", "end", "==", "-", "1", "else", "args", ".", "end", "\n", "end", "=", "min", "(", "max", "(", "end", ",", "0", ")", ",", "len", "(", "loader", ")", ")", "\n", "print", "(", "start", ",", "end", ")", "\n", "\n", "success_cnt", "=", "0", "\n", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "        ", "if", "index", "not", "in", "range", "(", "start", ",", "end", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "des_path", "=", "os", ".", "path", ".", "join", "(", "adver_dir", ",", "file_name", "[", "0", "]", ".", "split", "(", "'-'", ")", "[", "0", "]", ",", "file_name", "[", "0", "]", "+", "'.wav'", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "des_path", ")", ":", "\n", "            ", "print", "(", "'*'", "*", "40", ",", "index", ",", "file_name", "[", "0", "]", ",", "'Exists, SKip'", ",", "'*'", "*", "40", ")", "\n", "continue", "\n", "\n", "", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "to", "(", "device", ")", "\n", "if", "args", ".", "targeted", ":", "\n", "            ", "target", "=", "true", ".", "clone", "(", ")", "\n", "for", "ii", ",", "y", "in", "enumerate", "(", "true", ")", ":", "\n", "                ", "if", "file_name", "[", "ii", "]", "in", "name2target", ".", "keys", "(", ")", ":", "\n", "                    ", "target", "[", "ii", "]", "=", "name2target", "[", "file_name", "[", "ii", "]", "]", "\n", "", "else", ":", "\n", "                    ", "candidate_target_labels", "=", "list", "(", "range", "(", "len", "(", "spk_ids", ")", ")", ")", "\n", "if", "args", ".", "task", "==", "'SV'", "or", "args", ".", "task", "==", "'OSI'", ":", "\n", "                        ", "candidate_target_labels", ".", "append", "(", "-", "1", ")", "# -1: reject", "\n", "", "if", "y", "in", "candidate_target_labels", ":", "\n", "                        ", "candidate_target_labels", ".", "remove", "(", "y", ")", "\n", "", "target", "[", "ii", "]", "=", "np", ".", "random", ".", "choice", "(", "candidate_target_labels", ")", "\n", "", "", "true", "=", "target", "\n", "", "print", "(", "'*'", "*", "10", ",", "index", ",", "'*'", "*", "10", ")", "\n", "adver", ",", "success", "=", "attacker", ".", "attack", "(", "origin", ",", "true", ")", "\n", "save_audio", "(", "adver", ",", "file_name", ",", "adver_dir", ")", "\n", "success_cnt", "+=", "sum", "(", "success", ")", "\n", "\n", "", "total_cnt", "=", "len", "(", "dataset", ")", "\n", "print", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "attacker", ",", "attacker_param", ",", "'success rate: %f'", "%", "(", "success_cnt", "*", "100", "/", "total_cnt", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.set_threshold.set_threshold": [[22, 48], ["isinstance", "numpy.array", "isinstance", "numpy.array", "numpy.abs", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "numpy.argwhere", "numpy.argwhere"], "function", ["None"], ["def", "set_threshold", "(", "score_target", ",", "score_untarget", ")", ":", "\n", "\n", "    ", "if", "not", "isinstance", "(", "score_target", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "score_target", "=", "np", ".", "array", "(", "score_target", ")", "\n", "", "if", "not", "isinstance", "(", "score_untarget", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "score_untarget", "=", "np", ".", "array", "(", "score_untarget", ")", "\n", "\n", "", "n_target", "=", "score_target", ".", "size", "\n", "n_untarget", "=", "score_untarget", ".", "size", "\n", "\n", "final_threshold", "=", "0.", "\n", "min_difference", "=", "np", ".", "infty", "\n", "final_far", "=", "0.", "\n", "final_frr", "=", "0.", "\n", "for", "candidate_threshold", "in", "score_target", ":", "\n", "\n", "        ", "frr", "=", "np", ".", "argwhere", "(", "score_target", "<", "candidate_threshold", ")", ".", "flatten", "(", ")", ".", "size", "*", "100", "/", "n_target", "\n", "far", "=", "np", ".", "argwhere", "(", "score_untarget", ">=", "candidate_threshold", ")", ".", "flatten", "(", ")", ".", "size", "*", "100", "/", "n_untarget", "\n", "difference", "=", "np", ".", "abs", "(", "frr", "-", "far", ")", "\n", "if", "difference", "<", "min_difference", ":", "\n", "            ", "final_threshold", "=", "candidate_threshold", "\n", "final_far", "=", "far", "\n", "final_frr", "=", "frr", "\n", "min_difference", "=", "difference", "\n", "\n", "", "", "return", "final_threshold", ",", "final_frr", ",", "final_far", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.set_threshold.main": [[49, 127], ["defense.defense.parser_defense", "model.defended_model.defended_model", "dataset.Spk10_test.Spk10_test", "torch.utils.data.DataLoader", "dataset.Spk10_imposter.Spk10_imposter", "torch.utils.data.DataLoader", "set_threshold.set_threshold", "print", "set_threshold.set_threshold", "print", "print", "model.iv_plda.iv_plda", "torch.no_grad", "enumerate", "enumerate", "numpy.intersect1d().flatten", "len", "model.xv_plda.xv_plda", "NotImplementedError", "origin.to.to", "true.cpu().item.cpu().item", "model.defended_model.defended_model.make_decision", "decision.cpu().item.cpu().item", "scores.cpu().numpy().flatten.cpu().numpy().flatten", "print", "score_target_sv.append", "numpy.delete().tolist", "trues.append", "max_scores.append", "decisions.append", "origin.to.to", "true.cpu().item.cpu().item", "model.defended_model.defended_model.make_decision", "decision.cpu().item.cpu().item", "scores.cpu().numpy().flatten.cpu().numpy().flatten", "print", "scores.cpu().numpy().flatten.tolist", "score_untarget_osi.append", "max", "max", "len", "score_target_osi.append", "numpy.max", "numpy.max", "numpy.intersect1d", "true.cpu().item.cpu", "decision.cpu().item.cpu", "scores.cpu().numpy().flatten.cpu().numpy", "numpy.delete", "true.cpu().item.cpu", "decision.cpu().item.cpu", "scores.cpu().numpy().flatten.cpu().numpy", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "scores.cpu().numpy().flatten.cpu", "scores.cpu().numpy().flatten.cpu", "numpy.argwhere", "numpy.argwhere"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.set_threshold.set_threshold", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.set_threshold.set_threshold", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "#Step 1: set up base_model", "\n", "    ", "if", "args", ".", "system_type", "==", "'iv_plda'", ":", "\n", "        ", "base_model", "=", "iv_plda", "(", "args", ".", "gmm", ",", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'xv_plda'", ":", "\n", "        ", "base_model", "=", "xv_plda", "(", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Unsupported System Type'", ")", "\n", "\n", "", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "\n", "#Step2: load dataset", "\n", "test_dataset", "=", "Spk10_test", "(", "base_model", ".", "spk_ids", ",", "args", ".", "root", ",", "return_file_name", "=", "True", ")", "\n", "test_loader", "=", "DataLoader", "(", "test_dataset", ",", "batch_size", "=", "1", ",", "num_workers", "=", "0", ")", "\n", "imposter_dataset", "=", "Spk10_imposter", "(", "base_model", ".", "spk_ids", ",", "args", ".", "root", ",", "return_file_name", "=", "True", ")", "\n", "imposter_loader", "=", "DataLoader", "(", "imposter_dataset", ",", "batch_size", "=", "1", ",", "num_workers", "=", "0", ")", "\n", "\n", "#Step3: scoring", "\n", "# score_target = []", "\n", "# score_untarget = []", "\n", "score_target_sv", "=", "[", "]", "\n", "score_untarget_sv", "=", "[", "]", "\n", "score_target_osi", "=", "[", "]", "\n", "score_untarget_osi", "=", "[", "]", "\n", "trues", "=", "[", "]", "# used to calculate IER for OSI", "\n", "max_scores", "=", "[", "]", "# used to calculate IER for OSI", "\n", "decisions", "=", "[", "]", "# used to calculate IER for OSI", "\n", "\n", "acc_cnt", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "test_loader", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "# print(origin.shape)", "\n", "decision", ",", "scores", "=", "model", ".", "make_decision", "(", "origin", ")", "\n", "decision", "=", "decision", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "# (n_spks,)", "\n", "print", "(", "index", ",", "file_name", "[", "0", "]", ",", "scores", ",", "true", ",", "decision", ")", "\n", "score_target_sv", ".", "append", "(", "scores", "[", "true", "]", ")", "\n", "score_untarget_sv", "+=", "np", ".", "delete", "(", "scores", ",", "true", ")", ".", "tolist", "(", ")", "\n", "if", "decision", "==", "true", ":", "\n", "                ", "score_target_osi", ".", "append", "(", "scores", "[", "true", "]", ")", "\n", "", "trues", ".", "append", "(", "true", ")", "\n", "max_scores", ".", "append", "(", "np", ".", "max", "(", "scores", ")", ")", "\n", "decisions", ".", "append", "(", "decision", ")", "\n", "\n", "if", "decision", "==", "true", ":", "\n", "                ", "acc_cnt", "+=", "1", "\n", "\n", "", "", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "imposter_loader", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "decision", ",", "scores", "=", "model", ".", "make_decision", "(", "origin", ")", "\n", "decision", "=", "decision", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "# (n_spks,)", "\n", "print", "(", "index", ",", "file_name", "[", "0", "]", ",", "scores", ",", "true", ",", "decision", ")", "\n", "score_untarget_sv", "+=", "scores", ".", "tolist", "(", ")", "\n", "score_untarget_osi", ".", "append", "(", "np", ".", "max", "(", "scores", ")", ")", "\n", "\n", "", "", "task", "=", "'SV'", "\n", "threshold", ",", "frr", ",", "far", "=", "set_threshold", "(", "score_target_sv", ",", "score_untarget_sv", ")", "\n", "print", "(", "\"----- Test of {}-based {}, result ---> threshold: {:.2f} EER: {:.2f}\"", ".", "format", "(", "args", ".", "system_type", ",", "\n", "task", ",", "threshold", ",", "max", "(", "frr", ",", "far", ")", ")", ")", "\n", "\n", "task", "=", "'OSI'", "\n", "threshold", ",", "frr", ",", "far", "=", "set_threshold", "(", "score_target_osi", ",", "score_untarget_osi", ")", "\n", "IER_cnt", "=", "np", ".", "intersect1d", "(", "np", ".", "argwhere", "(", "max_scores", ">=", "threshold", ")", ".", "flatten", "(", ")", ",", "\n", "np", ".", "argwhere", "(", "decisions", "!=", "trues", ")", ".", "flatten", "(", ")", ")", ".", "flatten", "(", ")", ".", "size", "\n", "# # IER: Identification Error, ", "\n", "# for detail, refer to 'Who is Real Bob? Adversarial Attacks on Speaker Recognition Systems'", "\n", "IER", "=", "IER_cnt", "*", "100", "/", "len", "(", "trues", ")", "\n", "print", "(", "\"----- Test of {}-based {}, result ---> threshold: {:.2f}, EER: {:.2f}, IER: {:.2f} -----\"", ".", "format", "(", "\n", "args", ".", "system_type", ",", "task", ",", "threshold", ",", "max", "(", "frr", ",", "far", ")", ",", "IER", ")", ")", "\n", "\n", "# CSI-E accuracy", "\n", "print", "(", "'CSI ACC:'", ",", "acc_cnt", "*", "100", "/", "len", "(", "test_loader", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.specify_target_label.main": [[22, 85], ["defense.defense.parser_defense", "model.defended_model.defended_model", "list", "dataset.Dataset.Dataset", "torch.utils.data.dataloader.DataLoader", "print", "model.iv_plda.iv_plda", "range", "list.append", "warnings.warn", "torch.no_grad", "enumerate", "open", "pickle.dump", "model.xv_plda.xv_plda", "len", "origin.to.to", "true.cpu().item.cpu().item", "model.defended_model.defended_model.make_decision", "decision.cpu().item.cpu().item", "scores.cpu().numpy().flatten.cpu().numpy().flatten", "print", "model.audionet_csine.audionet_csine", "NotImplementedError", "len", "len", "numpy.random.choice", "true.cpu().item.cpu", "decision.cpu().item.cpu", "scores.cpu().numpy().flatten.cpu().numpy", "enumerate", "candidate_target_labels.remove", "enumerate", "scores.cpu().numpy().flatten.cpu", "numpy.argmin", "numpy.argmax"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["def", "main", "(", "args", ")", ":", "\n", "\n", "#Step1: load the model", "\n", "# set up model", "\n", "    ", "if", "args", ".", "system_type", "==", "'iv_plda'", ":", "\n", "        ", "base_model", "=", "iv_plda", "(", "args", ".", "gmm", ",", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'xv_plda'", ":", "\n", "        ", "base_model", "=", "xv_plda", "(", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'audionet_csine'", ":", "\n", "        ", "base_model", "=", "audionet_csine", "(", "args", ".", "extractor", ",", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Unsupported System Type'", ")", "\n", "\n", "", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "spk_ids", "=", "base_model", ".", "spk_ids", "\n", "\n", "possible_decisions", "=", "list", "(", "range", "(", "len", "(", "spk_ids", ")", ")", ")", "\n", "if", "args", ".", "task", "==", "'SV'", "or", "args", ".", "task", "==", "'OSI'", ":", "\n", "        ", "possible_decisions", ".", "append", "(", "-", "1", ")", "# -1: rejecting", "\n", "\n", "#Step2: load the dataset", "\n", "", "dataset", "=", "Dataset", "(", "spk_ids", ",", "args", ".", "root", ",", "args", ".", "name", ",", "return_file_name", "=", "True", ")", "\n", "loader", "=", "DataLoader", "(", "dataset", ",", "batch_size", "=", "1", ",", "num_workers", "=", "0", ")", "\n", "\n", "if", "args", ".", "task", "==", "'SV'", ":", "\n", "        ", "args", ".", "hardest", "=", "False", "# hardest is meaningless for SV task", "\n", "", "if", "args", ".", "hardest", "and", "args", ".", "simplest", ":", "\n", "        ", "args", ".", "hardest", "=", "False", "\n", "args", ".", "simplest", "=", "False", "\n", "warnings", ".", "warn", "(", "'You set both hardest and simplest to true, will roll back to random!!'", ")", "\n", "\n", "#Step3: start", "\n", "", "name2target", "=", "{", "}", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "decision", ",", "scores", "=", "model", ".", "make_decision", "(", "origin", ")", "\n", "decision", "=", "decision", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "# (n_spks,)", "\n", "candidate_target_labels", "=", "[", "ii", "for", "ii", "in", "possible_decisions", "if", "ii", "!=", "true", "and", "ii", "!=", "decision", "]", "\n", "candidate_scores", "=", "[", "score", "for", "ii", ",", "score", "in", "enumerate", "(", "scores", ")", "if", "ii", "!=", "true", "and", "ii", "!=", "decision", "]", "\n", "if", "len", "(", "candidate_target_labels", ")", "==", "0", ":", "\n", "                ", "candidate_target_labels", "=", "[", "ii", "for", "ii", "in", "possible_decisions", "if", "ii", "!=", "decision", "]", "\n", "", "if", "len", "(", "candidate_scores", ")", "==", "0", ":", "\n", "                ", "candidate_scores", "=", "[", "score", "for", "ii", ",", "score", "in", "enumerate", "(", "scores", ")", "if", "ii", "!=", "decision", "]", "\n", "", "if", "not", "args", ".", "hardest", "and", "not", "args", ".", "simplest", ":", "\n", "                ", "target_label", "=", "np", ".", "random", ".", "choice", "(", "candidate_target_labels", ")", "\n", "", "else", ":", "\n", "                ", "if", "-", "1", "in", "candidate_target_labels", ":", "\n", "                    ", "candidate_target_labels", ".", "remove", "(", "-", "1", ")", "# reject decision has no score, so remove it", "\n", "", "target_label", "=", "candidate_target_labels", "[", "np", ".", "argmin", "(", "candidate_scores", ")", "]", "if", "args", ".", "hardest", "else", "candidate_target_labels", "[", "np", ".", "argmax", "(", "candidate_scores", ")", "]", "\n", "", "name2target", "[", "file_name", "[", "0", "]", "]", "=", "target_label", "\n", "print", "(", "index", ",", "file_name", "[", "0", "]", ",", "scores", ",", "true", ",", "decision", ",", "target_label", ")", "\n", "# Step4: save", "\n", "", "", "save_path", "=", "args", ".", "save_path", "if", "args", ".", "save_path", "else", "'{}-{}-{}-{}-{}.target_label'", ".", "format", "(", "args", ".", "system_type", ",", "args", ".", "task", ",", "\n", "defense_name", ",", "args", ".", "name", ",", "args", ".", "hardest", ")", "\n", "with", "open", "(", "save_path", ",", "'wb'", ")", "as", "writer", ":", "\n", "        ", "pickle", ".", "dump", "(", "name2target", ",", "writer", ",", "-", "1", ")", "\n", "", "print", "(", "'save file name and target label pair in {}'", ".", "format", "(", "save_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.adver_train.parser_args": [[20, 66], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.parse_args"], ["def", "parser_args", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-defense'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_param'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_flag'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_order'", ",", "default", "=", "'sequential'", ",", "choices", "=", "[", "'sequential'", ",", "'average'", "]", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-label_encoder'", ",", "default", "=", "'./label-encoder-audionet-Spk251_test.txt'", ")", "\n", "\n", "# parser.add_argument('-aug_eps', type=float, default=0.002)", "\n", "# unlike natural_train.py, we don't apply noise augmentation to normal examples ", "\n", "# since adversarial examples already augment the training data.", "\n", "parser", ".", "add_argument", "(", "'-aug_eps'", ",", "type", "=", "float", ",", "default", "=", "0.", ")", "\n", "\n", "\n", "parser", ".", "add_argument", "(", "'-attacker'", ",", "type", "=", "str", ",", "choices", "=", "[", "'PGD'", ",", "'FGSM'", "]", ",", "default", "=", "'PGD'", ")", "\n", "parser", ".", "add_argument", "(", "'-epsilon'", ",", "type", "=", "float", ",", "default", "=", "0.002", ")", "\n", "parser", ".", "add_argument", "(", "'-step_size'", ",", "type", "=", "float", ",", "default", "=", "0.0004", ")", "# recommend: epsilon / 5", "\n", "parser", ".", "add_argument", "(", "'-max_iter'", ",", "type", "=", "int", ",", "default", "=", "10", ")", "# PGD-10 default", "\n", "parser", ".", "add_argument", "(", "'-num_random_init'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'-EOT_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'-EOT_batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "\n", "# using root/Spk251_train as training data", "\n", "# using root/Spk251_test as validation data", "\n", "parser", ".", "add_argument", "(", "'-root'", ",", "type", "=", "str", ",", "default", "=", "'./data'", ")", "# directory where Spk251_train and Spk251_test locates", "\n", "parser", ".", "add_argument", "(", "'-num_epoches'", ",", "type", "=", "int", ",", "default", "=", "30", ")", "\n", "parser", ".", "add_argument", "(", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "128", ")", "\n", "parser", ".", "add_argument", "(", "'-num_workers'", ",", "type", "=", "int", ",", "default", "=", "4", ")", "\n", "parser", ".", "add_argument", "(", "'-wav_length'", ",", "type", "=", "int", ",", "default", "=", "80_000", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-ratio'", ",", "type", "=", "float", ",", "default", "=", "0.5", ")", "# the ratio of adversarial examples in each minibatch", "\n", "\n", "parser", ".", "add_argument", "(", "'-model_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-log'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-ori_model_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-ori_opt_ckpt'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'-start_epoch'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-evaluate_per_epoch'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "'-evaluate_adver'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.adver_train.validation": [[68, 102], ["model.eval", "print", "torch.no_grad", "len", "enumerate", "len", "enumerate", "print", "origin.to.to", "true.to.to", "model.make_decision", "print", "origin.to.to", "true.to.to", "attacker.attack", "model.make_decision", "print", "true.to.cpu().item", "decision.cpu().item", "true.to.cpu().item", "decision.cpu().item", "true.to.cpu", "decision.cpu", "true.to.cpu", "decision.cpu"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "validation", "(", "args", ",", "model", ",", "val_data", ",", "attacker", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "val_normal_acc", "=", "None", "\n", "val_adver_acc", "=", "None", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "total_cnt", "=", "len", "(", "val_data", ")", "\n", "right_cnt", "=", "0", "\n", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "val_data", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "to", "(", "device", ")", "\n", "decision", ",", "_", "=", "model", ".", "make_decision", "(", "origin", ")", "\n", "print", "(", "(", "f'[{index}/{total_cnt}], name:{file_name[0]}, true:{true.cpu().item():.0f}, predict:{decision.cpu().item():.0f}'", ")", ",", "\n", "end", "=", "'\\r'", ")", "\n", "if", "decision", "==", "true", ":", "\n", "                ", "right_cnt", "+=", "1", "\n", "", "", "val_normal_acc", "=", "right_cnt", "/", "total_cnt", "\n", "", "print", "(", ")", "\n", "if", "args", ".", "evaluate_adver", ":", "\n", "        ", "n_select", "=", "len", "(", "val_data", ")", "\n", "val_adver_cnt", "=", "0", "\n", "for", "index", ",", "(", "origin", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "val_data", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "to", "(", "device", ")", "\n", "adver", ",", "success", "=", "attacker", ".", "attack", "(", "origin", ",", "true", ")", "\n", "decision", ",", "_", "=", "model", ".", "make_decision", "(", "adver", ")", "\n", "print", "(", "(", "f'[{index}/{n_select}], name:{file_name[0]}, true:{true.cpu().item():.0f}, predict:{decision.cpu().item():.0f}'", ")", ",", "\n", "end", "=", "'\\r'", ")", "\n", "if", "decision", "==", "true", ":", "\n", "                ", "val_adver_cnt", "+=", "1", "\n", "", "", "val_adver_acc", "=", "val_adver_cnt", "/", "n_select", "\n", "print", "(", ")", "\n", "", "else", ":", "\n", "        ", "val_adver_acc", "=", "0.0", "\n", "", "return", "val_normal_acc", ",", "val_adver_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.adver_train.main": [[103, 280], ["defense.defense.parser_defense", "model.defended_model.defended_model", "print", "torch.optim.Adam", "print", "dataset.Spk251_train.Spk251_train", "torch.utils.data.DataLoader", "print", "torch.nn.CrossEntropyLoss", "logging.basicConfig", "print", "range", "torch.save", "print", "model.audionet_csine.audionet_csine", "model.audionet_csine.audionet_csine.train", "model.audionet_csine.audionet_csine", "model.defended_model.defended_model.parameters", "print", "torch.load", "torch.optim.Adam.load_state_dict", "dataset.Spk251_test.Spk251_test", "torch.utils.data.DataLoader", "len", "attack.FGSM.FGSM", "len", "model.defended_model.defended_model.train", "enumerate", "print", "print", "print", "print", "print", "logging.info", "torch.save", "torch.save", "print", "print", "print", "model.defended_model.defended_model.base_model.state_dict", "attack.PGD.PGD", "NotImplementedError", "time.time", "torch.cat.to", "torch.cat.to", "int", "attack.PGD.PGD.attack", "ASR.append", "range", "model.defended_model.defended_model.", "torch.nn.CrossEntropyLoss.", "torch.optim.Adam.zero_grad", "criterion.backward", "torch.optim.Adam.step", "model.defended_model.defended_model.make_decision", "time.time", "print", "all_accuracies.append", "all_accuracies_normal.append", "all_accuracies_adv.append", "round", "round", "round", "round", "model.defended_model.defended_model.base_model.state_dict", "torch.optim.Adam.state_dict", "adver_train.validation", "print", "print", "print", "logging.info", "int", "numpy.ceil", "numpy.random.choice", "list", "numpy.random.shuffle", "torch.cat.clone", "numpy.argwhere().flatten", "len", "numpy.random.rand", "torch.rand_like", "torch.cat", "torch.cat", "model.defended_model.defended_model.make_decision", "round", "round", "round", "round", "round", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "int", "range", "len", "[].size", "predictions.size", "[].size", "predictions_adv.size", "predictions_normal.size", "numpy.argwhere", "[].size", "predictions_normal.size", "[].size", "predictions_normal.size", "torch.where", "torch.where", "torch.where", "torch.where"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.adver_train.validation", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "# load model", "\n", "    ", "if", "args", ".", "ori_model_ckpt", ":", "\n", "        ", "print", "(", "args", ".", "ori_model_ckpt", ")", "\n", "base_model", "=", "audionet_csine", "(", "extractor_file", "=", "args", ".", "ori_model_ckpt", ",", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "base_model", ".", "train", "(", ")", "# important!! since audionet_csine() will set to eval() if extractor_file is not None", "\n", "", "else", ":", "\n", "        ", "base_model", "=", "audionet_csine", "(", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "", "spk_ids", "=", "base_model", ".", "spk_ids", "\n", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "print", "(", "'load model done'", ")", "\n", "\n", "# load optimizer", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ")", "\n", "if", "args", ".", "ori_opt_ckpt", ":", "\n", "        ", "print", "(", "args", ".", "ori_opt_ckpt", ")", "\n", "# optimizer_state_dict = torch.load(args.ori_opt_ckpt).state_dict()", "\n", "optimizer_state_dict", "=", "torch", ".", "load", "(", "args", ".", "ori_opt_ckpt", ")", "\n", "optimizer", ".", "load_state_dict", "(", "optimizer_state_dict", ")", "\n", "", "print", "(", "'set optimizer done'", ")", "\n", "\n", "# load val data", "\n", "val_dataset", "=", "None", "\n", "val_loader", "=", "None", "\n", "if", "args", ".", "evaluate_per_epoch", ">", "0", ":", "\n", "        ", "val_dataset", "=", "Spk251_test", "(", "spk_ids", ",", "args", ".", "root", ",", "return_file_name", "=", "True", ",", "wav_length", "=", "None", ")", "\n", "test_loader_params", "=", "{", "\n", "'batch_size'", ":", "1", ",", "\n", "'shuffle'", ":", "True", ",", "\n", "'num_workers'", ":", "0", ",", "\n", "'pin_memory'", ":", "True", "\n", "}", "\n", "val_loader", "=", "DataLoader", "(", "val_dataset", ",", "**", "test_loader_params", ")", "\n", "\n", "# load train data", "\n", "", "train_dataset", "=", "Spk251_train", "(", "spk_ids", ",", "args", ".", "root", ",", "wav_length", "=", "args", ".", "wav_length", ")", "\n", "train_loader_params", "=", "{", "\n", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "True", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'pin_memory'", ":", "True", "\n", "}", "\n", "train_loader", "=", "DataLoader", "(", "train_dataset", ",", "**", "train_loader_params", ")", "\n", "print", "(", "'load train data done'", ",", "len", "(", "train_dataset", ")", ")", "\n", "\n", "# attacker", "\n", "attacker", "=", "None", "\n", "if", "args", ".", "attacker", "==", "'FGSM'", ":", "\n", "        ", "attacker", "=", "FGSM", "(", "model", ",", "epsilon", "=", "args", ".", "epsilon", ",", "loss", "=", "'Entropy'", ",", "targeted", "=", "False", ",", "\n", "batch_size", "=", "int", "(", "args", ".", "batch_size", "*", "args", ".", "ratio", ")", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "\n", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "verbose", "=", "0", ")", "\n", "", "elif", "args", ".", "attacker", "==", "'PGD'", ":", "\n", "        ", "attacker", "=", "PGD", "(", "model", ",", "targeted", "=", "False", ",", "step_size", "=", "args", ".", "step_size", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "max_iter", "=", "args", ".", "max_iter", ",", "\n", "batch_size", "=", "int", "(", "args", ".", "batch_size", "*", "args", ".", "ratio", ")", ",", "num_random_init", "=", "args", ".", "num_random_init", ",", "\n", "loss", "=", "'Entropy'", ",", "EOT_size", "=", "args", ".", "EOT_size", ",", "EOT_batch_size", "=", "args", ".", "EOT_batch_size", ",", "\n", "verbose", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Not Supported Attack Algorithm for Adversarial Training'", ")", "\n", "\n", "# loss", "\n", "", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "# ", "\n", "log", "=", "args", ".", "log", "if", "args", ".", "log", "else", "(", "'./model_file/audionet-adver-{}.log'", ".", "format", "(", "defense_name", ")", "if", "defense", "is", "not", "None", "else", "'./model_file/audionet-adver.log'", ")", "\n", "logging", ".", "basicConfig", "(", "filename", "=", "log", ",", "level", "=", "logging", ".", "DEBUG", ")", "\n", "model_ckpt", "=", "args", ".", "model_ckpt", "if", "args", ".", "model_ckpt", "else", "(", "'./model_file/audionet-adver-{}'", ".", "format", "(", "defense_name", ")", "if", "defense", "is", "not", "None", "else", "'./model_file/audionet-adver'", ")", "\n", "print", "(", "log", ",", "model_ckpt", ")", "\n", "\n", "num_batches", "=", "len", "(", "train_dataset", ")", "//", "args", ".", "batch_size", "\n", "for", "i_epoch", "in", "range", "(", "args", ".", "num_epoches", ")", ":", "\n", "        ", "all_accuracies", "=", "[", "]", "\n", "all_accuracies_normal", "=", "[", "]", "\n", "all_accuracies_adv", "=", "[", "]", "\n", "ASR", "=", "[", "]", "\n", "model", ".", "train", "(", ")", "\n", "for", "batch_id", ",", "(", "x_batch", ",", "y_batch", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "            ", "start_t", "=", "time", ".", "time", "(", ")", "\n", "x_batch", "=", "x_batch", ".", "to", "(", "device", ")", "\n", "y_batch", "=", "y_batch", ".", "to", "(", "device", ")", "\n", "\n", "# Choose indices to replace with adversarial samples", "\n", "nb_adv", "=", "int", "(", "np", ".", "ceil", "(", "args", ".", "ratio", "*", "x_batch", ".", "shape", "[", "0", "]", ")", ")", "\n", "if", "args", ".", "ratio", "<", "1", ":", "\n", "                ", "adv_ids", "=", "np", ".", "random", ".", "choice", "(", "x_batch", ".", "shape", "[", "0", "]", ",", "size", "=", "nb_adv", ",", "replace", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "adv_ids", "=", "list", "(", "range", "(", "x_batch", ".", "shape", "[", "0", "]", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "adv_ids", ")", "\n", "x_batch_clone", "=", "x_batch", ".", "clone", "(", ")", "\n", "\n", "", "x_batch", "[", "adv_ids", "]", ",", "success", "=", "attacker", ".", "attack", "(", "x_batch", "[", "adv_ids", "]", ",", "y_batch", "[", "adv_ids", "]", ")", "\n", "success_cnt", "=", "np", ".", "argwhere", "(", "success", ")", ".", "flatten", "(", ")", ".", "size", "\n", "success_rate", "=", "success_cnt", "*", "100", "/", "len", "(", "success", ")", "\n", "ASR", ".", "append", "(", "success_rate", ")", "\n", "\n", "#Noise augmentation to normal samples", "\n", "all_ids", "=", "range", "(", "x_batch", ".", "shape", "[", "0", "]", ")", "\n", "normal_ids", "=", "[", "i_", "for", "i_", "in", "all_ids", "if", "i_", "not", "in", "adv_ids", "]", "\n", "if", "len", "(", "normal_ids", ")", ">", "0", "and", "args", ".", "aug_eps", ">", "0.", ":", "\n", "                ", "x_batch_normal", "=", "x_batch", "[", "normal_ids", ",", "...", "]", "\n", "y_batch_normal", "=", "y_batch", "[", "normal_ids", ",", "...", "]", "\n", "\n", "a", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "noise", "=", "torch", ".", "rand_like", "(", "x_batch_normal", ",", "dtype", "=", "x_batch_normal", ".", "dtype", ",", "device", "=", "device", ")", "\n", "epsilon", "=", "args", ".", "aug_eps", "\n", "noise", "=", "2", "*", "a", "*", "epsilon", "*", "noise", "-", "a", "*", "epsilon", "\n", "x_batch_normal_noisy", "=", "x_batch_normal", "+", "noise", "\n", "x_batch", "=", "torch", ".", "cat", "(", "(", "x_batch", ",", "x_batch_normal_noisy", ")", ",", "dim", "=", "0", ")", "\n", "y_batch", "=", "torch", ".", "cat", "(", "(", "y_batch", ",", "y_batch_normal", ")", ")", "\n", "\n", "", "outputs", "=", "model", "(", "x_batch", ")", "\n", "loss", "=", "criterion", "(", "outputs", ",", "y_batch", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "predictions", ",", "_", "=", "model", ".", "make_decision", "(", "x_batch", ")", "\n", "acc", "=", "torch", ".", "where", "(", "predictions", "==", "y_batch", ")", "[", "0", "]", ".", "size", "(", ")", "[", "0", "]", "/", "predictions", ".", "size", "(", ")", "[", "0", "]", "\n", "predictions_adv", "=", "predictions", "[", "adv_ids", "]", "\n", "acc_adv", "=", "torch", ".", "where", "(", "predictions_adv", "==", "y_batch", "[", "adv_ids", "]", ")", "[", "0", "]", ".", "size", "(", ")", "[", "0", "]", "/", "predictions_adv", ".", "size", "(", ")", "[", "0", "]", "\n", "predictions_normal", "=", "predictions", "[", "normal_ids", "]", "\n", "acc_normal", "=", "None", "\n", "if", "predictions_normal", ".", "size", "(", ")", "[", "0", "]", ">", "0", ":", "\n", "                ", "acc_normal", "=", "torch", ".", "where", "(", "predictions_normal", "==", "y_batch", "[", "normal_ids", "]", ")", "[", "0", "]", ".", "size", "(", ")", "[", "0", "]", "/", "predictions_normal", ".", "size", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "predictions_normal", ",", "_", "=", "model", ".", "make_decision", "(", "x_batch_clone", ")", "\n", "acc_normal", "=", "torch", ".", "where", "(", "predictions_normal", "==", "y_batch", ")", "[", "0", "]", ".", "size", "(", ")", "[", "0", "]", "/", "predictions_normal", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "", "end_t", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Batch\"", ",", "batch_id", ",", "\"/\"", ",", "num_batches", ",", "\" : ASR = \"", ",", "round", "(", "success_rate", ",", "4", ")", ",", "\n", "\"\\tAcc = \"", ",", "round", "(", "acc", ",", "4", ")", ",", "\"\\tAcc adv =\"", ",", "round", "(", "acc_adv", ",", "4", ")", ",", "\n", "\"\\tAcc normal =\"", ",", "round", "(", "acc_normal", ",", "4", ")", ",", "\"\\t batch time =\"", ",", "round", "(", "end_t", "-", "start_t", ",", "6", ")", ")", "\n", "\n", "all_accuracies", ".", "append", "(", "acc", ")", "\n", "all_accuracies_normal", ".", "append", "(", "acc_normal", ")", "\n", "all_accuracies_adv", ".", "append", "(", "acc_adv", ")", "\n", "\n", "", "print", "(", ")", "\n", "print", "(", "'--------------------------------------'", ")", "\n", "print", "(", "\"EPOCH\"", ",", "i_epoch", "+", "args", ".", "start_epoch", ",", "\"/\"", ",", "args", ".", "num_epoches", "+", "args", ".", "start_epoch", ",", "\n", "\": ASR = \"", ",", "round", "(", "np", ".", "mean", "(", "ASR", ")", ",", "4", ")", ",", "\n", "\"\\tAcc = \"", ",", "round", "(", "np", ".", "mean", "(", "all_accuracies", ")", ",", "4", ")", ",", "\n", "\"\\tAcc adv =\"", ",", "round", "(", "np", ".", "mean", "(", "all_accuracies_adv", ")", ",", "4", ")", ",", "\n", "\"\\tAcc normal =\"", ",", "round", "(", "np", ".", "mean", "(", "all_accuracies_normal", ")", ",", "4", ")", ")", "\n", "print", "(", "'--------------------------------------'", ")", "\n", "print", "(", ")", "\n", "logging", ".", "info", "(", "\"EPOCH {}/{}: ASR = {:.6f}\\tAcc = {:.6f}\\tAcc adv = {:.6f}\\tAcc normal = {:.6f}\"", ".", "format", "(", "i_epoch", "+", "args", ".", "start_epoch", ",", "args", ".", "num_epoches", "+", "args", ".", "start_epoch", ",", "np", ".", "mean", "(", "ASR", ")", ",", "np", ".", "mean", "(", "all_accuracies", ")", ",", "np", ".", "mean", "(", "all_accuracies_adv", ")", ",", "np", ".", "mean", "(", "all_accuracies_normal", ")", ")", ")", "\n", "\n", "### save ckpt", "\n", "ckpt", "=", "model_ckpt", "+", "\"_{}\"", ".", "format", "(", "i_epoch", "+", "args", ".", "start_epoch", ")", "\n", "ckpt_optim", "=", "ckpt", "+", "'.opt'", "\n", "# torch.save(model, ckpt)", "\n", "# torch.save(optimizer, ckpt_optim)", "\n", "# torch.save(model.state_dict(), ckpt) # DO NOT save the whole defended_model", "\n", "torch", ".", "save", "(", "model", ".", "base_model", ".", "state_dict", "(", ")", ",", "ckpt", ")", "# save the base_model", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "ckpt_optim", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"Save epoch ckpt in %s\"", "%", "ckpt", ")", "\n", "print", "(", ")", "\n", "\n", "### evaluate", "\n", "if", "args", ".", "evaluate_per_epoch", ">", "0", "and", "i_epoch", "%", "args", ".", "evaluate_per_epoch", "==", "0", ":", "\n", "            ", "val_acc", ",", "val_adver_acc", "=", "validation", "(", "args", ",", "model", ",", "val_loader", ",", "attacker", ")", "\n", "print", "(", ")", "\n", "print", "(", "'Val Acc: %f, Val Adver Acc: %f'", "%", "(", "val_acc", ",", "val_adver_acc", ")", ")", "\n", "print", "(", ")", "\n", "logging", ".", "info", "(", "'Val Acc: {:.6f} Val Adver Acc: {:.6f}'", ".", "format", "(", "val_acc", ",", "val_adver_acc", ")", ")", "\n", "\n", "# torch.save(model, model_ckpt)", "\n", "# torch.save(model.state_dict(), model_ckpt) # DO NOT save the whole defended_model", "\n", "", "", "torch", ".", "save", "(", "model", ".", "base_model", ".", "state_dict", "(", ")", ",", "model_ckpt", ")", "# save the base_model", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.enroll.main": [[15, 112], ["defense.defense.parser_defense", "model.defended_model.defended_model", "model.iv_plda.iv_plda", "os.path.exists", "os.makedirs", "torch.no_grad", "os.path.join", "os.listdir", "numpy.savetxt", "model.xv_plda.xv_plda", "NotImplementedError", "os.path.join", "os.listdir", "enumerate", "os.path.join", "torch.save", "os.path.join", "os.listdir", "numpy.mean", "numpy.std", "model_info.append", "numpy.savetxt", "os.path.join", "os.path.join", "os.path.join", "torchaudio.load", "audio.unsqueeze.unsqueeze", "model.defended_model.defended_model.embedding", "os.path.exists", "os.makedirs", "os.path.join", "os.listdir", "os.path.join", "os.path.join", "audio.unsqueeze.to", "os.path.join", "torchaudio.load", "model.defended_model.defended_model.score().flatten().detach().cpu().item", "spk_nontarget_scores.append", "print", "model.defended_model.defended_model.score().flatten().detach().cpu", "test_audio.to", "model.defended_model.defended_model.score().flatten().detach", "model.defended_model.defended_model.score().flatten", "model.defended_model.defended_model.score"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["def", "main", "(", "args", ")", ":", "\n", "\n", "#Step 1: set up base_model", "\n", "    ", "if", "args", ".", "system_type", "==", "'iv_plda'", ":", "\n", "        ", "base_model", "=", "iv_plda", "(", "args", ".", "gmm", ",", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'xv_plda'", ":", "\n", "        ", "base_model", "=", "xv_plda", "(", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Unsupported System Type'", ")", "\n", "\n", "", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "\n", "#Step2: scoring", "\n", "des_dir", "=", "args", ".", "model_dir", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "des_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "des_dir", ")", "\n", "", "model_info", "=", "[", "]", "\n", "\n", "# import pickle", "\n", "# with open('vox1-dev.pickle', 'rb') as reader:", "\n", "#     print('begin loading data')", "\n", "#     loader = pickle.load(reader)", "\n", "#     print('load data done')", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "root", "=", "args", ".", "root", "\n", "enroll_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "'Spk10_enroll'", ")", "\n", "spk_iter", "=", "os", ".", "listdir", "(", "enroll_dir", ")", "\n", "for", "spk_id", "in", "spk_iter", ":", "\n", "\n", "            ", "spk_dir", "=", "os", ".", "path", ".", "join", "(", "enroll_dir", ",", "spk_id", ")", "\n", "audio_iter", "=", "os", ".", "listdir", "(", "spk_dir", ")", "\n", "num_enroll_utt", "=", "0", "\n", "for", "ii", ",", "audio_name", "in", "enumerate", "(", "audio_iter", ")", ":", "\n", "                ", "audio_path", "=", "os", ".", "path", ".", "join", "(", "spk_dir", ",", "audio_name", ")", "\n", "audio", ",", "_", "=", "torchaudio", ".", "load", "(", "audio_path", ")", "\n", "audio", "=", "audio", ".", "to", "(", "device", ")", "*", "(", "2", "**", "(", "16", "-", "1", ")", ")", "\n", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "\n", "emb_", "=", "model", ".", "embedding", "(", "audio", ")", "# (1, dim)", "\n", "\n", "if", "ii", "==", "0", ":", "\n", "                    ", "emb", "=", "emb_", "\n", "", "else", ":", "\n", "                    ", "emb", ".", "data", "+=", "emb_", "\n", "\n", "", "num_enroll_utt", "+=", "1", "\n", "\n", "", "emb", ".", "data", "=", "emb", "/", "num_enroll_utt", "\n", "des_path", "=", "os", ".", "path", ".", "join", "(", "des_dir", ",", "args", ".", "system_type", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "des_path", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "des_path", ")", "\n", "", "emb_path", "=", "'{}/{}.{}'", ".", "format", "(", "des_path", ",", "spk_id", ",", "args", ".", "system_type", ")", "if", "defense", "is", "None", "else", "'{}/{}.{}-{}'", ".", "format", "(", "des_path", ",", "spk_id", ",", "args", ".", "system_type", ",", "defense_name", ")", "\n", "torch", ".", "save", "(", "emb", ",", "emb_path", ")", "\n", "\n", "spk_nontarget_scores", "=", "[", "]", "\n", "test_dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "'Spk10_test'", ")", "\n", "# test_dir = os.path.join(root, 'Spk10_imposter')", "\n", "test_spk_iter", "=", "os", ".", "listdir", "(", "test_dir", ")", "\n", "for", "test_spk_id", "in", "test_spk_iter", ":", "\n", "\n", "                ", "if", "test_spk_id", "==", "spk_id", ":", "\n", "                    ", "continue", "\n", "\n", "", "test_spk_dir", "=", "os", ".", "path", ".", "join", "(", "test_dir", ",", "test_spk_id", ")", "\n", "test_audio_iter", "=", "os", ".", "listdir", "(", "test_spk_dir", ")", "\n", "for", "name", "in", "test_audio_iter", ":", "\n", "                    ", "test_audio_path", "=", "os", ".", "path", ".", "join", "(", "test_spk_dir", ",", "name", ")", "\n", "test_audio", ",", "_", "=", "torchaudio", ".", "load", "(", "test_audio_path", ")", "\n", "test_audio", "=", "(", "test_audio", ".", "to", "(", "device", ")", "*", "(", "2", "**", "(", "16", "-", "1", ")", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "scores", "=", "model", ".", "score", "(", "test_audio", ",", "enroll_embs", "=", "emb", ")", ".", "flatten", "(", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "spk_nontarget_scores", ".", "append", "(", "scores", ")", "\n", "print", "(", "spk_id", ",", "name", ",", "scores", ")", "\n", "# spk_nontarget_scores = []", "\n", "# for index, (origin, _, file_name, lens) in enumerate(loader):", "\n", "#     origin = origin.to(device)", "\n", "#     scores = model.score(origin, enroll_embs=emb).flatten().detach().cpu().item()", "\n", "#     spk_nontarget_scores.append(scores)", "\n", "#     print(spk_id, file_name, scores)", "\n", "\n", "", "", "z_norm_mean", "=", "np", ".", "mean", "(", "spk_nontarget_scores", ")", "\n", "z_norm_std", "=", "np", ".", "std", "(", "spk_nontarget_scores", ")", "\n", "\n", "spk_model_info", "=", "\"{} {} {} {}\"", ".", "format", "(", "spk_id", ",", "emb_path", ",", "z_norm_mean", ",", "z_norm_std", ")", "\n", "model_info", ".", "append", "(", "spk_model_info", ")", "\n", "if", "defense", "is", "not", "None", ":", "\n", "                ", "spk_model_file", "=", "os", ".", "path", ".", "join", "(", "des_path", ",", "'speaker_model_{}_{}_{}'", ".", "format", "(", "args", ".", "system_type", ",", "defense_name", ",", "spk_id", ")", ")", "\n", "", "else", ":", "\n", "                ", "spk_model_file", "=", "os", ".", "path", ".", "join", "(", "des_path", ",", "'speaker_model_{}_{}'", ".", "format", "(", "args", ".", "system_type", ",", "spk_id", ")", ")", "\n", "", "np", ".", "savetxt", "(", "spk_model_file", ",", "[", "spk_model_info", "]", ",", "fmt", "=", "'%s'", ")", "\n", "\n", "", "if", "defense", "is", "not", "None", ":", "\n", "            ", "model_file", "=", "os", ".", "path", ".", "join", "(", "des_path", ",", "'speaker_model_{}_{}'", ".", "format", "(", "args", ".", "system_type", ",", "defense_name", ")", ")", "\n", "", "else", ":", "\n", "            ", "model_file", "=", "os", ".", "path", ".", "join", "(", "des_path", ",", "'speaker_model_{}'", ".", "format", "(", "args", ".", "system_type", ")", ")", "\n", "", "np", ".", "savetxt", "(", "model_file", ",", "model_info", ",", "fmt", "=", "'%s'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.parse_args": [[24, 74], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_subparsers", "parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "parser.add_subparsers.add_parser", "subparser.add_parser.add_argument", "subparser.add_parser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "import", "argparse", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "subparser", "=", "parser", ".", "add_subparsers", "(", "dest", "=", "'system_type'", ")", "# either iv (ivector-PLDA) or xv (xvector-PLDA)", "\n", "\n", "iv_parser", "=", "subparser", ".", "add_parser", "(", "\"iv_plda\"", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-gmm'", ",", "default", "=", "'pre-trained-models/iv_plda/final_ubm.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-extractor'", ",", "default", "=", "'pre-trained-models/iv_plda/final_ie.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-plda'", ",", "default", "=", "'pre-trained-models/iv_plda/plda.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-mean'", ",", "default", "=", "'pre-trained-models/iv_plda/mean.vec'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-transform'", ",", "default", "=", "'pre-trained-models/iv_plda/transform.txt'", ")", "\n", "iv_parser", ".", "add_argument", "(", "'-model_file'", ",", "default", "=", "'model_file/iv_plda/speaker_model_iv_plda'", ")", "\n", "\n", "xv_parser", "=", "subparser", ".", "add_parser", "(", "\"xv_plda\"", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-extractor'", ",", "default", "=", "'pre-trained-models/xv_plda/xvecTDNN_origin.ckpt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-plda'", ",", "default", "=", "'pre-trained-models/xv_plda/plda.txt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-mean'", ",", "default", "=", "'pre-trained-models/xv_plda/mean.vec'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-transform'", ",", "default", "=", "'pre-trained-models/xv_plda/transform.txt'", ")", "\n", "xv_parser", ".", "add_argument", "(", "'-model_file'", ",", "default", "=", "'model_file/xv_plda/speaker_model_xv_plda'", ")", "\n", "\n", "audionet_c_parser", "=", "subparser", ".", "add_parser", "(", "\"audionet_csine\"", ")", "\n", "audionet_c_parser", ".", "add_argument", "(", "'-extractor'", ",", "\n", "default", "=", "'pre-trained-models/audionet/cnn-natural-model-noise-0-002-50-epoch.pt.tmp8540_ckpt'", ")", "\n", "audionet_c_parser", ".", "add_argument", "(", "'-label_encoder'", ",", "default", "=", "'./label-encoder-audionet-Spk251_test.txt'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-threshold'", ",", "type", "=", "float", ",", "default", "=", "None", ")", "# for SV/OSI task", "\n", "\n", "#### add a defense layer in the model", "\n", "#### Note that for white-box attack, the defense method needs to be differentiable", "\n", "parser", ".", "add_argument", "(", "'-defense'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_param'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_flag'", ",", "nargs", "=", "'+'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'-defense_order'", ",", "default", "=", "'sequential'", ",", "choices", "=", "[", "'sequential'", ",", "'average'", "]", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-root'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-name'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-root_ori'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "# directory where the name_ori locates", "\n", "parser", ".", "add_argument", "(", "'-name_ori'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "# used to calculate imperceptibility", "\n", "parser", ".", "add_argument", "(", "'-wav_length'", ",", "type", "=", "int", ",", "default", "=", "None", ")", "\n", "\n", "## common attack parameters", "\n", "# parser.add_argument('-targeted', action='store_true', default=False)", "\n", "parser", ".", "add_argument", "(", "'-batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-target_label_file'", ",", "default", "=", "None", ")", "# used to test the targeted attack success rate", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.None.test_attack.main": [[75, 167], ["defense.defense.parser_defense", "model.defended_model.defended_model", "dataset.Dataset.Dataset", "torch.utils.data.DataLoader", "print", "len", "print", "print", "model.iv_plda.iv_plda", "warnings.warn", "dataset.Dataset.Dataset", "torch.utils.data.DataLoader", "enumerate", "torch.no_grad", "enumerate", "print", "numpy.mean", "print", "model.xv_plda.xv_plda", "origin.to.to", "open", "pickle.load", "adver.to.to", "true.to.to", "model.defended_model.defended_model.make_decision", "print", "numpy.array", "model.audionet_csine.audionet_csine", "NotImplementedError", "true.to.clone", "enumerate", "metric.metric.get_all_metric", "np.mean.append", "torch.where", "pickle.load.keys", "NotImplementedError", "torch.where"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.get_all_metric"], ["", "def", "main", "(", "args", ")", ":", "\n", "\n", "# set up model", "\n", "    ", "if", "args", ".", "system_type", "==", "'iv_plda'", ":", "\n", "        ", "base_model", "=", "iv_plda", "(", "args", ".", "gmm", ",", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'xv_plda'", ":", "\n", "        ", "base_model", "=", "xv_plda", "(", "args", ".", "extractor", ",", "args", ".", "plda", ",", "args", ".", "mean", ",", "args", ".", "transform", ",", "device", "=", "device", ",", "model_file", "=", "args", ".", "model_file", ",", "threshold", "=", "args", ".", "threshold", ")", "\n", "", "elif", "args", ".", "system_type", "==", "'audionet_csine'", ":", "\n", "        ", "base_model", "=", "audionet_csine", "(", "args", ".", "extractor", ",", "label_encoder", "=", "args", ".", "label_encoder", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Unsupported System Type'", ")", "\n", "\n", "", "defense", ",", "defense_name", "=", "parser_defense", "(", "args", ".", "defense", ",", "args", ".", "defense_param", ",", "args", ".", "defense_flag", ",", "args", ".", "defense_order", ")", "\n", "model", "=", "defended_model", "(", "base_model", "=", "base_model", ",", "defense", "=", "defense", ",", "order", "=", "args", ".", "defense_order", ")", "\n", "spk_ids", "=", "base_model", ".", "spk_ids", "\n", "\n", "wav_length", "=", "None", "if", "args", ".", "batch_size", "==", "1", "else", "args", ".", "wav_length", "\n", "# If you want to test the distance between ori and adv voices, you must make sure", "\n", "# the ori voice is not padded or cutted during adv voice generation, i.e., ", "\n", "# no batch attack (batch_size=1) and wav_length=None in attackMain.py", "\n", "# The reason is that if ori voice is not padded or cutted, the ori and adv voices will no longer align with each other,", "\n", "# and the impercpetibility result will be wrong", "\n", "if", "args", ".", "root_ori", "is", "not", "None", "and", "args", ".", "name_ori", "is", "not", "None", ":", "\n", "        ", "wav_length", "=", "None", "\n", "args", ".", "batch_size", "=", "1", "# force set args.batch_size to 1", "\n", "warnings", ".", "warn", "(", "'You want to test the imperceptibility. \\\n        Make sure you set batch_size to 1 and wav_length to None for attackMain.py when generating adv. voices \\\n            Otherwise, the adv. and ori. voices will not align with each other. \\\n                and the imperceptibility result is wrong.'", ")", "\n", "\n", "", "dataset", "=", "Dataset", "(", "spk_ids", ",", "args", ".", "root", ",", "args", ".", "name", ",", "return_file_name", "=", "True", ",", "wav_length", "=", "wav_length", ")", "\n", "loader", "=", "DataLoader", "(", "dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "num_workers", "=", "0", ")", "\n", "\n", "if", "args", ".", "root_ori", "is", "not", "None", "and", "args", ".", "name_ori", "is", "not", "None", ":", "\n", "        ", "ori_dataset", "=", "Dataset", "(", "spk_ids", ",", "args", ".", "root_ori", ",", "args", ".", "name_ori", ",", "return_file_name", "=", "True", ",", "wav_length", "=", "wav_length", ")", "\n", "ori_loader", "=", "DataLoader", "(", "ori_dataset", ",", "batch_size", "=", "args", ".", "batch_size", ",", "num_workers", "=", "0", ")", "\n", "name2ori", "=", "{", "}", "\n", "for", "index", ",", "(", "origin", ",", "_", ",", "file_name", ")", "in", "enumerate", "(", "ori_loader", ")", ":", "\n", "            ", "origin", "=", "origin", ".", "to", "(", "device", ")", "\n", "name2ori", "[", "file_name", "[", "0", "]", "]", "=", "origin", "# single audio, since args.batch_size=1", "\n", "\n", "", "", "if", "args", ".", "target_label_file", "is", "not", "None", ":", "\n", "        ", "with", "open", "(", "args", ".", "target_label_file", ",", "'rb'", ")", "as", "reader", ":", "\n", "            ", "name2target", "=", "pickle", ".", "load", "(", "reader", ")", "\n", "\n", "", "", "right_cnt", "=", "0", "\n", "target_success_cnt", "=", "0", "\n", "imper", "=", "[", "]", "# imperceptibilty results", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "index", ",", "(", "adver", ",", "true", ",", "file_name", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "adver", "=", "adver", ".", "to", "(", "device", ")", "\n", "true", "=", "true", ".", "to", "(", "device", ")", "\n", "decisions", ",", "_", "=", "model", ".", "make_decision", "(", "adver", ")", "\n", "right_cnt", "+=", "torch", ".", "where", "(", "true", "==", "decisions", ")", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "# print('*' * 10, index, '*' * 10)", "\n", "# print(true, decisions) ", "\n", "\n", "# get target label", "\n", "target", "=", "None", "\n", "if", "args", ".", "target_label_file", "is", "not", "None", ":", "\n", "                ", "target", "=", "true", ".", "clone", "(", ")", "\n", "for", "ii", ",", "name", "in", "enumerate", "(", "file_name", ")", ":", "\n", "                    ", "if", "name", "in", "name2target", ".", "keys", "(", ")", ":", "\n", "                        ", "target", "[", "ii", "]", "=", "name2target", "[", "name", "]", "\n", "", "else", ":", "\n", "                        ", "raise", "NotImplementedError", "(", "'Wrong target label file'", ")", "\n", "# print(target)", "\n", "", "", "target_success_cnt", "+=", "torch", ".", "where", "(", "target", "==", "decisions", ")", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# get original audios", "\n", "", "if", "args", ".", "root_ori", "is", "not", "None", "and", "args", ".", "name_ori", "is", "not", "None", ":", "\n", "                ", "imper_", "=", "get_all_metric", "(", "name2ori", "[", "file_name", "[", "0", "]", "]", ",", "adver", ")", "\n", "imper", ".", "append", "(", "imper_", ")", "\n", "# print(imper_)", "\n", "\n", "", "print", "(", "(", "f\"index: {index} true: {true} target: {target} decision: {decisions}\"", ")", ",", "end", "=", "'\\r'", ")", "\n", "\n", "", "", "print", "(", ")", "\n", "total_cnt", "=", "len", "(", "dataset", ")", "\n", "ACC", "=", "right_cnt", "*", "100", "/", "total_cnt", "\n", "print", "(", "'Acc:'", ",", "ACC", ")", "\n", "untar_ASR", "=", "100.", "-", "ACC", "\n", "print", "(", "'Untargeted Attack Success Rate:'", ",", "untar_ASR", ")", "\n", "if", "args", ".", "target_label_file", "is", "not", "None", ":", "\n", "        ", "target_ASR", "=", "target_success_cnt", "*", "100", "/", "total_cnt", "\n", "print", "(", "'Targeted Attack Success Rate:'", ",", "target_ASR", ")", "\n", "", "if", "args", ".", "root_ori", "is", "not", "None", "and", "args", ".", "name_ori", "is", "not", "None", ":", "\n", "# check for abnormal imper", "\n", "        ", "imper", "=", "[", "imper_", "for", "imper_", "in", "imper", "if", "imper_", "[", "4", "]", "!=", "np", ".", "infty", "]", "\n", "imper", "=", "np", ".", "mean", "(", "np", ".", "array", "(", "imper", ")", ",", "axis", "=", "0", ")", "\n", "# print('L2, L0, L1, Linf, SNR, PESQ, STOI', imper)", "\n", "print", "(", "'L2, SNR, PESQ: {:.3f} {:.2f} {:.2f}'", ".", "format", "(", "imper", "[", "0", "]", ",", "imper", "[", "4", "]", ",", "imper", "[", "5", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.PGD.PGD.__init__": [[11, 39], ["max", "max", "attack.utils.resolve_loss", "adaptive_attack.EOT.EOT", "print"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "task", "=", "'CSI'", ",", "epsilon", "=", "0.002", ",", "step_size", "=", "0.0004", ",", "max_iter", "=", "10", ",", "num_random_init", "=", "0", ",", "\n", "loss", "=", "'Entropy'", ",", "targeted", "=", "False", ",", "\n", "batch_size", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "\n", "verbose", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "# remember to call model.eval()", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "step_size", "=", "step_size", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "num_random_init", "=", "num_random_init", "\n", "self", ".", "loss_name", "=", "loss", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "EOT_size", "=", "max", "(", "1", ",", "EOT_size", ")", "\n", "EOT_batch_size", "=", "max", "(", "1", ",", "EOT_batch_size", ")", "\n", "assert", "EOT_size", "%", "EOT_batch_size", "==", "0", ",", "'EOT size should be divisible by EOT batch size'", "\n", "self", ".", "EOT_size", "=", "EOT_size", "\n", "self", ".", "EOT_batch_size", "=", "EOT_batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "threshold", "=", "None", "\n", "if", "self", ".", "task", "in", "[", "'SV'", ",", "'OSI'", "]", ":", "\n", "            ", "self", ".", "threshold", "=", "self", ".", "model", ".", "threshold", "\n", "print", "(", "'Running white box attack for {} task, directly using the true threshold {}'", ".", "format", "(", "self", ".", "task", ",", "self", ".", "threshold", ")", ")", "\n", "", "self", ".", "loss", ",", "self", ".", "grad_sign", "=", "resolve_loss", "(", "loss_name", "=", "self", ".", "loss_name", ",", "targeted", "=", "self", ".", "targeted", ",", "\n", "task", "=", "self", ".", "task", ",", "threshold", "=", "self", ".", "threshold", ",", "clip_max", "=", "False", ")", "\n", "self", ".", "EOT_wrapper", "=", "EOT", "(", "self", ".", "model", ",", "self", ".", "loss", ",", "self", ".", "EOT_size", ",", "self", ".", "EOT_batch_size", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.PGD.PGD.attack": [[40, 80], ["x.size", "torch.clamp", "torch.clamp", "min", "int", "x.clone", "range", "x.max", "numpy.ceil", "max", "range", "PGD.PGD.attack_batch", "float", "torch.tensor", "torch.cat", "sum", "len", "sum", "len", "numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack_batch"], ["", "def", "attack", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "\n", "        ", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "assert", "lower", "<=", "x", ".", "max", "(", ")", "<", "upper", ",", "'generating adversarial examples should be done in [-1, 1) float domain'", "\n", "n_audios", ",", "n_channels", ",", "max_len", "=", "x", ".", "size", "(", ")", "\n", "assert", "n_channels", "==", "1", ",", "'Only Support Mono Audio'", "\n", "assert", "y", ".", "shape", "[", "0", "]", "==", "n_audios", ",", "'The number of x and y should be equal'", "\n", "upper", "=", "torch", ".", "clamp", "(", "x", "+", "self", ".", "epsilon", ",", "max", "=", "upper", ")", "\n", "lower", "=", "torch", ".", "clamp", "(", "x", "-", "self", ".", "epsilon", ",", "min", "=", "lower", ")", "\n", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "n_audios", ")", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "n_audios", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "\n", "x_ori", "=", "x", ".", "clone", "(", ")", "\n", "best_success_rate", "=", "-", "1", "\n", "best_success", "=", "None", "\n", "best_adver_x", "=", "None", "\n", "for", "init", "in", "range", "(", "max", "(", "1", ",", "self", ".", "num_random_init", ")", ")", ":", "\n", "            ", "if", "self", ".", "num_random_init", ">", "0", ":", "\n", "                ", "x", "=", "x_ori", "+", "torch", ".", "tensor", "(", "np", ".", "random", ".", "uniform", "(", "-", "self", ".", "epsilon", ",", "self", ".", "epsilon", ",", "(", "n_audios", ",", "n_channels", ",", "max_len", ")", ")", ",", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "", "for", "batch_id", "in", "range", "(", "n_batches", ")", ":", "\n", "                ", "x_batch", "=", "x", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "# (batch_size, 1, max_len)", "\n", "y_batch", "=", "y", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "lower_batch", "=", "lower", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "upper_batch", "=", "upper", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "adver_x_batch", ",", "success_batch", "=", "self", ".", "attack_batch", "(", "x_batch", ",", "y_batch", ",", "lower_batch", ",", "upper_batch", ",", "'{}-{}'", ".", "format", "(", "init", ",", "batch_id", ")", ")", "\n", "if", "batch_id", "==", "0", ":", "\n", "                    ", "adver_x", "=", "adver_x_batch", "\n", "success", "=", "success_batch", "\n", "", "else", ":", "\n", "                    ", "adver_x", "=", "torch", ".", "cat", "(", "(", "adver_x", ",", "adver_x_batch", ")", ",", "0", ")", "\n", "success", "+=", "success_batch", "\n", "", "", "if", "sum", "(", "success", ")", "/", "len", "(", "success", ")", ">", "best_success_rate", ":", "\n", "                ", "best_success_rate", "=", "sum", "(", "success", ")", "/", "len", "(", "success", ")", "\n", "best_success", "=", "success", "\n", "best_adver_x", "=", "adver_x", "\n", "\n", "", "", "return", "best_adver_x", ",", "best_success", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.SirenAttack.SirenAttack.__init__": [[11, 38], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "threshold", "=", "None", ",", "\n", "task", "=", "'CSI'", ",", "targeted", "=", "False", ",", "confidence", "=", "0.", ",", "\n", "epsilon", "=", "0.002", ",", "max_epoch", "=", "300", ",", "max_iter", "=", "30", ",", "\n", "c1", "=", "1.4961", ",", "c2", "=", "1.4961", ",", "n_particles", "=", "25", ",", "w_init", "=", "0.9", ",", "w_end", "=", "0.1", ",", "\n", "batch_size", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "verbose", "=", "1", ",", "abort_early", "=", "True", ",", "abort_early_iter", "=", "10", ",", "abort_early_epoch", "=", "10", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "max_epoch", "=", "max_epoch", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "c1", "=", "c1", "\n", "self", ".", "c2", "=", "c2", "\n", "self", ".", "n_particles", "=", "n_particles", "\n", "self", ".", "w_init", "=", "w_init", "\n", "self", ".", "w_end", "=", "w_end", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "EOT_size", "=", "EOT_size", "\n", "self", ".", "EOT_batch_size", "=", "EOT_batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "abort_early", "=", "abort_early", "\n", "self", ".", "abort_early_iter", "=", "abort_early_iter", "\n", "self", ".", "abort_early_epoch", "=", "abort_early_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.SirenAttack.SirenAttack.attack_batch": [[40, 189], ["torch.no_grad", "torch.abs", "x_batch.clone", "list", "torch.zeros", "numpy.array", "gbests.clone", "gbests.clone", "range", "enumerate", "range", "torch.ones", "torch.cat.clone", "numpy.random.uniform", "torch.tensor", "range", "numpy.random.uniform", "torch.tensor", "torch.argmin", "numpy.random.uniform", "torch.tensor", "torch.cat", "torch.cat", "eval_x.view.view.view", "enumerate", "SirenAttack.SirenAttack.EOT_wrapper", "int", "loss.view.view.view", "attack.utils.resolve_prediction().reshape", "torch.where", "update_index[].cpu().numpy().tolist", "update_index[].cpu().numpy().tolist", "torch.argmin", "range", "SirenAttack.SirenAttack.delete_found", "gbests.clone", "torch.ones", "torch.ones", "v_lower.unsqueeze().cpu().numpy", "torch.abs.unsqueeze().cpu().numpy", "x_batch.unsqueeze", "torch.tensor", "len", "len", "len", "zip", "print", "gbests.clone", "len", "torch.abs", "torch.tensor", "torch.tensor", "torch.min", "torch.mean", "print", "lower.unsqueeze().cpu().numpy", "upper.unsqueeze().cpu().numpy", "lower.unsqueeze().cpu().numpy", "upper.unsqueeze().cpu().numpy", "best_location.unsqueeze", "len", "pbests[].unsqueeze", "len", "torch.cat", "attack.utils.resolve_prediction", "update_index[].cpu().numpy", "update_index[].cpu().numpy", "torch.mean", "print", "numpy.random.rand", "numpy.random.rand", "torch.max", "upper.unsqueeze", "torch.mean", "numpy.arange", "len", "v_lower.unsqueeze().cpu", "torch.abs.unsqueeze().cpu", "y_batch.cpu().numpy().tolist", "gbests[].cpu().numpy().tolist", "torch.mean", "len", "len", "lower.unsqueeze", "lower.unsqueeze().cpu", "upper.unsqueeze().cpu", "len", "lower.unsqueeze().cpu", "upper.unsqueeze().cpu", "update_index[].cpu", "update_index[].cpu", "gbest_location[].unsqueeze", "v_lower.unsqueeze", "torch.abs.unsqueeze", "y_batch.cpu().numpy", "gbests[].cpu().numpy", "lower.unsqueeze", "upper.unsqueeze", "lower.unsqueeze", "upper.unsqueeze", "numpy.arange", "y_batch.cpu", "gbests[].cpu", "len"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.delete_found", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_prediction"], ["", "def", "attack_batch", "(", "self", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "batch_id", ")", ":", "\n", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "v_upper", "=", "torch", ".", "abs", "(", "lower", "-", "upper", ")", "\n", "v_lower", "=", "-", "v_upper", "\n", "\n", "x_batch_clone", "=", "x_batch", ".", "clone", "(", ")", "# for return", "\n", "n_audios", ",", "n_channels", ",", "N", "=", "x_batch", ".", "shape", "\n", "consider_index", "=", "list", "(", "range", "(", "n_audios", ")", ")", "\n", "# pbest_locations = np.random.uniform(low=lower.unsqueeze(1).cpu().numpy(),", "\n", "#                     high=upper.unsqueeze(1).cpu().numpy(), size=(n_audios, self.n_particles, n_channels, N))", "\n", "# pbest_locations = torch.tensor(pbest_locations, device=x_batch.device, dtype=torch.float)", "\n", "\n", "gbest_location", "=", "torch", ".", "zeros", "(", "n_audios", ",", "n_channels", ",", "N", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "gbests", "=", "torch", ".", "ones", "(", "n_audios", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "*", "np", ".", "infty", "\n", "gbest_predict", "=", "np", ".", "array", "(", "[", "None", "]", "*", "n_audios", ")", "\n", "prev_gbest", "=", "gbests", ".", "clone", "(", ")", "\n", "prev_gbest_epoch", "=", "gbests", ".", "clone", "(", ")", "\n", "\n", "continue_flag", "=", "True", "\n", "for", "epoch", "in", "range", "(", "self", ".", "max_epoch", ")", ":", "\n", "\n", "                ", "if", "not", "continue_flag", ":", "\n", "                    ", "break", "\n", "\n", "", "if", "epoch", "==", "0", ":", "\n", "                    ", "pbest_locations", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "lower", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "high", "=", "upper", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "size", "=", "(", "n_audios", ",", "self", ".", "n_particles", ",", "n_channels", ",", "N", ")", ")", "\n", "pbest_locations", "=", "torch", ".", "tensor", "(", "pbest_locations", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "pbests", "=", "torch", ".", "ones", "(", "n_audios", ",", "self", ".", "n_particles", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "*", "np", ".", "infty", "\n", "", "else", ":", "\n", "                    ", "best_index", "=", "torch", ".", "argmin", "(", "pbests", ",", "dim", "=", "1", ")", "# (len(consider_index), )", "\n", "best_location", "=", "pbest_locations", "[", "np", ".", "arange", "(", "len", "(", "consider_index", ")", ")", ",", "best_index", "]", "# (len(consider_index), n_channels, N)", "\n", "pbest_locations", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "lower", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "high", "=", "upper", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "size", "=", "(", "len", "(", "consider_index", ")", ",", "self", ".", "n_particles", "-", "1", ",", "n_channels", ",", "N", ")", ")", "\n", "pbest_locations", "=", "torch", ".", "tensor", "(", "pbest_locations", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "pbest_locations", "=", "torch", ".", "cat", "(", "(", "best_location", ".", "unsqueeze", "(", "1", ")", ",", "pbest_locations", ")", ",", "dim", "=", "1", ")", "\n", "pbests_new", "=", "torch", ".", "ones", "(", "len", "(", "consider_index", ")", ",", "self", ".", "n_particles", "-", "1", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "*", "np", ".", "infty", "\n", "pbests", "=", "torch", ".", "cat", "(", "(", "pbests", "[", "np", ".", "arange", "(", "len", "(", "consider_index", ")", ")", ",", "best_index", "]", ".", "unsqueeze", "(", "1", ")", ",", "pbests_new", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "locations", "=", "pbest_locations", ".", "clone", "(", ")", "\n", "# volicities = np.random.uniform(low=lower.unsqueeze(1).cpu().numpy(),", "\n", "#                 high=upper.unsqueeze(1).cpu().numpy(), size=(len(consider_index), self.n_particles, n_channels, N))", "\n", "volicities", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "v_lower", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "high", "=", "v_upper", ".", "unsqueeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "size", "=", "(", "len", "(", "consider_index", ")", ",", "self", ".", "n_particles", ",", "n_channels", ",", "N", ")", ")", "\n", "volicities", "=", "torch", ".", "tensor", "(", "volicities", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "### ????", "\n", "# pbests = torch.ones(len(consider_index), self.n_particles, device=x_batch.device, dtype=torch.float) * np.infty", "\n", "\n", "continue_flag_inner", "=", "True", "\n", "\n", "# for iter in range(self.max_iter):", "\n", "for", "iter", "in", "range", "(", "self", ".", "max_iter", "+", "1", ")", ":", "\n", "\n", "                    ", "if", "not", "continue_flag_inner", ":", "\n", "                        ", "break", "\n", "\n", "", "eval_x", "=", "locations", "+", "x_batch", ".", "unsqueeze", "(", "1", ")", "# (n_audios, self.n_particles, n_channels, N)", "\n", "eval_x", "=", "eval_x", ".", "view", "(", "-", "1", ",", "n_channels", ",", "N", ")", "\n", "eval_y", "=", "None", "\n", "for", "jj", ",", "y_", "in", "enumerate", "(", "y_batch", ")", ":", "\n", "                        ", "tmp", "=", "torch", ".", "tensor", "(", "[", "y_", "]", "*", "self", ".", "n_particles", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "if", "jj", "==", "0", ":", "\n", "                            ", "eval_y", "=", "tmp", "\n", "", "else", ":", "\n", "                            ", "eval_y", "=", "torch", ".", "cat", "(", "(", "eval_y", ",", "tmp", ")", ")", "\n", "# print(eval_x.shape, eval_y.shape)", "\n", "", "", "_", ",", "loss", ",", "_", ",", "decisions", "=", "self", ".", "EOT_wrapper", "(", "eval_x", ",", "eval_y", ")", "\n", "EOT_num_batches", "=", "int", "(", "self", ".", "EOT_wrapper", ".", "EOT_size", "//", "self", ".", "EOT_wrapper", ".", "EOT_batch_size", ")", "\n", "loss", ".", "data", "/=", "EOT_num_batches", "# (n_audios*n_p,)", "\n", "loss", "=", "loss", ".", "view", "(", "len", "(", "consider_index", ")", ",", "-", "1", ")", "# (n_audios, n_p)", "\n", "predict", "=", "resolve_prediction", "(", "decisions", ")", ".", "reshape", "(", "len", "(", "consider_index", ")", ",", "-", "1", ")", "\n", "\n", "update_index", "=", "torch", ".", "where", "(", "loss", "<", "pbests", ")", "\n", "update_ii", "=", "update_index", "[", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "update_jj", "=", "update_index", "[", "1", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "update_ii", ")", ">", "0", ":", "\n", "                        ", "for", "ii", ",", "jj", "in", "zip", "(", "update_ii", ",", "update_jj", ")", ":", "\n", "                            ", "pbests", "[", "ii", ",", "jj", "]", "=", "loss", "[", "ii", ",", "jj", "]", "\n", "pbest_locations", "[", "ii", ",", "jj", ",", "...", "]", "=", "locations", "[", "ii", ",", "jj", ",", "...", "]", "\n", "\n", "# if self.abort_early and (iter+1) % self.abort_early_iter == 0:", "\n", "#     prev_gbest.data = gbests", "\n", "\n", "", "", "gbest_index", "=", "torch", ".", "argmin", "(", "pbests", ",", "1", ")", "\n", "for", "kk", "in", "range", "(", "gbest_index", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "index", "=", "consider_index", "[", "kk", "]", "\n", "if", "pbests", "[", "kk", ",", "gbest_index", "[", "kk", "]", "]", "<", "gbests", "[", "index", "]", ":", "\n", "                            ", "gbests", "[", "index", "]", "=", "pbests", "[", "kk", ",", "gbest_index", "[", "kk", "]", "]", "\n", "gbest_location", "[", "index", "]", "=", "pbest_locations", "[", "kk", ",", "gbest_index", "[", "kk", "]", "]", "\n", "gbest_predict", "[", "index", "]", "=", "predict", "[", "kk", ",", "gbest_index", "[", "kk", "]", "]", "\n", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "                        ", "print", "(", "'batch: {}, epoch: {}, iter: {}, y: {}, y_pred: {}, gbest: {}'", ".", "format", "(", "batch_id", ",", "\n", "epoch", ",", "iter", ",", "y_batch", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ",", "gbest_predict", "[", "consider_index", "]", ",", "gbests", "[", "consider_index", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "abort_early", "and", "(", "iter", "+", "1", ")", "%", "self", ".", "abort_early_iter", "==", "0", ":", "\n", "                        ", "if", "torch", ".", "mean", "(", "gbests", ")", ">", "0.9999", "*", "torch", ".", "mean", "(", "prev_gbest", ")", ":", "\n", "                            ", "print", "(", "'Converge, Break Inner Loop'", ")", "\n", "continue_flag_inner", "=", "False", "\n", "# break", "\n", "# prev_gbest.data = gbests", "\n", "", "prev_gbest", "=", "gbests", ".", "clone", "(", ")", "\n", "\n", "# stop early", "\n", "# x_batch, y_batch, lower, upper", "\n", "# pbest_locations, locations, v, pbests", "\n", "# consider_index", "\n", "# delete alrady found examples", "\n", "", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "pbest_locations", ",", "locations", ",", "volicities", ",", "pbests", ",", "consider_index", "=", "self", ".", "delete_found", "(", "gbests", "[", "consider_index", "]", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "\n", "pbest_locations", ",", "locations", ",", "volicities", ",", "pbests", ",", "\n", "consider_index", ")", "\n", "if", "len", "(", "consider_index", ")", "==", "0", ":", "\n", "                        ", "continue_flag", "=", "False", "# used to break the outer loop", "\n", "break", "\n", "", "else", ":", "\n", "                        ", "v_upper", "=", "torch", ".", "abs", "(", "lower", "-", "upper", ")", "\n", "v_lower", "=", "-", "v_upper", "\n", "\n", "", "if", "iter", "<", "self", ".", "max_iter", ":", "\n", "                        ", "w", "=", "(", "self", ".", "w_init", "-", "self", ".", "w_end", ")", "*", "(", "self", ".", "max_iter", "-", "iter", "-", "1", ")", "/", "self", ".", "max_iter", "+", "self", ".", "w_end", "\n", "# r1 = np.random.rand() + 0.00001", "\n", "# r2 = np.random.rand() + 0.00001", "\n", "r1", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "consider_index", ")", ",", "self", ".", "n_particles", ",", "n_channels", ",", "N", ")", "+", "0.00001", "\n", "r2", "=", "np", ".", "random", ".", "rand", "(", "len", "(", "consider_index", ")", ",", "self", ".", "n_particles", ",", "n_channels", ",", "N", ")", "+", "0.00001", "\n", "r1", "=", "torch", ".", "tensor", "(", "r1", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "r2", "=", "torch", ".", "tensor", "(", "r2", ",", "device", "=", "x_batch", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "volicities", "=", "(", "w", "*", "volicities", "+", "self", ".", "c1", "*", "r1", "*", "(", "pbest_locations", "-", "locations", ")", "+", "\n", "self", ".", "c2", "*", "r2", "*", "(", "gbest_location", "[", "consider_index", ",", "...", "]", ".", "unsqueeze", "(", "1", ")", "-", "locations", ")", ")", "\n", "locations", "=", "locations", "+", "volicities", "\n", "locations", "=", "torch", ".", "min", "(", "torch", ".", "max", "(", "locations", ",", "lower", ".", "unsqueeze", "(", "1", ")", ")", ",", "upper", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "", "", "if", "self", ".", "abort_early", "and", "(", "epoch", "+", "1", ")", "%", "self", ".", "abort_early_epoch", "==", "0", ":", "\n", "                    ", "if", "torch", ".", "mean", "(", "gbests", ")", ">", "0.9999", "*", "torch", ".", "mean", "(", "prev_gbest_epoch", ")", ":", "\n", "                        ", "print", "(", "'Converge, Break Outer Loop'", ")", "\n", "continue_flag", "=", "False", "\n", "# break", "\n", "", "prev_gbest_epoch", "=", "gbests", ".", "clone", "(", ")", "\n", "\n", "", "", "success", "=", "[", "False", "]", "*", "n_audios", "\n", "for", "kk", ",", "best_l", "in", "enumerate", "(", "gbests", ")", ":", "\n", "                ", "if", "best_l", "<", "0", ":", "\n", "                    ", "success", "[", "kk", "]", "=", "True", "\n", "\n", "", "", "return", "gbest_location", "+", "x_batch_clone", ",", "success", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.SirenAttack.SirenAttack.delete_found": [[191, 233], ["enumerate", "consider_index_u.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "", "def", "delete_found", "(", "self", ",", "gbests", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "\n", "pbest_locations", ",", "locations", ",", "volicities", ",", "pbests", ",", "\n", "consider_index", ")", ":", "\n", "\n", "        ", "x_batch_u", "=", "None", "\n", "y_batch_u", "=", "None", "\n", "lower_u", "=", "None", "\n", "upper_u", "=", "None", "\n", "pbest_locations_u", "=", "None", "\n", "locations_u", "=", "None", "\n", "volicities_u", "=", "None", "\n", "pbests_u", "=", "None", "\n", "consider_index_u", "=", "[", "]", "\n", "\n", "for", "ii", ",", "g", "in", "enumerate", "(", "gbests", ")", ":", "\n", "            ", "if", "g", "<", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "x_batch_u", "is", "None", ":", "\n", "                    ", "x_batch_u", "=", "x_batch", "[", "ii", ":", "ii", "+", "1", "]", "\n", "y_batch_u", "=", "y_batch", "[", "ii", ":", "ii", "+", "1", "]", "\n", "lower_u", "=", "lower", "[", "ii", ":", "ii", "+", "1", "]", "\n", "upper_u", "=", "upper", "[", "ii", ":", "ii", "+", "1", "]", "\n", "pbest_locations_u", "=", "pbest_locations", "[", "ii", ":", "ii", "+", "1", "]", "\n", "locations_u", "=", "locations", "[", "ii", ":", "ii", "+", "1", "]", "\n", "volicities_u", "=", "volicities", "[", "ii", ":", "ii", "+", "1", "]", "\n", "pbests_u", "=", "pbests", "[", "ii", ":", "ii", "+", "1", "]", "\n", "", "else", ":", "\n", "                    ", "x_batch_u", "=", "torch", ".", "cat", "(", "(", "x_batch_u", ",", "x_batch", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "y_batch_u", "=", "torch", ".", "cat", "(", "(", "y_batch_u", ",", "y_batch", "[", "ii", ":", "ii", "+", "1", "]", ")", ")", "\n", "lower_u", "=", "torch", ".", "cat", "(", "(", "lower_u", ",", "lower", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "upper_u", "=", "torch", ".", "cat", "(", "(", "upper_u", ",", "upper", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "pbest_locations_u", "=", "torch", ".", "cat", "(", "(", "pbest_locations_u", ",", "pbest_locations", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "locations_u", "=", "torch", ".", "cat", "(", "(", "locations_u", ",", "locations", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "volicities_u", "=", "torch", ".", "cat", "(", "(", "volicities_u", ",", "volicities", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "pbests_u", "=", "torch", ".", "cat", "(", "(", "pbests_u", ",", "pbests", "[", "ii", ":", "ii", "+", "1", "]", ")", ",", "0", ")", "\n", "", "index", "=", "consider_index", "[", "ii", "]", "\n", "consider_index_u", ".", "append", "(", "index", ")", "\n", "\n", "", "", "return", "x_batch_u", ",", "y_batch_u", ",", "lower_u", ",", "upper_u", ",", "pbest_locations_u", ",", "locations_u", ",", "volicities_u", ",", "pbests_u", ",", "consider_index_u", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.SirenAttack.SirenAttack.attack": [[235, 270], ["attack.utils.resolve_loss", "adaptive_attack.EOT.EOT", "x.size", "torch.clamp", "torch.clamp", "min", "int", "range", "NotImplementedError", "x.max", "numpy.ceil", "SirenAttack.SirenAttack.attack_batch", "torch.cat", "float"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack_batch"], ["", "def", "attack", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "\n", "        ", "if", "self", ".", "task", "in", "[", "'SV'", ",", "'OSI'", "]", "and", "self", ".", "threshold", "is", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'You are running black box attack for {} task, \\\n                        but the threshold not specified. Consider Estimating the threshold by FAKEBOB!'", ")", "\n", "", "self", ".", "loss", ",", "self", ".", "grad_sign", "=", "resolve_loss", "(", "'Margin'", ",", "self", ".", "targeted", ",", "self", ".", "confidence", ",", "self", ".", "task", ",", "self", ".", "threshold", ",", "False", ")", "\n", "self", ".", "EOT_wrapper", "=", "EOT", "(", "self", ".", "model", ",", "self", ".", "loss", ",", "self", ".", "EOT_size", ",", "self", ".", "EOT_batch_size", ",", "False", ")", "\n", "\n", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "assert", "lower", "<=", "x", ".", "max", "(", ")", "<", "upper", ",", "'generating adversarial examples should be done in [-1, 1) float domain'", "\n", "n_audios", ",", "n_channels", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "assert", "n_channels", "==", "1", ",", "'Only Support Mono Audio'", "\n", "assert", "y", ".", "shape", "[", "0", "]", "==", "n_audios", ",", "'The number of x and y should be equal'", "\n", "# upper = torch.clamp(x+self.epsilon, max=upper)", "\n", "# lower = torch.clamp(x-self.epsilon, min=lower)", "\n", "lower", "=", "torch", ".", "clamp", "(", "-", "1", "-", "x", ",", "min", "=", "-", "self", ".", "epsilon", ")", "# for distortion, not adver audio", "\n", "upper", "=", "torch", ".", "clamp", "(", "1", "-", "x", ",", "max", "=", "self", ".", "epsilon", ")", "# for distortion, not adver audio", "\n", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "n_audios", ")", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "n_audios", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "x_batch", "=", "x", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "# (batch_size, 1, max_len)", "\n", "y_batch", "=", "y", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "lower_batch", "=", "lower", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "upper_batch", "=", "upper", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "adver_x_batch", ",", "success_batch", "=", "self", ".", "attack_batch", "(", "x_batch", ",", "y_batch", ",", "lower_batch", ",", "upper_batch", ",", "batch_id", ")", "\n", "if", "batch_id", "==", "0", ":", "\n", "                ", "adver_x", "=", "adver_x_batch", "\n", "success", "=", "success_batch", "\n", "", "else", ":", "\n", "                ", "adver_x", "=", "torch", ".", "cat", "(", "(", "adver_x", ",", "adver_x_batch", ")", ",", "0", ")", "\n", "success", "+=", "success_batch", "\n", "\n", "", "", "return", "adver_x", ",", "success", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.CW2.CW2.__init__": [[9, 40], ["attack.utils.SEC4SR_MarginLoss", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "task", "=", "'CSI'", ",", "\n", "targeted", "=", "False", ",", "\n", "confidence", "=", "0.", ",", "\n", "initial_const", "=", "1e-3", ",", "\n", "binary_search_steps", "=", "9", ",", "\n", "max_iter", "=", "10000", ",", "\n", "stop_early", "=", "True", ",", "\n", "stop_early_iter", "=", "1000", ",", "\n", "lr", "=", "1e-2", ",", "\n", "batch_size", "=", "1", ",", "\n", "verbose", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "stop_early", "=", "stop_early", "\n", "self", ".", "stop_early_iter", "=", "stop_early_iter", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "threshold", "=", "None", "\n", "if", "self", ".", "task", "in", "[", "'SV'", ",", "'OSI'", "]", ":", "\n", "            ", "self", ".", "threshold", "=", "self", ".", "model", ".", "threshold", "\n", "print", "(", "'Running white box attack for {} task, directly using the true threshold {}'", ".", "format", "(", "self", ".", "task", ",", "self", ".", "threshold", ")", ")", "\n", "\n", "", "self", ".", "loss", "=", "SEC4SR_MarginLoss", "(", "targeted", "=", "self", ".", "targeted", ",", "confidence", "=", "self", ".", "confidence", ",", "task", "=", "self", ".", "task", ",", "threshold", "=", "self", ".", "threshold", ",", "clip_max", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.CW2.CW2.attack_batch": [[41, 133], ["torch.tensor", "torch.tensor", "torch.tensor", "x_batch.clone", "range", "enumerate", "torch.zeros_like", "torch.optim.Adam", "range", "enumerate", "print", "torch.tanh", "CW2.CW2.model.make_decision", "CW2.CW2.loss", "torch.sum", "decisions.detach().cpu().numpy", "scores.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "loss.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist", "loss1.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist", "loss2.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist", "enumerate", "torch.tensor.detach().cpu().numpy", "torch.square", "loss.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.backward", "CW2.CW2.optimizer.step", "CW2.CW2.modifier.grad.zero_", "print", "numpy.mean", "zip", "min", "max", "torch.atanh", "torch.ones_like", "decisions.detach().cpu", "scores.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "loss.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy", "loss1.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy", "loss2.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu().numpy", "numpy.mean", "print", "torch.tensor.detach().cpu", "torch.tensor.detach().cpu().numpy", "y_batch.detach().cpu().numpy", "decisions.detach", "scores.detach().cpu().numpy.detach().cpu().numpy.detach", "loss.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu", "loss1.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu", "loss2.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach().cpu", "torch.tensor.detach", "torch.tensor.detach().cpu", "y_batch.detach().cpu", "loss.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach", "loss1.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach", "loss2.detach().cpu().numpy().tolist.detach().cpu().numpy().tolist.detach", "torch.tensor.detach", "y_batch.detach"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "attack_batch", "(", "self", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "batch_id", ")", ":", "\n", "\n", "        ", "n_audios", ",", "_", ",", "_", "=", "x_batch", ".", "shape", "\n", "\n", "const", "=", "torch", ".", "tensor", "(", "[", "self", ".", "initial_const", "]", "*", "n_audios", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "lower_bound", "=", "torch", ".", "tensor", "(", "[", "0", "]", "*", "n_audios", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "upper_bound", "=", "torch", ".", "tensor", "(", "[", "1e10", "]", "*", "n_audios", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "\n", "global_best_l2", "=", "[", "np", ".", "infty", "]", "*", "n_audios", "\n", "global_best_adver_x", "=", "x_batch", ".", "clone", "(", ")", "\n", "# global_best_score = [-1] * n_audios", "\n", "global_best_score", "=", "[", "-", "2", "]", "*", "n_audios", "# do not use [-1] * n_audios since -1 is within the decision space of SV and OSI tasks ", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "binary_search_steps", ")", ":", "\n", "\n", "            ", "self", ".", "modifier", "=", "torch", ".", "zeros_like", "(", "x_batch", ",", "dtype", "=", "torch", ".", "float", ",", "requires_grad", "=", "True", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "[", "self", ".", "modifier", "]", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "best_l2", "=", "[", "np", ".", "infty", "]", "*", "n_audios", "\n", "# best_score = [-1] * n_audios", "\n", "best_score", "=", "[", "-", "2", "]", "*", "n_audios", "\n", "\n", "continue_flag", "=", "True", "\n", "prev_loss", "=", "np", ".", "infty", "\n", "# we need to perform the gradient descent max_iter times; ", "\n", "# the additional one iteration is used to to evaluate the final updated examples", "\n", "for", "n_iter", "in", "range", "(", "self", ".", "max_iter", "+", "1", ")", ":", "\n", "# for n_iter in range(self.max_iter):", "\n", "                ", "if", "not", "continue_flag", ":", "\n", "                    ", "break", "\n", "# deal with box constraint, [-1, 1], different from image", "\n", "", "input_x", "=", "torch", ".", "tanh", "(", "self", ".", "modifier", "+", "torch", ".", "atanh", "(", "x_batch", "*", "0.999999", ")", ")", "\n", "# scores = self.model(input_x) # (n_audios, n_spks)", "\n", "decisions", ",", "scores", "=", "self", ".", "model", ".", "make_decision", "(", "input_x", ")", "# (n_audios, n_spks)", "\n", "loss1", "=", "self", ".", "loss", "(", "scores", ",", "y_batch", ")", "\n", "loss2", "=", "torch", ".", "sum", "(", "torch", ".", "square", "(", "input_x", "-", "x_batch", ")", ",", "dim", "=", "(", "1", ",", "2", ")", ")", "\n", "loss", "=", "const", "*", "loss1", "+", "loss2", "\n", "\n", "if", "n_iter", "<", "self", ".", "max_iter", ":", "# we only perform gradient descent max_iter times", "\n", "                    ", "loss", ".", "backward", "(", "torch", ".", "ones_like", "(", "loss", ")", ")", "\n", "# update modifier", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "modifier", ".", "grad", ".", "zero_", "(", ")", "\n", "\n", "# predict = torch.argmax(scores.data, dim=1).detach().cpu().numpy() # not suitable for SV and OSI tasks which will reject", "\n", "", "predict", "=", "decisions", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scores", "=", "scores", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "loss", "=", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "loss1", "=", "loss1", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "loss2", "=", "loss2", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"batch: {}, c: {}, iter: {}, loss: {}, loss1: {}, loss2: {}, y_pred: {}, y: {}\"", ".", "format", "(", "\n", "batch_id", ",", "const", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "n_iter", ",", "\n", "loss", ",", "loss1", ",", "loss2", ",", "predict", ",", "y_batch", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "stop_early", "and", "n_iter", "%", "self", ".", "stop_early_iter", "==", "0", ":", "\n", "                    ", "if", "np", ".", "mean", "(", "loss", ")", ">", "0.9999", "*", "prev_loss", ":", "\n", "                        ", "print", "(", "\"Early Stop ! \"", ")", "\n", "continue_flag", "=", "False", "\n", "", "prev_loss", "=", "np", ".", "mean", "(", "loss", ")", "\n", "\n", "", "for", "ii", ",", "(", "l2", ",", "y_pred", ",", "adver_x", ",", "l1", ")", "in", "enumerate", "(", "zip", "(", "loss2", ",", "predict", ",", "input_x", ",", "loss1", ")", ")", ":", "\n", "# IF-BRANCH-1", "\n", "                    ", "if", "l1", "<=", "0", "and", "l2", "<", "best_l2", "[", "ii", "]", ":", "# l1 <= 0 indicates the attack succeed with at least kappa confidence", "\n", "                        ", "best_l2", "[", "ii", "]", "=", "l2", "\n", "best_score", "[", "ii", "]", "=", "y_pred", "\n", "# IF-BRANCH-2", "\n", "", "if", "l1", "<=", "0", "and", "l2", "<", "global_best_l2", "[", "ii", "]", ":", "# l1 <= 0 indicates the attack succeed with at least kappa confidence", "\n", "                        ", "global_best_l2", "[", "ii", "]", "=", "l2", "\n", "global_best_score", "[", "ii", "]", "=", "y_pred", "\n", "global_best_adver_x", "[", "ii", "]", "=", "adver_x", "\n", "\n", "", "", "", "for", "jj", ",", "y_pred", "in", "enumerate", "(", "best_score", ")", ":", "\n", "                ", "if", "y_pred", "!=", "-", "2", ":", "# y_pred != -2 infers that IF-BRANCH-1 is entered at least one time, thus the attack succeeds", "\n", "                    ", "upper_bound", "[", "jj", "]", "=", "min", "(", "upper_bound", "[", "jj", "]", ",", "const", "[", "jj", "]", ")", "\n", "if", "upper_bound", "[", "jj", "]", "<", "1e9", ":", "\n", "                        ", "const", "[", "jj", "]", "=", "(", "lower_bound", "[", "jj", "]", "+", "upper_bound", "[", "jj", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "                    ", "lower_bound", "[", "jj", "]", "=", "max", "(", "lower_bound", "[", "jj", "]", ",", "const", "[", "jj", "]", ")", "\n", "if", "upper_bound", "[", "jj", "]", "<", "1e9", ":", "\n", "                        ", "const", "[", "jj", "]", "=", "(", "lower_bound", "[", "jj", "]", "+", "upper_bound", "[", "jj", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "                        ", "const", "[", "jj", "]", "*=", "10", "\n", "\n", "", "", "", "print", "(", "const", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "best_l2", ",", "global_best_l2", ")", "\n", "\n", "", "success", "=", "[", "False", "]", "*", "n_audios", "\n", "for", "kk", ",", "y_pred", "in", "enumerate", "(", "global_best_score", ")", ":", "\n", "            ", "if", "y_pred", "!=", "-", "2", ":", "# y_pred != -2 infers that IF-BRANCH-2 is entered at least one time, thus the attack succeeds", "\n", "                ", "success", "[", "kk", "]", "=", "True", "\n", "\n", "", "", "return", "global_best_adver_x", ",", "success", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.CW2.CW2.attack": [[134, 136], ["super().attack"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack"], ["", "def", "attack", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "return", "super", "(", ")", ".", "attack", "(", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.Attack.Attack.attack": [[7, 10], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "attack", "(", "self", ",", "x", ",", "y", ",", "verbose", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.Attack.Attack.compare": [[11, 16], ["None"], "methods", ["None"], ["", "def", "compare", "(", "self", ",", "y", ",", "y_pred", ",", "targeted", ")", ":", "\n", "        ", "if", "targeted", ":", "\n", "            ", "return", "(", "y_pred", "==", "y", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "(", "y_pred", "!=", "y", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.__init__": [[16, 46], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "threshold", "=", "None", ",", "\n", "task", "=", "'CSI'", ",", "targeted", "=", "False", ",", "confidence", "=", "0.", ",", "\n", "epsilon", "=", "0.002", ",", "max_iter", "=", "1000", ",", "\n", "max_lr", "=", "0.001", ",", "min_lr", "=", "1e-6", ",", "\n", "samples_per_draw", "=", "50", ",", "samples_per_draw_batch_size", "=", "50", ",", "sigma", "=", "0.001", ",", "momentum", "=", "0.9", ",", "\n", "plateau_length", "=", "5", ",", "plateau_drop", "=", "2.", ",", "\n", "stop_early", "=", "True", ",", "stop_early_iter", "=", "100", ",", "\n", "batch_size", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "verbose", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "max_lr", "=", "max_lr", "\n", "self", ".", "min_lr", "=", "min_lr", "\n", "self", ".", "samples_per_draw", "=", "samples_per_draw", "\n", "self", ".", "samples_per_draw_batch_size", "=", "samples_per_draw_batch_size", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "plateau_length", "=", "plateau_length", "\n", "self", ".", "plateau_drop", "=", "plateau_drop", "\n", "self", ".", "stop_early", "=", "stop_early", "\n", "self", ".", "stop_early_iter", "=", "stop_early_iter", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "EOT_size", "=", "EOT_size", "\n", "self", ".", "EOT_batch_size", "=", "EOT_batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.attack_batch": [[50, 124], ["torch.no_grad", "x_batch.clone", "torch.zeros_like", "x_batch.clone.clone", "list", "range", "enumerate", "range", "torch.zeros_like.clone", "FAKEBOB.FAKEBOB.get_grad", "enumerate", "FAKEBOB.FAKEBOB.delete_found", "print", "enumerate", "torch.tensor().unsqueeze().unsqueeze", "torch.min", "adver_l.cpu().item", "last_ls[].append", "torch.max", "numpy.array", "FAKEBOB.FAKEBOB.delete_found", "adver_loss.cpu().numpy", "y_batch.cpu().numpy", "torch.tensor().unsqueeze", "torch.sign", "adver_l.cpu", "len", "max", "l.cpu", "numpy.array", "adver_loss.cpu", "y_batch.cpu", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.get_grad", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.delete_found", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.delete_found"], ["", "def", "attack_batch", "(", "self", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "batch_id", ")", ":", "\n", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "n_audios", ",", "_", ",", "_", "=", "x_batch", ".", "shape", "\n", "\n", "last_ls", "=", "[", "[", "]", "]", "*", "n_audios", "\n", "lr", "=", "[", "self", ".", "max_lr", "]", "*", "n_audios", "\n", "prev_loss", "=", "[", "np", ".", "infty", "]", "*", "n_audios", "\n", "\n", "adver_x", "=", "x_batch", ".", "clone", "(", ")", "\n", "grad", "=", "torch", ".", "zeros_like", "(", "x_batch", ",", "dtype", "=", "x_batch", ".", "dtype", ",", "device", "=", "x_batch", ".", "device", ")", "\n", "\n", "best_adver_x", "=", "adver_x", ".", "clone", "(", ")", "\n", "best_loss", "=", "[", "np", ".", "infty", "]", "*", "n_audios", "\n", "consider_index", "=", "list", "(", "range", "(", "n_audios", ")", ")", "\n", "\n", "for", "iter", "in", "range", "(", "self", ".", "max_iter", "+", "1", ")", ":", "\n", "                ", "prev_grad", "=", "grad", ".", "clone", "(", ")", "\n", "# loss, grad, adver_loss, scores = self.get_grad(adver_x, y_batch)", "\n", "loss", ",", "grad", ",", "adver_loss", ",", "_", ",", "y_pred", "=", "self", ".", "get_grad", "(", "adver_x", ",", "y_batch", ")", "\n", "# y_pred = torch.max(scores, 1)[1].cpu().numpy()", "\n", "\n", "for", "ii", ",", "adver_l", "in", "enumerate", "(", "adver_loss", ")", ":", "\n", "                    ", "index", "=", "consider_index", "[", "ii", "]", "\n", "if", "adver_l", "<", "best_loss", "[", "index", "]", ":", "\n", "                        ", "best_loss", "[", "index", "]", "=", "adver_l", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "best_adver_x", "[", "index", "]", "=", "adver_x", "[", "ii", "]", "\n", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"batch: {} iter: {}, loss: {}, y: {}, y_pred: {}, best loss: {}\"", ".", "format", "(", "\n", "batch_id", ",", "iter", ",", "\n", "adver_loss", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "y_batch", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "y_pred", ",", "best_loss", ")", ")", "\n", "\n", "# delete alrady found examples", "\n", "", "adver_x", ",", "y_batch", ",", "prev_grad", ",", "grad", ",", "lower", ",", "upper", ",", "consider_index", ",", "last_ls", ",", "lr", ",", "prev_loss", ",", "loss", "=", "self", ".", "delete_found", "(", "adver_loss", ",", "adver_x", ",", "y_batch", ",", "prev_grad", ",", "grad", ",", "lower", ",", "upper", ",", "\n", "consider_index", ",", "last_ls", ",", "lr", ",", "prev_loss", ",", "loss", ")", "\n", "if", "adver_x", "is", "None", ":", "# all found", "\n", "                    ", "break", "\n", "\n", "", "if", "iter", "<", "self", ".", "max_iter", ":", "\n", "                    ", "grad", "=", "self", ".", "momentum", "*", "prev_grad", "+", "(", "1.0", "-", "self", ".", "momentum", ")", "*", "grad", "\n", "for", "jj", ",", "loss_", "in", "enumerate", "(", "loss", ")", ":", "\n", "                        ", "last_ls", "[", "jj", "]", ".", "append", "(", "loss_", ")", "\n", "last_ls", "[", "jj", "]", "=", "last_ls", "[", "jj", "]", "[", "-", "self", ".", "plateau_length", ":", "]", "\n", "if", "last_ls", "[", "jj", "]", "[", "-", "1", "]", ">", "last_ls", "[", "jj", "]", "[", "0", "]", "and", "len", "(", "last_ls", "[", "jj", "]", ")", "==", "self", ".", "plateau_length", ":", "\n", "                            ", "if", "lr", "[", "jj", "]", ">", "self", ".", "min_lr", ":", "\n", "                                ", "lr", "[", "jj", "]", "=", "max", "(", "lr", "[", "jj", "]", "/", "self", ".", "plateau_drop", ",", "self", ".", "min_lr", ")", "\n", "", "last_ls", "[", "jj", "]", "=", "[", "]", "\n", "\n", "", "", "lr_t", "=", "torch", ".", "tensor", "(", "lr", ",", "device", "=", "adver_x", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "adver_x", ".", "data", "=", "adver_x", "+", "self", ".", "grad_sign", "*", "lr_t", "*", "torch", ".", "sign", "(", "grad", ")", "\n", "adver_x", ".", "data", "=", "torch", ".", "min", "(", "torch", ".", "max", "(", "adver_x", ".", "data", ",", "lower", ")", ",", "upper", ")", "\n", "\n", "if", "self", ".", "stop_early", "and", "iter", "%", "self", ".", "stop_early_iter", "==", "0", ":", "\n", "                        ", "loss_np", "=", "np", ".", "array", "(", "[", "l", ".", "cpu", "(", ")", "for", "l", "in", "loss", "]", ")", "\n", "converge_loss", "=", "np", ".", "array", "(", "prev_loss", ")", "*", "0.9999", "-", "loss_np", "\n", "adver_x", ",", "y_batch", ",", "prev_grad", ",", "grad", ",", "lower", ",", "upper", ",", "consider_index", ",", "last_ls", ",", "lr", ",", "prev_loss", ",", "loss", "=", "self", ".", "delete_found", "(", "converge_loss", ",", "adver_x", ",", "y_batch", ",", "prev_grad", ",", "grad", ",", "lower", ",", "upper", ",", "\n", "consider_index", ",", "last_ls", ",", "lr", ",", "prev_loss", ",", "loss", ")", "\n", "if", "adver_x", "is", "None", ":", "# all converage", "\n", "                            ", "break", "\n", "\n", "", "prev_loss", "=", "loss_np", "\n", "\n", "", "", "", "success", "=", "[", "False", "]", "*", "n_audios", "\n", "for", "kk", ",", "best_l", "in", "enumerate", "(", "best_loss", ")", ":", "\n", "                ", "if", "best_l", "<", "0", ":", "\n", "                    ", "success", "[", "kk", "]", "=", "True", "\n", "\n", "", "", "return", "best_adver_x", ",", "success", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.delete_found": [[125, 169], ["enumerate", "consider_index_u.append", "last_ls_u.append", "lr_u.append", "prev_loss_u.append", "loss_u.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "", "def", "delete_found", "(", "self", ",", "adver_loss", ",", "adver_x", ",", "y_batch", ",", "prev_grad", ",", "grad", ",", "lower", ",", "upper", ",", "\n", "consider_index", ",", "last_ls", ",", "lr", ",", "prev_loss", ",", "loss", ")", ":", "\n", "        ", "adver_x_u", "=", "None", "\n", "y_batch_u", "=", "None", "\n", "prev_grad_u", "=", "None", "\n", "grad_u", "=", "None", "\n", "lower_u", "=", "None", "\n", "upper_u", "=", "None", "\n", "\n", "consider_index_u", "=", "[", "]", "\n", "last_ls_u", "=", "[", "]", "\n", "lr_u", "=", "[", "]", "\n", "prev_loss_u", "=", "[", "]", "\n", "loss_u", "=", "[", "]", "\n", "\n", "for", "ii", ",", "adver_l", "in", "enumerate", "(", "adver_loss", ")", ":", "\n", "            ", "if", "adver_l", "<", "0", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "if", "adver_x_u", "is", "None", ":", "\n", "                    ", "adver_x_u", "=", "adver_x", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", "\n", "y_batch_u", "=", "y_batch", "[", "ii", ":", "ii", "+", "1", "]", "\n", "prev_grad_u", "=", "prev_grad", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", "\n", "grad_u", "=", "grad", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", "\n", "lower_u", "=", "lower", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", "\n", "upper_u", "=", "upper", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", "\n", "", "else", ":", "\n", "                    ", "adver_x_u", "=", "torch", ".", "cat", "(", "(", "adver_x_u", ",", "adver_x", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", ")", ",", "0", ")", "\n", "y_batch_u", "=", "torch", ".", "cat", "(", "(", "y_batch_u", ",", "y_batch", "[", "ii", ":", "ii", "+", "1", "]", ")", ")", "\n", "prev_grad_u", "=", "torch", ".", "cat", "(", "(", "prev_grad_u", ",", "prev_grad", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", ")", ",", "0", ")", "\n", "grad_u", "=", "torch", ".", "cat", "(", "(", "grad_u", ",", "grad", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", ")", ",", "0", ")", "\n", "lower_u", "=", "torch", ".", "cat", "(", "(", "lower_u", ",", "lower", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", ")", ",", "0", ")", "\n", "upper_u", "=", "torch", ".", "cat", "(", "(", "upper_u", ",", "upper", "[", "ii", ":", "ii", "+", "1", ",", "...", "]", ")", ",", "0", ")", "\n", "", "index", "=", "consider_index", "[", "ii", "]", "\n", "consider_index_u", ".", "append", "(", "index", ")", "\n", "last_ls_u", ".", "append", "(", "last_ls", "[", "ii", "]", ")", "\n", "lr_u", ".", "append", "(", "lr", "[", "ii", "]", ")", "\n", "prev_loss_u", ".", "append", "(", "prev_loss", "[", "ii", "]", ")", "\n", "loss_u", ".", "append", "(", "loss", "[", "ii", "]", ")", "\n", "\n", "", "", "return", "adver_x_u", ",", "y_batch_u", ",", "prev_grad_u", ",", "grad_u", ",", "lower_u", ",", "upper_u", ",", "consider_index_u", ",", "last_ls_u", ",", "lr_u", ",", "prev_loss_u", ",", "loss_u", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.get_grad": [[170, 175], ["adaptive_attack.NES.NES", "adaptive_attack.NES.NES."], "methods", ["None"], ["", "def", "get_grad", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "NES_wrapper", "=", "NES", "(", "self", ".", "samples_per_draw", ",", "self", ".", "samples_per_draw_batch_size", ",", "self", ".", "sigma", ",", "self", ".", "EOT_wrapper", ")", "\n", "mean_loss", ",", "grad", ",", "adver_loss", ",", "adver_score", ",", "predict", "=", "NES_wrapper", "(", "x", ",", "y", ")", "\n", "\n", "return", "mean_loss", ",", "grad", ",", "adver_loss", ",", "adver_score", ",", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.attack": [[176, 209], ["attack.utils.resolve_loss", "adaptive_attack.EOT.EOT", "x.size", "torch.clamp", "torch.clamp", "min", "int", "range", "NotImplementedError", "x.max", "numpy.ceil", "FAKEBOB.FAKEBOB.attack_batch", "torch.cat", "float"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack_batch"], ["", "def", "attack", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "\n", "        ", "if", "self", ".", "task", "in", "[", "'SV'", ",", "'OSI'", "]", "and", "self", ".", "threshold", "is", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'You are running black box attack for {} task, \\\n                        but the threshold not specified. Consider calling estimate threshold'", ")", "\n", "", "self", ".", "loss", ",", "self", ".", "grad_sign", "=", "resolve_loss", "(", "'Margin'", ",", "self", ".", "targeted", ",", "self", ".", "confidence", ",", "self", ".", "task", ",", "self", ".", "threshold", ",", "False", ")", "\n", "self", ".", "EOT_wrapper", "=", "EOT", "(", "self", ".", "model", ",", "self", ".", "loss", ",", "self", ".", "EOT_size", ",", "self", ".", "EOT_batch_size", ",", "False", ")", "\n", "\n", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "assert", "lower", "<=", "x", ".", "max", "(", ")", "<", "upper", ",", "'generating adversarial examples should be done in [-1, 1) float domain'", "\n", "n_audios", ",", "n_channels", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "assert", "n_channels", "==", "1", ",", "'Only Support Mono Audio'", "\n", "assert", "y", ".", "shape", "[", "0", "]", "==", "n_audios", ",", "'The number of x and y should be equal'", "\n", "upper", "=", "torch", ".", "clamp", "(", "x", "+", "self", ".", "epsilon", ",", "max", "=", "upper", ")", "\n", "lower", "=", "torch", ".", "clamp", "(", "x", "-", "self", ".", "epsilon", ",", "min", "=", "lower", ")", "\n", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "n_audios", ")", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "n_audios", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "x_batch", "=", "x", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "# (batch_size, 1, max_len)", "\n", "y_batch", "=", "y", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "lower_batch", "=", "lower", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "upper_batch", "=", "upper", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "adver_x_batch", ",", "success_batch", "=", "self", ".", "attack_batch", "(", "x_batch", ",", "y_batch", ",", "lower_batch", ",", "upper_batch", ",", "batch_id", ")", "\n", "if", "batch_id", "==", "0", ":", "\n", "                ", "adver_x", "=", "adver_x_batch", "\n", "success", "=", "success_batch", "\n", "", "else", ":", "\n", "                ", "adver_x", "=", "torch", ".", "cat", "(", "(", "adver_x", ",", "adver_x_batch", ")", ",", "0", ")", "\n", "success", "+=", "success_batch", "\n", "\n", "", "", "return", "adver_x", ",", "success", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.estimate_threshold_run": [[210, 279], ["FAKEBOB.FAKEBOB.model.make_decision", "torch.tensor", "numpy.max", "numpy.abs", "x.clone", "torch.zeros_like", "torch.clamp", "torch.clamp", "s.cpu().numpy", "attack.utils.resolve_loss", "adaptive_attack.EOT.EOT", "FAKEBOB.FAKEBOB.model.make_decision", "numpy.max", "print", "torch.zeros_like.clone", "FAKEBOB.FAKEBOB.get_grad", "enumerate", "torch.tensor().unsqueeze().unsqueeze", "torch.min", "s.cpu", "numpy.max.cpu().numpy", "last_ls[].append", "torch.max", "torch.tensor().unsqueeze", "torch.sign", "numpy.max.cpu", "len", "max", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.get_grad"], ["", "def", "estimate_threshold_run", "(", "self", ",", "x", ",", "step", "=", "0.1", ")", ":", "\n", "\n", "        ", "n_audios", ",", "_", ",", "_", "=", "x", ".", "shape", "\n", "\n", "d", ",", "s", "=", "self", ".", "model", ".", "make_decision", "(", "x", ")", "\n", "d", "=", "d", "[", "0", "]", "\n", "s", "=", "s", "[", "0", "]", "\n", "if", "d", "!=", "-", "1", ":", "\n", "            ", "return", "# aleady accept, cannot be used to estimate threshold", "\n", "", "y", "=", "torch", ".", "tensor", "(", "[", "-", "1", "]", "*", "n_audios", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "x", ".", "device", ")", "\n", "init_score", "=", "np", ".", "max", "(", "s", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "delta", "=", "np", ".", "abs", "(", "init_score", "*", "step", ")", "\n", "threshold", "=", "init_score", "+", "delta", "\n", "\n", "adver_x", "=", "x", ".", "clone", "(", ")", "\n", "grad", "=", "torch", ".", "zeros_like", "(", "x", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "\n", "\n", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "upper", "=", "torch", ".", "clamp", "(", "x", "+", "self", ".", "epsilon", ",", "max", "=", "upper", ")", "\n", "lower", "=", "torch", ".", "clamp", "(", "x", "-", "self", ".", "epsilon", ",", "min", "=", "lower", ")", "\n", "\n", "iter_outer", "=", "0", "\n", "n_iters", "=", "0", "\n", "\n", "while", "True", ":", "\n", "            ", "self", ".", "loss", ",", "self", ".", "grad_sign", "=", "resolve_loss", "(", "'Margin'", ",", "False", ",", "0.", ",", "self", ".", "task", ",", "threshold", ",", "False", ")", "\n", "self", ".", "EOT_wrapper", "=", "EOT", "(", "self", ".", "model", ",", "self", ".", "loss", ",", "self", ".", "EOT_size", ",", "self", ".", "EOT_batch_size", ",", "False", ")", "\n", "\n", "iter_inner", "=", "0", "\n", "\n", "last_ls", "=", "[", "[", "]", "]", "*", "n_audios", "\n", "lr", "=", "[", "self", ".", "max_lr", "]", "*", "n_audios", "\n", "\n", "while", "True", ":", "\n", "\n", "# test whether succeed", "\n", "                ", "decision", ",", "score", "=", "self", ".", "model", ".", "make_decision", "(", "adver_x", ")", "\n", "decision", "=", "decision", "[", "0", "]", "\n", "score", "=", "score", "[", "0", "]", "\n", "score", "=", "np", ".", "max", "(", "score", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "print", "(", "iter_outer", ",", "iter_inner", ",", "score", ",", "self", ".", "model", ".", "threshold", ")", "\n", "if", "decision", "!=", "-", "1", ":", "# succeed, found the threshold", "\n", "                    ", "return", "score", "\n", "", "elif", "score", ">=", "threshold", ":", "# exceed the candidate threshold, but not succeed, exit the inner loop and increase the threshold", "\n", "                    ", "break", "\n", "\n", "# not succeed, update", "\n", "", "prev_grad", "=", "grad", ".", "clone", "(", ")", "\n", "loss", ",", "grad", ",", "_", ",", "_", ",", "_", "=", "self", ".", "get_grad", "(", "adver_x", ",", "y", ")", "\n", "\n", "grad", "=", "self", ".", "momentum", "*", "prev_grad", "+", "(", "1.0", "-", "self", ".", "momentum", ")", "*", "grad", "\n", "for", "jj", ",", "loss_", "in", "enumerate", "(", "loss", ")", ":", "\n", "                    ", "last_ls", "[", "jj", "]", ".", "append", "(", "loss_", ")", "\n", "last_ls", "[", "jj", "]", "=", "last_ls", "[", "jj", "]", "[", "-", "self", ".", "plateau_length", ":", "]", "\n", "if", "last_ls", "[", "jj", "]", "[", "-", "1", "]", ">", "last_ls", "[", "jj", "]", "[", "0", "]", "and", "len", "(", "last_ls", "[", "jj", "]", ")", "==", "self", ".", "plateau_length", ":", "\n", "                        ", "if", "lr", "[", "jj", "]", ">", "self", ".", "min_lr", ":", "\n", "                            ", "lr", "[", "jj", "]", "=", "max", "(", "lr", "[", "jj", "]", "/", "self", ".", "plateau_drop", ",", "self", ".", "min_lr", ")", "\n", "", "last_ls", "[", "jj", "]", "=", "[", "]", "\n", "\n", "", "", "lr_t", "=", "torch", ".", "tensor", "(", "lr", ",", "device", "=", "adver_x", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "adver_x", ".", "data", "=", "adver_x", "+", "self", ".", "grad_sign", "*", "lr_t", "*", "torch", ".", "sign", "(", "grad", ")", "\n", "adver_x", ".", "data", "=", "torch", ".", "min", "(", "torch", ".", "max", "(", "adver_x", ".", "data", ",", "lower", ")", ",", "upper", ")", "\n", "\n", "iter_inner", "+=", "1", "\n", "n_iters", "+=", "1", "\n", "\n", "", "threshold", "+=", "delta", "\n", "iter_outer", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.estimate_threshold": [[280, 296], ["print", "torch.no_grad", "x.unsqueeze", "FAKEBOB.FAKEBOB.estimate_threshold_run", "len", "numpy.mean", "estimated_thresholds.append"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FAKEBOB.FAKEBOB.estimate_threshold_run"], ["", "", "def", "estimate_threshold", "(", "self", ",", "x", ",", "step", "=", "0.1", ")", ":", "\n", "        ", "if", "self", ".", "task", "==", "'CSI'", ":", "\n", "            ", "print", "(", "\"--- Warning: no need to estimate threshold for CSI, quitting ---\"", ")", "\n", "return", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "estimated_thresholds", "=", "[", "]", "\n", "for", "xx", "in", "x", ".", "unsqueeze", "(", "0", ")", ":", "# parallel running, not easy for batch running", "\n", "                ", "estimated_threshold", "=", "self", ".", "estimate_threshold_run", "(", "xx", ",", "step", ")", "\n", "if", "estimated_threshold", "is", "not", "None", ":", "\n", "                    ", "estimated_thresholds", ".", "append", "(", "estimated_threshold", ")", "\n", "", "", "if", "len", "(", "estimated_thresholds", ")", ">", "0", ":", "\n", "                ", "self", ".", "threshold", "=", "np", ".", "mean", "(", "estimated_thresholds", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "threshold", "=", "None", "\n", "", "return", "self", ".", "threshold", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.CWinf.CWinf.__init__": [[7, 17], ["attack.PGD.PGD.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "task", "=", "'CSI'", ",", "epsilon", "=", "0.002", ",", "step_size", "=", "0.0004", ",", "max_iter", "=", "10", ",", "num_random_init", "=", "0", ",", "\n", "loss", "=", "'Margin'", ",", "targeted", "=", "False", ",", "\n", "batch_size", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "\n", "verbose", "=", "1", ")", ":", "\n", "\n", "        ", "loss", "=", "'Margin'", "# hard coding: using Margin Loss", "\n", "super", "(", ")", ".", "__init__", "(", "model", ",", "task", "=", "task", ",", "epsilon", "=", "epsilon", ",", "step_size", "=", "step_size", ",", "max_iter", "=", "max_iter", ",", "num_random_init", "=", "num_random_init", ",", "\n", "loss", "=", "loss", ",", "targeted", "=", "targeted", ",", "\n", "batch_size", "=", "batch_size", ",", "EOT_size", "=", "EOT_size", ",", "EOT_batch_size", "=", "EOT_batch_size", ",", "\n", "verbose", "=", "verbose", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.SEC4SR_CrossEntropy.__init__": [[9, 13], ["torch.CrossEntropyLoss.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "weight", "=", "None", ",", "size_average", "=", "None", ",", "ignore_index", "=", "-", "100", ",", "reduce", "=", "None", ",", "reduction", "=", "'mean'", ",", "task", "=", "'CSI'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "weight", "=", "weight", ",", "size_average", "=", "size_average", ",", "ignore_index", "=", "ignore_index", ",", "reduce", "=", "reduce", ",", "reduction", "=", "reduction", ")", "\n", "\n", "assert", "task", "==", "'CSI'", "# CrossEntropy only supports CSI task", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.SEC4SR_CrossEntropy.forward": [[14, 30], ["label.to.to.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "[].detach().cpu().numpy().tolist", "[].detach().cpu().numpy().tolist", "len", "len", "super().forward", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "[].detach().cpu", "[].detach().cpu", "[].detach", "[].detach", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.forward"], ["", "def", "forward", "(", "self", ",", "scores", ",", "label", ")", ":", "\n", "\n", "        ", "_", ",", "num_class", "=", "scores", ".", "shape", "\n", "device", "=", "scores", ".", "device", "\n", "label", "=", "label", ".", "to", "(", "device", ")", "\n", "loss", "=", "torch", ".", "zeros", "(", "label", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "scores", ".", "device", ")", "\n", "\n", "consider_index", "=", "torch", ".", "nonzero", "(", "label", "!=", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "consider_index", ")", ">", "0", ":", "\n", "            ", "loss", "[", "consider_index", "]", "=", "super", "(", ")", ".", "forward", "(", "scores", "[", "consider_index", "]", ",", "label", "[", "consider_index", "]", ")", "\n", "\n", "", "imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "imposter_index", ")", ":", "\n", "            ", "loss", "[", "imposter_index", "]", "=", "0.", "*", "torch", ".", "sum", "(", "scores", "[", "imposter_index", "]", ")", "# make backward", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.SEC4SR_MarginLoss.__init__": [[33, 40], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "targeted", "=", "False", ",", "confidence", "=", "0.", ",", "task", "=", "'CSI'", ",", "threshold", "=", "None", ",", "clip_max", "=", "True", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.SEC4SR_MarginLoss.forward": [[41, 103], ["label.to.to.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "[].detach().cpu().numpy().tolist", "[].detach().cpu().numpy().tolist", "torch.max", "torch.max", "torch.max", "torch.max", "len", "len", "[].detach().cpu().numpy().tolist", "[].detach().cpu().numpy().tolist", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "[].detach().cpu().numpy", "[].detach().cpu().numpy", "len", "len", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "len", "scores[].squeeze", "scores[].squeeze", "[].detach().cpu().numpy", "int", "torch.max", "torch.max", "torch.max", "torch.max", "[].detach().cpu().numpy", "len", "[].detach().cpu", "[].detach().cpu", "scores[].squeeze", "scores[].squeeze", "len", "torch.minimum", "torch.minimum", "torch.minimum", "torch.minimum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "[].detach().cpu", "[].detach().cpu", "[].detach", "[].detach", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.max", "torch.max", "torch.max", "torch.max", "[].detach", "torch.max", "torch.max", "torch.max", "torch.max", "[].detach", "torch.max", "torch.max", "torch.max", "torch.max", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "forward", "(", "self", ",", "scores", ",", "label", ")", ":", "\n", "        ", "_", ",", "num_class", "=", "scores", ".", "shape", "\n", "device", "=", "scores", ".", "device", "\n", "label", "=", "label", ".", "to", "(", "device", ")", "\n", "loss", "=", "torch", ".", "zeros", "(", "label", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "scores", ".", "device", ")", "\n", "confidence", "=", "torch", ".", "tensor", "(", "self", ".", "confidence", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "\n", "if", "self", ".", "task", "==", "'SV'", ":", "\n", "            ", "enroll_index", "=", "torch", ".", "nonzero", "(", "label", "==", "0", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "enroll_index", ")", "+", "len", "(", "imposter_index", ")", "==", "label", ".", "shape", "[", "0", "]", ",", "'SV task should not have labels out of 0 and -1'", "\n", "if", "len", "(", "enroll_index", ")", ">", "0", ":", "\n", "                ", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "enroll_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "scores", "[", "enroll_index", "]", ".", "squeeze", "(", "1", ")", "# imposter --> enroll, authentication bypass", "\n", "", "else", ":", "\n", "                    ", "loss", "[", "enroll_index", "]", "=", "scores", "[", "enroll_index", "]", ".", "squeeze", "(", "1", ")", "+", "confidence", "-", "self", ".", "threshold", "# enroll --> imposter, Denial of Service", "\n", "", "", "if", "len", "(", "imposter_index", ")", ">", "0", ":", "\n", "                ", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "imposter_index", "]", "=", "scores", "[", "imposter_index", "]", ".", "squeeze", "(", "1", ")", "+", "confidence", "-", "self", ".", "threshold", "# enroll --> imposter, Denial of Service", "\n", "", "else", ":", "\n", "                    ", "loss", "[", "imposter_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "scores", "[", "imposter_index", "]", ".", "squeeze", "(", "1", ")", "# imposter --> enroll, authentication bypass", "\n", "\n", "", "", "", "elif", "self", ".", "task", "==", "'CSI'", "or", "self", ".", "task", "==", "'OSI'", ":", "\n", "# remove imposter index which is unmeaningful for CSI task", "\n", "            ", "consider_index", "=", "torch", ".", "nonzero", "(", "label", "!=", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "consider_index", ")", ">", "0", ":", "\n", "                ", "label_one_hot", "=", "torch", ".", "zeros", "(", "(", "len", "(", "consider_index", ")", ",", "num_class", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "ii", "in", "enumerate", "(", "consider_index", ")", ":", "\n", "                    ", "index", "=", "int", "(", "label", "[", "ii", "]", ")", "\n", "label_one_hot", "[", "i", "]", "[", "index", "]", "=", "1", "\n", "", "score_real", "=", "torch", ".", "sum", "(", "label_one_hot", "*", "scores", "[", "consider_index", "]", ",", "dim", "=", "1", ")", "\n", "score_other", "=", "torch", ".", "max", "(", "(", "1", "-", "label_one_hot", ")", "*", "scores", "[", "consider_index", "]", "-", "label_one_hot", "*", "10000", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "consider_index", "]", "=", "score_other", "+", "confidence", "-", "score_real", "if", "self", ".", "task", "==", "'CSI'", "else", "torch", ".", "clamp", "(", "score_other", ",", "min", "=", "self", ".", "threshold", ")", "+", "confidence", "-", "score_real", "\n", "", "else", ":", "\n", "                    ", "if", "self", ".", "task", "==", "'CSI'", ":", "\n", "                        ", "loss", "[", "consider_index", "]", "=", "score_real", "+", "confidence", "-", "score_other", "\n", "", "else", ":", "\n", "                        ", "f_reject", "=", "torch", ".", "max", "(", "scores", "[", "consider_index", "]", ",", "1", ")", "[", "0", "]", "+", "confidence", "-", "self", ".", "threshold", "# spk m --> reject", "\n", "f_mis", "=", "torch", ".", "clamp", "(", "score_real", ",", "min", "=", "self", ".", "threshold", ")", "+", "confidence", "-", "score_other", "# spk_m --> spk_n", "\n", "loss", "[", "consider_index", "]", "=", "torch", ".", "minimum", "(", "f_reject", ",", "f_mis", ")", "\n", "\n", "", "", "", "imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "self", ".", "task", "==", "'OSI'", ":", "\n", "# imposter_index = torch.nonzero(label == -1, as_tuple=True)[0].detach().cpu().numpy().tolist()", "\n", "                ", "if", "len", "(", "imposter_index", ")", ">", "0", ":", "\n", "                    ", "if", "self", ".", "targeted", ":", "\n", "                        ", "loss", "[", "imposter_index", "]", "=", "torch", ".", "max", "(", "scores", "[", "imposter_index", "]", ",", "1", ")", "[", "0", "]", "+", "confidence", "-", "self", ".", "threshold", "\n", "", "else", ":", "\n", "                        ", "loss", "[", "imposter_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "torch", ".", "max", "(", "scores", "[", "imposter_index", "]", ",", "1", ")", "[", "0", "]", "\n", "", "", "", "else", ":", "# CSI", "\n", "                ", "if", "len", "(", "imposter_index", ")", ":", "\n", "                    ", "loss", "[", "imposter_index", "]", "=", "0.", "*", "torch", ".", "sum", "(", "scores", "[", "imposter_index", "]", ")", "# make backward", "\n", "\n", "# else:", "\n", "#     loss[imposter_index] = torch.zeros(len(imposter_index))", "\n", "\n", "", "", "", "if", "self", ".", "clip_max", ":", "\n", "            ", "loss", "=", "torch", ".", "max", "(", "torch", ".", "tensor", "(", "0", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", ",", "loss", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss": [[104, 117], ["utils.SEC4SR_MarginLoss", "utils.SEC4SR_CrossEntropy", "warnings.warn", "int"], "function", ["None"], ["", "", "def", "resolve_loss", "(", "loss_name", "=", "'Entropy'", ",", "targeted", "=", "False", ",", "confidence", "=", "0.", ",", "task", "=", "'CSI'", ",", "threshold", "=", "None", ",", "clip_max", "=", "True", ")", ":", "\n", "    ", "assert", "loss_name", "in", "[", "'Entropy'", ",", "'Margin'", "]", "\n", "assert", "task", "in", "[", "'CSI'", ",", "'SV'", ",", "'OSI'", "]", "\n", "if", "task", "==", "'SV'", "or", "task", "==", "'OSI'", "or", "loss_name", "==", "'Margin'", ":", "# SV/OSI: ignore loss name, force using Margin Loss", "\n", "        ", "loss", "=", "SEC4SR_MarginLoss", "(", "targeted", "=", "targeted", ",", "confidence", "=", "confidence", ",", "task", "=", "task", ",", "threshold", "=", "threshold", ",", "clip_max", "=", "clip_max", ")", "\n", "if", "(", "task", "==", "'SV'", "or", "task", "==", "'OSI'", ")", "and", "loss_name", "==", "'Entropy'", ":", "\n", "            ", "warnings", ".", "warn", "(", "'You are targeting {} task. Force using Margin Loss.'", ")", "\n", "", "", "else", ":", "\n", "# loss = nn.CrossEntropyLoss(reduction='none') # ONLY FOR CSI TASK", "\n", "        ", "loss", "=", "SEC4SR_CrossEntropy", "(", "reduction", "=", "'none'", ",", "task", "=", "'CSI'", ")", "# ONLY FOR CSI TASK", "\n", "", "grad_sign", "=", "(", "1", "-", "2", "*", "int", "(", "targeted", ")", ")", "if", "loss_name", "==", "'Entropy'", "else", "-", "1", "\n", "\n", "return", "loss", ",", "grad_sign", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_prediction": [[118, 126], ["numpy.array", "collections.Counter", "np.array.append", "collections.Counter.most_common"], "function", ["None"], ["", "def", "resolve_prediction", "(", "decisions", ")", ":", "\n", "# print(decisions)", "\n", "    ", "predict", "=", "[", "]", "\n", "for", "d", "in", "decisions", ":", "\n", "        ", "counts", "=", "Counter", "(", "d", ")", "\n", "predict", ".", "append", "(", "counts", ".", "most_common", "(", "1", ")", "[", "0", "]", "[", "0", "]", ")", "\n", "", "predict", "=", "np", ".", "array", "(", "predict", ")", "\n", "return", "predict", "\n", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.__init__": [[10, 37], ["max", "max", "attack.utils.resolve_loss", "adaptive_attack.EOT.EOT", "print"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_loss"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "task", "=", "'CSI'", ",", "epsilon", "=", "0.002", ",", "loss", "=", "'Entropy'", ",", "targeted", "=", "False", ",", "\n", "batch_size", "=", "1", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "\n", "verbose", "=", "1", ")", ":", "\n", "\n", "        ", "self", ".", "model", "=", "model", "# remember to call model.eval()", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "loss_name", "=", "loss", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "EOT_size", "=", "max", "(", "1", ",", "EOT_size", ")", "\n", "EOT_batch_size", "=", "max", "(", "1", ",", "EOT_batch_size", ")", "\n", "assert", "EOT_size", "%", "EOT_batch_size", "==", "0", ",", "'EOT size should be divisible by EOT batch size'", "\n", "self", ".", "EOT_size", "=", "EOT_size", "\n", "self", ".", "EOT_batch_size", "=", "EOT_batch_size", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "threshold", "=", "None", "\n", "if", "self", ".", "task", "in", "[", "'SV'", ",", "'OSI'", "]", ":", "\n", "            ", "self", ".", "threshold", "=", "self", ".", "model", ".", "threshold", "\n", "print", "(", "'Running white box attack for {} task, directly using the true threshold {}'", ".", "format", "(", "self", ".", "task", ",", "self", ".", "threshold", ")", ")", "\n", "", "self", ".", "loss", ",", "self", ".", "grad_sign", "=", "resolve_loss", "(", "loss_name", "=", "self", ".", "loss_name", ",", "targeted", "=", "self", ".", "targeted", ",", "\n", "task", "=", "self", ".", "task", ",", "threshold", "=", "self", ".", "threshold", ",", "clip_max", "=", "False", ")", "\n", "self", ".", "EOT_wrapper", "=", "EOT", "(", "self", ".", "model", ",", "self", ".", "loss", ",", "self", ".", "EOT_size", ",", "self", ".", "EOT_batch_size", ",", "True", ")", "\n", "\n", "self", ".", "max_iter", "=", "1", "# FGSM is single step attack, keep in consistency with PGD", "\n", "self", ".", "step_size", "=", "epsilon", "# keep in consistency with PGD", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack_batch": [[38, 71], ["x_batch.clone.clone.clone", "range", "FGSM.FGSM.EOT_wrapper", "attack.utils.resolve_prediction", "y_batch.detach().cpu().numpy", "FGSM.FGSM.compare", "int", "print", "x_batch.clone.clone.grad.zero_", "torch.min", "y_batch.detach().cpu", "torch.max", "loss.detach().cpu().numpy().tolist", "torch.sign", "y_batch.detach", "loss.detach().cpu().numpy", "loss.detach().cpu", "loss.detach"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_prediction", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.Attack.Attack.compare"], ["", "def", "attack_batch", "(", "self", ",", "x_batch", ",", "y_batch", ",", "lower", ",", "upper", ",", "batch_id", ")", ":", "\n", "\n", "        ", "x_batch", "=", "x_batch", ".", "clone", "(", ")", "# avoid influcing", "\n", "# x_batch.retain_grad()", "\n", "x_batch", ".", "requires_grad", "=", "True", "\n", "success", "=", "None", "\n", "for", "iter", "in", "range", "(", "self", ".", "max_iter", "+", "1", ")", ":", "\n", "            ", "EOT_num_batches", "=", "int", "(", "self", ".", "EOT_size", "//", "self", ".", "EOT_batch_size", ")", "if", "iter", "<", "self", ".", "max_iter", "else", "1", "\n", "real_EOT_batch_size", "=", "self", ".", "EOT_batch_size", "if", "iter", "<", "self", ".", "max_iter", "else", "1", "\n", "use_grad", "=", "True", "if", "iter", "<", "self", ".", "max_iter", "else", "False", "\n", "# scores, loss, grad = EOT_wrapper(x_batch, y_batch, EOT_num_batches, real_EOT_batch_size, use_grad)", "\n", "scores", ",", "loss", ",", "grad", ",", "decisions", "=", "self", ".", "EOT_wrapper", "(", "x_batch", ",", "y_batch", ",", "EOT_num_batches", ",", "real_EOT_batch_size", ",", "use_grad", ")", "\n", "scores", ".", "data", "=", "scores", "/", "EOT_num_batches", "\n", "loss", ".", "data", "=", "loss", "/", "EOT_num_batches", "\n", "if", "iter", "<", "self", ".", "max_iter", ":", "\n", "                ", "grad", ".", "data", "=", "grad", "/", "EOT_num_batches", "\n", "# predict = torch.argmax(scores.data, dim=1).detach().cpu().numpy()", "\n", "", "predict", "=", "resolve_prediction", "(", "decisions", ")", "\n", "target", "=", "y_batch", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "success", "=", "self", ".", "compare", "(", "target", ",", "predict", ",", "self", ".", "targeted", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"batch:{} iter:{} loss: {} predict: {}, target: {}\"", ".", "format", "(", "batch_id", ",", "iter", ",", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ",", "predict", ",", "target", ")", ")", "\n", "\n", "", "if", "iter", "<", "self", ".", "max_iter", ":", "\n", "                ", "x_batch", ".", "grad", "=", "grad", "\n", "# x_batch.data += self.epsilon * torch.sign(x_batch.grad) * self.grad_sign", "\n", "## x_batch.data += self.epsilon * torch.sign(grad) * self.grad_sign", "\n", "x_batch", ".", "data", "+=", "self", ".", "step_size", "*", "torch", ".", "sign", "(", "x_batch", ".", "grad", ")", "*", "self", ".", "grad_sign", "\n", "x_batch", ".", "grad", ".", "zero_", "(", ")", "\n", "# x_batch.data = torch.clamp(x_batch.data, min=lower, max=upper)", "\n", "x_batch", ".", "data", "=", "torch", ".", "min", "(", "torch", ".", "max", "(", "x_batch", ".", "data", ",", "lower", ")", ",", "upper", ")", "\n", "\n", "", "", "return", "x_batch", ",", "success", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack": [[72, 99], ["x.size", "torch.tensor().expand_as", "torch.tensor().expand_as", "min", "int", "range", "x.max", "numpy.ceil", "FGSM.FGSM.attack_batch", "torch.tensor", "torch.tensor", "torch.cat", "float"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.FGSM.FGSM.attack_batch"], ["", "def", "attack", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "\n", "        ", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "assert", "lower", "<=", "x", ".", "max", "(", ")", "<", "upper", ",", "'generating adversarial examples should be done in [-1, 1) float domain'", "\n", "n_audios", ",", "n_channels", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "assert", "n_channels", "==", "1", ",", "'Only Support Mono Audio'", "\n", "assert", "y", ".", "shape", "[", "0", "]", "==", "n_audios", ",", "'The number of x and y should be equal'", "\n", "lower", "=", "torch", ".", "tensor", "(", "lower", ",", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", ".", "expand_as", "(", "x", ")", "\n", "upper", "=", "torch", ".", "tensor", "(", "upper", ",", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", ".", "expand_as", "(", "x", ")", "\n", "\n", "batch_size", "=", "min", "(", "self", ".", "batch_size", ",", "n_audios", ")", "\n", "n_batches", "=", "int", "(", "np", ".", "ceil", "(", "n_audios", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "range", "(", "n_batches", ")", ":", "\n", "            ", "x_batch", "=", "x", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "# (batch_size, 1, max_len)", "\n", "y_batch", "=", "y", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "lower_batch", "=", "lower", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "upper_batch", "=", "upper", "[", "batch_id", "*", "batch_size", ":", "(", "batch_id", "+", "1", ")", "*", "batch_size", "]", "\n", "adver_x_batch", ",", "success_batch", "=", "self", ".", "attack_batch", "(", "x_batch", ",", "y_batch", ",", "lower_batch", ",", "upper_batch", ",", "batch_id", ")", "\n", "if", "batch_id", "==", "0", ":", "\n", "                ", "adver_x", "=", "adver_x_batch", "\n", "success", "=", "success_batch", "\n", "", "else", ":", "\n", "                ", "adver_x", "=", "torch", ".", "cat", "(", "(", "adver_x", ",", "adver_x_batch", ")", ",", "0", ")", "\n", "success", "+=", "success_batch", "\n", "\n", "", "", "return", "adver_x", ",", "success", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Spk251_test.Spk251_test.__init__": [[6, 12], ["dataset.Dataset.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "        ", "normalize", "=", "True", "\n", "bits", "=", "16", "\n", "super", "(", ")", ".", "__init__", "(", "spk_ids", ",", "root", ",", "'Spk251_test'", ",", "\n", "normalize", "=", "normalize", ",", "bits", "=", "bits", ",", "\n", "return_file_name", "=", "return_file_name", ",", "wav_length", "=", "wav_length", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Spk251_train.Spk251_train.__init__": [[6, 12], ["dataset.Dataset.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "        ", "normalize", "=", "True", "\n", "bits", "=", "16", "\n", "super", "(", ")", ".", "__init__", "(", "spk_ids", ",", "root", ",", "'Spk251_train'", ",", "\n", "normalize", "=", "normalize", ",", "bits", "=", "bits", ",", "\n", "return_file_name", "=", "return_file_name", ",", "wav_length", "=", "wav_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Spk10_test.Spk10_test.__init__": [[6, 13], ["dataset.Dataset.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "\n", "        ", "normalize", "=", "False", "\n", "bits", "=", "16", "\n", "super", "(", ")", ".", "__init__", "(", "spk_ids", ",", "root", ",", "'Spk10_test'", ",", "\n", "normalize", "=", "normalize", ",", "bits", "=", "bits", ",", "\n", "return_file_name", "=", "return_file_name", ",", "wav_length", "=", "wav_length", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Dataset.Dataset.__init__": [[22, 61], ["os.path.join", "os.listdir", "os.path.exists", "os.system", "os.system", "os.path.join", "os.listdir", "name2url.keys", "NotImplementedError", "torch.utils.data.Dataset.Dataset.audio_paths.append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "name", ",", "normalize", "=", "False", ",", "bits", "=", "16", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "        ", "\"\"\"[summary]\n\n        Parameters\n        ----------\n        spk_ids : list or tuple. Elements should be str.\n            The ids of the speakers to be recognized. Should consistent with model.spk_ids\n        root : [type]\n            [description]\n        normalize : bool, optional\n            [description], by default False\n        bits : int, optional\n            [description], by default 16\n        return_file_name : bool, optional\n            [description], by default False\n        \"\"\"", "\n", "self", ".", "spk_ids", "=", "spk_ids", "\n", "self", ".", "root", "=", "os", ".", "path", ".", "join", "(", "root", ",", "name", ")", "\n", "# not exist, download", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "root", ")", ":", "\n", "            ", "if", "name", "not", "in", "name2url", ".", "keys", "(", ")", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'No download url for {}'", ".", "format", "(", "name", ")", ")", "\n", "", "url", "=", "url_prefix", "+", "name2url", "[", "name", "]", "+", "url_suffix", "\n", "download_command", "=", "'gdown {}'", ".", "format", "(", "url", ")", "\n", "os", ".", "system", "(", "download_command", ")", "\n", "tar_command", "=", "'tar -xzf {}.tar.gz'", ".", "format", "(", "name", ")", "\n", "os", ".", "system", "(", "tar_command", ")", "\n", "", "spk_iter", "=", "os", ".", "listdir", "(", "self", ".", "root", ")", "\n", "self", ".", "audio_paths", "=", "[", "]", "\n", "for", "spk_id", "in", "spk_iter", ":", "\n", "            ", "spk_dir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "spk_id", ")", "\n", "audio_iter", "=", "os", ".", "listdir", "(", "spk_dir", ")", "\n", "for", "audio_name", "in", "audio_iter", ":", "\n", "                ", "self", ".", "audio_paths", ".", "append", "(", "(", "spk_id", ",", "audio_name", ")", ")", "\n", "\n", "", "", "self", ".", "normalize", "=", "normalize", "\n", "self", ".", "bits", "=", "bits", "\n", "self", ".", "return_file_name", "=", "return_file_name", "\n", "self", ".", "wav_length", "=", "wav_length", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Dataset.Dataset.__len__": [[62, 64], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "audio_paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Dataset.Dataset.__getitem__": [[65, 88], ["torch.tensor", "os.path.join", "torchaudio.load", "torch.utils.data.Dataset.Dataset.spk_ids.index", "numpy.random.choice", "torch.zeros", "torch.cat", "os.path.splitext"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "spk_id", ",", "audio_name", "=", "self", ".", "audio_paths", "[", "idx", "]", "\n", "if", "spk_id", "in", "self", ".", "spk_ids", ":", "\n", "            ", "spk_label", "=", "self", ".", "spk_ids", ".", "index", "(", "spk_id", ")", "\n", "", "else", ":", "\n", "            ", "spk_label", "=", "-", "1", "# # -1 means the spk is an imposter (not any enrolled speakers)", "\n", "", "spk_label", "=", "torch", ".", "tensor", "(", "spk_label", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "audio_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "spk_id", ",", "audio_name", ")", "\n", "audio", ",", "_", "=", "torchaudio", ".", "load", "(", "audio_path", ")", "\n", "if", "not", "self", ".", "normalize", ":", "\n", "            ", "audio", ".", "data", "*=", "(", "2", "**", "(", "self", ".", "bits", "-", "1", ")", ")", "\n", "", "n_channel", ",", "audio_len", "=", "audio", ".", "shape", "\n", "if", "self", ".", "wav_length", ":", "\n", "            ", "if", "self", ".", "wav_length", "<", "audio_len", ":", "\n", "                ", "start", "=", "np", ".", "random", ".", "choice", "(", "audio_len", "-", "self", ".", "wav_length", "+", "1", ")", "\n", "audio", "=", "audio", "[", "...", ",", "start", ":", "start", "+", "self", ".", "wav_length", "]", "\n", "", "elif", "self", ".", "wav_length", ">", "audio_len", ":", "\n", "                ", "pad_zero", "=", "torch", ".", "zeros", "(", "(", "n_channel", ",", "self", ".", "wav_length", "-", "audio_len", ")", ",", "dtype", "=", "audio", ".", "dtype", ")", "\n", "audio", "=", "torch", ".", "cat", "(", "(", "audio", ",", "pad_zero", ")", ",", "1", ")", "\n", "", "", "if", "not", "self", ".", "return_file_name", ":", "\n", "            ", "return", "audio", ",", "spk_label", "\n", "", "else", ":", "\n", "            ", "return", "audio", ",", "spk_label", ",", "os", ".", "path", ".", "splitext", "(", "audio_name", ")", "[", "0", "]", "# audio: (n_channel=1, len)", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Spk10_imposter.Spk10_imposter.__init__": [[6, 13], ["dataset.Dataset.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "\n", "        ", "normalize", "=", "False", "\n", "bits", "=", "16", "\n", "super", "(", ")", ".", "__init__", "(", "spk_ids", ",", "root", ",", "'Spk10_imposter'", ",", "\n", "normalize", "=", "normalize", ",", "bits", "=", "bits", ",", "\n", "return_file_name", "=", "return_file_name", ",", "wav_length", "=", "wav_length", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.dataset.Spk10_enroll.Spk10_enroll.__init__": [[6, 12], ["dataset.Dataset.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "spk_ids", ",", "root", ",", "return_file_name", "=", "False", ",", "wav_length", "=", "None", ")", ":", "\n", "        ", "normalize", "=", "False", "\n", "bits", "=", "16", "\n", "super", "(", ")", ".", "__init__", "(", "spk_ids", ",", "root", ",", "'Spk10_enroll'", ",", "\n", "normalize", "=", "normalize", ",", "bits", "=", "bits", ",", "\n", "return_file_name", "=", "return_file_name", ",", "wav_length", "=", "wav_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.__init__": [[17, 49], ["torch.Module.__init__", "torch.Module.__init__", "model._xv_plda.xvector_extract.xvectorExtractor", "model._xv_plda.plda.PLDA", "model.utils.parse_mean_file", "model.utils.parse_transform_mat_file", "sorted", "xv_plda.xv_plda.extractor.to", "xv_plda.xv_plda.plda.to", "model.utils.parse_enroll_model_file"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_mean_file", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_transform_mat_file", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_enroll_model_file"], ["    ", "def", "__init__", "(", "self", ",", "extractor_file", ",", "plda_file", ",", "mean_file", ",", "transform_mat_file", ",", "\n", "model_file", "=", "None", ",", "threshold", "=", "None", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "        ", "nn", ".", "Module", ".", "__init__", "(", "self", ")", "\n", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "extractor_file", "=", "extractor_file", "\n", "self", ".", "plda_file", "=", "plda_file", "\n", "\n", "self", ".", "extractor", "=", "xvectorExtractor", "(", "self", ".", "extractor_file", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "plda", "=", "PLDA", "(", "self", ".", "plda_file", ")", "\n", "\n", "if", "self", ".", "extractor", ".", "device", "!=", "self", ".", "device", ":", "\n", "            ", "self", ".", "extractor", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "self", ".", "plda", ".", "device", "!=", "self", ".", "device", ":", "\n", "            ", "self", ".", "plda", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "emb_mean", "=", "parse_mean_file", "(", "mean_file", ",", "self", ".", "device", ")", "\n", "self", ".", "transform_mat", "=", "parse_transform_mat_file", "(", "transform_mat_file", ",", "self", ".", "device", ")", "\n", "\n", "if", "model_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "num_spks", ",", "self", ".", "spk_ids", ",", "self", ".", "z_norm_means", ",", "self", ".", "z_norm_stds", ",", "self", ".", "enroll_embs", "=", "parse_enroll_model_file", "(", "model_file", ",", "self", ".", "device", ")", "\n", "\n", "# If you need SV or OSI, must input threshold", "\n", "", "self", ".", "threshold", "=", "threshold", "if", "threshold", "else", "-", "np", ".", "infty", "# Valid for SV and OSI tasks; CSI: -infty", "\n", "\n", "self", ".", "allowed_flags", "=", "sorted", "(", "[", "\n", "0", ",", "1", ",", "2", "\n", "]", ")", "# 0: wav; 1: raw feat; 2: cmvn feat", "\n", "self", ".", "range_type", "=", "'origin'", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.compute_feat": [[51, 68], ["model.utils.check_input_range", "xv_plda.xv_plda.raw", "xv_plda.xv_plda.comput_feat_from_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.check_input_range", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.raw", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat"], ["", "def", "compute_feat", "(", "self", ",", "x", ",", "flag", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        x: wav with shape [B, 1, T]\n        flag: the flag indicating to compute what type of features (1: raw feat; 2: cmvn feat)\n        return: feats with shape [B, T, F] (T: #Frames, F: #feature_dim)\n        \"\"\"", "\n", "assert", "flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "x", "=", "check_input_range", "(", "x", ",", "range_type", "=", "self", ".", "range_type", ")", "\n", "\n", "feats", "=", "self", ".", "raw", "(", "x", ")", "# (B, T, F)", "\n", "if", "flag", "==", "1", ":", "# calulate ori feat", "\n", "            ", "return", "feats", "\n", "", "elif", "flag", "==", "2", ":", "# calulate norm feat", "\n", "            ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "feats", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "2", ")", "\n", "return", "feats", "\n", "", "else", ":", "# will not go to this branch", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.comput_feat_from_feat": [[70, 85], ["xv_plda.xv_plda.cmvn"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.cmvn"], ["", "", "def", "comput_feat_from_feat", "(", "self", ",", "feats", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "2", ")", ":", "\n", "        ", "\"\"\"\n        transfer function between different levels of acoustic features\n        x: feature with shape [B, T, F]\n        ori_flag: the level of input feature x\n        des_flag: the level of the target feature\n        \"\"\"", "\n", "assert", "ori_flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "assert", "des_flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "assert", "des_flag", ">", "ori_flag", "\n", "\n", "if", "ori_flag", "==", "1", "and", "des_flag", "==", "2", ":", "\n", "            ", "return", "self", ".", "cmvn", "(", "feats", ")", "\n", "", "else", ":", "# will not go to this branch", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.embedding": [[87, 105], ["xv_plda.xv_plda.extract_emb", "xv_plda.xv_plda.compute_feat", "xv_plda.xv_plda.comput_feat_from_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.extract_emb", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat"], ["", "", "def", "embedding", "(", "self", ",", "x", ",", "flag", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat; 2: cmvn feat)\n        \"\"\"", "\n", "assert", "flag", "in", "self", ".", "allowed_flags", "\n", "if", "flag", "==", "0", ":", "\n", "# x = check_input_range(x, range_type=self.range_type) # no need since compute_feat will check", "\n", "            ", "feats", "=", "self", ".", "compute_feat", "(", "x", ",", "flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "1", ":", "\n", "            ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "x", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "2", ":", "\n", "            ", "feats", "=", "x", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "", "emb", "=", "self", ".", "extract_emb", "(", "feats", ")", "\n", "# return emb - self.emb_mean # [B, D]", "\n", "return", "emb", "# already subtract emb mean in self.extract_emb(feats)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.raw": [[107, 157], ["torchaudio.compliance.kaldi.mfcc", "raw_feat.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "raw", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        x: (B, 1, T)\n        \"\"\"", "\n", "batch_raw_feat", "=", "None", "\n", "for", "audio", "in", "x", ":", "\n", "# the parameter values of kaldi.mfcc are different from that of iv_plda", "\n", "            ", "raw_feat", "=", "torchaudio", ".", "compliance", ".", "kaldi", ".", "mfcc", "(", "audio", ",", "\n", "\n", "sample_frequency", "=", "16000", ",", "\n", "frame_shift", "=", "10", ",", "\n", "frame_length", "=", "25", ",", "\n", "dither", "=", "1.0", ",", "\n", "# dither=0.0, ", "\n", "preemphasis_coefficient", "=", "0.97", ",", "\n", "remove_dc_offset", "=", "True", ",", "\n", "window_type", "=", "\"povey\"", ",", "\n", "round_to_power_of_two", "=", "True", ",", "\n", "blackman_coeff", "=", "0.42", ",", "\n", "snip_edges", "=", "False", ",", "\n", "# allow_downsample=False,", "\n", "# allow_upsample=False,", "\n", "# max_feature_vectors=-1,", "\n", "\n", "num_mel_bins", "=", "30", ",", "\n", "low_freq", "=", "20", ",", "\n", "high_freq", "=", "7600", ",", "\n", "vtln_low", "=", "100", ",", "\n", "vtln_high", "=", "-", "500", ",", "\n", "vtln_warp", "=", "1.0", ",", "\n", "# debug_mel=False,", "\n", "# htk_mode=False,", "\n", "\n", "# num_ceps=24, # egs/voxceleb/v1", "\n", "num_ceps", "=", "30", ",", "# egs/voxceleb/v2", "\n", "use_energy", "=", "True", ",", "\n", "energy_floor", "=", "0.0", ",", "\n", "# energy_floor=1.0, ", "\n", "# energy_floor=0.1,   ", "\n", "raw_energy", "=", "True", ",", "\n", "cepstral_lifter", "=", "22.0", ",", "\n", "htk_compat", "=", "False", ")", "\n", "\n", "raw_feat", "=", "raw_feat", ".", "unsqueeze", "(", "0", ")", "# (T, F) --> (1, T, F)", "\n", "if", "batch_raw_feat", "is", "None", ":", "\n", "                ", "batch_raw_feat", "=", "raw_feat", "\n", "", "else", ":", "\n", "                ", "batch_raw_feat", "=", "torch", ".", "cat", "(", "(", "batch_raw_feat", ",", "raw_feat", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_raw_feat", "# (B, T, F)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.xv_plda.xv_plda.extract_emb": [[159, 175], ["xv_plda.xv_plda.extractor.Extract", "xv_plda.xv_plda.process_emb", "emb.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.Extract", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.process_emb"], ["", "def", "extract_emb", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        x: (B, T, F)\n        '''", "\n", "batch_emb", "=", "None", "\n", "for", "mfcc", "in", "x", ":", "\n", "            ", "emb", "=", "self", ".", "extractor", ".", "Extract", "(", "mfcc", ")", "\n", "emb", "=", "self", ".", "process_emb", "(", "emb", ",", "num_utt", "=", "1", ",", "simple_length_norm", "=", "False", ",", "normalize_length", "=", "True", ")", "\n", "\n", "emb", "=", "emb", ".", "unsqueeze", "(", "0", ")", "\n", "if", "batch_emb", "is", "None", ":", "\n", "                ", "batch_emb", "=", "emb", "\n", "", "else", ":", "\n", "                ", "batch_emb", "=", "torch", ".", "cat", "(", "(", "batch_emb", ",", "emb", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.__init__": [[19, 84], ["torch.Module.__init__", "model.utils.parse_mean_file", "model.utils.parse_transform_mat_file", "sorted", "os.path.dirname", "os.path.exists", "model._iv_plda.gmm.FullGMM", "os.path.dirname", "os.path.exists", "model._iv_plda.ivector_extract.ivectorExtractor", "os.path.dirname", "os.path.exists", "model._iv_plda.plda.PLDA", "iv_plda.iv_plda.fgmm.to", "iv_plda.iv_plda.extractor.to", "iv_plda.iv_plda.plda.to", "model.utils.parse_enroll_model_file", "open", "pickle.dump", "open", "pickle.load", "open", "pickle.dump", "open", "pickle.load", "open", "pickle.dump", "open", "pickle.load"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_mean_file", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_transform_mat_file", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_enroll_model_file"], ["    ", "def", "__init__", "(", "self", ",", "fgmm_file", ",", "extractor_file", ",", "plda_file", ",", "mean_file", ",", "transform_mat_file", ",", "\n", "model_file", "=", "None", ",", "threshold", "=", "None", ",", "device", "=", "\"cpu\"", ",", "gmm_frame_bs", "=", "200", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "fgmm_file", "=", "fgmm_file", "\n", "self", ".", "extractor_file", "=", "extractor_file", "\n", "self", ".", "plda_file", "=", "plda_file", "\n", "\n", "## using cache to save time since the from-scratch loading of the model is time consuming", "\n", "fgmm_cache_path", "=", "\"{}/fgmm.pickle\"", ".", "format", "(", "os", ".", "path", ".", "dirname", "(", "fgmm_file", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "fgmm_cache_path", ")", ":", "\n", "            ", "self", ".", "fgmm", "=", "FullGMM", "(", "self", ".", "fgmm_file", ")", "\n", "with", "open", "(", "fgmm_cache_path", ",", "\"wb\"", ")", "as", "writer", ":", "\n", "                ", "pickle", ".", "dump", "(", "self", ".", "fgmm", ",", "writer", ",", "-", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "with", "open", "(", "fgmm_cache_path", ",", "\"rb\"", ")", "as", "reader", ":", "\n", "                ", "self", ".", "fgmm", "=", "pickle", ".", "load", "(", "reader", ")", "\n", "\n", "", "", "extractor_cache_path", "=", "\"{}/extractor.pickle\"", ".", "format", "(", "os", ".", "path", ".", "dirname", "(", "extractor_file", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "extractor_cache_path", ")", ":", "\n", "            ", "self", ".", "extractor", "=", "ivectorExtractor", "(", "self", ".", "extractor_file", ")", "\n", "with", "open", "(", "extractor_cache_path", ",", "\"wb\"", ")", "as", "writer", ":", "\n", "                ", "pickle", ".", "dump", "(", "self", ".", "extractor", ",", "writer", ",", "-", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "with", "open", "(", "extractor_cache_path", ",", "\"rb\"", ")", "as", "reader", ":", "\n", "                ", "self", ".", "extractor", "=", "pickle", ".", "load", "(", "reader", ")", "\n", "\n", "", "", "plda_cache_path", "=", "\"{}/plda.pickle\"", ".", "format", "(", "os", ".", "path", ".", "dirname", "(", "plda_file", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "plda_cache_path", ")", ":", "\n", "            ", "self", ".", "plda", "=", "PLDA", "(", "self", ".", "plda_file", ")", "\n", "with", "open", "(", "plda_cache_path", ",", "\"wb\"", ")", "as", "writer", ":", "\n", "                ", "pickle", ".", "dump", "(", "self", ".", "plda", ",", "writer", ",", "-", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "with", "open", "(", "plda_cache_path", ",", "\"rb\"", ")", "as", "reader", ":", "\n", "                ", "self", ".", "plda", "=", "pickle", ".", "load", "(", "reader", ")", "\n", "\n", "", "", "if", "self", ".", "fgmm", ".", "device", "!=", "self", ".", "device", ":", "\n", "            ", "self", ".", "fgmm", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "self", ".", "extractor", ".", "device", "!=", "self", ".", "device", ":", "\n", "            ", "self", ".", "extractor", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "self", ".", "plda", ".", "device", "!=", "self", ".", "device", ":", "\n", "            ", "self", ".", "plda", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "emb_mean", "=", "parse_mean_file", "(", "mean_file", ",", "self", ".", "device", ")", "\n", "self", ".", "transform_mat", "=", "parse_transform_mat_file", "(", "transform_mat_file", ",", "self", ".", "device", ")", "\n", "\n", "if", "model_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "num_spks", ",", "self", ".", "spk_ids", ",", "self", ".", "z_norm_means", ",", "self", ".", "z_norm_stds", ",", "self", ".", "enroll_embs", "=", "parse_enroll_model_file", "(", "model_file", ",", "self", ".", "device", ")", "\n", "\n", "# If you need SV or OSI, must input threshold", "\n", "", "self", ".", "threshold", "=", "threshold", "if", "threshold", "else", "-", "np", ".", "infty", "# Valid for SV and OSI tasks; CSI: -infty", "\n", "\n", "self", ".", "allowed_flags", "=", "sorted", "(", "[", "\n", "0", ",", "1", ",", "2", ",", "3", "\n", "]", ")", "# 0: wav; 1: raw feat; 2: delta feat; 3: cmvn feat", "\n", "self", ".", "range_type", "=", "'origin'", "\n", "\n", "# how many frames to be processed in one batch when calculating the 0-th and 1-th stats in GMM; ", "\n", "# setting > 1 to speed up the computation", "\n", "# adjust it according to your GPU memory", "\n", "self", ".", "gmm_frame_bs", "=", "gmm_frame_bs", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.compute_feat": [[86, 110], ["model.utils.check_input_range", "iv_plda.iv_plda.raw", "iv_plda.iv_plda.comput_feat_from_feat", "iv_plda.iv_plda.comput_feat_from_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.check_input_range", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.raw", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat"], ["", "def", "compute_feat", "(", "self", ",", "x", ",", "flag", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        x: wav with shape [B, 1, T]\n        flag: the flag indicating to compute what type of features (1: raw feat; 2: delta feat; 3: cmvn feat)\n        return: feats with shape [B, T, F] (T: #Frames, F: #feature_dim)\n        \"\"\"", "\n", "assert", "flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "x", "=", "check_input_range", "(", "x", ",", "range_type", "=", "self", ".", "range_type", ")", "\n", "\n", "feats", "=", "self", ".", "raw", "(", "x", ")", "# (B, T, F)", "\n", "if", "flag", "==", "1", ":", "# calulate ori feat", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "feats", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "2", ")", "\n", "if", "flag", "==", "2", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "feats", ",", "ori_flag", "=", "2", ",", "des_flag", "=", "3", ")", "\n", "if", "flag", "==", "3", ":", "\n", "                    ", "pass", "\n", "", "else", ":", "# will not enter this branch", "\n", "                    ", "pass", "\n", "\n", "", "", "", "return", "feats", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat": [[112, 131], ["iv_plda.iv_plda.add_delta", "iv_plda.iv_plda.cmvn", "iv_plda.iv_plda.cmvn", "iv_plda.iv_plda.add_delta"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.add_delta", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.cmvn", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.cmvn", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.add_delta"], ["", "def", "comput_feat_from_feat", "(", "self", ",", "feats", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "2", ")", ":", "\n", "        ", "\"\"\"\n        transfer function between different levels of acoustic features\n        x: feature with shape [B, T, F]\n        ori_flag: the level of input feature x\n        des_flag: the level of the target feature\n        \"\"\"", "\n", "assert", "ori_flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "assert", "des_flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "assert", "des_flag", ">", "ori_flag", "\n", "\n", "if", "ori_flag", "==", "1", ":", "\n", "            ", "if", "des_flag", "==", "2", ":", "\n", "                ", "return", "self", ".", "add_delta", "(", "feats", ")", "\n", "", "if", "des_flag", "==", "3", ":", "\n", "                ", "return", "self", ".", "cmvn", "(", "self", ".", "add_delta", "(", "feats", ")", ")", "\n", "", "", "if", "ori_flag", "==", "2", ":", "\n", "            ", "if", "des_flag", "==", "3", ":", "\n", "                ", "return", "self", ".", "cmvn", "(", "feats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.embedding": [[133, 153], ["iv_plda.iv_plda.extract_emb", "iv_plda.iv_plda.compute_feat", "iv_plda.iv_plda.comput_feat_from_feat", "iv_plda.iv_plda.comput_feat_from_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.extract_emb", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat"], ["", "", "", "def", "embedding", "(", "self", ",", "x", ",", "flag", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat; 2: delta feat; 3: cmvn feat)\n        \"\"\"", "\n", "assert", "flag", "in", "self", ".", "allowed_flags", "\n", "if", "flag", "==", "0", ":", "\n", "# x = check_input_range(x, range_type=self.range_type) # no need since compute_feat will check", "\n", "            ", "feats", "=", "self", ".", "compute_feat", "(", "x", ",", "flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "1", ":", "\n", "            ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "x", ",", "ori_flag", "=", "1", ",", "des_flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "2", ":", "\n", "            ", "feats", "=", "self", ".", "comput_feat_from_feat", "(", "x", ",", "ori_flag", "=", "2", ",", "des_flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "3", ":", "\n", "            ", "feats", "=", "x", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "", "emb", "=", "self", ".", "extract_emb", "(", "feats", ")", "\n", "# return emb - self.emb_mean # [B, D]", "\n", "return", "emb", "# already subtract emb mean in self.extract_emb(feats)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.forward": [[155, 170], ["iv_plda.iv_plda.embedding", "iv_plda.iv_plda.scoring_trials", "hasattr"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.scoring_trials"], ["", "def", "forward", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "return_emb", "=", "False", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat; 2: delta feat; 3: cmvn feat)\n        \"\"\"", "\n", "embedding", "=", "self", ".", "embedding", "(", "x", ",", "flag", "=", "flag", ")", "\n", "\n", "if", "not", "hasattr", "(", "self", ",", "'enroll_embs'", ")", ":", "\n", "            ", "assert", "enroll_embs", "is", "not", "None", "\n", "", "enroll_embs", "=", "enroll_embs", "if", "enroll_embs", "is", "not", "None", "else", "self", ".", "enroll_embs", "\n", "scores", "=", "self", ".", "scoring_trials", "(", "enroll_embs", "=", "enroll_embs", ",", "embs", "=", "embedding", ")", "\n", "if", "not", "return_emb", ":", "\n", "            ", "return", "scores", "\n", "", "else", ":", "\n", "            ", "return", "scores", ",", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.score": [[172, 180], ["iv_plda.iv_plda.forward"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.forward"], ["", "", "def", "score", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat; 2: delta feat; 3: cmvn feat)\n        \"\"\"", "\n", "logits", "=", "self", ".", "forward", "(", "x", ",", "flag", "=", "flag", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "scores", "=", "logits", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.make_decision": [[182, 195], ["iv_plda.iv_plda.score", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.where", "torch.where", "torch.where", "torch.where", "torch.max", "torch.max", "torch.max", "torch.max", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["", "def", "make_decision", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat; 2: delta feat; 3: cmvn feat)\n        \"\"\"", "\n", "scores", "=", "self", ".", "score", "(", "x", ",", "flag", "=", "flag", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "\n", "decisions", "=", "torch", ".", "argmax", "(", "scores", ",", "dim", "=", "1", ")", "\n", "max_scores", "=", "torch", ".", "max", "(", "scores", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "decisions", "=", "torch", ".", "where", "(", "max_scores", ">", "self", ".", "threshold", ",", "decisions", ",", "\n", "torch", ".", "tensor", "(", "[", "-", "1", "]", "*", "decisions", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "decisions", ".", "device", ")", ")", "# -1 means reject", "\n", "\n", "return", "decisions", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.raw": [[197, 246], ["torchaudio.compliance.kaldi.mfcc", "raw_feat.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "raw", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        x: (B, 1, T)\n        \"\"\"", "\n", "batch_raw_feat", "=", "None", "\n", "for", "audio", "in", "x", ":", "\n", "            ", "raw_feat", "=", "torchaudio", ".", "compliance", ".", "kaldi", ".", "mfcc", "(", "\n", "audio", ",", "\n", "\n", "sample_frequency", "=", "16000", ",", "\n", "frame_shift", "=", "10", ",", "\n", "frame_length", "=", "25", ",", "\n", "dither", "=", "1.0", ",", "\n", "# dither=0.0, ", "\n", "preemphasis_coefficient", "=", "0.97", ",", "\n", "remove_dc_offset", "=", "True", ",", "\n", "window_type", "=", "\"povey\"", ",", "\n", "round_to_power_of_two", "=", "True", ",", "\n", "blackman_coeff", "=", "0.42", ",", "\n", "snip_edges", "=", "False", ",", "\n", "# allow_downsample=False,", "\n", "# allow_upsample=False,", "\n", "# max_feature_vectors=-1,", "\n", "\n", "num_mel_bins", "=", "30", ",", "\n", "low_freq", "=", "20", ",", "\n", "high_freq", "=", "7600", ",", "\n", "vtln_low", "=", "100", ",", "\n", "vtln_high", "=", "-", "500", ",", "\n", "vtln_warp", "=", "1.0", ",", "\n", "# debug_mel=False,", "\n", "# htk_mode=False,", "\n", "\n", "num_ceps", "=", "24", ",", "\n", "use_energy", "=", "True", ",", "\n", "energy_floor", "=", "0.0", ",", "\n", "# energy_floor=1.0, ", "\n", "# energy_floor=0.1,   ", "\n", "raw_energy", "=", "True", ",", "\n", "cepstral_lifter", "=", "22.0", ",", "\n", "htk_compat", "=", "False", ")", "\n", "\n", "raw_feat", "=", "raw_feat", ".", "unsqueeze", "(", "0", ")", "# (T, F) --> (1, T, F)", "\n", "if", "batch_raw_feat", "is", "None", ":", "\n", "                ", "batch_raw_feat", "=", "raw_feat", "\n", "", "else", ":", "\n", "                ", "batch_raw_feat", "=", "torch", ".", "cat", "(", "(", "batch_raw_feat", ",", "raw_feat", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_raw_feat", "# (B, T, F)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.add_delta": [[248, 275], ["iv_plda.iv_plda.get_scales", "raw_feat.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "delta_feat.unsqueeze.unsqueeze.unsqueeze", "scales_[].to", "int", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "part_feat.add_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.arange.repeat", "torch.arange.repeat", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "raw_feat[].view", "scales_[].to.view().expand", "scales_[].to.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "scales_[].to.view", "torch.clamp.view", "torch.clamp.view"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.get_scales", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "add_delta", "(", "self", ",", "batch_raw_feat", ",", "window", "=", "3", ",", "order", "=", "2", ",", "mode", "=", "\"replicate\"", ")", ":", "\n", "        ", "'''\n        batch_raw_feat: (B, T, F)\n        '''", "\n", "batch_delta_feat", "=", "None", "\n", "for", "raw_feat", "in", "batch_raw_feat", ":", "\n", "# get scales", "\n", "            ", "scales_", "=", "self", ".", "get_scales", "(", "window", ",", "order", ",", "mode", ")", "\n", "\n", "num_frames", ",", "feat_dim", "=", "raw_feat", ".", "size", "(", ")", "\n", "delta_feat", "=", "torch", ".", "zeros", "(", "(", "num_frames", ",", "feat_dim", "*", "(", "order", "+", "1", ")", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "order", "+", "1", ")", ":", "\n", "                ", "scales", "=", "scales_", "[", "i", "]", ".", "to", "(", "raw_feat", ".", "device", ")", "\n", "max_offset", "=", "int", "(", "(", "scales", ".", "size", "(", ")", "[", "0", "]", "-", "1", ")", "/", "2", ")", "\n", "j", "=", "torch", ".", "arange", "(", "-", "1", "*", "max_offset", ",", "max_offset", "+", "1", ",", "device", "=", "raw_feat", ".", "device", ")", "\n", "offset_frame", "=", "torch", ".", "clamp", "(", "j", ".", "repeat", "(", "num_frames", ",", "1", ")", "+", "torch", ".", "arange", "(", "num_frames", ",", "device", "=", "raw_feat", ".", "device", ")", ".", "view", "(", "-", "1", ",", "1", ")", ",", "min", "=", "0", ",", "max", "=", "num_frames", "-", "1", ")", "\n", "part_feat", "=", "delta_feat", "[", ":", ",", "i", "*", "feat_dim", ":", "(", "i", "+", "1", ")", "*", "feat_dim", "]", "\n", "part_feat", ".", "add_", "(", "torch", ".", "sum", "(", "raw_feat", "[", "offset_frame", ".", "view", "(", "-", "1", ",", ")", ",", ":", "]", ".", "view", "(", "num_frames", ",", "-", "1", ",", "feat_dim", ")", "*", "scales", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "num_frames", ",", "scales", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dim", "=", "1", ")", ")", "\n", "\n", "", "delta_feat", "=", "delta_feat", ".", "unsqueeze", "(", "0", ")", "\n", "if", "batch_delta_feat", "is", "None", ":", "\n", "                ", "batch_delta_feat", "=", "delta_feat", "\n", "", "else", ":", "\n", "                ", "batch_delta_feat", "=", "torch", ".", "cat", "(", "(", "batch_delta_feat", ",", "delta_feat", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_delta_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.get_scales": [[277, 294], ["range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "int", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "scales.append", "int", "int", "range", "int", "int", "prev_scales.size", "prev_scales.size"], "methods", ["None"], ["", "def", "get_scales", "(", "self", ",", "window", ",", "order", ",", "mode", ")", ":", "\n", "        ", "scales", "=", "[", "torch", ".", "tensor", "(", "[", "1.0", "]", ",", "dtype", "=", "torch", ".", "float", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "order", "+", "1", ")", ":", "\n", "            ", "prev_scales", "=", "scales", "[", "i", "-", "1", "]", "\n", "assert", "window", "!=", "0", "\n", "prev_offset", "=", "int", "(", "(", "prev_scales", ".", "size", "(", ")", "[", "0", "]", "-", "1", ")", "/", "2", ")", "\n", "cur_offset", "=", "int", "(", "prev_offset", "+", "window", ")", "\n", "cur_scales", "=", "torch", ".", "zeros", "(", "(", "prev_scales", ".", "size", "(", ")", "[", "0", "]", "+", "2", "*", "window", ",", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "normalizer", "=", "0.0", "\n", "for", "j", "in", "range", "(", "int", "(", "-", "1", "*", "window", ")", ",", "int", "(", "window", "+", "1", ")", ")", ":", "\n", "                ", "normalizer", "+=", "j", "*", "j", "\n", "for", "k", "in", "range", "(", "int", "(", "-", "1", "*", "prev_offset", ")", ",", "int", "(", "prev_offset", "+", "1", ")", ")", ":", "\n", "                    ", "cur_scales", "[", "j", "+", "k", "+", "cur_offset", "]", "+=", "j", "*", "prev_scales", "[", "k", "+", "prev_offset", "]", "\n", "", "", "cur_scales", "=", "cur_scales", "*", "(", "1.", "/", "normalizer", ")", "\n", "scales", ".", "append", "(", "cur_scales", ")", "\n", "\n", "", "return", "scales", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.cmvn": [[296, 378], ["delta_feat.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "delta_feat.clone", "range", "cmvn_feat.unsqueeze.unsqueeze.unsqueeze", "cmvn_feat[].add_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros.fill_", "torch.zeros.fill_", "torch.zeros.add_", "torch.zeros.add_", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros.add_", "torch.zeros.add_", "torch.zeros.add_", "torch.zeros.add_", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "cmvn", "(", "self", ",", "batch_delta_feat", ")", ":", "\n", "        ", "'''\n        batch_delta_feat: (B, T, F)\n        '''", "\n", "batch_cmvn_feat", "=", "None", "\n", "\n", "for", "delta_feat", "in", "batch_delta_feat", ":", "\n", "\n", "            ", "opts", "=", "{", "}", "\n", "CENTER", "=", "\"center\"", "\n", "NORMALIZE_VARIANCE", "=", "\"normalize_variance\"", "\n", "CMN_WINDOW", "=", "\"cmn_window\"", "\n", "opts", "[", "CENTER", "]", "=", "True", "\n", "opts", "[", "NORMALIZE_VARIANCE", "]", "=", "False", "\n", "opts", "[", "CMN_WINDOW", "]", "=", "300", "\n", "\n", "num_frames", ",", "dim", "=", "delta_feat", ".", "size", "(", ")", "\n", "last_window_start", "=", "-", "1", "\n", "last_window_end", "=", "-", "1", "\n", "cur_sum", "=", "torch", ".", "zeros", "(", "(", "dim", ",", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "cur_sumsq", "=", "torch", ".", "zeros", "(", "(", "dim", ",", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "cmvn_feat", "=", "delta_feat", ".", "clone", "(", ")", "\n", "for", "t", "in", "range", "(", "num_frames", ")", ":", "\n", "\n", "                ", "window_start", "=", "0", "\n", "window_end", "=", "0", "\n", "if", "opts", "[", "CENTER", "]", ":", "\n", "                    ", "window_start", "=", "t", "-", "(", "opts", "[", "CMN_WINDOW", "]", "/", "2", ")", "\n", "window_end", "=", "window_start", "+", "opts", "[", "CMN_WINDOW", "]", "\n", "", "else", ":", "\n", "                    ", "pass", "\n", "", "if", "window_start", "<", "0", ":", "\n", "                    ", "window_end", "-=", "window_start", "\n", "window_start", "=", "0", "\n", "", "if", "not", "opts", "[", "CENTER", "]", ":", "\n", "                    ", "pass", "\n", "", "if", "window_end", ">", "num_frames", ":", "\n", "                    ", "window_start", "-=", "(", "window_end", "-", "num_frames", ")", "\n", "window_end", "=", "num_frames", "\n", "if", "window_start", "<", "0", ":", "\n", "                        ", "window_start", "=", "0", "\n", "", "", "if", "last_window_start", "==", "-", "1", ":", "\n", "                    ", "delta_feat_part", "=", "delta_feat", "[", "int", "(", "window_start", ")", ":", "int", "(", "window_end", ")", ",", ":", "]", "\n", "cur_sum", ".", "fill_", "(", "0.", ")", "\n", "cur_sum", ".", "add_", "(", "torch", ".", "sum", "(", "delta_feat_part", ",", "0", ",", "keepdim", "=", "False", ")", ",", "alpha", "=", "1.", ")", "\n", "if", "opts", "[", "NORMALIZE_VARIANCE", "]", ":", "\n", "                        ", "pass", "\n", "", "", "else", ":", "\n", "                    ", "if", "window_start", ">", "last_window_start", ":", "\n", "                        ", "assert", "window_start", "==", "last_window_start", "+", "1", "\n", "frame_to_remove", "=", "delta_feat", "[", "int", "(", "last_window_start", ")", ",", ":", "]", "\n", "cur_sum", ".", "add_", "(", "frame_to_remove", ",", "alpha", "=", "-", "1.", ")", "\n", "\n", "if", "opts", "[", "NORMALIZE_VARIANCE", "]", ":", "\n", "                            ", "pass", "\n", "\n", "", "", "if", "window_end", ">", "last_window_end", ":", "\n", "                        ", "assert", "window_end", "==", "last_window_end", "+", "1", "\n", "frame_to_add", "=", "delta_feat", "[", "int", "(", "last_window_end", ")", ",", ":", "]", "\n", "cur_sum", ".", "add_", "(", "frame_to_add", ",", "alpha", "=", "1.", ")", "\n", "\n", "if", "opts", "[", "NORMALIZE_VARIANCE", "]", ":", "\n", "                            ", "pass", "\n", "\n", "", "", "", "window_frames", "=", "window_end", "-", "window_start", "\n", "last_window_start", "=", "window_start", "\n", "last_window_end", "=", "window_end", "\n", "\n", "assert", "window_frames", ">", "0", "\n", "cmvn_feat", "[", "t", "]", ".", "add_", "(", "cur_sum", ",", "alpha", "=", "-", "1.", "/", "window_frames", ")", "\n", "\n", "if", "opts", "[", "NORMALIZE_VARIANCE", "]", ":", "\n", "                    ", "pass", "\n", "\n", "", "", "cmvn_feat", "=", "cmvn_feat", ".", "unsqueeze", "(", "0", ")", "\n", "if", "batch_cmvn_feat", "is", "None", ":", "\n", "                ", "batch_cmvn_feat", "=", "cmvn_feat", "\n", "", "else", ":", "\n", "                ", "batch_cmvn_feat", "=", "torch", ".", "cat", "(", "(", "batch_cmvn_feat", ",", "cmvn_feat", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_cmvn_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.extract_emb": [[380, 397], ["iv_plda.iv_plda.fgmm.Zeroth_First_Stats", "iv_plda.iv_plda.extractor.Extract", "iv_plda.iv_plda.process_emb", "emb.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Zeroth_First_Stats", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.Extract", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.process_emb"], ["", "def", "extract_emb", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        x: (B, T, F)\n        '''", "\n", "batch_emb", "=", "None", "\n", "for", "mfcc", "in", "x", ":", "\n", "            ", "zeroth_stats", ",", "first_stats", "=", "self", ".", "fgmm", ".", "Zeroth_First_Stats", "(", "mfcc", ",", "self", ".", "gmm_frame_bs", ")", "\n", "emb", ",", "_", ",", "_", "=", "self", ".", "extractor", ".", "Extract", "(", "zeroth_stats", ",", "first_stats", ")", "\n", "emb", "=", "self", ".", "process_emb", "(", "emb", ",", "num_utt", "=", "1", ",", "simple_length_norm", "=", "False", ",", "normalize_length", "=", "True", ")", "\n", "\n", "emb", "=", "emb", ".", "unsqueeze", "(", "0", ")", "\n", "if", "batch_emb", "is", "None", ":", "\n", "                ", "batch_emb", "=", "emb", "\n", "", "else", ":", "\n", "                ", "batch_emb", "=", "torch", ".", "cat", "(", "(", "batch_emb", ",", "emb", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "batch_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.scoring_trials": [[399, 409], ["iv_plda.iv_plda.plda.ComputeScores", "score.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.ComputeScores"], ["", "def", "scoring_trials", "(", "self", ",", "enroll_embs", ",", "embs", ")", ":", "\n", "        ", "scores", "=", "None", "\n", "for", "emb", "in", "embs", ":", "\n", "            ", "score", "=", "self", ".", "plda", ".", "ComputeScores", "(", "enroll_embs", ",", "1", ",", "emb", ")", "\n", "score", "=", "score", ".", "unsqueeze", "(", "0", ")", "\n", "if", "scores", "is", "None", ":", "\n", "                ", "scores", "=", "score", "\n", "", "else", ":", "\n", "                ", "scores", "=", "torch", ".", "cat", "(", "(", "scores", ",", "score", ")", ",", "dim", "=", "0", ")", "\n", "", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.process_emb": [[411, 417], ["iv_plda.iv_plda.SubtractGlobalMean", "iv_plda.iv_plda.lda_reduce_dim", "iv_plda.iv_plda.LengthNormalization", "iv_plda.iv_plda.TransformEmb"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.SubtractGlobalMean", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.lda_reduce_dim", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.LengthNormalization", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.TransformEmb"], ["", "def", "process_emb", "(", "self", ",", "emb", ",", "num_utt", "=", "1", ",", "simple_length_norm", "=", "False", ",", "normalize_length", "=", "True", ")", ":", "\n", "        ", "emb", "=", "self", ".", "SubtractGlobalMean", "(", "emb", ")", "\n", "emb", "=", "self", ".", "lda_reduce_dim", "(", "emb", ")", "\n", "emb", "=", "self", ".", "LengthNormalization", "(", "emb", ")", "\n", "emb", "=", "self", ".", "TransformEmb", "(", "emb", ",", "num_utt", ",", "simple_length_norm", ",", "normalize_length", ")", "\n", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.SubtractGlobalMean": [[419, 421], ["iv_plda.iv_plda.extractor.SubtractGlobalMean"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.SubtractGlobalMean"], ["", "def", "SubtractGlobalMean", "(", "self", ",", "emb", ")", ":", "\n", "        ", "return", "self", ".", "extractor", ".", "SubtractGlobalMean", "(", "emb", ",", "self", ".", "emb_mean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.lda_reduce_dim": [[423, 436], ["iv_plda.iv_plda.transform_mat.size", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "emb.size", "reduced_dim_vec.clone.clone.clone", "reduced_dim_vec.clone.clone.add_", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze"], "methods", ["None"], ["", "def", "lda_reduce_dim", "(", "self", ",", "emb", ")", ":", "\n", "        ", "_", ",", "transform_cols", "=", "self", ".", "transform_mat", ".", "size", "(", ")", "\n", "vec_dim", "=", "emb", ".", "size", "(", ")", "[", "0", "]", "\n", "reduced_dim_vec", "=", "None", "\n", "if", "transform_cols", "==", "vec_dim", ":", "\n", "            ", "pass", "# not our case, just skip", "\n", "", "else", ":", "\n", "            ", "assert", "transform_cols", "==", "vec_dim", "+", "1", "\n", "reduced_dim_vec", "=", "self", ".", "transform_mat", "[", ":", ",", "vec_dim", ":", "vec_dim", "+", "1", "]", "\n", "reduced_dim_vec", "=", "reduced_dim_vec", ".", "clone", "(", ")", "# avoid influcing self.transform_mat  ", "\n", "reduced_dim_vec", ".", "add_", "(", "1.", "*", "torch", ".", "matmul", "(", "self", ".", "transform_mat", "[", ":", ",", ":", "-", "1", "]", ",", "torch", ".", "unsqueeze", "(", "emb", ",", "1", ")", ")", ")", "\n", "\n", "", "return", "torch", ".", "squeeze", "(", "reduced_dim_vec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.LengthNormalization": [[438, 440], ["iv_plda.iv_plda.extractor.LengthNormalization", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "emb.size"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.LengthNormalization"], ["", "def", "LengthNormalization", "(", "self", ",", "emb", ")", ":", "\n", "        ", "return", "self", ".", "extractor", ".", "LengthNormalization", "(", "emb", ",", "torch", ".", "sqrt", "(", "torch", ".", "tensor", "(", "emb", ".", "size", "(", ")", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "self", ".", "device", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.TransformEmb": [[442, 444], ["iv_plda.iv_plda.plda.Transform"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.Transform"], ["", "def", "TransformEmb", "(", "self", ",", "emb", ",", "num_utt", "=", "1", ",", "simple_length_norm", "=", "False", ",", "normalize_length", "=", "True", ")", ":", "\n", "        ", "return", "self", ".", "plda", ".", "Transform", "(", "emb", ",", "num_utt", ",", "simple_length_norm", ",", "normalize_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.__init__": [[13, 44], ["torch.Module.__init__", "dict", "isinstance", "isinstance", "flag2defense[].append", "len", "warnings.warn", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "base_model", ",", "defense", "=", "None", ",", "order", "=", "sequential", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "base_model", "=", "base_model", "\n", "self", ".", "threshold", "=", "base_model", ".", "threshold", "\n", "\n", "## check the defense", "\n", "if", "defense", "is", "not", "None", ":", "\n", "            ", "flag2defense", "=", "dict", "(", ")", "\n", "for", "flag", "in", "self", ".", "base_model", ".", "allowed_flags", ":", "\n", "                ", "flag2defense", "[", "flag", "]", "=", "[", "]", "\n", "", "assert", "isinstance", "(", "defense", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "order", "in", "[", "sequential", ",", "average", "]", "\n", "prev_flag", "=", "-", "1", "\n", "for", "flag_method", "in", "defense", ":", "\n", "                ", "assert", "isinstance", "(", "flag_method", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "flag_method", ")", "==", "2", "\n", "flag", "=", "flag_method", "[", "0", "]", "\n", "if", "flag", "not", "in", "self", ".", "base_model", ".", "allowed_flags", ":", "\n", "                    ", "warnings", ".", "warn", "(", "'Unsupported Input Level Flag. Ignore the Defense!'", ")", "\n", "continue", "\n", "", "method", "=", "flag_method", "[", "1", "]", "\n", "flag2defense", "[", "flag", "]", ".", "append", "(", "method", ")", "\n", "if", "order", "==", "sequential", ":", "\n", "                    ", "if", "flag", "<", "prev_flag", ":", "\n", "                        ", "warnings", ".", "warn", "(", "'You want to combine multiple defenses in sequential order, but it seems that the order of your defense is wrong. I have reranged for you!'", ")", "\n", "", "prev_flag", "=", "flag", "\n", "", "", "self", ".", "order", "=", "order", "\n", "self", ".", "flag2defense", "=", "flag2defense", "\n", "", "self", ".", "defense", "=", "defense", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.process_sequential": [[46, 66], ["sorted", "list", "defended_model.defended_model.flag2defense.keys", "x.clone", "defense", "defended_model.defended_model.base_model.compute_feat", "defended_model.defended_model.base_model.comput_feat_from_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.iv_plda.iv_plda.comput_feat_from_feat"], ["", "def", "process_sequential", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        x: wav with shape [B, 1, T]\n        return: the final type of input to the base model, e.g., cmvn_feat for iv_plda/xv_plda and raw_feat for audionet_csine\n        '''", "\n", "if", "self", ".", "defense", "is", "not", "None", ":", "\n", "            ", "for", "flag", "in", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", ":", "# sorted is important here", "\n", "                ", "if", "flag", "==", "0", ":", "\n", "                    ", "xx", "=", "x", ".", "clone", "(", ")", "\n", "", "elif", "flag", "==", "1", ":", "\n", "                    ", "xx", "=", "self", ".", "base_model", ".", "compute_feat", "(", "xx", ",", "flag", "=", "1", ")", "\n", "", "else", ":", "\n", "                    ", "xx", "=", "self", ".", "base_model", ".", "comput_feat_from_feat", "(", "xx", ",", "ori_flag", "=", "flag", "-", "1", ",", "des_flag", "=", "flag", ")", "\n", "", "for", "defense", "in", "self", ".", "flag2defense", "[", "flag", "]", ":", "\n", "# print(xx)", "\n", "                    ", "xx", "=", "defense", "(", "xx", ")", "\n", "# print(xx)", "\n", "", "", "return", "xx", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.embedding": [[68, 95], ["defended_model.defended_model.base_model.embedding", "defended_model.defended_model.process_sequential", "defended_model.defended_model.base_model.embedding", "sorted", "len", "list", "defended_model.defended_model.flag2defense.keys", "x.clone", "defended_model.defended_model.base_model.compute_feat", "defense", "defended_model.defended_model.base_model.embedding", "sorted", "list", "defended_model.defended_model.flag2defense.keys"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.process_sequential", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding"], ["", "", "def", "embedding", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        x: wav with shape [B, 1, T]\n        return the same thing as the base model\n        '''", "\n", "if", "self", ".", "defense", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "order", "==", "sequential", ":", "\n", "                ", "xx", "=", "self", ".", "process_sequential", "(", "x", ")", "\n", "return", "self", ".", "base_model", ".", "embedding", "(", "xx", ",", "flag", "=", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", "[", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "avg_emb", "=", "None", "\n", "for", "flag", "in", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", ":", "# sorted is important here", "\n", "                    ", "if", "flag", "==", "0", ":", "\n", "                        ", "xx", "=", "x", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "xx", "=", "self", ".", "base_model", ".", "compute_feat", "(", "x", ",", "flag", "=", "flag", ")", "\n", "", "for", "defense", "in", "self", ".", "flag2defense", "[", "flag", "]", ":", "\n", "                        ", "xxx", "=", "defense", "(", "xx", ")", "\n", "emb", "=", "self", ".", "base_model", ".", "embedding", "(", "xxx", ",", "flag", "=", "flag", ")", "\n", "if", "avg_emb", "is", "None", ":", "\n", "                            ", "avg_emb", "=", "emb", "\n", "", "else", ":", "\n", "                            ", "avg_emb", ".", "data", "+=", "emb", "\n", "", "", "", "avg_emb", ".", "data", "/=", "len", "(", "self", ".", "defense", ")", "\n", "return", "avg_emb", "\n", "", "", "else", ":", "\n", "            ", "return", "self", ".", "base_model", ".", "embedding", "(", "x", ",", "flag", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.forward": [[98, 129], ["defended_model.defended_model.base_model", "defended_model.defended_model.process_sequential", "defended_model.defended_model.base_model", "sorted", "len", "len", "list", "defended_model.defended_model.flag2defense.keys", "x.clone", "defended_model.defended_model.base_model.compute_feat", "defense", "defended_model.defended_model.base_model", "sorted", "list", "defended_model.defended_model.flag2defense.keys"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.process_sequential", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "return_emb", "=", "False", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "'''\n        x: wav with shape [B, 1, T]\n        return the same thing as the base model\n        '''", "\n", "if", "self", ".", "defense", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "order", "==", "sequential", ":", "\n", "                ", "xx", "=", "self", ".", "process_sequential", "(", "x", ")", "\n", "return", "self", ".", "base_model", "(", "xx", ",", "flag", "=", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", "[", "-", "1", "]", ",", "return_emb", "=", "return_emb", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "", "else", ":", "\n", "                ", "avg_logits", "=", "None", "\n", "avg_emb", "=", "None", "\n", "for", "flag", "in", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", ":", "# sorted is important here", "\n", "                    ", "if", "flag", "==", "0", ":", "\n", "                        ", "xx", "=", "x", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "xx", "=", "self", ".", "base_model", ".", "compute_feat", "(", "x", ",", "flag", "=", "flag", ")", "\n", "", "for", "defense", "in", "self", ".", "flag2defense", "[", "flag", "]", ":", "\n", "                        ", "xxx", "=", "defense", "(", "xx", ")", "\n", "logits", ",", "emb", "=", "self", ".", "base_model", "(", "xxx", ",", "flag", "=", "flag", ",", "return_emb", "=", "True", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "if", "avg_emb", "is", "None", ":", "\n", "                            ", "avg_emb", "=", "emb", "\n", "avg_logits", "=", "logits", "\n", "", "else", ":", "\n", "                            ", "avg_emb", ".", "data", "+=", "emb", "\n", "avg_logits", ".", "data", "+=", "logits", "\n", "", "", "", "avg_logits", ".", "data", "/=", "len", "(", "self", ".", "defense", ")", "\n", "avg_emb", ".", "data", "/=", "len", "(", "self", ".", "defense", ")", "\n", "return", "avg_logits", "if", "not", "return_emb", "else", "(", "avg_logits", ",", "avg_emb", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "self", ".", "base_model", "(", "x", ",", "flag", "=", "0", ",", "return_emb", "=", "return_emb", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.score": [[131, 158], ["defended_model.defended_model.base_model.score", "defended_model.defended_model.process_sequential", "defended_model.defended_model.base_model.score", "sorted", "len", "list", "defended_model.defended_model.flag2defense.keys", "x.clone", "defended_model.defended_model.base_model.compute_feat", "defense", "defended_model.defended_model.base_model.score", "sorted", "list", "defended_model.defended_model.flag2defense.keys"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.process_sequential", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["", "", "def", "score", "(", "self", ",", "x", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "'''\n        x: wav with shape [B, 1, T]\n        return the same thing as the base model\n        '''", "\n", "if", "self", ".", "defense", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "order", "==", "sequential", ":", "\n", "                ", "xx", "=", "self", ".", "process_sequential", "(", "x", ")", "\n", "return", "self", ".", "base_model", ".", "score", "(", "xx", ",", "flag", "=", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", "[", "-", "1", "]", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "", "else", ":", "\n", "                ", "avg_scores", "=", "None", "\n", "for", "flag", "in", "sorted", "(", "list", "(", "self", ".", "flag2defense", ".", "keys", "(", ")", ")", ")", ":", "# sorted is important here", "\n", "                    ", "if", "flag", "==", "0", ":", "\n", "                        ", "xx", "=", "x", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "xx", "=", "self", ".", "base_model", ".", "compute_feat", "(", "x", ",", "flag", "=", "flag", ")", "\n", "", "for", "defense", "in", "self", ".", "flag2defense", "[", "flag", "]", ":", "\n", "                        ", "xxx", "=", "defense", "(", "xx", ")", "\n", "scores", "=", "self", ".", "base_model", ".", "score", "(", "xxx", ",", "flag", "=", "flag", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "if", "avg_scores", "is", "None", ":", "\n", "                            ", "avg_scores", "=", "scores", "\n", "", "else", ":", "\n", "                            ", "avg_scores", ".", "data", "+=", "scores", "\n", "", "", "", "avg_scores", ".", "data", "/=", "len", "(", "self", ".", "defense", ")", "\n", "return", "avg_scores", "\n", "", "", "else", ":", "\n", "            ", "return", "self", ".", "base_model", ".", "score", "(", "x", ",", "flag", "=", "0", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.defended_model.defended_model.make_decision": [[160, 173], ["defended_model.defended_model.score", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.where", "torch.where", "torch.where", "torch.where", "torch.max", "torch.max", "torch.max", "torch.max", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["", "", "def", "make_decision", "(", "self", ",", "x", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "'''\n        x: wav with shape [B, 1, T]\n        return the same thing as the base model\n        '''", "\n", "scores", "=", "self", ".", "score", "(", "x", ",", "enroll_embs", "=", "enroll_embs", ")", "\n", "\n", "decisions", "=", "torch", ".", "argmax", "(", "scores", ",", "dim", "=", "1", ")", "\n", "max_scores", "=", "torch", ".", "max", "(", "scores", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "decisions", "=", "torch", ".", "where", "(", "max_scores", ">", "self", ".", "base_model", ".", "threshold", ",", "decisions", ",", "\n", "torch", ".", "tensor", "(", "[", "-", "1", "]", "*", "decisions", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "decisions", ".", "device", ")", ")", "\n", "\n", "return", "decisions", ",", "scores", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.__init__": [[22, 131], ["torch.Module.__init__", "model._audionet.Preprocessor.Preprocessor", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "sorted", "torch.load", "torch.load", "torch.load", "torch.load", "numpy.loadtxt", "len", "len", "hasattr", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "audionet_csine.audionet_csine.load_state_dict", "audionet_csine.audionet_csine.eval().to", "audionet_csine.audionet_csine.train().to", "int", "len", "str", "range", "range", "audionet_csine.audionet_csine.eval", "audionet_csine.audionet_csine.train", "int", "len", "list", "label2id.keys"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["def", "__init__", "(", "self", ",", "extractor_file", "=", "None", ",", "num_class", "=", "None", ",", "label_encoder", "=", "None", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "'''\n        if extractor_file is not None, we want to inference by providing pre-trained model ckpt\n        if extractor_file is None, we want to train the model. In this case, num_class must not be None\n        '''", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "device", "=", "device", "\n", "\n", "num_class_1", "=", "None", "\n", "if", "extractor_file", "is", "not", "None", ":", "\n", "            ", "model_state_dict", "=", "torch", ".", "load", "(", "extractor_file", ",", "map_location", "=", "self", ".", "device", ")", "\n", "num_class_1", "=", "model_state_dict", "[", "'fc.bias'", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "num_class_2", "=", "None", "\n", "if", "label_encoder", "is", "not", "None", ":", "\n", "# parser label info", "\n", "            ", "id_label", "=", "np", ".", "loadtxt", "(", "label_encoder", ",", "dtype", "=", "str", ",", "converters", "=", "{", "0", ":", "lambda", "s", ":", "s", "[", "1", ":", "-", "1", "]", "}", ")", "\n", "id2label", "=", "{", "}", "\n", "label2id", "=", "{", "}", "\n", "for", "row", "in", "id_label", ":", "\n", "                ", "id2label", "[", "row", "[", "0", "]", "]", "=", "int", "(", "row", "[", "1", "]", ")", "\n", "label2id", "[", "int", "(", "row", "[", "1", "]", ")", "]", "=", "row", "[", "0", "]", "\n", "", "self", ".", "spk_ids", "=", "[", "label2id", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "list", "(", "label2id", ".", "keys", "(", ")", ")", ")", ")", "]", "\n", "self", ".", "id2label", "=", "id2label", "\n", "self", ".", "label2id", "=", "label2id", "\n", "num_class_2", "=", "len", "(", "self", ".", "spk_ids", ")", "# label encoder provides spk_ids info", "\n", "\n", "", "if", "len", "(", "[", "kk", "for", "kk", "in", "[", "num_class_1", ",", "num_class_2", "]", "if", "kk", "is", "not", "None", "]", ")", "==", "2", ":", "\n", "            ", "assert", "num_class_1", "==", "num_class_2", "\n", "num_class", "=", "num_class_1", "\n", "", "elif", "len", "(", "[", "kk", "for", "kk", "in", "[", "num_class_1", ",", "num_class_2", "]", "if", "kk", "is", "not", "None", "]", ")", "==", "1", ":", "\n", "            ", "num_class", "=", "[", "kk", "for", "kk", "in", "[", "num_class_1", ",", "num_class_2", "]", "if", "kk", "is", "not", "None", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "assert", "num_class", "is", "not", "None", "\n", "\n", "", "self", ".", "num_spks", "=", "num_class", "\n", "if", "not", "hasattr", "(", "self", ",", "'spk_ids'", ")", ":", "\n", "            ", "self", ".", "spk_ids", "=", "[", "str", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "num_spks", ")", "]", "\n", "\n", "", "self", ".", "prep", "=", "Preprocessor", "(", ")", "\n", "\n", "# =========== EXPERIMENTAL pre-filtering ======", "\n", "# 32 x 100", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "1", ",", "1", ",", "kernel_size", "=", "[", "5", ",", "5", "]", ",", "stride", "=", "1", ",", "padding", "=", "[", "2", ",", "2", "]", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "1", ")", ",", "\n", ")", "\n", "# =========== ============= ======", "\n", "\n", "# 32 x 100", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "32", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "MaxPool1d", "(", "2", ",", "stride", "=", "2", ")", "\n", ")", "\n", "# 64 x 100", "\n", "self", ".", "conv3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "128", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "# 128 x 100", "\n", "self", ".", "conv4", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "128", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "# 128 x 50", "\n", "self", ".", "conv5", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "128", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "MaxPool1d", "(", "2", ",", "stride", "=", "2", ")", "\n", ")", "\n", "# 128 x 50", "\n", "self", ".", "conv6", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "128", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "# 128 x 25", "\n", "self", ".", "conv7", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "128", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "MaxPool1d", "(", "2", ",", "stride", "=", "2", ")", "\n", ")", "\n", "self", ".", "conv8", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "64", ",", "32", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "32", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "\n", "# 32 x 30", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "32", ",", "num_class", ")", "\n", "\n", "if", "extractor_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "load_state_dict", "(", "model_state_dict", ")", "\n", "self", ".", "eval", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "train", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "threshold", "=", "-", "np", ".", "infty", "# this model targeted CSI-NE task, so threshold is -infty", "\n", "self", ".", "allowed_flags", "=", "sorted", "(", "[", "\n", "0", ",", "1", "\n", "]", ")", "# 0: wav; 1: raw feat", "\n", "self", ".", "range_type", "=", "'scale'", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat": [[133, 147], ["model.utils.check_input_range", "audionet_csine.audionet_csine.raw"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.check_input_range", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.raw"], ["", "def", "compute_feat", "(", "self", ",", "x", ",", "flag", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        x: wav with shape [B, 1, T]\n        flag: the flag indicating to compute what type of features (1: raw feat)\n        return: feats with shape [B, T, F] (T: #Frames, F: #feature_dim)\n        \"\"\"", "\n", "assert", "flag", "in", "[", "f", "for", "f", "in", "self", ".", "allowed_flags", "if", "f", "!=", "0", "]", "\n", "x", "=", "check_input_range", "(", "x", ",", "range_type", "=", "self", ".", "range_type", ")", "\n", "\n", "feats", "=", "self", ".", "raw", "(", "x", ")", "# (B, T, F)", "\n", "if", "flag", "==", "1", ":", "# calulate ori feat", "\n", "            ", "return", "feats", "\n", "", "else", ":", "# will not go to this branch", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.embedding": [[149, 165], ["audionet_csine.audionet_csine.extract_emb", "audionet_csine.audionet_csine.compute_feat"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.extract_emb", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.compute_feat"], ["", "", "def", "embedding", "(", "self", ",", "x", ",", "flag", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat)\n        \"\"\"", "\n", "assert", "flag", "in", "self", ".", "allowed_flags", "\n", "if", "flag", "==", "0", ":", "\n", "# x = check_input_range(x, range_type=self.range_type) # no need, since compute_feat will check", "\n", "            ", "feats", "=", "self", ".", "compute_feat", "(", "x", ",", "flag", "=", "self", ".", "allowed_flags", "[", "-", "1", "]", ")", "\n", "", "elif", "flag", "==", "1", ":", "\n", "            ", "feats", "=", "x", "\n", "", "else", ":", "# will not go to this branch", "\n", "            ", "pass", "\n", "", "emb", "=", "self", ".", "extract_emb", "(", "feats", ")", "\n", "# return emb - self.emb_mean # [B, D]", "\n", "return", "emb", "# already subtract emb mean in self.extract_emb(feats)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.raw": [[167, 174], ["x.squeeze.squeeze.squeeze", "audionet_csine.audionet_csine.prep", "audionet_csine.audionet_csine.transpose"], "methods", ["None"], ["", "def", "raw", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        x: (B, 1, T)\n        \"\"\"", "\n", "x", "=", "x", ".", "squeeze", "(", "1", ")", "\n", "feat", "=", "self", ".", "prep", "(", "x", ")", "# (B, F, T)", "\n", "return", "feat", ".", "transpose", "(", "1", ",", "2", ")", "# (B, T, F)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.extract_emb": [[176, 208], ["x.repeat.repeat.transpose", "x.repeat.repeat.unsqueeze", "audionet_csine.audionet_csine.conv1", "x.repeat.repeat.squeeze", "audionet_csine.audionet_csine.conv2", "audionet_csine.audionet_csine.conv3", "audionet_csine.audionet_csine.conv4", "audionet_csine.audionet_csine.conv5", "audionet_csine.audionet_csine.conv6", "audionet_csine.audionet_csine.conv7", "audionet_csine.audionet_csine.conv8", "x.repeat.repeat.max", "x.repeat.repeat.repeat"], "methods", ["None"], ["", "def", "extract_emb", "(", "self", ",", "x", ")", ":", "\n", "        ", "'''\n        x: (B, T, F)\n        '''", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", "\n", "# ===== pre-filtering ========", "\n", "# [B, F, T]", "\n", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "x", ".", "squeeze", "(", "1", ")", "\n", "# ===== pre-filtering ========", "\n", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "x", "=", "self", ".", "conv5", "(", "x", ")", "\n", "x", "=", "self", ".", "conv6", "(", "x", ")", "\n", "x", "=", "self", ".", "conv7", "(", "x", ")", "\n", "\n", "target_len", "=", "3", "\n", "real_len", "=", "x", ".", "shape", "[", "2", "]", "\n", "if", "real_len", "<", "target_len", ":", "\n", "            ", "n", "=", "target_len", "//", "real_len", "\n", "if", "target_len", "%", "real_len", "==", "0", ":", "\n", "                ", "n", "=", "n", "\n", "", "else", ":", "\n", "                ", "n", "=", "n", "+", "1", "\n", "", "x", "=", "x", ".", "repeat", "(", "1", ",", "1", ",", "n", ")", "\n", "\n", "", "x", "=", "self", ".", "conv8", "(", "x", ")", "\n", "x", ",", "_", "=", "x", ".", "max", "(", "2", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.predict_from_embeddings": [[210, 212], ["audionet_csine.audionet_csine.fc"], "methods", ["None"], ["", "def", "predict_from_embeddings", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "fc", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.forward": [[214, 229], ["audionet_csine.audionet_csine.embedding", "audionet_csine.audionet_csine.predict_from_embeddings"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.predict_from_embeddings"], ["", "def", "forward", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "return_emb", "=", "False", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat)\n        \"\"\"", "\n", "\"\"\"\n        enroll_embs is useless since this model targets CSI-NE task\n        just to keep consistency with other models\n        \"\"\"", "\n", "embedding", "=", "self", ".", "embedding", "(", "x", ",", "flag", "=", "flag", ")", "\n", "logits", "=", "self", ".", "predict_from_embeddings", "(", "embedding", ")", "\n", "if", "not", "return_emb", ":", "\n", "            ", "return", "logits", "\n", "", "else", ":", "\n", "            ", "return", "logits", ",", "embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.score": [[231, 244], ["audionet_csine.audionet_csine.forward"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.forward"], ["", "", "def", "score", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat)\n        \"\"\"", "\n", "\"\"\"\n        enroll_embs is useless since this model targets CSI-NE task\n        just to keep consistency with other models\n        \"\"\"", "\n", "logits", "=", "self", ".", "forward", "(", "x", ",", "flag", "=", "flag", ")", "\n", "# scores = F.softmax(logits, dim=1) # do not use softmax! Since CrossEntropy Loss in Pytorch already does this for us. Also to keep consistent with other models.", "\n", "scores", "=", "logits", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.audionet_csine.audionet_csine.make_decision": [[246, 258], ["audionet_csine.audionet_csine.score", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["", "def", "make_decision", "(", "self", ",", "x", ",", "flag", "=", "0", ",", "enroll_embs", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        x: wav or acoustic features (raw/delta/cmvn)\n        flag: indicating the type of x (0: wav; 1: raw feat)\n        \"\"\"", "\n", "\"\"\"\n        enroll_embs is useless since this model targets CSI-NE task\n        just to keep consistency with other models\n        \"\"\"", "\n", "scores", "=", "self", ".", "score", "(", "x", ",", "flag", "=", "flag", ")", "\n", "decisions", "=", "torch", ".", "argmax", "(", "scores", ",", "dim", "=", "1", ")", "\n", "return", "decisions", ",", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.check_input_range": [[7, 20], ["x.max", "x.min"], "function", ["None"], ["class", "SEC4SR_CrossEntropy", "(", "nn", ".", "CrossEntropyLoss", ")", ":", "# deal with something special on top of CrossEntropyLoss", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "weight", "=", "None", ",", "size_average", "=", "None", ",", "ignore_index", "=", "-", "100", ",", "reduce", "=", "None", ",", "reduction", "=", "'mean'", ",", "task", "=", "'CSI'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "weight", "=", "weight", ",", "size_average", "=", "size_average", ",", "ignore_index", "=", "ignore_index", ",", "reduce", "=", "reduce", ",", "reduction", "=", "reduction", ")", "\n", "\n", "assert", "task", "==", "'CSI'", "# CrossEntropy only supports CSI task", "\n", "\n", "", "def", "forward", "(", "self", ",", "scores", ",", "label", ")", ":", "\n", "\n", "        ", "_", ",", "num_class", "=", "scores", ".", "shape", "\n", "device", "=", "scores", ".", "device", "\n", "label", "=", "label", ".", "to", "(", "device", ")", "\n", "loss", "=", "torch", ".", "zeros", "(", "label", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "scores", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_enroll_model_file": [[21, 48], ["numpy.loadtxt", "list", "list", "model_info[].astype", "model_info[].astype", "torch.tensor", "torch.tensor", "enumerate", "len", "torch.load", "len", "warnings.warn", "torch.cat"], "function", ["None"], ["consider_index", "=", "torch", ".", "nonzero", "(", "label", "!=", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "consider_index", ")", ">", "0", ":", "\n", "            ", "loss", "[", "consider_index", "]", "=", "super", "(", ")", ".", "forward", "(", "scores", "[", "consider_index", "]", ",", "label", "[", "consider_index", "]", ")", "\n", "\n", "", "imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "imposter_index", ")", ":", "\n", "            ", "loss", "[", "imposter_index", "]", "=", "0.", "*", "torch", ".", "sum", "(", "scores", "[", "imposter_index", "]", ")", "# make backward", "\n", "\n", "", "return", "loss", "\n", "\n", "", "", "class", "SEC4SR_MarginLoss", "(", "nn", ".", "Module", ")", ":", "# deal with something special on top of MarginLoss", "\n", "\n", "    ", "def", "__init__", "(", "self", ",", "targeted", "=", "False", ",", "confidence", "=", "0.", ",", "task", "=", "'CSI'", ",", "threshold", "=", "None", ",", "clip_max", "=", "True", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "targeted", "=", "targeted", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n", "", "def", "forward", "(", "self", ",", "scores", ",", "label", ")", ":", "\n", "        ", "_", ",", "num_class", "=", "scores", ".", "shape", "\n", "device", "=", "scores", ".", "device", "\n", "label", "=", "label", ".", "to", "(", "device", ")", "\n", "loss", "=", "torch", ".", "zeros", "(", "label", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "scores", ".", "device", ")", "\n", "confidence", "=", "torch", ".", "tensor", "(", "self", ".", "confidence", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "\n", "if", "self", ".", "task", "==", "'SV'", ":", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_mean_file": [[50, 61], ["open", "open.readline", "range", "torch.tensor", "open.close", "rfile.readline.split", "len", "float"], "function", ["None"], ["imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "enroll_index", ")", "+", "len", "(", "imposter_index", ")", "==", "label", ".", "shape", "[", "0", "]", ",", "'SV task should not have labels out of 0 and -1'", "\n", "if", "len", "(", "enroll_index", ")", ">", "0", ":", "\n", "                ", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "enroll_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "scores", "[", "enroll_index", "]", ".", "squeeze", "(", "1", ")", "# imposter --> enroll, authentication bypass", "\n", "", "else", ":", "\n", "                    ", "loss", "[", "enroll_index", "]", "=", "scores", "[", "enroll_index", "]", ".", "squeeze", "(", "1", ")", "+", "confidence", "-", "self", ".", "threshold", "# enroll --> imposter, Denial of Service", "\n", "", "", "if", "len", "(", "imposter_index", ")", ">", "0", ":", "\n", "                ", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "imposter_index", "]", "=", "scores", "[", "imposter_index", "]", ".", "squeeze", "(", "1", ")", "+", "confidence", "-", "self", ".", "threshold", "# enroll --> imposter, Denial of Service", "\n", "", "else", ":", "\n", "                    ", "loss", "[", "imposter_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "scores", "[", "imposter_index", "]", ".", "squeeze", "(", "1", ")", "# imposter --> enroll, authentication bypass", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_transform_mat_file": [[63, 81], ["open", "reader.readlines", "len", "len", "numpy.zeros", "enumerate", "torch.tensor", "[].lstrip().rstrip().split", "numpy.array", "[].lstrip().rstrip().split", "[].lstrip().rstrip().split", "[].lstrip().rstrip", "float", "[].lstrip().rstrip", "[].lstrip().rstrip", "[].lstrip", "[].lstrip", "[].lstrip"], "function", ["None"], ["", "", "", "elif", "self", ".", "task", "==", "'CSI'", "or", "self", ".", "task", "==", "'OSI'", ":", "\n", "# remove imposter index which is unmeaningful for CSI task", "\n", "            ", "consider_index", "=", "torch", ".", "nonzero", "(", "label", "!=", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "len", "(", "consider_index", ")", ">", "0", ":", "\n", "                ", "label_one_hot", "=", "torch", ".", "zeros", "(", "(", "len", "(", "consider_index", ")", ",", "num_class", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "for", "i", ",", "ii", "in", "enumerate", "(", "consider_index", ")", ":", "\n", "                    ", "index", "=", "int", "(", "label", "[", "ii", "]", ")", "\n", "label_one_hot", "[", "i", "]", "[", "index", "]", "=", "1", "\n", "", "score_real", "=", "torch", ".", "sum", "(", "label_one_hot", "*", "scores", "[", "consider_index", "]", ",", "dim", "=", "1", ")", "\n", "score_other", "=", "torch", ".", "max", "(", "(", "1", "-", "label_one_hot", ")", "*", "scores", "[", "consider_index", "]", "-", "label_one_hot", "*", "10000", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "if", "self", ".", "targeted", ":", "\n", "                    ", "loss", "[", "consider_index", "]", "=", "score_other", "+", "confidence", "-", "score_real", "if", "self", ".", "task", "==", "'CSI'", "else", "torch", ".", "clamp", "(", "score_other", ",", "min", "=", "self", ".", "threshold", ")", "+", "confidence", "-", "score_real", "\n", "", "else", ":", "\n", "                    ", "if", "self", ".", "task", "==", "'CSI'", ":", "\n", "                        ", "loss", "[", "consider_index", "]", "=", "score_real", "+", "confidence", "-", "score_other", "\n", "", "else", ":", "\n", "                        ", "f_reject", "=", "torch", ".", "max", "(", "scores", "[", "consider_index", "]", ",", "1", ")", "[", "0", "]", "+", "confidence", "-", "self", ".", "threshold", "# spk m --> reject", "\n", "f_mis", "=", "torch", ".", "clamp", "(", "score_real", ",", "min", "=", "self", ".", "threshold", ")", "+", "confidence", "-", "score_other", "# spk_m --> spk_n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.model.utils.parse_mean_file_2": [[84, 92], ["open", "pickle.load().squeeze().to", "pickle.load().squeeze", "pickle.load"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "", "", "imposter_index", "=", "torch", ".", "nonzero", "(", "label", "==", "-", "1", ",", "as_tuple", "=", "True", ")", "[", "0", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "self", ".", "task", "==", "'OSI'", ":", "\n", "# imposter_index = torch.nonzero(label == -1, as_tuple=True)[0].detach().cpu().numpy().tolist()", "\n", "                ", "if", "len", "(", "imposter_index", ")", ">", "0", ":", "\n", "                    ", "if", "self", ".", "targeted", ":", "\n", "                        ", "loss", "[", "imposter_index", "]", "=", "torch", ".", "max", "(", "scores", "[", "imposter_index", "]", ",", "1", ")", "[", "0", "]", "+", "confidence", "-", "self", ".", "threshold", "\n", "", "else", ":", "\n", "                        ", "loss", "[", "imposter_index", "]", "=", "self", ".", "threshold", "+", "confidence", "-", "torch", ".", "max", "(", "scores", "[", "imposter_index", "]", ",", "1", ")", "[", "0", "]", "\n", "", "", "", "else", ":", "# CSI", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Hparams.__init__": [[14, 23], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "sr", "=", "16_000", "\n", "self", ".", "n_mels", "=", "32", "\n", "self", ".", "n_fft", "=", "1024", "\n", "self", ".", "hop_length", "=", "160", "\n", "self", ".", "win_length", "=", "800", "\n", "self", ".", "preemphasis", "=", "0.97", "\n", "self", ".", "fmin", "=", "0", "\n", "self", ".", "fmax", "=", "self", ".", "sr", "//", "2", "\n", "", "", "hp", "=", "Hparams", "(", ")", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor.__init__": [[55, 75], ["torch.nn.Module.__init__", "librosa.filters.mel", "torch.nn.Parameter", "torch.nn.Parameter", "Preprocessor.mel_to_linear_matrix", "numpy.linalg.pinv", "torch.from_numpy().float", "torch.tensor().float", "torch.from_numpy", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.mel_to_linear_matrix"], ["def", "__init__", "(", "self", ",", "augmentation", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "mel_basis", "=", "librosa", ".", "filters", ".", "mel", "(", "\n", "hp", ".", "sr", ",", "hp", ".", "n_fft", ",", "hp", ".", "n_mels", ",", "\n", "fmin", "=", "hp", ".", "fmin", ",", "fmax", "=", "hp", ".", "fmax", ")", "\n", "if", "hp", ".", "n_fft", "//", "4", "==", "hp", ".", "n_mels", ":", "\n", "            ", "inverse_mel", "=", "mel_to_linear_matrix", "(", "\n", "mel_basis", ",", "hp", ".", "sr", ",", "hp", ".", "n_fft", ",", "hp", ".", "n_mels", ")", "\n", "", "else", ":", "\n", "            ", "inverse_mel", "=", "np", ".", "linalg", ".", "pinv", "(", "mel_basis", ")", "\n", "\n", "", "self", ".", "_inverse_mel", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "from_numpy", "(", "inverse_mel", ")", ".", "float", "(", ")", ",", "\n", "requires_grad", "=", "False", "\n", ")", "\n", "self", ".", "mel_basis", "=", "torch", ".", "nn", ".", "Parameter", "(", "\n", "torch", ".", "tensor", "(", "mel_basis", ".", "T", ")", ".", "float", "(", ")", ",", "\n", "requires_grad", "=", "False", "\n", ")", "\n", "self", ".", "augmentation", "=", "augmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor._convert_to_mel_frequency": [[76, 84], ["mag_spec.transpose.transpose.transpose", "torch.matmul", "mel.transpose().contiguous.transpose().contiguous.transpose().contiguous", "mel.transpose().contiguous.transpose().contiguous.transpose"], "methods", ["None"], ["", "def", "_convert_to_mel_frequency", "(", "self", ",", "mag_spec", ")", ":", "\n", "        ", "\"\"\"\n        Input: linear magnitude spectrogram. [b, F, T] (float32)\n        \"\"\"", "\n", "mag_spec", "=", "mag_spec", ".", "transpose", "(", "2", ",", "1", ")", "\n", "mel", "=", "torch", ".", "matmul", "(", "mag_spec", ",", "self", ".", "mel_basis", ")", "\n", "mel", "=", "mel", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "return", "mel", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor.preemphasize": [[85, 87], ["None"], "methods", ["None"], ["", "def", "preemphasize", "(", "self", ",", "wav", ",", "coeff", ")", ":", "\n", "        ", "return", "wav", "[", ":", ",", "1", ":", "]", "-", "coeff", "*", "wav", "[", ":", ",", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor.forward": [[88, 113], ["Preprocessor.Preprocessor.preemphasize", "torch.stft", "Preprocessor._square", "Preprocessor.Preprocessor._convert_to_mel_frequency", "torch.clamp().log10", "torch.hann_window().to", "torch.clamp", "torch.hann_window"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor.preemphasize", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor._square", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.Preprocessor._convert_to_mel_frequency", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "forward", "(", "self", ",", "wav", ")", ":", "\n", "        ", "\"\"\" \n        Input: [b, T] `int16`\n        output: [b, F, t], values are in the range of [0, 1]\n        \"\"\"", "\n", "# if wav.dtype == torch.int16:", "\n", "#     wav = int16_to_float32(wav)", "\n", "# elif wav.dtype is not torch.float32:", "\n", "#     raise TypeError(f\"Unsupported type: {wav.dtype}\")", "\n", "\n", "wav", "=", "self", ".", "preemphasize", "(", "wav", ",", "hp", ".", "preemphasis", ")", "\n", "\n", "spec", "=", "torch", ".", "stft", "(", "\n", "wav", ",", "\n", "n_fft", "=", "hp", ".", "n_fft", ",", "\n", "hop_length", "=", "hp", ".", "hop_length", ",", "\n", "win_length", "=", "hp", ".", "win_length", ",", "\n", "window", "=", "torch", ".", "hann_window", "(", "hp", ".", "win_length", ")", ".", "to", "(", "wav", ".", "device", ")", ")", "\n", "\n", "# can't use abs because `torch` use 2 channels to represent complex number", "\n", "mag_spec", "=", "_square", "(", "spec", ")", "\n", "mel", "=", "self", ".", "_convert_to_mel_frequency", "(", "mag_spec", ")", "\n", "\n", "mel", "=", "10", "*", "torch", ".", "clamp", "(", "mel", ",", "EPSILON", ")", ".", "log10", "(", ")", "\n", "return", "mel", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor._square": [[28, 38], ["x.pow().sum", "x.pow"], "function", ["None"], ["def", "_square", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Torch represents Complex Number using 2 channels,\n    so the square of a complex number has to be implemented.\n    Inputs:\n        x: [..., 2]\n    Ouptuts:\n        y: [...]\n    \"\"\"", "\n", "return", "x", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", "# [b, F=1025, T]", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._audionet.Preprocessor.mel_to_linear_matrix": [[40, 46], ["librosa.filters.mel", "numpy.transpose", "numpy.matmul", "numpy.matmul", "numpy.diag", "numpy.sum", "numpy.abs"], "function", ["None"], ["", "def", "mel_to_linear_matrix", "(", "mel_basis", ",", "sr", ",", "n_fft", ",", "n_mels", ")", ":", "\n", "    ", "mel_basis", "=", "librosa", ".", "filters", ".", "mel", "(", "sr", ",", "n_fft", ",", "n_mels", ")", "\n", "m_t", "=", "np", ".", "transpose", "(", "mel_basis", ")", "\n", "p", "=", "np", ".", "matmul", "(", "mel_basis", ",", "m_t", ")", "\n", "d", "=", "[", "1.0", "/", "x", "if", "np", ".", "abs", "(", "x", ")", ">", "1.0e-8", "else", "x", "for", "x", "in", "np", ".", "sum", "(", "p", ",", "axis", "=", "0", ")", "]", "\n", "return", "np", ".", "matmul", "(", "m_t", ",", "np", ".", "diag", "(", "d", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.__init__": [[17, 52], ["torch.ones", "torch.ones", "torch.ones", "open", "open.readline", "len", "range", "torch.tensor", "open.readline", "open.readline", "range", "torch.tensor", "range", "torch.tensor", "open.close", "open.readline.split", "float", "range", "transform_matrix.append", "open.readline", "open.readline.split", "float", "open.readline.split", "float"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "mdlfile", ",", "random", "=", "False", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "\t\t", "self", ".", "device", "=", "device", "\n", "\n", "if", "random", "==", "True", ":", "\n", "\t\t\t", "self", ".", "dim", "=", "600", "\n", "self", ".", "mean", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "transform", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "psi", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "\t\t\t", "rdfile", "=", "open", "(", "mdlfile", ",", "'r'", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "data", "=", "line", ".", "split", "(", ")", "[", "2", ":", "-", "1", "]", "\n", "self", ".", "dim", "=", "len", "(", "data", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "[", "i", "]", "=", "float", "(", "data", "[", "i", "]", ")", "\n", "", "self", ".", "mean", "=", "torch", ".", "tensor", "(", "data", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "transform_matrix", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "=", "line", ".", "split", "(", "' '", ")", "[", "2", ":", "-", "1", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t\t", "data", "[", "j", "]", "=", "float", "(", "data", "[", "j", "]", ")", "\n", "", "transform_matrix", ".", "append", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "self", ".", "transform", "=", "torch", ".", "tensor", "(", "transform_matrix", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "data", "=", "line", ".", "split", "(", ")", "[", "1", ":", "-", "1", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "[", "i", "]", "=", "float", "(", "data", "[", "i", "]", ")", "\n", "", "self", ".", "psi", "=", "torch", ".", "tensor", "(", "data", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "rdfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.ReadIvectors": [[53, 67], ["kaldi_io.read_vec_flt_scp", "print", "keys.append", "data.append", "mat.tolist"], "methods", ["None"], ["", "", "def", "ReadIvectors", "(", "self", ",", "ivectorfile", ")", ":", "\n", "\t\t", "keys", "=", "[", "]", "\n", "data", "=", "[", "]", "\n", "i", "=", "0", "\n", "for", "key", ",", "mat", "in", "kaldi_io", ".", "read_vec_flt_scp", "(", "ivectorfile", ")", ":", "\n", "# print(key)", "\n", "# print(mat)", "\n", "# print(len(mat.tolist()))", "\n", "# exit(0)", "\n", "\t\t\t", "i", "+=", "1", "\n", "keys", ".", "append", "(", "key", ")", "\n", "data", ".", "append", "(", "mat", ".", "tolist", "(", ")", ")", "\n", "", "print", "(", "'totally %d ivectors'", "%", "(", "i", ")", ")", "\n", "return", "keys", ",", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.Transform": [[69, 72], ["plda.PLDA.TransformIvector"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.TransformIvector"], ["", "def", "Transform", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "\n", "\t\t", "return", "self", ".", "TransformIvector", "(", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.TransformIvector": [[73, 90], ["torch.matmul", "torch.sqrt", "torch.norm", "plda.PLDA.GetNormalizaionFactor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.GetNormalizaionFactor"], ["", "def", "TransformIvector", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "# print(self.transform, self.mean, ivector),", "\n", "\t\t", "trans_ivector", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ",", "ivector", "-", "self", ".", "mean", ")", "\n", "factor", "=", "1.0", "\n", "if", "simple_length_norm", "==", "True", ":", "\n", "\t\t\t", "factor", "=", "torch", ".", "sqrt", "(", "self", ".", "dim", ")", "/", "torch", ".", "norm", "(", "trans_ivector", ",", "2", ")", "\n", "", "elif", "normalize_length", "==", "True", ":", "\n", "\t\t\t", "factor", "=", "self", ".", "GetNormalizaionFactor", "(", "trans_ivector", ",", "num_examples", ")", "\n", "\n", "# print('original ivector is \\n')", "\n", "# print(trans_ivector)", "\n", "", "trans_ivector", "=", "trans_ivector", "*", "factor", "\n", "# print('factor is %f' %(factor))", "\n", "# print('transformed ivector is \\n')", "\n", "# print(trans_ivector)", "\n", "\n", "return", "trans_ivector", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.GetNormalizaionFactor": [[92, 98], ["torch.pow", "torch.sqrt", "torch.dot"], "methods", ["None"], ["", "def", "GetNormalizaionFactor", "(", "self", ",", "trans_ivector", ",", "num_examples", ")", ":", "\n", "\t\t", "trans_ivector_sq", "=", "torch", ".", "pow", "(", "trans_ivector", ",", "2", ")", "\n", "inv_covar", "=", "1.0", "/", "(", "self", ".", "psi", "+", "1.0", "/", "num_examples", ")", "\n", "factor", "=", "torch", ".", "sqrt", "(", "self", ".", "dim", "/", "torch", ".", "dot", "(", "inv_covar", ",", "trans_ivector_sq", ")", ")", "\n", "\n", "return", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.ComputeScores_loop": [[99, 138], ["torch.zeros", "torch.zeros", "range", "torch.sum", "torch.pow", "torch.pow", "torch.sum", "torch.log", "torch.log", "torch.dot", "torch.dot", "torch.log", "torch.log", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "ComputeScores_loop", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "# trans_trainivector = self.TransformIvector(trainivector, num_examples, simple_length_norm, normalize_length)", "\n", "# trans_testivector = self.TransformIvector(testivector, 1, simple_length_norm, normalize_length)", "\n", "\n", "#### work out loglike_given_class", "\n", "# mean = torch.zeros(self.dim) ", "\n", "# variance = torch.zeros(self.dim)", "\n", "\t\t", "mean", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "variance", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# debug", "\n", "# print(self.dim),", "\n", "# print(mean.size())", "\n", "# print(variance.size())", "\n", "# print(self.psi.size())", "\n", "# print(trans_trainivector.size())  ", "\n", "# print(trans_testivector.size())    ", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t", "mean", "[", "i", "]", "=", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "*", "trans_trainivector", "[", "i", "]", "\n", "variance", "[", "i", "]", "=", "1.0", "+", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "\n", "\n", "", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "\n", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", "-", "mean", ",", "2", ")", "\n", "variance", "=", "1.0", "/", "variance", "\n", "\n", "loglike_given_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "\n", "\n", "### work out loglike_without_class", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", ",", "2", ")", "\n", "variance", "=", "self", ".", "psi", "+", "1.0", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "\n", "variance", "=", "1.0", "/", "variance", "\n", "loglike_without_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "\n", "\n", "loglike_ratio", "=", "loglike_given_class", "-", "loglike_without_class", "\n", "\n", "return", "loglike_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.ComputeScores": [[140, 191], ["torch.zeros", "torch.zeros", "torch.sum", "torch.pow", "torch.pow", "torch.sum", "torch.log", "torch.log", "torch.sum", "torch.dot", "torch.log", "torch.log", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "ComputeScores", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "# trans_trainivector = self.TransformIvector(trainivector, num_examples, simple_length_norm, normalize_length)", "\n", "# trans_testivector = self.TransformIvector(testivector, 1, simple_length_norm, normalize_length)", "\n", "\n", "#### work out loglike_given_class", "\n", "# mean = torch.zeros(self.dim)", "\n", "# variance = torch.zeros(self.dim)", "\n", "# mean = torch.zeros(self.dim, device=self.device)", "\n", "# variance = torch.zeros(self.dim, device=self.device)", "\n", "\t\t", "n_train_ivectors", "=", "trans_trainivector", ".", "shape", "[", "0", "]", "\n", "assert", "num_examples", "==", "1", "\n", "mean", "=", "torch", ".", "zeros", "(", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "variance", "=", "torch", ".", "zeros", "(", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# debug", "\n", "# print(self.dim),  ", "\n", "# print(mean.size()) ", "\n", "# print(variance.size()) ", "\n", "# print(self.psi.size()) ", "\n", "# print(trans_trainivector.size())  ", "\n", "# print(trans_testivector.size())    ", "\n", "\n", "# for i in range(self.dim):", "\n", "# \tmean[i] = num_examples*self.psi[i]/(num_examples*self.psi[i]+1.0)*trans_trainivector[i]", "\n", "# \tvariance[i] = 1.0+self.psi[i]/(num_examples*self.psi[i]+1.0)", "\n", "# for i in range(self.dim):", "\n", "# \tmean[i] = num_examples*self.psi[i]/(num_examples*self.psi[i]+1.0)*trans_trainivector[i]", "\n", "# \tvariance[i] = 1.0+self.psi[i]/(num_examples*self.psi[i]+1.0)", "\n", "mean", "=", "num_examples", "*", "self", ".", "psi", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1.0", ")", "*", "trans_trainivector", "# (n, dim)", "\n", "variance", "=", "(", "1.0", "+", "self", ".", "psi", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1.0", ")", ")", ".", "expand", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", "# (n, dim)", "\n", "# print(mean.shape, variance.shape)", "\n", "\n", "# logdet = torch.sum(torch.log(variance)) ", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ",", "dim", "=", "1", ")", "# (n, ) ", "\n", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", "-", "mean", ",", "2", ")", "# (n, dim)", "\n", "variance", "=", "1.0", "/", "variance", "# (n, dim)", "\n", "\n", "# loglike_given_class = -0.5*(logdet + torch.log(2*torch.tensor(3.1415926, device=self.device))*self.dim + torch.dot(sqdiff, variance))", "\n", "loglike_given_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "sum", "(", "sqdiff", "*", "variance", ",", "axis", "=", "1", ")", ")", "# (n, )", "\n", "\n", "### work out loglike_without_class", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", ",", "2", ")", "# (dim, )", "\n", "variance", "=", "self", ".", "psi", "+", "1.0", "# (dim, )", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "# scalar", "\n", "variance", "=", "1.0", "/", "variance", "# (dim, )", "\n", "loglike_without_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "# scalar", "\n", "\n", "loglike_ratio", "=", "loglike_given_class", "-", "loglike_without_class", "# (n,)", "\n", "\n", "return", "loglike_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.DRV_TransformIvector": [[192, 214], ["torch.matmul", "plda.PLDA.GetNormalizaionFactor", "torch.zeros", "torch.pow", "torch.matmul", "range", "torch.matmul", "plda.PLDA.transform.t", "torch.diag", "plda.PLDA.transform.t", "torch.pow"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.GetNormalizaionFactor"], ["", "def", "DRV_TransformIvector", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "############ Currently we only consider simple_length_norm = False situation.", "\n", "\t\t", "if", "normalize_length", "==", "True", ":", "\n", "\t\t\t", "trans_ivector", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ",", "ivector", "-", "self", ".", "mean", ")", "\n", "factor", "=", "1.0", "\n", "factor", "=", "self", ".", "GetNormalizaionFactor", "(", "trans_ivector", ",", "num_examples", ")", "\n", "\n", "norm_drv", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "trans_ivector_sq", "=", "torch", ".", "pow", "(", "trans_ivector", ",", "2", ")", "\n", "\n", "common_vector", "=", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "num_examples", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1", ")", ")", ",", "-", "1", "*", "trans_ivector_sq", "*", "torch", ".", "pow", "(", "factor", ",", "3", ")", "/", "self", ".", "dim", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "norm_drv", "[", ":", ",", "i", "]", "+=", "common_vector", "\n", "norm_drv", "[", "i", "]", "[", "i", "]", "+=", "factor", "\n", "\n", "", "transform_drv", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ".", "t", "(", ")", ",", "norm_drv", ")", "\n", "", "else", ":", "\n", "\t\t\t", "transform_drv", "=", "self", ".", "transform", ".", "t", "(", ")", "\n", "\n", "", "return", "transform_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.DRV_Scores": [[215, 229], ["torch.zeros", "torch.zeros", "range", "torch.matmul", "torch.matmul", "torch.diag", "torch.diag"], "methods", ["None"], ["", "def", "DRV_Scores", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "\t\t", "mean", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "v1", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t", "mean", "[", "i", "]", "=", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "*", "trans_trainivector", "[", "i", "]", "\n", "v1", "[", "i", "]", "=", "1.0", "+", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "\n", "\n", "", "v1", "=", "1.0", "/", "v1", "\n", "v2", "=", "1.0", "/", "(", "1", "+", "self", ".", "psi", ")", "\n", "\n", "score_drv", "=", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "trans_testivector", ")", ",", "v2", ")", "-", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "trans_testivector", "-", "mean", ")", ",", "v1", ")", "\n", "\n", "return", "score_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.plda.PLDA.to": [[230, 239], ["plda.PLDA.mean.to", "plda.PLDA.transform.to", "plda.PLDA.psi.to"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "\n", "\t\t", "if", "device", "==", "self", ".", "device", ":", "\n", "\t\t\t", "return", "\n", "\n", "", "self", ".", "device", "=", "device", "\n", "self", ".", "mean", "=", "self", ".", "mean", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "transform", "=", "self", ".", "transform", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "psi", "=", "self", ".", "psi", ".", "to", "(", "self", ".", "device", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.__init__": [[20, 83], ["gmm.FullGMM.Means", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "open", "open.readline", "open.close", "len", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "open.readline", "open.readline.split", "float", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "open.readline", "open.readline.split", "float", "open.readline", "range", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "means_invcovars.append", "open.readline", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "open.readline", "open.readline.split", "len", "float", "open.readline", "range", "range", "open.readline", "open.readline.split", "len", "float", "float"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Means"], ["\t", "def", "__init__", "(", "self", ",", "mdlfile", ",", "random", "=", "False", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "\t\t", "self", ".", "device", "=", "device", "\n", "\n", "if", "random", "==", "True", ":", "\n", "\t\t\t", "self", ".", "num_gaussians", "=", "2048", "\n", "self", ".", "dim", "=", "60", "\n", "self", ".", "gconsts", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussians", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "weights", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussians", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "means_invcovars", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussians", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "invcovars", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussians", ",", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "\t\t\t", "rdfile", "=", "open", "(", "mdlfile", ",", "'r'", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "while", "line", "!=", "''", ":", "\n", "\t\t\t\t", "if", "'<GCONSTS>'", "in", "line", ":", "\n", "# print('processing <GCONSTS>')", "\n", "\t\t\t\t\t", "gconsts", "=", "line", ".", "split", "(", ")", "[", "2", ":", "-", "1", "]", "\n", "self", ".", "num_gaussians", "=", "len", "(", "gconsts", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t\t\t\t", "gconsts", "[", "i", "]", "=", "float", "(", "gconsts", "[", "i", "]", ")", "\n", "", "self", ".", "gconsts", "=", "torch", ".", "tensor", "(", "gconsts", ",", "device", "=", "self", ".", "device", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "elif", "'<WEIGHTS>'", "in", "line", ":", "\n", "# print('processing <WEIGHTS>')", "\n", "\t\t\t\t\t", "weights", "=", "line", ".", "split", "(", ")", "[", "2", ":", "-", "1", "]", "\n", "# if len(weights) != self.num_gaussians:", "\n", "# \tprint('Dimension does not match between weights and gconsts.')", "\n", "# \texit(1)", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t\t\t\t", "weights", "[", "i", "]", "=", "float", "(", "weights", "[", "i", "]", ")", "\n", "", "self", ".", "weights", "=", "torch", ".", "tensor", "(", "weights", ",", "device", "=", "self", ".", "device", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "elif", "'<MEANS_INVCOVARS>'", "in", "line", ":", "\n", "# print('processing <MEANS_INVCOVARS>')", "\n", "\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "means_invcovars", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t\t\t\t", "data", "=", "line", ".", "split", "(", "' '", ")", "[", "2", ":", "-", "1", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "\t\t\t\t\t\t\t", "data", "[", "j", "]", "=", "float", "(", "data", "[", "j", "]", ")", "\n", "", "means_invcovars", ".", "append", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "self", ".", "dim", "=", "len", "(", "data", ")", "\n", "self", ".", "means_invcovars", "=", "torch", ".", "tensor", "(", "means_invcovars", ",", "device", "=", "self", ".", "device", ")", "# (self.num_gaussians, self.dim)", "\n", "# print(self.means_invcovars.size())", "\n", "", "elif", "'<INV_COVARS>'", "in", "line", ":", "\n", "# print('processing <INV_COVARS>')", "\n", "\t\t\t\t\t", "self", ".", "invcovars", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussians", ",", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "for", "j", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t\t\t\t", "data", "=", "line", ".", "split", "(", "' '", ")", "[", ":", "-", "1", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "invcovars", "[", "i", "]", "[", "j", "]", "[", "k", "]", "=", "float", "(", "data", "[", "k", "]", ")", "\n", "self", ".", "invcovars", "[", "i", "]", "[", "k", "]", "[", "j", "]", "=", "float", "(", "data", "[", "k", "]", ")", "\n", "", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "# for i in range(self.num_gaussians):", "\n", "# \tself.invcovars[i] = self.SymmetricMatrix(self.invcovars[i])", "\n", "", "", "", "else", ":", "\n", "\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "", "rdfile", ".", "close", "(", ")", "\n", "", "self", ".", "Means", "(", ")", "# (self.num_gaussians, self.dim)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Means": [[84, 88], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "gmm.FullGMM.means_invcovars.unsqueeze"], "methods", ["None"], ["", "def", "Means", "(", "self", ")", ":", "\n", "# print('processing <Means>')", "\n", "\t\t", "self", ".", "means", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussians", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "means", "=", "torch", ".", "matmul", "(", "torch", ".", "inverse", "(", "self", ".", "invcovars", ")", ",", "self", ".", "means_invcovars", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "# print(self.means.size())", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.SymmetricMatrix": [[91, 99], ["matrix.size", "range", "range"], "methods", ["None"], ["", "def", "SymmetricMatrix", "(", "self", ",", "matrix", ")", ":", "\n", "\t\t", "num_row", ",", "num_col", "=", "matrix", ".", "size", "(", ")", "\n", "new_matrix", "=", "matrix", "\n", "for", "i", "in", "range", "(", "num_row", ")", ":", "\n", "\t\t\t", "for", "j", "in", "range", "(", "i", "+", "1", ",", "num_col", ")", ":", "\n", "\t\t\t\t", "new_matrix", "[", "i", "]", "[", "j", "]", "=", "matrix", "[", "j", "]", "[", "i", "]", "\n", "\n", "", "", "return", "new_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.ComponentLogLikelihood": [[120, 132], ["torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "range", "math.ceil", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "gmm.FullGMM.means_invcovars.unsqueeze", "data.unsqueeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "data[].unsqueeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "gmm.FullGMM.invcovars.unsqueeze", "data[].unsqueeze().unsqueeze", "data[].unsqueeze"], "methods", ["None"], ["", "def", "ComponentLogLikelihood", "(", "self", ",", "data", ",", "gmm_frame_bs", "=", "200", ")", ":", "# data: (T, dim)", "\n", "\t\t", "loglike", "=", "torch", ".", "matmul", "(", "self", ".", "means_invcovars", ".", "unsqueeze", "(", "0", ")", ",", "data", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "# (T, n_g)", "\n", "bs", "=", "gmm_frame_bs", "\n", "for", "T_i", "in", "range", "(", "math", ".", "ceil", "(", "loglike", ".", "shape", "[", "0", "]", "/", "bs", ")", ")", ":", "\n", "\t\t\t", "s", "=", "T_i", "*", "bs", "\n", "e", "=", "(", "T_i", "+", "1", ")", "*", "bs", "\n", "# print(data.shape[0], T_i, s, e, data[s:e].shape)", "\n", "loglike", "[", "s", ":", "e", ",", ":", "]", "-=", "0.5", "*", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "invcovars", ".", "unsqueeze", "(", "0", ")", ",", "data", "[", "s", ":", "e", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", ",", "\n", "data", "[", "s", ":", "e", ",", ":", "]", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "# (T, n_g)", "\n", "", "loglike", "+=", "self", ".", "gconsts", "\n", "\n", "return", "loglike", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Posterior": [[133, 137], ["torch.softmax", "torch.softmax", "gmm.FullGMM.ComponentLogLikelihood"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.ComponentLogLikelihood"], ["", "def", "Posterior", "(", "self", ",", "data", ",", "gmm_frame_bs", "=", "200", ")", ":", "\n", "\t\t", "post", "=", "F", ".", "softmax", "(", "self", ".", "ComponentLogLikelihood", "(", "data", ",", "gmm_frame_bs", ")", ",", "-", "1", ")", "\n", "\n", "return", "post", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Zeroth_FirstCenter_Stats": [[138, 150], ["len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "gmm.FullGMM.Posterior", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "gmm.FullGMM.unsqueeze", "data_seq[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Posterior"], ["", "def", "Zeroth_FirstCenter_Stats", "(", "self", ",", "data_seq", ")", ":", "\n", "\t\t", "num_frame", "=", "len", "(", "data_seq", ")", "\n", "zeroth_stats", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussians", ",", "device", "=", "self", ".", "device", ")", "\n", "firstcenter_stats", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussians", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "num_frame", ")", ":", "\n", "\t\t\t", "post", "=", "self", ".", "Posterior", "(", "data_seq", "[", "i", "]", ")", "\n", "zeroth_stats", "+=", "post", "\n", "firstcenter_stats", "+=", "torch", ".", "mm", "(", "post", ".", "unsqueeze", "(", "-", "1", ")", ",", "data_seq", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "", "firstcenter_stats", "-=", "torch", ".", "mm", "(", "torch", ".", "diag", "(", "zeroth_stats", ")", ",", "self", ".", "means", ")", "\n", "\n", "return", "zeroth_stats", ",", "firstcenter_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Zeroth_First_Stats": [[166, 172], ["gmm.FullGMM.Posterior", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "gmm.FullGMM.unsqueeze", "data_seq.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Posterior"], ["", "def", "Zeroth_First_Stats", "(", "self", ",", "data_seq", ",", "gmm_frame_bs", "=", "200", ")", ":", "\n", "\t\t", "posts", "=", "self", ".", "Posterior", "(", "data_seq", ",", "gmm_frame_bs", ")", "# (T, n_g)", "\n", "zeroth_stats", "=", "torch", ".", "sum", "(", "posts", ",", "0", ")", "# (n_g)", "\n", "first_stats", "=", "torch", ".", "sum", "(", "torch", ".", "matmul", "(", "posts", ".", "unsqueeze", "(", "-", "1", ")", ",", "data_seq", ".", "unsqueeze", "(", "1", ")", ")", ",", "0", ")", "\n", "\n", "return", "zeroth_stats", ",", "first_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.DRV_Ni": [[173, 180], ["torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().unsqueeze", "torch.matmul().unsqueeze", "torch.matmul().unsqueeze", "torch.matmul().unsqueeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "post.unsqueeze().t", "torch.matmul().squeeze.t", "torch.matmul().squeeze.t", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "centered_data.unsqueeze", "torch.matmul().squeeze.t", "torch.matmul().squeeze.t", "post.unsqueeze"], "methods", ["None"], ["", "def", "DRV_Ni", "(", "self", ",", "data", ",", "post", ")", ":", "\n", "\t\t", "centered_data", "=", "-", "1", "*", "self", ".", "means", "+", "data", "# C*F", "\n", "sig_in_cent", "=", "torch", ".", "matmul", "(", "self", ".", "invcovars", ",", "centered_data", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "# C*F", "\n", "const", "=", "torch", ".", "matmul", "(", "sig_in_cent", ".", "t", "(", ")", ",", "post", ")", ".", "unsqueeze", "(", "-", "1", ")", "# F*1", "\n", "Ni_drv", "=", "torch", ".", "matmul", "(", "const", ",", "post", ".", "unsqueeze", "(", "-", "1", ")", ".", "t", "(", ")", ")", "-", "torch", ".", "matmul", "(", "sig_in_cent", ".", "t", "(", ")", ",", "torch", ".", "diag", "(", "post", ")", ")", "\n", "\n", "return", "Ni_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.DRV_ui": [[181, 189], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.append", "torch.cat.append", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "Ni_drv[].unsqueeze", "data.unsqueeze().t", "data.unsqueeze"], "methods", ["None"], ["", "def", "DRV_ui", "(", "self", ",", "Ni_drv", ",", "data", ",", "post", ")", ":", "\n", "\t\t", "ui_drv", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t", "drv", "=", "post", "[", "i", "]", "*", "torch", ".", "eye", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "+", "torch", ".", "matmul", "(", "Ni_drv", "[", ":", ",", "i", "]", ".", "unsqueeze", "(", "-", "1", ")", ",", "data", ".", "unsqueeze", "(", "-", "1", ")", ".", "t", "(", ")", ")", "\n", "ui_drv", ".", "append", "(", "drv", ")", "\n", "", "ui_drv", "=", "torch", ".", "cat", "(", "ui_drv", ",", "1", ")", "# F*CF", "\n", "\n", "return", "ui_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.ui": [[190, 199], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.cat.append", "torch.cat.append", "data_seq.t", "torch.matmul.t", "torch.matmul.t"], "methods", ["None"], ["", "def", "ui", "(", "self", ",", "posts_seq", ",", "data_seq", ")", ":", "\n", "\t\t", "ui", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussians", ")", ":", "\n", "\t\t\t", "uij", "=", "torch", ".", "matmul", "(", "data_seq", ".", "t", "(", ")", ",", "posts_seq", "[", "i", "]", ")", "# F*1", "\n", "ui", ".", "append", "(", "uij", ".", "t", "(", ")", ")", "\n", "\n", "", "ui", "=", "torch", ".", "cat", "(", "ui", ",", "0", ")", "\n", "\n", "return", "ui", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.post_seq": [[200, 208], ["range", "torch.stack().t", "torch.stack().t", "torch.stack().t", "torch.stack().t", "len", "torch.stack().t.append", "torch.stack().t.append", "gmm.FullGMM.Posterior", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.Posterior"], ["", "def", "post_seq", "(", "self", ",", "data_seq", ")", ":", "\n", "\t\t", "posts", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "data_seq", ")", ")", ":", "\n", "\t\t\t", "posts", ".", "append", "(", "self", ".", "Posterior", "(", "data_seq", "[", "i", "]", ")", ")", "\n", "\n", "", "posts", "=", "torch", ".", "stack", "(", "posts", ",", "0", ")", ".", "t", "(", ")", "\n", "\n", "return", "posts", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.gmm.FullGMM.to": [[210, 221], ["gmm.FullGMM.gconsts.to", "gmm.FullGMM.weights.to", "gmm.FullGMM.means_invcovars.to", "gmm.FullGMM.invcovars.to", "gmm.FullGMM.means.to"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "\n", "\t\t", "if", "device", "==", "self", ".", "device", ":", "\n", "\t\t\t", "return", "\n", "\n", "", "self", ".", "device", "=", "device", "\n", "self", ".", "gconsts", "=", "self", ".", "gconsts", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "weights", "=", "self", ".", "weights", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "means_invcovars", "=", "self", ".", "means_invcovars", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "invcovars", "=", "self", ".", "invcovars", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "means", "=", "self", ".", "means", ".", "to", "(", "self", ".", "device", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.__init__": [[16, 71], ["torch.ones", "torch.ones", "torch.tensor", "open", "open.readline", "open.close", "len", "open.readline", "open.readline.split", "range", "torch.tensor", "open.readline", "range", "component_extractor_matrix.append", "open.readline", "extractor_matrix.append", "torch.zeros", "range", "open.readline.split", "range", "component_extractor_matrix.append", "open.readline", "open.readline.split", "len", "float", "ivector_extract.ivectorExtractor.extractor_matrix.size", "ivector_extract.ivectorExtractor.extractor_matrix.size", "open.readline", "range", "torch.tensor", "open.readline", "open.readline", "len", "float", "open.readline.split", "range", "open.readline", "float", "float", "float", "open.readline.split"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "mdlfile", ",", "random", "=", "False", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "\t\t", "self", ".", "device", "=", "device", "\n", "\n", "if", "random", "==", "True", ":", "\n", "\t\t\t", "self", ".", "num_gaussian", "=", "2048", "\n", "self", ".", "dim", "=", "60", "\n", "self", ".", "ivector_dim", "=", "600", "\n", "self", ".", "extractor_matrix", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussian", ",", "self", ".", "dim", ",", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "sigma_inv", "=", "torch", ".", "ones", "(", "self", ".", "num_gaussian", ",", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "offset", "=", "torch", ".", "tensor", "(", "1.0", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "\t\t\t", "rdfile", "=", "open", "(", "mdlfile", ",", "'r'", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "while", "line", "!=", "''", ":", "\n", "\t\t\t\t", "if", "'<w_vec>'", "in", "line", ":", "\n", "\t\t\t\t\t", "data", "=", "line", ".", "split", "(", ")", "[", "2", ":", "-", "1", "]", "\n", "self", ".", "num_gaussian", "=", "len", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "elif", "'<M>'", "in", "line", ":", "\n", "\t\t\t\t\t", "extractor_matrix", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussian", ")", ":", "\n", "\t\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "component_extractor_matrix", "=", "[", "]", "\n", "while", "']'", "not", "in", "line", ":", "\n", "\t\t\t\t\t\t\t", "data", "=", "line", ".", "split", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "data", "[", "j", "]", "=", "float", "(", "data", "[", "j", "]", ")", "\n", "", "component_extractor_matrix", ".", "append", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "data", "=", "line", ".", "split", "(", ")", "[", ":", "-", "1", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "\t\t\t\t\t\t\t", "data", "[", "j", "]", "=", "float", "(", "data", "[", "j", "]", ")", "\n", "", "component_extractor_matrix", ".", "append", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "extractor_matrix", ".", "append", "(", "component_extractor_matrix", ")", "\n", "", "self", ".", "extractor_matrix", "=", "torch", ".", "tensor", "(", "extractor_matrix", ",", "device", "=", "self", ".", "device", ")", "# C*F*D", "\n", "", "elif", "'<SigmaInv>'", "in", "line", ":", "\n", "\t\t\t\t\t", "self", ".", "dim", "=", "self", ".", "extractor_matrix", ".", "size", "(", ")", "[", "1", "]", "\n", "self", ".", "ivector_dim", "=", "self", ".", "extractor_matrix", ".", "size", "(", ")", "[", "2", "]", "\n", "self", ".", "sigma_inv", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussian", ",", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussian", ")", ":", "\n", "\t\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "for", "j", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t\t\t\t", "data", "=", "line", ".", "split", "(", ")", "\n", "for", "k", "in", "range", "(", "j", "+", "1", ")", ":", "\n", "\t\t\t\t\t\t\t\t", "self", ".", "sigma_inv", "[", "i", "]", "[", "j", "]", "[", "k", "]", "=", "float", "(", "data", "[", "k", "]", ")", "\n", "self", ".", "sigma_inv", "[", "i", "]", "[", "k", "]", "[", "j", "]", "=", "float", "(", "data", "[", "k", "]", ")", "\n", "", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "", "", "elif", "'<IvectorOffset>'", "in", "line", ":", "\n", "\t\t\t\t\t", "self", ".", "offset", "=", "torch", ".", "tensor", "(", "float", "(", "line", ".", "split", "(", ")", "[", "1", "]", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "else", ":", "\n", "\t\t\t\t\t", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "", "rdfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.Extractivector_loop": [[77, 92], ["torch.eye", "torch.zeros", "range", "torch.inverse", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "ivector_extract.ivectorExtractor.extractor_matrix[].t", "ivector_extract.ivectorExtractor.extractor_matrix[].t"], "methods", ["None"], ["", "", "def", "Extractivector_loop", "(", "self", ",", "zeroth_stats", ",", "first_stats", ")", ":", "\n", "\t\t", "L", "=", "torch", ".", "eye", "(", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "\n", "linear", "=", "torch", ".", "zeros", "(", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_gaussian", ")", ":", "\n", "\t\t\t", "L", "+=", "zeroth_stats", "[", "i", "]", "*", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "extractor_matrix", "[", "i", "]", ".", "t", "(", ")", ",", "self", ".", "sigma_inv", "[", "i", "]", ")", ",", "self", ".", "extractor_matrix", "[", "i", "]", ")", "\n", "linear", "+=", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "extractor_matrix", "[", "i", "]", ".", "t", "(", ")", ",", "self", ".", "sigma_inv", "[", "i", "]", ")", ",", "first_stats", "[", "i", "]", ")", "\n", "\n", "", "linear", "[", "0", "]", "+=", "self", ".", "offset", "\n", "L_inv", "=", "torch", ".", "inverse", "(", "L", ")", "\n", "\n", "ivector", "=", "torch", ".", "matmul", "(", "L_inv", ",", "linear", ")", "\n", "ivector", "[", "0", "]", "-=", "self", ".", "offset", "\n", "\n", "return", "ivector", ",", "L_inv", ",", "linear", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.Extract": [[94, 96], ["ivector_extract.ivectorExtractor.Extractivector"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.Extractivector"], ["", "def", "Extract", "(", "self", ",", "zeroth_stats", ",", "first_stats", ")", ":", "\n", "\t\t", "return", "self", ".", "Extractivector", "(", "zeroth_stats", ",", "first_stats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.Extractivector": [[98, 115], ["torch.eye", "torch.zeros", "torch.sum", "torch.sum", "torch.inverse", "torch.matmul", "torch.matmul", "zeroth_stats.view", "torch.matmul", "torch.matmul", "first_stats.view", "torch.matmul", "ivector_extract.ivectorExtractor.extractor_matrix.transpose", "ivector_extract.ivectorExtractor.extractor_matrix.transpose"], "methods", ["None"], ["", "def", "Extractivector", "(", "self", ",", "zeroth_stats", ",", "first_stats", ")", ":", "\n", "\t\t", "L", "=", "torch", ".", "eye", "(", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "\n", "linear", "=", "torch", ".", "zeros", "(", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# for i in range(self.num_gaussian):", "\n", "# \tL += zeroth_stats[i]*torch.matmul(torch.matmul(self.extractor_matrix[i].t(), self.sigma_inv[i]), self.extractor_matrix[i])", "\n", "# \tlinear += torch.matmul(torch.matmul(self.extractor_matrix[i].t(), self.sigma_inv[i]), first_stats[i])", "\n", "\n", "L", "+=", "torch", ".", "sum", "(", "zeroth_stats", ".", "view", "(", "self", ".", "num_gaussian", ",", "1", ",", "1", ")", "*", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "extractor_matrix", ".", "transpose", "(", "1", ",", "2", ")", ",", "self", ".", "sigma_inv", ")", ",", "self", ".", "extractor_matrix", ")", ",", "dim", "=", "0", ")", "\n", "linear", "+=", "torch", ".", "sum", "(", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "extractor_matrix", ".", "transpose", "(", "1", ",", "2", ")", ",", "self", ".", "sigma_inv", ")", ",", "first_stats", ".", "view", "(", "self", ".", "num_gaussian", ",", "self", ".", "dim", ",", "1", ")", ")", ",", "dim", "=", "(", "0", ",", "2", ")", ")", "\n", "linear", "[", "0", "]", "+=", "self", ".", "offset", "\n", "L_inv", "=", "torch", ".", "inverse", "(", "L", ")", "\n", "\n", "ivector", "=", "torch", ".", "matmul", "(", "L_inv", ",", "linear", ")", "\n", "ivector", "[", "0", "]", "-=", "self", ".", "offset", "\n", "\n", "return", "ivector", ",", "L_inv", ",", "linear", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.LengthNormalization": [[116, 126], ["torch.norm().item", "print", "exit", "torch.norm"], "methods", ["None"], ["", "def", "LengthNormalization", "(", "self", ",", "ivector", ",", "expected_length", ")", ":", "\n", "# input_norm = torch.norm(ivector)", "\n", "\t\t", "input_norm", "=", "torch", ".", "norm", "(", "ivector", ")", ".", "item", "(", ")", "\n", "if", "input_norm", "==", "0", ":", "\n", "\t\t\t", "print", "(", "'Zero ivector!'", ")", "\n", "exit", "(", "0", ")", "\n", "", "radio", "=", "expected_length", "/", "input_norm", "\n", "ivector", "=", "ivector", "*", "radio", "\n", "\n", "return", "ivector", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.LengthNormalization_kaldi": [[128, 140], ["torch.norm().item", "print", "exit", "ivector.size", "torch.sqrt", "torch.norm", "torch.tensor"], "methods", ["None"], ["", "def", "LengthNormalization_kaldi", "(", "self", ",", "ivector", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "# input_norm = torch.norm(ivector)", "\n", "\t\t", "input_norm", "=", "torch", ".", "norm", "(", "ivector", ")", ".", "item", "(", ")", "\n", "if", "input_norm", "==", "0", ":", "\n", "\t\t\t", "print", "(", "'Zero ivector!'", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "vec_dim", "=", "ivector", ".", "size", "(", ")", "[", "0", "]", "\n", "radio", "=", "torch", ".", "sqrt", "(", "torch", ".", "tensor", "(", "vec_dim", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "self", ".", "device", ")", ")", "/", "input_norm", "\n", "ivector", "=", "ivector", "*", "radio", "\n", "\n", "return", "ivector", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.SubtractGlobalMean": [[141, 144], ["None"], "methods", ["None"], ["", "def", "SubtractGlobalMean", "(", "self", ",", "ivector", ",", "mean", ")", ":", "\n", "\t\t", "ivector", "=", "ivector", "-", "mean", "\n", "return", "ivector", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.DRV_L_inv": [[145, 164], ["torch.matmul", "range", "torch.cat", "torch.matmul", "torch.matmul().view", "torch.diag", "torch.matmul", "torch.cat.append", "torch.matmul", "torch.matmul().view.squeeze", "torch.matmul", "torch.matmul.view", "ivector_extract.ivectorExtractor.T.t", "torch.matmul", "torch.diag", "torch.ones"], "methods", ["None"], ["", "def", "DRV_L_inv", "(", "self", ",", "Ni_drv", ",", "L_inv", ")", ":", "\n", "# T = self.extractor_matrix.view(-1, self.ivector_dim) # CF*D", "\n", "# sigma_inv = torch.zeros(self.num_gaussian*self.dim, self.num_gaussian*self.dim, device=self.device)", "\n", "# for i in range(self.num_gaussian):", "\n", "# \tsigma_inv[i*self.dim:(i+1)*self.dim][i*self.dim:(i+1)*self.dim] = self.sigma_inv[i]", "\n", "\n", "\t\t", "const_left", "=", "-", "1", "*", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "L_inv", ",", "self", ".", "T", ".", "t", "(", ")", ")", ",", "self", ".", "big_sigma_inv", ")", "# D*CF", "\n", "const_right", "=", "torch", ".", "matmul", "(", "self", ".", "T", ",", "L_inv", ")", "# CF*D", "\n", "\n", "L_inv_drv", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t", "diag_elements", "=", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "Ni_drv", "[", "i", "]", ")", ",", "torch", ".", "ones", "(", "self", ".", "num_gaussian", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", ")", ".", "view", "(", "1", ",", "-", "1", ")", "# 1*CF", "\n", "diag_matrix", "=", "torch", ".", "diag", "(", "diag_elements", ".", "squeeze", "(", "0", ")", ")", "# CF*CF", "\n", "rst", "=", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "const_left", ",", "diag_matrix", ")", ",", "const_right", ")", "\n", "L_inv_drv", ".", "append", "(", "rst", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "L_inv_drv", "=", "torch", ".", "cat", "(", "L_inv_drv", ",", "0", ")", "\n", "\n", "return", "L_inv_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.L_inv": [[165, 182], ["post_seq.t.t.t", "torch.zeros", "range", "torch.diag", "torch.matmul", "torch.inverse", "len", "torch.matmul().view", "torch.matmul", "torch.matmul", "torch.eye", "torch.matmul", "ivector_extract.ivectorExtractor.T.t", "torch.diag", "torch.ones"], "methods", ["None"], ["", "def", "L_inv", "(", "self", ",", "post_seq", ")", ":", "\n", "\t\t", "post_seq", "=", "post_seq", ".", "t", "(", ")", "# Ti*C", "\n", "# T = self.extractor_matrix.view(-1, self.ivector_dim) # CF*D", "\n", "# sigma_inv = torch.zeros(self.num_gaussian*self.dim, self.num_gaussian*self.dim, device=self.device)", "\n", "# for i in range(self.num_gaussian):", "\n", "# \tsigma_inv[i*self.dim:(i+1)*self.dim][i*self.dim:(i+1)*self.dim] = self.sigma_inv[i]", "\n", "\n", "Ni_vec", "=", "torch", ".", "zeros", "(", "self", ".", "num_gaussians", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "post_seq", ")", ")", ":", "\n", "\t\t\t", "Ni_vec", "+=", "post_seq", "[", "i", "]", "\n", "\n", "", "Ni", "=", "torch", ".", "diag", "(", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "Ni_vec", ")", ",", "torch", ".", "ones", "(", "self", ".", "num_gaussian", ",", "self", ".", "num_gaussian", ",", "device", "=", "self", ".", "device", ")", ")", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "rightside", "=", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "self", ".", "T", ".", "t", "(", ")", ",", "self", ".", "big_sigma_inv", ")", ",", "Ni", ")", ",", "self", ".", "T", ")", "\n", "\n", "L_inv", "=", "torch", ".", "inverse", "(", "torch", ".", "eye", "(", "self", ".", "ivector_dim", ",", "device", "=", "self", ".", "device", ")", "+", "rightside", ")", "\n", "\n", "return", "L_inv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.DRV_norm": [[183, 196], ["torch.norm", "torch.pow", "torch.zeros", "range", "vector.size", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "DRV_norm", "(", "self", ",", "expected_length", ",", "vector", ")", ":", "\n", "\t\t", "v_norm", "=", "torch", ".", "norm", "(", "vector", ")", "\n", "dim", "=", "vector", ".", "size", "(", ")", "[", "-", "1", "]", "\n", "vec_sq", "=", "torch", ".", "pow", "(", "vector", ",", "2", ")", "\n", "norm_drv", "=", "torch", ".", "zeros", "(", "dim", ",", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "common_vector", "=", "-", "1", "*", "vec_sq", "*", "expected_length", "*", "torch", ".", "pow", "(", "v_norm", ",", "-", "3", ")", "\n", "common_scalar", "=", "expected_length", "*", "torch", ".", "pow", "(", "v_norm", ",", "-", "1", ")", "\n", "for", "i", "in", "range", "(", "dim", ")", ":", "\n", "\t\t\t", "norm_drv", "[", ":", ",", "i", "]", "+=", "common_vector", "\n", "norm_drv", "[", "i", "]", "[", "i", "]", "+=", "common_scalar", "\n", "\n", "", "return", "norm_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._iv_plda.ivector_extract.ivectorExtractor.to": [[198, 207], ["ivector_extract.ivectorExtractor.extractor_matrix.to", "ivector_extract.ivectorExtractor.sigma_inv.to", "ivector_extract.ivectorExtractor.offset.to"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "\n", "\t\t", "if", "device", "==", "self", ".", "device", ":", "\n", "\t\t\t", "return", "\n", "\n", "", "self", ".", "device", "=", "device", "\n", "self", ".", "extractor_matrix", "=", "self", ".", "extractor_matrix", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "sigma_inv", "=", "self", ".", "sigma_inv", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "offset", "=", "self", ".", "offset", ".", "to", "(", "self", ".", "device", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.__init__": [[7, 24], ["isinstance", "xvector_extract.xvectorExtractor.extractor.eval().to", "torch.load", "model._xv_plda.xvecTDNN.xvecTDNN", "xvector_extract.xvectorExtractor.extractor.state_dict", "xvector_extract.xvectorExtractor.extractor.load_state_dict", "isinstance", "NotImplementedError", "xvector_extract.xvectorExtractor.extractor.eval", "torch.load.items"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["\t", "def", "__init__", "(", "self", ",", "xvnet_ckpt", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "\t\t", "self", ".", "device", "=", "device", "\n", "if", "isinstance", "(", "xvnet_ckpt", ",", "str", ")", ":", "# when xvnet_ckpt is the path of the ckpt", "\n", "\t\t\t", "ori_dict", "=", "torch", ".", "load", "(", "xvnet_ckpt", ")", "\n", "num_spks", "=", "ori_dict", "[", "'fc3.bias'", "]", ".", "shape", "[", "0", "]", "\n", "self", ".", "extractor", "=", "xvecTDNN", "(", "numSpkrs", "=", "num_spks", ")", "\n", "my_dict", "=", "self", ".", "extractor", ".", "state_dict", "(", ")", "\n", "update_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "ori_dict", ".", "items", "(", ")", "if", "k", "in", "my_dict", "}", "\n", "self", ".", "extractor", ".", "load_state_dict", "(", "update_dict", ")", "\n", "", "elif", "isinstance", "(", "xvnet_ckpt", ",", "xvecTDNN", ")", ":", "# when xvnet_ckpt is directly an instance of xvecTDNN", "\n", "\t\t\t", "self", ".", "extractor", "=", "xvnet_ckpt", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "NotImplementedError", "(", "'Invalid parameter, plz provide a ckpt or a xvecTDNN instance'", ")", "\n", "", "self", ".", "extractor", ".", "eval", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "self", ".", "xvector_dim", "=", "512", "## HARD CODE HERE", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.Extract": [[25, 30], ["xvector_extract.xvectorExtractor.extractor.embedding().squeeze", "xvector_extract.xvectorExtractor.extractor.embedding", "feat.unsqueeze().transpose", "feat.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding"], ["", "def", "Extract", "(", "self", ",", "feat", ")", ":", "\n", "\t\t", "'''\n\t\tfeat: num_frames, n_dim\n\t\t'''", "\n", "return", "self", ".", "extractor", ".", "embedding", "(", "feat", ".", "unsqueeze", "(", "0", ")", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.LengthNormalization": [[31, 41], ["torch.norm().item", "print", "exit", "torch.norm"], "methods", ["None"], ["", "def", "LengthNormalization", "(", "self", ",", "emb", ",", "expected_length", ")", ":", "\n", "# input_norm = torch.norm(emb)", "\n", "\t\t", "input_norm", "=", "torch", ".", "norm", "(", "emb", ")", ".", "item", "(", ")", "\n", "if", "input_norm", "==", "0", ":", "\n", "\t\t\t", "print", "(", "'Zero emb!'", ")", "\n", "exit", "(", "0", ")", "\n", "", "radio", "=", "expected_length", "/", "input_norm", "\n", "emb", "=", "emb", "*", "radio", "\n", "\n", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.SubtractGlobalMean": [[42, 45], ["None"], "methods", ["None"], ["", "def", "SubtractGlobalMean", "(", "self", ",", "emb", ",", "mean", ")", ":", "\n", "\t\t", "emb", "=", "emb", "-", "mean", "\n", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvector_extract.xvectorExtractor.to": [[46, 53], ["xvector_extract.xvectorExtractor.extractor.to"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "\n", "\t\t", "if", "device", "==", "self", ".", "device", ":", "\n", "\t\t\t", "return", "\n", "\n", "", "self", ".", "device", "=", "device", "\n", "self", ".", "extractor", ".", "to", "(", "self", ".", "device", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.__init__": [[17, 52], ["torch.ones", "torch.ones", "torch.ones", "open", "open.readline", "len", "range", "torch.tensor", "open.readline", "open.readline", "range", "torch.tensor", "range", "torch.tensor", "open.close", "open.readline.split", "float", "range", "transform_matrix.append", "open.readline", "open.readline.split", "float", "open.readline.split", "float"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "mdlfile", ",", "random", "=", "False", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "\n", "\t\t", "self", ".", "device", "=", "device", "\n", "\n", "if", "random", "==", "True", ":", "\n", "\t\t\t", "self", ".", "dim", "=", "600", "\n", "self", ".", "mean", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "transform", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "psi", "=", "torch", ".", "ones", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "\t\t\t", "rdfile", "=", "open", "(", "mdlfile", ",", "'r'", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "data", "=", "line", ".", "split", "(", ")", "[", "2", ":", "-", "1", "]", "\n", "self", ".", "dim", "=", "len", "(", "data", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "[", "i", "]", "=", "float", "(", "data", "[", "i", "]", ")", "\n", "", "self", ".", "mean", "=", "torch", ".", "tensor", "(", "data", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "transform_matrix", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "=", "line", ".", "split", "(", "' '", ")", "[", "2", ":", "-", "1", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t\t", "data", "[", "j", "]", "=", "float", "(", "data", "[", "j", "]", ")", "\n", "", "transform_matrix", ".", "append", "(", "data", ")", "\n", "line", "=", "rdfile", ".", "readline", "(", ")", "\n", "", "self", ".", "transform", "=", "torch", ".", "tensor", "(", "transform_matrix", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "data", "=", "line", ".", "split", "(", ")", "[", "1", ":", "-", "1", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "data", "[", "i", "]", "=", "float", "(", "data", "[", "i", "]", ")", "\n", "", "self", ".", "psi", "=", "torch", ".", "tensor", "(", "data", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "rdfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.ReadIvectors": [[53, 67], ["kaldi_io.read_vec_flt_scp", "print", "keys.append", "data.append", "mat.tolist"], "methods", ["None"], ["", "", "def", "ReadIvectors", "(", "self", ",", "ivectorfile", ")", ":", "\n", "\t\t", "keys", "=", "[", "]", "\n", "data", "=", "[", "]", "\n", "i", "=", "0", "\n", "for", "key", ",", "mat", "in", "kaldi_io", ".", "read_vec_flt_scp", "(", "ivectorfile", ")", ":", "\n", "# print(key)", "\n", "# print(mat)", "\n", "# print(len(mat.tolist()))", "\n", "# exit(0)", "\n", "\t\t\t", "i", "+=", "1", "\n", "keys", ".", "append", "(", "key", ")", "\n", "data", ".", "append", "(", "mat", ".", "tolist", "(", ")", ")", "\n", "", "print", "(", "'totally %d ivectors'", "%", "(", "i", ")", ")", "\n", "return", "keys", ",", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.Transform": [[69, 72], ["plda.PLDA.TransformIvector"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.TransformIvector"], ["", "def", "Transform", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "\n", "\t\t", "return", "self", ".", "TransformIvector", "(", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.TransformIvector": [[73, 90], ["torch.matmul", "torch.sqrt", "torch.norm", "plda.PLDA.GetNormalizaionFactor"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.GetNormalizaionFactor"], ["", "def", "TransformIvector", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "# print(self.transform, self.mean, ivector),", "\n", "\t\t", "trans_ivector", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ",", "ivector", "-", "self", ".", "mean", ")", "\n", "factor", "=", "1.0", "\n", "if", "simple_length_norm", "==", "True", ":", "\n", "\t\t\t", "factor", "=", "torch", ".", "sqrt", "(", "self", ".", "dim", ")", "/", "torch", ".", "norm", "(", "trans_ivector", ",", "2", ")", "\n", "", "elif", "normalize_length", "==", "True", ":", "\n", "\t\t\t", "factor", "=", "self", ".", "GetNormalizaionFactor", "(", "trans_ivector", ",", "num_examples", ")", "\n", "\n", "# print('original ivector is \\n')", "\n", "# print(trans_ivector)", "\n", "", "trans_ivector", "=", "trans_ivector", "*", "factor", "\n", "# print('factor is %f' %(factor))", "\n", "# print('transformed ivector is \\n')", "\n", "# print(trans_ivector)", "\n", "\n", "return", "trans_ivector", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.GetNormalizaionFactor": [[92, 98], ["torch.pow", "torch.sqrt", "torch.dot"], "methods", ["None"], ["", "def", "GetNormalizaionFactor", "(", "self", ",", "trans_ivector", ",", "num_examples", ")", ":", "\n", "\t\t", "trans_ivector_sq", "=", "torch", ".", "pow", "(", "trans_ivector", ",", "2", ")", "\n", "inv_covar", "=", "1.0", "/", "(", "self", ".", "psi", "+", "1.0", "/", "num_examples", ")", "\n", "factor", "=", "torch", ".", "sqrt", "(", "self", ".", "dim", "/", "torch", ".", "dot", "(", "inv_covar", ",", "trans_ivector_sq", ")", ")", "\n", "\n", "return", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.ComputeScores_loop": [[99, 138], ["torch.zeros", "torch.zeros", "range", "torch.sum", "torch.pow", "torch.pow", "torch.sum", "torch.log", "torch.log", "torch.dot", "torch.dot", "torch.log", "torch.log", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "ComputeScores_loop", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "# trans_trainivector = self.TransformIvector(trainivector, num_examples, simple_length_norm, normalize_length)", "\n", "# trans_testivector = self.TransformIvector(testivector, 1, simple_length_norm, normalize_length)", "\n", "\n", "#### work out loglike_given_class", "\n", "# mean = torch.zeros(self.dim) ", "\n", "# variance = torch.zeros(self.dim)", "\n", "\t\t", "mean", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "variance", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# debug", "\n", "# print(self.dim),", "\n", "# print(mean.size())", "\n", "# print(variance.size())", "\n", "# print(self.psi.size())", "\n", "# print(trans_trainivector.size())  ", "\n", "# print(trans_testivector.size())    ", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t", "mean", "[", "i", "]", "=", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "*", "trans_trainivector", "[", "i", "]", "\n", "variance", "[", "i", "]", "=", "1.0", "+", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "\n", "\n", "", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "\n", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", "-", "mean", ",", "2", ")", "\n", "variance", "=", "1.0", "/", "variance", "\n", "\n", "loglike_given_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "\n", "\n", "### work out loglike_without_class", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", ",", "2", ")", "\n", "variance", "=", "self", ".", "psi", "+", "1.0", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "\n", "variance", "=", "1.0", "/", "variance", "\n", "loglike_without_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "\n", "\n", "loglike_ratio", "=", "loglike_given_class", "-", "loglike_without_class", "\n", "\n", "return", "loglike_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.ComputeScores": [[140, 191], ["torch.zeros", "torch.zeros", "torch.sum", "torch.pow", "torch.pow", "torch.sum", "torch.log", "torch.log", "torch.sum", "torch.dot", "torch.log", "torch.log", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "ComputeScores", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "# trans_trainivector = self.TransformIvector(trainivector, num_examples, simple_length_norm, normalize_length)", "\n", "# trans_testivector = self.TransformIvector(testivector, 1, simple_length_norm, normalize_length)", "\n", "\n", "#### work out loglike_given_class", "\n", "# mean = torch.zeros(self.dim)", "\n", "# variance = torch.zeros(self.dim)", "\n", "# mean = torch.zeros(self.dim, device=self.device)", "\n", "# variance = torch.zeros(self.dim, device=self.device)", "\n", "\t\t", "n_train_ivectors", "=", "trans_trainivector", ".", "shape", "[", "0", "]", "\n", "assert", "num_examples", "==", "1", "\n", "mean", "=", "torch", ".", "zeros", "(", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "variance", "=", "torch", ".", "zeros", "(", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# debug", "\n", "# print(self.dim),  ", "\n", "# print(mean.size()) ", "\n", "# print(variance.size()) ", "\n", "# print(self.psi.size()) ", "\n", "# print(trans_trainivector.size())  ", "\n", "# print(trans_testivector.size())    ", "\n", "\n", "# for i in range(self.dim):", "\n", "# \tmean[i] = num_examples*self.psi[i]/(num_examples*self.psi[i]+1.0)*trans_trainivector[i]", "\n", "# \tvariance[i] = 1.0+self.psi[i]/(num_examples*self.psi[i]+1.0)", "\n", "# for i in range(self.dim):", "\n", "# \tmean[i] = num_examples*self.psi[i]/(num_examples*self.psi[i]+1.0)*trans_trainivector[i]", "\n", "# \tvariance[i] = 1.0+self.psi[i]/(num_examples*self.psi[i]+1.0)", "\n", "mean", "=", "num_examples", "*", "self", ".", "psi", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1.0", ")", "*", "trans_trainivector", "# (n, dim)", "\n", "variance", "=", "(", "1.0", "+", "self", ".", "psi", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1.0", ")", ")", ".", "expand", "(", "n_train_ivectors", ",", "self", ".", "dim", ")", "# (n, dim)", "\n", "# print(mean.shape, variance.shape)", "\n", "\n", "# logdet = torch.sum(torch.log(variance)) ", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ",", "dim", "=", "1", ")", "# (n, ) ", "\n", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", "-", "mean", ",", "2", ")", "# (n, dim)", "\n", "variance", "=", "1.0", "/", "variance", "# (n, dim)", "\n", "\n", "# loglike_given_class = -0.5*(logdet + torch.log(2*torch.tensor(3.1415926, device=self.device))*self.dim + torch.dot(sqdiff, variance))", "\n", "loglike_given_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "sum", "(", "sqdiff", "*", "variance", ",", "axis", "=", "1", ")", ")", "# (n, )", "\n", "\n", "### work out loglike_without_class", "\n", "sqdiff", "=", "torch", ".", "pow", "(", "trans_testivector", ",", "2", ")", "# (dim, )", "\n", "variance", "=", "self", ".", "psi", "+", "1.0", "# (dim, )", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "variance", ")", ")", "# scalar", "\n", "variance", "=", "1.0", "/", "variance", "# (dim, )", "\n", "loglike_without_class", "=", "-", "0.5", "*", "(", "logdet", "+", "torch", ".", "log", "(", "2", "*", "torch", ".", "tensor", "(", "3.1415926", ",", "device", "=", "self", ".", "device", ")", ")", "*", "self", ".", "dim", "+", "torch", ".", "dot", "(", "sqdiff", ",", "variance", ")", ")", "# scalar", "\n", "\n", "loglike_ratio", "=", "loglike_given_class", "-", "loglike_without_class", "# (n,)", "\n", "\n", "return", "loglike_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.DRV_TransformIvector": [[192, 214], ["torch.matmul", "plda.PLDA.GetNormalizaionFactor", "torch.zeros", "torch.pow", "torch.matmul", "range", "torch.matmul", "plda.PLDA.transform.t", "torch.diag", "plda.PLDA.transform.t", "torch.pow"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.GetNormalizaionFactor"], ["", "def", "DRV_TransformIvector", "(", "self", ",", "ivector", ",", "num_examples", ",", "simple_length_norm", ",", "normalize_length", ")", ":", "\n", "############ Currently we only consider simple_length_norm = False situation.", "\n", "\t\t", "if", "normalize_length", "==", "True", ":", "\n", "\t\t\t", "trans_ivector", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ",", "ivector", "-", "self", ".", "mean", ")", "\n", "factor", "=", "1.0", "\n", "factor", "=", "self", ".", "GetNormalizaionFactor", "(", "trans_ivector", ",", "num_examples", ")", "\n", "\n", "norm_drv", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ",", "self", ".", "dim", ",", "device", "=", "self", ".", "device", ")", "\n", "trans_ivector_sq", "=", "torch", ".", "pow", "(", "trans_ivector", ",", "2", ")", "\n", "\n", "common_vector", "=", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "num_examples", "/", "(", "num_examples", "*", "self", ".", "psi", "+", "1", ")", ")", ",", "-", "1", "*", "trans_ivector_sq", "*", "torch", ".", "pow", "(", "factor", ",", "3", ")", "/", "self", ".", "dim", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t\t", "norm_drv", "[", ":", ",", "i", "]", "+=", "common_vector", "\n", "norm_drv", "[", "i", "]", "[", "i", "]", "+=", "factor", "\n", "\n", "", "transform_drv", "=", "torch", ".", "matmul", "(", "self", ".", "transform", ".", "t", "(", ")", ",", "norm_drv", ")", "\n", "", "else", ":", "\n", "\t\t\t", "transform_drv", "=", "self", ".", "transform", ".", "t", "(", ")", "\n", "\n", "", "return", "transform_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.DRV_Scores": [[215, 229], ["torch.zeros", "torch.zeros", "range", "torch.matmul", "torch.matmul", "torch.diag", "torch.diag"], "methods", ["None"], ["", "def", "DRV_Scores", "(", "self", ",", "trans_trainivector", ",", "num_examples", ",", "trans_testivector", ")", ":", "\n", "\t\t", "mean", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "v1", "=", "torch", ".", "zeros", "(", "self", ".", "dim", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "\t\t\t", "mean", "[", "i", "]", "=", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "*", "trans_trainivector", "[", "i", "]", "\n", "v1", "[", "i", "]", "=", "1.0", "+", "self", ".", "psi", "[", "i", "]", "/", "(", "num_examples", "*", "self", ".", "psi", "[", "i", "]", "+", "1.0", ")", "\n", "\n", "", "v1", "=", "1.0", "/", "v1", "\n", "v2", "=", "1.0", "/", "(", "1", "+", "self", ".", "psi", ")", "\n", "\n", "score_drv", "=", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "trans_testivector", ")", ",", "v2", ")", "-", "torch", ".", "matmul", "(", "torch", ".", "diag", "(", "trans_testivector", "-", "mean", ")", ",", "v1", ")", "\n", "\n", "return", "score_drv", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to": [[230, 239], ["plda.PLDA.mean.to", "plda.PLDA.transform.to", "plda.PLDA.psi.to"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "\n", "\t\t", "if", "device", "==", "self", ".", "device", ":", "\n", "\t\t\t", "return", "\n", "\n", "", "self", ".", "device", "=", "device", "\n", "self", ".", "mean", "=", "self", ".", "mean", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "transform", "=", "self", ".", "transform", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "psi", "=", "self", ".", "psi", ".", "to", "(", "self", ".", "device", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.__init__": [[14, 45], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "numSpkrs", ",", "p_dropout", "=", "0.", ")", ":", "\n", "        ", "super", "(", "xvecTDNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "tdnn1", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "30", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "5", ",", "dilation", "=", "1", ")", "\n", "self", ".", "bn_tdnn1", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_tdnn1", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "tdnn2", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "512", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "5", ",", "dilation", "=", "2", ")", "\n", "self", ".", "bn_tdnn2", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_tdnn2", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "tdnn3", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "512", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "7", ",", "dilation", "=", "3", ")", "\n", "self", ".", "bn_tdnn3", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_tdnn3", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "tdnn4", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "512", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "1", ",", "dilation", "=", "1", ")", "\n", "self", ".", "bn_tdnn4", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_tdnn4", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "tdnn5", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "512", ",", "out_channels", "=", "1500", ",", "kernel_size", "=", "1", ",", "dilation", "=", "1", ")", "\n", "self", ".", "bn_tdnn5", "=", "nn", ".", "BatchNorm1d", "(", "1500", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_tdnn5", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "3000", ",", "512", ")", "\n", "self", ".", "bn_fc1", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_fc1", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "512", ",", "512", ")", "\n", "self", ".", "bn_fc2", "=", "nn", ".", "BatchNorm1d", "(", "512", ",", "momentum", "=", "0.1", ",", "affine", "=", "False", ")", "\n", "self", ".", "dropout_fc2", "=", "nn", ".", "Dropout", "(", "p", "=", "p_dropout", ")", "\n", "\n", "self", ".", "fc3", "=", "nn", ".", "Linear", "(", "512", ",", "numSpkrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding": [[46, 65], ["xvecTDNN.xvecTDNN.dropout_tdnn1", "xvecTDNN.xvecTDNN.dropout_tdnn2", "xvecTDNN.xvecTDNN.dropout_tdnn3", "xvecTDNN.xvecTDNN.dropout_tdnn4", "xvecTDNN.xvecTDNN.dropout_tdnn5", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "xvecTDNN.xvecTDNN.fc1", "xvecTDNN.xvecTDNN.bn_tdnn1", "xvecTDNN.xvecTDNN.bn_tdnn2", "xvecTDNN.xvecTDNN.bn_tdnn3", "xvecTDNN.xvecTDNN.bn_tdnn4", "xvecTDNN.xvecTDNN.bn_tdnn5", "xvecTDNN.xvecTDNN.size", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "xvecTDNN.xvecTDNN.mean", "xvecTDNN.xvecTDNN.std", "xvecTDNN.xvecTDNN.tdnn1", "xvecTDNN.xvecTDNN.tdnn2", "xvecTDNN.xvecTDNN.tdnn3", "xvecTDNN.xvecTDNN.tdnn4", "xvecTDNN.xvecTDNN.tdnn5"], "methods", ["None"], ["", "def", "embedding", "(", "self", ",", "x", ",", "eps", "=", "1e-5", ")", ":", "\n", "# Note: x must be (batch_size, feat_dim, chunk_len)", "\n", "\n", "        ", "x", "=", "self", ".", "dropout_tdnn1", "(", "self", ".", "bn_tdnn1", "(", "F", ".", "relu", "(", "self", ".", "tdnn1", "(", "x", ")", ")", ")", ")", "\n", "x", "=", "self", ".", "dropout_tdnn2", "(", "self", ".", "bn_tdnn2", "(", "F", ".", "relu", "(", "self", ".", "tdnn2", "(", "x", ")", ")", ")", ")", "\n", "x", "=", "self", ".", "dropout_tdnn3", "(", "self", ".", "bn_tdnn3", "(", "F", ".", "relu", "(", "self", ".", "tdnn3", "(", "x", ")", ")", ")", ")", "\n", "x", "=", "self", ".", "dropout_tdnn4", "(", "self", ".", "bn_tdnn4", "(", "F", ".", "relu", "(", "self", ".", "tdnn4", "(", "x", ")", ")", ")", ")", "\n", "x", "=", "self", ".", "dropout_tdnn5", "(", "self", ".", "bn_tdnn5", "(", "F", ".", "relu", "(", "self", ".", "tdnn5", "(", "x", ")", ")", ")", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# if True:", "\n", "            ", "shape", "=", "x", ".", "size", "(", ")", "\n", "noise", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "shape", ")", "\n", "torch", ".", "randn", "(", "shape", ",", "out", "=", "noise", ")", "\n", "x", "+=", "noise", "*", "eps", "\n", "\n", "", "stats", "=", "torch", ".", "cat", "(", "(", "x", ".", "mean", "(", "dim", "=", "2", ")", ",", "x", ".", "std", "(", "dim", "=", "2", ")", ")", ",", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "fc1", "(", "stats", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.forward": [[66, 74], ["xvecTDNN.xvecTDNN.embedding", "xvecTDNN.xvecTDNN.dropout_fc1", "xvecTDNN.xvecTDNN.dropout_fc2", "xvecTDNN.xvecTDNN.fc3", "xvecTDNN.xvecTDNN.bn_fc1", "xvecTDNN.xvecTDNN.bn_fc2", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "xvecTDNN.xvecTDNN.fc2"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.embedding"], ["", "def", "forward", "(", "self", ",", "x", ",", "eps", "=", "1e-5", ")", ":", "\n", "# Note: x must be (batch_size, feat_dim, chunk_len)", "\n", "\n", "        ", "x", "=", "self", ".", "embedding", "(", "x", ",", "eps", "=", "eps", ")", "\n", "x", "=", "self", ".", "dropout_fc1", "(", "self", ".", "bn_fc1", "(", "F", ".", "relu", "(", "x", ")", ")", ")", "\n", "x", "=", "self", ".", "dropout_fc2", "(", "self", ".", "bn_fc2", "(", "F", ".", "relu", "(", "self", ".", "fc2", "(", "x", ")", ")", ")", ")", "\n", "x", "=", "self", ".", "fc3", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score": [[75, 80], ["xvecTDNN.xvecTDNN.forward", "torch.nn.functional.softmax", "torch.nn.functional.softmax"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.forward"], ["", "def", "score", "(", "self", ",", "x", ",", "softmax", "=", "True", ")", ":", "\n", "        ", "x", "=", "self", ".", "forward", "(", "x", ")", "\n", "if", "softmax", ":", "\n", "            ", "x", "=", "F", ".", "softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision": [[81, 85], ["xvecTDNN.xvecTDNN.score", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.score"], ["", "def", "make_decision", "(", "self", ",", "x", ")", ":", "\n", "        ", "score", "=", "self", ".", "score", "(", "x", ",", "softmax", "=", "True", ")", "\n", "decision", "=", "torch", ".", "argmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "return", "decision", ",", "score", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess": [[10, 15], ["benign_xx.detach().cpu().numpy.detach().cpu().numpy", "benign_xx.detach().cpu().numpy.flatten", "benign_xx.detach().cpu().numpy.detach().cpu", "benign_xx.detach().cpu().numpy.max", "benign_xx.detach().cpu().numpy.detach"], "function", ["None"], ["def", "preprocess", "(", "benign_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "benign_xx", "=", "benign_xx", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "not", "LOWER", "<=", "benign_xx", ".", "max", "(", ")", "<=", "UPPER", ":", "\n", "        ", "benign_xx", "=", "benign_xx", "/", "(", "2", "**", "(", "bits", "-", "1", ")", ")", "\n", "", "return", "benign_xx", ".", "flatten", "(", ")", "# one channel", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Lp": [[16, 20], ["metric.preprocess", "metric.preprocess", "numpy.linalg.norm", "numpy.np.infty"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess"], ["", "def", "Lp", "(", "benign_xx", ",", "adver_xx", ",", "p", ",", "bits", "=", "16", ")", ":", "\n", "    ", "benign_xx", "=", "preprocess", "(", "benign_xx", ",", "bits", "=", "bits", ")", "\n", "adver_xx", "=", "preprocess", "(", "adver_xx", ",", "bits", "=", "bits", ")", "\n", "return", "LA", ".", "norm", "(", "adver_xx", "-", "benign_xx", ",", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L2": [[21, 23], ["metric.Lp"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Lp"], ["", "def", "L2", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "return", "Lp", "(", "benign_xx", ",", "adver_xx", ",", "2", ",", "bits", "=", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L0": [[24, 26], ["metric.Lp"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Lp"], ["", "def", "L0", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "return", "Lp", "(", "benign_xx", ",", "adver_xx", ",", "0", ",", "bits", "=", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L1": [[27, 29], ["metric.Lp"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Lp"], ["", "def", "L1", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "return", "Lp", "(", "benign_xx", ",", "adver_xx", ",", "1", ",", "bits", "=", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Linf": [[30, 32], ["metric.Lp"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Lp"], ["", "def", "Linf", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "return", "Lp", "(", "benign_xx", ",", "adver_xx", ",", "np", ".", "infty", ",", "bits", "=", "bits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.SNR": [[33, 43], ["metric.preprocess", "metric.preprocess", "numpy.sum", "numpy.sum", "numpy.log10"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess"], ["", "def", "SNR", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "benign_xx", "=", "preprocess", "(", "benign_xx", ",", "bits", "=", "bits", ")", "\n", "adver_xx", "=", "preprocess", "(", "adver_xx", ",", "bits", "=", "bits", ")", "\n", "noise", "=", "adver_xx", "-", "benign_xx", "\n", "power_noise", "=", "np", ".", "sum", "(", "noise", "**", "2", ")", "\n", "if", "power_noise", "<=", "0.", ":", "\n", "        ", "return", "np", ".", "infty", "\n", "", "power_benign", "=", "np", ".", "sum", "(", "benign_xx", "**", "2", ")", "\n", "snr", "=", "10", "*", "np", ".", "log10", "(", "power_benign", "/", "power_noise", ")", "\n", "return", "snr", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.PESQ": [[44, 49], ["metric.preprocess", "metric.preprocess", "pesq.pesq"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess"], ["", "def", "PESQ", "(", "benign_xx", ",", "adver_xx", ",", "bits", "=", "16", ")", ":", "\n", "    ", "benign_xx", "=", "preprocess", "(", "benign_xx", ",", "bits", "=", "bits", ")", "\n", "adver_xx", "=", "preprocess", "(", "adver_xx", ",", "bits", "=", "bits", ")", "\n", "pesq_value", "=", "pesq", "(", "16_000", ",", "benign_xx", ",", "adver_xx", ",", "'wb'", "if", "bits", "==", "16", "else", "'nb'", ")", "\n", "return", "pesq_value", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.STOI": [[50, 55], ["metric.preprocess", "metric.preprocess", "pystoi.stoi"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.preprocess"], ["", "def", "STOI", "(", "benign_xx", ",", "adver_xx", ",", "fs", "=", "16_000", ",", "bits", "=", "16", ")", ":", "\n", "    ", "benign_xx", "=", "preprocess", "(", "benign_xx", ",", "bits", "=", "bits", ")", "\n", "adver_xx", "=", "preprocess", "(", "adver_xx", ",", "bits", "=", "bits", ")", "\n", "d", "=", "stoi", "(", "benign_xx", ",", "adver_xx", ",", "fs", ",", "extended", "=", "False", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.get_all_metric": [[56, 64], ["metric.L2", "metric.L0", "metric.L1", "metric.Linf", "metric.SNR", "metric.PESQ", "metric.STOI"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L2", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L0", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.L1", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.Linf", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.SNR", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.PESQ", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.metric.metric.STOI"], ["", "def", "get_all_metric", "(", "benign_xx", ",", "adver_xx", ",", "fs", "=", "16_000", ",", "bits", "=", "16", ")", ":", "\n", "    ", "return", "[", "L2", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "L0", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "L1", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "Linf", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "SNR", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "PESQ", "(", "benign_xx", ",", "adver_xx", ",", "bits", ")", ",", "\n", "STOI", "(", "benign_xx", ",", "adver_xx", ",", "fs", ",", "bits", ")", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.BPDA.BPDA.__init__": [[9, 26], ["torch.Module.__init__", "BPDA.BPDA.get_diff_func", "inspect.getfullargspec", "inspect.getfullargspec", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.BPDA.BPDA.get_diff_func"], ["    ", "def", "__init__", "(", "self", ",", "ori_f", ",", "sub_f", ")", ":", "\n", "        ", "\"\"\"[summary]\n\n        Parameters\n        ----------\n        ori_f : [type]\n            Currently BPDA not supports ori_f with * and ** parameter;\n            Only support ori_f like defense/time_domain/QT_Non_Diff\n        sub_f : [type]\n            Should accept the same number of input and return the same number of outputs as ori_f\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "f", "=", "self", ".", "get_diff_func", "(", "ori_f", ",", "sub_f", ")", "\n", "ori_f_args", "=", "inspect", ".", "getfullargspec", "(", "ori_f", ")", ".", "args", "\n", "self", ".", "ori_f_defaults", "=", "inspect", ".", "getfullargspec", "(", "ori_f", ")", ".", "defaults", "# maybe None --> no default parameters", "\n", "self", ".", "ori_f_num_required", "=", "len", "(", "ori_f_args", ")", "-", "len", "(", "self", ".", "ori_f_defaults", ")", "if", "self", ".", "ori_f_defaults", "else", "len", "(", "ori_f_args", ")", "\n", "self", ".", "ori_f_option_parameters", "=", "ori_f_args", "[", "-", "len", "(", "self", ".", "ori_f_defaults", ")", ":", "]", "if", "self", ".", "ori_f_defaults", "else", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.BPDA.BPDA.get_diff_func": [[27, 54], ["torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "torch.enable_grad", "ori_f", "sub_f", "len", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "inputs_all.append", "isinstance", "len", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "tuple", "input_.detach().clone().requires_grad_.detach().clone().requires_grad_.detach().clone().requires_grad_", "inputs_need_grad.append", "input_.detach().clone().requires_grad_.detach().clone().requires_grad_.detach().clone", "len", "len", "input_.detach().clone().requires_grad_.detach().clone().requires_grad_.detach"], "methods", ["None"], ["", "def", "get_diff_func", "(", "self", ",", "ori_f", ",", "sub_f", ")", ":", "\n", "\n", "        ", "class", "differ_func", "(", "torch", ".", "autograd", ".", "Function", ")", ":", "\n", "\n", "            ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "*", "args", ")", ":", "\n", "                ", "ctx", ".", "args", "=", "args", "\n", "return", "ori_f", "(", "*", "args", ")", "\n", "\n", "", "@", "staticmethod", "\n", "@", "torch", ".", "enable_grad", "(", ")", "\n", "def", "backward", "(", "ctx", ",", "*", "grad_output", ")", ":", "\n", "                ", "inputs", "=", "ctx", ".", "args", "\n", "inputs_all", "=", "[", "]", "\n", "inputs_need_grad", "=", "[", "]", "\n", "for", "input_", "in", "inputs", ":", "\n", "                    ", "if", "torch", ".", "is_tensor", "(", "input_", ")", ":", "# TO DO: change to float or double tensor ", "\n", "                        ", "input_", "=", "input_", ".", "detach", "(", ")", ".", "clone", "(", ")", ".", "requires_grad_", "(", ")", "\n", "inputs_need_grad", ".", "append", "(", "input_", ")", "\n", "", "inputs_all", ".", "append", "(", "input_", ")", "\n", "", "outputs", "=", "sub_f", "(", "*", "inputs_all", ")", "\n", "num_output_ori", "=", "len", "(", "grad_output", ")", "\n", "num_output_sub", "=", "len", "(", "outputs", ")", "if", "isinstance", "(", "outputs", ",", "(", "tuple", ",", "list", ")", ")", "else", "1", "\n", "assert", "num_output_ori", "==", "num_output_sub", ",", "'The number of outputs of sub_f mismatches with ori_f'", "\n", "return", "torch", ".", "autograd", ".", "grad", "(", "outputs", ",", "inputs_need_grad", ",", "*", "grad_output", ")", "+", "tuple", "(", "[", "None", "]", "*", "(", "len", "(", "inputs_all", ")", "-", "len", "(", "inputs_need_grad", ")", ")", ")", "\n", "\n", "", "", "return", "differ_func", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.BPDA.BPDA.forward": [[55, 66], ["BPDA.BPDA.f.apply", "len", "list", "zip", "tuple", "list", "len", "kwargs.keys", "kwargs.keys", "tuple.append", "tuple.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "len", "(", "list", "(", "kwargs", ".", "keys", "(", ")", ")", ")", ">", "0", ":", "\n", "            ", "args", "=", "list", "(", "args", ")", "\n", "start", "=", "len", "(", "args", ")", "-", "self", ".", "ori_f_num_required", "\n", "for", "k", ",", "v", "in", "zip", "(", "self", ".", "ori_f_option_parameters", "[", "start", ":", "]", ",", "self", ".", "ori_f_defaults", "[", "start", ":", "]", ")", ":", "\n", "                ", "if", "k", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "                    ", "args", ".", "append", "(", "kwargs", "[", "k", "]", ")", "\n", "", "else", ":", "\n", "                    ", "args", ".", "append", "(", "v", ")", "\n", "", "", "args", "=", "tuple", "(", "args", ")", "\n", "", "return", "self", ".", "f", ".", "apply", "(", "*", "args", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.EOT.EOT.__init__": [[7, 15], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "loss", ",", "EOT_size", "=", "1", ",", "EOT_batch_size", "=", "1", ",", "use_grad", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "EOT_size", "=", "EOT_size", "\n", "self", ".", "EOT_batch_size", "=", "EOT_batch_size", "\n", "self", ".", "EOT_num_batches", "=", "self", ".", "EOT_size", "//", "self", ".", "EOT_batch_size", "\n", "self", ".", "use_grad", "=", "use_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.EOT.EOT.forward": [[16, 55], ["x_batch.size", "range", "x_batch.repeat", "y_batch.repeat", "EOT.EOT.model.make_decision", "EOT.EOT.loss", "decisions_EOT.view().detach().cpu().numpy.view().detach().cpu().numpy.view().detach().cpu().numpy", "range", "range", "x_batch.repeat.retain_grad", "EOT.EOT.backward", "scores_EOT.view().mean", "EOT.EOT.view().mean", "scores_EOT.view().mean", "EOT.EOT.view().mean", "list", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "x_batch.repeat.grad.view().mean", "x_batch.repeat.grad.zero_", "x_batch.repeat.grad.view().mean", "x_batch.repeat.grad.zero_", "decisions_EOT.view().detach().cpu().numpy.view().detach().cpu().numpy.view().detach().cpu", "scores_EOT.view", "EOT.EOT.view", "scores_EOT.view", "EOT.EOT.view", "x_batch.repeat.grad.view", "x_batch.repeat.grad.view", "decisions_EOT.view().detach().cpu().numpy.view().detach().cpu().numpy.view().detach", "decisions_EOT.view().detach().cpu().numpy.view().detach().cpu().numpy.view"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.xvecTDNN.xvecTDNN.make_decision"], ["", "def", "forward", "(", "self", ",", "x_batch", ",", "y_batch", ",", "EOT_num_batches", "=", "None", ",", "EOT_batch_size", "=", "None", ",", "use_grad", "=", "None", ")", ":", "\n", "        ", "EOT_num_batches", "=", "EOT_num_batches", "if", "EOT_num_batches", "else", "self", ".", "EOT_num_batches", "\n", "EOT_batch_size", "=", "EOT_batch_size", "if", "EOT_batch_size", "else", "self", ".", "EOT_batch_size", "\n", "use_grad", "=", "use_grad", "if", "use_grad", "else", "self", ".", "use_grad", "\n", "n_audios", ",", "n_channels", ",", "max_len", "=", "x_batch", ".", "size", "(", ")", "\n", "grad", "=", "None", "\n", "scores", "=", "None", "\n", "loss", "=", "0", "\n", "# decisions = [[]] * n_audios ## wrong, all element shares the same memory", "\n", "decisions", "=", "[", "[", "]", "for", "_", "in", "range", "(", "n_audios", ")", "]", "\n", "for", "EOT_index", "in", "range", "(", "EOT_num_batches", ")", ":", "\n", "            ", "x_batch_repeat", "=", "x_batch", ".", "repeat", "(", "EOT_batch_size", ",", "1", ",", "1", ")", "\n", "if", "use_grad", ":", "\n", "                ", "x_batch_repeat", ".", "retain_grad", "(", ")", "\n", "", "y_batch_repeat", "=", "y_batch", ".", "repeat", "(", "EOT_batch_size", ")", "\n", "# scores_EOT = self.model(x_batch_repeat) # scores or logits. Just Name it scores. (batch_size, n_spks)", "\n", "decisions_EOT", ",", "scores_EOT", "=", "self", ".", "model", ".", "make_decision", "(", "x_batch_repeat", ")", "# scores or logits. Just Name it scores. (batch_size, n_spks)", "\n", "loss_EOT", "=", "self", ".", "loss", "(", "scores_EOT", ",", "y_batch_repeat", ")", "\n", "if", "use_grad", ":", "\n", "                ", "loss_EOT", ".", "backward", "(", "torch", ".", "ones_like", "(", "loss_EOT", ")", ")", "\n", "\n", "", "if", "EOT_index", "==", "0", ":", "\n", "                ", "scores", "=", "scores_EOT", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ",", "scores_EOT", ".", "shape", "[", "1", "]", ")", ".", "mean", "(", "0", ")", "\n", "loss", "=", "loss_EOT", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ")", ".", "mean", "(", "0", ")", "\n", "if", "use_grad", ":", "\n", "                    ", "grad", "=", "x_batch_repeat", ".", "grad", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ",", "n_channels", ",", "max_len", ")", ".", "mean", "(", "0", ")", "\n", "x_batch_repeat", ".", "grad", ".", "zero_", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "scores", ".", "data", "+=", "scores_EOT", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ",", "scores", ".", "shape", "[", "1", "]", ")", ".", "mean", "(", "0", ")", "\n", "loss", ".", "data", "+=", "loss_EOT", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ")", ".", "mean", "(", "0", ")", "\n", "if", "use_grad", ":", "\n", "                    ", "grad", ".", "data", "+=", "x_batch_repeat", ".", "grad", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ",", "n_channels", ",", "max_len", ")", ".", "mean", "(", "0", ")", "\n", "x_batch_repeat", ".", "grad", ".", "zero_", "(", ")", "\n", "\n", "", "", "decisions_EOT", "=", "decisions_EOT", ".", "view", "(", "EOT_batch_size", ",", "-", "1", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "ii", "in", "range", "(", "n_audios", ")", ":", "\n", "                ", "decisions", "[", "ii", "]", "+=", "list", "(", "decisions_EOT", "[", ":", ",", "ii", "]", ")", "\n", "\n", "", "", "return", "scores", ",", "loss", ",", "grad", ",", "decisions", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__": [[8, 14], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.__init__"], ["    ", "def", "__init__", "(", "self", ",", "samples_per_draw", ",", "samples_per_draw_batch", ",", "sigma", ",", "EOT_wrapper", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "samples_per_draw", "=", "samples_per_draw", "\n", "self", ".", "samples_per_draw_batch_size", "=", "samples_per_draw_batch", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "EOT_wrapper", "=", "EOT_wrapper", "# EOT wraps the model", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.adaptive_attack.NES.NES.forward": [[15, 57], ["range", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "eval_input.view.view.view", "enumerate", "NES.NES.EOT_wrapper", "int", "loss.view.view.view", "scores.view.view.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "x.unsqueeze", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "loss.view.view.mean", "attack.utils.resolve_prediction().reshape", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "loss.view.view.mean", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros_like().unsqueeze", "torch.zeros_like().unsqueeze", "torch.zeros_like().unsqueeze", "torch.zeros_like().unsqueeze", "loss.view.view.unsqueeze().unsqueeze", "attack.utils.resolve_prediction", "loss.view.view.unsqueeze().unsqueeze", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "loss.view.view.unsqueeze", "loss.view.view.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.attack.utils.resolve_prediction"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "n_audios", ",", "n_channels", ",", "N", "=", "x", ".", "shape", "\n", "num_batches", "=", "self", ".", "samples_per_draw", "//", "self", ".", "samples_per_draw_batch_size", "\n", "for", "i", "in", "range", "(", "num_batches", ")", ":", "\n", "            ", "noise", "=", "torch", ".", "randn", "(", "[", "n_audios", ",", "self", ".", "samples_per_draw_batch_size", "//", "2", ",", "n_channels", ",", "N", "]", ",", "device", "=", "x", ".", "device", ")", "\n", "# noise = (torch.rand([n_audios, self.samples_per_draw_batch_size // 2, n_channels, N], device=x.device) * 2 - 1).sign()", "\n", "noise", "=", "torch", ".", "cat", "(", "(", "noise", ",", "-", "noise", ")", ",", "1", ")", "\n", "if", "i", "==", "0", ":", "\n", "                ", "noise", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros_like", "(", "x", ",", "device", "=", "x", ".", "device", ")", ".", "unsqueeze", "(", "1", ")", ",", "noise", ")", ",", "1", ")", "\n", "", "eval_input", "=", "noise", "*", "self", ".", "sigma", "+", "x", ".", "unsqueeze", "(", "1", ")", "\n", "eval_input", "=", "eval_input", ".", "view", "(", "-", "1", ",", "n_channels", ",", "N", ")", "# (n_audios*samples_per_draw_batch_size, n_channels, N)", "\n", "eval_y", "=", "None", "\n", "for", "jj", ",", "y_", "in", "enumerate", "(", "y", ")", ":", "\n", "                ", "tmp", "=", "torch", ".", "tensor", "(", "[", "y_", "]", "*", "(", "self", ".", "samples_per_draw_batch_size", "+", "1", "if", "i", "==", "0", "else", "self", ".", "samples_per_draw_batch_size", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "x", ".", "device", ")", "\n", "if", "jj", "==", "0", ":", "\n", "                    ", "eval_y", "=", "tmp", "\n", "", "else", ":", "\n", "                    ", "eval_y", "=", "torch", ".", "cat", "(", "(", "eval_y", ",", "tmp", ")", ")", "\n", "# scores, loss, _ = EOT_wrapper(eval_input, eval_y, EOT_num_batches, self.EOT_batch_size, use_grad=False)", "\n", "", "", "scores", ",", "loss", ",", "_", ",", "decisions", "=", "self", ".", "EOT_wrapper", "(", "eval_input", ",", "eval_y", ")", "\n", "EOT_num_batches", "=", "int", "(", "self", ".", "EOT_wrapper", ".", "EOT_size", "//", "self", ".", "EOT_wrapper", ".", "EOT_batch_size", ")", "\n", "loss", ".", "data", "/=", "EOT_num_batches", "# (n_audios*samples_per_draw_batch_size,)", "\n", "scores", ".", "data", "/=", "EOT_num_batches", "\n", "\n", "loss", "=", "loss", ".", "view", "(", "n_audios", ",", "-", "1", ")", "\n", "scores", "=", "scores", ".", "view", "(", "n_audios", ",", "-", "1", ",", "scores", ".", "shape", "[", "1", "]", ")", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                ", "adver_loss", "=", "loss", "[", "...", ",", "0", "]", "# (n_audios, )", "\n", "loss", "=", "loss", "[", "...", ",", "1", ":", "]", "# (n_audios, samples_batch)", "\n", "adver_score", "=", "scores", "[", ":", ",", "0", ",", ":", "]", "# (n_audios, n_spks)", "\n", "noise", "=", "noise", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "# (n_audios, samples_batch, n_channels, N)", "\n", "grad", "=", "torch", ".", "mean", "(", "loss", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "*", "noise", ",", "1", ")", "\n", "mean_loss", "=", "loss", ".", "mean", "(", "1", ")", "\n", "predicts", "=", "resolve_prediction", "(", "decisions", ")", ".", "reshape", "(", "n_audios", ",", "-", "1", ")", "# (n_audios, samples_batch)", "\n", "predict", "=", "predicts", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "                ", "grad", "+=", "torch", ".", "mean", "(", "loss", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "*", "noise", ",", "1", ")", "\n", "mean_loss", "+=", "loss", ".", "mean", "(", "1", ")", "\n", "", "", "grad", "=", "grad", "/", "self", ".", "sigma", "/", "num_batches", "\n", "mean_loss", "=", "mean_loss", "/", "num_batches", "\n", "return", "mean_loss", ",", "grad", ",", "adver_loss", ",", "adver_score", ",", "predict", "", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.frequency_domain.DS": [[8, 32], ["int", "torchaudio.transforms.Resample().to", "torchaudio.transforms.Resample().to", "torchaudio.transforms.Resample().to.", "torchaudio.transforms.Resample().to.", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "len", "audio.squeeze.unsqueeze", "new_audio[].view", "up_sampler.view", "len", "torchaudio.transforms.Resample", "torchaudio.transforms.Resample", "len", "audio.squeeze.squeeze", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["def", "DS", "(", "audio", ",", "param", "=", "0.5", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "ori_shape", "=", "audio", ".", "shape", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "1", ":", "\n", "        ", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "3", ":", "\n", "        ", "audio", "=", "audio", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "down_ratio", "=", "param", "\n", "new_freq", "=", "int", "(", "fs", "*", "down_ratio", ")", "\n", "resampler", "=", "torchaudio", ".", "transforms", ".", "Resample", "(", "orig_freq", "=", "fs", ",", "new_freq", "=", "new_freq", ",", "resampling_method", "=", "'sinc_interpolation'", ")", ".", "to", "(", "audio", ".", "device", ")", "\n", "up_sampler", "=", "torchaudio", ".", "transforms", ".", "Resample", "(", "orig_freq", "=", "new_freq", ",", "new_freq", "=", "fs", ",", "resampling_method", "=", "'sinc_interpolation'", ")", ".", "to", "(", "audio", ".", "device", ")", "\n", "down_audio", "=", "resampler", "(", "audio", ")", "\n", "new_audio", "=", "up_sampler", "(", "down_audio", ")", "\n", "if", "same_size", ":", "## sometimes the returned audio may have longer size (usually 1 point)", "\n", "        ", "return", "new_audio", "[", "...", ",", ":", "audio", ".", "shape", "[", "1", "]", "]", ".", "view", "(", "ori_shape", ")", "\n", "", "else", ":", "\n", "        ", "return", "new_audio", ".", "view", "(", "ori_shape", "[", ":", "-", "1", "]", "+", "new_audio", ".", "shape", "[", "-", "1", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.frequency_domain.LPF": [[33, 71], ["scipy.signal.buttord", "scipy.signal.butter", "new.squeeze.T.to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "torch.cat.clamp", "torch.cat.to().view", "torch.is_tensor", "torch.is_tensor", "len", "new.squeeze.unsqueeze", "len", "torch_lfilter.lfilter", "torch.cat", "torch.cat", "torch.cat.to", "len", "new.squeeze.squeeze", "NotImplementedError", "new.squeeze.max", "new.squeeze.min"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "", "def", "LPF", "(", "new", ",", "fs", "=", "16000", ",", "wp", "=", "4000", ",", "param", "=", "8000", ",", "gpass", "=", "3", ",", "gstop", "=", "40", ",", "same_size", "=", "True", ",", "bits", "=", "16", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "new", ")", "==", "True", "\n", "ori_shape", "=", "new", ".", "shape", "\n", "if", "len", "(", "new", ".", "shape", ")", "==", "1", ":", "\n", "        ", "new", "=", "new", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "3", ":", "\n", "        ", "new", "=", "new", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "if", "0.9", "*", "new", ".", "max", "(", ")", "<=", "1", "and", "0.9", "*", "new", ".", "min", "(", ")", ">=", "-", "1", ":", "\n", "        ", "clip_max", "=", "1", "\n", "clip_min", "=", "-", "1", "\n", "", "else", ":", "\n", "        ", "clip_max", "=", "2", "**", "(", "bits", "-", "1", ")", "-", "1", "\n", "clip_min", "=", "-", "2", "**", "(", "bits", "-", "1", ")", "\n", "\n", "", "ws", "=", "param", "\n", "wp", "=", "2", "*", "wp", "/", "fs", "\n", "ws", "=", "2", "*", "ws", "/", "fs", "\n", "N", ",", "Wn", "=", "signal", ".", "buttord", "(", "wp", ",", "ws", ",", "gpass", ",", "gstop", ",", "analog", "=", "False", ",", "fs", "=", "None", ")", "\n", "b", ",", "a", "=", "signal", ".", "butter", "(", "N", ",", "Wn", ",", "btype", "=", "'low'", ",", "analog", "=", "False", ",", "output", "=", "'ba'", ")", "\n", "\n", "audio", "=", "new", ".", "T", ".", "to", "(", "\"cpu\"", ")", "# torch_lfilter only supports CPU tensor speed up", "\n", "a", "=", "torch", ".", "tensor", "(", "a", ",", "device", "=", "\"cpu\"", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "b", "=", "torch", ".", "tensor", "(", "b", ",", "device", "=", "\"cpu\"", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "new_audio", "=", "None", "\n", "for", "ppp", "in", "range", "(", "audio", ".", "shape", "[", "1", "]", ")", ":", "# torch_lfilter will give weird results for batch samples when using cpu tensor speed up; so we use naive loop here", "\n", "        ", "new_audio_", "=", "lfilter", "(", "b", ",", "a", ",", "audio", "[", ":", ",", "ppp", ":", "ppp", "+", "1", "]", ")", ".", "T", "\n", "if", "new_audio", "is", "None", ":", "\n", "            ", "new_audio", "=", "new_audio_", "\n", "", "else", ":", "\n", "            ", "new_audio", "=", "torch", ".", "cat", "(", "(", "new_audio", ",", "new_audio_", ")", ",", "dim", "=", "0", ")", "\n", "", "", "new_audio", "=", "new_audio", ".", "clamp", "(", "clip_min", ",", "clip_max", ")", "\n", "return", "new_audio", ".", "to", "(", "new", ".", "device", ")", ".", "view", "(", "ori_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.frequency_domain.BPF": [[72, 113], ["scipy.signal.buttord", "scipy.signal.butter", "new.squeeze.T.to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "range", "torch.cat.clamp", "torch.cat.to().view", "torch.is_tensor", "torch.is_tensor", "len", "new.squeeze.unsqueeze", "len", "torch_lfilter.lfilter", "torch.cat", "torch.cat", "torch.cat.to", "len", "new.squeeze.squeeze", "NotImplementedError", "new.squeeze.max", "new.squeeze.min"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR._xv_plda.plda.PLDA.to"], ["", "def", "BPF", "(", "new", ",", "fs", "=", "16000", ",", "wp", "=", "[", "300", ",", "4000", "]", ",", "param", "=", "[", "50", ",", "5000", "]", ",", "gpass", "=", "3", ",", "gstop", "=", "40", ",", "same_size", "=", "True", ",", "bits", "=", "16", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "new", ")", "==", "True", "\n", "ori_shape", "=", "new", ".", "shape", "\n", "if", "len", "(", "new", ".", "shape", ")", "==", "1", ":", "\n", "        ", "new", "=", "new", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "3", ":", "\n", "        ", "new", "=", "new", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "if", "0.9", "*", "new", ".", "max", "(", ")", "<=", "1", "and", "0.9", "*", "new", ".", "min", "(", ")", ">=", "-", "1", ":", "\n", "        ", "clip_max", "=", "1", "\n", "clip_min", "=", "-", "1", "\n", "# print(clip_max, clip_min)", "\n", "", "else", ":", "\n", "        ", "clip_max", "=", "2", "**", "(", "bits", "-", "1", ")", "-", "1", "\n", "clip_min", "=", "-", "2", "**", "(", "bits", "-", "1", ")", "\n", "\n", "", "ws", "=", "param", "\n", "wp", "=", "[", "2", "*", "wp_", "/", "fs", "for", "wp_", "in", "wp", "]", "\n", "ws", "=", "[", "2", "*", "ws_", "/", "fs", "for", "ws_", "in", "ws", "]", "\n", "N", ",", "Wn", "=", "signal", ".", "buttord", "(", "wp", ",", "ws", ",", "gpass", ",", "gstop", ",", "analog", "=", "False", ",", "fs", "=", "None", ")", "\n", "b", ",", "a", "=", "signal", ".", "butter", "(", "N", ",", "Wn", ",", "btype", "=", "\"bandpass\"", ",", "analog", "=", "False", ",", "output", "=", "'ba'", ",", "fs", "=", "None", ")", "\n", "\n", "audio", "=", "new", ".", "T", ".", "to", "(", "\"cpu\"", ")", "\n", "a", "=", "torch", ".", "tensor", "(", "a", ",", "device", "=", "\"cpu\"", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "b", "=", "torch", ".", "tensor", "(", "b", ",", "device", "=", "\"cpu\"", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "new_audio", "=", "None", "\n", "for", "ppp", "in", "range", "(", "audio", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "new_audio_", "=", "lfilter", "(", "b", ",", "a", ",", "audio", "[", ":", ",", "ppp", ":", "ppp", "+", "1", "]", ")", ".", "T", "\n", "if", "new_audio", "is", "None", ":", "\n", "            ", "new_audio", "=", "new_audio_", "\n", "", "else", ":", "\n", "            ", "new_audio", "=", "torch", ".", "cat", "(", "(", "new_audio", ",", "new_audio_", ")", ",", "dim", "=", "0", ")", "\n", "", "", "new_audio", "=", "new_audio", ".", "clamp", "(", "clip_min", ",", "clip_max", ")", "\n", "\n", "return", "new_audio", ".", "to", "(", "new", ".", "device", ")", ".", "view", "(", "ori_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.parser_defense": [[32, 53], ["zip", "len", "len", "len", "len", "defense.lambda_defense", "my_defense.append", "y.split", "y.replace", "y.replace"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.lambda_defense"], ["def", "parser_defense", "(", "defense", ",", "defense_param", ",", "defense_flag", ",", "defense_order", ")", ":", "\n", "    ", "''' defense: list of str, e.g., ['AT', 'QT', 'FeCo']\n        defense_param: list of str, e.g., ['16', '512', \"kmeans 0.2 L2\"]\n        defense_param: list of int, e.g., [0, 0, 1]\n    '''", "\n", "if", "defense", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "defense", ")", "==", "len", "(", "defense_param", ")", "\n", "assert", "len", "(", "defense_param", ")", "==", "len", "(", "defense_flag", ")", "\n", "my_defense", "=", "[", "]", "\n", "defense_name", "=", "\"\"", "\n", "for", "x", ",", "y", ",", "z", "in", "zip", "(", "defense", ",", "defense_param", ",", "defense_flag", ")", ":", "\n", "            ", "f", "=", "lambda_defense", "(", "x", ",", "y", ".", "split", "(", "' '", ")", ")", "\n", "my_defense", ".", "append", "(", "[", "z", ",", "f", "]", ")", "\n", "defense_name", "=", "defense_name", "+", "'{}&{}@{}+'", ".", "format", "(", "x", ",", "y", ".", "replace", "(", "' '", ",", "'#'", ")", ",", "z", ")", "if", "defense_order", "==", "'sequential'", "else", "defense_name", "+", "'{}&{}@{}$'", ".", "format", "(", "x", ",", "y", ".", "replace", "(", "' '", ",", "'#'", ")", ",", "z", ")", "\n", "", "defense_name", "=", "defense_name", "[", ":", "-", "1", "]", "\n", "# print(defense_name)", "\n", "", "else", ":", "\n", "        ", "my_defense", "=", "None", "\n", "defense_name", "=", "None", "\n", "", "return", "my_defense", ",", "defense_name", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.defense.lambda_defense": [[55, 88], ["hasattr", "getattr", "hasattr", "float", "hasattr", "getattr.", "getattr.", "hasattr", "float", "float", "float", "int", "NotImplementedError"], "function", ["None"], ["", "def", "lambda_defense", "(", "defense", ",", "defense_param", ")", ":", "\n", "    ", "''' defense: str\n        defense_param: list\n    '''", "\n", "if", "defense", "is", "None", ":", "\n", "        ", "return", "lambda", "x", ":", "x", "\n", "\n", "", "if", "hasattr", "(", "TD", ",", "defense", ")", ":", "\n", "        ", "ori_f_source", "=", "TD", "\n", "", "elif", "hasattr", "(", "FD", ",", "defense", ")", ":", "\n", "        ", "ori_f_source", "=", "FD", "\n", "", "elif", "hasattr", "(", "SC", ",", "defense", ")", ":", "\n", "        ", "ori_f_source", "=", "SC", "\n", "", "elif", "hasattr", "(", "FL", ",", "defense", ")", ":", "\n", "        ", "ori_f_source", "=", "FL", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Upsupported Defense Method'", ")", "\n", "", "ori_f", "=", "getattr", "(", "ori_f_source", ",", "defense", ")", "\n", "\n", "if", "defense", "==", "'FeCo'", "or", "defense", "==", "'FEATURE_COMPRESSION'", ":", "# cl_m, point, ratio, other_param (L2, cos, ts, random) ", "\n", "        ", "cl_m", "=", "defense_param", "[", "0", "]", "\n", "cl_r", "=", "float", "(", "defense_param", "[", "1", "]", ")", "\n", "other_param", "=", "defense_param", "[", "2", "]", "\n", "f", "=", "lambda", "x", ":", "ori_f", "(", "x", ",", "method", "=", "cl_m", ",", "param", "=", "cl_r", ",", "other_param", "=", "other_param", ")", "\n", "", "else", ":", "\n", "        ", "if", "defense", "==", "'BPF'", ":", "\n", "            ", "defense_param", "=", "[", "float", "(", "defense_param", "[", "0", "]", ")", ",", "float", "(", "defense_param", "[", "1", "]", ")", "]", "\n", "", "elif", "defense", "==", "'DS'", ":", "\n", "            ", "defense_param", "=", "float", "(", "defense_param", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "defense_param", "=", "int", "(", "defense_param", "[", "0", "]", ")", "\n", "", "f", "=", "lambda", "x", ":", "ori_f", "(", "x", ",", "param", "=", "defense_param", ")", "\n", "", "return", "f", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.Speech_Compression_Non_Diff": [[15, 136], ["torch.is_tensor", "torch.is_tensor", "abs", "shutil.rmtree", "numpy.array", "torch.tensor.reshape", "time.time", "range", "time.time", "NotImplementedError", "str", "new.reshape.clone().detach().cpu().numpy", "len", "new.reshape.reshape", "numpy.random.randint", "speech_compression.Speech_Compression_Non_Diff._worker"], "function", ["None"], ["def", "Speech_Compression_Non_Diff", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "name", ",", "param", ",", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "start_2", ",", "debug", ")", ":", "\n", "\n", "    ", "def", "_worker", "(", "start_", ",", "end", ")", ":", "\n", "        ", "st", "=", "time", ".", "time", "(", ")", "\n", "for", "i", "in", "range", "(", "start_", ",", "end", ")", ":", "\n", "            ", "origin_audio_path", "=", "tmp_dir", "+", "\"/\"", "+", "str", "(", "i", ")", "+", "\".wav\"", "\n", "audio", "=", "np", ".", "clip", "(", "new", "[", "i", "]", "[", ":", "lengths", "[", "i", "]", "]", ",", "min", ",", "max", ")", ".", "astype", "(", "np", ".", "int16", ")", "\n", "write", "(", "origin_audio_path", ",", "fs", ",", "audio", ")", "\n", "opus_audio_path", "=", "\"{}/{}.{}\"", ".", "format", "(", "tmp_dir", ",", "i", ",", "name", ")", "\n", "command", "=", "\"ffmpeg -i {} -ac 1 -ar {} {} {} -c:a {} {}\"", ".", "format", "(", "origin_audio_path", ",", "fs", ",", "\n", "param", "[", "0", "]", ",", "param", "[", "1", "]", ",", "param", "[", "2", "]", ",", "opus_audio_path", ")", "\n", "args", "=", "shlex", ".", "split", "(", "command", ")", "\n", "if", "debug", ":", "\n", "                ", "p", "=", "subprocess", ".", "Popen", "(", "args", ")", "\n", "", "else", ":", "\n", "                ", "p", "=", "subprocess", ".", "Popen", "(", "args", ",", "stderr", "=", "subprocess", ".", "DEVNULL", ",", "\n", "stdout", "=", "subprocess", ".", "DEVNULL", ")", "\n", "", "p", ".", "wait", "(", ")", "\n", "\n", "pcm_type", "=", "\"pcm_s16le\"", "if", "bits_per_sample", "==", "16", "else", "\"pcm_s8\"", "\n", "target_audio_path", "=", "tmp_dir", "+", "\"/\"", "+", "str", "(", "i", ")", "+", "\"-target.wav\"", "\n", "command", "=", "\"ffmpeg -i {} -ac 1 -ar {} -c:a {} {}\"", ".", "format", "(", "opus_audio_path", ",", "fs", ",", "pcm_type", ",", "target_audio_path", ")", "\n", "args", "=", "shlex", ".", "split", "(", "command", ")", "\n", "if", "debug", ":", "\n", "                ", "p", "=", "subprocess", ".", "Popen", "(", "args", ")", "\n", "", "else", ":", "\n", "                ", "p", "=", "subprocess", ".", "Popen", "(", "args", ",", "stderr", "=", "subprocess", ".", "DEVNULL", ",", "\n", "stdout", "=", "subprocess", ".", "DEVNULL", ")", "\n", "", "p", ".", "wait", "(", ")", "\n", "\n", "_", ",", "coding_audio", "=", "read", "(", "target_audio_path", ")", "\n", "if", "coding_audio", ".", "size", "<=", "lengths", "[", "i", "]", "or", "(", "coding_audio", ".", "size", ">", "lengths", "[", "i", "]", "and", "not", "same_size", ")", ":", "\n", "                ", "opuseds", "[", "i", "]", "=", "list", "(", "coding_audio", ")", "\n", "", "else", ":", "\n", "                ", "start", "=", "start_2", "\n", "if", "start", "is", "None", ":", "\n", "                    ", "min_dist", "=", "np", ".", "infty", "\n", "start", "=", "0", "\n", "for", "start_candidate", "in", "range", "(", "0", ",", "coding_audio", ".", "size", "-", "audio", ".", "size", "+", "1", ",", "1", ")", ":", "\n", "                        ", "dist", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "audio", "/", "abs_max", "-", "coding_audio", "[", "start_candidate", ":", "start_candidate", "+", "audio", ".", "size", "]", "/", "abs_max", ")", ")", "\n", "if", "dist", "<", "min_dist", ":", "\n", "                            ", "start", "=", "start_candidate", "\n", "min_dist", "=", "dist", "\n", "", "", "", "opuseds", "[", "i", "]", "=", "list", "(", "coding_audio", "[", "start", ":", "start", "+", "lengths", "[", "i", "]", "]", ")", "\n", "", "", "et", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "if", "not", "bits_per_sample", "in", "[", "16", ",", "8", "]", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Currently We Only Support 16 Bit and 8 Bit Quantized Audio, \\\n                You Need to Modify 'pcm_type' for Other Bit Type\"", ")", "\n", "\n", "", "out_tensor", "=", "False", "\n", "device", "=", "None", "\n", "if", "torch", ".", "is_tensor", "(", "new", ")", ":", "\n", "        ", "device", "=", "str", "(", "new", ".", "device", ")", "\n", "out_tensor", "=", "True", "\n", "new", "=", "new", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "ori_shape", "=", "new", ".", "shape", "\n", "if", "len", "(", "new", ".", "shape", ")", "==", "1", ":", "\n", "        ", "new", "=", "new", ".", "reshape", "(", "(", "1", ",", "new", ".", "shape", "[", "0", "]", ")", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "new", ".", "shape", ")", "==", "3", ":", "\n", "        ", "new", "=", "new", ".", "reshape", "(", "(", "new", ".", "shape", "[", "0", "]", ",", "new", ".", "shape", "[", "2", "]", ")", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "bit_rate", "=", "param", "\n", "n_audios", ",", "max_len", "=", "new", ".", "shape", "\n", "### indicating the real length of each audio in new", "\n", "### this parameter is only valid in speech coding method since other methods not use loop", "\n", "lengths", "=", "lengths", "if", "lengths", "else", "n_audios", "*", "[", "max_len", "]", "\n", "max", "=", "2", "**", "(", "bits_per_sample", "-", "1", ")", "-", "1", "\n", "min", "=", "-", "1.", "*", "2", "**", "(", "bits_per_sample", "-", "1", ")", "\n", "abs_max", "=", "abs", "(", "min", ")", "\n", "scale", "=", "False", "\n", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "# if -1 <= new.max() <= 1:", "\n", "if", "new", ".", "min", "(", ")", ">=", "2", "*", "lower", "and", "new", ".", "max", "(", ")", "<=", "2", "*", "upper", ":", "# 2*lower and 2*upper due to floating point issue, e.g., sometimes will have 1.0002", "\n", "        ", "new", "=", "new", "*", "abs_max", "\n", "scale", "=", "True", "\n", "\n", "", "high", "=", "100000", "\n", "while", "True", ":", "\n", "        ", "random_number", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "high", "+", "1", ")", "\n", "tmp_dir", "=", "\"{}-Coding-\"", ".", "format", "(", "name", ")", "+", "str", "(", "random_number", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "tmp_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "tmp_dir", ")", "\n", "break", "\n", "", "", "opuseds", "=", "[", "0", "]", "*", "n_audios", "\n", "\n", "if", "not", "parallel", "or", "(", "parallel", "and", "n_jobs", "==", "1", ")", "or", "n_audios", "==", "1", ":", "\n", "        ", "_worker", "(", "0", ",", "n_audios", ")", "\n", "\n", "", "else", ":", "\n", "        ", "n_jobs", "=", "n_jobs", "if", "n_jobs", "<=", "n_audios", "else", "n_audios", "\n", "n_audios_per_job", "=", "n_audios", "//", "n_jobs", "\n", "process_index", "=", "[", "]", "\n", "for", "ii", "in", "range", "(", "n_jobs", ")", ":", "\n", "            ", "process_index", ".", "append", "(", "[", "ii", "*", "n_audios_per_job", ",", "(", "ii", "+", "1", ")", "*", "n_audios_per_job", "]", ")", "\n", "", "if", "n_jobs", "*", "n_audios_per_job", "!=", "n_audios", ":", "\n", "            ", "process_index", "[", "-", "1", "]", "[", "-", "1", "]", "=", "n_audios", "\n", "", "futures", "=", "set", "(", ")", "\n", "with", "ThreadPoolExecutor", "(", ")", "as", "executor", ":", "\n", "            ", "for", "job_id", "in", "range", "(", "n_jobs", ")", ":", "\n", "                ", "future", "=", "executor", ".", "submit", "(", "_worker", ",", "process_index", "[", "job_id", "]", "[", "0", "]", ",", "process_index", "[", "job_id", "]", "[", "1", "]", ")", "\n", "futures", ".", "add", "(", "future", ")", "\n", "", "for", "future", "in", "as_completed", "(", "futures", ")", ":", "\n", "                ", "pass", "\n", "\n", "", "", "", "shutil", ".", "rmtree", "(", "tmp_dir", ")", "\n", "opuseds", "=", "np", ".", "array", "(", "[", "(", "x", "+", "[", "0", "]", "*", "(", "max_len", "-", "len", "(", "x", ")", ")", ")", "[", ":", "max_len", "]", "for", "x", "in", "opuseds", "]", ")", "\n", "opuseds", "=", "opuseds", ".", "reshape", "(", "ori_shape", ")", "\n", "if", "out_tensor", ":", "\n", "        ", "opuseds", "=", "torch", ".", "tensor", "(", "opuseds", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "", "if", "scale", ":", "\n", "        ", "opuseds", ".", "data", "/=", "abs_max", "\n", "", "return", "opuseds", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.OPUS": [[139, 145], ["speech_compression"], "function", ["None"], ["def", "OPUS", "(", "new", ",", "lengths", "=", "None", ",", "bits_per_sample", "=", "16", ",", "param", "=", "16000", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'opus'", ",", "[", "'-b:a'", ",", "param", ",", "'libopus'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "69", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.SPEEX": [[147, 153], ["speech_compression"], "function", ["None"], ["", "def", "SPEEX", "(", "new", ",", "lengths", "=", "None", ",", "bits_per_sample", "=", "16", ",", "param", "=", "43200", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'spx'", ",", "[", "'-b:a'", ",", "param", ",", "'libspeex'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "None", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.AMR": [[155, 170], ["speech_compression", "NotImplementedError", "NotImplementedError", "int"], "function", ["None"], ["", "def", "AMR", "(", "new", ",", "lengths", "=", "None", ",", "bits_per_sample", "=", "16", ",", "param", "=", "6600", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "if", "fs", "==", "16000", ":", "\n", "        ", "legal_bit_rate", "=", "[", "6600", ",", "8850", ",", "12650", ",", "14250", ",", "15850", ",", "18250", ",", "19850", ",", "23050", ",", "23850", "]", "\n", "", "elif", "fs", "==", "8000", ":", "\n", "        ", "legal_bit_rate", "=", "[", "4750", ",", "5150", ",", "5900", ",", "6700", ",", "7400", ",", "7950", ",", "10200", ",", "12200", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"AMR Compression only support sampling rate 16000 and 8000\"", ")", "\n", "", "if", "not", "int", "(", "param", ")", "in", "legal_bit_rate", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"%f Not Allowed When fs=%d\"", "%", "(", "param", ",", "fs", ")", ")", "\n", "\n", "", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'amr'", ",", "[", "'-b:a'", ",", "param", ",", "\"libvo_amrwbenc\"", "if", "fs", "==", "16000", "else", "\"libopencore_amrnb\"", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "None", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.AAC_V": [[172, 178], ["speech_compression"], "function", ["None"], ["", "def", "AAC_V", "(", "new", ",", "lengths", "=", "None", ",", "bits_per_sample", "=", "16", ",", "param", "=", "5", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'aac'", ",", "[", "'-vbr'", ",", "param", ",", "'libfdk_aac'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "2048", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.AAC_C": [[180, 186], ["speech_compression"], "function", ["None"], ["", "def", "AAC_C", "(", "new", ",", "lengths", "=", "None", ",", "bits_per_sample", "=", "16", ",", "param", "=", "20000", ",", "fs", "=", "16000", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'aac'", ",", "[", "'-b:a'", ",", "param", ",", "'libfdk_aac'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "2048", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.MP3_V": [[188, 194], ["speech_compression"], "function", ["None"], ["", "def", "MP3_V", "(", "new", ",", "lengths", "=", "None", ",", "param", "=", "9", ",", "fs", "=", "16000", ",", "bits_per_sample", "=", "16", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'mp3'", ",", "[", "'-q:a'", ",", "param", ",", "'mp3'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "0", ",", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.speech_compression.MP3_C": [[196, 202], ["speech_compression"], "function", ["None"], ["", "def", "MP3_C", "(", "new", ",", "lengths", "=", "None", ",", "param", "=", "16000", ",", "fs", "=", "16000", ",", "bits_per_sample", "=", "16", ",", "same_size", "=", "True", ",", "parallel", "=", "True", ",", "n_jobs", "=", "10", ",", "debug", "=", "False", ")", ":", "\n", "\n", "    ", "return", "speech_compression", "(", "new", ",", "lengths", ",", "bits_per_sample", ",", "\n", "'mp3'", ",", "[", "'-b:a'", ",", "param", ",", "'mp3'", "]", ",", "\n", "fs", ",", "same_size", ",", "\n", "parallel", ",", "n_jobs", ",", "0", ",", "debug", ")", "", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.time_domain.QT_Non_Diff": [[10, 43], ["abs", "audio_q.view", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "len", "audio.squeeze.unsqueeze", "torch.round", "torch.round", "torch.round", "len", "len", "audio.squeeze.squeeze", "NotImplementedError", "audio.squeeze.max", "audio.squeeze.min"], "function", ["None"], ["def", "QT_Non_Diff", "(", "audio", ",", "param", "=", "128", ",", "bits", "=", "16", ",", "same_size", "=", "True", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "ori_shape", "=", "audio", ".", "shape", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "1", ":", "\n", "        ", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "3", ":", "\n", "        ", "audio", "=", "audio", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "max", "=", "2", "**", "(", "bits", "-", "1", ")", "-", "1", "\n", "min", "=", "-", "1.", "*", "2", "**", "(", "bits", "-", "1", ")", "\n", "abs_max", "=", "abs", "(", "min", ")", "\n", "scale", "=", "False", "\n", "lower", "=", "-", "1", "\n", "upper", "=", "1", "\n", "# print('QT-1:', audio.max(), audio.min())", "\n", "# if audio.min() >= 2 * lower and audio.max() <= 2 * upper: # 2*lower and 2*upper due to floating point issue, e.g., sometimes will have 1.0002", "\n", "if", "0.9", "*", "audio", ".", "max", "(", ")", "<=", "upper", "and", "0.9", "*", "audio", ".", "min", "(", ")", ">=", "lower", ":", "\n", "        ", "audio", "=", "audio", "*", "abs_max", "\n", "scale", "=", "True", "\n", "# print('QT-2:', audio.max(), audio.min())", "\n", "", "q", "=", "param", "\n", "audio_q", "=", "torch", ".", "round", "(", "audio", "/", "q", ")", "*", "q", "# round operation makes it non-differentiable", "\n", "# print('QT-3:', audio_q.max(), audio_q.min())", "\n", "\n", "if", "scale", ":", "\n", "        ", "audio_q", ".", "data", "/=", "abs_max", "\n", "\n", "", "return", "audio_q", ".", "view", "(", "ori_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.time_domain.BDR": [[46, 49], ["QT"], "function", ["None"], ["def", "BDR", "(", "audio", ",", "param", "=", "8", ",", "bits", "=", "16", ",", "same_size", "=", "True", ")", ":", "\n", "    ", "q", "=", "2", "**", "(", "bits", "-", "param", ")", "\n", "return", "QT", "(", "audio", ",", "param", "=", "q", ",", "bits", "=", "bits", ",", "same_size", "=", "same_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.time_domain.AT": [[50, 71], ["torch.sum", "torch.sum", "torch.sum", "noised_audio.view", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "len", "audio.squeeze.unsqueeze", "torch.randn", "torch.randn", "torch.randn", "torch.sqrt", "torch.sqrt", "torch.sqrt", "len", "len", "audio.squeeze.squeeze", "NotImplementedError", "math.sqrt"], "function", ["None"], ["", "def", "AT", "(", "audio", ",", "param", "=", "25", ",", "same_size", "=", "True", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "ori_shape", "=", "audio", ".", "shape", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "1", ":", "\n", "        ", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "3", ":", "\n", "        ", "audio", "=", "audio", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "snr", "=", "param", "\n", "snr", "=", "10", "**", "(", "snr", "/", "10", ")", "\n", "batch", ",", "N", "=", "audio", ".", "shape", "\n", "power_audio", "=", "torch", ".", "sum", "(", "(", "audio", "/", "math", ".", "sqrt", "(", "N", ")", ")", "**", "2", ",", "dim", "=", "1", ",", "keepdims", "=", "True", ")", "# (batch, 1)", "\n", "power_noise", "=", "power_audio", "/", "snr", "# (batch, 1)", "\n", "noise", "=", "torch", ".", "randn", "(", "(", "batch", ",", "N", ")", ",", "device", "=", "audio", ".", "device", ")", "*", "torch", ".", "sqrt", "(", "power_noise", ")", "# (batch, N)", "\n", "noised_audio", "=", "audio", "+", "noise", "\n", "return", "noised_audio", ".", "view", "(", "ori_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.time_domain.AS": [[72, 98], ["audio.squeeze.view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.conv1d", "F.conv1d.squeeze().view", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "len", "audio.squeeze.unsqueeze", "numpy.ones", "len", "torch.tensor", "torch.tensor", "torch.tensor", "F.conv1d.squeeze", "len", "audio.squeeze.squeeze", "NotImplementedError"], "function", ["None"], ["", "def", "AS", "(", "audio", ",", "param", "=", "3", ",", "same_size", "=", "True", ")", ":", "\n", "\n", "    ", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "ori_shape", "=", "audio", ".", "shape", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "1", ":", "\n", "        ", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "3", ":", "\n", "        ", "audio", "=", "audio", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "batch", ",", "_", "=", "audio", ".", "shape", "\n", "\n", "kernel_size", "=", "param", "\n", "assert", "kernel_size", "%", "2", "==", "1", "\n", "audio", "=", "audio", ".", "view", "(", "batch", ",", "1", ",", "-", "1", ")", "# (batch, in_channel:1, max_len)", "\n", "\n", "################# Using torch.nn.functional ###################", "\n", "kernel_weights", "=", "np", ".", "ones", "(", "kernel_size", ")", "/", "kernel_size", "\n", "weight", "=", "torch", ".", "tensor", "(", "kernel_weights", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "audio", ".", "device", ")", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "# (out_channel:1, in_channel:1, kernel_size)", "\n", "output", "=", "F", ".", "conv1d", "(", "audio", ",", "weight", ",", "padding", "=", "(", "kernel_size", "-", "1", ")", "//", "2", ")", "# (batch, 1, max_len)", "\n", "###############################################################", "\n", "\n", "return", "output", ".", "squeeze", "(", "1", ")", ".", "view", "(", "ori_shape", ")", "# (batch, max_len)", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.time_domain.MS": [[100, 128], ["torch.pad", "audio.squeeze.unfold", "torch.median", "torch.median", "torch.median", "values.view", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "len", "audio.squeeze.unsqueeze", "len", "len", "audio.squeeze.squeeze", "NotImplementedError"], "function", ["None"], ["", "def", "MS", "(", "audio", ",", "param", "=", "3", ",", "same_size", "=", "True", ")", ":", "\n", "    ", "r\"\"\"\n    Apply median smoothing to the 1D tensor over the given window.\n    \"\"\"", "\n", "\n", "assert", "torch", ".", "is_tensor", "(", "audio", ")", "==", "True", "\n", "ori_shape", "=", "audio", ".", "shape", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "1", ":", "\n", "        ", "audio", "=", "audio", ".", "unsqueeze", "(", "0", ")", "# (T, ) --> (1, T)", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "# (B, T)", "\n", "        ", "pass", "\n", "", "elif", "len", "(", "audio", ".", "shape", ")", "==", "3", ":", "\n", "        ", "audio", "=", "audio", ".", "squeeze", "(", "1", ")", "# (B, 1, T) --> (B, T)", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Audio Shape Error'", ")", "\n", "\n", "", "win_length", "=", "param", "\n", "# Centered windowed", "\n", "pad_length", "=", "(", "win_length", "-", "1", ")", "//", "2", "\n", "\n", "# \"replicate\" padding in any dimension", "\n", "audio", "=", "F", ".", "pad", "(", "audio", ",", "(", "pad_length", ",", "pad_length", ")", ",", "mode", "=", "\"constant\"", ",", "value", "=", "0.", ")", "\n", "\n", "# indices[..., :pad_length] = torch.cat(pad_length * [indices[..., pad_length].unsqueeze(-1)], dim=-1)", "\n", "roll", "=", "audio", ".", "unfold", "(", "-", "1", ",", "win_length", ",", "1", ")", "\n", "\n", "values", ",", "_", "=", "torch", ".", "median", "(", "roll", ",", "-", "1", ")", "\n", "return", "values", ".", "view", "(", "ori_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.FeCo": [[18, 20], ["feature_level.FEATURE_COMPRESSION"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.FEATURE_COMPRESSION"], ["", "def", "FeCo", "(", "feat", ",", "method", "=", "'kmeans'", ",", "param", "=", "0.5", ",", "other_param", "=", "'L2'", ")", ":", "\n", "    ", "return", "FEATURE_COMPRESSION", "(", "feat", ",", "method", ",", "param", ",", "other_param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.FEATURE_COMPRESSION": [[21, 51], ["enumerate", "cl_m", "y.unsqueeze.unsqueeze", "kmeans_pytorch.kmeans", "NotImplementedError", "torch.cat", "torch.cat", "feature_level.warped_kmeans"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.kmeans", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.warped_kmeans"], ["", "def", "FEATURE_COMPRESSION", "(", "feat", ",", "method", "=", "'kmeans'", ",", "param", "=", "0.5", ",", "other_param", "=", "'L2'", ")", ":", "\n", "    ", "\"\"\"[summary]\n\n    Parameters\n    ----------\n    feat : torch tensor of shape (batch, num_frames, num_dim)\n        feature to be compressed\n    method : str, optional\n        clustering method (cl_m in paper), by default 'kmeans'\n    param : float, optional\n        the ratio between ori #frames and compressed #frames (cl_r in paper), by default 0.5\n    other_param : str, optional\n        for kmeans, it is either 'L2' or 'cosine'; for warped_kmeans, it is 'random' or 'ts', by default 'L2'\n    \"\"\"", "\n", "if", "method", "==", "'kmeans'", ":", "\n", "        ", "cl_m", "=", "lambda", "x", ":", "kmeans", "(", "x", ",", "param", "=", "param", ",", "other_param", "=", "other_param", ",", "force", "=", "feat", ".", "shape", "[", "0", "]", ">", "1", ")", "\n", "", "elif", "method", "==", "'warped_kmeans'", ":", "\n", "        ", "cl_m", "=", "lambda", "x", ":", "warped_kmeans", "(", "x", ",", "param", "=", "param", ",", "other_param", "=", "other_param", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Currently FEATURE COMPRESSION only suppots kmeans and warped_kmeans'", ")", "\n", "\n", "", "compressed_feat", "=", "None", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "feat", ")", ":", "\n", "        ", "y", "=", "cl_m", "(", "x", ")", "\n", "y", "=", "y", ".", "unsqueeze", "(", "0", ")", "\n", "if", "i", "==", "0", ":", "\n", "            ", "compressed_feat", "=", "y", "\n", "", "else", ":", "\n", "            ", "compressed_feat", "=", "torch", ".", "cat", "(", "(", "compressed_feat", ",", "y", ")", ",", "dim", "=", "0", ")", "\n", "", "", "return", "compressed_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.TS": [[53, 78], ["torch.zeros", "torch.zeros", "range", "range", "torch.tensor", "torch.tensor", "enumerate", "range", "feat.size", "torch.tensor.append", "torch.where", "torch.where", "torch.norm", "torch.norm", "surpass_index.size", "surpass_index.size"], "function", ["None"], ["", "def", "TS", "(", "feat", ",", "k", ")", ":", "\n", "    ", "n", "=", "feat", ".", "size", "(", ")", "[", "0", "]", "\n", "distance", "=", "torch", ".", "zeros", "(", "(", "n", ",", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "distance", "[", "i", "]", "=", "distance", "[", "i", "-", "1", "]", "+", "torch", ".", "norm", "(", "feat", "[", "i", "]", "-", "feat", "[", "i", "-", "1", "]", ")", "\n", "", "seg_dist", "=", "distance", "[", "n", "-", "1", "]", "/", "k", "\n", "boundary", "=", "[", "0", "]", "\n", "index", "=", "0", "\n", "for", "j", "in", "range", "(", "1", ",", "k", ")", ":", "\n", "        ", "required_dist", "=", "seg_dist", "*", "j", "\n", "while", "(", "index", "<", "n", "and", "(", "required_dist", ">", "distance", "[", "index", "]", "or", "index", "in", "boundary", ")", ")", ":", "\n", "            ", "index", "+=", "1", "\n", "", "boundary", ".", "append", "(", "index", ")", "\n", "", "boundary", "=", "torch", ".", "tensor", "(", "boundary", ",", "dtype", "=", "torch", ".", "int", ")", "\n", "surpass_index", "=", "torch", ".", "where", "(", "boundary", "==", "n", ")", "[", "0", "]", "\n", "if", "surpass_index", ".", "size", "(", ")", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "boundary", "\n", "", "for", "i", ",", "index", "in", "enumerate", "(", "surpass_index", ")", ":", "\n", "        ", "boundary", "[", "index", "]", "=", "n", "-", "surpass_index", ".", "size", "(", ")", "[", "0", "]", "+", "i", "\n", "", "for", "i", "in", "range", "(", "surpass_index", "[", "0", "]", "-", "1", ",", "1", ",", "-", "1", ")", ":", "\n", "        ", "if", "boundary", "[", "i", "]", ">=", "boundary", "[", "i", "+", "1", "]", ":", "\n", "            ", "boundary", "[", "i", "]", "=", "boundary", "[", "i", "+", "1", "]", "-", "1", "\n", "", "else", ":", "\n", "            ", "break", "\n", "", "", "return", "boundary", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.random_init": [[80, 86], ["list", "boundary.sort", "torch.tensor", "torch.tensor", "feat.size", "numpy.random.choice", "range"], "function", ["None"], ["", "def", "random_init", "(", "feat", ",", "k", ")", ":", "\n", "    ", "n", "=", "feat", ".", "size", "(", ")", "[", "0", "]", "\n", "boundary", "=", "[", "0", "]", "\n", "boundary", "+=", "list", "(", "np", ".", "random", ".", "choice", "(", "range", "(", "1", ",", "n", ")", ",", "size", "=", "(", "k", "-", "1", ",", ")", ",", "replace", "=", "False", ",", "p", "=", "None", ")", ")", "\n", "boundary", ".", "sort", "(", ")", "\n", "return", "torch", ".", "tensor", "(", "boundary", ",", "dtype", "=", "torch", ".", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.init": [[88, 107], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.any", "torch.any", "torch.nn.functional.pad", "torch.nn.functional.pad", "range", "boundary.size", "feat.size", "feat.size", "print", "torch.mean", "torch.mean", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "init", "(", "feat", ",", "boundary", ")", ":", "\n", "    ", "device", "=", "feat", ".", "device", "\n", "k", "=", "boundary", ".", "size", "(", ")", "[", "0", "]", "\n", "feat_dim", "=", "feat", ".", "size", "(", ")", "[", "1", "]", "\n", "means", "=", "torch", ".", "zeros", "(", "(", "k", ",", "feat_dim", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "counts", "=", "torch", ".", "zeros", "(", "(", "k", ",", ")", ",", "dtype", "=", "torch", ".", "int", ",", "device", "=", "device", ")", "\n", "# counts = torch.zeros((k, ), dtype=torch.float)", "\n", "counts", "[", ":", "-", "1", "]", "=", "boundary", "[", "1", ":", "]", "-", "boundary", "[", ":", "-", "1", "]", "\n", "n", "=", "feat", ".", "size", "(", ")", "[", "0", "]", "\n", "counts", "[", "-", "1", "]", "=", "n", "-", "boundary", "[", "-", "1", "]", "\n", "if", "torch", ".", "any", "(", "counts", "==", "0", ")", ":", "\n", "        ", "print", "(", "\"Warning, zero counts\"", ")", "\n", "", "boundary_pad", "=", "torch", ".", "nn", ".", "functional", ".", "pad", "(", "boundary", ",", "(", "0", ",", "1", ")", ",", "mode", "=", "'constant'", ",", "value", "=", "n", ")", "\n", "quadratic_error", "=", "0", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "feat_seg", "=", "feat", "[", "boundary_pad", "[", "i", "]", ":", "boundary_pad", "[", "i", "+", "1", "]", ",", ":", "]", "\n", "means", "[", "i", "]", "=", "torch", ".", "mean", "(", "feat_seg", ",", "dim", "=", "0", ",", "keepdim", "=", "False", ")", "\n", "quadratic_error", "+=", "torch", ".", "sum", "(", "(", "feat_seg", "-", "means", "[", "i", "]", ")", "**", "2", ")", "\n", "", "return", "quadratic_error", ",", "means", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.delta_SQE": [[109, 112], ["torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "delta_SQE", "(", "x", ",", "mean_j", ",", "mean_l", ",", "count_j", ",", "count_l", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "x", "-", "mean_l", ")", "**", "2", ")", "*", "count_l", "/", "(", "count_l", "+", "1", ")", "-", "torch", ".", "sum", "(", "(", "x", "-", "mean_j", ")", "**", "2", ")", "*", "count_j", "/", "(", "count_j", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.wk_compute": [[114, 155], ["feature_level.init", "feature_level.TS", "feature_level.random_init", "range", "range", "range", "math.floor", "feature_level.delta_SQE", "math.floor", "feature_level.delta_SQE", "counts[].item", "counts[].item"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.init", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.TS", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.random_init", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.delta_SQE", "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.delta_SQE"], ["", "def", "wk_compute", "(", "feat", ",", "k", ",", "delta", ",", "bounday_init", "=", "\"ts\"", ")", ":", "\n", "\n", "    ", "boundary", "=", "TS", "(", "feat", ",", "k", ")", "if", "bounday_init", "==", "\"ts\"", "else", "random_init", "(", "feat", ",", "k", ")", "\n", "quadratic_error", ",", "means", ",", "counts", "=", "init", "(", "feat", ",", "boundary", ")", "\n", "continue_flag", "=", "True", "\n", "iter_cnt", "=", "0", "\n", "while", "continue_flag", ":", "\n", "        ", "continue_flag", "=", "False", "\n", "iter_cnt", "+=", "1", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "            ", "if", "i", ">", "0", ":", "\n", "                ", "begin", "=", "boundary", "[", "i", "]", "\n", "end", "=", "begin", "+", "math", ".", "floor", "(", "counts", "[", "i", "]", ".", "item", "(", ")", "/", "2", "*", "(", "1", "-", "delta", ")", ")", "\n", "for", "j", "in", "range", "(", "begin", ",", "end", ")", ":", "\n", "                    ", "delta_sqe", "=", "delta_SQE", "(", "feat", "[", "j", "]", ",", "means", "[", "i", "]", ",", "means", "[", "i", "-", "1", "]", ",", "counts", "[", "i", "]", ",", "counts", "[", "i", "-", "1", "]", ")", "\n", "if", "counts", "[", "i", "]", ">", "1", "and", "delta_sqe", "<", "0", ":", "\n", "                        ", "continue_flag", "=", "True", "\n", "boundary", "[", "i", "]", "+=", "1", "\n", "counts", "[", "i", "]", "-=", "1", "\n", "counts", "[", "i", "-", "1", "]", "+=", "1", "\n", "quadratic_error", "+=", "delta_sqe", "\n", "means", ".", "data", "[", "i", "]", "-=", "(", "feat", "[", "j", "]", "-", "means", ".", "data", "[", "i", "]", ")", "/", "counts", "[", "i", "]", "\n", "means", ".", "data", "[", "i", "-", "1", "]", "+=", "(", "feat", "[", "j", "]", "-", "means", ".", "data", "[", "i", "-", "1", "]", ")", "/", "counts", "[", "i", "-", "1", "]", "\n", "", "else", ":", "\n", "                        ", "break", "\n", "", "", "", "if", "i", "<", "k", "-", "1", ":", "\n", "                ", "end", "=", "boundary", "[", "i", "+", "1", "]", "-", "1", "\n", "begin", "=", "end", "-", "math", ".", "floor", "(", "counts", "[", "i", "]", ".", "item", "(", ")", "/", "2", "*", "(", "1", "-", "delta", ")", ")", "\n", "for", "j", "in", "range", "(", "end", ",", "begin", ",", "-", "1", ")", ":", "\n", "                    ", "delta_sqe", "=", "delta_SQE", "(", "feat", "[", "j", "]", ",", "means", "[", "i", "]", ",", "means", "[", "i", "+", "1", "]", ",", "counts", "[", "i", "]", ",", "counts", "[", "i", "+", "1", "]", ")", "\n", "if", "counts", "[", "i", "]", ">", "1", "and", "delta_sqe", "<", "0", ":", "\n", "                        ", "continue_flag", "=", "True", "\n", "boundary", "[", "i", "+", "1", "]", "-=", "1", "\n", "counts", "[", "i", "]", "-=", "1", "\n", "counts", "[", "i", "+", "1", "]", "+=", "1", "\n", "quadratic_error", "+=", "delta_sqe", "\n", "means", ".", "data", "[", "i", "]", "-=", "(", "feat", "[", "j", "]", "-", "means", ".", "data", "[", "i", "]", ")", "/", "counts", "[", "i", "]", "\n", "means", ".", "data", "[", "i", "+", "1", "]", "+=", "(", "feat", "[", "j", "]", "-", "means", ".", "data", "[", "i", "+", "1", "]", ")", "/", "counts", "[", "i", "+", "1", "]", "\n", "", "else", ":", "\n", "                        ", "break", "\n", "", "", "", "", "", "return", "means", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.warped_kmeans": [[157, 166], ["int", "feature_level.wk_compute", "torch.is_tensor", "torch.is_tensor", "feat.size"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.wk_compute"], ["", "def", "warped_kmeans", "(", "feat", ",", "param", "=", "0.5", ",", "delta", "=", "0.", ",", "other_param", "=", "\"random\"", ")", ":", "\n", "    ", "bounday_init", "=", "other_param", "\n", "assert", "torch", ".", "is_tensor", "(", "feat", ")", "==", "True", "\n", "assert", "bounday_init", "in", "[", "\"ts\"", ",", "\"random\"", "]", "\n", "ratio", "=", "param", "\n", "n", "=", "feat", ".", "size", "(", ")", "[", "0", "]", "\n", "k", "=", "int", "(", "n", "*", "ratio", ")", "\n", "warped_feat", "=", "wk_compute", "(", "feat", ",", "k", ",", "delta", ",", "bounday_init", "=", "bounday_init", ")", "\n", "return", "warped_feat", "\n", "\n"]], "home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.kmeans": [[168, 218], ["feat.size", "int", "range", "torch.is_tensor", "torch.is_tensor", "torch.cuda.is_available", "torch.cuda.is_available", "feat.clone().detach().cpu().numpy().astype", "kmeans_cuda", "kmeans_pytorch.kmeans", "cluster_ids.numpy.numpy", "numpy.argwhere().flatten", "str", "torch.device", "torch.device", "int", "torch.mean().unsqueeze", "torch.mean().unsqueeze", "feat.clone().detach().cpu().numpy", "feature_level.kmeans.get_device"], "function", ["home.repos.pwc.inspect_result.SEC4SR_SEC4SR.defense.feature_level.kmeans"], ["", "def", "kmeans", "(", "feat", ",", "param", "=", "0.5", ",", "other_param", "=", "\"L2\"", ",", "force", "=", "True", ")", ":", "\n", "\n", "# def get_device(name):", "\n", "#     if str(name) == \"cpu\":", "\n", "#         name = torch.device(\"cuda:0\")", "\n", "#     return int(str(name).split(\":\")[1]) + 1 # Wrong", "\n", "    ", "def", "get_device", "(", "name", ")", ":", "\n", "        ", "if", "str", "(", "name", ")", "==", "\"cpu\"", ":", "\n", "            ", "name", "=", "torch", ".", "device", "(", "\"cuda:0\"", ")", "\n", "", "return", "2", "**", "(", "int", "(", "str", "(", "name", ")", ".", "split", "(", "\":\"", ")", "[", "1", "]", ")", ")", "# kmeans_cuda using bitwise OR to indicate the cuda device, e.g., 1--> cuda:0, 2-->cuda:1, 4-->cuda:2, 8-->cuda:3", "\n", "\n", "", "distance", "=", "other_param", "\n", "assert", "torch", ".", "is_tensor", "(", "feat", ")", "==", "True", "\n", "assert", "distance", "in", "[", "\"L2\"", ",", "\"cos\"", "]", "#### Note: Currently, 'cos' distance does not work well for kmeans_cuda", "\n", "if", "distance", "==", "'cos'", ":", "\n", "        ", "assert", "feat", ".", "shape", "[", "1", "]", "%", "2", "==", "0", "\n", "", "ratio", "=", "param", "\n", "n", ",", "dim", "=", "feat", ".", "size", "(", ")", "\n", "k", "=", "int", "(", "n", "*", "ratio", ")", "\n", "device", "=", "feat", ".", "device", "\n", "\n", "# invoke kmeans to obtain the clustering results", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "distance", "==", "'L2'", ":", "# when GPU available, using kmeans_cuda (not support COS distance well)", "\n", "# x = feat.clone().detach().cpu().numpy() # kmeans_cuda runs on numpy", "\n", "        ", "x", "=", "feat", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "# kmeans_cuda runs on numpy (np.float16 or np.float32)", "\n", "_", ",", "cluster_ids", "=", "kmeans_cuda", "(", "x", ",", "k", ",", "verbosity", "=", "0", ",", "device", "=", "get_device", "(", "device", ")", ",", "yinyang_t", "=", "0.", ",", "metric", "=", "distance", ")", "\n", "", "else", ":", "\n", "# When no GPU or using cosine distance, use another version of kmeans algo", "\n", "# Although 'kmeans_pytorch' can also run on GPU, it is slower than 'kmeans_cuda'", "\n", "        ", "distance_", "=", "'euclidean'", "if", "distance", "==", "'L2'", "else", "'cosine'", "# kmeans_pytorch takes different distance name", "\n", "# cluster_ids, _ = kmeans_pytorch(feat, k, distance=distance_, tqdm_flag=False, device=device)", "\n", "cluster_ids", ",", "_", "=", "kmeans_pytorch", "(", "feat", ",", "k", ",", "distance", "=", "distance_", ",", "device", "=", "device", ")", "# will display lots of useless log TODO: disable the log by adding a parameter 'tqdm_flag'", "\n", "cluster_ids", "=", "cluster_ids", ".", "numpy", "(", ")", "\n", "\n", "## tricky way to make 'FeCo' differentiable (with the help of automatic differentiation supported by Pytorch) ##", "\n", "## also deal with possible Nan problem (in rare cases, a very few clusters will contain no any vectors) ##", "\n", "", "y", "=", "None", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "ids", "=", "np", ".", "argwhere", "(", "cluster_ids", "==", "i", ")", ".", "flatten", "(", ")", "\n", "y_", "=", "None", "\n", "if", "ids", ".", "size", ">", "0", ":", "\n", "            ", "y_", "=", "torch", ".", "mean", "(", "feat", "[", "ids", ",", ":", "]", ",", "dim", "=", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "", "elif", "force", ":", "# force the shape of y to be (k, dim), otherwise we cannot concatenate the batch", "\n", "            ", "y_", "=", "feat", "[", "i", ":", "i", "+", "1", ",", ":", "]", "\n", "", "if", "y_", "is", "not", "None", ":", "\n", "            ", "if", "y", "is", "None", ":", "\n", "                ", "y", "=", "y_", "\n", "", "else", ":", "\n", "                ", "y", "=", "torch", ".", "cat", "(", "(", "y", ",", "y_", ")", ",", "dim", "=", "0", ")", "\n", "", "", "", "return", "y", "\n", "", ""]]}