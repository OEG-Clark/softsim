{"home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.__init__": [[31, 145], ["torch.Module.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "JoinedDataset.JoinedDataset.JoinedDataset", "hvd.init", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "hvd.rank", "TypeError", "TypeError", "TypeError", "TypeError", "TypeError", "len", "ValueError", "len", "ValueError", "float", "float", "hasattr", "hvd.local_rank", "PINN.PINN.model.cuda", "type", "ValueError", "type", "ValueError", "PINN.PINN.pde_loss.hpm_model.cuda", "float", "type", "isinstance", "TypeError", "isinstance", "TypeError", "len", "ValueError", "float"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "torch", ".", "nn", ".", "Module", ",", "input_dimension", ":", "int", ",", "output_dimension", ":", "int", ",", "\n", "pde_loss", ":", "PDELoss", ",", "initial_condition", ":", "InitialCondition", ",", "boundary_condition", ",", "\n", "use_gpu", "=", "True", ",", "use_horovod", "=", "False", ",", "dataset_mode", "=", "'min'", ")", ":", "\n", "        ", "\"\"\"\n        Initializes an physics-informed neural network (PINN). A PINN consists of a model which represents the solution\n        of the underlying partial differential equation(PDE) u, three loss terms representing initial (IC) and boundary\n        condition(BC) and the PDE and a dataset which represents the bounded domain U.\n\n        Args: \n            model : is the model which is trained to represent the underlying PDE\n            input_dimension : represents the dimension of the input vector x\n            output_dimension : represents the dimension of the solution u\n            pde_loss: Instance of the PDELoss class. Represents the underlying PDE\n            initial_condition: Instance of the InitialCondition class. Represents the initial condition\n            boundary_condition (BoundaryCondition, list): Instance of the BoundaryCondition class or a list of instances\n            of the BoundaryCondition class\n            use_gpu: enables gpu usage\n            use_horovod: enables horovod support\n            dataset_mode: defines the behavior of the joined dataset. The 'min'-mode sets the length of the dataset to\n            the minimum of the\n\n        \"\"\"", "\n", "super", "(", "PINN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# checking if the model is a torch module more model checking should be possible", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "use_horovod", "=", "use_horovod", "\n", "self", ".", "rank", "=", "0", "# initialize rank 0 by default in order to make the fit method more flexible", "\n", "self", ".", "loss_gradients_storage", "=", "{", "}", "\n", "if", "self", ".", "use_horovod", ":", "\n", "\n", "# Initialize Horovod", "\n", "            ", "hvd", ".", "init", "(", ")", "\n", "# Pin GPU to be used to process local rank (one GPU per process)", "\n", "torch", ".", "cuda", ".", "set_device", "(", "hvd", ".", "local_rank", "(", ")", ")", "\n", "self", ".", "rank", "=", "hvd", ".", "rank", "(", ")", "\n", "", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "self", ".", "loss_log", "=", "{", "}", "\n", "", "if", "isinstance", "(", "model", ",", "nn", ".", "Module", ")", ":", "\n", "            ", "self", ".", "model", "=", "model", "\n", "if", "self", ".", "use_gpu", ":", "\n", "                ", "self", ".", "model", ".", "cuda", "(", ")", "\n", "self", ".", "dtype", "=", "torch", ".", "cuda", ".", "FloatTensor", "\n", "", "else", ":", "\n", "                ", "self", ".", "dtype", "=", "torch", ".", "FloatTensor", "\n", "", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"Only models of type torch.nn.Module are allowed\"", ")", "\n", "\n", "# checking if the input dimension is well defined ", "\n", "", "if", "not", "type", "(", "input_dimension", ")", "is", "int", ":", "\n", "            ", "raise", "TypeError", "(", "\"Only integers are allowed as input dimension\"", ")", "\n", "", "elif", "input_dimension", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input dimension has to be greater than zero\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "input_dimension", "=", "input_dimension", "\n", "\n", "# checking if the output dimension is well defined ", "\n", "", "if", "not", "type", "(", "output_dimension", ")", "is", "int", ":", "\n", "            ", "raise", "TypeError", "(", "\"Only integers are allowed as output dimension\"", ")", "\n", "", "elif", "input_dimension", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input dimension has to be greater than zero\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "output_dimension", "=", "output_dimension", "\n", "\n", "", "if", "isinstance", "(", "pde_loss", ",", "PDELoss", ")", ":", "\n", "            ", "self", ".", "pde_loss", "=", "pde_loss", "\n", "self", ".", "is_hpm", "=", "False", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"PDE loss has to be an instance of a PDE Loss class\"", ")", "\n", "\n", "", "if", "isinstance", "(", "pde_loss", ",", "HPMLoss", ")", ":", "\n", "            ", "self", ".", "is_hpm", "=", "True", "\n", "if", "self", ".", "use_gpu", ":", "\n", "                ", "self", ".", "pde_loss", ".", "hpm_model", ".", "cuda", "(", ")", "\n", "\n", "", "", "if", "isinstance", "(", "initial_condition", ",", "InitialCondition", ")", ":", "\n", "            ", "self", ".", "initial_condition", "=", "initial_condition", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"Initial condition has to be an instance of the InitialCondition class\"", ")", "\n", "\n", "", "if", "not", "len", "(", "initial_condition", ".", "dataset", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Initial condition dataset is empty\"", ")", "\n", "\n", "", "if", "not", "len", "(", "pde_loss", ".", "dataset", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"PDE dataset is empty\"", ")", "\n", "\n", "", "joined_datasets", "=", "{", "\n", "initial_condition", ".", "name", ":", "initial_condition", ".", "dataset", ",", "\n", "pde_loss", ".", "name", ":", "pde_loss", ".", "dataset", "\n", "}", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "            ", "self", ".", "loss_log", "[", "initial_condition", ".", "name", "]", "=", "float", "(", "0.0", ")", "# adding initial condition to the loss_log", "\n", "self", ".", "loss_log", "[", "pde_loss", ".", "name", "]", "=", "float", "(", "0.0", ")", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "'loss'", ")", ":", "\n", "                ", "self", ".", "loss_log", "[", "\"model_loss_pinn\"", "]", "=", "float", "(", "0.0", ")", "\n", "\n", "", "", "if", "not", "self", ".", "is_hpm", ":", "\n", "            ", "if", "type", "(", "boundary_condition", ")", "is", "list", ":", "\n", "                ", "for", "bc", "in", "boundary_condition", ":", "\n", "                    ", "if", "not", "isinstance", "(", "bc", ",", "BoundaryCondition", ")", ":", "\n", "                        ", "raise", "TypeError", "(", "\"Boundary Condition has to be an instance of the BoundaryCondition class \"", ")", "\n", "", "if", "not", "len", "(", "bc", ".", "dataset", ")", ":", "\n", "                        ", "raise", "ValueError", "(", "\"Boundary condition dataset is empty\"", ")", "\n", "", "joined_datasets", "[", "bc", ".", "name", "]", "=", "bc", ".", "dataset", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                        ", "self", ".", "loss_log", "[", "bc", ".", "name", "]", "=", "float", "(", "0.0", ")", "\n", "", "", "self", ".", "boundary_condition", "=", "boundary_condition", "\n", "", "else", ":", "\n", "                ", "if", "isinstance", "(", "boundary_condition", ",", "BoundaryCondition", ")", ":", "\n", "                    ", "self", ".", "boundary_condition", "=", "boundary_condition", "\n", "joined_datasets", "[", "boundary_condition", ".", "name", "]", "=", "boundary_condition", ".", "dataset", "\n", "", "else", ":", "\n", "                    ", "raise", "TypeError", "(", "\"Boundary Condition has to be an instance of the BoundaryCondition class\"", "\n", "\"or a list of instances of the BoundaryCondition class\"", ")", "\n", "", "", "", "self", ".", "dataset", "=", "JoinedDataset", "(", "joined_datasets", ",", "dataset_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.loss_gradients": [[146, 154], ["torch.device", "torch.device", "torch.device", "torch.device", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.autograd.grad", "torch.autograd.grad", "PINN.PINN.model.parameters", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "elem.view"], "methods", ["None"], ["", "def", "loss_gradients", "(", "self", ",", "loss", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "self", ".", "use_gpu", "else", "\"cpu\"", ")", "\n", "grad_", "=", "torch", ".", "zeros", "(", "(", "0", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "model_grads", "=", "grad", "(", "loss", ",", "self", ".", "model", ".", "parameters", "(", ")", ",", "allow_unused", "=", "True", ",", "retain_graph", "=", "True", ")", "\n", "for", "elem", "in", "model_grads", ":", "\n", "            ", "if", "elem", "is", "not", "None", ":", "\n", "                ", "grad_", "=", "torch", ".", "cat", "(", "(", "grad_", ",", "elem", ".", "view", "(", "-", "1", ")", ")", ")", "\n", "", "", "return", "grad_", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.forward": [[155, 160], ["PINN.PINN.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Predicting the solution at given pos\n        \"\"\"", "\n", "return", "self", ".", "model", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.save_model": [[161, 176], ["isinstance", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "ValueError", "PINN.PINN.model.state_dict", "PINN.PINN.pde_loss.hpm_model.state_dict", "PINN.PINN.model.state_dict"], "methods", ["None"], ["", "def", "save_model", "(", "self", ",", "pinn_path", ",", "hpm_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Saves the state dict of the models. Differs between HPM and Model\n\n        Args:\n            pinn_path: path where the pinn get stored\n            hpm_path: path where the HPM get stored\n        \"\"\"", "\n", "if", "isinstance", "(", "self", ".", "pde_loss", ",", "HPMLoss", ")", ":", "\n", "            ", "if", "hpm_path", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"Saving path for the HPM has to be defined\"", ")", "\n", "", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "pinn_path", ")", "\n", "torch", ".", "save", "(", "self", ".", "pde_loss", ".", "hpm_model", ".", "state_dict", "(", ")", ",", "hpm_path", ")", "\n", "", "else", ":", "\n", "            ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "pinn_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.load_model": [[177, 192], ["isinstance", "PINN.PINN.model.load_state_dict", "PINN.PINN.pde_loss.hpm_model.load_state_dict", "PINN.PINN.model.load_state_dict", "ValueError", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["None"], ["", "", "def", "load_model", "(", "self", ",", "pinn_path", ",", "hpm_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Load the state dict of the models. Differs between HPM and Model\n\n        Args:\n            pinn_path: path from where the pinn get loaded\n            hpm_path: path from where the HPM get loaded\n        \"\"\"", "\n", "if", "isinstance", "(", "self", ".", "pde_loss", ",", "HPMLoss", ")", ":", "\n", "            ", "if", "hpm_path", "is", "None", ":", "\n", "                ", "raise", "ValueError", "(", "\"Loading path for the HPM has to be defined\"", ")", "\n", "", "self", ".", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "pinn_path", ")", ")", "\n", "self", ".", "pde_loss", ".", "hpm_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "hpm_path", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "pinn_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.calculate_boundary_condition": [[193, 259], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "ValueError", "isinstance", "boundary_condition", "ValueError", "isinstance", "boundary_condition", "ValueError", "ValueError", "ValueError", "len", "boundary_condition", "ValueError", "len", "boundary_condition", "ValueError", "len", "boundary_condition", "ValueError", "[].type", "[].type", "training_data.type", "training_data.type", "[].type", "[].type", "[].type", "[].type"], "methods", ["None"], ["", "", "def", "calculate_boundary_condition", "(", "self", ",", "boundary_condition", ":", "BoundaryCondition", ",", "training_data", ")", ":", "\n", "        ", "\"\"\"\n        This function classifies the boundary condition and calculates the satisfaction\n\n        Args:\n            boundary_condition (BoundaryCondition) : boundary condition to be calculated\n            training_data: training data used for evaluation\n        \"\"\"", "\n", "\n", "if", "isinstance", "(", "boundary_condition", ",", "PeriodicBC", ")", ":", "\n", "# Periodic Boundary Condition", "\n", "            ", "if", "isinstance", "(", "training_data", ",", "list", ")", ":", "\n", "                ", "if", "len", "(", "training_data", ")", "==", "2", ":", "\n", "                    ", "return", "boundary_condition", "(", "training_data", "[", "0", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "training_data", "[", "1", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"The boundary condition {} has to be tuple of coordinates for lower and upper bound\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"The boundary condition {} has to be tuple of coordinates for lower and upper bound\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "if", "isinstance", "(", "boundary_condition", ",", "DirichletBC", ")", ":", "\n", "# Dirchlet Boundary Condition", "\n", "            ", "if", "not", "isinstance", "(", "training_data", ",", "list", ")", ":", "\n", "                ", "return", "boundary_condition", "(", "training_data", ".", "type", "(", "self", ".", "dtype", ")", "[", "0", "]", ",", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"The boundary condition {} should be a tensor of coordinates not a tuple\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "if", "isinstance", "(", "boundary_condition", ",", "NeumannBC", ")", ":", "\n", "# Neumann Boundary Condition", "\n", "            ", "if", "not", "isinstance", "(", "training_data", ",", "list", ")", ":", "\n", "                ", "return", "boundary_condition", "(", "training_data", ".", "type", "(", "self", ".", "dtype", ")", "[", "0", "]", ",", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"The boundary condition {} should be a tensor of coordinates not a tuple\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "if", "isinstance", "(", "boundary_condition", ",", "RobinBC", ")", ":", "\n", "# Robin Boundary Condition", "\n", "            ", "if", "isinstance", "(", "training_data", ",", "list", ")", ":", "\n", "                ", "if", "len", "(", "training_data", ")", "==", "2", ":", "\n", "                    ", "return", "boundary_condition", "(", "training_data", "[", "0", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "training_data", "[", "1", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"The boundary condition {} has to be tuple of coordinates for lower and upper bound\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"The boundary condition {} has to be tuple of coordinates for lower and upper bound\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "\n", "", "", "if", "isinstance", "(", "boundary_condition", ",", "TimeDerivativeBC", ")", ":", "\n", "# Robin Boundary Condition", "\n", "            ", "if", "isinstance", "(", "training_data", ",", "list", ")", ":", "\n", "                ", "if", "len", "(", "training_data", ")", "==", "2", ":", "\n", "                    ", "return", "boundary_condition", "(", "training_data", "[", "0", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "training_data", "[", "1", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "self", ".", "model", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "\"The boundary condition {} has to be tuple of coordinates for input data and gt time derivative\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"The boundary condition {} has to be tuple of coordinates for lower and upper bound\"", ".", "\n", "format", "(", "boundary_condition", ".", "name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.inverse_dirichlet_annealing": [[260, 282], ["max", "isinstance", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "PINN.PINN.loss_gradients_storage.values", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std", "torch.std"], "methods", ["None"], ["", "", "", "def", "inverse_dirichlet_annealing", "(", "self", ",", "alpha", "=", "0.5", ")", ":", "\n", "# calculating maximum std", "\n", "        ", "stds", "=", "[", "torch", ".", "std", "(", "grad_", ")", "for", "grad_", "in", "self", ".", "loss_gradients_storage", ".", "values", "(", ")", "]", "\n", "maximum_std", "=", "max", "(", "stds", ")", "\n", "\n", "# annealing initial condition", "\n", "lambda_ic_head", "=", "maximum_std", "/", "torch", ".", "std", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "initial_condition", ".", "name", "]", ")", "\n", "self", ".", "initial_condition", ".", "weight", "=", "0.5", "*", "self", ".", "initial_condition", ".", "weight", "+", "0.5", "*", "lambda_ic_head", "\n", "\n", "# annealing boundary condition", "\n", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "            ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "# annealing initial condition", "\n", "                ", "lambda_bc_head", "=", "maximum_std", "/", "torch", ".", "std", "(", "self", ".", "loss_gradients_storage", "[", "bc", ".", "name", "]", ")", "\n", "bc", ".", "weight", "=", "0.5", "*", "bc", ".", "weight", "+", "0.5", "*", "lambda_bc_head", "\n", "", "", "else", ":", "\n", "            ", "lambda_bc_head", "=", "maximum_std", "/", "torch", ".", "std", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "boundary_condition", ".", "name", "]", ")", "\n", "self", ".", "boundary_condition", ".", "weight", "=", "0.5", "*", "self", ".", "boundary_condition", ".", "weight", "+", "0.5", "*", "lambda_bc_head", "\n", "\n", "# annealing pde loss", "\n", "", "lambda_pde_head", "=", "maximum_std", "/", "torch", ".", "std", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "pde_loss", ".", "name", "]", ")", "\n", "self", ".", "pde_loss", ".", "weight", "=", "0.5", "*", "self", ".", "pde_loss", ".", "weight", "+", "0.5", "*", "lambda_pde_head", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.standard_learning_rate_annealing": [[283, 302], ["torch.max", "torch.max", "torch.max", "torch.max", "isinstance", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "standard_learning_rate_annealing", "(", "self", ",", "alpha", "=", "0.9", ")", ":", "\n", "# calculating maximum std", "\n", "        ", "maximum_residual", "=", "torch", ".", "max", "(", "torch", ".", "abs", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "pde_loss", ".", "name", "]", ")", ")", "\n", "\n", "# annealing initial condition", "\n", "lambda_ic_head", "=", "maximum_residual", "/", "torch", ".", "mean", "(", "\n", "torch", ".", "abs", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "initial_condition", ".", "name", "]", ")", ")", "\n", "self", ".", "initial_condition", ".", "weight", "=", "(", "1", "-", "alpha", ")", "*", "self", ".", "initial_condition", ".", "weight", "+", "(", "alpha", "*", "lambda_ic_head", ")", "\n", "\n", "# annealing boundary condition", "\n", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "            ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "# annealing initial condition", "\n", "                ", "lambda_bc_head", "=", "maximum_residual", "/", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "self", ".", "loss_gradients_storage", "[", "bc", ".", "name", "]", ")", ")", "\n", "bc", ".", "weight", "=", "(", "1", "-", "alpha", ")", "*", "bc", ".", "weight", "+", "alpha", "*", "lambda_bc_head", "\n", "", "", "else", ":", "\n", "            ", "lambda_bc_head", "=", "maximum_residual", "/", "torch", ".", "mean", "(", "\n", "torch", ".", "abs", "(", "self", ".", "loss_gradients_storage", "[", "self", ".", "boundary_condition", ".", "name", "]", ")", ")", "\n", "self", ".", "boundary_condition", ".", "weight", "=", "(", "1", "-", "alpha", ")", "*", "self", ".", "boundary_condition", ".", "weight", "+", "alpha", "*", "lambda_bc_head", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.pinn_loss": [[303, 386], ["hasattr", "type", "PINN.PINN.pde_loss", "ValueError", "type", "ValueError", "isinstance", "hasattr", "PINN.PINN.inverse_dirichlet_annealing", "[].type", "PINN.PINN.loss_gradients", "len", "PINN.PINN.initial_condition", "ValueError", "PINN.PINN.calculate_boundary_condition", "[].type", "[].type", "PINN.PINN.loss_gradients", "PINN.PINN.calculate_boundary_condition", "PINN.PINN.loss_gradients", "PINN.PINN.loss_gradients"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.inverse_dirichlet_annealing", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.loss_gradients", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.calculate_boundary_condition", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.loss_gradients", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.calculate_boundary_condition", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.loss_gradients", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.loss_gradients"], ["", "", "def", "pinn_loss", "(", "self", ",", "training_data", ",", "track_gradient", "=", "False", ",", "annealing", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Function for calculating the PINN loss. The PINN Loss is a weighted sum of losses for initial and boundary\n        condition and the residual of the PDE\n\n        Args:\n            training_data (Dictionary): Training Data for calculating the PINN loss in form of ta dictionary. The\n            dictionary holds the training data for initial condition at the key \"Initial_Condition\" training data for\n            the PDE at the key \"PDE\" and the data for the boundary condition under the name of the boundary condition\n            track_gradient(Boolean): Activates tracking of the gradinents of the loss terms\n            annealing (Boolean): Activates automatic balancing of the loss terms\n        \"\"\"", "\n", "if", "annealing", "or", "track_gradient", ":", "\n", "            ", "self", ".", "loss_gradients_storage", "=", "{", "}", "# creating an empty dictionary that holds the loss gradients with respect to the weights", "\n", "", "pinn_loss", "=", "0", "\n", "# unpack training data", "\n", "# ============== PDE LOSS ============== \"", "\n", "if", "type", "(", "training_data", "[", "self", ".", "pde_loss", ".", "name", "]", ")", "is", "not", "list", ":", "\n", "            ", "pde_loss", "=", "self", ".", "pde_loss", "(", "training_data", "[", "self", ".", "pde_loss", ".", "name", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "self", ".", "model", ")", "\n", "if", "annealing", "or", "track_gradient", ":", "\n", "                ", "self", ".", "loss_gradients_storage", "[", "self", ".", "pde_loss", ".", "name", "]", "=", "self", ".", "loss_gradients", "(", "pde_loss", ")", "\n", "", "pinn_loss", "=", "pinn_loss", "+", "self", ".", "pde_loss", ".", "weight", "*", "pde_loss", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                ", "self", ".", "loss_log", "[", "self", ".", "pde_loss", ".", "name", "]", "=", "pde_loss", "+", "self", ".", "loss_log", "[", "self", ".", "pde_loss", ".", "name", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Training Data for PDE data is a single tensor consists of residual points \"", ")", "\n", "\n", "# ============== INITIAL CONDITION ============== \"", "\n", "", "if", "type", "(", "training_data", "[", "self", ".", "initial_condition", ".", "name", "]", ")", "is", "list", ":", "\n", "# initial condition loss", "\n", "            ", "if", "len", "(", "training_data", "[", "self", ".", "initial_condition", ".", "name", "]", ")", "==", "2", ":", "\n", "                ", "ic_loss", "=", "self", ".", "initial_condition", "(", "\n", "training_data", "[", "self", ".", "initial_condition", ".", "name", "]", "[", "0", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", ",", "\n", "self", ".", "model", ",", "\n", "training_data", "[", "self", ".", "initial_condition", ".", "name", "]", "[", "1", "]", "[", "0", "]", ".", "type", "(", "self", ".", "dtype", ")", "\n", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                    ", "self", ".", "loss_log", "[", "self", ".", "initial_condition", ".", "name", "]", "=", "self", ".", "loss_log", "[", "self", ".", "initial_condition", ".", "name", "]", "+", "ic_loss", "\n", "", "if", "annealing", "or", "track_gradient", ":", "\n", "                    ", "self", ".", "loss_gradients_storage", "[", "self", ".", "initial_condition", ".", "name", "]", "=", "self", ".", "loss_gradients", "(", "ic_loss", ")", "\n", "\n", "", "pinn_loss", "=", "pinn_loss", "+", "ic_loss", "*", "self", ".", "initial_condition", ".", "weight", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Training Data for initial condition is a tuple (x,y) with x the  input coordinates\"", "\n", "\" and ground truth values y\"", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Training Data for initial condition is a tuple (x,y) with x the input coordinates\"", "\n", "\" and ground truth values y\"", ")", "\n", "\n", "# ============== BOUNDARY CONDITION ============== \"", "\n", "", "if", "not", "self", ".", "is_hpm", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "                ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "                    ", "bc_loss", "=", "self", ".", "calculate_boundary_condition", "(", "bc", ",", "training_data", "[", "bc", ".", "name", "]", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                        ", "self", ".", "loss_log", "[", "bc", ".", "name", "]", "=", "self", ".", "loss_log", "[", "bc", ".", "name", "]", "+", "bc_loss", "\n", "", "if", "annealing", "or", "track_gradient", ":", "\n", "                        ", "self", ".", "loss_gradients_storage", "[", "bc", ".", "name", "]", "=", "self", ".", "loss_gradients", "(", "bc_loss", ")", "\n", "", "pinn_loss", "=", "pinn_loss", "+", "bc_loss", "*", "bc", ".", "weight", "\n", "", "", "else", ":", "\n", "                ", "bc_loss", "=", "self", ".", "calculate_boundary_condition", "(", "self", ".", "boundary_condition", ",", "\n", "training_data", "[", "self", ".", "boundary_condition", ".", "name", "]", ")", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                    ", "self", ".", "loss_log", "[", "self", ".", "boundary_condition", ".", "name", "]", "=", "self", ".", "loss_log", "[", "self", ".", "boundary_condition", ".", "name", "]", "+", "bc_loss", "\n", "", "if", "annealing", "or", "track_gradient", ":", "\n", "                    ", "self", ".", "loss_gradients_storage", "[", "self", ".", "boundary_condition", ".", "name", "]", "=", "self", ".", "loss_gradients", "(", "bc_loss", ")", "\n", "", "pinn_loss", "=", "pinn_loss", "+", "bc_loss", "*", "self", ".", "boundary_condition", ".", "weight", "\n", "\n", "# ============== Model specific losses  ============== \"", "\n", "", "", "if", "hasattr", "(", "self", ".", "model", ",", "'loss'", ")", ":", "\n", "            ", "pinn_loss", "=", "pinn_loss", "+", "self", ".", "model", ".", "loss", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                ", "self", ".", "loss_log", "[", "\"model_loss_pinn\"", "]", "=", "self", ".", "loss_log", "[", "\"model_loss_pinn\"", "]", "+", "self", ".", "model", ".", "loss", "\n", "\n", "", "", "if", "self", ".", "is_hpm", ":", "\n", "            ", "if", "hasattr", "(", "self", ".", "pde_loss", ".", "hpm_model", ",", "'loss'", ")", ":", "\n", "                ", "pinn_loss", "=", "pinn_loss", "+", "self", ".", "pde_loss", ".", "hpm_model", ".", "loss", "\n", "if", "self", ".", "rank", "==", "0", ":", "\n", "                    ", "self", ".", "loss_log", "[", "\"model_loss_hpm\"", "]", "=", "self", ".", "loss_log", "[", "\"model_loss_hpm\"", "]", "+", "self", ".", "pde_loss", ".", "hpm_model", ".", "loss", "\n", "", "", "", "if", "annealing", ":", "\n", "            ", "self", ".", "inverse_dirichlet_annealing", "(", "alpha", "=", "0.5", ")", "\n", "\n", "", "return", "pinn_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.write_checkpoint": [[387, 405], ["optimizer.state_dict", "PINN.PINN.model.state_dict", "isinstance", "torch.save", "torch.save", "torch.save", "torch.save", "PINN.PINN.pde_loss.hpm_model.state_dict"], "methods", ["None"], ["", "def", "write_checkpoint", "(", "self", ",", "checkpoint_path", ",", "epoch", ",", "pretraining", ",", "minimum_pinn_loss", ",", "optimizer", ")", ":", "\n", "        ", "checkpoint", "=", "{", "}", "\n", "checkpoint", "[", "\"epoch\"", "]", "=", "epoch", "\n", "checkpoint", "[", "\"pretraining\"", "]", "=", "pretraining", "\n", "checkpoint", "[", "\"minimum_pinn_loss\"", "]", "=", "minimum_pinn_loss", "\n", "checkpoint", "[", "\"optimizer\"", "]", "=", "optimizer", ".", "state_dict", "(", ")", "\n", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "initial_condition", ".", "name", "]", "=", "self", ".", "initial_condition", ".", "weight", "\n", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "pde_loss", ".", "name", "]", "=", "self", ".", "initial_condition", ".", "weight", "\n", "checkpoint", "[", "\"pinn_model\"", "]", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "            ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "                ", "checkpoint", "[", "\"weight_\"", "+", "bc", ".", "name", "]", "=", "bc", ".", "weight", "\n", "", "", "else", ":", "\n", "            ", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "boundary_condition", ".", "name", "]", "=", "self", ".", "boundary_condition", ".", "weight", "\n", "\n", "", "if", "self", ".", "is_hpm", ":", "\n", "            ", "checkpoint", "[", "\"hpm_model\"", "]", "=", "self", ".", "pde_loss", ".", "hpm_model", ".", "state_dict", "(", ")", "\n", "", "torch", ".", "save", "(", "checkpoint", ",", "checkpoint_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.fit": [[408, 654], ["isinstance", "float", "print", "print", "range", "itertools.chain", "PINN.PINN.model.named_parameters", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "hvd.DistributedOptimizer", "hvd.broadcast_parameters", "isinstance", "hvd.broadcast_optimizer_state", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.load", "torch.load", "torch.load", "torch.load", "isinstance", "PINN.PINN.model.load_state_dict", "torch.optim.LBFGS.load_state_dict", "torch.optim.LBFGS.load_state_dict", "print", "print", "range", "datetime.datetime.datetime.now", "numpy.random.seed", "enumerate", "torch.optim.LBFGS.step", "torch.optim.LBFGS.step", "PINN.PINN.pinn_loss", "print", "isinstance", "ValueError", "list", "list", "PINN.PINN.model.named_parameters", "PINN.PINN.pde_loss.hpm_model.named_parameters", "ValueError", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.distributed.DistributedSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "PINN.PINN.model.state_dict", "hvd.broadcast_parameters", "FileNotFoundError", "PINN.PINN.pde_loss.hpm_model.load_state_dict", "datetime.datetime.datetime.now", "torch.optim.LBFGS.zero_grad", "torch.optim.LBFGS.zero_grad", "PINN.PINN.pinn_loss", "PINN.PINN.backward", "torch.optim.LBFGS.step", "torch.optim.LBFGS.step", "datetime.datetime.datetime.now", "print", "PINN.PINN.loss_log.keys", "PINN.PINN.save_model", "PINN.PINN.model.parameters", "PINN.PINN.pde_loss.hpm_model.parameters", "torch.optim.LBFGS.zero_grad", "torch.optim.LBFGS.zero_grad", "PINN.PINN.pinn_loss", "PINN.PINN.backward", "PINN.PINN.model.parameters", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "PINN.PINN.model.parameters", "torch.optim.LBFGS.zero_grad", "torch.optim.LBFGS.zero_grad", "PINN.PINN.pinn_loss", "PINN.PINN.backward", "hvd.size", "hvd.rank", "PINN.PINN.pde_loss.hpm_model.state_dict", "os.path.exists", "torch.optim.LBFGS.zero_grad", "torch.optim.LBFGS.zero_grad", "PINN.PINN.initial_condition", "PINN.PINN.backward", "torch.optim.LBFGS.step", "torch.optim.LBFGS.step", "PINN.PINN.write_checkpoint", "datetime.datetime.datetime.now", "print", "logger.log_scalar", "logger.log_scalar", "PINN.PINN.loss_log.items", "logger.log_scalar", "logger.log_scalar", "callbacks", "PINN.PINN.save_model", "float", "PINN.PINN.write_checkpoint", "type", "TypeError", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "torch.optim.LBFGS", "PINN.PINN.model.parameters", "hvd.size", "hvd.rank", "logger.log_scalar", "PINN.PINN.loss_gradients_storage.items", "isinstance", "x.type", "y.type", "PINN.PINN.loss_log.items", "logger.log_histogram", "logger.log_scalar", "sum", "gradients.cpu", "logger.log_scalar", "PINN.PINN.loss_log.values"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.pinn_loss", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.pinn_loss", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.save_model", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.pinn_loss", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.pinn_loss", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.write_checkpoint", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.save_model", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.write_checkpoint", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_histogram", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar"], ["", "def", "fit", "(", "self", ",", "\n", "epochs", ",", "\n", "checkpoint_path", "=", "None", ",", "\n", "restart", "=", "False", ",", "\n", "optimizer", "=", "'Adam'", ",", "\n", "learning_rate", "=", "1e-3", ",", "\n", "pretraining", "=", "False", ",", "\n", "epochs_pt", "=", "100", ",", "\n", "lbfgs_finetuning", "=", "True", ",", "\n", "writing_cycle", "=", "30", ",", "\n", "writing_cycle_pt", "=", "30", ",", "\n", "save_model", "=", "True", ",", "\n", "pinn_path", "=", "'best_model_pinn.pt'", ",", "\n", "hpm_path", "=", "'best_model_hpm.pt'", ",", "\n", "logger", "=", "None", ",", "\n", "track_gradient", "=", "False", ",", "\n", "activate_annealing", "=", "False", ",", "\n", "annealing_cycle", "=", "100", ",", "\n", "callbacks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Function for optimizing the parameters of the PINN-Model\n\n        Args:\n            epochs (int) : number of epochs used for training\n            optimizer (String, torch.optim.Optimizer) : Optimizer used for training. At the moment only ADAM and LBFGS\n            are supported by string command. It is also possible to give instances of torch optimizers as a parameter\n            learning_rate: The learning rate of the optimizer\n            pretraining: Activates seperate training on the initial condition at the beginning\n            epochs_pt: defines the number of epochs for the pretraining\n            lbfgs_finetuning: Enables LBFGS finetuning after main training\n            writing_cycle: defines the cylcus of model writing\n            writing_cycle_pt: defines the cylcus of model writing in pretraining phase\n            save_model: enables or disables checkpointing\n            pinn_path: defines the path where the pinn get stored\n            hpm_path: defines the path where the hpm get stored\n            logger (Logger): tracks the convergence of all loss terms\n            track_gradient: activates tracking of histograms and write it to logger\n            activate_annealing (Boolean): enables annealing\n            annealing_cycle (int): defines the periodicity of using annealing\n            callbacks (CallbackList): is a list of callbacks which are called at the end of a writing cycle. Can be used\n            for different purposes e.g. early stopping, visualization, model state logging etc.\n            checkpoint_path (string) : path to the checkpoint\n            restart (integer) : defines if checkpoint will be used (False) or will be overwritten (True)\n\n\n        \"\"\"", "\n", "# checking if callbacks are a instance of CallbackList", "\n", "if", "callbacks", "is", "not", "None", ":", "\n", "            ", "if", "not", "isinstance", "(", "callbacks", ",", "CallbackList", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Callbacks has to be a instance of CallbackList but type {} was found\"", ".", "\n", "format", "(", "type", "(", "callbacks", ")", ")", ")", "\n", "\n", "", "", "if", "isinstance", "(", "self", ".", "pde_loss", ",", "HPMLoss", ")", ":", "\n", "            ", "params", "=", "list", "(", "self", ".", "model", ".", "parameters", "(", ")", ")", "+", "list", "(", "self", ".", "pde_loss", ".", "hpm_model", ".", "parameters", "(", ")", ")", "\n", "named_parameters", "=", "chain", "(", "self", ".", "model", ".", "named_parameters", "(", ")", ",", "self", ".", "pde_loss", ".", "hpm_model", ".", "named_parameters", "(", ")", ")", "\n", "if", "self", ".", "use_horovod", "and", "lbfgs_finetuning", ":", "\n", "                ", "raise", "ValueError", "(", "\"LBFGS Finetuning is not possible with horovod\"", ")", "\n", "", "if", "optimizer", "==", "'Adam'", ":", "\n", "                ", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "params", ",", "lr", "=", "learning_rate", ")", "\n", "", "elif", "optimizer", "==", "'LBFGS'", ":", "\n", "                ", "if", "self", ".", "use_horovod", ":", "\n", "                    ", "raise", "TypeError", "(", "\"LBFGS is not supported with Horovod\"", ")", "\n", "", "else", ":", "\n", "                    ", "optim", "=", "torch", ".", "optim", ".", "LBFGS", "(", "params", ",", "lr", "=", "learning_rate", ")", "\n", "", "", "else", ":", "\n", "                ", "optim", "=", "optimizer", "\n", "\n", "", "if", "lbfgs_finetuning", "and", "not", "self", ".", "use_horovod", ":", "\n", "                ", "lbfgs_optim", "=", "torch", ".", "optim", ".", "LBFGS", "(", "params", ",", "lr", "=", "0.9", ")", "\n", "\n", "def", "closure", "(", ")", ":", "\n", "                    ", "lbfgs_optim", ".", "zero_grad", "(", ")", "\n", "pinn_loss", "=", "self", ".", "pinn_loss", "(", "training_data", ")", "\n", "pinn_loss", ".", "backward", "(", ")", "\n", "return", "pinn_loss", "\n", "", "", "", "else", ":", "\n", "            ", "named_parameters", "=", "self", ".", "model", ".", "named_parameters", "(", ")", "\n", "if", "optimizer", "==", "'Adam'", ":", "\n", "                ", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "learning_rate", ")", "\n", "", "elif", "optimizer", "==", "'LBFGS'", ":", "\n", "                ", "optim", "=", "torch", ".", "optim", ".", "LBFGS", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "learning_rate", ")", "\n", "", "else", ":", "\n", "                ", "optim", "=", "optimizer", "\n", "\n", "", "if", "lbfgs_finetuning", "and", "not", "self", ".", "use_horovod", ":", "\n", "                ", "lbfgs_optim", "=", "torch", ".", "optim", ".", "LBFGS", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "0.9", ")", "\n", "\n", "def", "closure", "(", ")", ":", "\n", "                    ", "lbfgs_optim", ".", "zero_grad", "(", ")", "\n", "pinn_loss", "=", "self", ".", "pinn_loss", "(", "training_data", ")", "\n", "pinn_loss", ".", "backward", "(", ")", "\n", "return", "pinn_loss", "\n", "\n", "", "", "", "minimum_pinn_loss", "=", "float", "(", "\"inf\"", ")", "\n", "if", "self", ".", "use_horovod", ":", "\n", "# Partition dataset among workers using DistributedSampler", "\n", "            ", "train_sampler", "=", "torch", ".", "utils", ".", "data", ".", "distributed", ".", "DistributedSampler", "(", "\n", "self", ".", "dataset", ",", "num_replicas", "=", "hvd", ".", "size", "(", ")", ",", "rank", "=", "hvd", ".", "rank", "(", ")", "\n", ")", "\n", "data_loader", "=", "DataLoader", "(", "self", ".", "dataset", ",", "batch_size", "=", "1", ",", "sampler", "=", "train_sampler", ",", "worker_init_fn", "=", "worker_init_fn", ")", "\n", "optim", "=", "hvd", ".", "DistributedOptimizer", "(", "optim", ",", "named_parameters", "=", "named_parameters", ")", "\n", "if", "pretraining", ":", "\n", "                ", "train_sampler_pt", "=", "torch", ".", "utils", ".", "data", ".", "distributed", ".", "DistributedSampler", "(", "\n", "self", ".", "initial_condition", ".", "dataset", ",", "num_replicas", "=", "hvd", ".", "size", "(", ")", ",", "rank", "=", "hvd", ".", "rank", "(", ")", "\n", ")", "\n", "data_loader_pt", "=", "DataLoader", "(", "self", ".", "initial_condition", ".", "dataset", ",", "\n", "batch_size", "=", "None", ",", "\n", "sampler", "=", "train_sampler_pt", ",", "\n", "worker_init_fn", "=", "worker_init_fn", ")", "\n", "# Broadcast parameters from rank 0 to all other processes.", "\n", "", "hvd", ".", "broadcast_parameters", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "root_rank", "=", "0", ")", "\n", "if", "isinstance", "(", "self", ".", "pde_loss", ",", "HPMLoss", ")", ":", "\n", "                ", "hvd", ".", "broadcast_parameters", "(", "self", ".", "pde_loss", ".", "hpm_model", ".", "state_dict", "(", ")", ",", "root_rank", "=", "0", ")", "\n", "", "hvd", ".", "broadcast_optimizer_state", "(", "optim", ",", "root_rank", "=", "0", ")", "\n", "\n", "", "else", ":", "\n", "            ", "data_loader", "=", "DataLoader", "(", "self", ".", "dataset", ",", "batch_size", "=", "1", ",", "worker_init_fn", "=", "worker_init_fn", ")", "\n", "data_loader_pt", "=", "DataLoader", "(", "self", ".", "initial_condition", ".", "dataset", ",", "batch_size", "=", "None", ",", "worker_init_fn", "=", "worker_init_fn", ")", "\n", "\n", "", "start_epoch", "=", "0", "\n", "\n", "# load checkpoint routine if a checkpoint path is set and its allowed to not overwrite the checkpoint", "\n", "if", "checkpoint_path", "is", "not", "None", ":", "\n", "            ", "if", "not", "exists", "(", "checkpoint_path", ")", "and", "not", "restart", ":", "\n", "                ", "raise", "FileNotFoundError", "(", "\n", "\"Checkpoint path {} do not exists. Please change the path to a existing checkpoint\"", "\n", "\"or change the restart flag to true in order to create a new checkpoint\"", "\n", ".", "format", "(", "checkpoint_path", ")", ")", "\n", "", "", "if", "checkpoint_path", "is", "not", "None", "and", "restart", "==", "0", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "checkpoint_path", ")", "\n", "start_epoch", "=", "checkpoint", "[", "\"epoch\"", "]", "\n", "pretraining", "=", "checkpoint", "[", "\"pretraining\"", "]", "\n", "self", ".", "initial_condition", ".", "weight", "=", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "initial_condition", ".", "name", "]", "\n", "self", ".", "pde_loss", ".", "weight", "=", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "pde_loss", ".", "name", "]", "\n", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "                ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "                    ", "bc", ".", "weight", "=", "checkpoint", "[", "\"weight_\"", "+", "bc", ".", "name", "]", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "boundary_condition", ".", "weight", "=", "checkpoint", "[", "\"weight_\"", "+", "self", ".", "boundary_condition", ".", "name", "]", "\n", "\n", "", "self", ".", "model", ".", "load_state_dict", "(", "checkpoint", "[", "\"pinn_model\"", "]", ")", "\n", "if", "self", ".", "is_hpm", ":", "\n", "                ", "self", ".", "pde_loss", ".", "hpm_model", ".", "load_state_dict", "(", "checkpoint", "[", "\"hpm_model\"", "]", ")", "\n", "\n", "", "optim", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "minimum_pinn_loss", "=", "checkpoint", "[", "\"minimum_pinn_loss\"", "]", "\n", "print", "(", "\"Checkpoint Loaded\"", ",", "flush", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Checkpoint not loaded\"", ",", "flush", "=", "True", ")", "\n", "\n", "", "print", "(", "\"===== Pretraining =====\"", ")", "\n", "if", "pretraining", ":", "\n", "            ", "for", "epoch", "in", "range", "(", "start_epoch", ",", "epochs_pt", ")", ":", "\n", "                ", "epoch_start_time", "=", "datetime", ".", "now", "(", ")", "\n", "for", "x", ",", "y", "in", "data_loader_pt", ":", "\n", "                    ", "optim", ".", "zero_grad", "(", ")", "\n", "ic_loss", "=", "self", ".", "initial_condition", "(", "model", "=", "self", ".", "model", ",", "x", "=", "x", ".", "type", "(", "self", ".", "dtype", ")", ",", "gt_y", "=", "y", ".", "type", "(", "self", ".", "dtype", ")", ")", "\n", "ic_loss", ".", "backward", "(", ")", "\n", "optim", ".", "step", "(", ")", "\n", "", "if", "not", "self", ".", "rank", "and", "not", "(", "epoch", "+", "1", ")", "%", "writing_cycle_pt", "and", "checkpoint_path", "is", "not", "None", ":", "\n", "                    ", "self", ".", "write_checkpoint", "(", "checkpoint_path", ",", "epoch", ",", "True", ",", "minimum_pinn_loss", ",", "optim", ")", "\n", "", "if", "not", "self", ".", "rank", ":", "\n", "                    ", "epoch_end_time", "=", "datetime", ".", "now", "(", ")", "\n", "time_taken", "=", "(", "epoch_end_time", "-", "epoch_start_time", ")", ".", "total_seconds", "(", ")", "\n", "print", "(", "\"[{}]:Epoch {:2d}/{} | IC Loss {:.15f} | Epoch Duration {:.5f}\"", "\n", ".", "format", "(", "epoch_end_time", ",", "epoch", "+", "1", ",", "epochs_pt", ",", "ic_loss", ",", "time_taken", ")", ")", "\n", "", "", "", "print", "(", "\"===== Main training =====\"", ")", "\n", "for", "epoch", "in", "range", "(", "start_epoch", ",", "epochs", ")", ":", "\n", "            ", "epoch_start_time", "=", "datetime", ".", "now", "(", ")", "\n", "# for parallel training the rank should also define the seed", "\n", "np", ".", "random", ".", "seed", "(", "42", "+", "epoch", "+", "self", ".", "rank", ")", "\n", "batch_counter", "=", "0.", "\n", "pinn_loss_sum", "=", "0.", "\n", "for", "idx", ",", "training_data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "                ", "do_annealing", "=", "activate_annealing", "and", "not", "(", "epoch", "+", "1", ")", "%", "annealing_cycle", "and", "idx", "==", "0", "\n", "do_gradient_tracking", "=", "track_gradient", "and", "not", "(", "epoch", "+", "1", ")", "%", "writing_cycle", "and", "idx", "==", "0", "\n", "optim", ".", "zero_grad", "(", ")", "\n", "pinn_loss", "=", "self", ".", "pinn_loss", "(", "training_data", ",", "do_gradient_tracking", ",", "do_annealing", ")", "\n", "pinn_loss", ".", "backward", "(", ")", "\n", "optim", ".", "step", "(", ")", "\n", "pinn_loss_sum", "=", "pinn_loss_sum", "+", "pinn_loss", "\n", "batch_counter", "+=", "1", "\n", "del", "pinn_loss", "\n", "\n", "", "if", "not", "self", ".", "rank", ":", "\n", "                ", "epoch_end_time", "=", "datetime", ".", "now", "(", ")", "\n", "time_taken", "=", "(", "epoch_end_time", "-", "epoch_start_time", ")", ".", "total_seconds", "(", ")", "\n", "all_losses", "=", "\" | \"", ".", "join", "(", "\n", "[", "\"{} loss: {:.6f}\"", ".", "format", "(", "key", ",", "value", "/", "batch_counter", ")", "for", "key", ",", "value", "in", "self", ".", "loss_log", ".", "items", "(", ")", "]", ")", "\n", "print", "(", "\"[{}]:Epoch {:2d}/{} | PINN Loss {:.10f} | {} | Epoch Duration {:.5f}\"", "\n", ".", "format", "(", "epoch_end_time", ",", "epoch", "+", "1", ",", "epochs", ",", "pinn_loss_sum", "/", "batch_counter", ",", "all_losses", ",", "time_taken", ")", ",", "\n", "flush", "=", "True", "\n", ")", "\n", "\n", "if", "logger", "is", "not", "None", "and", "not", "(", "epoch", "+", "1", ")", "%", "writing_cycle", ":", "\n", "                    ", "logger", ".", "log_scalar", "(", "scalar", "=", "pinn_loss_sum", "/", "batch_counter", ",", "name", "=", "\" Weighted PINN Loss\"", ",", "epoch", "=", "epoch", "+", "1", ")", "\n", "logger", ".", "log_scalar", "(", "scalar", "=", "sum", "(", "self", ".", "loss_log", ".", "values", "(", ")", ")", "/", "batch_counter", ",", "\n", "name", "=", "\" Non-Weighted PINN Loss\"", ",", "epoch", "=", "epoch", "+", "1", ")", "\n", "# Log values of the loss terms", "\n", "for", "key", ",", "value", "in", "self", ".", "loss_log", ".", "items", "(", ")", ":", "\n", "                        ", "logger", ".", "log_scalar", "(", "scalar", "=", "value", "/", "batch_counter", ",", "name", "=", "key", ",", "epoch", "=", "epoch", "+", "1", ")", "\n", "\n", "# Log weights of loss terms separately", "\n", "", "logger", ".", "log_scalar", "(", "scalar", "=", "self", ".", "initial_condition", ".", "weight", ",", "\n", "name", "=", "self", ".", "initial_condition", ".", "name", "+", "\"_weight\"", ",", "\n", "epoch", "=", "epoch", "+", "1", ")", "\n", "# Log weights of PDE LOss", "\n", "logger", ".", "log_scalar", "(", "scalar", "=", "self", ".", "pde_loss", ".", "weight", ",", "\n", "name", "=", "self", ".", "pde_loss", ".", "name", "+", "'_weight'", ",", "\n", "epoch", "=", "epoch", "+", "1", ")", "\n", "# track gradients of loss terms as histogram", "\n", "if", "activate_annealing", "or", "track_gradient", ":", "\n", "                        ", "for", "key", ",", "gradients", "in", "self", ".", "loss_gradients_storage", ".", "items", "(", ")", ":", "\n", "                            ", "logger", ".", "log_histogram", "(", "gradients", ".", "cpu", "(", ")", ",", "\n", "'gradients_'", "+", "key", ",", "\n", "epoch", "+", "1", ")", "\n", "", "", "if", "not", "self", ".", "is_hpm", ":", "\n", "                        ", "if", "isinstance", "(", "self", ".", "boundary_condition", ",", "list", ")", ":", "\n", "                            ", "for", "bc", "in", "self", ".", "boundary_condition", ":", "\n", "                                ", "logger", ".", "log_scalar", "(", "scalar", "=", "bc", ".", "weight", ",", "\n", "name", "=", "bc", ".", "name", "+", "\"_weight\"", ",", "\n", "epoch", "=", "epoch", "+", "1", ")", "\n", "", "", "else", ":", "\n", "                            ", "logger", ".", "log_scalar", "(", "scalar", "=", "self", ".", "boundary_condition", ".", "weight", ",", "\n", "name", "=", "self", ".", "boundary_condition", ".", "name", "+", "\"_weight\"", ",", "\n", "epoch", "=", "epoch", "+", "1", ")", "\n", "", "", "", "if", "callbacks", "is", "not", "None", "and", "not", "(", "epoch", "+", "1", ")", "%", "writing_cycle", ":", "\n", "                    ", "callbacks", "(", "epoch", "=", "epoch", "+", "1", ")", "\n", "# saving routine", "\n", "", "if", "(", "pinn_loss_sum", "/", "batch_counter", "<", "minimum_pinn_loss", ")", "and", "save_model", ":", "\n", "                    ", "self", ".", "save_model", "(", "pinn_path", ",", "hpm_path", ")", "\n", "minimum_pinn_loss", "=", "pinn_loss_sum", "/", "batch_counter", "\n", "\n", "# reset loss log after the end of the epoch", "\n", "", "for", "key", "in", "self", ".", "loss_log", ".", "keys", "(", ")", ":", "\n", "                    ", "self", ".", "loss_log", "[", "key", "]", "=", "float", "(", "0", ")", "\n", "\n", "# writing checkpoint", "\n", "", "if", "not", "(", "epoch", "+", "1", ")", "%", "writing_cycle", "and", "checkpoint_path", "is", "not", "None", ":", "\n", "                    ", "self", ".", "write_checkpoint", "(", "checkpoint_path", ",", "epoch", ",", "False", ",", "minimum_pinn_loss", ",", "optim", ")", "\n", "", "", "", "if", "lbfgs_finetuning", ":", "\n", "            ", "lbfgs_optim", ".", "step", "(", "closure", ")", "\n", "pinn_loss", "=", "self", ".", "pinn_loss", "(", "training_data", ")", "\n", "print", "(", "\"After LBFGS-B: PINN Loss: {} Epoch {} from {}\"", ".", "format", "(", "pinn_loss", ",", "epoch", "+", "1", ",", "epochs", ")", ")", "\n", "if", "(", "pinn_loss", "<", "minimum_pinn_loss", ")", "and", "not", "(", "epoch", "%", "writing_cycle", ")", "and", "save_model", ":", "\n", "                ", "self", ".", "save_model", "(", "pinn_path", ",", "hpm_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.PINN.take_snapshot": [[655, 677], ["torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.cat().view().to", "torch.cat().view().to", "torch.cat().view().to", "torch.cat().view().to", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "output.view().to().numpy.view().to().numpy.view().to().numpy", "imageToVTK", "len", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "x.numpy", "y.numpy", "z.numpy", "range", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "output.view().to().numpy.view().to().numpy.view().to", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model", "output.view().to().numpy.view().to().numpy.view", "range", "x.unsqueeze", "y.unsqueeze", "z.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "", "", "def", "take_snapshot", "(", "model", ",", "file_path", ",", "device", ",", "n_points", ")", ":", "\n", "        ", "\"\"\"\n        Calculates a model output on a regular 3D grid and saves it as a VTK data.\n        Args:\n            model (nn.Module): a model predicting a scalar. It must have 'lb' and 'ub' attributes.\n            file_path (str): a path of a file where VTK data will be saved.\n            device (str): the device where the given model is located.\n            n_points ([int,int,int]): number of points along each axis in the grid.        \n        \"\"\"", "\n", "assert", "len", "(", "model", ".", "lb", ")", "==", "3", "# Implemented only for 3D grid", "\n", "from", "pyevtk", ".", "hl", "import", "imageToVTK", "\n", "# evenly spaced numbers over a inteval specified by model.lb and model.ub ", "\n", "x", ",", "y", ",", "z", "=", "[", "torch", ".", "linspace", "(", "model", ".", "lb", "[", "i", "]", ",", "model", ".", "ub", "[", "i", "]", ",", "n_points", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "model", ".", "lb", ")", ")", "]", "\n", "x", ",", "y", ",", "z", "=", "torch", ".", "meshgrid", "(", "x", ",", "y", ",", "z", ")", "\n", "# create an input of shape [# points, 3]", "\n", "input", "=", "torch", ".", "cat", "(", "[", "x", ".", "unsqueeze", "(", "-", "1", ")", ",", "y", ".", "unsqueeze", "(", "-", "1", ")", ",", "z", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "-", "1", ")", ".", "view", "(", "-", "1", ",", "3", ")", ".", "to", "(", "device", ")", "\n", "# calculate the model output via minibatches of size 64", "\n", "output", "=", "torch", ".", "cat", "(", "[", "model", "(", "input", "[", "k", "*", "64", ":", "(", "k", "+", "1", ")", "*", "64", "]", ")", "for", "k", "in", "range", "(", "(", "input", ".", "shape", "[", "0", "]", "//", "64", "+", "1", ")", ")", "]", ",", "0", ")", ".", "view", "(", "-", "1", ")", "\n", "# convert all tensors to numpy arrays and save as VTK data", "\n", "grid", "=", "[", "x", ".", "numpy", "(", ")", ",", "y", ".", "numpy", "(", ")", ",", "z", ".", "numpy", "(", ")", "]", "\n", "output", "=", "output", ".", "view", "(", "n_points", ")", ".", "to", "(", "'cpu'", ")", ".", "numpy", "(", ")", "\n", "imageToVTK", "(", "file_path", ",", "grid", ",", "pointData", "=", "{", "\"model output\"", ":", "output", "}", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PINN.worker_init_fn": [[26, 28], ["numpy.random.seed", "numpy.random.get_state"], "function", ["None"], ["def", "worker_init_fn", "(", "worker_id", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "np", ".", "random", ".", "get_state", "(", ")", "[", "1", "]", "[", "0", "]", "+", "worker_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.min_length": [[8, 21], ["float", "datasets.keys", "len"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "min_length", "(", "datasets", ")", ":", "\n", "        ", "\"\"\"\n        Calculates the minimum dataset length of a list of datasets\n\n        datasets (Map): Map of datasets to be concatenated\n        \"\"\"", "\n", "minimum", "=", "float", "(", "\"inf\"", ")", "\n", "for", "key", "in", "datasets", ".", "keys", "(", ")", ":", "\n", "            ", "length", "=", "len", "(", "datasets", "[", "key", "]", ")", "\n", "if", "length", "<", "minimum", ":", "\n", "                ", "minimum", "=", "length", "\n", "", "", "return", "minimum", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.max_length": [[22, 35], ["datasets.keys", "float", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "max_length", "(", "datasets", ")", ":", "\n", "        ", "\"\"\"\n        Calculates the minimum dataset length of a list of datasets\n\n        datasets (Map): Map of datasets to be concatenated\n        \"\"\"", "\n", "maximum", "=", "-", "1", "*", "float", "(", "\"inf\"", ")", "\n", "for", "key", "in", "datasets", ".", "keys", "(", ")", ":", "\n", "            ", "length", "=", "len", "(", "datasets", "[", "key", "]", ")", "\n", "if", "length", ">", "maximum", ":", "\n", "                ", "maximum", "=", "length", "\n", "", "", "return", "maximum", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.__init__": [[36, 40], ["torch.utils.data.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["", "def", "__init__", "(", "self", ",", "datasets", ",", "mode", "=", "'min'", ")", ":", "\n", "        ", "super", "(", "JoinedDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "mode", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.__len__": [[41, 46], ["JoinedDataset.JoinedDataset.min_length", "JoinedDataset.JoinedDataset.max_length"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.min_length", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.max_length"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "'min'", ":", "\n", "            ", "return", "self", ".", "min_length", "(", "self", ".", "datasets", ")", "\n", "", "if", "self", ".", "mode", "==", "'max'", ":", "\n", "            ", "return", "self", ".", "max_length", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.__getitem__": [[47, 58], ["JoinedDataset.JoinedDataset.datasets.keys", "len", "ValueError", "len"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "idx", "<", "0", ":", "\n", "            ", "if", "-", "idx", ">", "len", "(", "self", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"absolute value of index should not exceed dataset length\"", ")", "\n", "", "", "combined_item", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "datasets", ".", "keys", "(", ")", ":", "\n", "            ", "if", "self", ".", "mode", "==", "'max'", ":", "\n", "                ", "idx", "=", "idx", "%", "len", "(", "self", ".", "datasets", "[", "key", "]", ")", "\n", "", "item", "=", "self", ".", "datasets", "[", "key", "]", "[", "idx", "]", "\n", "combined_item", "[", "key", "]", "=", "item", "\n", "", "return", "combined_item", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.JoinedDataset.JoinedDataset.register_dataset": [[59, 63], ["print"], "methods", ["None"], ["", "def", "register_dataset", "(", "self", ",", "key", ",", "dataset", ")", ":", "\n", "        ", "if", "key", "in", "self", ".", "datasets", ":", "\n", "            ", "print", "(", "\"Key already exists. Dataset will be overwritten\"", ")", "\n", "", "self", ".", "datasets", "[", "key", "]", "=", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.Logger_Interface.LoggerInterface.log_scalar": [[6, 18], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "log_scalar", "(", "self", ",", "scalar", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Method that defines how scalars are logged\n\n        Args:\n            scalar: scalar to be logged\n            name: name of the scalar\n            epoch: epoch in the training loop\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.Logger_Interface.LoggerInterface.log_image": [[19, 31], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "log_image", "(", "self", ",", "image", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Method that defines how images are logged\n\n        Args:\n            image: image to be logged\n            name: name of the image\n            epoch: epoch in the training loop\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.Logger_Interface.LoggerInterface.log_histogram": [[32, 44], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "log_histogram", "(", "self", ",", "histogram", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Method that defines how images are logged\n\n        Args:\n            histogram: histogram to be logged\n            name: name of the histogram\n            epoch: epoch in the training loop\n\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.BoundaryCondition.__init__": [[7, 9], ["LossTerm.LossTerm.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "super", "(", "BoundaryCondition", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.BoundaryCondition.__call__": [[10, 12], ["NotImplementedError"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"The call function of the Boundary Condition has to be implemented\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.DirichletBC.__init__": [[19, 22], ["BoundaryCondition.BoundaryCondition.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "func", ",", "dataset", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "super", "(", "DirichletBC", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "self", ".", "func", "=", "func", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.DirichletBC.__call__": [[23, 26], ["model", "BoundaryCondition.DirichletBC.norm", "BoundaryCondition.DirichletBC.func"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "model", ")", ":", "\n", "        ", "prediction", "=", "model", "(", "x", ")", "# is equal to y", "\n", "return", "self", ".", "norm", "(", "prediction", ",", "self", ".", "func", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.NeumannBC.__init__": [[35, 52], ["BoundaryCondition.BoundaryCondition.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "func", ",", "dataset", ",", "normal_vector", ",", "begin", ",", "end", ",", "output_dimension", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            func: scalar but vectorized function f(x)\n            normal_vector: normal vector for the face\n            name: identifier of the boundary condition\n            weight: weighting of the boundary condition\n            begin: defines the begin of spatial variables in x\n            end: defines the end of the spatial domain in x\n            output_dimension defines on which dimension of the output the boundary condition performed\n        \"\"\"", "\n", "super", "(", "NeumannBC", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "self", ".", "func", "=", "func", "\n", "self", ".", "normal_vector", "=", "normal_vector", "\n", "self", ".", "begin", "=", "begin", "\n", "self", ".", "end", "=", "end", "\n", "self", ".", "output_dimension", "=", "output_dimension", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.NeumannBC.__call__": [[53, 63], ["model", "torch.ones", "BoundaryCondition.NeumannBC.normal_vector.to", "BoundaryCondition.NeumannBC.norm", "torch.autograd.grad", "BoundaryCondition.NeumannBC.func"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "__call__", "(", "self", ",", "x", ",", "model", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", "=", "model", "(", "x", ")", "\n", "y", "=", "y", "[", ":", ",", "self", ".", "output_dimension", "]", "\n", "grads", "=", "ones", "(", "y", ".", "shape", ",", "device", "=", "y", ".", "device", ")", "\n", "grad_y", "=", "grad", "(", "y", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "grad_y", "=", "grad_y", "[", ":", ",", "self", ".", "begin", ":", "self", ".", "end", "]", "\n", "self", ".", "normal_vector", ".", "to", "(", "y", ".", "device", ")", "# move normal vector to the correct device", "\n", "y_dn", "=", "grad_y", "@", "self", ".", "normal_vector", "\n", "return", "self", ".", "norm", "(", "y_dn", ",", "self", ".", "func", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.RobinBC.__init__": [[70, 88], ["BoundaryCondition.BoundaryCondition.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "func", ",", "dataset", ",", "normal_vector", ",", "begin", ",", "end", ",", "output_dimension", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n            Args:\n                func: scalar but vectorized function f(x,y)\n                normal_vector: normal vector for the face\n                name: identifier of the boundary condition\n                weight: weighting of the boundary condition\n                begin: defines the begin of spatial variables in x\n                end: defines the end of the spatial domain in x\n                output_dimension defines on which dimension of the output the boundary condition performed\n        \"\"\"", "\n", "\n", "super", "(", "RobinBC", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "self", ".", "func", "=", "func", "\n", "self", ".", "begin", "=", "begin", "\n", "self", ".", "end", "=", "end", "\n", "self", ".", "normal_vector", "=", "normal_vector", "\n", "self", ".", "output_dimension", "=", "output_dimension", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.RobinBC.__call__": [[89, 99], ["model", "torch.ones", "BoundaryCondition.RobinBC.normal_vector.to", "BoundaryCondition.RobinBC.norm", "torch.autograd.grad", "BoundaryCondition.RobinBC.func"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "__call__", "(", "self", ",", "x", ",", "y", ",", "model", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "y", "=", "model", "(", "x", ")", "\n", "y", "=", "y", "[", ":", ",", "self", ".", "output_dimension", "]", "\n", "grads", "=", "ones", "(", "y", ".", "shape", ",", "device", "=", "y", ".", "device", ")", "\n", "grad_y", "=", "grad", "(", "y", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "grad_y", "=", "grad_y", "[", ":", ",", "self", ".", "begin", ":", "self", ".", "end", "]", "\n", "self", ".", "normal_vector", ".", "to", "(", "y", ".", "device", ")", "# move normal vector to the correct device", "\n", "y_dn", "=", "grad_y", "@", "self", ".", "normal_vector", "\n", "return", "self", ".", "norm", "(", "y_dn", ",", "self", ".", "func", "(", "x", ",", "y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.PeriodicBC.__init__": [[106, 114], ["BoundaryCondition.BoundaryCondition.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "dataset", ",", "output_dimension", ",", "name", ",", "degree", "=", "None", ",", "input_dimension", "=", "None", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "super", "(", "PeriodicBC", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "if", "degree", "is", "not", "None", "and", "input_dimension", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"If the degree of the boundary condition is defined the input dimension for the \"", "\n", "\"derivative has to be defined too \"", ")", "\n", "", "self", ".", "input_dimension", "=", "input_dimension", "\n", "self", ".", "output_dimension", "=", "output_dimension", "\n", "self", ".", "degree", "=", "degree", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.PeriodicBC.__call__": [[115, 132], ["torch.ones", "model", "model", "BoundaryCondition.PeriodicBC.norm", "NotImplementedError", "torch.autograd.grad", "torch.autograd.grad", "BoundaryCondition.PeriodicBC.norm"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x_lb", ",", "x_ub", ",", "model", ")", ":", "\n", "        ", "x_lb", ".", "requires_grad", "=", "True", "\n", "x_ub", ".", "requires_grad", "=", "True", "\n", "y_lb", "=", "model", "(", "x_lb", ")", "[", ":", ",", "self", ".", "output_dimension", "]", "\n", "y_ub", "=", "model", "(", "x_ub", ")", "[", ":", ",", "self", ".", "output_dimension", "]", "\n", "grads", "=", "ones", "(", "y_lb", ".", "shape", ",", "device", "=", "y_ub", ".", "device", ")", "\n", "if", "self", ".", "degree", "is", "None", ":", "\n", "            ", "return", "self", ".", "weight", "*", "self", ".", "norm", "(", "y_lb", ",", "y_ub", ")", "\n", "", "elif", "self", ".", "degree", "==", "1", ":", "\n", "            ", "y_lb_grad", "=", "grad", "(", "y_lb", ",", "x_lb", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "y_ub_grad", "=", "grad", "(", "y_ub", ",", "x_ub", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "y_lb_dn", "=", "y_lb_grad", "[", ":", ",", "self", ".", "input_dimension", "]", "\n", "y_ub_dn", "=", "y_ub_grad", "[", ":", ",", "self", ".", "input_dimension", "]", "\n", "return", "self", ".", "weight", "*", "self", ".", "norm", "(", "y_lb_dn", ",", "y_ub_dn", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Periodic Boundary Condition for a higher degree than one is not supported\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.TimeDerivativeBC.__init__": [[140, 142], ["BoundaryCondition.BoundaryCondition.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "dataset", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1", ")", ":", "\n", "        ", "super", "(", "TimeDerivativeBC", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.BoundaryCondition.TimeDerivativeBC.__call__": [[143, 150], ["model", "torch.ones", "pred_dt.reshape.reshape.reshape", "BoundaryCondition.TimeDerivativeBC.norm", "torch.autograd.grad"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "dt_y", ",", "model", ")", ":", "\n", "        ", "x", ".", "requires_grad", "=", "True", "\n", "pred", "=", "model", "(", "x", ")", "\n", "grads", "=", "ones", "(", "pred", ".", "shape", ",", "device", "=", "pred", ".", "device", ")", "\n", "pred_dt", "=", "grad", "(", "pred", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "[", ":", ",", "-", "1", "]", "\n", "pred_dt", "=", "pred_dt", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "return", "self", ".", "norm", "(", "pred_dt", ",", "dt_y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.WandB_Logger.WandbLogger.__init__": [[7, 19], ["wandb.init", "wandb.config.update"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "project", ",", "args", ",", "entity", "=", "None", ",", "group", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Initialize wandb instance and connect to the server\n\n        Args:\n            project: name of the project\n            args: hyperparameters used for this runs\n            writing_cycle: defines the writing period\n            entity: account or group id used for that run\n        \"\"\"", "\n", "wandb", ".", "init", "(", "project", "=", "project", ",", "entity", "=", "entity", ",", "group", "=", "group", ")", "\n", "wandb", ".", "config", ".", "update", "(", "args", ")", "# adds all of the arguments as config variable", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.WandB_Logger.WandbLogger.log_scalar": [[20, 30], ["wandb.log"], "methods", ["None"], ["", "def", "log_scalar", "(", "self", ",", "scalar", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a scalar to wandb\n\n        Args:\n            scalar: the scalar to be logged\n            name: name of the sclar\n            epoch: epoch in the training loop\n        \"\"\"", "\n", "wandb", ".", "log", "(", "{", "name", ":", "scalar", "}", ",", "step", "=", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.WandB_Logger.WandbLogger.log_image": [[31, 42], ["wandb.log", "wandb.Image"], "methods", ["None"], ["", "def", "log_image", "(", "self", ",", "image", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a image to wandb\n\n        Args:\n            image (Image) : the image to be logged\n            name (String) : name of the image\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "wandb", ".", "log", "(", "{", "name", ":", "[", "wandb", ".", "Image", "(", "image", ",", "caption", "=", "name", ")", "]", "}", ",", "step", "=", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.WandB_Logger.WandbLogger.log_plot": [[43, 54], ["wandb.log"], "methods", ["None"], ["", "def", "log_plot", "(", "self", ",", "plot", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a plot to wandb\n\n        Args:\n            plot (plot) : the plot to be logged\n            name (String) : name of the plot\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "wandb", ".", "log", "(", "{", "name", ":", "plot", "}", ",", "step", "=", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.WandB_Logger.WandbLogger.log_histogram": [[55, 66], ["wandb.log", "wandb.Histogram"], "methods", ["None"], ["", "def", "log_histogram", "(", "self", ",", "histogram", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a histogram to wandb\n\n        Args:\n            histogram (histogram) : the histogram to be logged\n            name (String) : name of the histogram\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "wandb", ".", "log", "(", "{", "name", ":", "wandb", ".", "Histogram", "(", "histogram", ")", "}", ",", "step", "=", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.HPMLoss.HPMLoss.__init__": [[4, 18], ["PDELoss.PDELoss.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "name", ",", "hpm_input", ",", "hpm_model", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the HPM loss\n        Args:\n            dataset (torch.utils.Dataset): dataset that provides the residual points\n            hpm_input(function): function that calculates the needed input for the HPM model. The hpm_input function\n            should return a list of tensors, where the last entry is the time_derivative\n            hpm_model (torch.nn.Module): model for the HPM, represents the underlying PDE\n            norm: Norm used for calculation PDE loss\n            weight: Weighting for the loss term\n        \"\"\"", "\n", "super", "(", "HPMLoss", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "None", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", "\n", "self", ".", "hpm_input", "=", "hpm_input", "\n", "self", ".", "hpm_model", "=", "hpm_model", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.HPMLoss.HPMLoss.__call__": [[19, 33], ["model", "HPMLoss.HPMLoss.hpm_input", "hpm_input[].reshape", "HPMLoss.HPMLoss.hpm_model", "HPMLoss.HPMLoss.norm"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "model", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Calculation of the HPM Loss\n        Args:\n            x(torch.Tensor): residual points\n            model(torch.nn.module): model representing the solution\n        \"\"\"", "\n", "x", ".", "requires_grad", "=", "True", "\n", "prediction_u", "=", "model", "(", "x", ")", "\n", "hpm_input", "=", "self", ".", "hpm_input", "(", "x", ",", "prediction_u", ")", "\n", "time_derivative", "=", "hpm_input", "[", ":", ",", "-", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "input", "=", "hpm_input", "[", ":", ",", ":", "-", "1", "]", "\n", "hpm_output", "=", "self", ".", "hpm_model", "(", "input", ")", "\n", "return", "self", ".", "norm", "(", "time_derivative", ",", "hpm_output", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.LossTerm.LossTerm.__init__": [[8, 28], ["torch.nn.MSELoss", "torch.nn.L1Loss"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of a loss term\n        \n        Args:\n            dataset (torch.utils.Dataset): dataset that provides the residual points\n            norm: Norm used for calculation PDE loss\n            weight: Weighting for the loss term\n        \"\"\"", "\n", "# cases for standard torch norms", "\n", "if", "norm", "==", "'L2'", ":", "\n", "            ", "self", ".", "norm", "=", "MSELoss", "(", ")", "\n", "", "elif", "norm", "==", "'L1'", ":", "\n", "            ", "self", ".", "norm", "=", "L1Loss", "(", ")", "\n", "", "else", ":", "\n", "# Case for self implemented norms", "\n", "            ", "self", ".", "norm", "=", "norm", "\n", "", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "weight", "=", "weight", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.__init__": [[6, 14], ["tensorboardX.SummaryWriter"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "logdir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create an event file in a given directory.\n\n        Args:\n            logdir: save directory location\n        \"\"\"", "\n", "self", ".", "writer", "=", "SummaryWriter", "(", "logdir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_scalar": [[15, 25], ["TensorBoard_Logger.TensorBoardLogger.writer.add_scalar"], "methods", ["None"], ["", "def", "log_scalar", "(", "self", ",", "scalar", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Add scalar data to summary.\n\n        Args:\n            scalar: the scalar to be logged\n            name: name of the sclar\n            epoch: epoch in the training loop\n        \"\"\"", "\n", "self", ".", "writer", ".", "add_scalar", "(", "name", ",", "scalar", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_image": [[26, 38], ["TensorBoard_Logger.TensorBoardLogger.writer.add_image"], "methods", ["None"], ["", "def", "log_image", "(", "self", ",", "image", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Add image data to summary. \n        Note that this requires the 'pillow' package.\n\n        Args:\n            image (Image) : the image tensor of shape (3,H,W) to be logged\n            name (String) : name of the image\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "self", ".", "writer", ".", "add_image", "(", "name", ",", "image", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_plot": [[40, 51], ["TensorBoard_Logger.TensorBoardLogger.writer.add_figure"], "methods", ["None"], ["", "def", "log_plot", "(", "self", ",", "plot", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a plot to wandb.\n\n        Args:\n            plot (plot) : the plot to be logged\n            name (String) : name of the plot\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "self", ".", "writer", ".", "add_figure", "(", "name", ",", "plot", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.TensorBoard_Logger.TensorBoardLogger.log_histogram": [[52, 63], ["TensorBoard_Logger.TensorBoardLogger.writer.add_histogram"], "methods", ["None"], ["", "def", "log_histogram", "(", "self", ",", "histogram", ",", "name", ",", "epoch", ")", ":", "\n", "        ", "\"\"\"\n        Logs a histogram to wandb\n\n        Args:\n            histogram (histogram) : the histogram to be logged\n            name (String) : name of the histogram\n            epoch (Integer) : epoch in the training loop\n\n        \"\"\"", "\n", "self", ".", "writer", ".", "add_histogram", "(", "name", ",", "histogram", ",", "epoch", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PDELoss.PDELoss.__init__": [[8, 21], ["LossTerm.LossTerm.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "pde", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the PDE Loss\n\n        Args:\n            dataset (torch.utils.Dataset): dataset that provides the residual points\n            pde (function): function that represents residual of the PDE\n            norm: Norm used for calculation PDE loss\n            weight: Weighting for the loss term\n        \"\"\"", "\n", "super", "(", "PDELoss", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "pde", "=", "pde", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.PDELoss.PDELoss.__call__": [[22, 34], ["model.forward", "PDELoss.PDELoss.pde", "torch.zeros", "PDELoss.PDELoss.norm"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.activations.snake.Snake.forward"], ["", "def", "__call__", "(", "self", ",", "x", ":", "Tensor", ",", "model", ":", "Module", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Call function of the PDE loss. Calculates the norm of the PDE residual\n\n        x: residual points\n        model: model that predicts the solution of the PDE\n        \"\"\"", "\n", "x", ".", "requires_grad", "=", "True", "# setting requires grad to true in order to calculate", "\n", "u", "=", "model", ".", "forward", "(", "x", ")", "\n", "pde_residual", "=", "self", ".", "pde", "(", "x", ",", "u", ",", "**", "kwargs", ")", "\n", "zeros", "=", "torch", ".", "zeros", "(", "pde_residual", ".", "shape", ",", "device", "=", "pde_residual", ".", "device", ")", "\n", "return", "self", ".", "norm", "(", "pde_residual", ",", "zeros", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.Lamb.__init__": [[25, 39], ["dict", "torch.optim.optimizer.Optimizer.__init__", "ValueError", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "1e-3", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "eps", "=", "1e-6", ",", "\n", "weight_decay", "=", "0", ",", "adam", "=", "False", ")", ":", "\n", "        ", "if", "not", "0.0", "<=", "lr", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "not", "0.0", "<=", "eps", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid epsilon value: {}\"", ".", "format", "(", "eps", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "0", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 0: {}\"", ".", "format", "(", "betas", "[", "0", "]", ")", ")", "\n", "", "if", "not", "0.0", "<=", "betas", "[", "1", "]", "<", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid beta parameter at index 1: {}\"", ".", "format", "(", "betas", "[", "1", "]", ")", ")", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "betas", "=", "betas", ",", "eps", "=", "eps", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "self", ".", "adam", "=", "adam", "\n", "super", "(", "Lamb", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.Lamb.step": [[40, 105], ["closure", "exp_avg.mul_().add_", "exp_avg_sq.mul_().addcmul_", "p.data.pow().sum().sqrt().clamp", "adam_step.pow().sum().sqrt", "p.data.add_", "RuntimeError", "len", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "exp_avg_sq.sqrt().add", "adam_step.add_", "exp_avg.mul_", "exp_avg_sq.mul_", "p.data.pow().sum().sqrt", "adam_step.pow().sum", "exp_avg_sq.sqrt", "p.data.pow().sum", "adam_step.pow", "p.data.pow"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "grad", "=", "p", ".", "grad", ".", "data", "\n", "if", "grad", ".", "is_sparse", ":", "\n", "                    ", "raise", "RuntimeError", "(", "'Lamb does not support sparse gradients, consider SparseAdam instad.'", ")", "\n", "\n", "", "state", "=", "self", ".", "state", "[", "p", "]", "\n", "\n", "# State initialization", "\n", "if", "len", "(", "state", ")", "==", "0", ":", "\n", "                    ", "state", "[", "'step'", "]", "=", "0", "\n", "# Exponential moving average of gradient values", "\n", "state", "[", "'exp_avg'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "# Exponential moving average of squared gradient values", "\n", "state", "[", "'exp_avg_sq'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "\n", "", "exp_avg", ",", "exp_avg_sq", "=", "state", "[", "'exp_avg'", "]", ",", "state", "[", "'exp_avg_sq'", "]", "\n", "beta1", ",", "beta2", "=", "group", "[", "'betas'", "]", "\n", "\n", "state", "[", "'step'", "]", "+=", "1", "\n", "\n", "# Decay the first and second moment rufing average coefficient", "\n", "# m_t", "\n", "exp_avg", ".", "mul_", "(", "beta1", ")", ".", "add_", "(", "1", "-", "beta1", ",", "grad", ")", "\n", "# v_t", "\n", "exp_avg_sq", ".", "mul_", "(", "beta2", ")", ".", "addcmul_", "(", "1", "-", "beta2", ",", "grad", ",", "grad", ")", "\n", "\n", "# Paper v3 does not use debiasing.", "\n", "# bias_correction1 = 1 - beta1 ** state['step']", "\n", "# bias_correction2 = 1 - beta2 ** state['step']", "\n", "# Apply bias to lr to avoid broadcast.", "\n", "step_size", "=", "group", "[", "'lr'", "]", "# * math.sqrt(bias_correction2) / bias_correction1", "\n", "\n", "weight_norm", "=", "p", ".", "data", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ".", "sqrt", "(", ")", ".", "clamp", "(", "0", ",", "10", ")", "\n", "\n", "adam_step", "=", "exp_avg", "/", "exp_avg_sq", ".", "sqrt", "(", ")", ".", "add", "(", "group", "[", "'eps'", "]", ")", "\n", "if", "group", "[", "'weight_decay'", "]", "!=", "0", ":", "\n", "                    ", "adam_step", ".", "add_", "(", "group", "[", "'weight_decay'", "]", ",", "p", ".", "data", ")", "\n", "\n", "", "adam_norm", "=", "adam_step", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ".", "sqrt", "(", ")", "\n", "if", "weight_norm", "==", "0", "or", "adam_norm", "==", "0", ":", "\n", "                    ", "trust_ratio", "=", "1", "\n", "", "else", ":", "\n", "                    ", "trust_ratio", "=", "weight_norm", "/", "adam_norm", "\n", "", "state", "[", "'weight_norm'", "]", "=", "weight_norm", "\n", "state", "[", "'adam_norm'", "]", "=", "adam_norm", "\n", "state", "[", "'trust_ratio'", "]", "=", "trust_ratio", "\n", "if", "self", ".", "adam", ":", "\n", "                    ", "trust_ratio", "=", "1", "\n", "\n", "", "p", ".", "data", ".", "add_", "(", "-", "step_size", "*", "trust_ratio", ",", "adam_step", ")", "\n", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.__init__": [[128, 145], ["dict", "torch.optim.optimizer.Optimizer.__init__", "ValueError", "ValueError", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "params", ",", "lr", "=", "required", ",", "momentum", "=", ".9", ",", "\n", "weight_decay", "=", ".0005", ",", "eta", "=", "0.001", ",", "max_epoch", "=", "200", ")", ":", "\n", "        ", "if", "lr", "is", "not", "required", "and", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid weight_decay value: {}\"", "\n", ".", "format", "(", "weight_decay", ")", ")", "\n", "", "if", "eta", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid LARS coefficient value: {}\"", ".", "format", "(", "eta", ")", ")", "\n", "\n", "", "self", ".", "epoch", "=", "0", "\n", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "\n", "weight_decay", "=", "weight_decay", ",", "\n", "eta", "=", "eta", ",", "max_epoch", "=", "max_epoch", ")", "\n", "super", "(", "LARS", ",", "self", ")", ".", "__init__", "(", "params", ",", "defaults", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.optimizer.LARS.step": [[146, 199], ["closure", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "p.data.add_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.mul_", "torch.zeros_like.mul_", "float"], "methods", ["None"], ["", "def", "step", "(", "self", ",", "epoch", "=", "None", ",", "closure", "=", "None", ")", ":", "\n", "        ", "\"\"\"Performs a single optimization step.\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n            epoch: current epoch to calculate polynomial LR decay schedule.\n                   if None, uses self.epoch and increments it.\n        \"\"\"", "\n", "loss", "=", "None", "\n", "if", "closure", "is", "not", "None", ":", "\n", "            ", "loss", "=", "closure", "(", ")", "\n", "\n", "", "if", "epoch", "is", "None", ":", "\n", "            ", "epoch", "=", "self", ".", "epoch", "\n", "self", ".", "epoch", "+=", "1", "\n", "\n", "", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "eta", "=", "group", "[", "'eta'", "]", "\n", "lr", "=", "group", "[", "'lr'", "]", "\n", "max_epoch", "=", "group", "[", "'max_epoch'", "]", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "d_p", "=", "p", ".", "grad", ".", "data", "\n", "\n", "weight_norm", "=", "torch", ".", "norm", "(", "p", ".", "data", ")", "\n", "grad_norm", "=", "torch", ".", "norm", "(", "d_p", ")", "\n", "\n", "# Global LR computed on polynomial decay schedule", "\n", "decay", "=", "(", "1", "-", "float", "(", "epoch", ")", "/", "max_epoch", ")", "**", "2", "\n", "global_lr", "=", "lr", "*", "decay", "\n", "\n", "# Compute local learning rate for this layer", "\n", "local_lr", "=", "eta", "*", "weight_norm", "/", "(", "grad_norm", "+", "weight_decay", "*", "weight_norm", ")", "\n", "\n", "# Update the momentum term", "\n", "actual_lr", "=", "local_lr", "*", "global_lr", "\n", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                    ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "", "else", ":", "\n", "                    ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "actual_lr", ",", "d_p", "+", "weight_decay", "*", "p", ".", "data", ")", "\n", "p", ".", "data", ".", "add_", "(", "-", "buf", ")", "\n", "\n", "", "", "return", "loss", "", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.InitalCondition.InitialCondition.__init__": [[7, 17], ["LossTerm.LossTerm.__init__"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "name", ",", "norm", "=", "'L2'", ",", "weight", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Constructor for the Initial condition\n\n        Args:\n            dataset (torch.utils.Dataset): dataset that provides the residual points\n            norm: Norm used for calculation PDE loss\n            weight: Weighting for the loss term\n        \"\"\"", "\n", "super", "(", "InitialCondition", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "name", ",", "norm", ",", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.PINNFramework.InitalCondition.InitialCondition.__call__": [[18, 30], ["model", "InitalCondition.InitialCondition.norm"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ":", "Tensor", ",", "model", ":", "Module", ",", "gt_y", ":", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        This function returns the loss for the initial condition\n        L_0 = norm(model(x), gt_y)\n\n        Args:\n        x (Tensor) : position of initial condition\n        model (Module): model that represents the solution\n        gt_y (Tensor): ground true values for the initial state\n        \"\"\"", "\n", "prediction", "=", "model", "(", "x", ")", "\n", "return", "self", ".", "norm", "(", "prediction", ",", "gt_y", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.Callback.__init__": [[6, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", "=", "None", "\n", "self", ".", "logger", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.Callback.set_model": [[10, 16], ["isinstance", "ValueError", "type"], "methods", ["None"], ["", "def", "set_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "if", "isinstance", "(", "model", ",", "Module", ")", ":", "\n", "            ", "self", ".", "model", "=", "model", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Model is not of type <torch.nn.module> but model of type {} was found\"", "\n", ".", "format", "(", "type", "(", "model", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.Callback.set_logger": [[17, 23], ["isinstance", "ValueError", "type"], "methods", ["None"], ["", "", "def", "set_logger", "(", "self", ",", "logger", ")", ":", "\n", "        ", "if", "isinstance", "(", "LoggerInterface", ")", ":", "\n", "            ", "self", ".", "logger", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Logger is not of type <LoggerInterface> but logger of type {} was found\"", "\n", ".", "format", "(", "type", "(", "logger", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.Callback.__call__": [[24, 26], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"method __call__() of the callback is not implemented\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.CallbackList.__init__": [[29, 39], ["isinstance", "ValueError", "isinstance", "ValueError", "type", "type"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "callbacks", ")", ":", "\n", "        ", "if", "isinstance", "(", "callbacks", ",", "list", ")", ":", "\n", "            ", "for", "cb", "in", "callbacks", ":", "\n", "                ", "if", "not", "isinstance", "(", "cb", ",", "Callback", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Callback has to be of type <Callback> but type {} was found\"", "\n", ".", "format", "(", "type", "(", "cb", ")", ")", ")", "\n", "", "", "self", ".", "callbacks", "=", "callbacks", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Callback has to be of type <list> but type {} was found\"", "\n", ".", "format", "(", "type", "(", "callbacks", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.callbacks.Callback.CallbackList.__call__": [[40, 43], ["cb"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "for", "cb", "in", "self", ".", "callbacks", ":", "\n", "            ", "cb", "(", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.__init__": [[8, 16], ["mlp.MLP.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "snake_mlp.SnakeMLP.init_layers", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.init_layers"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "frequency", ",", "normalize", "=", "True", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "activation", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "init_layers", "(", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "frequency", ")", "\n", "self", ".", "lb", "=", "torch", ".", "tensor", "(", "lb", ")", ".", "float", "(", ")", "\n", "self", ".", "ub", "=", "torch", ".", "tensor", "(", "ub", ")", ".", "float", "(", ")", "\n", "self", ".", "normalize", "=", "normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.init_layers": [[18, 31], ["snake_mlp.SnakeMLP.linear_layers.append", "snake_mlp.SnakeMLP.activation.append", "range", "snake_mlp.SnakeMLP.linear_layers.append", "torch.Linear", "torch.Linear", "activations.snake.Snake", "snake_mlp.SnakeMLP.linear_layers.append", "snake_mlp.SnakeMLP.activation.append", "torch.Linear", "torch.Linear", "isinstance", "torch.Linear", "torch.Linear", "activations.snake.Snake", "math.sqrt", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.init.constant_", "torch.init.constant_", "m.weight.size"], "methods", ["None"], ["", "def", "init_layers", "(", "self", ",", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "frequency", ")", ":", "\n", "        ", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "input_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "activation", ".", "append", "(", "Snake", "(", "frequency", "=", "frequency", ")", ")", "\n", "for", "_", "in", "range", "(", "num_hidden", ")", ":", "\n", "            ", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "activation", ".", "append", "(", "Snake", "(", "frequency", "=", "frequency", ")", ")", "\n", "", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "output_size", ")", ")", "\n", "\n", "for", "m", "in", "self", ".", "linear_layers", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "bound", "=", "math", ".", "sqrt", "(", "3", "/", "m", ".", "weight", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "torch", ".", "nn", ".", "init", ".", "uniform_", "(", "m", ".", "weight", ",", "a", "=", "-", "bound", ",", "b", "=", "bound", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.forward": [[32, 40], ["range", "len"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "normalize", ":", "\n", "            ", "x", "=", "2.0", "*", "(", "x", "-", "self", ".", "lb", ")", "/", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "-", "1.0", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "linear_layers", ")", "-", "1", ")", ":", "\n", "            ", "x", "=", "self", ".", "linear_layers", "[", "i", "]", "(", "x", ")", "\n", "x", "=", "self", ".", "activation", "[", "i", "]", "(", "x", ")", "\n", "", "x", "=", "self", ".", "linear_layers", "[", "-", "1", "]", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.cuda": [[41, 45], ["super().cuda", "snake_mlp.SnakeMLP.lb.cuda", "snake_mlp.SnakeMLP.ub.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "super", "(", "SnakeMLP", ",", "self", ")", ".", "cuda", "(", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "cuda", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.cpu": [[46, 50], ["super().cpu", "snake_mlp.SnakeMLP.lb.cpu", "snake_mlp.SnakeMLP.ub.cpu"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "super", "(", "SnakeMLP", ",", "self", ")", ".", "cpu", "(", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "cpu", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.snake_mlp.SnakeMLP.to": [[51, 55], ["super().to", "snake_mlp.SnakeMLP.lb.to", "snake_mlp.SnakeMLP.ub.to"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", "SnakeMLP", ",", "self", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "to", "(", "device", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "to", "(", "device", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.SparseDispatcher.__init__": [[50, 70], ["torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "sorted_experts.split", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "list", "list", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "moe_finger.SparseDispatcher._batch_index.flatten"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_experts", ",", "gates", ",", "use_gpu", "=", "False", ")", ":", "\n", "        ", "\"\"\"Create a SparseDispatcher.\"\"\"", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "_gates", "=", "gates", "\n", "self", ".", "_num_experts", "=", "num_experts", "\n", "# sort experts", "\n", "sorted_experts", ",", "index_sorted_experts", "=", "torch", ".", "nonzero", "(", "gates", ")", ".", "sort", "(", "0", ")", "\n", "# drop indices", "\n", "_", ",", "self", ".", "_expert_index", "=", "sorted_experts", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "# get according batch index for each expert", "\n", "self", ".", "_batch_index", "=", "sorted_experts", "[", "index_sorted_experts", "[", ":", ",", "1", "]", ",", "0", "]", "\n", "# calculate num samples that each expert gets", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "self", ".", "_part_sizes", "=", "list", "(", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_part_sizes", "=", "list", "(", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", ")", "\n", "\n", "# expand gates to match with self._batch_index", "\n", "", "gates_exp", "=", "gates", "[", "self", ".", "_batch_index", ".", "flatten", "(", ")", "]", "\n", "self", ".", "_nonzero_gates", "=", "torch", ".", "gather", "(", "gates_exp", ",", "1", ",", "self", ".", "_expert_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.SparseDispatcher.dispatch": [[71, 87], ["inp[].squeeze", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "dispatch", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"Create one input Tensor for each expert.\n        The `Tensor` for a expert `i` contains the slices of `inp` corresponding\n        to the batch elements `b` where `gates[b, i] > 0`.\n        Args:\n          inp: a `Tensor` of shape \"[batch_size, <extra_input_dims>]`\n        Returns:\n          a list of `num_experts` `Tensor`s with shapes\n            `[expert_batch_size_i, <extra_input_dims>]`.\n        \"\"\"", "\n", "\n", "# assigns samples to experts whose gate is nonzero", "\n", "\n", "# expand according to batch index so we can just split by _part_sizes", "\n", "inp_exp", "=", "inp", "[", "self", ".", "_batch_index", "]", ".", "squeeze", "(", "1", ")", "\n", "return", "torch", ".", "split", "(", "inp_exp", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.SparseDispatcher.combine": [[89, 116], ["torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zeros.cuda.cuda.index_add", "zeros.cuda.index_add.log", "stitched.mul.mul.mul", "moe_finger.SparseDispatcher._gates.size", "expert_out[].size", "zeros.cuda.cuda.cuda", "stitched.mul.mul.float", "numpy.finfo", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "combine", "(", "self", ",", "expert_out", ",", "multiply_by_gates", "=", "True", ")", ":", "\n", "        ", "\"\"\"Sum together the expert output, weighted by the gates.\n        The slice corresponding to a particular batch element `b` is computed\n        as the sum over all experts `i` of the expert output, weighted by the\n        corresponding gate values.  If `multiply_by_gates` is set to False, the\n        gate values are ignored.\n        Args:\n          expert_out: a list of `num_experts` `Tensor`s, each with shape\n            `[expert_batch_size_i, <extra_output_dims>]`.\n          multiply_by_gates: a boolean\n        Returns:\n          a `Tensor` with shape `[batch_size, <extra_output_dims>]`.\n        \"\"\"", "\n", "# apply exp to expert outputs, so we are not longer in log space", "\n", "stitched", "=", "torch", ".", "cat", "(", "expert_out", ",", "0", ")", ".", "exp", "(", ")", "\n", "\n", "if", "multiply_by_gates", ":", "\n", "            ", "stitched", "=", "stitched", ".", "mul", "(", "self", ".", "_nonzero_gates", ")", "\n", "", "zeros", "=", "torch", ".", "zeros", "(", "self", ".", "_gates", ".", "size", "(", "0", ")", ",", "expert_out", "[", "-", "1", "]", ".", "size", "(", "1", ")", ",", "requires_grad", "=", "True", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "zeros", "=", "zeros", ".", "cuda", "(", ")", "\n", "# combine samples that have been processed by the same k experts", "\n", "", "combined", "=", "zeros", ".", "index_add", "(", "0", ",", "self", ".", "_batch_index", ",", "stitched", ".", "float", "(", ")", ")", "\n", "# add eps to all zero values in order to avoid nans when going back to log space", "\n", "combined", "[", "combined", "==", "0", "]", "=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "# back to log space", "\n", "return", "combined", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.SparseDispatcher.expert_to_gates": [[118, 126], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "expert_to_gates", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gate values corresponding to the examples in the per-expert `Tensor`s.\n        Returns:\n          a list of `num_experts` one-dimensional `Tensor`s with type `tf.float32`\n              and shapes `[expert_batch_size_i]`\n        \"\"\"", "\n", "# split nonzero gates for each expert", "\n", "return", "torch", ".", "split", "(", "self", ".", "_nonzero_gates", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.__init__": [[139, 184], ["torch.Module.__init__", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Softplus", "torch.Softplus", "torch.Softplus", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "PINNFramework.models.MLP", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "PINNFramework.models.FingerNet", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "num_experts", ",", "\n", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", "=", "torch", ".", "tanh", ",", "\n", "non_linear", "=", "False", ",", "noisy_gating", "=", "False", ",", "k", "=", "1", ",", "scaling_factor", "=", "1.", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "noisy_gating", "=", "noisy_gating", "\n", "self", ".", "num_experts", "=", "num_experts", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "use_gpu", "=", "False", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "loss", "=", "0", "\n", "self", ".", "lb", "=", "torch", ".", "Tensor", "(", "lb", ")", ".", "float", "(", ")", "\n", "self", ".", "ub", "=", "torch", ".", "Tensor", "(", "ub", ")", ".", "float", "(", ")", "\n", "self", ".", "scaling_factor", "=", "scaling_factor", "\n", "\n", "# instantiate experts", "\n", "# normalization of the MLPs is disabled cause the Gating Network performs the normalization", "\n", "self", ".", "experts", "=", "nn", ".", "ModuleList", "(", "[", "\n", "FingerNet", "(", "lb", ",", "ub", ",", "hidden_size", ",", "num_hidden", ",", "activation", ",", "False", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "num_experts", ")", "\n", "]", ")", "\n", "\n", "self", ".", "w_gate", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "input_size", ",", "num_experts", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "w_noise", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "input_size", ",", "num_experts", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "1", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "self", ".", "normal", "=", "Normal", "(", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ".", "cuda", "(", ")", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "normal", "=", "Normal", "(", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ".", "cuda", "(", ")", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ".", "cuda", "(", ")", ")", "\n", "\n", "", "self", ".", "non_linear", "=", "non_linear", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", "=", "MLP", "(", "input_size", ",", "\n", "num_experts", ",", "\n", "num_experts", "*", "2", ",", "\n", "1", ",", "\n", "lb", ",", "\n", "ub", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", "normalize", "=", "False", ")", "\n", "\n", "", "assert", "(", "self", ".", "k", "<=", "self", ".", "num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.cv_squared": [[185, 200], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "x.float().var", "x.float", "x.float().mean", "x.float"], "methods", ["None"], ["", "def", "cv_squared", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"The squared coefficient of variation of a sample.\n        Useful as a loss to encourage a positive distribution to be more uniform.\n        Epsilons added for numerical stability.\n        Returns 0 for an empty Tensor.\n        Args:\n        x: a `Tensor`.\n        Returns:\n        a `Scalar`.\n        \"\"\"", "\n", "eps", "=", "1e-10", "\n", "# if only num_experts = 1", "\n", "if", "x", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "return", "torch", ".", "Tensor", "(", "[", "0", "]", ")", "\n", "", "return", "x", ".", "float", "(", ")", ".", "var", "(", ")", "/", "(", "x", ".", "float", "(", ")", ".", "mean", "(", ")", "**", "2", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE._gates_to_load": [[202, 211], ["None"], "methods", ["None"], ["", "def", "_gates_to_load", "(", "self", ",", "gates", ")", ":", "\n", "        ", "\"\"\"Compute the true load per expert, given the gates.\n        The load is the number of examples for which the corresponding gate is >0.\n        Args:\n        gates: a `Tensor` of shape [batch_size, n]\n        Returns:\n        a float32 `Tensor` of shape [n]\n        \"\"\"", "\n", "return", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE._prob_in_top_k": [[212, 250], ["clean_values.size", "noisy_top_values.size", "noisy_top_values.flatten", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "moe_finger.MoE.normal.cdf", "moe_finger.MoE.normal.cdf", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "_prob_in_top_k", "(", "self", ",", "clean_values", ",", "noisy_values", ",", "noise_stddev", ",", "noisy_top_values", ")", ":", "\n", "        ", "\"\"\"Helper function to NoisyTopKGating.\n        Computes the probability that value is in top k, given different random noise.\n        This gives us a way of backpropagating from a loss that balances the number\n        of times each expert is in the top k experts per example.\n        In the case of no noise, pass in None for noise_stddev, and the result will\n        not be differentiable.\n        Args:\n        clean_values: a `Tensor` of shape [batch, n].\n        noisy_values: a `Tensor` of shape [batch, n].  Equal to clean values plus\n          normally distributed noise with standard deviation noise_stddev.\n        noise_stddev: a `Tensor` of shape [batch, n], or None\n        noisy_top_values: a `Tensor` of shape [batch, m].\n           \"values\" Output of tf.top_k(noisy_top_values, m).  m >= k+1\n        Returns:\n        a `Tensor` of shape [batch, n].\n        \"\"\"", "\n", "\n", "batch", "=", "clean_values", ".", "size", "(", "0", ")", "\n", "m", "=", "noisy_top_values", ".", "size", "(", "1", ")", "\n", "top_values_flat", "=", "noisy_top_values", ".", "flatten", "(", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "threshold_positions_if_in", "=", "(", "torch", ".", "arange", "(", "batch", ")", "*", "m", "+", "self", ".", "k", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "threshold_positions_if_in", "=", "(", "torch", ".", "arange", "(", "batch", ")", "*", "m", "+", "self", ".", "k", ")", ".", "cuda", "(", ")", "\n", "", "threshold_if_in", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_in", ")", ",", "1", ")", "\n", "is_in", "=", "torch", ".", "gt", "(", "noisy_values", ",", "threshold_if_in", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "threshold_positions_if_out", "=", "(", "threshold_positions_if_in", "-", "1", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "threshold_positions_if_out", "=", "(", "threshold_positions_if_in", "-", "1", ")", ".", "cuda", "(", ")", "\n", "\n", "", "threshold_if_out", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_out", ")", ",", "1", ")", "\n", "# is each value currently in the top k.", "\n", "prob_if_in", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_in", ")", "/", "noise_stddev", ")", "\n", "prob_if_out", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_out", ")", "/", "noise_stddev", ")", "\n", "prob", "=", "torch", ".", "where", "(", "is_in", ",", "prob_if_in", ",", "prob_if_out", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.noisy_top_k_gating": [[252, 294], ["logits.topk", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "moe_finger.MoE.gating_network", "min", "moe_finger.MoE.softmax", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "moe_finger.MoE._prob_in_top_k().sum", "moe_finger.MoE._gates_to_load", "moe_finger.MoE.softplus", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "moe_finger.MoE._prob_in_top_k"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._gates_to_load", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._prob_in_top_k"], ["", "def", "noisy_top_k_gating", "(", "self", ",", "x", ",", "train", ",", "noise_epsilon", "=", "1e-2", ")", ":", "\n", "        ", "\"\"\"Noisy top-k gating.\n          See paper: https://arxiv.org/abs/1701.06538.\n          Args:\n            x: input Tensor with shape [batch_size, input_size]\n            train: a boolean - we only add noise at training time.\n            noise_epsilon: a float\n          Returns:\n            gates: a Tensor with shape [batch_size, num_experts]\n            load: a Tensor with shape [num_experts]\n        \"\"\"", "\n", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "clean_logits", "=", "self", ".", "gating_network", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "clean_logits", "=", "x", "@", "self", ".", "w_gate", "\n", "", "if", "self", ".", "noisy_gating", ":", "\n", "            ", "raw_noise_stddev", "=", "x", "@", "self", ".", "w_noise", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "                ", "raw_noise_stddev", "=", "self", ".", "softplus", "(", "raw_noise_stddev", ")", "\n", "", "noise_stddev", "=", "(", "(", "raw_noise_stddev", "+", "noise_epsilon", ")", "*", "train", ")", "\n", "noisy_logits", "=", "clean_logits", "+", "(", "torch", ".", "randn_like", "(", "clean_logits", ")", "*", "noise_stddev", ")", "\n", "logits", "=", "noisy_logits", "\n", "", "else", ":", "\n", "            ", "logits", "=", "clean_logits", "\n", "\n", "# calculate topk + 1 that will be needed for the noisy gates", "\n", "", "top_logits", ",", "top_indices", "=", "logits", ".", "topk", "(", "min", "(", "self", ".", "k", "+", "1", ",", "self", ".", "num_experts", ")", ",", "dim", "=", "1", ")", "\n", "top_k_logits", "=", "top_logits", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "top_k_indices", "=", "top_indices", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "            ", "top_k_gates", "=", "self", ".", "softmax", "(", "top_k_logits", ")", "\n", "", "else", ":", "\n", "            ", "top_k_gates", "=", "torch", ".", "sigmoid", "(", "top_k_logits", ")", "\n", "", "zeros", "=", "torch", ".", "zeros_like", "(", "logits", ",", "requires_grad", "=", "True", ")", "\n", "gates", "=", "zeros", ".", "scatter", "(", "1", ",", "top_k_indices", ",", "top_k_gates", ")", "\n", "\n", "if", "self", ".", "noisy_gating", "and", "self", ".", "k", "<", "self", ".", "num_experts", ":", "\n", "            ", "load", "=", "(", "self", ".", "_prob_in_top_k", "(", "clean_logits", ",", "noisy_logits", ",", "noise_stddev", ",", "top_logits", ")", ")", ".", "sum", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "load", "=", "self", ".", "_gates_to_load", "(", "gates", ")", "\n", "", "return", "gates", ",", "load", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.get_utilisation_loss": [[296, 298], ["None"], "methods", ["None"], ["", "def", "get_utilisation_loss", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.forward": [[299, 330], ["moe_finger.MoE.noisy_top_k_gating", "moe_finger.SparseDispatcher.expert_to_gates", "moe_finger.SparseDispatcher", "moe_finger.SparseDispatcher.dispatch", "moe_finger.SparseDispatcher.expert_to_gates", "range", "moe_finger.SparseDispatcher.combine", "moe_finger.MoE.cv_squared", "moe_finger.MoE.cv_squared", "expert_outputs.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.noisy_top_k_gating", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.dispatch", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.combine", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared"], ["", "def", "forward", "(", "self", ",", "x", ",", "train", "=", "True", ",", "loss_coef", "=", "1e-2", ")", ":", "\n", "        ", "\"\"\"Args:\n        x: tensor shape [batch_size, input_size]\n        train: a boolean scalar.\n        loss_coef: a scalar - multiplier on load-balancing losses\n        Returns:\n        y: a tensor with shape [batch_size, output_size].\n        extra_training_loss: a scalar.  This should be added into the overall\n        training loss of the model.  The backpropagation of this loss\n        encourages all experts to be approximately equally used across a batch.\n        \"\"\"", "\n", "# normalization is performed here for better convergence of the gating network", "\n", "x", "=", "2.0", "*", "(", "x", "-", "self", ".", "lb", ")", "/", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "-", "1.0", "\n", "\n", "gates", ",", "load", "=", "self", ".", "noisy_top_k_gating", "(", "x", ",", "train", ")", "\n", "# calculate importance loss", "\n", "importance", "=", "gates", ".", "sum", "(", "0", ")", "\n", "#", "\n", "loss", "=", "self", ".", "cv_squared", "(", "importance", ")", "+", "self", ".", "cv_squared", "(", "load", ")", "\n", "loss", "*=", "loss_coef", "\n", "self", ".", "loss", "=", "loss", "\n", "\n", "dispatcher", "=", "SparseDispatcher", "(", "self", ".", "num_experts", ",", "gates", ",", "self", ".", "use_gpu", ")", "\n", "expert_inputs", "=", "dispatcher", ".", "dispatch", "(", "x", ")", "\n", "gates", "=", "dispatcher", ".", "expert_to_gates", "(", ")", "\n", "expert_outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "if", "expert_inputs", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "expert_outputs", ".", "append", "(", "self", ".", "experts", "[", "i", "]", "(", "expert_inputs", "[", "i", "]", ")", ")", "\n", "", "", "y", "=", "dispatcher", ".", "combine", "(", "expert_outputs", ")", "\n", "return", "self", ".", "scaling_factor", "*", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.cuda": [[331, 341], ["super().cuda", "range", "moe_finger.MoE.lb.cuda", "moe_finger.MoE.ub.cuda", "moe_finger.MoE.experts[].cuda", "moe_finger.MoE.gating_network.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "cuda", "(", ")", "\n", "self", ".", "use_gpu", "=", "True", "\n", "#iterate over all experts and move them to gpu", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "cuda", "(", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "cuda", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cuda", "(", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.cpu": [[342, 351], ["super().cpu", "range", "moe_finger.MoE.lb.cpu", "moe_finger.MoE.ub.cpu", "moe_finger.MoE.experts[].cpu", "moe_finger.MoE.gating_network.cpu"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu"], ["", "", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "cpu", "(", ")", "\n", "self", ".", "use_gpu", "=", "False", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "cpu", "(", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "cpu", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cpu", "(", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_finger.MoE.to": [[352, 360], ["super().to", "range", "moe_finger.MoE.lb.to", "moe_finger.MoE.ub.to", "moe_finger.MoE.experts[].to", "moe_finger.MoE.gating_network.to"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "to", "(", "device", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "to", "(", "device", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "to", "(", "device", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "to", "(", "device", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "to", "(", "device", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.SparseDispatcher.__init__": [[49, 65], ["torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "sorted_experts.split", "list", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "distributed_moe.SparseDispatcher._batch_index.flatten"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_experts", ",", "gates", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "\"\"\"Create a SparseDispatcher.\"\"\"", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "_gates", "=", "gates", "\n", "self", ".", "_num_experts", "=", "num_experts", "\n", "# sort experts", "\n", "sorted_experts", ",", "index_sorted_experts", "=", "torch", ".", "nonzero", "(", "gates", ")", ".", "sort", "(", "0", ")", "\n", "# drop indices", "\n", "_", ",", "self", ".", "_expert_index", "=", "sorted_experts", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "# get according batch index for each expert", "\n", "self", ".", "_batch_index", "=", "sorted_experts", "[", "index_sorted_experts", "[", ":", ",", "1", "]", ",", "0", "]", "\n", "# calculate num samples that each expert gets", "\n", "self", ".", "_part_sizes", "=", "list", "(", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", ".", "to", "(", "device", ")", ")", "#.cuda())", "\n", "# expand gates to match with self._batch_index", "\n", "gates_exp", "=", "gates", "[", "self", ".", "_batch_index", ".", "flatten", "(", ")", "]", "\n", "self", ".", "_nonzero_gates", "=", "torch", ".", "gather", "(", "gates_exp", ",", "1", ",", "self", ".", "_expert_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.SparseDispatcher.dispatch": [[66, 82], ["inp[].squeeze", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "dispatch", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"Create one input Tensor for each expert.\n        The `Tensor` for a expert `i` contains the slices of `inp` corresponding\n        to the batch elements `b` where `gates[b, i] > 0`.\n        Args:\n          inp: a `Tensor` of shape \"[batch_size, <extra_input_dims>]`\n        Returns:\n          a list of `num_experts` `Tensor`s with shapes\n            `[expert_batch_size_i, <extra_input_dims>]`.\n        \"\"\"", "\n", "\n", "# assigns samples to experts whose gate is nonzero", "\n", "\n", "# expand according to batch index so we can just split by _part_sizes", "\n", "inp_exp", "=", "inp", "[", "self", ".", "_batch_index", "]", ".", "squeeze", "(", "1", ")", "\n", "return", "torch", ".", "split", "(", "inp_exp", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.SparseDispatcher.combine": [[84, 109], ["torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to.index_add", "torch.zeros().to.index_add", "torch.zeros().to.index_add", "torch.zeros().to.index_add.log", "stitched.mul.mul.mul", "stitched.mul.mul.float", "numpy.finfo", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "distributed_moe.SparseDispatcher._gates.size", "expert_out[].size"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "combine", "(", "self", ",", "expert_out", ",", "multiply_by_gates", "=", "True", ")", ":", "\n", "        ", "\"\"\"Sum together the expert output, weighted by the gates.\n        The slice corresponding to a particular batch element `b` is computed\n        as the sum over all experts `i` of the expert output, weighted by the\n        corresponding gate values.  If `multiply_by_gates` is set to False, the\n        gate values are ignored.\n        Args:\n          expert_out: a list of `num_experts` `Tensor`s, each with shape\n            `[expert_batch_size_i, <extra_output_dims>]`.\n          multiply_by_gates: a boolean\n        Returns:\n          a `Tensor` with shape `[batch_size, <extra_output_dims>]`.\n        \"\"\"", "\n", "# apply exp to expert outputs, so we are not longer in log space", "\n", "stitched", "=", "torch", ".", "cat", "(", "expert_out", ",", "0", ")", ".", "exp", "(", ")", "\n", "\n", "if", "multiply_by_gates", ":", "\n", "            ", "stitched", "=", "stitched", ".", "mul", "(", "self", ".", "_nonzero_gates", ")", "\n", "", "zeros", "=", "torch", ".", "zeros", "(", "self", ".", "_gates", ".", "size", "(", "0", ")", ",", "expert_out", "[", "-", "1", "]", ".", "size", "(", "1", ")", ",", "requires_grad", "=", "True", ")", ".", "to", "(", "self", ".", "device", ")", "#.cuda()", "\n", "# combine samples that have been processed by the same k experts", "\n", "combined", "=", "zeros", ".", "index_add", "(", "0", ",", "self", ".", "_batch_index", ",", "stitched", ".", "float", "(", ")", ")", "\n", "# add eps to all zero values in order to avoid nans when going back to log space", "\n", "combined", "[", "combined", "==", "0", "]", "=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "# back to log space", "\n", "return", "combined", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.SparseDispatcher.expert_to_gates": [[111, 119], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "expert_to_gates", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gate values corresponding to the examples in the per-expert `Tensor`s.\n        Returns:\n          a list of `num_experts` one-dimensional `Tensor`s with type `tf.float32`\n              and shapes `[expert_batch_size_i]`\n        \"\"\"", "\n", "# split nonzero gates for each expert", "\n", "return", "torch", ".", "split", "(", "self", ".", "_nonzero_gates", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE.__init__": [[135, 168], ["torch.Module.__init__", "print", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Softplus", "torch.Softplus", "torch.Softplus", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "PINNFramework.models.mlp.MLP().to", "PINNFramework.models.mlp.MLP().to", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "PINNFramework.models.mlp.MLP", "PINNFramework.models.mlp.MLP"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "num_experts", ",", "\n", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", "=", "torch", ".", "tanh", ",", "\n", "non_linear", "=", "False", ",", "noisy_gating", "=", "False", ",", "k", "=", "1", ",", "device", "=", "\"cpu\"", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "noisy_gating", "=", "noisy_gating", "\n", "self", ".", "num_experts", "=", "num_experts", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "loss", "=", "0", "\n", "self", ".", "num_devices", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "-", "1", "# cuda:0 is for handling data", "\n", "print", "(", "\"The model runs on {} devices\"", ".", "format", "(", "self", ".", "num_devices", ")", ")", "\n", "# instantiate experts on the needed GPUs", "\n", "self", ".", "experts", "=", "nn", ".", "ModuleList", "(", "[", "\n", "MLP", "(", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", ",", "\n", "device", "=", "'cuda:{}'", ".", "format", "(", "(", "i", "%", "self", ".", "num_devices", ")", "+", "1", ")", ")", "\n", ".", "to", "(", "'cuda:{}'", ".", "format", "(", "(", "i", "%", "self", ".", "num_devices", ")", "+", "1", ")", ")", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", "\n", "]", ")", "\n", "self", ".", "w_gate", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "input_size", ",", "num_experts", ",", "device", "=", "self", ".", "device", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "w_noise", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "input_size", ",", "num_experts", ",", "device", "=", "self", ".", "device", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "1", ")", "\n", "self", ".", "normal", "=", "Normal", "(", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ".", "to", "(", "self", ".", "device", ")", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "\n", "self", ".", "non_linear", "=", "non_linear", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", "=", "MLP", "(", "input_size", ",", "num_experts", ",", "num_experts", "*", "2", ",", "1", ",", "lb", ",", "ub", ",", "activation", "=", "F", ".", "relu", ",", "\n", "device", "=", "self", ".", "device", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "assert", "(", "self", ".", "k", "<=", "self", ".", "num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE.cv_squared": [[169, 184], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "x.float().var", "x.float", "x.float().mean", "x.float"], "methods", ["None"], ["", "def", "cv_squared", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"The squared coefficient of variation of a sample.\n        Useful as a loss to encourage a positive distribution to be more uniform.\n        Epsilons added for numerical stability.\n        Returns 0 for an empty Tensor.\n        Args:\n        x: a `Tensor`.\n        Returns:\n        a `Scalar`.\n        \"\"\"", "\n", "eps", "=", "1e-10", "\n", "# if only num_experts = 1", "\n", "if", "x", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "return", "torch", ".", "Tensor", "(", "[", "0", "]", ")", "\n", "", "return", "x", ".", "float", "(", ")", ".", "var", "(", ")", "/", "(", "x", ".", "float", "(", ")", ".", "mean", "(", ")", "**", "2", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE._gates_to_load": [[186, 195], ["None"], "methods", ["None"], ["", "def", "_gates_to_load", "(", "self", ",", "gates", ")", ":", "\n", "        ", "\"\"\"Compute the true load per expert, given the gates.\n        The load is the number of examples for which the corresponding gate is >0.\n        Args:\n        gates: a `Tensor` of shape [batch_size, n]\n        Returns:\n        a float32 `Tensor` of shape [n]\n        \"\"\"", "\n", "return", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE._prob_in_top_k": [[196, 227], ["clean_values.size", "noisy_top_values.size", "noisy_top_values.flatten", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "distributed_moe.MoE.normal.cdf", "distributed_moe.MoE.normal.cdf", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "_prob_in_top_k", "(", "self", ",", "clean_values", ",", "noisy_values", ",", "noise_stddev", ",", "noisy_top_values", ")", ":", "\n", "        ", "\"\"\"Helper function to NoisyTopKGating.\n        Computes the probability that value is in top k, given different random noise.\n        This gives us a way of backpropagating from a loss that balances the number\n        of times each expert is in the top k experts per example.\n        In the case of no noise, pass in None for noise_stddev, and the result will\n        not be differentiable.\n        Args:\n        clean_values: a `Tensor` of shape [batch, n].\n        noisy_values: a `Tensor` of shape [batch, n].  Equal to clean values plus\n          normally distributed noise with standard deviation noise_stddev.\n        noise_stddev: a `Tensor` of shape [batch, n], or None\n        noisy_top_values: a `Tensor` of shape [batch, m].\n           \"values\" Output of tf.top_k(noisy_top_values, m).  m >= k+1\n        Returns:\n        a `Tensor` of shape [batch, n].\n        \"\"\"", "\n", "\n", "batch", "=", "clean_values", ".", "size", "(", "0", ")", "\n", "m", "=", "noisy_top_values", ".", "size", "(", "1", ")", "\n", "top_values_flat", "=", "noisy_top_values", ".", "flatten", "(", ")", "\n", "threshold_positions_if_in", "=", "(", "torch", ".", "arange", "(", "batch", ")", "*", "m", "+", "self", ".", "k", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "threshold_if_in", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_in", ")", ",", "1", ")", "\n", "is_in", "=", "torch", ".", "gt", "(", "noisy_values", ",", "threshold_if_in", ")", "\n", "threshold_positions_if_out", "=", "(", "threshold_positions_if_in", "-", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "threshold_if_out", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_out", ")", ",", "1", ")", "\n", "# is each value currently in the top k.", "\n", "prob_if_in", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_in", ")", "/", "noise_stddev", ")", "\n", "prob_if_out", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_out", ")", "/", "noise_stddev", ")", "\n", "prob", "=", "torch", ".", "where", "(", "is_in", ",", "prob_if_in", ",", "prob_if_out", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE.noisy_top_k_gating": [[229, 271], ["logits.topk", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "distributed_moe.MoE.gating_network", "min", "distributed_moe.MoE.softmax", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "distributed_moe.MoE._prob_in_top_k().sum", "distributed_moe.MoE._gates_to_load", "distributed_moe.MoE.softplus", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "distributed_moe.MoE._prob_in_top_k"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._gates_to_load", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._prob_in_top_k"], ["", "def", "noisy_top_k_gating", "(", "self", ",", "x", ",", "train", ",", "noise_epsilon", "=", "1e-1", ")", ":", "\n", "        ", "\"\"\"Noisy top-k gating.\n          See paper: https://arxiv.org/abs/1701.06538.\n          Args:\n            x: input Tensor with shape [batch_size, input_size]\n            train: a boolean - we only add noise at training time.\n            noise_epsilon: a float\n          Returns:\n            gates: a Tensor with shape [batch_size, num_experts]\n            load: a Tensor with shape [num_experts]\n        \"\"\"", "\n", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "clean_logits", "=", "self", ".", "gating_network", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "clean_logits", "=", "x", "@", "self", ".", "w_gate", "\n", "", "if", "self", ".", "noisy_gating", ":", "\n", "            ", "raw_noise_stddev", "=", "x", "@", "self", ".", "w_noise", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "                ", "raw_noise_stddev", "=", "self", ".", "softplus", "(", "raw_noise_stddev", ")", "\n", "", "noise_stddev", "=", "(", "(", "raw_noise_stddev", "+", "noise_epsilon", ")", "*", "train", ")", "\n", "noisy_logits", "=", "clean_logits", "+", "(", "torch", ".", "randn_like", "(", "clean_logits", ")", "*", "noise_stddev", ")", "\n", "logits", "=", "noisy_logits", "\n", "", "else", ":", "\n", "            ", "logits", "=", "clean_logits", "\n", "\n", "# calculate topk + 1 that will be needed for the noisy gates", "\n", "", "top_logits", ",", "top_indices", "=", "logits", ".", "topk", "(", "min", "(", "self", ".", "k", "+", "1", ",", "self", ".", "num_experts", ")", ",", "dim", "=", "1", ")", "\n", "top_k_logits", "=", "top_logits", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "top_k_indices", "=", "top_indices", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "            ", "top_k_gates", "=", "self", ".", "softmax", "(", "top_k_logits", ")", "\n", "", "else", ":", "\n", "            ", "top_k_gates", "=", "torch", ".", "sigmoid", "(", "top_k_logits", ")", "\n", "", "zeros", "=", "torch", ".", "zeros_like", "(", "logits", ",", "requires_grad", "=", "True", ")", "\n", "gates", "=", "zeros", ".", "scatter", "(", "1", ",", "top_k_indices", ",", "top_k_gates", ")", "\n", "\n", "if", "self", ".", "noisy_gating", "and", "self", ".", "k", "<", "self", ".", "num_experts", ":", "\n", "            ", "load", "=", "(", "self", ".", "_prob_in_top_k", "(", "clean_logits", ",", "noisy_logits", ",", "noise_stddev", ",", "top_logits", ")", ")", ".", "sum", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "load", "=", "self", ".", "_gates_to_load", "(", "gates", ")", "\n", "", "return", "gates", ",", "load", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE.get_utilisation_loss": [[273, 275], ["None"], "methods", ["None"], ["", "def", "get_utilisation_loss", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.distributed_moe.MoE.forward": [[277, 312], ["distributed_moe.MoE.noisy_top_k_gating", "distributed_moe.SparseDispatcher.expert_to_gates", "distributed_moe.SparseDispatcher", "distributed_moe.SparseDispatcher.dispatch", "distributed_moe.SparseDispatcher.expert_to_gates", "range", "distributed_moe.SparseDispatcher.combine", "distributed_moe.MoE.cv_squared", "distributed_moe.MoE.cv_squared", "expert_inputs[].to", "expert_output.to.to.to", "expert_outputs.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.noisy_top_k_gating", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.dispatch", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.combine", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "forward", "(", "self", ",", "x", ",", "train", "=", "True", ",", "loss_coef", "=", "1e-2", ")", ":", "\n", "        ", "\"\"\"Args:\n        x: tensor shape [batch_size, input_size]\n        train: a boolean scalar.\n        loss_coef: a scalar - multiplier on load-balancing losses\n        Returns:\n        y: a tensor with shape [batch_size, output_size].\n        extra_training_loss: a scalar.  This should be added into the overall\n        training loss of the model.  The backpropagation of this loss\n        encourages all experts to be approximately equally used across a batch.\n        \"\"\"", "\n", "gates", ",", "load", "=", "self", ".", "noisy_top_k_gating", "(", "x", ",", "train", ")", "\n", "# calculate importance loss", "\n", "importance", "=", "gates", ".", "sum", "(", "0", ")", "\n", "#", "\n", "loss", "=", "self", ".", "cv_squared", "(", "importance", ")", "+", "self", ".", "cv_squared", "(", "load", ")", "\n", "loss", "*=", "loss_coef", "\n", "\n", "self", ".", "loss", "=", "loss", "\n", "\n", "dispatcher", "=", "SparseDispatcher", "(", "self", ".", "num_experts", ",", "gates", ",", "device", "=", "self", ".", "device", ")", "\n", "expert_inputs", "=", "dispatcher", ".", "dispatch", "(", "x", ")", "\n", "gates", "=", "dispatcher", ".", "expert_to_gates", "(", ")", "\n", "# Here is a loop needed for asynchonous calls of the GPUs", "\n", "expert_outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "# move data to device", "\n", "            ", "exp_input", "=", "expert_inputs", "[", "i", "]", ".", "to", "(", "self", ".", "experts", "[", "i", "]", ".", "device", ")", "\n", "expert_output", "=", "self", ".", "experts", "[", "i", "]", "(", "exp_input", ")", "\n", "# move expert output back to device", "\n", "expert_output", "=", "expert_output", ".", "to", "(", "self", ".", "device", ")", "\n", "# append it for stiching", "\n", "expert_outputs", ".", "append", "(", "expert_output", ")", "\n", "", "y", "=", "dispatcher", ".", "combine", "(", "expert_outputs", ")", "\n", "return", "y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.__init__": [[6, 14], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "mlp.MLP.init_layers", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.init_layers"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", "=", "torch", ".", "tanh", ",", "normalize", "=", "True", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "init_layers", "(", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ")", "\n", "self", ".", "lb", "=", "torch", ".", "Tensor", "(", "lb", ")", ".", "float", "(", ")", "\n", "self", ".", "ub", "=", "torch", ".", "Tensor", "(", "ub", ")", ".", "float", "(", ")", "\n", "self", ".", "normalize", "=", "normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.init_layers": [[15, 25], ["mlp.MLP.linear_layers.append", "range", "mlp.MLP.linear_layers.append", "torch.Linear", "torch.Linear", "mlp.MLP.linear_layers.append", "torch.Linear", "torch.Linear", "isinstance", "torch.Linear", "torch.Linear", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_layers", "(", "self", ",", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ")", ":", "\n", "        ", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "input_size", ",", "hidden_size", ")", ")", "\n", "for", "_", "in", "range", "(", "num_hidden", ")", ":", "\n", "            ", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "", "self", ".", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_size", ",", "output_size", ")", ")", "\n", "\n", "for", "m", "in", "self", ".", "linear_layers", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.forward": [[26, 34], ["range", "mlp.MLP.activation", "len"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "normalize", ":", "\n", "            ", "x", "=", "2.0", "*", "(", "x", "-", "self", ".", "lb", ")", "/", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "-", "1.0", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "linear_layers", ")", "-", "1", ")", ":", "\n", "            ", "x", "=", "self", ".", "linear_layers", "[", "i", "]", "(", "x", ")", "\n", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "x", "=", "self", ".", "linear_layers", "[", "-", "1", "]", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.cuda": [[35, 39], ["super().cuda", "mlp.MLP.lb.cuda", "mlp.MLP.ub.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "cuda", "(", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "cuda", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.cpu": [[40, 44], ["super().cpu", "mlp.MLP.lb.cpu", "mlp.MLP.ub.cpu"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "cpu", "(", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "cpu", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.mlp.MLP.to": [[45, 49], ["super().to", "mlp.MLP.lb.to", "mlp.MLP.ub.to"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "to", "(", "device", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "to", "(", "device", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.__init__": [[16, 29], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.randn().clone().detach().requires_grad_", "torch.randn().clone().detach().requires_grad_", "torch.randn().clone().detach().requires_grad_", "torch.randn().clone().detach", "torch.randn().clone().detach", "torch.randn().clone().detach", "torch.randn().clone", "torch.randn().clone", "torch.randn().clone", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "config", ",", "u_blood", "=", "37.", ",", "spat_res", "=", "0.3", ",", "hs_net", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "u_blood", "=", "u_blood", "\n", "self", ".", "spat_res", "=", "0.3", "\n", "if", "config", "[", "'convection'", "]", ":", "\n", "            ", "self", ".", "a_conv", "=", "Parameter", "(", "Variable", "(", "(", "randn", "(", "[", "640", ",", "480", "]", ")", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", ")", ")", ")", "\n", "", "if", "config", "[", "'linear_u'", "]", ":", "\n", "            ", "self", ".", "a_linear_u_w", "=", "Parameter", "(", "Variable", "(", "(", "randn", "(", "[", "640", ",", "480", "]", ")", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", ")", ")", ")", "\n", "self", ".", "a_linear_u_b", "=", "Parameter", "(", "Variable", "(", "(", "randn", "(", "[", "640", ",", "480", "]", ")", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", ")", ")", ")", "\n", "", "if", "config", "[", "'heat_source'", "]", ":", "\n", "            ", "assert", "hs_net", "is", "not", "None", "\n", "self", ".", "hs_net", "=", "hs_net", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.convection": [[30, 45], ["derivatives[].view", "derivatives[].view", "torch.nn.functional.relu", "pennesmodel.PennesHPM.a_conv[].view", "derivatives[].view", "derivatives[].view"], "methods", ["None"], ["", "", "def", "convection", "(", "self", ",", "derivatives", ")", ":", "\n", "        ", "\"\"\"\n        Convection term of the model:\n            convection = a_conv * \u0394u\n        It is linear mapping of the convection term in the original equation.\n        Args:\n            derivatives(tensor): tensor of the form [x,y,t,u,u_xx,u_yy,u_t].\n                                                    [0,1,2,3,  4 ,  5 , 6 ].\n        \"\"\"", "\n", "u_xx", "=", "derivatives", "[", ":", ",", "4", "]", ".", "view", "(", "-", "1", ")", "\n", "u_yy", "=", "derivatives", "[", ":", ",", "5", "]", ".", "view", "(", "-", "1", ")", "\n", "x_indices", "=", "(", "derivatives", "[", ":", ",", "0", "]", ".", "view", "(", "-", "1", ")", "/", "self", ".", "spat_res", ")", ".", "long", "(", ")", "\n", "y_indices", "=", "(", "derivatives", "[", ":", ",", "1", "]", ".", "view", "(", "-", "1", ")", "/", "self", ".", "spat_res", ")", ".", "long", "(", ")", "\n", "a_conv", "=", "relu", "(", "self", ".", "a_conv", "[", "x_indices", ",", "y_indices", "]", ".", "view", "(", "-", "1", ")", ")", "\n", "return", "a_conv", "*", "(", "u_xx", "+", "u_yy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.linear_u": [[46, 60], ["derivatives[].view", "pennesmodel.PennesHPM.a_linear_u_w[].view", "pennesmodel.PennesHPM.a_linear_u_b[].view", "derivatives[].view", "derivatives[].view"], "methods", ["None"], ["", "def", "linear_u", "(", "self", ",", "derivatives", ")", ":", "\n", "        ", "\"\"\"\n        Linear term of the model:\n            linear(u) = w * u + b\n        It is linear mapping of the perfusion term in the original equation.\n        Args:\n            derivatives(tensor): tensor of the form [x,y,t,u,u_xx,u_yy,u_t].\n        \"\"\"", "\n", "x_indices", "=", "(", "derivatives", "[", ":", ",", "0", "]", ".", "view", "(", "-", "1", ")", "/", "self", ".", "spat_res", ")", ".", "long", "(", ")", "\n", "y_indices", "=", "(", "derivatives", "[", ":", ",", "1", "]", ".", "view", "(", "-", "1", ")", "/", "self", ".", "spat_res", ")", ".", "long", "(", ")", "\n", "u_values", "=", "derivatives", "[", ":", ",", "3", "]", ".", "view", "(", "-", "1", ")", "\n", "a_linear_u_w", "=", "self", ".", "a_linear_u_w", "[", "x_indices", ",", "y_indices", "]", ".", "view", "(", "-", "1", ")", "\n", "a_linear_u_b", "=", "self", ".", "a_linear_u_b", "[", "x_indices", ",", "y_indices", "]", ".", "view", "(", "-", "1", ")", "\n", "return", "a_linear_u_w", "*", "(", "u_values", "-", "self", ".", "u_blood", ")", "+", "a_linear_u_b", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.heat_source": [[61, 63], ["pennesmodel.PennesHPM.heat_source"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.heat_source"], ["", "def", "heat_source", "(", "self", ",", "derivatives", ")", ":", "\n", "        ", "return", "heat_source", "(", "derivatives", "[", ":", ",", ":", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.forward": [[64, 78], ["pennesmodel.PennesHPM.convection", "pennesmodel.PennesHPM.linear_u"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.convection", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.linear_u"], ["", "def", "forward", "(", "self", ",", "derivatives", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass of the model.\n        Args:\n            derivatives(tensor): tensor of the form [x,y,t,u,u_xx,u_yy,u_t].\n                where x,y,t - spatiotemporal coordinates in physical units;\n                      u, u_xx, u_yy, u_t - temprerature and its derivatives.\n        \"\"\"", "\n", "predicted_u_t", "=", "0", "\n", "if", "self", ".", "config", "[", "'convection'", "]", ":", "\n", "            ", "predicted_u_t", "+=", "self", ".", "convection", "(", "derivatives", ")", "\n", "", "if", "self", ".", "config", "[", "'linear_u'", "]", ":", "\n", "            ", "predicted_u_t", "+=", "self", ".", "linear_u", "(", "derivatives", ")", "\n", "", "return", "predicted_u_t", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.pennesmodel.PennesHPM.cuda": [[79, 89], ["super().cuda", "pennesmodel.PennesHPM.a_conv.cuda", "pennesmodel.PennesHPM.a_linear_u_w.cuda", "pennesmodel.PennesHPM.a_linear_u_b.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Sends the instance of the class to cuda device.\n        \"\"\"", "\n", "super", "(", ")", ".", "cuda", "(", ")", "\n", "if", "self", ".", "config", "[", "'convection'", "]", ":", "\n", "            ", "self", ".", "a_conv", "=", "self", ".", "a_conv", ".", "cuda", "(", ")", "\n", "", "if", "self", ".", "config", "[", "'linear_u'", "]", ":", "\n", "            ", "self", ".", "a_linear_u_w", "=", "self", ".", "a_linear_u_w", ".", "cuda", "(", ")", "\n", "self", ".", "a_linear_u_b", "=", "self", ".", "a_linear_u_b", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.__init__": [[5, 20], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "Finger_Net.FingerNet.init_layers", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.init_layers"], ["    ", "def", "__init__", "(", "self", ",", "lb", ",", "ub", ",", "inputSize", ",", "outputSize", ",", "numFeatures", "=", "500", ",", "num_finger_layers", "=", "3", ",", "numLayers", "=", "8", ",", "activation", "=", "torch", ".", "relu", ",", "normalize", "=", "True", ",", "scaling", "=", "1.", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "1234", ")", "\n", "super", "(", "FingerNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "inputSize", "\n", "self", ".", "num_finger_layers", "=", "num_finger_layers", "\n", "self", ".", "numFeatures", "=", "numFeatures", "\n", "self", ".", "numLayers", "=", "numLayers", "\n", "self", ".", "lin_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "lb", "=", "torch", ".", "tensor", "(", "lb", ")", ".", "float", "(", ")", "\n", "self", ".", "ub", "=", "torch", ".", "tensor", "(", "ub", ")", ".", "float", "(", ")", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "normalize", "=", "normalize", "\n", "self", ".", "scaling", "=", "scaling", "\n", "self", ".", "output_size", "=", "outputSize", "\n", "self", ".", "init_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.init_layers": [[22, 49], ["torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "Finger_Net.FingerNet.lin_layers.append", "range", "Finger_Net.FingerNet.lin_layers.append", "Finger_Net.FingerNet.finger_nets.append", "Finger_Net.FingerNet.finger_nets[].append", "range", "torch.Linear", "torch.Linear", "Finger_Net.FingerNet.lin_layers.append", "torch.Linear", "torch.Linear", "isinstance", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "Finger_Net.FingerNet.finger_nets[].append", "isinstance", "torch.Linear", "torch.Linear", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.constant_", "torch.init.constant_", "torch.Linear", "torch.Linear", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_"], "methods", ["None"], ["", "def", "init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        This function creates the torch layers and initialize them with xavier\n        :param self:\n        :return:\n        \"\"\"", "\n", "self", ".", "finger_nets", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "lin_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "input_size", ")", ":", "\n", "            ", "self", ".", "finger_nets", ".", "append", "(", "nn", ".", "ModuleList", "(", ")", ")", "\n", "self", ".", "finger_nets", "[", "i", "]", ".", "append", "(", "nn", ".", "Linear", "(", "1", ",", "self", ".", "numFeatures", ")", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "num_finger_layers", "-", "1", ")", ":", "\n", "                ", "self", ".", "finger_nets", "[", "i", "]", ".", "append", "(", "nn", ".", "Linear", "(", "self", ".", "numFeatures", ",", "self", ".", "numFeatures", ")", ")", "\n", "", "for", "m", "in", "self", ".", "finger_nets", "[", "i", "]", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "\n", "", "", "", "self", ".", "lin_layers", ".", "append", "(", "nn", ".", "Linear", "(", "self", ".", "input_size", "*", "self", ".", "numFeatures", ",", "self", ".", "numFeatures", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "numLayers", "-", "1", ")", ":", "\n", "            ", "inFeatures", "=", "self", ".", "numFeatures", "\n", "self", ".", "lin_layers", ".", "append", "(", "nn", ".", "Linear", "(", "inFeatures", ",", "self", ".", "numFeatures", ")", ")", "\n", "", "inFeatures", "=", "self", ".", "numFeatures", "\n", "self", ".", "lin_layers", ".", "append", "(", "nn", ".", "Linear", "(", "inFeatures", ",", "self", ".", "output_size", ")", ")", "\n", "for", "m", "in", "self", ".", "lin_layers", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.forward": [[50, 74], ["range", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "input_tensors.append", "range", "output_tensors.append", "Finger_Net.FingerNet.activation", "x_in[].view", "Finger_Net.FingerNet.activation", "len"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x_in", ")", ":", "\n", "        ", "if", "self", ".", "normalize", ":", "\n", "            ", "x_in", "=", "2.0", "*", "(", "x_in", "-", "self", ".", "lb", ")", "/", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "-", "1.0", "\n", "\n", "", "input_tensors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "input_size", ")", ":", "\n", "            ", "input_tensors", ".", "append", "(", "x_in", "[", ":", ",", "i", "]", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "", "output_tensors", "=", "[", "]", "\n", "\n", "for", "finger_idx", "in", "range", "(", "self", ".", "input_size", ")", ":", "\n", "            ", "x_in", "=", "input_tensors", "[", "finger_idx", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "num_finger_layers", ")", ":", "\n", "                ", "x_in", "=", "self", ".", "finger_nets", "[", "finger_idx", "]", "[", "i", "]", "(", "x_in", ")", "\n", "x_in", "=", "self", ".", "activation", "(", "x_in", ")", "\n", "", "output_tensors", ".", "append", "(", "x_in", ")", "\n", "\n", "", "x", "=", "torch", ".", "cat", "(", "output_tensors", ",", "1", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "lin_layers", ")", "-", "1", ")", ":", "\n", "            ", "x", "=", "self", ".", "lin_layers", "[", "i", "]", "(", "x", ")", "\n", "x", "=", "self", ".", "activation", "(", "x", ")", "\n", "", "x", "=", "self", ".", "lin_layers", "[", "-", "1", "]", "(", "x", ")", "\n", "\n", "return", "self", ".", "scaling", "*", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.cuda": [[75, 82], ["super().cuda", "Finger_Net.FingerNet.lin_layers.cuda", "Finger_Net.FingerNet.lb.cuda", "Finger_Net.FingerNet.ub.cuda", "layers.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "super", "(", "FingerNet", ",", "self", ")", ".", "cuda", "(", ")", "\n", "for", "layers", "in", "self", ".", "finger_nets", ":", "\n", "            ", "layers", ".", "cuda", "(", ")", "\n", "", "self", ".", "lin_layers", ".", "cuda", "(", ")", "\n", "self", ".", "lb", "=", "self", ".", "lb", ".", "cuda", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.cpu": [[83, 89], ["super().cpu", "Finger_Net.FingerNet.lb.cpu", "Finger_Net.FingerNet.ub.cpu", "layers.cpu"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "super", "(", "FingerNet", ",", "self", ")", ".", "cpu", "(", ")", "\n", "for", "layers", "in", "self", ".", "finger_nets", ":", "\n", "            ", "layers", ".", "cpu", "(", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "cpu", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.Finger_Net.FingerNet.to": [[90, 96], ["super().to", "Finger_Net.FingerNet.lb.to", "Finger_Net.FingerNet.ub.to", "layers.to"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", "FingerNet", ",", "self", ")", ".", "to", "(", "device", ")", "\n", "for", "layers", "in", "self", ".", "finger_nets", ":", "\n", "            ", "layers", ".", "to", "(", "device", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "to", "(", "device", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "to", "(", "device", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.test_Finger_Net.FingerNetTest.test_constructor": [[11, 18], ["Finger_Net.FingerNet", "test_Finger_Net.FingerNetTest.assertIsNotNone", "test_Finger_Net.FingerNetTest.assertIsInstance"], "methods", ["None"], ["    ", "def", "test_constructor", "(", "self", ")", ":", "\n", "        ", "lb", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "3", ",", "1", ")", "\n", "self", ".", "assertIsNotNone", "(", "model", ",", "\"Model is not none\"", ")", "# add assertion here", "\n", "self", ".", "assertIsInstance", "(", "model", ",", "Module", ",", "\"Model is instance of torch.nn.module \"", ")", "\n", "del", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.test_Finger_Net.FingerNetTest.test_architecture": [[19, 44], ["Finger_Net.FingerNet", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet", "test_Finger_Net.FingerNetTest.assertEqual", "len", "len", "len"], "methods", ["None"], ["", "def", "test_architecture", "(", "self", ")", ":", "\n", "# test case with 1 finger", "\n", "        ", "InputSize", "=", "1", "\n", "OutputSize", "=", "1", "\n", "lb", "=", "[", "0", "]", "\n", "ub", "=", "[", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "model", ".", "finger_nets", ")", ",", "InputSize", ")", "\n", "del", "model", "\n", "\n", "InputSize", "=", "2", "\n", "OutputSize", "=", "1", "\n", "lb", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "model", ".", "finger_nets", ")", ",", "InputSize", ")", "\n", "del", "model", "\n", "\n", "InputSize", "=", "10", "\n", "OutputSize", "=", "1", "\n", "lb", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "model", ".", "finger_nets", ")", ",", "InputSize", ")", "\n", "del", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.test_Finger_Net.FingerNetTest.test_device_movement": [[47, 75], ["Finger_Net.FingerNet", "Finger_Net.FingerNet.cuda", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet.cpu", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet.to", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "def", "test_device_movement", "(", "self", ")", ":", "\n", "        ", "InputSize", "=", "2", "\n", "OutputSize", "=", "1", "\n", "lb", "=", "[", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "\n", "# moving model to cuda", "\n", "model", ".", "cuda", "(", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lb", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "ub", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "finger_nets", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lin_layers", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "\n", "# moving model to cpu", "\n", "model", ".", "cpu", "(", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lb", ".", "device", ")", ",", "'cpu'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "ub", ".", "device", ")", ",", "'cpu'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "finger_nets", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cpu'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lin_layers", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cpu'", ")", "\n", "\n", "# use `to`-function to move it back to gpu", "\n", "model", ".", "to", "(", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lb", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "ub", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "finger_nets", "[", "0", "]", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "model", ".", "lin_layers", "[", "0", "]", ".", "weight", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "del", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.test_Finger_Net.FingerNetTest.test_forward": [[76, 108], ["Finger_Net.FingerNet", "torch.rand", "Finger_Net.FingerNet.", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet", "torch.rand", "Finger_Net.FingerNet.", "test_Finger_Net.FingerNetTest.assertEqual", "Finger_Net.FingerNet", "Finger_Net.FingerNet.cuda", "torch.rand", "Finger_Net.FingerNet.", "test_Finger_Net.FingerNetTest.assertEqual", "test_Finger_Net.FingerNetTest.assertEqual", "str"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "test_forward", "(", "self", ")", ":", "\n", "# test forward on cpu", "\n", "        ", "InputSize", "=", "2", "\n", "OutputSize", "=", "1", "\n", "lb", "=", "[", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "x", "=", "torch", ".", "rand", "(", "10", ",", "InputSize", ")", "\n", "y", "=", "model", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "y", ".", "shape", ",", "(", "10", ",", "OutputSize", ")", ")", "\n", "\n", "# test on different input and output size", "\n", "InputSize", "=", "3", "\n", "OutputSize", "=", "3", "\n", "lb", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "x", "=", "torch", ".", "rand", "(", "10", ",", "InputSize", ")", "\n", "y", "=", "model", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "y", ".", "shape", ",", "(", "10", ",", "OutputSize", ")", ")", "\n", "\n", "# test forward on gpu", "\n", "InputSize", "=", "3", "\n", "OutputSize", "=", "3", "\n", "lb", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "model", ".", "cuda", "(", ")", "\n", "x", "=", "torch", ".", "rand", "(", "10", ",", "InputSize", ",", "device", "=", "'cuda:0'", ")", "\n", "y", "=", "model", "(", "x", ")", "\n", "self", ".", "assertEqual", "(", "y", ".", "shape", ",", "(", "10", ",", "OutputSize", ")", ")", "\n", "self", ".", "assertEqual", "(", "str", "(", "y", ".", "device", ")", ",", "'cuda:0'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.test_Finger_Net.FingerNetTest.test_parameter_function": [[109, 118], ["Finger_Net.FingerNet", "Finger_Net.FingerNet.named_parameters", "test_Finger_Net.FingerNetTest.assertGreater"], "methods", ["None"], ["", "def", "test_parameter_function", "(", "self", ")", ":", "\n", "        ", "InputSize", "=", "3", "\n", "OutputSize", "=", "3", "\n", "lb", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "ub", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "model", "=", "FingerNet", "(", "lb", ",", "ub", ",", "InputSize", ",", "OutputSize", ")", "\n", "num_parameter_entries", "=", "0", "\n", "for", "_", "in", "model", ".", "named_parameters", "(", ")", ":", "num_parameter_entries", "+=", "1", "\n", "self", ".", "assertGreater", "(", "num_parameter_entries", ",", "0", ",", "\"Number of parameters is not empty\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.__init__": [[49, 69], ["torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "torch.nonzero().sort", "sorted_experts.split", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "list", "list", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "moe_mlp.SparseDispatcher._batch_index.flatten"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_experts", ",", "gates", ",", "use_gpu", "=", "True", ")", ":", "\n", "        ", "\"\"\"Create a SparseDispatcher.\"\"\"", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "_gates", "=", "gates", "\n", "self", ".", "_num_experts", "=", "num_experts", "\n", "# sort experts", "\n", "sorted_experts", ",", "index_sorted_experts", "=", "torch", ".", "nonzero", "(", "gates", ")", ".", "sort", "(", "0", ")", "\n", "# drop indices", "\n", "_", ",", "self", ".", "_expert_index", "=", "sorted_experts", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "# get according batch index for each expert", "\n", "self", ".", "_batch_index", "=", "sorted_experts", "[", "index_sorted_experts", "[", ":", ",", "1", "]", ",", "0", "]", "\n", "# calculate num samples that each expert gets", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "self", ".", "_part_sizes", "=", "list", "(", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_part_sizes", "=", "list", "(", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", ")", "\n", "\n", "# expand gates to match with self._batch_index", "\n", "", "gates_exp", "=", "gates", "[", "self", ".", "_batch_index", ".", "flatten", "(", ")", "]", "\n", "self", ".", "_nonzero_gates", "=", "torch", ".", "gather", "(", "gates_exp", ",", "1", ",", "self", ".", "_expert_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.dispatch": [[70, 86], ["inp[].squeeze", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "dispatch", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"Create one input Tensor for each expert.\n        The `Tensor` for a expert `i` contains the slices of `inp` corresponding\n        to the batch elements `b` where `gates[b, i] > 0`.\n        Args:\n          inp: a `Tensor` of shape \"[batch_size, <extra_input_dims>]`\n        Returns:\n          a list of `num_experts` `Tensor`s with shapes\n            `[expert_batch_size_i, <extra_input_dims>]`.\n        \"\"\"", "\n", "\n", "# assigns samples to experts whose gate is nonzero", "\n", "\n", "# expand according to batch index so we can just split by _part_sizes", "\n", "inp_exp", "=", "inp", "[", "self", ".", "_batch_index", "]", ".", "squeeze", "(", "1", ")", "\n", "return", "torch", ".", "split", "(", "inp_exp", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.combine": [[88, 117], ["torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.cat().exp", "torch.zeros.index_add", "torch.zeros.index_add", "torch.zeros.index_add", "torch.zeros.index_add.log", "stitched.mul.mul.mul", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "stitched.mul.mul.float", "numpy.finfo", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "moe_mlp.SparseDispatcher._gates.size", "expert_out[].size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "moe_mlp.SparseDispatcher._gates.size", "expert_out[].size"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "combine", "(", "self", ",", "expert_out", ",", "multiply_by_gates", "=", "True", ")", ":", "\n", "        ", "\"\"\"Sum together the expert output, weighted by the gates.\n        The slice corresponding to a particular batch element `b` is computed\n        as the sum over all experts `i` of the expert output, weighted by the\n        corresponding gate values.  If `multiply_by_gates` is set to False, the\n        gate values are ignored.\n        Args:\n          expert_out: a list of `num_experts` `Tensor`s, each with shape\n            `[expert_batch_size_i, <extra_output_dims>]`.\n          multiply_by_gates: a boolean\n        Returns:\n          a `Tensor` with shape `[batch_size, <extra_output_dims>]`.\n        \"\"\"", "\n", "# apply exp to expert outputs, so we are not longer in log space", "\n", "stitched", "=", "torch", ".", "cat", "(", "expert_out", ",", "0", ")", ".", "exp", "(", ")", "\n", "\n", "if", "multiply_by_gates", ":", "\n", "            ", "stitched", "=", "stitched", ".", "mul", "(", "self", ".", "_nonzero_gates", ")", "\n", "", "if", "self", ".", "use_gpu", ":", "\n", "            ", "zeros", "=", "torch", ".", "zeros", "(", "self", ".", "_gates", ".", "size", "(", "0", ")", ",", "expert_out", "[", "-", "1", "]", ".", "size", "(", "1", ")", ",", "requires_grad", "=", "True", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "zeros", "=", "torch", ".", "zeros", "(", "self", ".", "_gates", ".", "size", "(", "0", ")", ",", "expert_out", "[", "-", "1", "]", ".", "size", "(", "1", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# combine samples that have been processed by the same k experts", "\n", "", "combined", "=", "zeros", ".", "index_add", "(", "0", ",", "self", ".", "_batch_index", ",", "stitched", ".", "float", "(", ")", ")", "\n", "# add eps to all zero values in order to avoid nans when going back to log space", "\n", "combined", "[", "combined", "==", "0", "]", "=", "np", ".", "finfo", "(", "float", ")", ".", "eps", "\n", "# back to log space", "\n", "return", "combined", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates": [[119, 127], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "expert_to_gates", "(", "self", ")", ":", "\n", "        ", "\"\"\"Gate values corresponding to the examples in the per-expert `Tensor`s.\n        Returns:\n          a list of `num_experts` one-dimensional `Tensor`s with type `tf.float32`\n              and shapes `[expert_batch_size_i]`\n        \"\"\"", "\n", "# split nonzero gates for each expert", "\n", "return", "torch", ".", "split", "(", "self", ".", "_nonzero_gates", ",", "self", ".", "_part_sizes", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.__init__": [[140, 194], ["torch.Module.__init__", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.Softplus", "torch.Softplus", "torch.Softplus", "torch.Softmax", "torch.Softmax", "torch.Softmax", "moe_mlp.MoE.w_gate.cuda", "moe_mlp.MoE.w_noise.cuda", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "torch.distributions.normal.Normal", "PINNFramework.models.MLP", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "PINNFramework.models.MLP", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "moe_mlp.MoE.gating_network.cuda", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["def", "__init__", "(", "self", ",", "input_size", ",", "output_size", ",", "num_experts", ",", "\n", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", "=", "torch", ".", "tanh", ",", "\n", "non_linear", "=", "False", ",", "noisy_gating", "=", "False", ",", "k", "=", "1", ",", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "noisy_gating", "=", "noisy_gating", "\n", "self", ".", "num_experts", "=", "num_experts", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "use_gpu", "=", "False", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "loss", "=", "0", "\n", "self", ".", "lb", "=", "torch", ".", "Tensor", "(", "lb", ")", ".", "float", "(", ")", "\n", "self", ".", "ub", "=", "torch", ".", "Tensor", "(", "ub", ")", ".", "float", "(", ")", "\n", "\n", "# instantiate experts", "\n", "# normalization of the MLPs is disabled cause the Gating Network performs the normalization", "\n", "self", ".", "experts", "=", "nn", ".", "ModuleList", "(", "[", "\n", "MLP", "(", "input_size", ",", "output_size", ",", "hidden_size", ",", "num_hidden", ",", "lb", ",", "ub", ",", "activation", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "num_experts", ")", "\n", "]", ")", "\n", "\n", "self", ".", "w_gate", "=", "torch", ".", "randn", "(", "input_size", ",", "num_experts", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "w_noise", "=", "torch", ".", "zeros", "(", "input_size", ",", "num_experts", ",", "requires_grad", "=", "True", ")", "\n", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "self", ".", "w_gate", "=", "self", ".", "w_gate", ".", "cuda", "(", ")", "\n", "self", ".", "w_noise", "=", "self", ".", "w_noise", ".", "cuda", "(", ")", "\n", "\n", "", "self", ".", "w_gate", "=", "torch", ".", "nn", ".", "Parameter", "(", "self", ".", "w_gate", ")", "\n", "self", ".", "w_noise", "=", "torch", ".", "nn", ".", "Parameter", "(", "self", ".", "w_noise", ")", "\n", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "1", ")", "\n", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "self", ".", "normal", "=", "Normal", "(", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ".", "cuda", "(", ")", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "normal", "=", "Normal", "(", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ",", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", ")", "\n", "\n", "", "self", ".", "non_linear", "=", "non_linear", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", "=", "MLP", "(", "input_size", ",", "\n", "num_experts", ",", "\n", "num_experts", "*", "2", ",", "\n", "1", ",", "\n", "lb", ",", "\n", "ub", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", "normalize", "=", "False", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "                ", "self", ".", "gating_network", ".", "cuda", "(", ")", "\n", "\n", "", "", "assert", "(", "self", ".", "k", "<=", "self", ".", "num_experts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared": [[195, 210], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "x.float().var", "x.float", "x.float().mean", "x.float"], "methods", ["None"], ["", "def", "cv_squared", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"The squared coefficient of variation of a sample.\n        Useful as a loss to encourage a positive distribution to be more uniform.\n        Epsilons added for numerical stability.\n        Returns 0 for an empty Tensor.\n        Args:\n        x: a `Tensor`.\n        Returns:\n        a `Scalar`.\n        \"\"\"", "\n", "eps", "=", "1e-10", "\n", "# if only num_experts = 1", "\n", "if", "x", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "return", "torch", ".", "Tensor", "(", "[", "0", "]", ")", "\n", "", "return", "x", ".", "float", "(", ")", ".", "var", "(", ")", "/", "(", "x", ".", "float", "(", ")", ".", "mean", "(", ")", "**", "2", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._gates_to_load": [[212, 221], ["None"], "methods", ["None"], ["", "def", "_gates_to_load", "(", "self", ",", "gates", ")", ":", "\n", "        ", "\"\"\"Compute the true load per expert, given the gates.\n        The load is the number of examples for which the corresponding gate is >0.\n        Args:\n        gates: a `Tensor` of shape [batch_size, n]\n        Returns:\n        a float32 `Tensor` of shape [n]\n        \"\"\"", "\n", "return", "(", "gates", ">", "0", ")", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._prob_in_top_k": [[222, 260], ["clean_values.size", "noisy_top_values.size", "noisy_top_values.flatten", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "moe_mlp.MoE.normal.cdf", "moe_mlp.MoE.normal.cdf", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "_prob_in_top_k", "(", "self", ",", "clean_values", ",", "noisy_values", ",", "noise_stddev", ",", "noisy_top_values", ")", ":", "\n", "        ", "\"\"\"Helper function to NoisyTopKGating.\n        Computes the probability that value is in top k, given different random noise.\n        This gives us a way of backpropagating from a loss that balances the number\n        of times each expert is in the top k experts per example.\n        In the case of no noise, pass in None for noise_stddev, and the result will\n        not be differentiable.\n        Args:\n        clean_values: a `Tensor` of shape [batch, n].\n        noisy_values: a `Tensor` of shape [batch, n].  Equal to clean values plus\n          normally distributed noise with standard deviation noise_stddev.\n        noise_stddev: a `Tensor` of shape [batch, n], or None\n        noisy_top_values: a `Tensor` of shape [batch, m].\n           \"values\" Output of tf.top_k(noisy_top_values, m).  m >= k+1\n        Returns:\n        a `Tensor` of shape [batch, n].\n        \"\"\"", "\n", "\n", "batch", "=", "clean_values", ".", "size", "(", "0", ")", "\n", "m", "=", "noisy_top_values", ".", "size", "(", "1", ")", "\n", "top_values_flat", "=", "noisy_top_values", ".", "flatten", "(", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "threshold_positions_if_in", "=", "(", "torch", ".", "arange", "(", "batch", ")", "*", "m", "+", "self", ".", "k", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "threshold_positions_if_in", "=", "(", "torch", ".", "arange", "(", "batch", ")", "*", "m", "+", "self", ".", "k", ")", "\n", "\n", "", "threshold_if_in", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_in", ")", ",", "1", ")", "\n", "is_in", "=", "torch", ".", "gt", "(", "noisy_values", ",", "threshold_if_in", ")", "\n", "if", "self", ".", "use_gpu", ":", "\n", "            ", "threshold_positions_if_out", "=", "(", "threshold_positions_if_in", "-", "1", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "threshold_positions_if_out", "=", "(", "threshold_positions_if_in", "-", "1", ")", "\n", "", "threshold_if_out", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "gather", "(", "top_values_flat", ",", "0", ",", "threshold_positions_if_out", ")", ",", "1", ")", "\n", "# is each value currently in the top k.", "\n", "prob_if_in", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_in", ")", "/", "noise_stddev", ")", "\n", "prob_if_out", "=", "self", ".", "normal", ".", "cdf", "(", "(", "clean_values", "-", "threshold_if_out", ")", "/", "noise_stddev", ")", "\n", "prob", "=", "torch", ".", "where", "(", "is_in", ",", "prob_if_in", ",", "prob_if_out", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.noisy_top_k_gating": [[262, 304], ["logits.topk", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "torch.zeros_like.scatter", "moe_mlp.MoE.gating_network", "min", "moe_mlp.MoE.softmax", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "moe_mlp.MoE._prob_in_top_k().sum", "moe_mlp.MoE._gates_to_load", "moe_mlp.MoE.softplus", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "moe_mlp.MoE._prob_in_top_k"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._gates_to_load", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE._prob_in_top_k"], ["", "def", "noisy_top_k_gating", "(", "self", ",", "x", ",", "train", ",", "noise_epsilon", "=", "1e-2", ")", ":", "\n", "        ", "\"\"\"Noisy top-k gating.\n          See paper: https://arxiv.org/abs/1701.06538.\n          Args:\n            x: input Tensor with shape [batch_size, input_size]\n            train: a boolean - we only add noise at training time.\n            noise_epsilon: a float\n          Returns:\n            gates: a Tensor with shape [batch_size, num_experts]\n            load: a Tensor with shape [num_experts]\n        \"\"\"", "\n", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "clean_logits", "=", "self", ".", "gating_network", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "clean_logits", "=", "x", "@", "self", ".", "w_gate", "\n", "", "if", "self", ".", "noisy_gating", ":", "\n", "            ", "raw_noise_stddev", "=", "x", "@", "self", ".", "w_noise", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "                ", "raw_noise_stddev", "=", "self", ".", "softplus", "(", "raw_noise_stddev", ")", "\n", "", "noise_stddev", "=", "(", "(", "raw_noise_stddev", "+", "noise_epsilon", ")", "*", "train", ")", "\n", "noisy_logits", "=", "clean_logits", "+", "(", "torch", ".", "randn_like", "(", "clean_logits", ")", "*", "noise_stddev", ")", "\n", "logits", "=", "noisy_logits", "\n", "", "else", ":", "\n", "            ", "logits", "=", "clean_logits", "\n", "\n", "# calculate topk + 1 that will be needed for the noisy gates", "\n", "", "top_logits", ",", "top_indices", "=", "logits", ".", "topk", "(", "min", "(", "self", ".", "k", "+", "1", ",", "self", ".", "num_experts", ")", ",", "dim", "=", "1", ")", "\n", "top_k_logits", "=", "top_logits", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "top_k_indices", "=", "top_indices", "[", ":", ",", ":", "self", ".", "k", "]", "\n", "if", "(", "self", ".", "k", ">", "1", ")", ":", "\n", "            ", "top_k_gates", "=", "self", ".", "softmax", "(", "top_k_logits", ")", "\n", "", "else", ":", "\n", "            ", "top_k_gates", "=", "torch", ".", "sigmoid", "(", "top_k_logits", ")", "\n", "", "zeros", "=", "torch", ".", "zeros_like", "(", "logits", ",", "requires_grad", "=", "True", ")", "\n", "gates", "=", "zeros", ".", "scatter", "(", "1", ",", "top_k_indices", ",", "top_k_gates", ")", "\n", "\n", "if", "self", ".", "noisy_gating", "and", "self", ".", "k", "<", "self", ".", "num_experts", ":", "\n", "            ", "load", "=", "(", "self", ".", "_prob_in_top_k", "(", "clean_logits", ",", "noisy_logits", ",", "noise_stddev", ",", "top_logits", ")", ")", ".", "sum", "(", "0", ")", "\n", "", "else", ":", "\n", "            ", "load", "=", "self", ".", "_gates_to_load", "(", "gates", ")", "\n", "", "return", "gates", ",", "load", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.get_utilisation_loss": [[306, 308], ["None"], "methods", ["None"], ["", "def", "get_utilisation_loss", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.forward": [[309, 339], ["moe_mlp.MoE.noisy_top_k_gating", "moe_mlp.SparseDispatcher.expert_to_gates", "moe_mlp.SparseDispatcher", "moe_mlp.SparseDispatcher.dispatch", "moe_mlp.SparseDispatcher.expert_to_gates", "range", "moe_mlp.SparseDispatcher.combine", "moe_mlp.MoE.cv_squared", "moe_mlp.MoE.cv_squared", "expert_outputs.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.noisy_top_k_gating", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.dispatch", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.expert_to_gates", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.SparseDispatcher.combine", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cv_squared"], ["", "def", "forward", "(", "self", ",", "x", ",", "train", "=", "True", ",", "loss_coef", "=", "1e-2", ")", ":", "\n", "        ", "\"\"\"Args:\n        x: tensor shape [batch_size, input_size]\n        train: a boolean scalar.\n        loss_coef: a scalar - multiplier on load-balancing losses\n        Returns:\n        y: a tensor with shape [batch_size, output_size].\n        extra_training_loss: a scalar.  This should be added into the overall\n        training loss of the model.  The backpropagation of this loss\n        encourages all experts to be approximately equally used across a batch.\n        \"\"\"", "\n", "# normalization is performed here for better convergence of the gating network", "\n", "x", "=", "2.0", "*", "(", "x", "-", "self", ".", "lb", ")", "/", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "-", "1.0", "\n", "gates", ",", "load", "=", "self", ".", "noisy_top_k_gating", "(", "x", ",", "train", ")", "\n", "# calculate importance loss", "\n", "importance", "=", "gates", ".", "sum", "(", "0", ")", "\n", "#", "\n", "loss", "=", "self", ".", "cv_squared", "(", "importance", ")", "+", "self", ".", "cv_squared", "(", "load", ")", "\n", "loss", "*=", "loss_coef", "\n", "self", ".", "loss", "=", "loss", "\n", "\n", "dispatcher", "=", "SparseDispatcher", "(", "self", ".", "num_experts", ",", "gates", ",", "self", ".", "use_gpu", ")", "\n", "expert_inputs", "=", "dispatcher", ".", "dispatch", "(", "x", ")", "\n", "gates", "=", "dispatcher", ".", "expert_to_gates", "(", ")", "\n", "expert_outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "if", "expert_inputs", "[", "i", "]", "is", "not", "None", ":", "\n", "                ", "expert_outputs", ".", "append", "(", "self", ".", "experts", "[", "i", "]", "(", "expert_inputs", "[", "i", "]", ")", ")", "\n", "", "", "y", "=", "dispatcher", ".", "combine", "(", "expert_outputs", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda": [[340, 349], ["super().cuda", "range", "moe_mlp.MoE.lb.cuda", "moe_mlp.MoE.ub.cuda", "moe_mlp.MoE.experts[].cuda", "moe_mlp.MoE.gating_network.cuda"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cuda"], ["", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "cuda", "(", ")", "\n", "self", ".", "use_gpu", "=", "True", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "cuda", "(", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "cuda", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cuda", "(", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu": [[350, 359], ["super().cpu", "range", "moe_mlp.MoE.lb.cpu", "moe_mlp.MoE.ub.cpu", "moe_mlp.MoE.experts[].cpu", "moe_mlp.MoE.gating_network.cpu"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.cpu"], ["", "", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "cpu", "(", ")", "\n", "self", ".", "use_gpu", "=", "False", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "cpu", "(", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "cpu", "(", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "cpu", "(", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to": [[360, 368], ["super().to", "range", "moe_mlp.MoE.lb.to", "moe_mlp.MoE.ub.to", "moe_mlp.MoE.experts[].to", "moe_mlp.MoE.gating_network.to"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.models.moe_mlp.MoE.to"], ["", "", "def", "to", "(", "self", ",", "device", ")", ":", "\n", "        ", "super", "(", "MoE", ",", "self", ")", ".", "to", "(", "device", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_experts", ")", ":", "\n", "            ", "self", ".", "experts", "[", "i", "]", ".", "to", "(", "device", ")", "\n", "", "self", ".", "lb", "=", "self", ".", "lb", ".", "to", "(", "device", ")", "\n", "self", ".", "ub", "=", "self", ".", "ub", ".", "to", "(", "device", ")", "\n", "if", "self", ".", "non_linear", ":", "\n", "            ", "self", ".", "gating_network", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.activations.snake.Snake.__init__": [[11, 18], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "float"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["def", "__init__", "(", "self", ",", "frequency", "=", "10", ")", ":", "\n", "        ", "\"\"\"Constructor function that initialize the torch module\n        \"\"\"", "\n", "super", "(", "Snake", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# making beta trainable by activating gradient calculation", "\n", "self", ".", "a", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "float", "(", "frequency", ")", "]", ",", "requires_grad", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.activations.snake.Snake.forward": [[19, 21], ["torch.sin", "torch.sin", "torch.sin", "torch.sin"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "+", "(", "(", "torch", ".", "sin", "(", "self", ".", "a", "*", "x", ")", ")", "**", "2", ")", "/", "self", ".", "a", "", "", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.InitialConditionDataset.__init__": [[97, 175], ["datasets.segmentation", "range", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "min", "numpy.random.seed", "numpy.random.permutation", "dtype1", "dtype1", "dtype1", "dtype1", "dtype1", "dtype1", "os.path.exists", "FileNotFoundError", "datasets.load_frame", "u_exact.reshape.reshape.reshape", "range", "datasets.InitialConditionDataset.x_values.min", "datasets.InitialConditionDataset.y_values.min", "datasets.InitialConditionDataset.t_values.min", "datasets.InitialConditionDataset.x_values.max", "datasets.InitialConditionDataset.y_values.max", "datasets.InitialConditionDataset.t_values.max", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "len", "datasets.InitialConditionDataset.u_values.append", "datasets.InitialConditionDataset.x_values.append", "datasets.InitialConditionDataset.y_values.append", "datasets.InitialConditionDataset.t_values.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.segmentation", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.load_frame"], ["def", "__init__", "(", "self", ",", "data_info", ",", "batch_size", ",", "num_batches", ",", "segm_params", ")", ":", "\n", "        ", "\"\"\"Constructor of the initial condition dataset.\n        Args:\n            data_info (dict): dictionary with info about the data (see the module docs).\n            batch_size (int): size of a mini-batch in the dataset.\n            num_batches (int): number of mini-batches in the dataset.\n        \"\"\"", "\n", "self", ".", "u_values", "=", "[", "]", "\n", "self", ".", "x_values", "=", "[", "]", "\n", "self", ".", "y_values", "=", "[", "]", "\n", "self", ".", "t_values", "=", "[", "]", "\n", "# Check if given path to data is valid", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\n", "data_info", "[", "\"path_data\"", "]", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "\n", "'Could not find file'", "+", "\n", "data_info", "[", "\"path_data\"", "]", ")", "\n", "# Calculate the segmentation mask for the data", "\n", "", "seg_mask", "=", "segmentation", "(", "\n", "data_info", "[", "\"path_data\"", "]", ",", "\n", "0", ",", "\n", "data_info", "[", "\"num_x\"", "]", ",", "\n", "data_info", "[", "\"num_y\"", "]", ",", "\n", "segm_params", ")", "\n", "# Load each t_step-th frame from the dataset", "\n", "for", "t_frame", "in", "range", "(", "\n", "0", ",", "data_info", "[", "\"num_t\"", "]", ",", "data_info", "[", "\"t_step\"", "]", ")", ":", "\n", "# Upload an image from dataset at time point t_frame", "\n", "            ", "u_exact", ",", "timing", "=", "load_frame", "(", "data_info", "[", "\"path_data\"", "]", ",", "t_frame", ")", "\n", "u_exact", "=", "u_exact", ".", "reshape", "(", "data_info", "[", "\"num_x\"", "]", ",", "data_info", "[", "\"num_y\"", "]", ")", "#.astype(np.float)      ", "\n", "u_exact", "=", "u_exact", "*", "seg_mask", "# apply segmentation", "\n", "# Sample only each pix_step-th spatial point from an image", "\n", "for", "x_i", "in", "range", "(", "\n", "0", ",", "data_info", "[", "\"num_x\"", "]", ",", "data_info", "[", "\"pix_step\"", "]", ")", ":", "\n", "                ", "for", "y_i", "in", "range", "(", "0", ",", "data_info", "[", "\"num_y\"", "]", ",", "data_info", "[", "\"pix_step\"", "]", ")", ":", "\n", "                    ", "if", "seg_mask", "[", "x_i", ",", "y_i", "]", "!=", "0", ":", "# neglect non-cortex data", "\n", "                        ", "self", ".", "u_values", ".", "append", "(", "u_exact", "[", "x_i", ",", "y_i", "]", ")", "\n", "self", ".", "x_values", ".", "append", "(", "x_i", ")", "\n", "self", ".", "y_values", ".", "append", "(", "y_i", ")", "\n", "self", ".", "t_values", ".", "append", "(", "timing", ")", "\n", "\n", "", "", "", "", "self", ".", "u_values", "=", "np", ".", "array", "(", "self", ".", "u_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "x_values", "=", "np", ".", "array", "(", "self", ".", "x_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "y_values", "=", "np", ".", "array", "(", "self", ".", "y_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "t_values", "=", "np", ".", "array", "(", "self", ".", "t_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "# Sometimes we are loading less files than we specified by batch_size + num_batches", "\n", "# => adapt num_batches to real number of batches for avoiding empty batches", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "num_samples", "=", "min", "(", "(", "num_batches", "*", "batch_size", ",", "len", "(", "self", ".", "x_values", ")", ")", ")", "\n", "self", ".", "num_batches", "=", "num_samples", "//", "self", ".", "batch_size", "\n", "# Convert grid coordinates to physical quantities ([mm])", "\n", "self", ".", "x_values", "=", "self", ".", "x_values", "*", "data_info", "[", "\"spat_res\"", "]", "\n", "self", ".", "y_values", "=", "self", ".", "y_values", "*", "data_info", "[", "\"spat_res\"", "]", "\n", "# Create lists with boundary values for spatio-temporal coordinates", "\n", "self", ".", "low_bound", "=", "[", "\n", "self", ".", "x_values", ".", "min", "(", ")", ",", "\n", "self", ".", "y_values", ".", "min", "(", ")", ",", "\n", "self", ".", "t_values", ".", "min", "(", ")", "]", "\n", "self", ".", "up_bound", "=", "[", "\n", "self", ".", "x_values", ".", "max", "(", ")", ",", "\n", "self", ".", "y_values", ".", "max", "(", ")", ",", "\n", "self", ".", "t_values", ".", "max", "(", ")", "]", "\n", "dtype1", "=", "torch", ".", "FloatTensor", "\n", "# Generate random permutation idx", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "rand_idx", "=", "np", ".", "random", ".", "permutation", "(", "self", ".", "x_values", ".", "shape", "[", "0", "]", ")", "\n", "# Permutate data points", "\n", "self", ".", "x_values", "=", "self", ".", "x_values", "[", "rand_idx", "]", "\n", "self", ".", "y_values", "=", "self", ".", "y_values", "[", "rand_idx", "]", "\n", "self", ".", "t_values", "=", "self", ".", "t_values", "[", "rand_idx", "]", "\n", "self", ".", "u_values", "=", "self", ".", "u_values", "[", "rand_idx", "]", "\n", "# Slice data for training and convert to torch tensors", "\n", "self", ".", "x_values", "=", "dtype1", "(", "self", ".", "x_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "y_values", "=", "dtype1", "(", "self", ".", "y_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "t_values", "=", "dtype1", "(", "self", ".", "t_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "u_values", "=", "dtype1", "(", "self", ".", "u_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "low_bound", "=", "dtype1", "(", "self", ".", "low_bound", ")", "\n", "self", ".", "up_bound", "=", "dtype1", "(", "self", ".", "up_bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.InitialConditionDataset.__len__": [[176, 181], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Length of the dataset.\n        \"\"\"", "\n", "return", "self", ".", "num_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.InitialConditionDataset.__getitem__": [[182, 201], ["torch.stack", "u_values.reshape"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Returns a mini-batch at given index containing X,u.\n        Args:\n            index(int): index of the mini-batch.\n        Returns:\n            X: spatio-temporal coordinates x,y,t concatenated.\n            u: real-value function of spatio-temporal coordinates.\n        \"\"\"", "\n", "# Generate batch for inital solution", "\n", "x_values", "=", "(", "\n", "self", ".", "x_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "y_values", "=", "(", "\n", "self", ".", "y_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "t_values", "=", "(", "\n", "self", ".", "t_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "u_values", "=", "(", "\n", "self", ".", "u_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "return", "torch", ".", "stack", "(", "[", "x_values", ",", "y_values", ",", "t_values", "]", ",", "1", ")", ",", "u_values", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.PDEDataset.__init__": [[206, 254], ["datasets.segmentation", "range", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "min", "numpy.random.seed", "numpy.random.permutation", "dtype1", "dtype1", "dtype1", "range", "datasets.load_frame", "range", "numpy.array", "numpy.array", "numpy.array", "len", "datasets.PDEDataset.x_values.append", "datasets.PDEDataset.y_values.append", "datasets.PDEDataset.t_values.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.segmentation", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.load_frame"], ["def", "__init__", "(", "self", ",", "data_info", ",", "batch_size", ",", "num_batches", ",", "segm_params", ")", ":", "\n", "        ", "\"\"\"Constructor of the residual poins dataset.\n        Args:\n            data_info (dict): dictionary with info about the data.\n            batch_size (int): size of a mini-batch in the dataset.\n            num_batches (int): number of mini-batches in the dataset.\n        \"\"\"", "\n", "self", ".", "x_values", "=", "[", "]", "\n", "self", ".", "y_values", "=", "[", "]", "\n", "self", ".", "t_values", "=", "[", "]", "\n", "seg_mask", "=", "segmentation", "(", "\n", "data_info", "[", "\"path_data\"", "]", ",", "0", ",", "data_info", "[", "\"num_x\"", "]", ",", "data_info", "[", "\"num_y\"", "]", ",", "segm_params", ")", "\n", "# Consider only each t_step-th frame", "\n", "for", "t_frame", "in", "range", "(", "\n", "0", ",", "data_info", "[", "\"num_t\"", "]", ",", "data_info", "[", "\"t_step\"", "]", ")", ":", "\n", "            ", "t_frame", "=", "load_frame", "(", "data_info", "[", "\"path_data\"", "]", ",", "t_frame", ")", "[", "1", "]", "\n", "# Sample only each pix_step-th spatial point from the range", "\n", "for", "x_i", "in", "range", "(", "\n", "0", ",", "data_info", "[", "\"num_x\"", "]", ",", "data_info", "[", "\"pix_step\"", "]", ")", ":", "\n", "                ", "for", "y_i", "in", "range", "(", "0", ",", "data_info", "[", "\"num_y\"", "]", ",", "data_info", "[", "\"pix_step\"", "]", ")", ":", "\n", "                    ", "if", "seg_mask", "[", "x_i", ",", "y_i", "]", "!=", "0", ":", "# neglect non-cortex data", "\n", "                        ", "self", ".", "x_values", ".", "append", "(", "x_i", ")", "\n", "self", ".", "y_values", ".", "append", "(", "y_i", ")", "\n", "self", ".", "t_values", ".", "append", "(", "t_frame", ")", "\n", "\n", "", "", "", "", "self", ".", "x_values", "=", "np", ".", "array", "(", "self", ".", "x_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "y_values", "=", "np", ".", "array", "(", "self", ".", "y_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "t_values", "=", "np", ".", "array", "(", "self", ".", "t_values", ")", ".", "reshape", "(", "-", "1", ")", "\n", "# Sometimes we are loading less files than we specified by batch_size + num_batches", "\n", "# => adapt num_batches to real number of batches for avoiding empty batches", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "num_batches", "=", "num_batches", "\n", "num_samples", "=", "min", "(", "(", "num_batches", "*", "batch_size", ",", "len", "(", "self", ".", "x_values", ")", ")", ")", "\n", "# Convert grid coordinates to physical quantities ([mm])", "\n", "self", ".", "x_values", "=", "self", ".", "x_values", "*", "data_info", "[", "\"spat_res\"", "]", "\n", "self", ".", "y_values", "=", "self", ".", "y_values", "*", "data_info", "[", "\"spat_res\"", "]", "\n", "dtype1", "=", "torch", ".", "FloatTensor", "\n", "# Slice data for training and convert to torch tensors", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "rand_idx", "=", "np", ".", "random", ".", "permutation", "(", "self", ".", "x_values", ".", "shape", "[", "0", "]", ")", "\n", "# Permutate data points", "\n", "self", ".", "x_values", "=", "self", ".", "x_values", "[", "rand_idx", "]", "\n", "self", ".", "y_values", "=", "self", ".", "y_values", "[", "rand_idx", "]", "\n", "self", ".", "t_values", "=", "self", ".", "t_values", "[", "rand_idx", "]", "\n", "# Slice data for training and convert to torch tensors", "\n", "self", ".", "x_values", "=", "dtype1", "(", "self", ".", "x_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "y_values", "=", "dtype1", "(", "self", ".", "y_values", "[", ":", "num_samples", "]", ")", "\n", "self", ".", "t_values", "=", "dtype1", "(", "self", ".", "t_values", "[", ":", "num_samples", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.PDEDataset.__len__": [[255, 260], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Length of the dataset.\n        \"\"\"", "\n", "return", "self", ".", "num_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.PDEDataset.__getitem__": [[261, 277], ["torch.stack"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Returns a mini-batch at given index containing X.\n        Args:\n            index(int): index of the mini-batch.\n        Returns:\n            X: spatio-temporal coordinates x,y,t concatenated.\n        \"\"\"", "\n", "# Generate batch with residual points", "\n", "x_values", "=", "(", "\n", "self", ".", "x_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "y_values", "=", "(", "\n", "self", ".", "y_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "t_values", "=", "(", "\n", "self", ".", "t_values", "[", "index", "*", "self", ".", "batch_size", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batch_size", "]", ")", "\n", "return", "torch", ".", "stack", "(", "[", "x_values", ",", "y_values", ",", "t_values", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.load_frame": [[31, 51], ["h5py.File", "numpy.array", "numpy.array", "h5py.File.close", "os.path.exists", "FileNotFoundError", "str"], "function", ["None"], ["def", "load_frame", "(", "path_data", ",", "t_frame", ")", ":", "\n", "    ", "\"\"\"\n    Upload t_frame-th image from data.\n    Args:\n        path_data (str): path to data folder.\n        t_frame (int): number of time frame to take.\n    Returns:\n        value (numpy array): image data.\n        timing (float): relative time point when the image was acquired [s].\n    \"\"\"", "\n", "# Check if given path to data is valid", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "\n", "path_data", ")", ":", "\n", "        ", "raise", "FileNotFoundError", "(", "'Could not find file'", "+", "path_data", ")", "\n", "# Upload the data", "\n", "", "h5_file", "=", "h5py", ".", "File", "(", "path_data", "+", "str", "(", "t_frame", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "value", "=", "np", ".", "array", "(", "h5_file", "[", "'seq'", "]", "[", ":", "]", ")", "\n", "timing", "=", "np", ".", "array", "(", "h5_file", "[", "'timing'", "]", "[", ":", "]", ")", "\n", "h5_file", ".", "close", "(", ")", "\n", "return", "value", ",", "timing", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.segmentation": [[52, 92], ["h5py.File", "numpy.array", "h5py.File.close", "numpy.array().reshape", "skimage.restoration.denoise_bilateral.reshape", "skimage.restoration.denoise_bilateral.astype", "skimage.restoration.denoise_bilateral", "skimage.filters.sobel", "numpy.zeros_like", "skimage.segmentation.watershed", "scipy.ndimage.binary_fill_holes", "numpy.array", "numpy.array", "str"], "function", ["None"], ["", "def", "segmentation", "(", "path_data", ",", "t_frame", ",", "num_x", ",", "num_y", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    Calculate segmentation mask for the brain cortex depicted at time point t_frame.\n    Segmentation is calculated based on smoothing + watershed algorithm with predefined threshold.\n    Args:\n        path_data (str): path to data folder.\n        t_frame (int): number of time frame to take.\n        num_x (int): length of an image.\n        num_y (int): width of an image.\n        params (list): list of the from [threshold, sigma_color, sigma_spatial].\n            threshold (float): absolute minimum height value used during processing.\n            sigma_color (float): filter sigma in the color space. \n            sigma_spatial (float): filter sigma in the coordinate space. \n    Returns:\n        seg_mask (numpy array [num_x, num_y]): binary segmentation mask.\n    \"\"\"", "\n", "threshold", ",", "sigma_color", ",", "sigma_spatial", "=", "params", "\n", "# Upload an image at time point t_frame", "\n", "h5_file", "=", "h5py", ".", "File", "(", "path_data", "+", "str", "(", "t_frame", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "value", "=", "np", ".", "array", "(", "h5_file", "[", "'seq'", "]", "[", ":", "]", ")", "\n", "h5_file", ".", "close", "(", ")", "\n", "# Reshape image from 1D array to 2D array", "\n", "value", "=", "np", ".", "array", "(", "value", ")", ".", "reshape", "(", "-", "1", ")", "\n", "value", "=", "value", ".", "reshape", "(", "num_x", ",", "num_y", ")", "\n", "value", "=", "value", ".", "astype", "(", "np", ".", "float", ")", "\n", "# Apply bilateralFilter to improve segmentation quality", "\n", "value", "=", "denoise_bilateral", "(", "\n", "value", ",", "\n", "sigma_color", "=", "sigma_color", ",", "\n", "sigma_spatial", "=", "sigma_spatial", ",", "\n", "multichannel", "=", "False", ")", "\n", "# Segmentation algorithm", "\n", "elevation_map", "=", "sobel", "(", "value", ")", "\n", "markers", "=", "np", ".", "zeros_like", "(", "value", ")", "\n", "markers", "[", "value", ">", "threshold", "]", "=", "2", "\n", "markers", "[", "value", "<=", "threshold", "]", "=", "1", "\n", "seg_mask", "=", "watershed", "(", "elevation_map", ",", "markers", ")", "\n", "seg_mask", "=", "binary_fill_holes", "(", "seg_mask", "-", "1", ")", "\n", "seg_mask", "=", "np", ".", "array", "(", "seg_mask", ",", "dtype", "=", "np", ".", "int", ")", "\n", "return", "seg_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_UKD_Heat.datasets.derivatives": [[278, 316], ["torch.ones", "du_dx_values[].reshape", "du_dx_values[].reshape", "du_dx_values[].reshape", "u_xx_values[].reshape", "u_yy_values[].reshape", "x_values.reshape.reshape", "y_values.reshape.reshape", "t_values.reshape.reshape", "torch.stack().squeeze", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.stack"], "function", ["None"], ["", "", "def", "derivatives", "(", "x_values", ",", "u_values", ")", ":", "\n", "    ", "\"\"\"\n    Create an input for the HPM model.\n    Args:\n        x_values (torch tensor): concatenated spatio-temporal and grid coordinaties (x,y,t).\n        u_values (torch tensor): real-value function to differentiate.\n    Returns:\n        x, y, t, u, d2u/dx2, d2u/dy2, du/dt concatenated.\n    \"\"\"", "\n", "# Save input in variables is necessary for gradient calculation", "\n", "x_values", ".", "requires_grad", "=", "True", "\n", "# Calculate derivatives with torch automatic differentiation", "\n", "# Move to the same device as prediction", "\n", "grads", "=", "torch", ".", "ones", "(", "u_values", ".", "shape", ",", "device", "=", "u_values", ".", "device", ")", "\n", "du_dx_values", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "u_values", ",", "\n", "x_values", ",", "\n", "create_graph", "=", "True", ",", "\n", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "#du_dx_values = [du/dx, du/dy, du/dt]", "\n", "u_x_values", "=", "du_dx_values", "[", ":", ",", "0", "]", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "u_y_values", "=", "du_dx_values", "[", ":", ",", "1", "]", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "u_t_values", "=", "du_dx_values", "[", ":", ",", "2", "]", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "u_xx_values", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "u_x_values", ",", "x_values", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "u_yy_values", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "u_y_values", ",", "x_values", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "#u_xx = [u_xx, u_xy, u_xt]", "\n", "u_xx_values", "=", "u_xx_values", "[", ":", ",", "0", "]", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "#u_yy = [u_yx, u_yy, u_yt]", "\n", "u_yy_values", "=", "u_yy_values", "[", ":", ",", "1", "]", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "x_values", ",", "y_values", ",", "t_values", "=", "x_values", ".", "T", "\n", "\n", "x_values", "=", "x_values", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "y_values", "=", "y_values", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "t_values", "=", "t_values", ".", "reshape", "(", "u_values", ".", "shape", ")", "\n", "return", "torch", ".", "stack", "(", "[", "x_values", ",", "y_values", ",", "t_values", ",", "u_values", ",", "u_x_values", ",", "u_y_values", ",", "\n", "u_xx_values", ",", "u_yy_values", ",", "u_t_values", "]", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.BoundaryConditionDataset.__init__": [[19, 33], ["torch.utils.data.Dataset.__init__", "scipy.io.loadmat", "numpy.random.choice", "numpy.concatenate", "numpy.concatenate", "data[].flatten", "type"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nb", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the initial condition dataset\n\n        Args:\n          n0 (int)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "data", "=", "scipy", ".", "io", ".", "loadmat", "(", "'NLS.mat'", ")", "\n", "t", "=", "data", "[", "'tt'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "idx_t", "=", "np", ".", "random", ".", "choice", "(", "t", ".", "shape", "[", "0", "]", ",", "nb", ",", "replace", "=", "False", ")", "\n", "tb", "=", "t", "[", "idx_t", ",", ":", "]", "\n", "self", ".", "x_lb", "=", "np", ".", "concatenate", "(", "(", "0", "*", "tb", "+", "lb", "[", "0", "]", ",", "tb", ")", ",", "1", ")", "# (lb[0], tb)", "\n", "self", ".", "x_ub", "=", "np", ".", "concatenate", "(", "(", "0", "*", "tb", "+", "ub", "[", "0", "]", ",", "tb", ")", ",", "1", ")", "# (ub[0], tb)", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.BoundaryConditionDataset.__getitem__": [[34, 39], ["torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data for initial state\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "x_lb", ")", ".", "float", "(", ")", ",", "Tensor", "(", "self", ".", "x_ub", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.BoundaryConditionDataset.__len__": [[40, 45], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.InitialConditionDataset.__init__": [[49, 68], ["torch.utils.data.Dataset.__init__", "scipy.io.loadmat", "numpy.real", "numpy.imag", "numpy.random.choice", "numpy.zeros", "data[].flatten", "data[].flatten", "type"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the boundary condition dataset\n\n        Args:\n          n0 (int)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "data", "=", "scipy", ".", "io", ".", "loadmat", "(", "'NLS.mat'", ")", "\n", "x", "=", "data", "[", "'x'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "t", "=", "data", "[", "'tt'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "Exact", "=", "data", "[", "'uu'", "]", "\n", "Exact_u", "=", "np", ".", "real", "(", "Exact", ")", "\n", "Exact_v", "=", "np", ".", "imag", "(", "Exact", ")", "\n", "idx_x", "=", "np", ".", "random", ".", "choice", "(", "x", ".", "shape", "[", "0", "]", ",", "n0", ",", "replace", "=", "False", ")", "\n", "self", ".", "x", "=", "x", "[", "idx_x", ",", ":", "]", "\n", "self", ".", "u", "=", "Exact_u", "[", "idx_x", ",", "0", ":", "1", "]", "\n", "self", ".", "v", "=", "Exact_v", "[", "idx_x", ",", "0", ":", "1", "]", "\n", "self", ".", "t", "=", "np", ".", "zeros", "(", "self", ".", "x", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.InitialConditionDataset.__len__": [[69, 74], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.InitialConditionDataset.__getitem__": [[75, 79], ["numpy.concatenate", "numpy.concatenate", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "x", "=", "np", ".", "concatenate", "(", "[", "self", ".", "x", ",", "self", ".", "t", "]", ",", "axis", "=", "1", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "[", "self", ".", "u", ",", "self", ".", "v", "]", ",", "axis", "=", "1", ")", "\n", "return", "Tensor", "(", "x", ")", ".", "float", "(", ")", ",", "Tensor", "(", "y", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.PDEDataset.__init__": [[82, 84], ["pyDOE.lhs"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "nf", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "self", ".", "xf", "=", "lb", "+", "(", "ub", "-", "lb", ")", "*", "lhs", "(", "2", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.PDEDataset.__getitem__": [[85, 90], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data for initial state\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "xf", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Schroedinger.1D_Schroedinger.PDEDataset.__len__": [[91, 96], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.InitialConditionDataset.__init__": [[21, 50], ["torch.utils.data.Dataset.__init__", "scipy.io.loadmat", "numpy.meshgrid", "numpy.meshgrid", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.vstack", "numpy.vstack", "numpy.vstack", "numpy.vstack", "numpy.random.choice", "numpy.random.choice", "data[].flatten", "data[].flatten", "numpy.real", "numpy.real", "type"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the boundary condition dataset\n\n        Args:\n          n0 (int)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "data", "=", "scipy", ".", "io", ".", "loadmat", "(", "'burgers_shock.mat'", ")", "\n", "\n", "t", "=", "data", "[", "'t'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "x", "=", "data", "[", "'x'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "\n", "Exact", "=", "np", ".", "real", "(", "data", "[", "'usol'", "]", ")", ".", "T", "\n", "\n", "X", ",", "T", "=", "np", ".", "meshgrid", "(", "x", ",", "t", ")", "\n", "xx1", "=", "np", ".", "hstack", "(", "(", "X", "[", "0", ":", "1", ",", ":", "]", ".", "T", ",", "T", "[", "0", ":", "1", ",", ":", "]", ".", "T", ")", ")", "\n", "uu1", "=", "Exact", "[", "0", ":", "1", ",", ":", "]", ".", "T", "\n", "xx2", "=", "np", ".", "hstack", "(", "(", "X", "[", ":", ",", "0", ":", "1", "]", ",", "T", "[", ":", ",", "0", ":", "1", "]", ")", ")", "\n", "uu2", "=", "Exact", "[", ":", ",", "0", ":", "1", "]", "\n", "xx3", "=", "np", ".", "hstack", "(", "(", "X", "[", ":", ",", "-", "1", ":", "]", ",", "T", "[", ":", ",", "-", "1", ":", "]", ")", ")", "\n", "uu3", "=", "Exact", "[", ":", ",", "-", "1", ":", "]", "\n", "\n", "X_u_train", "=", "np", ".", "vstack", "(", "[", "xx1", ",", "xx2", ",", "xx3", "]", ")", "\n", "u_train", "=", "np", ".", "vstack", "(", "[", "uu1", ",", "uu2", ",", "uu3", "]", ")", "\n", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "X_u_train", ".", "shape", "[", "0", "]", ",", "n0", ",", "replace", "=", "False", ")", "\n", "self", ".", "X_u_train", "=", "X_u_train", "[", "idx", ",", ":", "]", "\n", "self", ".", "u_train", "=", "u_train", "[", "idx", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.InitialConditionDataset.__len__": [[51, 56], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.InitialConditionDataset.__getitem__": [[57, 62], ["torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "x", "=", "self", ".", "X_u_train", "\n", "y", "=", "self", ".", "u_train", "\n", "\n", "return", "Tensor", "(", "x", ")", ".", "float", "(", ")", ",", "Tensor", "(", "y", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.PDEDataset.__init__": [[65, 76], ["scipy.io.loadmat", "numpy.meshgrid", "numpy.meshgrid", "numpy.hstack", "numpy.hstack", "numpy.hstack.min", "numpy.hstack.max", "data[].flatten", "data[].flatten", "pyDOE.lhs", "X.flatten", "T.flatten"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "nf", ")", ":", "\n", "        ", "data", "=", "scipy", ".", "io", ".", "loadmat", "(", "'burgers_shock.mat'", ")", "\n", "t", "=", "data", "[", "'t'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "x", "=", "data", "[", "'x'", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "X", ",", "T", "=", "np", ".", "meshgrid", "(", "x", ",", "t", ")", "\n", "\n", "X_star", "=", "np", ".", "hstack", "(", "(", "X", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", ",", "T", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", ")", ")", "\n", "self", ".", "lb", "=", "X_star", ".", "min", "(", "0", ")", "\n", "self", ".", "ub", "=", "X_star", ".", "max", "(", "0", ")", "\n", "\n", "self", ".", "xf", "=", "self", ".", "lb", "+", "(", "self", ".", "ub", "-", "self", ".", "lb", ")", "*", "lhs", "(", "2", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.PDEDataset.__getitem__": [[77, 82], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data for initial state\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "xf", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Burgers_Equation.1D_Burgers_Equation.PDEDataset.__len__": [[83, 88], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.BoundaryConditionDataset.__init__": [[15, 20], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "nb", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the initial condition dataset\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.BoundaryConditionDataset.__getitem__": [[21, 26], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data for initial state\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.BoundaryConditionDataset.__len__": [[27, 32], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Length of the dataset\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.get2DGrid": [[36, 50], ["numpy.arange", "numpy.arange", "numpy.meshgrid", "xGrid.reshape", "yGrid.reshape"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get2DGrid", "(", "nx", ",", "ny", ")", ":", "\n", "        ", "\"\"\"\n        Create a vector with all postions of a 2D grid (nx X ny )\n        \"\"\"", "\n", "x", "=", "np", ".", "arange", "(", "0", ",", "nx", ",", "1", ")", "\n", "y", "=", "np", ".", "arange", "(", "0", ",", "ny", ",", "1", ")", "\n", "\n", "xGrid", ",", "yGrid", "=", "np", ".", "meshgrid", "(", "x", ",", "y", ")", "\n", "\n", "posX", "=", "xGrid", ".", "reshape", "(", "-", "1", ")", "\n", "posY", "=", "yGrid", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "return", "posX", ",", "posY", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.get3DGrid": [[51, 67], ["numpy.arange", "numpy.arange", "numpy.arange", "numpy.meshgrid", "xGrid.reshape", "yGrid.reshape", "tGrid.reshape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get3DGrid", "(", "nx", ",", "ny", ",", "nt", ")", ":", "\n", "        ", "\"\"\"\n        Create a vector with all postions of a 3D grid (nx X ny X nt)\n        \"\"\"", "\n", "x", "=", "np", ".", "arange", "(", "0", ",", "nx", ",", "1", ")", "\n", "y", "=", "np", ".", "arange", "(", "0", ",", "ny", ",", "1", ")", "\n", "t", "=", "np", ".", "arange", "(", "0", ",", "nt", ",", "1", ")", "\n", "\n", "xGrid", ",", "yGrid", ",", "tGrid", "=", "np", ".", "meshgrid", "(", "x", ",", "y", ",", "t", ")", "\n", "\n", "posX", "=", "xGrid", ".", "reshape", "(", "-", "1", ")", "\n", "posY", "=", "yGrid", ".", "reshape", "(", "-", "1", ")", "\n", "posT", "=", "tGrid", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "return", "posX", ",", "posY", ",", "posT", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.getInput": [[68, 95], ["h5py.File", "numpy.array", "h5py.File.close", "Datasets.InitialConditionDataset.get2DGrid", "numpy.zeros", "str"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.get2DGrid"], ["", "@", "staticmethod", "\n", "def", "getInput", "(", "pData", ",", "tPoint", ",", "cSystem", ",", "spatRes", "=", "0.3", ")", ":", "\n", "        ", "\"\"\"\n        Get the spatiotemporal coordinates for a specific time point tPoint\n        The function returns a list of grid points appended with time t (nx X ny X nt)\n        pData: path to a dataset\n        cSystem: dictionary storing information about the dataset\n        spatRes: spatial resolution of an image in the dataset [mm/pixel]\n        \"\"\"", "\n", "# Upload an image at time point tPoint", "\n", "# hf = {'seq': thermal data at t, 'timing': t x image length}", "\n", "hf", "=", "h5py", ".", "File", "(", "pData", "+", "str", "(", "tPoint", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "t", "=", "np", ".", "array", "(", "hf", "[", "'timing'", "]", "[", "0", "]", ")", "\n", "hf", ".", "close", "(", ")", "\n", "\n", "# Get spatial grid for an image", "\n", "posX", ",", "posY", "=", "InitialConditionDataset", ".", "get2DGrid", "(", "\n", "cSystem", "[", "\"nx\"", "]", ",", "cSystem", "[", "\"ny\"", "]", ")", "\n", "\n", "size", "=", "cSystem", "[", "\"nx\"", "]", "*", "cSystem", "[", "\"ny\"", "]", "# number of pixels in an image", "\n", "posT", "=", "np", ".", "zeros", "(", "size", ")", "+", "t", "\n", "\n", "# Convert indices to physical quantities", "\n", "posX", "=", "posX", "*", "spatRes", "\n", "posY", "=", "posY", "*", "spatRes", "\n", "\n", "return", "posX", ",", "posY", ",", "posT", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.segmentation": [[96, 131], ["h5py.File", "numpy.array", "h5py.File.close", "numpy.array().reshape", "skimage.restoration.denoise_bilateral.reshape", "skimage.restoration.denoise_bilateral", "skimage.filters.sobel", "numpy.zeros_like", "skimage.segmentation.watershed", "scipy.ndimage.binary_fill_holes", "numpy.array", "numpy.array", "str"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "segmentation", "(", "pData", ",", "tPoint", ",", "nx", ",", "ny", ",", "threshold", "=", "32.4", ")", ":", "\n", "        ", "\"\"\"\n        Calculate segmentation mask for the brain cortex depicted at time point tPoint\n        pData: path to a dataset\n        cSystem: dictionary storing information about the dataset\n        Segmentation is calculated based on watershed algorithm with predefined threshold\n        \"\"\"", "\n", "# Upload an image at time point tPoint", "\n", "# hf = {'seq': thermal data at t, 'timing': t x image length}", "\n", "hf", "=", "h5py", ".", "File", "(", "pData", "+", "str", "(", "tPoint", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "value", "=", "np", ".", "array", "(", "hf", "[", "'seq'", "]", "[", ":", "]", ")", "\n", "hf", ".", "close", "(", ")", "\n", "\n", "# Reshape image from 1D array to 2D array", "\n", "value", "=", "np", ".", "array", "(", "value", ")", ".", "reshape", "(", "-", "1", ")", "\n", "value", "=", "value", ".", "reshape", "(", "nx", ",", "ny", ")", "\n", "\n", "# Apply bilateralFilter to improve segmentation quality", "\n", "value", "=", "denoise_bilateral", "(", "\n", "value", ",", "\n", "sigma_color", "=", "5", ",", "\n", "sigma_spatial", "=", "5", ",", "\n", "multichannel", "=", "False", ")", "\n", "\n", "# Segmentation algorithm", "\n", "elevation_map", "=", "sobel", "(", "value", ")", "\n", "markers", "=", "np", ".", "zeros_like", "(", "value", ")", "\n", "markers", "[", "value", ">", "threshold", "]", "=", "2", "\n", "markers", "[", "value", "<=", "threshold", "]", "=", "1", "\n", "segmentation", "=", "watershed", "(", "elevation_map", ",", "markers", ")", "\n", "segmentation", "=", "binary_fill_holes", "(", "segmentation", "-", "1", ")", "\n", "segmentation", "=", "np", ".", "array", "(", "segmentation", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "return", "segmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.loadFrame": [[132, 147], ["h5py.File", "numpy.array", "numpy.array", "h5py.File.close", "os.path.exists", "FileNotFoundError", "str"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "loadFrame", "(", "pData", ",", "tPoint", ")", ":", "\n", "        ", "\"\"\"\n        Upload an image from dataset at time point tPoint\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "pData", ")", ":", "# Check if given path to data is valid", "\n", "            ", "raise", "FileNotFoundError", "(", "'Could not find file'", "+", "pData", ")", "\n", "\n", "# hf = {'seq': thermal data at t, 'timing': t x image length}", "\n", "", "hf", "=", "h5py", ".", "File", "(", "pData", "+", "str", "(", "tPoint", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "value", "=", "np", ".", "array", "(", "hf", "[", "'seq'", "]", "[", ":", "]", ")", "\n", "timing", "=", "np", ".", "array", "(", "hf", "[", "'timing'", "]", "[", ":", "]", ")", "\n", "hf", ".", "close", "(", ")", "\n", "\n", "return", "value", ",", "timing", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.__init__": [[148, 244], ["h5py.File", "numpy.array", "h5py.File.close", "Datasets.InitialConditionDataset.segmentation", "range", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "print", "print", "min", "print", "print", "numpy.random.RandomState", "numpy.array", "numpy.array", "Datasets.InitialConditionDataset.dtype", "Datasets.InitialConditionDataset.dtype", "Datasets.InitialConditionDataset.dtype", "Datasets.InitialConditionDataset.dtype", "os.path.exists", "FileNotFoundError", "Datasets.InitialConditionDataset.loadFrame", "range", "len", "Datasets.InitialConditionDataset.x.min", "Datasets.InitialConditionDataset.x.max", "Datasets.InitialConditionDataset.y.min", "Datasets.InitialConditionDataset.y.max", "Datasets.InitialConditionDataset.t.max", "Datasets.InitialConditionDataset.randomState.permutation", "Exact_u.reshape", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "len", "Datasets.InitialConditionDataset.x.min", "Datasets.InitialConditionDataset.y.min", "Datasets.InitialConditionDataset.t.min", "Datasets.InitialConditionDataset.x.max", "Datasets.InitialConditionDataset.y.max", "Datasets.InitialConditionDataset.t.max", "str", "Datasets.InitialConditionDataset.u.append", "Datasets.InitialConditionDataset.x.append", "Datasets.InitialConditionDataset.y.append", "Datasets.InitialConditionDataset.t.append"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.segmentation", "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.loadFrame"], ["", "def", "__init__", "(", "self", ",", "pData", ",", "batchSize", ",", "numBatches", ",", "nt", ",", "timeStep", ",", "nx", "=", "640", ",", "\n", "ny", "=", "480", ",", "pixStep", "=", "4", ",", "shuffle", "=", "True", ",", "useGPU", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the initial condition dataset\n        __getitem()__ returns a batch with x,y,t to compute u_predicted value at as well as u_exact\n        \"\"\"", "\n", "self", ".", "u", "=", "[", "]", "# thermal data", "\n", "self", ".", "x", "=", "[", "]", "\n", "self", ".", "y", "=", "[", "]", "\n", "self", ".", "t", "=", "[", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "pData", ")", ":", "# Check if given path to data is valid", "\n", "            ", "raise", "FileNotFoundError", "(", "'Could not find file'", "+", "pData", ")", "\n", "\n", "# Find out the last time point which data is presented at", "\n", "", "hf", "=", "h5py", ".", "File", "(", "pData", "+", "str", "(", "nt", "-", "1", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "tmax", "=", "np", ".", "array", "(", "hf", "[", "'timing'", "]", "[", "0", "]", ")", "\n", "hf", ".", "close", "(", ")", "\n", "\n", "self", ".", "seg_mask", "=", "self", ".", "segmentation", "(", "\n", "pData", "=", "pData", ",", "tPoint", "=", "0", ",", "nx", "=", "nx", ",", "ny", "=", "ny", ")", "# segmentation mask", "\n", "\n", "for", "tPoint", "in", "range", "(", "\n", "0", ",", "nt", ",", "timeStep", ")", ":", "# load each timeStep-th frame from the dataset", "\n", "# Upload an image from dataset at time point tPoint", "\n", "            ", "Exact_u", ",", "timing", "=", "self", ".", "loadFrame", "(", "pData", ",", "tPoint", ")", "\n", "Exact_u", "=", "Exact_u", ".", "reshape", "(", "\n", "nx", ",", "ny", ")", "*", "self", ".", "seg_mask", "# apply segmentation", "\n", "for", "xi", "in", "range", "(", "\n", "0", ",", "nx", ",", "pixStep", ")", ":", "# sample only each pixStep-th spatial point from an image", "\n", "                ", "for", "yi", "in", "range", "(", "0", ",", "ny", ",", "pixStep", ")", ":", "\n", "                    ", "if", "Exact_u", "[", "xi", ",", "yi", "]", "!=", "0", ":", "# neglect non-cortex data", "\n", "                        ", "self", ".", "u", ".", "append", "(", "Exact_u", "[", "xi", ",", "yi", "]", ")", "\n", "self", ".", "x", ".", "append", "(", "xi", ")", "\n", "self", ".", "y", ".", "append", "(", "yi", ")", "\n", "self", ".", "t", ".", "append", "(", "timing", ")", "\n", "\n", "# Convert python lists to numpy arrays", "\n", "", "", "", "", "self", ".", "u", "=", "np", ".", "array", "(", "self", ".", "u", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "x", "=", "np", ".", "array", "(", "self", ".", "x", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "y", "=", "np", ".", "array", "(", "self", ".", "y", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "t", "=", "np", ".", "array", "(", "self", ".", "t", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "print", "(", "len", "(", "self", ".", "x", ")", ")", "\n", "\n", "# Sometimes we are loading less files than we specified by batchsize + numBatches", "\n", "# => adapt numBatches to real number of batches for avoiding empty batches", "\n", "self", ".", "batchSize", "=", "batchSize", "\n", "print", "(", "\"batchSize: %d\"", "%", "(", "self", ".", "batchSize", ")", ")", "\n", "self", ".", "numSamples", "=", "min", "(", "(", "numBatches", "*", "batchSize", ",", "len", "(", "self", ".", "x", ")", ")", ")", "\n", "print", "(", "\"numSamples: %d\"", "%", "(", "self", ".", "numSamples", ")", ")", "\n", "self", ".", "numBatches", "=", "self", ".", "numSamples", "//", "self", ".", "batchSize", "\n", "print", "(", "\"numBatches: %d\"", "%", "(", "self", ".", "numBatches", ")", ")", "\n", "self", ".", "randomState", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "1234", ")", "\n", "\n", "# Create dictionary with information about the dataset", "\n", "self", ".", "cSystem", "=", "{", "\n", "\"x_lb\"", ":", "self", ".", "x", ".", "min", "(", ")", ",", "\n", "\"x_ub\"", ":", "self", ".", "x", ".", "max", "(", ")", ",", "\n", "\"y_lb\"", ":", "self", ".", "y", ".", "min", "(", ")", ",", "\n", "\"y_ub\"", ":", "self", ".", "y", ".", "max", "(", ")", ",", "\n", "\"nx\"", ":", "nx", ",", "\n", "\"ny\"", ":", "ny", ",", "\n", "\"nt\"", ":", "nt", ",", "\n", "\"t_ub\"", ":", "self", ".", "t", ".", "max", "(", ")", "}", "\n", "\n", "# Convert indices to physical quantities [mm]", "\n", "self", ".", "x", "=", "self", ".", "x", "*", "0.25", "\n", "self", ".", "y", "=", "self", ".", "y", "*", "0.25", "\n", "\n", "# Boundaries of spatiotemporal domain", "\n", "self", ".", "lb", "=", "np", ".", "array", "(", "[", "self", ".", "x", ".", "min", "(", ")", ",", "self", ".", "y", ".", "min", "(", ")", ",", "self", ".", "t", ".", "min", "(", ")", "]", ")", "\n", "self", ".", "ub", "=", "np", ".", "array", "(", "[", "self", ".", "x", ".", "max", "(", ")", ",", "self", ".", "y", ".", "max", "(", ")", ",", "self", ".", "t", ".", "max", "(", ")", "]", ")", "\n", "\n", "if", "(", "useGPU", ")", ":", "# send to GPU if requested", "\n", "            ", "self", ".", "dtype", "=", "torch", ".", "cuda", ".", "FloatTensor", "\n", "self", ".", "dtype2", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "", "else", ":", "\n", "            ", "self", ".", "dtype", "=", "torch", ".", "FloatTensor", "\n", "self", ".", "dtype2", "=", "torch", ".", "LongTensor", "\n", "\n", "", "if", "shuffle", ":", "# shuffle the whole dataset if requested", "\n", "# Generate random permutation idx", "\n", "            ", "randIdx", "=", "self", ".", "randomState", ".", "permutation", "(", "self", ".", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Use random index", "\n", "self", ".", "x", "=", "self", ".", "x", "[", "randIdx", "]", "\n", "self", ".", "y", "=", "self", ".", "y", "[", "randIdx", "]", "\n", "self", ".", "t", "=", "self", ".", "t", "[", "randIdx", "]", "\n", "self", ".", "u", "=", "self", ".", "u", "[", "randIdx", "]", "\n", "\n", "# Slice the array for training", "\n", "", "self", ".", "x", "=", "self", ".", "dtype", "(", "self", ".", "x", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "self", ".", "y", "=", "self", ".", "dtype", "(", "self", ".", "y", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "self", ".", "t", "=", "self", ".", "dtype", "(", "self", ".", "t", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "self", ".", "u", "=", "self", ".", "dtype", "(", "self", ".", "u", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.__len__": [[245, 250], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Length of the dataset\n        \"\"\"", "\n", "return", "self", ".", "numBatches", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.InitialConditionDataset.__getitem__": [[251, 261], ["torch.stack"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Returns item at given index\n        \"\"\"", "\n", "# Generate batch for inital solution", "\n", "x", "=", "(", "self", ".", "x", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "y", "=", "(", "self", ".", "y", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "t", "=", "(", "self", ".", "t", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "u", "=", "(", "self", ".", "u", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "return", "torch", ".", "stack", "(", "[", "x", ",", "y", ",", "t", "]", ",", "1", ")", ",", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.PDEDataset.__init__": [[264, 331], ["h5py.File", "numpy.array", "h5py.File.close", "range", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "print", "min", "print", "print", "numpy.random.RandomState", "Datasets.PDEDataset.dtype", "Datasets.PDEDataset.dtype", "Datasets.PDEDataset.dtype", "numpy.array.reshape", "range", "Datasets.PDEDataset.randomState.permutation", "range", "numpy.array", "numpy.array", "numpy.array", "len", "str", "Datasets.PDEDataset.x.append", "Datasets.PDEDataset.y.append", "Datasets.PDEDataset.t.append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pData", ",", "seg_mask", ",", "batchSize", ",", "numBatches", ",", "t_ub", ",", "nt", ",", "timeStep", ",", "nx", "=", "640", ",", "\n", "ny", "=", "480", ",", "pixStep", "=", "4", ",", "shuffle", "=", "True", ",", "useGPU", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the residual points dataset\n        __getitem()__ returns a batch with x,y,t points to compute residuals at\n        \"\"\"", "\n", "self", ".", "x", "=", "[", "]", "\n", "self", ".", "y", "=", "[", "]", "\n", "self", ".", "t", "=", "[", "]", "\n", "\n", "hf", "=", "h5py", ".", "File", "(", "pData", "+", "str", "(", "0", ")", "+", "'.h5'", ",", "'r'", ")", "\n", "Exact_u", "=", "np", ".", "array", "(", "hf", "[", "'seq'", "]", "[", ":", "]", ")", "\n", "hf", ".", "close", "(", ")", "\n", "\n", "Exact_u", "=", "Exact_u", ".", "reshape", "(", "nx", ",", "ny", ")", "*", "seg_mask", "# apply segmentation", "\n", "\n", "for", "tPoint", "in", "range", "(", "\n", "0", ",", "nt", ",", "timeStep", ")", ":", "# load each timeStep-th frame from the dataset", "\n", "# Upload an image from dataset at time point tPoint", "\n", "            ", "for", "xi", "in", "range", "(", "\n", "0", ",", "nx", ",", "pixStep", ")", ":", "# sample only each pixStep-th spatial point from an image", "\n", "                ", "for", "yi", "in", "range", "(", "0", ",", "ny", ",", "pixStep", ")", ":", "\n", "                    ", "if", "Exact_u", "[", "xi", ",", "yi", "]", "!=", "0", ":", "# neglect non-cortex data", "\n", "                        ", "self", ".", "x", ".", "append", "(", "xi", ")", "\n", "self", ".", "y", ".", "append", "(", "yi", ")", "\n", "self", ".", "t", ".", "append", "(", "tPoint", ")", "\n", "\n", "# Convert python lists to numpy arrays", "\n", "", "", "", "", "self", ".", "x", "=", "np", ".", "array", "(", "self", ".", "x", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "y", "=", "np", ".", "array", "(", "self", ".", "y", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "t", "=", "np", ".", "array", "(", "self", ".", "t", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# Sometimes we are loading less files than we specified by batchsize + numBatches", "\n", "# => adapt numBatches to real number of batches for avoiding empty batches", "\n", "self", ".", "batchSize", "=", "batchSize", "\n", "print", "(", "\"batchSize: %d\"", "%", "(", "self", ".", "batchSize", ")", ")", "\n", "self", ".", "numSamples", "=", "min", "(", "(", "numBatches", "*", "batchSize", ",", "len", "(", "self", ".", "x", ")", ")", ")", "\n", "print", "(", "\"numSamples: %d\"", "%", "(", "self", ".", "numSamples", ")", ")", "\n", "self", ".", "numBatches", "=", "self", ".", "numSamples", "//", "self", ".", "batchSize", "\n", "print", "(", "\"numBatches: %d\"", "%", "(", "self", ".", "numBatches", ")", ")", "\n", "self", ".", "randomState", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "1234", ")", "\n", "\n", "# Convert indices to physical quantities [mm] & [s]", "\n", "self", ".", "x", "=", "self", ".", "x", "*", "0.25", "\n", "self", ".", "y", "=", "self", ".", "y", "*", "0.25", "\n", "self", ".", "t", "=", "t_ub", "*", "self", ".", "t", "/", "nt", "\n", "\n", "if", "(", "useGPU", ")", ":", "# send to GPU if requested", "\n", "            ", "self", ".", "dtype", "=", "torch", ".", "cuda", ".", "FloatTensor", "\n", "self", ".", "dtype2", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "", "else", ":", "\n", "            ", "self", ".", "dtype", "=", "torch", ".", "FloatTensor", "\n", "self", ".", "dtype2", "=", "torch", ".", "LongTensor", "\n", "\n", "", "if", "shuffle", ":", "# shuffle the whole dataset if requested", "\n", "# Generate random permutation idx", "\n", "            ", "randIdx", "=", "self", ".", "randomState", ".", "permutation", "(", "self", ".", "x", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Use random index", "\n", "self", ".", "x", "=", "self", ".", "x", "[", "randIdx", "]", "\n", "self", ".", "y", "=", "self", ".", "y", "[", "randIdx", "]", "\n", "self", ".", "t", "=", "self", ".", "t", "[", "randIdx", "]", "\n", "\n", "# Slice the array for training", "\n", "", "self", ".", "x", "=", "self", ".", "dtype", "(", "self", ".", "x", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "self", ".", "y", "=", "self", ".", "dtype", "(", "self", ".", "y", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "self", ".", "t", "=", "self", ".", "dtype", "(", "self", ".", "t", "[", ":", "self", ".", "numSamples", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.PDEDataset.__len__": [[332, 337], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Length of the dataset\n        \"\"\"", "\n", "return", "self", ".", "numBatches", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.PDEDataset.__getitem__": [[338, 347], ["torch.stack"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Returns item at given index\n        \"\"\"", "\n", "# Generate batch with residual points", "\n", "x", "=", "(", "self", ".", "x", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "y", "=", "(", "self", ".", "y", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "t", "=", "(", "self", ".", "t", "[", "index", "*", "self", ".", "batchSize", ":", "(", "index", "+", "1", ")", "*", "self", ".", "batchSize", "]", ")", "\n", "return", "torch", ".", "stack", "(", "[", "x", ",", "y", ",", "t", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.2D_Bioheat.Datasets.derivatives": [[349, 380], ["torch.ones", "J_U[].reshape", "J_U[].reshape", "J_U[].reshape", "u_xx[].reshape", "u_yy[].reshape", "x.reshape.reshape", "y.reshape.reshape", "t.reshape.reshape", "torch.stack().squeeze", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.stack"], "function", ["None"], ["", "", "def", "derivatives", "(", "x", ",", "u", ")", ":", "\n", "    ", "\"\"\"\n    Calculate the nn output at postion (x,y) at time t\n    :param x: position\n    :param t: time\n    :return: Approximated solutions and their gradients\n    \"\"\"", "\n", "# Save input in variabeles is necessary for gradient calculation", "\n", "x", ".", "requires_grad", "=", "True", "\n", "\n", "# Calculate derivatives with torch automatic differentiation", "\n", "# Move to the same device as prediction", "\n", "grads", "=", "torch", ".", "ones", "(", "u", ".", "shape", ",", "device", "=", "u", ".", "device", ")", "\n", "J_U", "=", "torch", ".", "autograd", ".", "grad", "(", "u", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "u_x", "=", "J_U", "[", ":", ",", "0", "]", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "u_y", "=", "J_U", "[", ":", ",", "1", "]", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "u_t", "=", "J_U", "[", ":", ",", "2", "]", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "\n", "u_xx", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "u_x", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "u_yy", "=", "torch", ".", "autograd", ".", "grad", "(", "\n", "u_y", ",", "x", ",", "create_graph", "=", "True", ",", "grad_outputs", "=", "grads", ")", "[", "0", "]", "\n", "u_xx", "=", "u_xx", "[", ":", ",", "0", "]", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "u_yy", "=", "u_yy", "[", ":", ",", "1", "]", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "\n", "x", ",", "y", ",", "t", "=", "x", ".", "T", "\n", "x", "=", "x", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "y", "=", "y", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "t", "=", "t", ".", "reshape", "(", "u", ".", "shape", ")", "\n", "\n", "return", "torch", ".", "stack", "(", "[", "x", ",", "y", ",", "t", ",", "u", ",", "u_xx", ",", "u_yy", ",", "u_t", "]", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.InitialConditionDataset.__init__": [[25, 52], ["torch.utils.data.Dataset.__init__", "numpy.linspace", "numpy.linspace", "numpy.linspace", "numpy.linspace", "numpy.meshgrid", "numpy.meshgrid", "U.reshape.reshape.reshape", "X.reshape.reshape.reshape", "T.reshape.reshape.reshape", "numpy.random.choice", "numpy.random.choice", "numpy.exp", "numpy.exp", "numpy.sin", "numpy.sin", "type"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the inital condition dataset\n\n        Args:\n          n0 (int)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "L", "=", "1", "\n", "c", "=", "1", "\n", "alpha", "=", "(", "c", "*", "np", ".", "pi", "/", "L", ")", "**", "2", "\n", "max_t", "=", "10", "\n", "max_x", "=", "L", "\n", "\n", "t", "=", "np", ".", "linspace", "(", "0", ",", "max_t", ",", "200", ")", "\n", "x", "=", "np", ".", "linspace", "(", "0", ",", "max_x", ",", "200", ")", "\n", "X", ",", "T", "=", "np", ".", "meshgrid", "(", "x", ",", "t", ",", "indexing", "=", "'ij'", ")", "\n", "\n", "U", "=", "(", "np", ".", "exp", "(", "-", "(", "alpha", ")", "*", "T", ")", ")", "*", "np", ".", "sin", "(", "np", ".", "pi", "*", "X", "/", "L", ")", "\n", "U", "=", "U", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "X", "=", "X", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "T", "=", "T", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "idx_x", "=", "np", ".", "random", ".", "choice", "(", "X", ".", "shape", "[", "0", "]", ",", "n0", ",", "replace", "=", "False", ")", "\n", "self", ".", "x", "=", "X", "[", "idx_x", ",", ":", "]", "\n", "self", ".", "u", "=", "U", "[", "idx_x", ",", ":", "]", "\n", "self", ".", "t", "=", "T", "[", "idx_x", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.InitialConditionDataset.__len__": [[53, 58], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.InitialConditionDataset.__getitem__": [[59, 63], ["numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "x", "=", "np", ".", "concatenate", "(", "[", "self", ".", "x", ",", "self", ".", "t", "]", ",", "axis", "=", "1", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "[", "self", ".", "u", "]", ",", "axis", "=", "1", ")", "\n", "return", "Tensor", "(", "x", ")", ".", "float", "(", ")", ",", "Tensor", "(", "y", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.PDEDataset.__init__": [[69, 79], ["pyDOE.lhs"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "nf", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the PDE dataset\n\n        Args:\n          nf (int)\n          lb (numpy.ndarray)\n          ub (numpy.ndarray)\n        \"\"\"", "\n", "self", ".", "xf", "=", "lb", "+", "(", "ub", "-", "lb", ")", "*", "lhs", "(", "2", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.PDEDataset.__getitem__": [[80, 87], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data at given index\n        Args:\n            idx (int)\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "xf", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation_inversion.PDEDataset.__len__": [[88, 93], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetlb.__init__": [[28, 45], ["torch.utils.data.Dataset.__init__", "numpy.random.choice", "numpy.random.choice", "numpy.concatenate", "numpy.concatenate", "numpy.linspace().flatten", "numpy.linspace().flatten", "type", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nb", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the lower boundary condition dataset\n\n        Args:\n          nb (int)\n          lb (numpy.ndarray)\n          ub (numpy.ndarray)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "\n", "# maximum of the time domain", "\n", "max_t", "=", "2", "\n", "t", "=", "np", ".", "linspace", "(", "0", ",", "max_t", ",", "200", ")", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "idx_t", "=", "np", ".", "random", ".", "choice", "(", "t", ".", "shape", "[", "0", "]", ",", "nb", ",", "replace", "=", "False", ")", "\n", "tb", "=", "t", "[", "idx_t", ",", ":", "]", "\n", "self", ".", "x_lb", "=", "np", ".", "concatenate", "(", "(", "0", "*", "tb", "+", "lb", "[", "0", "]", ",", "tb", ")", ",", "1", ")", "# (lb[0], tb)", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetlb.__getitem__": [[46, 53], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data at given index\n        Args:\n            idx (int)\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "x_lb", ")", ".", "float", "(", ")", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetlb.__len__": [[53, 58], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetub.__init__": [[64, 81], ["torch.utils.data.Dataset.__init__", "numpy.random.choice", "numpy.random.choice", "numpy.concatenate", "numpy.concatenate", "numpy.linspace().flatten", "numpy.linspace().flatten", "type", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nb", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the upper boundary condition dataset\n\n        Args:\n          nb (int)\n          lb (numpy.ndarray)\n          ub (numpy.ndarray)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "\n", "# maximum of the time domain", "\n", "max_t", "=", "2", "\n", "t", "=", "np", ".", "linspace", "(", "0", ",", "max_t", ",", "200", ")", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "idx_t", "=", "np", ".", "random", ".", "choice", "(", "t", ".", "shape", "[", "0", "]", ",", "nb", ",", "replace", "=", "False", ")", "\n", "tb", "=", "t", "[", "idx_t", ",", ":", "]", "\n", "self", ".", "x_ub", "=", "np", ".", "concatenate", "(", "(", "0", "*", "tb", "+", "ub", "[", "0", "]", ",", "tb", ")", ",", "1", ")", "# (ub[0], tb)", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetub.__getitem__": [[82, 89], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data at given index\n        Args:\n            idx (int)\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "x_ub", ")", ".", "float", "(", ")", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.BoundaryConditionDatasetub.__len__": [[89, 94], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.InitialConditionDataset.__init__": [[100, 125], ["torch.utils.data.Dataset.__init__", "numpy.random.choice", "numpy.random.choice", "numpy.zeros().flatten", "numpy.zeros().flatten", "numpy.linspace().flatten", "numpy.linspace().flatten", "numpy.exp", "numpy.exp", "numpy.sin", "numpy.sin", "U.flatten", "type", "numpy.zeros", "numpy.zeros", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the inital condition dataset\n\n        Args:\n          n0 (int)\n        \"\"\"", "\n", "super", "(", "type", "(", "self", ")", ")", ".", "__init__", "(", ")", "\n", "\n", "L", "=", "1", "\n", "c", "=", "1", "\n", "alpha", "=", "(", "c", "*", "np", ".", "pi", "/", "L", ")", "**", "2", "\n", "max_t", "=", "10", "\n", "max_x", "=", "L", "\n", "\n", "t", "=", "np", ".", "zeros", "(", "200", ")", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "x", "=", "np", ".", "linspace", "(", "0", ",", "max_x", ",", "200", ")", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "\n", "U", "=", "(", "np", ".", "exp", "(", "-", "(", "alpha", ")", "*", "t", ")", ")", "*", "np", ".", "sin", "(", "np", ".", "pi", "*", "x", "/", "L", ")", "\n", "u", "=", "U", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", "\n", "\n", "idx_x", "=", "np", ".", "random", ".", "choice", "(", "x", ".", "shape", "[", "0", "]", ",", "n0", ",", "replace", "=", "False", ")", "\n", "self", ".", "x", "=", "x", "[", "idx_x", ",", ":", "]", "\n", "self", ".", "u", "=", "u", "[", "idx_x", ",", ":", "]", "\n", "self", ".", "t", "=", "t", "[", "idx_x", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.InitialConditionDataset.__len__": [[126, 131], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.InitialConditionDataset.__getitem__": [[132, 136], ["numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "x", "=", "np", ".", "concatenate", "(", "[", "self", ".", "x", ",", "self", ".", "t", "]", ",", "axis", "=", "1", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "[", "self", ".", "u", "]", ",", "axis", "=", "1", ")", "\n", "return", "Tensor", "(", "x", ")", ".", "float", "(", ")", ",", "Tensor", "(", "y", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__init__": [[142, 152], ["pyDOE.lhs"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "nf", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of the PDE dataset\n\n        Args:\n          nf (int)\n          lb (numpy.ndarray)\n          ub (numpy.ndarray)\n        \"\"\"", "\n", "self", ".", "xf", "=", "lb", "+", "(", "ub", "-", "lb", ")", "*", "lhs", "(", "2", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__getitem__": [[153, 160], ["torch.Tensor().float", "torch.Tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        Returns data at given index\n        Args:\n            idx (int)\n        \"\"\"", "\n", "return", "Tensor", "(", "self", ".", "xf", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ComputationalRadiationPhysics_NeuralSolvers.1D_Heat_Equation.1D_Heat_Equation.PDEDataset.__len__": [[161, 166], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        There exists no batch processing. So the size is 1\n        \"\"\"", "\n", "return", "1", "\n", "\n"]]}