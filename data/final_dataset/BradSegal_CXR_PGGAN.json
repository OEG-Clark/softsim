{"home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.MinibatchSTD.__init__": [[85, 90], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Calculates the standard deviation across a batch of feature maps\n        \"\"\"", "\n", "super", "(", "MinibatchSTD", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.MinibatchSTD.forward": [[91, 100], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.cat.mean().view", "torch.cat.mean().view", "torch.cat.repeat", "torch.cat.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "feature_maps.mean", "torch.cat.pow().mean", "torch.cat.pow().mean", "torch.cat.mean", "torch.cat.mean", "torch.cat.pow", "torch.cat.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feature_maps", ",", "dim", "=", "0", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "# Epsilon \u2192 Small value for numerical stability when dividing", "\n", "        ", "batch", ",", "channels", ",", "height", ",", "width", "=", "feature_maps", ".", "shape", "\n", "std", "=", "feature_maps", "-", "feature_maps", ".", "mean", "(", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", "# [B x C x H x W] Subtract mean over batch", "\n", "std", "=", "torch", ".", "sqrt", "(", "std", ".", "pow", "(", "2", ")", ".", "mean", "(", "dim", "=", "dim", ",", "keepdim", "=", "False", ")", "+", "epsilon", ")", "# [1 x C x H x W]  Calc std over batch", "\n", "std", "=", "std", ".", "mean", "(", ")", ".", "view", "(", "1", ",", "1", ",", "1", ",", "1", ")", "# Take average over feature_maps and pixels", "\n", "std", "=", "std", ".", "repeat", "(", "batch", ",", "1", ",", "height", ",", "width", ")", "# [B x 1 x H x W]  Replicate over group and pixels", "\n", "std", "=", "torch", ".", "cat", "(", "[", "feature_maps", ",", "std", "]", ",", "1", ")", "# [B x (C + 1) x H x W]  Append as new feature_map", "\n", "return", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.Checkpoint.__init__": [[103, 106], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filepath", ",", "save_rate", "=", "100", ")", ":", "\n", "        ", "self", ".", "filepath", "=", "filepath", "\n", "self", ".", "save_rate", "=", "save_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.Checkpoint.on_batch_end": [[107, 117], ["print", "torch.save", "torch.save", "torch.save", "torch.save", "pl_module.state_dict", "pl_module.get_settings"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.get_settings"], ["", "def", "on_batch_end", "(", "self", ",", "trainer", ",", "pl_module", ")", ":", "\n", "        ", "pl_module", ".", "batch_count", "+=", "1", "\n", "if", "pl_module", ".", "batch_count", "%", "self", ".", "save_rate", "==", "0", ":", "\n", "            ", "name", "=", "f\"{pl_module.name}-Scale({pl_module.scale})-Img({pl_module.img_size})-Iter({pl_module.total_iter}).pth\"", "\n", "\n", "print", "(", "\"Saving Model: \"", ",", "name", ")", "\n", "torch", ".", "save", "(", "{", "\n", "'state_dict'", ":", "pl_module", ".", "state_dict", "(", ")", ",", "\n", "'settings'", ":", "pl_module", ".", "get_settings", "(", ")", "\n", "}", ",", "self", ".", "filepath", "+", "name", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.calc_padding": [[8, 21], ["padding.is_integer", "int"], "function", ["None"], ["def", "calc_padding", "(", "dims", ",", "kernel", ",", "stride", ")", ":", "\n", "    ", "\"\"\"\n    For constant output: W = (W - F + 2P)/S + 1\n    W \u2192 Dimensions, F \u2192 Kernel, P \u2192 Padding, S \u2192 Stride\n    (S(W - 1) - W + F)/2\n    :param dims:\n    :param kernel:\n    :param stride:\n    :return:\n    \"\"\"", "\n", "padding", "=", "(", "stride", "*", "(", "dims", "-", "1", ")", "-", "dims", "+", "kernel", ")", "/", "2", "\n", "assert", "padding", ".", "is_integer", "(", ")", ",", "\"A non-integer result indicates an invalid pairing of dimensions and stride values\"", "\n", "return", "int", "(", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.exp_avg_update": [[23, 38], ["torch.no_grad", "torch.no_grad", "dict", "target.named_parameters", "source.named_parameters", "p_target.copy_"], "function", ["None"], ["", "def", "exp_avg_update", "(", "target", ",", "source", ",", "beta", ")", ":", "\n", "    ", "\"\"\"\n\n    :param target:\n    :param source:\n    :param beta:\n    :return:\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "source_parameters", "=", "dict", "(", "source", ".", "named_parameters", "(", ")", ")", "\n", "\n", "for", "p_name", ",", "p_target", "in", "target", ".", "named_parameters", "(", ")", ":", "\n", "            ", "p_source", "=", "source_parameters", "[", "p_name", "]", "\n", "assert", "p_source", "is", "not", "p_target", "\n", "p_target", ".", "copy_", "(", "beta", "*", "p_target", "+", "(", "1", "-", "beta", ")", "*", "p_source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.compute_gradient_penalty": [[40, 71], ["torch.rand", "torch.rand", "alpha.type_as.expand_as", "alpha.type_as.type_as", "interpolates.type_as.requires_grad_", "interpolates.type_as.type_as", "discriminator", "torch.ones_like", "torch.ones_like", "grad_output.type_as.type_as", "gradients.view.view", "real_samples.size", "torch.autograd.grad", "real_samples.detach", "fake_samples.detach", "gradients.view.norm"], "function", ["None"], ["", "", "", "def", "compute_gradient_penalty", "(", "discriminator", ",", "real_samples", ",", "fake_samples", ")", ":", "\n", "    ", "\"\"\"\n    Calculates the gradient penalty loss for WGAN-GP (https://arxiv.org/abs/1704.00028)\n    :param discriminator:\n    :param real_samples:\n    :param fake_samples:\n    :return:\n    \"\"\"", "\n", "# Random weight term for interpolation between real and fake samples", "\n", "alpha", "=", "torch", ".", "rand", "(", "real_samples", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "alpha", "=", "alpha", ".", "expand_as", "(", "real_samples", ")", "# Broadcast to correct shape", "\n", "alpha", "=", "alpha", ".", "type_as", "(", "real_samples", ")", "\n", "\n", "# Get random interpolation between real and fake samples", "\n", "interpolates", "=", "(", "alpha", "*", "real_samples", ".", "detach", "(", ")", "+", "(", "1", "-", "alpha", ")", "*", "fake_samples", ".", "detach", "(", ")", ")", "\n", "interpolates", "=", "interpolates", ".", "requires_grad_", "(", "True", ")", "\n", "interpolates", "=", "interpolates", ".", "type_as", "(", "real_samples", ")", "\n", "\n", "d_interpolates", "=", "discriminator", "(", "interpolates", ")", "\n", "grad_output", "=", "torch", ".", "ones_like", "(", "d_interpolates", ")", "\n", "grad_output", "=", "grad_output", ".", "type_as", "(", "real_samples", ")", "\n", "\n", "# Get gradient w.r.t. interpolates", "\n", "gradients", "=", "autograd", ".", "grad", "(", "outputs", "=", "d_interpolates", ",", "inputs", "=", "interpolates", ",", "\n", "grad_outputs", "=", "grad_output", ",", "create_graph", "=", "True", ",", "\n", "retain_graph", "=", "True", ",", "only_inputs", "=", "True", ")", "[", "0", "]", "\n", "\n", "gradients", "=", "gradients", ".", "view", "(", "real_samples", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "gradient_penalty", "=", "(", "(", "gradients", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ")", "-", "1", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "\n", "return", "gradient_penalty", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.calc_epoch_num": [[73, 82], ["numpy.ceil", "zip"], "function", ["None"], ["", "def", "calc_epoch_num", "(", "scale_list", ",", "batch_sizes", ",", "total_images", ")", ":", "\n", "    ", "\"\"\"\n\n    :param scale_list:\n    :param batch_sizes:\n    :param total_images:\n    :return:\n    \"\"\"", "\n", "return", "[", "np", ".", "ceil", "(", "scale", "/", "total_images", ")", "for", "scale", ",", "batch_size", "in", "zip", "(", "scale_list", ",", "batch_sizes", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGenerator.__init__": [[17, 60], ["torch.Module.__init__", "network.ProGenerator.register_buffer", "network.ProGenerator.register_buffer", "network.ProGenerator.register_buffer", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "network.ProGenerator.toRGB.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "GAN.custom_layers.EqualizedLinear", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "GAN.custom_layers.PixelNormalizationLayer", "GAN.custom_layers.Conv_Block", "GAN.custom_layers.Conv_Block", "GAN.utility.calc_padding"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.calc_padding"], ["    ", "def", "__init__", "(", "self", ",", "z_dim", "=", "512", ",", "channel_depth", "=", "512", ",", "init_bias", "=", "True", ",", "norm_layers", "=", "True", ",", "\n", "out_channels", "=", "3", ",", "equalize_layers", "=", "True", ",", "leakiness", "=", "0.2", ",", "mode", "=", "\"nearest\"", ")", ":", "\n", "        ", "super", "(", "ProGenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Store Model Parameters", "\n", "self", ".", "z_dim", "=", "z_dim", "# Dimensions of latent space vector", "\n", "\n", "self", ".", "channel_depth", "=", "[", "channel_depth", "]", "# Initial Number of channels to produce from latent space", "\n", "# Model begins by producing 4x4 images, incremented when alpha reaches 1", "\n", "self", ".", "register_buffer", "(", "'current_size'", ",", "torch", ".", "tensor", "(", "4", ")", ")", "\n", "# Current number of completed blocks, incremented when alpha reaches 1 for a given layer", "\n", "self", ".", "register_buffer", "(", "'current_depth'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'alpha'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "# Mixing co-efficient for use when upscaling the network", "\n", "\n", "self", ".", "init_bias", "=", "init_bias", "# Initialize bias to 0", "\n", "self", ".", "norm_layers", "=", "norm_layers", "# Whether to apply minibatch normalization layer", "\n", "self", ".", "out_channels", "=", "out_channels", "# The final number of colour channels used in the generated image", "\n", "self", ".", "equalize", "=", "equalize_layers", "# Whether to use the He Constant to equalize layer outputs at runtime", "\n", "self", ".", "leakiness", "=", "leakiness", "# The co-efficient of the negative slope of the Leaky ReLU activation", "\n", "self", ".", "mode", "=", "mode", "# Interpolation mode for upscaling, Paper utilizes nearest neighbour mode", "\n", "\n", "# Define Layer Architectures", "\n", "self", ".", "latent_linear", "=", "nn", ".", "Sequential", "(", "EqualizedLinear", "(", "in_features", "=", "z_dim", ",", "out_features", "=", "16", "*", "channel_depth", ",", "\n", "equalize", "=", "equalize_layers", ",", "bias_init", "=", "init_bias", ")", ",", "\n", "# Initial latent space processing", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "leakiness", ",", "inplace", "=", "True", ")", ")", "\n", "\n", "self", ".", "init_conv", "=", "nn", ".", "Sequential", "(", "# Initial convolution on latent space after initial linear processing", "\n", "*", "Conv_Block", "(", "prev_channel", "=", "channel_depth", ",", "channels", "=", "channel_depth", ",", "\n", "# Convolutions maintain number of channels", "\n", "kernel", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "calc_padding", "(", "dims", "=", "4", ",", "kernel", "=", "3", ",", "stride", "=", "1", ")", ",", "bias", "=", "True", ",", "\n", "equalize", "=", "equalize_layers", ",", "leakiness", "=", "leakiness", ",", "normalize", "=", "norm_layers", ")", ")", "\n", "\n", "self", ".", "ScaleBlocks", "=", "nn", ".", "ModuleList", "(", ")", "# Stores list of scaling blocks to double spatial resolutions", "\n", "# Stores the feature map to RGB convolutions A new one is needed for each network expansion", "\n", "self", ".", "toRGB", "=", "nn", ".", "ModuleList", "(", ")", "\n", "# The RGB layers are stored to enable extracting smaller intermediary images from scaling blocks", "\n", "self", ".", "toRGB", ".", "append", "(", "*", "Conv_Block", "(", "prev_channel", "=", "channel_depth", ",", "channels", "=", "out_channels", ",", "\n", "kernel", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "equalize", "=", "equalize_layers", ",", "\n", "activation", "=", "False", ",", "\n", "normalize", "=", "False", ")", ")", "# The final convolution acts as an activation function", "\n", "\n", "if", "self", ".", "norm_layers", ":", "\n", "            ", "self", ".", "norm", "=", "PixelNormalizationLayer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGenerator.forward": [[61, 93], ["numpy.prod", "scale_block.view", "network.ProGenerator.latent_linear", "scale_block.view", "network.ProGenerator.init_conv", "enumerate", "network.ProGenerator.norm", "scale_block.size", "torch.interpolate", "torch.interpolate", "torch.interpolate", "scale_block", "scale_block.size", "torch.interpolate", "torch.interpolate", "torch.interpolate"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "norm_layers", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "\n", "", "features", "=", "np", ".", "prod", "(", "x", ".", "size", "(", ")", "[", "1", ":", "]", ")", "# Multiple of all dimensions except batch dimension = Total Feature Number", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "features", ")", "# Batch dimension x Features", "\n", "\n", "batch_size", "=", "x", ".", "size", "(", ")", "[", "0", "]", "\n", "x", "=", "self", ".", "latent_linear", "(", "x", ")", "# Initial Latent Processing & Formatting", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ",", "4", ",", "4", ")", "# Reshape to Batch x Depth x 4 x 4", "\n", "\n", "x", "=", "self", ".", "init_conv", "(", "x", ")", "# Perform initial 3x3 convolution without upscaling", "\n", "\n", "if", "self", ".", "alpha", ">", "0", "and", "self", ".", "current_depth", "==", "1", ":", "# Apply mixing for when the network begins to expand", "\n", "# Expansion determined when alpha is incremented with the completed depth layers still at 0", "\n", "            ", "expansion", "=", "self", ".", "toRGB", "[", "-", "2", "]", "(", "x", ")", "\n", "expansion", "=", "F", ".", "interpolate", "(", "input", "=", "expansion", ",", "scale_factor", "=", "2", ",", "mode", "=", "self", ".", "mode", ")", "\n", "\n", "", "for", "scale_num", ",", "scale_block", "in", "enumerate", "(", "self", ".", "ScaleBlocks", ",", "1", ")", ":", "\n", "# Start at 1 due to the first image dimension not requiring scaling", "\n", "            ", "x", "=", "scale_block", "(", "x", ")", "# Process the input through the expansion block of upscale, conv, conv", "\n", "\n", "if", "self", ".", "alpha", ">", "0", "and", "(", "scale_num", "==", "self", ".", "current_depth", "-", "1", ")", ":", "\n", "                ", "expansion", "=", "self", ".", "toRGB", "[", "-", "2", "]", "(", "x", ")", "\n", "expansion", "=", "F", ".", "interpolate", "(", "input", "=", "expansion", ",", "scale_factor", "=", "2", ",", "mode", "=", "self", ".", "mode", ")", "\n", "\n", "", "", "x", "=", "self", ".", "toRGB", "[", "-", "1", "]", "(", "x", ")", "# Final layer to RGB", "\n", "\n", "if", "self", ".", "alpha", ">", "0", ":", "\n", "            ", "x", "=", "self", ".", "alpha", "*", "expansion", "+", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "x", "# Mix the inputs at the final scale", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGenerator.incrementdepth": [[94, 115], ["network.ProGenerator.channel_depth.append", "network.ProGenerator.current_size.cpu().numpy", "network.ProGenerator.ScaleBlocks.append", "network.ProGenerator.toRGB.append", "next", "GAN.custom_layers.ScaleBlock().to", "network.ProGenerator.parameters", "network.ProGenerator.current_size.cpu", "GAN.custom_layers.Conv_Block().to", "GAN.custom_layers.ScaleBlock", "GAN.custom_layers.Conv_Block"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block"], ["", "def", "incrementdepth", "(", "self", ",", "new_depth", ")", ":", "\n", "        ", "\"\"\"\n        Adds scaling block to the model, doubles the spatial resolution of the final image\n\n        \"\"\"", "\n", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "self", ".", "current_depth", "+=", "1", "\n", "self", ".", "current_size", "*=", "2", "\n", "\n", "prev_depth", "=", "self", ".", "channel_depth", "[", "-", "1", "]", "\n", "self", ".", "channel_depth", ".", "append", "(", "new_depth", ")", "\n", "# Adds scaling block, padding is calculated from the spatial dimensions and filter properties", "\n", "size", "=", "self", ".", "current_size", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "ScaleBlocks", ".", "append", "(", "ScaleBlock", "(", "dims", "=", "size", ",", "prev_channel", "=", "prev_depth", ",", "\n", "channels", "=", "new_depth", ",", "scale", "=", "2", ",", "equalize", "=", "self", ".", "equalize", ",", "\n", "normalize", "=", "self", ".", "norm_layers", ",", "leakiness", "=", "self", ".", "leakiness", ",", "kernel", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "None", ",", "bias", "=", "True", ",", "mode", "=", "self", ".", "mode", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "self", ".", "toRGB", ".", "append", "(", "*", "Conv_Block", "(", "prev_channel", "=", "new_depth", ",", "channels", "=", "self", ".", "out_channels", ",", "\n", "kernel", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "equalize", "=", "self", ".", "equalize", ",", "\n", "activation", "=", "False", ",", "normalize", "=", "False", ")", ".", "to", "(", "device", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGenerator.set_alpha": [[116, 125], ["ValueError"], "methods", ["None"], ["", "def", "set_alpha", "(", "self", ",", "new_alpha", ")", ":", "\n", "        ", "\"\"\"\n        Sets the mixing factor used when upscaling the network. Alters the functioning of the forward function\n        to include the second last layer and interpolate between it and the final output of the added scaling block.\n        \"\"\"", "\n", "if", "new_alpha", "<", "0", "or", "new_alpha", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Alpha must be in the range [0,1]\"", ")", "\n", "\n", "", "self", ".", "alpha", "=", "new_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGenerator.load": [[126, 136], ["network.ProGenerator.load_state_dict", "print", "network.ProGenerator.incrementdepth"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth"], ["", "def", "load", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "\"\"\"\n        Automatically scales the network to the required size and loads the weights\n        :param checkpoint: Saved network state\n        :return:\n        \"\"\"", "\n", "for", "depth", "in", "checkpoint", "[", "'settings'", "]", "[", "'channel_depth'", "]", "[", "1", ":", "]", ":", "\n", "            ", "self", ".", "incrementdepth", "(", "depth", ")", "\n", "", "self", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "print", "(", "\"Generator Weights Loaded\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.__init__": [[139, 180], ["torch.Module.__init__", "network.ProDiscriminator.register_buffer", "network.ProDiscriminator.register_buffer", "network.ProDiscriminator.register_buffer", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "network.ProDiscriminator.fromRGB.append", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Sequential", "torch.Sequential", "torch.Sequential", "GAN.custom_layers.EqualizedLinear", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "GAN.utility.MinibatchSTD", "GAN.custom_layers.Conv_Block", "GAN.custom_layers.Conv_Block", "GAN.custom_layers.Conv_Block", "GAN.utility.calc_padding"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.calc_padding"], ["    ", "def", "__init__", "(", "self", ",", "channel_depth", "=", "512", ",", "init_bias", "=", "True", ",", "norm_layers", "=", "False", ",", "input_channels", "=", "3", ",", "\n", "decision_layer_dim", "=", "1", ",", "equalize_layers", "=", "True", ",", "leakiness", "=", "0.2", ",", "minibatch_std", "=", "True", ")", ":", "\n", "        ", "super", "(", "ProDiscriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Store Model Parameters", "\n", "self", ".", "input_channels", "=", "input_channels", "\n", "self", ".", "decision_layer_dim", "=", "decision_layer_dim", "# Can be augmented to allow for classification of an image", "\n", "\n", "self", ".", "channel_depth", "=", "[", "channel_depth", "]", "# Initial Number of channels to produce from image", "\n", "self", ".", "register_buffer", "(", "'current_size'", ",", "torch", ".", "tensor", "(", "4", ")", ")", "# Current size of images for descrimination", "\n", "self", ".", "register_buffer", "(", "'current_depth'", ",", "torch", ".", "tensor", "(", "\n", "0", ")", ")", "# Current number of completed blocks, incremented when the generator completes mixing", "\n", "self", ".", "register_buffer", "(", "'alpha'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "# Mixing co-efficient for use when upscaling the network", "\n", "\n", "self", ".", "init_bias", "=", "init_bias", "# Initialize bias to 0", "\n", "self", ".", "norm_layers", "=", "norm_layers", "# Whether to apply minibatch normalization layer", "\n", "self", ".", "minibatch", "=", "minibatch_std", "# Whether to calculate the std of all layers prior to the final convolution", "\n", "self", ".", "equalize", "=", "equalize_layers", "# Whether to use the He Constant to equalize layer outputs at runtime", "\n", "self", ".", "leakiness", "=", "leakiness", "# The co-efficient of the negative slope of the Leaky ReLU activation", "\n", "\n", "if", "self", ".", "minibatch", ":", "\n", "            ", "self", ".", "miniSTD", "=", "MinibatchSTD", "(", ")", "\n", "\n", "", "self", ".", "fromRGB", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "self", ".", "fromRGB", ".", "append", "(", "*", "Conv_Block", "(", "prev_channel", "=", "input_channels", ",", "channels", "=", "channel_depth", ",", "\n", "kernel", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "equalize", "=", "equalize_layers", ",", "\n", "activation", "=", "False", ",", "normalize", "=", "False", ")", ")", "# Initial RGB to Feature Map Processing", "\n", "\n", "self", ".", "ScaleBlocks", "=", "nn", ".", "ModuleList", "(", ")", "# Will be added to as the network grows", "\n", "# Blocks will be added to the front of the list as the descriminator grows at its input end", "\n", "\n", "self", ".", "DecisionBlock", "=", "nn", ".", "Sequential", "(", "\n", "*", "Conv_Block", "(", "prev_channel", "=", "channel_depth", "+", "minibatch_std", ",", "channels", "=", "channel_depth", ",", "# Add channel for std", "\n", "kernel", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "calc_padding", "(", "4", ",", "3", ",", "1", ")", ",", "bias", "=", "True", ",", "equalize", "=", "equalize_layers", ",", "\n", "activation", "=", "True", ",", "normalize", "=", "norm_layers", ")", ",", "# eg: 513x4x4 \u2192 512x4x4", "\n", "*", "Conv_Block", "(", "prev_channel", "=", "channel_depth", ",", "channels", "=", "channel_depth", ",", "\n", "kernel", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "equalize", "=", "equalize_layers", ",", "\n", "activation", "=", "True", ",", "normalize", "=", "norm_layers", ")", ")", "# eg: 512x4x4 \u2192 512x1x1", "\n", "\n", "self", ".", "DecisionLinear", "=", "EqualizedLinear", "(", "in_features", "=", "channel_depth", ",", "out_features", "=", "decision_layer_dim", ",", "\n", "equalize", "=", "self", ".", "equalize", ",", "bias_init", "=", "self", ".", "init_bias", ")", "# eg: 512x1x1 \u2192 1x1x1", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.forward": [[181, 211], ["enumerate", "network.ProDiscriminator.DecisionBlock", "numpy.prod", "network.ProDiscriminator.view", "network.ProDiscriminator.DecisionLinear", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "scale_block", "network.ProDiscriminator.miniSTD", "len", "network.ProDiscriminator.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "if", "self", ".", "alpha", ">", "0", "and", "len", "(", "\n", "self", ".", "fromRGB", ")", ">", "1", ":", "# Check if the layers are mixed and multiple resolutions are being used", "\n", "            ", "pooled", "=", "F", ".", "avg_pool2d", "(", "input", "=", "x", ",", "\n", "kernel_size", "=", "(", "2", ",", "2", ")", ")", "# Downsample the larger image to mix with the output of the", "\n", "pooled", "=", "self", ".", "fromRGB", "[", "-", "2", "]", "(", "pooled", ")", "# new processing layer", "\n", "\n", "# Convert from RGB to Feature Maps:", "\n", "", "x", "=", "self", ".", "fromRGB", "[", "-", "1", "]", "(", "x", ")", "\n", "\n", "for", "scale_num", ",", "scale_block", "in", "enumerate", "(", "self", ".", "ScaleBlocks", ",", "1", ")", ":", "\n", "# Start at 1 due to the first image dimension not requiring scaling", "\n", "            ", "x", "=", "scale_block", "(", "x", ")", "# Process the input through the contraction block of conv, conv, downsample", "\n", "\n", "# Processing blocks are added to the front of the array, so mixing always occurs at the top layer", "\n", "if", "self", ".", "alpha", ">", "0", "and", "scale_num", "==", "1", ":", "\n", "                ", "x", "=", "self", ".", "alpha", "*", "pooled", "+", "(", "1.0", "-", "self", ".", "alpha", ")", "*", "x", "# Interpolate the downsampled input and the new input", "\n", "\n", "", "", "if", "self", ".", "minibatch", ":", "\n", "            ", "x", "=", "self", ".", "miniSTD", "(", "x", ")", "\n", "\n", "", "x", "=", "self", ".", "DecisionBlock", "(", "x", ")", "# Final 3x3, 4x4 conv", "\n", "\n", "features", "=", "np", ".", "prod", "(", "x", ".", "size", "(", ")", "[", "1", ":", "]", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "features", ")", "\n", "\n", "x", "=", "self", ".", "DecisionLinear", "(", "x", ")", "# Returns logits", "\n", "\n", "return", "x", "# Final score for whether the image is fake", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth": [[212, 233], ["network.ProDiscriminator.channel_depth.append", "network.ProDiscriminator.current_size.cpu().numpy", "network.ProDiscriminator.ScaleBlocks.insert", "network.ProDiscriminator.fromRGB.append", "next", "GAN.custom_layers.ScaleBlock().to", "network.ProDiscriminator.parameters", "network.ProDiscriminator.current_size.cpu", "GAN.custom_layers.Conv_Block().to", "GAN.custom_layers.ScaleBlock", "GAN.custom_layers.Conv_Block"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block"], ["", "def", "incrementdepth", "(", "self", ",", "new_depth", ")", ":", "\n", "        ", "\"\"\"\n        Adds scaling block to the model, doubles the spatial resolution of the inputted image\n        Includes two channel depth parameters as the descriminator often has different channels for each convolution\n        \"\"\"", "\n", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "self", ".", "current_depth", "+=", "1", "\n", "self", ".", "current_size", "*=", "2", "\n", "\n", "prev_depth", "=", "self", ".", "channel_depth", "[", "-", "1", "]", "\n", "self", ".", "channel_depth", ".", "append", "(", "new_depth", ")", "\n", "size", "=", "self", ".", "current_size", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "self", ".", "ScaleBlocks", ".", "insert", "(", "0", ",", "ScaleBlock", "(", "dims", "=", "size", ",", "prev_channel", "=", "new_depth", ",", "# Add block to the beginning of list", "\n", "channels", "=", "prev_depth", ",", "scale", "=", "0.5", ",", "equalize", "=", "self", ".", "equalize", ",", "\n", "normalize", "=", "self", ".", "norm_layers", ",", "leakiness", "=", "self", ".", "leakiness", ",", "kernel", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "None", ",", "bias", "=", "True", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "self", ".", "fromRGB", ".", "append", "(", "*", "Conv_Block", "(", "prev_channel", "=", "self", ".", "input_channels", ",", "channels", "=", "new_depth", ",", "\n", "kernel", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "equalize", "=", "self", ".", "equalize", ",", "\n", "activation", "=", "False", ",", "normalize", "=", "False", ")", ".", "to", "(", "device", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.set_alpha": [[234, 242], ["ValueError"], "methods", ["None"], ["", "def", "set_alpha", "(", "self", ",", "new_alpha", ")", ":", "\n", "        ", "\"\"\"\n        Sets the mixing factor used when incrementing the network. Alters the functioning of the forward function\n        to include the second layer and interpolate between it and the initial output of the added scaling block.\n        \"\"\"", "\n", "if", "new_alpha", "<", "0", "or", "new_alpha", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Alpha must be in the range [0,1]\"", ")", "\n", "", "self", ".", "alpha", "=", "new_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save": [[243, 256], ["torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "network.ProDiscriminator.state_dict"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.save"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "        ", "settings", "=", "{", "\n", "'input_channels'", ":", "self", ".", "input_channels", ",", "\n", "'decision_layer_dim'", ":", "self", ".", "decision_layer_dim", ",", "\n", "'channel_depth'", ":", "self", ".", "channel_depth", ",", "\n", "'init_bias'", ":", "self", ".", "init_bias", ",", "\n", "'norm_layers'", ":", "self", ".", "norm_layers", ",", "\n", "'minibatch'", ":", "self", ".", "minibatch", ",", "\n", "'equalize'", ":", "self", ".", "equalize", ",", "\n", "'leakiness'", ":", "self", ".", "leakiness", "\n", "}", "\n", "torch", ".", "save", "(", "{", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", ",", "\n", "'settings'", ":", "settings", "}", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load": [[257, 267], ["network.ProDiscriminator.load_state_dict", "print", "network.ProDiscriminator.incrementdepth"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth"], ["", "def", "load", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "\"\"\"\n        Automatically scales the network to the required size and loads the weights\n        :param checkpoint: Saved network state\n        :return:\n        \"\"\"", "\n", "for", "depth", "in", "checkpoint", "[", "'settings'", "]", "[", "'channel_depth'", "]", "[", "1", ":", "]", ":", "\n", "            ", "self", ".", "incrementdepth", "(", "depth", ")", "\n", "", "self", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "print", "(", "\"Discriminator Weights Loaded\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.__init__": [[270, 333], ["pytorch_lightning.LightningModule.__init__", "network.ProGAN.register_buffer", "network.ProGenerator", "network.ProDiscriminator", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "int", "numpy.linspace", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "network.ProGAN.register_buffer", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "copy.deepcopy", "GAN.utility.exp_avg_update"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.exp_avg_update"], ["    ", "def", "__init__", "(", "self", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "ProGAN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hparams", "=", "hparams", "\n", "\n", "self", ".", "name", "=", "hparams", ".", "name", "\n", "self", ".", "directory", "=", "hparams", ".", "directory", "\n", "self", ".", "batch_sizes", "=", "[", "int", "(", "batch", ")", "for", "batch", "in", "hparams", ".", "batch_sizes", "]", "\n", "\n", "self", ".", "worker_num", "=", "hparams", ".", "worker_num", "\n", "self", ".", "register_buffer", "(", "'img_size'", ",", "torch", ".", "tensor", "(", "4", ")", ")", "# initial spatial dimensions", "\n", "self", ".", "z_dim", "=", "hparams", ".", "z_dim", "\n", "\n", "self", ".", "generator", "=", "ProGenerator", "(", "z_dim", "=", "hparams", ".", "z_dim", ",", "channel_depth", "=", "hparams", ".", "initial_channel_depth", ",", "\n", "init_bias", "=", "hparams", ".", "init_bias", ",", "norm_layers", "=", "hparams", ".", "g_norm_layers", ",", "\n", "out_channels", "=", "hparams", ".", "img_channels", ",", "equalize_layers", "=", "hparams", ".", "equalize", ",", "\n", "leakiness", "=", "hparams", ".", "leakiness", ",", "mode", "=", "hparams", ".", "mode", ")", "\n", "\n", "self", ".", "discriminator", "=", "ProDiscriminator", "(", "channel_depth", "=", "hparams", ".", "initial_channel_depth", ",", "init_bias", "=", "hparams", ".", "init_bias", ",", "\n", "norm_layers", "=", "hparams", ".", "d_norm_layers", ",", "input_channels", "=", "hparams", ".", "img_channels", ",", "\n", "decision_layer_dim", "=", "hparams", ".", "decision_dim", ",", "equalize_layers", "=", "hparams", ".", "equalize", ",", "\n", "leakiness", "=", "hparams", ".", "leakiness", ",", "minibatch_std", "=", "hparams", ".", "minibatch_std", ")", "\n", "\n", "self", ".", "register_buffer", "(", "'scale'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "lr", "=", "hparams", ".", "lr", "\n", "self", ".", "b1", "=", "hparams", ".", "b1", "\n", "self", ".", "b2", "=", "hparams", ".", "b2", "\n", "self", ".", "eps", "=", "hparams", ".", "eps", "\n", "self", ".", "drift", "=", "hparams", ".", "drift", "\n", "self", ".", "lambda_val", "=", "hparams", ".", "lambda_val", "\n", "\n", "self", ".", "imgs", "=", "None", "\n", "\n", "self", ".", "channel_depths", "=", "[", "int", "(", "depths", ")", "for", "depths", "in", "hparams", ".", "depths", "]", "\n", "\n", "self", ".", "register_buffer", "(", "'alpha'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'alpha_jumps'", ",", "hparams", ".", "alpha_jumps", ")", "\n", "iters", "=", "int", "(", "self", ".", "alpha_jumps", "[", "self", ".", "scale", "]", "/", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", ")", "\n", "self", ".", "alpha_iters", "=", "iters", "\n", "self", ".", "alpha_vals", "=", "np", ".", "linspace", "(", "start", "=", "1", ",", "stop", "=", "0", ",", "num", "=", "iters", ")", "\n", "\n", "self", ".", "sample_rate", "=", "hparams", ".", "sample", "\n", "self", ".", "sample_num", "=", "hparams", ".", "sample_num", "\n", "\n", "self", ".", "iteration_sets", "=", "[", "int", "(", "iteration", ")", "for", "iteration", "in", "hparams", ".", "iterations", "]", "\n", "self", ".", "register_buffer", "(", "'total_iter'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'current_iter'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'num_images_seen'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'iter_images_seen'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'g_current_iter'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'d_current_iter'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "'fixed_z'", ",", "torch", ".", "randn", "(", "self", ".", "sample_num", ",", "self", ".", "z_dim", ",", "requires_grad", "=", "False", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "'epoch_counter'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "self", ".", "register_buffer", "(", "'batch_count'", ",", "torch", ".", "tensor", "(", "0", ")", ")", "\n", "\n", "self", ".", "ema", "=", "hparams", ".", "ema", "\n", "if", "self", ".", "ema", ":", "\n", "            ", "self", ".", "ema_decay", "=", "hparams", ".", "ema_decay", "\n", "self", ".", "gen_shadow", "=", "copy", ".", "deepcopy", "(", "self", ".", "generator", ")", "\n", "exp_avg_update", "(", "target", "=", "self", ".", "gen_shadow", ",", "source", "=", "self", ".", "generator", ",", "beta", "=", "0", ")", "\n", "\n", "", "self", ".", "set_fp16", "=", "hparams", ".", "set_fp16", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.forward": [[334, 336], ["network.ProGAN.generator"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "latent", ")", ":", "\n", "        ", "return", "self", ".", "generator", "(", "latent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.training_step": [[337, 389], ["network.ProGAN.check_network_scale", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "latent.type_as.type_as.type_as", "next", "img_batch.detach", "network.ProGAN.discriminator", "network.ProGAN.forward().detach", "network.ProGAN.discriminator", "GAN.utility.compute_gradient_penalty", "d_loss.unsqueeze.unsqueeze.unsqueeze", "collections.OrderedDict", "network.ProGAN.forward", "network.ProGAN.discriminator", "g_loss.unsqueeze.unsqueeze.unsqueeze", "collections.OrderedDict", "network.ProGAN.parameters", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "network.ProGAN.forward", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.check_network_scale", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.compute_gradient_penalty", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.forward", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.forward"], ["", "def", "training_step", "(", "self", ",", "img_list", ",", "batch_idx", ",", "optimizer_idx", ")", ":", "\n", "        ", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "img_batch", ",", "_", "=", "img_list", "\n", "\n", "self", ".", "check_network_scale", "(", ")", "\n", "\n", "# Random Noise Vector:", "\n", "latent", "=", "torch", ".", "randn", "(", "img_batch", ".", "shape", "[", "0", "]", ",", "self", ".", "z_dim", ")", "\n", "latent", "=", "latent", ".", "type_as", "(", "img_batch", ")", "\n", "# Training the discriminator first appears to promote more stable training", "\n", "if", "optimizer_idx", "==", "0", ":", "# Discriminator Training:", "\n", "# No labels are needed as the higher the average real score the better the discriminator", "\n", "# and the lower the average fake score the better", "\n", "            ", "real_imgs", "=", "img_batch", ".", "detach", "(", ")", "\n", "real_validity", "=", "self", ".", "discriminator", "(", "real_imgs", ")", "\n", "\n", "fake_imgs", "=", "self", ".", "forward", "(", "latent", ")", ".", "detach", "(", ")", "\n", "fake_validity", "=", "self", ".", "discriminator", "(", "fake_imgs", ")", "\n", "\n", "gradient_penalty", "=", "compute_gradient_penalty", "(", "real_samples", "=", "real_imgs", ",", "fake_samples", "=", "fake_imgs", ")", "\n", "\n", "d_loss", "=", "-", "torch", ".", "mean", "(", "real_validity", ")", "+", "torch", ".", "mean", "(", "fake_validity", ")", "+", "self", ".", "lambda_val", "*", "gradient_penalty", "+", "self", ".", "drift", "*", "torch", ".", "mean", "(", "real_validity", "**", "2", ")", "\n", "d_loss", "=", "d_loss", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "tqdm_dict", "=", "{", "'d_loss'", ":", "d_loss", "}", "\n", "output", "=", "OrderedDict", "(", "{", "\n", "'loss'", ":", "d_loss", ",", "\n", "'progress_bar'", ":", "tqdm_dict", ",", "\n", "'log'", ":", "tqdm_dict", ",", "\n", "'opt_step'", ":", "torch", ".", "tensor", "(", "[", "optimizer_idx", "]", ")", ".", "to", "(", "device", ")", "\n", "}", ")", "\n", "\n", "return", "output", "\n", "\n", "", "if", "optimizer_idx", "==", "1", ":", "# Generator Training:", "\n", "            ", "fake_imgs", "=", "self", ".", "forward", "(", "latent", ")", "# Generate Images from Noise", "\n", "validity_score", "=", "self", ".", "discriminator", "(", "fake_imgs", ")", "\n", "\n", "# Calculate Generator Loss", "\n", "g_loss", "=", "-", "torch", ".", "mean", "(", "validity_score", ")", "\n", "g_loss", "=", "g_loss", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "tqdm_dict", "=", "{", "'g_loss'", ":", "g_loss", "}", "\n", "output", "=", "OrderedDict", "(", "{", "\n", "'loss'", ":", "g_loss", ",", "\n", "'progress_bar'", ":", "tqdm_dict", ",", "\n", "'log'", ":", "tqdm_dict", ",", "\n", "'opt_step'", ":", "torch", ".", "tensor", "(", "[", "optimizer_idx", "]", ")", ".", "to", "(", "device", ")", "\n", "}", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.training_step_end": [[390, 438], ["outputs[].squeeze", "int", "network.ProGAN.check_network_scale", "network.ProGAN.logger.experiment.add_scalar", "next", "GAN.utility.exp_avg_update", "network.ProGAN.parameters", "len", "network.ProGAN.update_alpha", "network.ProGAN.update_alpha", "network.ProGAN.update_alpha", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "network.ProGAN.forward().detach", "torchvision.make_grid", "network.ProGAN.logger.experiment.add_image", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "network.ProGAN.gen_shadow.forward().detach", "torchvision.make_grid", "network.ProGAN.logger.experiment.add_image", "network.ProGAN.forward", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "network.ProGAN.gen_shadow.forward"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.check_network_scale", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.exp_avg_update", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.forward", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.forward"], ["", "", "def", "training_step_end", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Method collating all results on a single GPU. Can be used to increment values that will be distributed\n        to all GPUs on future training steps. Image logs can be produced without redundancy as well.\n        \"\"\"", "\n", "if", "int", "(", "outputs", "[", "'opt_step'", "]", "[", "-", "1", "]", ")", "==", "1", ":", "# Only called after the generator is updated", "\n", "            ", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "\n", "self", ".", "total_iter", "+=", "1", "\n", "self", ".", "current_iter", "+=", "1", "\n", "self", ".", "num_images_seen", "+=", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", "\n", "self", ".", "iter_images_seen", "+=", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", "\n", "self", ".", "g_current_iter", "+=", "1", "\n", "\n", "self", ".", "check_network_scale", "(", ")", "\n", "\n", "if", "self", ".", "ema", ":", "\n", "                ", "exp_avg_update", "(", "target", "=", "self", ".", "gen_shadow", ",", "source", "=", "self", ".", "generator", ",", "beta", "=", "self", ".", "ema_decay", ")", "\n", "\n", "", "if", "self", ".", "alpha_iters", ">=", "self", ".", "current_iter", ":", "\n", "                ", "if", "len", "(", "self", ".", "alpha_vals", ")", ">", "0", ":", "# Check alpha values exist for current scale", "\n", "                    ", "alpha", "=", "self", ".", "alpha_vals", "[", "self", ".", "current_iter", "-", "1", "]", "\n", "self", ".", "update_alpha", "(", "torch", ".", "tensor", "(", "alpha", ")", ".", "to", "(", "device", ")", ")", "\n", "", "else", ":", "# Correct if no mixing is specified for particular scale", "\n", "                    ", "self", ".", "update_alpha", "(", "torch", ".", "tensor", "(", "0", ")", ".", "to", "(", "device", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "alpha", ">", "0", ":", "# Correct if alpha not 0", "\n", "                    ", "self", ".", "update_alpha", "(", "torch", ".", "tensor", "(", "0", ")", ".", "to", "(", "device", ")", ")", "\n", "\n", "", "", "self", ".", "logger", ".", "experiment", ".", "add_scalar", "(", "'Alpha_Mixing_Coefficient'", ",", "self", ".", "alpha", ",", "self", ".", "total_iter", ")", "\n", "\n", "# Generate Fixed Samples & Store", "\n", "if", "self", ".", "current_iter", "%", "self", ".", "sample_rate", "==", "0", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "samples", "=", "self", ".", "forward", "(", "self", ".", "fixed_z", ")", ".", "detach", "(", ")", "\n", "grid", "=", "vutils", ".", "make_grid", "(", "samples", ",", "normalize", "=", "True", ")", "\n", "self", ".", "logger", ".", "experiment", ".", "add_image", "(", "'generated_images'", ",", "grid", ",", "self", ".", "total_iter", ")", "\n", "\n", "if", "self", ".", "ema", ":", "\n", "                        ", "samples", "=", "self", ".", "gen_shadow", ".", "forward", "(", "self", ".", "fixed_z", ")", ".", "detach", "(", ")", "\n", "grid", "=", "vutils", ".", "make_grid", "(", "samples", ",", "normalize", "=", "True", ")", "\n", "self", ".", "logger", ".", "experiment", ".", "add_image", "(", "'shadow_generated_images'", ",", "grid", ",", "self", ".", "total_iter", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "self", ".", "d_current_iter", "+=", "1", "\n", "\n", "", "outputs", "[", "'loss'", "]", "=", "outputs", "[", "'loss'", "]", ".", "squeeze", "(", "0", ")", "\n", "del", "outputs", "[", "'opt_step'", "]", "# Remove tracking value from output", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.check_network_scale": [[439, 448], ["next", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "network.ProGAN.parameters", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "check_network_scale", "(", "self", ")", ":", "\n", "        ", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "if", "self", ".", "generator", ".", "current_depth", "!=", "self", ".", "scale", ":", "\n", "            ", "self", ".", "generator", ".", "current_depth", "=", "torch", ".", "tensor", "(", "self", ".", "scale", ")", ".", "to", "(", "device", ")", "\n", "if", "self", ".", "ema", ":", "\n", "                ", "self", ".", "gen_shadow", ".", "current_depth", "=", "torch", ".", "tensor", "(", "self", ".", "scale", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "", "if", "self", ".", "discriminator", ".", "current_depth", "!=", "self", ".", "scale", ":", "\n", "            ", "self", ".", "discriminator", ".", "current_depth", "=", "torch", ".", "tensor", "(", "self", ".", "scale", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.configure_optimizers": [[449, 459], ["torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "network.ProGAN.discriminator.parameters", "network.ProGAN.generator.parameters"], "methods", ["None"], ["", "", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "lr", "=", "self", ".", "lr", "\n", "b1", "=", "self", ".", "b1", "\n", "b2", "=", "self", ".", "b2", "\n", "epsilon", "=", "self", ".", "eps", "\n", "\n", "opt_d", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "discriminator", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "betas", "=", "(", "b1", ",", "b2", ")", ",", "eps", "=", "epsilon", ")", "\n", "opt_g", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "generator", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "betas", "=", "(", "b1", ",", "b2", ")", ",", "eps", "=", "epsilon", ")", "\n", "\n", "return", "[", "opt_d", ",", "opt_g", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.configure_apex": [[460, 466], ["amp.initialize"], "methods", ["None"], ["", "def", "configure_apex", "(", "self", ",", "amp", ",", "model", ",", "optimizers", ",", "amp_level", ")", ":", "\n", "        ", "[", "model", ".", "generator", ",", "model", ".", "discriminator", "]", ",", "optimizers", "=", "amp", ".", "initialize", "(", "\n", "[", "model", ".", "generator", ",", "model", ".", "discriminator", "]", ",", "optimizers", ",", "opt_level", "=", "amp_level", ",", "\n", ")", "\n", "\n", "return", "model", ",", "optimizers", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.add_depth": [[467, 490], ["print", "network.ProGAN.generator.incrementdepth", "network.ProGAN.discriminator.incrementdepth", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "int", "numpy.linspace", "network.ProGAN.update_alpha", "next", "network.ProGAN.gen_shadow.incrementdepth", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "network.ProGAN.parameters", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.incrementdepth"], ["", "def", "add_depth", "(", "self", ")", ":", "\n", "        ", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "scale", "=", "self", ".", "scale", "\n", "\n", "print", "(", "\"Adding Depth, Scale:\"", ",", "scale", "+", "1", ",", "\"Img Size:\"", ",", "self", ".", "img_size", "*", "2", ")", "\n", "\n", "self", ".", "generator", ".", "incrementdepth", "(", "self", ".", "channel_depths", "[", "scale", "]", ")", "\n", "\n", "if", "self", ".", "ema", ":", "\n", "            ", "self", ".", "gen_shadow", ".", "incrementdepth", "(", "self", ".", "channel_depths", "[", "scale", "]", ")", "\n", "\n", "", "self", ".", "discriminator", ".", "incrementdepth", "(", "self", ".", "channel_depths", "[", "scale", "]", ")", "\n", "\n", "self", ".", "img_size", "*=", "2", "# Double Spatial Dimensions", "\n", "self", ".", "scale", "+=", "1", "\n", "self", ".", "current_iter", "=", "torch", ".", "tensor", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "iter_images_seen", "=", "torch", ".", "tensor", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "# Generate a smooth linear array of numbers from 1 to 0 for fading in layers", "\n", "iters", "=", "int", "(", "self", ".", "alpha_jumps", "[", "self", ".", "scale", "]", "/", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", ")", "\n", "self", ".", "alpha_iters", "=", "iters", "\n", "alpha_range", "=", "np", ".", "linspace", "(", "start", "=", "1", ",", "stop", "=", "0", ",", "num", "=", "iters", ")", "\n", "self", ".", "alpha_vals", "=", "alpha_range", "\n", "self", ".", "update_alpha", "(", "torch", ".", "tensor", "(", "1", ")", ".", "to", "(", "device", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha": [[491, 501], ["network.ProGAN.generator.set_alpha", "network.ProGAN.discriminator.set_alpha", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "network.ProGAN.gen_shadow.set_alpha", "type", "next", "network.ProGAN.parameters", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.set_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.set_alpha", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.set_alpha"], ["", "def", "update_alpha", "(", "self", ",", "new_alpha", ")", ":", "\n", "        ", "if", "type", "(", "new_alpha", ")", ".", "__name__", "!=", "'Tensor'", ":", "\n", "            ", "device", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "new_alpha", "=", "torch", ".", "tensor", "(", "new_alpha", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "self", ".", "alpha", "=", "new_alpha", "\n", "self", ".", "generator", ".", "set_alpha", "(", "new_alpha", ")", "\n", "if", "self", ".", "ema", ":", "\n", "            ", "self", ".", "gen_shadow", ".", "set_alpha", "(", "new_alpha", ")", "\n", "", "self", ".", "discriminator", ".", "set_alpha", "(", "new_alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.prepare_data": [[502, 504], ["GAN.dataset.VariableImageFolder"], "methods", ["None"], ["", "def", "prepare_data", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgs", "=", "VariableImageFolder", "(", "self", ".", "directory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.train_dataloader": [[505, 520], ["network.ProGAN.imgs.update_img_size", "network.ProGAN.imgs.update_img_len", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_img_size", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_img_len"], ["", "def", "train_dataloader", "(", "self", ")", ":", "# Dataloader is reset at the end of each epoch", "\n", "# Using the variable length dataset enables finer control over the number of images shown", "\n", "        ", "batch_size", "=", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", "\n", "img_size", "=", "self", ".", "img_size", "\n", "worker_num", "=", "self", ".", "worker_num", "\n", "imgs_needed", "=", "self", ".", "iteration_sets", "[", "self", ".", "scale", "]", "-", "self", ".", "iter_images_seen", "# For loading in the middle of epochs", "\n", "if", "imgs_needed", "<=", "0", ":", "\n", "            ", "imgs_needed", "=", "1", "# Correct for potential image number error", "\n", "\n", "", "self", ".", "imgs", ".", "update_img_size", "(", "img_size", ")", "\n", "self", ".", "imgs", ".", "update_img_len", "(", "imgs_needed", ")", "\n", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "self", ".", "imgs", ",", "batch_size", "=", "batch_size", ",", "drop_last", "=", "True", ",", "\n", "shuffle", "=", "True", ",", "num_workers", "=", "worker_num", ")", "\n", "return", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.on_epoch_end": [[521, 527], ["network.ProGAN.add_depth"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.add_depth"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "self", ".", "epoch_counter", "+=", "1", "\n", "# Number of total images needed", "\n", "imgs_needed", "=", "self", ".", "iteration_sets", "[", "self", ".", "scale", "]", "-", "self", ".", "iter_images_seen", "\n", "if", "imgs_needed", "<=", "0", ":", "\n", "            ", "self", ".", "add_depth", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.get_settings": [[528, 549], ["None"], "methods", ["None"], ["", "", "def", "get_settings", "(", "self", ")", ":", "\n", "        ", "settings_dict", "=", "{", "\n", "'alpha'", ":", "self", ".", "alpha", ",", "\n", "\n", "'g_size'", ":", "self", ".", "generator", ".", "current_size", ",", "\n", "'g_depth'", ":", "self", ".", "generator", ".", "current_depth", ",", "\n", "'g_alpha'", ":", "self", ".", "generator", ".", "alpha", ",", "\n", "'d_size'", ":", "self", ".", "discriminator", ".", "current_size", ",", "\n", "'d_depth'", ":", "self", ".", "discriminator", ".", "current_depth", ",", "\n", "'d_alpha'", ":", "self", ".", "discriminator", ".", "alpha", ",", "\n", "\n", "'total_iter'", ":", "self", ".", "total_iter", ",", "\n", "'current_iter'", ":", "self", ".", "current_iter", ",", "\n", "'num_images_seen'", ":", "self", ".", "num_images_seen", ",", "\n", "'iter_images_seen'", ":", "self", ".", "iter_images_seen", ",", "\n", "'g_current_iter'", ":", "self", ".", "g_current_iter", ",", "\n", "'d_current_iter'", ":", "self", ".", "d_current_iter", ",", "\n", "\n", "'fixed_z'", ":", "self", ".", "fixed_z", "\n", "}", "\n", "return", "settings_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.set_settings": [[550, 576], ["network.ProGAN.update_alpha", "int", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.update_alpha"], ["", "def", "set_settings", "(", "self", ",", "settings", ")", ":", "\n", "\n", "        ", "self", ".", "alpha", "=", "settings", "[", "'alpha'", "]", "\n", "self", ".", "update_alpha", "(", "settings", "[", "'alpha'", "]", ")", "# Update alpha to previous value", "\n", "iters", "=", "int", "(", "self", ".", "alpha_jumps", "[", "self", ".", "scale", "]", "/", "self", ".", "batch_sizes", "[", "self", ".", "scale", "]", ")", "\n", "self", ".", "alpha_iters", "=", "iters", "\n", "self", ".", "alpha_vals", "=", "np", ".", "linspace", "(", "start", "=", "1", ",", "stop", "=", "0", ",", "num", "=", "iters", ")", "\n", "\n", "self", ".", "generator", ".", "current_size", "=", "settings", "[", "'g_size'", "]", "\n", "self", ".", "generator", ".", "current_depth", "=", "settings", "[", "'g_depth'", "]", "\n", "\n", "if", "self", ".", "ema", ":", "\n", "            ", "self", ".", "gen_shadow", ".", "current_size", "=", "settings", "[", "'g_size'", "]", "\n", "self", ".", "gen_shadow", ".", "current_depth", "=", "settings", "[", "'g_depth'", "]", "\n", "\n", "", "self", ".", "discriminator", ".", "current_size", "=", "settings", "[", "'d_size'", "]", "\n", "self", ".", "discriminator", ".", "current_depth", "=", "settings", "[", "'d_depth'", "]", "\n", "\n", "self", ".", "total_iter", "=", "settings", "[", "'total_iter'", "]", "\n", "self", ".", "current_iter", "=", "settings", "[", "'current_iter'", "]", "\n", "self", ".", "num_images_seen", "=", "settings", "[", "'num_images_seen'", "]", "\n", "self", ".", "iter_images_seen", "=", "settings", "[", "'iter_images_seen'", "]", "\n", "self", ".", "g_current_iter", "=", "settings", "[", "'g_current_iter'", "]", "\n", "self", ".", "d_current_iter", "=", "settings", "[", "'d_current_iter'", "]", "\n", "\n", "self", ".", "fixed_z", "=", "settings", "[", "'fixed_z'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.load_model": [[577, 585], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "range", "network.ProGAN.load_state_dict", "network.ProGAN.set_settings", "print", "network.ProGAN.add_depth"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.set_settings", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProGAN.add_depth"], ["", "def", "load_model", "(", "self", ",", "path", ")", ":", "\n", "        ", "checkpoint", "=", "torch", ".", "load", "(", "path", ")", "\n", "for", "_", "in", "range", "(", "checkpoint", "[", "'settings'", "]", "[", "'g_depth'", "]", ")", ":", "\n", "            ", "self", ".", "add_depth", "(", ")", "\n", "", "self", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "self", ".", "set_settings", "(", "checkpoint", "[", "'settings'", "]", ")", "\n", "print", "(", "\"Model & Settings Successfully Loaded\"", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.__init__": [[6, 15], ["torchvision.ImageFolder.__init__", "int", "torchvision.ImageFolder.__len__", "dataset.VariableImageFolder.update_transformations"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.__len__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_transformations"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "img_size", "=", "4", ",", "mean", "=", "0", ",", "std", "=", "1", ",", "channels", "=", "3", ")", ":", "\n", "        ", "super", "(", "VariableImageFolder", ",", "self", ")", ".", "__init__", "(", "dataset", ",", "transform", "=", "transforms", ")", "\n", "\n", "self", ".", "mean", "=", "[", "mean", "]", "*", "channels", "\n", "self", ".", "std", "=", "[", "std", "]", "*", "channels", "\n", "self", ".", "img_size", "=", "int", "(", "img_size", ")", "\n", "self", ".", "max", "=", "super", "(", "VariableImageFolder", ",", "self", ")", ".", "__len__", "(", ")", "\n", "self", ".", "imgs", "=", "self", ".", "max", "\n", "self", ".", "update_transformations", "(", ")", "# Set the default method for transforming images", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.__len__": [[16, 21], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "imgs", ">", "self", ".", "max", ":", "\n", "            ", "return", "self", ".", "max", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_img_len": [[22, 28], ["int"], "methods", ["None"], ["", "", "def", "update_img_len", "(", "self", ",", "new_len", ")", ":", "\n", "        ", "new_len", "=", "int", "(", "new_len", ")", "\n", "if", "new_len", ">", "0", ":", "\n", "            ", "self", ".", "imgs", "=", "new_len", "\n", "", "else", ":", "\n", "            ", "self", ".", "imgs", "=", "1", "# Corrects for if during loading the image requirements are negative", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_img_size": [[29, 32], ["int", "dataset.VariableImageFolder.update_transformations"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_transformations"], ["", "", "def", "update_img_size", "(", "self", ",", "new_size", ")", ":", "\n", "        ", "self", ".", "img_size", "=", "int", "(", "new_size", ")", "\n", "self", ".", "update_transformations", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.dataset.VariableImageFolder.update_transformations": [[33, 39], ["torchvision.Compose", "torchvision.Compose", "torchvision.Resize", "torchvision.Resize", "torchvision.ToTensor", "torchvision.ToTensor", "torchvision.Normalize", "torchvision.Normalize", "tuple", "tuple"], "methods", ["None"], ["", "def", "update_transformations", "(", "self", ")", ":", "\n", "        ", "transformations", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "self", ".", "img_size", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "tuple", "(", "self", ".", "mean", ")", ",", "tuple", "(", "self", ".", "std", ")", ")", "]", ")", "\n", "self", ".", "transform", "=", "transformations", "\n", "", "", ""]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.PixelNormalizationLayer.__init__": [[28, 34], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Normalizes a minibatch of images by dividing each pixel by the average squared pixel across all channels\n        Norm = Root(Pixel / Sum(Pixel**2)/(Num Channels))\n        \"\"\"", "\n", "super", "(", "PixelNormalizationLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.PixelNormalizationLayer.forward": [[35, 39], ["x.pow().mean", "x.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "# Epsilon \u2192 Small value for numerical stability when dividing", "\n", "        ", "norm", "=", "x", "*", "(", "x", ".", "pow", "(", "2", ")", ".", "mean", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "+", "epsilon", ")", ".", "rsqrt", "(", ")", "# rsqrt \u2192 Reciprocal Square Root", "\n", "return", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.EqualizedLayer.__init__": [[42, 67], ["torch.Module.__init__", "custom_layers.EqualizedLayer.module.weight.data.normal_", "custom_layers.he_initializer", "custom_layers.EqualizedLayer.module.bias.data.fill_"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.he_initializer"], ["    ", "def", "__init__", "(", "self", ",", "module", ",", "equalize", "=", "True", ",", "bias_init", "=", "True", ",", "lrmult", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Wrapper layer that enables a linear or convolutional layer to execute He Initialization at runtime as well\n        as set initial biases of a module to 0.\n        The initialization is performed during the forward pass of the network to enable adaptive gradient descent methods\n        (eg. Adam) to better compensate for the equalization of learning rates. Equalization first sets all weights to random\n        numbers between -1 & 1 / N(0, 1), and then multiplies by the He constant at runtime.\n        :param module: Torch module to be equalized based on the number of connections\n        :param equalize: Flag to disable He Initialization\n        :param bias_init: Flag to disable initializing bias values to 0\n        :param lrmult: Custom layer-specific learning rate multiplier\n        \"\"\"", "\n", "super", "(", "EqualizedLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "module", "=", "module", "\n", "self", ".", "equalize", "=", "equalize", "\n", "self", ".", "init_bias", "=", "bias_init", "\n", "\n", "if", "self", ".", "equalize", ":", "\n", "            ", "self", ".", "module", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "1", ")", "# Normal distribution mean of 0, SD of 1", "\n", "self", ".", "module", ".", "weight", ".", "data", "/=", "lrmult", "# Scale weights by a layer specific learning rate multiplier", "\n", "# Divides by multiplier as the He Value is the reciprocal of multiple of the output weights", "\n", "self", ".", "he_val", "=", "he_initializer", "(", "self", ".", "module", ")", "\n", "", "if", "self", ".", "init_bias", ":", "\n", "            ", "self", ".", "module", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.EqualizedLayer.forward": [[68, 73], ["custom_layers.EqualizedLayer.module"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "module", "(", "x", ")", "# Forward pass through the module", "\n", "if", "self", ".", "equalize", ":", "\n", "            ", "x", "*=", "self", ".", "he_val", "# Scale by the He Constant", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.EqualizedConv2D.__init__": [[76, 104], ["custom_layers.EqualizedLayer.__init__", "torch.Conv2d", "torch.Conv2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "prev_channels", ",", "channels", ",", "kernel", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ",", "transpose", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Modified 2D convolution that is able to employ He Initialization at runtime as well as to initialize biases to 0\n        :param prev_channels:\n        :param channels:\n        :param kernel:\n        :param stride:\n        :param padding:\n        :param bias:\n        :param transpose:\n        :param kwargs:\n        \"\"\"", "\n", "if", "not", "transpose", ":", "\n", "            ", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "prev_channels", ",", "\n", "out_channels", "=", "channels", ",", "\n", "kernel_size", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "bias", ")", "\n", "", "else", ":", "\n", "            ", "conv", "=", "nn", ".", "ConvTranspose2d", "(", "in_channels", "=", "prev_channels", ",", "\n", "out_channels", "=", "channels", ",", "\n", "kernel_size", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "bias", ")", "\n", "\n", "", "EqualizedLayer", ".", "__init__", "(", "self", ",", "conv", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.EqualizedLinear.__init__": [[107, 120], ["torch.Linear", "torch.Linear", "custom_layers.EqualizedLayer.__init__"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "bias", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Modified Fully Connected Layer to employ He Initialization at runtime and initialize biases to 0\n        :param in_features:\n        :param out_features:\n        :param bias:\n        :param kwargs:\n        \"\"\"", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "bias", "=", "bias", "\n", "linear", "=", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ",", "bias", "=", "bias", ")", "\n", "EqualizedLayer", ".", "__init__", "(", "self", ",", "linear", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.ScaleBlock.__init__": [[157, 193], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "GAN.utility.calc_padding", "custom_layers.Conv_Block", "custom_layers.Conv_Block"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.utility.calc_padding", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block"], ["    ", "def", "__init__", "(", "self", ",", "dims", ",", "prev_channel", ",", "channels", ",", "scale", "=", "1", ",", "equalize", "=", "True", ",", "normalize", "=", "True", ",", "\n", "leakiness", "=", "0.2", ",", "kernel", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "None", ",", "bias", "=", "True", ",", "mode", "=", "\"bilinear\"", ")", ":", "\n", "        ", "\"\"\"\n        Standard convolutional block that combines two identical convolutions and an interpolation operation.\n        If the block upscales an image, the upscaling is done prior to the convolutions\n        If the block downscales, the upscaling is done after the convolutions\n        :param dims:\n        :param prev_channel:\n        :param channels:\n        :param scale:\n        :param equalize:\n        :param normalize:\n        :param leakiness:\n        :param kernel:\n        :param stride:\n        :param padding:\n        :param bias:\n        :param mode:\n        \"\"\"", "\n", "super", "(", "ScaleBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "scale", "in", "[", "0.5", ",", "1", ",", "2", "]", ",", "\"Scale can only half, double or maintain spatial resolution\"", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "equalize", "=", "equalize", "\n", "\n", "assert", "mode", "in", "[", "'nearest'", ",", "'bilinear'", "]", ",", "f\"Only configured for 'nearest' & 'bilinear', but {mode} was selected\"", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "if", "padding", "is", "None", ":", "\n", "            ", "padding", "=", "calc_padding", "(", "dims", ",", "kernel", ",", "stride", ")", "\n", "\n", "", "self", ".", "convolv", "=", "nn", ".", "Sequential", "(", "\n", "*", "Conv_Block", "(", "prev_channel", "=", "prev_channel", ",", "channels", "=", "channels", ",", "kernel", "=", "kernel", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "\n", "bias", "=", "bias", ",", "equalize", "=", "equalize", ",", "leakiness", "=", "leakiness", ",", "normalize", "=", "normalize", ")", ",", "\n", "*", "Conv_Block", "(", "prev_channel", "=", "channels", ",", "channels", "=", "channels", ",", "kernel", "=", "kernel", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "\n", "bias", "=", "bias", ",", "equalize", "=", "equalize", ",", "leakiness", "=", "leakiness", ",", "normalize", "=", "normalize", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.ScaleBlock.forward": [[195, 205], ["custom_layers.ScaleBlock.convolv", "torch.interpolate", "torch.interpolate", "torch.avg_pool2d", "torch.avg_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat_map", ")", ":", "\n", "        ", "if", "self", ".", "scale", ">", "1", ":", "\n", "            ", "feat_map", "=", "F", ".", "interpolate", "(", "input", "=", "feat_map", ",", "scale_factor", "=", "self", ".", "scale", ",", "mode", "=", "self", ".", "mode", ")", "\n", "\n", "", "feat_map", "=", "self", ".", "convolv", "(", "feat_map", ")", "\n", "\n", "if", "self", ".", "scale", "<", "1", ":", "\n", "            ", "feat_map", "=", "F", ".", "avg_pool2d", "(", "input", "=", "feat_map", ",", "kernel_size", "=", "(", "2", ",", "2", ")", ")", "\n", "\n", "", "return", "feat_map", "\n", "", "", ""]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.he_initializer": [[8, 25], ["isinstance", "module.weight.size", "numpy.prod", "numpy.sqrt"], "function", ["None"], ["def", "he_initializer", "(", "module", ")", ":", "\n", "    ", "\"\"\"\n    Returns He's Initialization Constant for Conv2D or linear modules. It is inversely proportional to the root\n    of the product of the neurons/weights for a given module. Scales the gradient relative to the number of weights\n    to remove the correlation between the number of connections and the gradient.\n    Formulation only valid for convolutional & linear layers due to weight arrangement\n    https://arxiv.org/abs/1502.01852\n    \"\"\"", "\n", "assert", "isinstance", "(", "module", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ",", "nn", ".", "Linear", ")", ")", ",", "\"Formulation only valid for Conv2d & linear layers\"", "\n", "weight_shape", "=", "module", ".", "weight", ".", "size", "(", ")", "# due to arrangement of weights", "\n", "# Conv2d weights as out_channel x in_channel x kernel[0] x kernel[1]", "\n", "\n", "fan_in", "=", "np", ".", "prod", "(", "weight_shape", "[", "1", ":", "]", ")", "# Removes the out_channel weights and multiplies the rest together", "\n", "he_const", "=", "np", ".", "sqrt", "(", "2.0", "/", "fan_in", ")", "\n", "\n", "return", "he_const", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.custom_layers.Conv_Block": [[122, 154], ["torch.ModuleList", "nn.ModuleList.append", "nn.ModuleList.append", "nn.ModuleList.append", "nn.ModuleList.append", "custom_layers.EqualizedConv2D", "torch.Conv2d", "torch.LeakyReLU", "custom_layers.PixelNormalizationLayer"], "function", ["None"], ["", "", "def", "Conv_Block", "(", "prev_channel", ",", "channels", ",", "kernel", ",", "stride", ",", "padding", ",", "bias", "=", "True", ",", "\n", "equalize", "=", "True", ",", "leakiness", "=", "0.2", ",", "normalize", "=", "True", ",", "activation", "=", "True", ",", "transpose", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Convenience method to simplify the logic of creating a convolution block by specifying the layers to return.\n    Allows specification of equalized learning rate convolutions and normalization layers after convolutions.\n    :param prev_channel:\n    :param channels:\n    :param kernel:\n    :param stride:\n    :param padding:\n    :param bias:\n    :param equalize:\n    :param leakiness:\n    :param normalize:\n    :param activation:\n    :param transpose:\n    :return:\n    \"\"\"", "\n", "block", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "equalize", ":", "\n", "        ", "block", ".", "append", "(", "EqualizedConv2D", "(", "prev_channels", "=", "prev_channel", ",", "channels", "=", "channels", ",", "kernel", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ",", "transpose", "=", "transpose", ")", ")", "\n", "", "else", ":", "\n", "        ", "block", ".", "append", "(", "nn", ".", "Conv2d", "(", "in_channels", "=", "prev_channel", ",", "out_channels", "=", "channels", ",", "kernel_size", "=", "kernel", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ")", ")", "\n", "", "if", "activation", ":", "\n", "        ", "block", ".", "append", "(", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "leakiness", ",", "inplace", "=", "True", ")", ")", "\n", "\n", "", "if", "normalize", ":", "\n", "        ", "block", ".", "append", "(", "PixelNormalizationLayer", "(", ")", ")", "\n", "\n", "", "return", "block", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.training.GAN_trainer": [[6, 15], ["utility.Checkpoint", "pytorch_lightning.Trainer", "pl.Trainer.fit"], "function", ["None"], ["def", "GAN_trainer", "(", "GAN_model", ",", "ngpu", ",", "iter_per_save", "=", "500", ",", "filepath", "=", "\"./Checkpoints/\"", ")", ":", "\n", "    ", "checkpoint_callback", "=", "Checkpoint", "(", "filepath", ",", "save_rate", "=", "iter_per_save", ")", "\n", "total_epochs", "=", "1", "\n", "GANTrainer", "=", "pl", ".", "Trainer", "(", "gpus", "=", "ngpu", ",", "min_epochs", "=", "total_epochs", ",", "max_epochs", "=", "total_epochs", ",", "\n", "callbacks", "=", "[", "checkpoint_callback", "]", ",", "distributed_backend", "=", "'dp'", ",", "early_stop_callback", "=", "False", ",", "\n", "reload_dataloaders_every_epoch", "=", "True", ",", "profiler", "=", "True", ")", "\n", "\n", "GANTrainer", ".", "progress_bar_refresh_rate", "=", "1", "\n", "GANTrainer", ".", "fit", "(", "GAN_model", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__": [[7, 19], ["GAN.network.ProDiscriminator.__init__", "subnetworks.FeatureExtractor.load"], "methods", ["home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.__init__", "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.network.ProDiscriminator.load"], ["    ", "def", "__init__", "(", "self", ",", "checkpoint", ")", ":", "\n", "        ", "state_dict", ",", "settings", "=", "checkpoint", "[", "'state_dict'", "]", ",", "checkpoint", "[", "'settings'", "]", "\n", "super", "(", "FeatureExtractor", ",", "self", ")", ".", "__init__", "(", "channel_depth", "=", "settings", "[", "'channel_depth'", "]", "[", "0", "]", ",", "\n", "init_bias", "=", "settings", "[", "'init_bias'", "]", ",", "\n", "norm_layers", "=", "settings", "[", "'norm_layers'", "]", ",", "\n", "input_channels", "=", "settings", "[", "'input_channels'", "]", ",", "\n", "decision_layer_dim", "=", "settings", "[", "'decision_layer_dim'", "]", ",", "\n", "equalize_layers", "=", "settings", "[", "'equalize'", "]", ",", "\n", "leakiness", "=", "settings", "[", "'leakiness'", "]", ",", "\n", "minibatch_std", "=", "settings", "[", "'minibatch'", "]", ")", "\n", "self", ".", "load", "(", "checkpoint", ")", "\n", "del", "self", ".", "DecisionLinear", "# Remove duplicate final scoring layer", "\n", "\n"]], "home.repos.pwc.inspect_result.BradSegal_CXR_PGGAN.PGGAN.subnetworks.FeatureExtractor.forward": [[41, 68], ["enumerate", "subnetworks.FeatureExtractor.DecisionBlock", "subnetworks.FeatureExtractor.view", "scale_block", "subnetworks.FeatureExtractor.miniSTD"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "#, map_extracts=1, cat=True):", "\n", "        ", "batch", ",", "channels", ",", "height", ",", "width", "=", "x", ".", "shape", "\n", "extract", "=", "[", "]", "# Multi-Scale Feature Extraction", "\n", "# Convert from RGB to Feature Maps:", "\n", "x", "=", "self", ".", "fromRGB", "[", "-", "1", "]", "(", "x", ")", "\n", "\n", "for", "scale_num", ",", "scale_block", "in", "enumerate", "(", "self", ".", "ScaleBlocks", ")", ":", "\n", "# if len(self.ScaleBlocks) - scale_num <= (map_extracts-2):  # Remove 2 due to the final 2 feature maps", "\n", "#     extract.append(x)", "\n", "            ", "x", "=", "scale_block", "(", "x", ")", "# Process the input through the contraction block of conv, conv, downsample", "\n", "\n", "# if map_extracts >= 2:", "\n", "#     extract.append(x)", "\n", "\n", "", "if", "self", ".", "minibatch", ":", "\n", "            ", "x", "=", "self", ".", "miniSTD", "(", "x", ",", "dim", "=", "1", ")", "# Calculate the std across the feature maps and not minibatchs", "\n", "\n", "", "x", "=", "self", ".", "DecisionBlock", "(", "x", ")", "# Final 3x3, 4x4 conv", "\n", "\n", "x", "=", "x", ".", "view", "(", "batch", ",", "-", "1", ")", "\n", "\n", "# if map_extracts >= 1:", "\n", "#     extract.append(x)", "\n", "\n", "# if cat:", "\n", "#     extract = torch.cat([feat.view(batch, -1) for feat in extract], dim=1)", "\n", "return", "x", "#extract  # Final set of extracted feature vectors for an image", "\n", "", "", ""]]}