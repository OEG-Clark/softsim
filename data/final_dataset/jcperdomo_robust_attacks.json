{"home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.compute_mwu_accuracies": [[7, 27], ["range", "range", "range", "model_accs_per_point.append", "numpy.mean", "numpy.mean", "max_acc_plot.append", "mean_acc_plot.append", "model_accs.append", "numpy.array", "numpy.mean", "numpy.max", "model.accuracy", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["def", "compute_mwu_accuracies", "(", "models", ",", "noise_vectors", ",", "images", ",", "labels", ")", ":", "\n", "    ", "mwu_iters", ",", "num_points", "=", "noise_vectors", ".", "shape", "[", ":", "2", "]", "\n", "model_accs_per_point", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_points", ")", ":", "\n", "        ", "x", "=", "images", "[", "i", "]", "\n", "y", "=", "labels", "[", "i", "]", "\n", "model_accs", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "mwu_iters", ")", ":", "\n", "            ", "v", "=", "noise_vectors", "[", "t", "]", "[", "i", "]", "\n", "model_accs", ".", "append", "(", "[", "model", ".", "accuracy", "(", "x", "+", "v", ",", "y", ")", "for", "model", "in", "models", "]", ")", "\n", "", "model_accs_per_point", ".", "append", "(", "np", ".", "array", "(", "model_accs", ")", ")", "\n", "\n", "", "max_acc_plot", "=", "[", "]", "\n", "mean_acc_plot", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "mwu_iters", ")", ":", "\n", "        ", "mean_acc", "=", "np", ".", "mean", "(", "[", "np", ".", "mean", "(", "np", ".", "mean", "(", "model_accs", "[", ":", "t", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "for", "model_accs", "in", "model_accs_per_point", "]", ")", "\n", "max_acc", "=", "np", ".", "mean", "(", "[", "np", ".", "max", "(", "np", ".", "mean", "(", "model_accs", "[", ":", "t", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "for", "model_accs", "in", "model_accs_per_point", "]", ")", "\n", "max_acc_plot", ".", "append", "(", "max_acc", ")", "\n", "mean_acc_plot", ".", "append", "(", "mean_acc", ")", "\n", "", "return", "{", "'max'", ":", "max_acc_plot", ",", "'mean'", ":", "mean_acc_plot", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.subset_feasible_models": [[28, 32], ["len", "model.distance().item", "range", "model.distance"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.distance"], ["", "def", "subset_feasible_models", "(", "models", ",", "x", ",", "noise_budget", ")", ":", "\n", "    ", "dists", "=", "[", "model", ".", "distance", "(", "x", ")", ".", "item", "(", ")", "for", "model", "in", "models", "]", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "return", "[", "models", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "dists", "[", "i", "]", "<", "noise_budget", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.ensemble_linear_models": [[34, 52], ["len", "type", "sum", "torch.tensor", "torch.tensor", "TorchModel", "sum", "sum", "model.weights.reshape"], "function", ["None"], ["", "def", "ensemble_linear_models", "(", "models", ")", ":", "\n", "    ", "num_classifiers", "=", "len", "(", "models", ")", "\n", "model_type", "=", "type", "(", "models", "[", "0", "]", ")", "\n", "if", "model_type", "is", "BinaryClassifier", ":", "\n", "        ", "TorchModel", "=", "BinaryClassifier", "\n", "ensemble_weights", "=", "sum", "(", "[", "1.0", "/", "num_classifiers", "*", "model", ".", "weights", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "for", "model", "in", "models", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "TorchModel", "=", "MultiClassifier", "\n", "ensemble_weights", "=", "sum", "(", "[", "1.0", "/", "num_classifiers", "*", "model", ".", "weights", "\n", "for", "model", "in", "models", "]", ")", "\n", "\n", "", "ensemble_bias", "=", "sum", "(", "[", "1.0", "/", "num_classifiers", "*", "model", ".", "bias", "for", "model", "in", "models", "]", ")", "\n", "ensemble_weights", "=", "torch", ".", "tensor", "(", "ensemble_weights", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "ensemble_bias", "=", "torch", ".", "tensor", "(", "ensemble_bias", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "ensemble", "=", "TorchModel", "(", "ensemble_weights", ",", "ensemble_bias", ")", "\n", "return", "ensemble", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.compute_linear_ensemble_baseline": [[54, 76], ["type", "range", "torch.stack().reshape", "len", "images[].unsqueeze", "linear_baselines.ensemble_linear_models", "oracle", "noise_vectors.append", "images.size", "linear_baselines.subset_feasible_models", "numpy.ones", "torch.stack", "torch.tensor", "torch.tensor", "oracle.norm", "ensemble_linear_models.weights.reshape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.ensemble_linear_models", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.subset_feasible_models"], ["", "def", "compute_linear_ensemble_baseline", "(", "models", ",", "images", ",", "labels", ",", "noise_budget", ")", ":", "\n", "    ", "model_type", "=", "type", "(", "models", "[", "0", "]", ")", "\n", "if", "model_type", "is", "BinaryClassifier", ":", "\n", "        ", "oracle", "=", "distributional_oracle_binary", "\n", "out_dim", "=", "1", "\n", "", "else", ":", "\n", "        ", "oracle", "=", "distributional_oracle_multi", "\n", "out_dim", "=", "3", "\n", "\n", "", "noise_vectors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "        ", "x", "=", "images", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "labels", "[", "i", "]", "\n", "ensemble", "=", "ensemble_linear_models", "(", "subset_feasible_models", "(", "models", ",", "x", ",", "noise_budget", ")", ")", "\n", "ensemble_array", "=", "[", "(", "torch", ".", "tensor", "(", "ensemble", ".", "weights", ".", "reshape", "(", "out_dim", ",", "-", "1", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "torch", ".", "tensor", "(", "ensemble", ".", "bias", ",", "dtype", "=", "torch", ".", "float", ")", ")", "]", "\n", "\n", "v", "=", "oracle", "(", "np", ".", "ones", "(", "1", ")", ",", "ensemble_array", ",", "x", ",", "y", ",", "sys", ".", "maxsize", ")", "\n", "v", "=", "v", "/", "v", ".", "norm", "(", ")", "*", "noise_budget", "\n", "noise_vectors", ".", "append", "(", "v", ")", "\n", "", "return", "torch", ".", "stack", "(", "noise_vectors", ")", ".", "reshape", "(", "images", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.coordinate_ascent": [[78, 119], ["linear_baselines.subset_feasible_models", "len", "torch.zeros", "type", "x.numpy().reshape.numpy().reshape", "y.item.item", "list", "list", "range", "x.numpy().reshape.size", "torch.zeros", "range", "set().difference", "range", "numpy.random.choice", "list", "numpy.random.choice", "try_region", "x.numpy().reshape.size", "x.numpy().reshape.numpy", "set", "set().difference", "numpy.linalg.norm", "set", "torch.tensor().reshape", "set", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.subset_feasible_models"], ["", "def", "coordinate_ascent", "(", "models", ",", "x", ",", "y", ",", "noise_budget", ")", ":", "\n", "    ", "models", "=", "subset_feasible_models", "(", "models", ",", "x", ",", "noise_budget", ")", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "\n", "sol", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", ")", ")", "\n", "# can't trick anything", "\n", "if", "num_models", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "x", ".", "size", "(", ")", ")", "\n", "\n", "", "model_type", "=", "type", "(", "models", "[", "0", "]", ")", "\n", "if", "model_type", "is", "BinaryClassifier", ":", "\n", "        ", "try_region", "=", "try_region_binary", "\n", "labels", "=", "[", "-", "1", ",", "1", "]", "\n", "", "else", ":", "\n", "        ", "try_region", "=", "try_region_multi", "\n", "labels", "=", "range", "(", "3", ")", "\n", "\n", "", "x", "=", "x", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "y", "=", "y", ".", "item", "(", ")", "\n", "\n", "label_vector", "=", "[", "y", "]", "*", "num_models", "# initialize to the original point, of length feasible_models", "\n", "label_options", "=", "list", "(", "set", "(", "labels", ")", ".", "difference", "(", "set", "(", "[", "y", "]", ")", ")", ")", "\n", "model_options", "=", "list", "(", "range", "(", "num_models", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_models", ")", ":", "\n", "        ", "coord", "=", "np", ".", "random", ".", "choice", "(", "model_options", ")", "\n", "model_options", "=", "list", "(", "set", "(", "model_options", ")", ".", "difference", "(", "[", "coord", "]", ")", ")", "\n", "\n", "label_vector", "[", "coord", "]", "=", "np", ".", "random", ".", "choice", "(", "label_options", ")", "\n", "v", "=", "try_region", "(", "models", ",", "label_vector", ",", "x", ")", "\n", "\n", "if", "v", "is", "not", "None", ":", "\n", "            ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "v", ")", "\n", "if", "norm", "<=", "noise_budget", ":", "\n", "                ", "sol", "=", "torch", ".", "tensor", "(", "v", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "", "else", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "sol", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.compute_linear_coordinate_ascent_baseline": [[121, 128], ["range", "torch.stack().reshape", "len", "images[].unsqueeze", "coordinate_ascent_baseline.append", "images.size", "linear_baselines.coordinate_ascent", "torch.stack"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.coordinate_ascent"], ["", "def", "compute_linear_coordinate_ascent_baseline", "(", "models", ",", "images", ",", "labels", ",", "noise_budget", ")", ":", "\n", "    ", "coordinate_ascent_baseline", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "        ", "x", "=", "images", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "labels", "[", "i", "]", "\n", "coordinate_ascent_baseline", ".", "append", "(", "coordinate_ascent", "(", "models", ",", "x", ",", "y", ",", "noise_budget", ")", ")", "\n", "", "return", "torch", ".", "stack", "(", "coordinate_ascent_baseline", ")", ".", "reshape", "(", "images", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_baselines.compute_max_individual_baseline": [[130, 159], ["type", "range", "torch.stack().reshape", "len", "images[].unsqueeze", "noise_vectors.append", "images.size", "oracle", "max", "individual_attacks.append", "torch.stack", "numpy.ones", "min", "torch.tensor", "torch.tensor", "oracle.norm", "model.accuracy", "model.weights.reshape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["", "def", "compute_max_individual_baseline", "(", "models", ",", "images", ",", "labels", ",", "noise_budget", ")", ":", "\n", "    ", "model_type", "=", "type", "(", "models", "[", "0", "]", ")", "\n", "if", "model_type", "is", "BinaryClassifier", ":", "\n", "        ", "oracle", "=", "distributional_oracle_binary", "\n", "out_dim", "=", "1", "\n", "", "else", ":", "\n", "        ", "oracle", "=", "distributional_oracle_multi", "\n", "out_dim", "=", "3", "\n", "\n", "", "noise_vectors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "        ", "x", "=", "images", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "labels", "[", "i", "]", "\n", "\n", "individual_attacks", "=", "[", "]", "\n", "for", "model", "in", "models", ":", "\n", "            ", "model_array", "=", "[", "(", "torch", ".", "tensor", "(", "model", ".", "weights", ".", "reshape", "(", "out_dim", ",", "-", "1", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "torch", ".", "tensor", "(", "model", ".", "bias", ",", "dtype", "=", "torch", ".", "float", ")", ")", "]", "\n", "\n", "v", "=", "oracle", "(", "np", ".", "ones", "(", "1", ")", ",", "model_array", ",", "x", ",", "y", ",", "sys", ".", "maxsize", ")", "\n", "v", "=", "v", "/", "v", ".", "norm", "(", ")", "*", "noise_budget", "\n", "\n", "max_acc", "=", "max", "(", "[", "model", ".", "accuracy", "(", "x", "+", "v", ",", "y", ")", "for", "model", "in", "models", "]", ")", "\n", "individual_attacks", ".", "append", "(", "(", "max_acc", ",", "v", ")", ")", "\n", "\n", "", "noise_vectors", ".", "append", "(", "min", "(", "individual_attacks", ",", "key", "=", "lambda", "x", ":", "x", "[", "0", "]", ")", "[", "1", "]", ")", "\n", "\n", "", "return", "torch", ".", "stack", "(", "noise_vectors", ")", ".", "reshape", "(", "images", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.subset_multiclass_data": [[13, 26], ["set", "range", "label_dict.keys", "len", "numpy.array", "numpy.array", "X.append", "Y.append"], "function", ["None"], ["def", "subset_multiclass_data", "(", "data", ",", "labels", ",", "label_dict", ")", ":", "\n", "# subsets data to only include labels in label dict", "\n", "# label dict has the form of original label -> new label", "\n", "    ", "subset", "=", "set", "(", "label_dict", ".", "keys", "(", ")", ")", "\n", "X", "=", "[", "]", "\n", "Y", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "        ", "label", "=", "labels", "[", "i", "]", "\n", "if", "label", "in", "subset", ":", "\n", "            ", "label", "=", "label_dict", "[", "label", "]", "\n", "X", ".", "append", "(", "data", "[", "i", "]", ")", "\n", "Y", ".", "append", "(", "label", ")", "\n", "", "", "return", "np", ".", "array", "(", "X", ")", ",", "np", ".", "array", "(", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.get_mnist_data": [[28, 49], ["torchvision.datasets.MNIST", "linear_experiments_setup.subset_multiclass_data", "datasets.MNIST.train_labels.numpy", "datasets.MNIST.test_labels.numpy", "len", "torchvision.transforms.ToTensor", "datasets.MNIST.train_data.numpy().reshape", "datasets.MNIST.test_data.numpy().reshape", "range", "datasets.MNIST.train_data.numpy", "datasets.MNIST.test_data.numpy", "len"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.subset_multiclass_data"], ["", "def", "get_mnist_data", "(", "train", ",", "sel_labels", ")", ":", "\n", "    ", "\"\"\"\n\n    :param train: bool, indicates whether to download the training set or test set\n    :param sel_labels: list of labels to subset from the full data set\n    :return: X, Y\n    \"\"\"", "\n", "mnist", "=", "datasets", ".", "MNIST", "(", "'../data'", ",", "train", "=", "train", ",", "download", "=", "True", ",", "transform", "=", "transforms", ".", "ToTensor", "(", ")", ")", "\n", "if", "train", ":", "\n", "        ", "images", "=", "mnist", ".", "train_data", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "28", "*", "28", ")", "/", "255.0", "\n", "labels", "=", "mnist", ".", "train_labels", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mnist", ".", "test_data", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", "28", "*", "28", ")", "/", "255.0", "\n", "labels", "=", "mnist", ".", "test_labels", ".", "numpy", "(", ")", "\n", "\n", "", "if", "len", "(", "sel_labels", ")", "==", "2", ":", "\n", "        ", "label_dict", "=", "{", "sel_labels", "[", "0", "]", ":", "-", "1", ",", "sel_labels", "[", "1", "]", ":", "1", "}", "\n", "", "else", ":", "\n", "        ", "label_dict", "=", "{", "sel_labels", "[", "i", "]", ":", "i", "for", "i", "in", "range", "(", "len", "(", "sel_labels", ")", ")", "}", "\n", "\n", "", "return", "subset_multiclass_data", "(", "images", ",", "labels", ",", "label_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.generate_feature_independent_svms": [[51, 87], ["int", "list", "range", "range", "range", "list", "numpy.copy", "sklearn.svm.LinearSVC", "sklearn.svm.LinearSVC.fit", "models.append", "TorchModel", "numpy.random.choice", "chosen_dims.append", "list", "numpy.random.choice", "set().difference", "len", "torch.tensor", "torch.tensor", "set().difference", "range", "set", "set", "set", "set", "set", "range"], "function", ["None"], ["", "def", "generate_feature_independent_svms", "(", "num_classifiers", ",", "train_data", ",", "train_labels", ",", "exclusive", ")", ":", "\n", "    ", "\"\"\"\n    :param num_classifiers: int\n    :param train_data: numpy array\n    :param train_labels: numpy array\n    :return: list of torch models with weight vectors that are nonzero in mutually exclusive dimensions\n    \"\"\"", "\n", "dims", "=", "train_data", ".", "shape", "[", "1", "]", "\n", "dim_per_classifier", "=", "int", "(", "dims", "/", "num_classifiers", ")", "# defaults to floor function if not integer", "\n", "remaining_dims", "=", "list", "(", "range", "(", "dims", ")", ")", "\n", "chosen_dims", "=", "[", "]", "\n", "\n", "if", "exclusive", ":", "\n", "        ", "for", "_", "in", "range", "(", "num_classifiers", ")", ":", "\n", "            ", "chosen", "=", "np", ".", "random", ".", "choice", "(", "remaining_dims", ",", "size", "=", "dim_per_classifier", ",", "replace", "=", "False", ")", "\n", "chosen_dims", ".", "append", "(", "chosen", ")", "\n", "remaining_dims", "=", "list", "(", "set", "(", "remaining_dims", ")", ".", "difference", "(", "set", "(", "chosen", ")", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "chosen_dims", "=", "[", "np", ".", "random", ".", "choice", "(", "remaining_dims", ",", "size", "=", "dim_per_classifier", ")", "for", "_", "in", "range", "(", "num_classifiers", ")", "]", "\n", "\n", "", "models", "=", "[", "]", "\n", "zeroed_features_list", "=", "[", "list", "(", "set", "(", "range", "(", "dims", ")", ")", ".", "difference", "(", "set", "(", "x", ")", ")", ")", "for", "x", "in", "chosen_dims", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_classifiers", ")", ":", "\n", "        ", "sparse_data", "=", "np", ".", "copy", "(", "train_data", ")", "\n", "sparse_data", "[", ":", ",", "zeroed_features_list", "[", "i", "]", "]", "=", "0.0", "\n", "model", "=", "LinearSVC", "(", "loss", "=", "'hinge'", ")", "\n", "model", ".", "fit", "(", "sparse_data", ",", "train_labels", ")", "\n", "models", ".", "append", "(", "model", ")", "\n", "\n", "", "TorchModel", "=", "BinaryClassifier", "if", "len", "(", "set", "(", "train_labels", ")", ")", "==", "2", "else", "MultiClassifier", "\n", "\n", "torch_models", "=", "[", "TorchModel", "(", "torch", ".", "tensor", "(", "model", ".", "coef_", ",", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "torch", ".", "tensor", "(", "model", ".", "intercept_", ",", "dtype", "=", "torch", ".", "float", ")", ")", "for", "model", "in", "models", "]", "\n", "\n", "return", "torch_models", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.generate_experiment_data": [[88, 105], ["len", "range", "len", "logging.info", "torch.stack", "torch.stack", "sum", "res_X.append", "res_Y.append", "model.accuracy"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["", "def", "generate_experiment_data", "(", "num_pts", ",", "X", ",", "Y", ",", "models", ")", ":", "\n", "# returns num_pts from (X, Y) that are correctly classified by all models", "\n", "    ", "num_selected", "=", "0", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "res_X", "=", "[", "]", "\n", "res_Y", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "        ", "all_correct", "=", "sum", "(", "[", "model", ".", "accuracy", "(", "X", "[", "i", ":", "i", "+", "1", "]", ",", "Y", "[", "i", ":", "i", "+", "1", "]", ")", "for", "model", "in", "models", "]", ")", "==", "num_models", "\n", "if", "all_correct", ":", "\n", "            ", "res_X", ".", "append", "(", "X", "[", "i", "]", ")", "\n", "res_Y", ".", "append", "(", "Y", "[", "i", "]", ")", "\n", "num_selected", "+=", "1", "\n", "", "if", "num_selected", "==", "num_pts", ":", "\n", "            ", "break", "\n", "", "", "if", "num_selected", "<", "num_pts", ":", "\n", "        ", "log", ".", "info", "(", "\"Not enough points were correctly predicted by all models\"", ")", "\n", "", "return", "torch", ".", "stack", "(", "res_X", ")", ",", "torch", ".", "stack", "(", "res_Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.main": [[106, 179], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logging.basicConfig", "logging.info", "logging.info", "logging.info", "linear_experiments_setup.get_mnist_data", "linear_experiments_setup.get_mnist_data", "linear_experiments_setup.generate_feature_independent_svms", "torch.tensor", "torch.tensor", "linear_experiments_setup.generate_experiment_data", "numpy.array", "numpy.percentile", "logging.info", "enumerate", "torch.save", "torch.save", "logging.info", "len", "len", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "multiprocessing.Pool", "pool.starmap", "logging.info", "torch.save", "os.path.exists", "os.mkdir", "torch.tensor", "torch.tensor", "numpy.ones", "x.reshape", "torch.tensor", "zip", "v.norm().item", "model.weights.reshape", "len", "model.accuracy", "v.norm"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.get_mnist_data", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.get_mnist_data", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.generate_feature_independent_svms", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.linear_experiments_setup.generate_experiment_data", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["", "def", "main", "(", "arguments", ")", ":", "\n", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-num_points\"", ",", "help", "=", "\"number of points to generate\"", ",", "type", "=", "int", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"-num_classifiers\"", ",", "help", "=", "\"number of classifiers\"", ",", "type", "=", "int", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-exclusive'", ",", "type", "=", "bool", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"-sel_labels\"", ",", "help", "=", "\"list of labels to subset\"", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ",", "required", "=", "True", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", "arguments", ")", "\n", "\n", "if", "len", "(", "args", ".", "sel_labels", ")", "==", "2", ":", "\n", "        ", "subdirectory", "=", "'binary'", "\n", "oracle", "=", "distributional_oracle_binary", "\n", "out_dim", "=", "1", "\n", "", "else", ":", "\n", "        ", "subdirectory", "=", "'multi'", "\n", "oracle", "=", "distributional_oracle_multi", "\n", "out_dim", "=", "len", "(", "args", ".", "sel_labels", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'experiment_data/'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'experiment_data/'", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'experiment_data/linear/'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'experiment_data/linear/'", ")", "\n", "\n", "", "log", ".", "basicConfig", "(", "format", "=", "'%(asctime)s: %(message)s'", ",", "level", "=", "log", ".", "INFO", ",", "datefmt", "=", "'%m/%d/%Y %I:%M:%S %p'", ",", "\n", "filename", "=", "'experiment_data/linear_{}_setup.log'", ".", "format", "(", "subdirectory", ")", ",", "filemode", "=", "'w'", ")", "\n", "log", ".", "info", "(", "'Number of Points {}'", ".", "format", "(", "args", ".", "num_points", ")", ")", "\n", "log", ".", "info", "(", "'Number of Classifiers {}'", ".", "format", "(", "args", ".", "num_classifiers", ")", ")", "\n", "log", ".", "info", "(", "'Selected Labels {}'", ".", "format", "(", "args", ".", "sel_labels", ")", ")", "\n", "\n", "train_data", ",", "train_labels", "=", "get_mnist_data", "(", "True", ",", "args", ".", "sel_labels", ")", "\n", "test_data", ",", "test_labels", "=", "get_mnist_data", "(", "False", ",", "args", ".", "sel_labels", ")", "\n", "\n", "models", "=", "generate_feature_independent_svms", "(", "args", ".", "num_classifiers", ",", "train_data", ",", "train_labels", ",", "args", ".", "exclusive", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'models/'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'models/'", ")", "\n", "\n", "", "model_save_path", "=", "'models/'", "+", "subdirectory", "+", "'/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "model_save_path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "model_save_path", ")", "\n", "\n", "", "test_data", "=", "torch", ".", "tensor", "(", "test_data", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "test_labels", "=", "torch", ".", "tensor", "(", "test_labels", ")", "\n", "exp_images", ",", "exp_labels", "=", "generate_experiment_data", "(", "args", ".", "num_points", ",", "test_data", ",", "test_labels", ",", "models", ")", "\n", "\n", "model_arrays", "=", "[", "(", "torch", ".", "tensor", "(", "model", ".", "weights", ".", "reshape", "(", "out_dim", ",", "-", "1", ")", ",", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "torch", ".", "tensor", "(", "model", ".", "bias", ",", "dtype", "=", "torch", ".", "float", ")", ")", "for", "model", "in", "models", "]", "\n", "\n", "param_list", "=", "[", "(", "np", ".", "ones", "(", "len", "(", "models", ")", ")", ",", "model_arrays", ",", "x", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "torch", ".", "tensor", "(", "[", "y", "]", ")", ",", "sys", ".", "maxsize", ")", "\n", "for", "x", ",", "y", "in", "zip", "(", "exp_images", ",", "exp_labels", ")", "]", "\n", "\n", "with", "multiprocessing", ".", "Pool", "(", "processes", "=", "30", ")", "as", "pool", ":", "\n", "        ", "vectors", "=", "pool", ".", "starmap", "(", "oracle", ",", "param_list", ")", "\n", "\n", "", "distances", "=", "np", ".", "array", "(", "[", "v", ".", "norm", "(", ")", ".", "item", "(", ")", "for", "v", "in", "vectors", "]", ")", "\n", "# distances = np.array([model.distance(exp_images).detach().numpy() for model in models])", "\n", "\n", "percentiles", "=", "np", ".", "percentile", "(", "distances", ",", "[", "10", ",", "25", ",", "50", ",", "75", ",", "90", "]", ")", "\n", "log", ".", "info", "(", "\"Max Distance Percentiles [10, 25, 50, 75, 90] for Exp Images \\n {}\"", ".", "format", "(", "percentiles", ")", ")", "\n", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "        ", "log", ".", "info", "(", "'Model {} Test Accuracy : {}'", ".", "format", "(", "i", ",", "model", ".", "accuracy", "(", "test_data", ",", "test_labels", ")", ")", ")", "\n", "torch", ".", "save", "(", "model", ",", "model_save_path", "+", "'model_{}.pt'", ".", "format", "(", "i", ")", ")", "\n", "\n", "", "data_save_path", "=", "'experiment_data/linear/'", "+", "subdirectory", "+", "'/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "data_save_path", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "data_save_path", ")", "\n", "\n", "", "torch", ".", "save", "(", "exp_images", ",", "'experiment_data/linear/'", "+", "subdirectory", "+", "'/mnist_images.pt'", ")", "\n", "torch", ".", "save", "(", "exp_labels", ",", "'experiment_data/linear/'", "+", "subdirectory", "+", "'/mnist_labels.pt'", ")", "\n", "\n", "log", ".", "info", "(", "'Success'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.main.main": [[14, 89], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logging.basicConfig", "logging.info", "logging.info", "logging.info", "logging.info", "torch_models.load_models", "logging.info", "logging.info", "multiplicative_weights.run_mwu", "torch.save", "numpy.save", "numpy.save", "numpy.save", "logging.info", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "logging.info", "functools.partial", "torch.load", "torch.load", "torch.load", "torch.load", "len", "torch.load", "torch.load", "torch.load.size"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.load_models", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.multiplicative_weights.run_mwu", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["def", "main", "(", "arguments", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-exp_type\"", ",", "help", "=", "\"choice of experiment to run\"", ",", "\n", "choices", "=", "[", "\"imagenet\"", ",", "\"mnist_binary\"", ",", "\"mnist_multi\"", "]", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"-mwu_iters\"", ",", "help", "=", "\"number of iterations for the MWU\"", ",", "type", "=", "int", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'-noise_function'", ",", "help", "=", "'noise function for best response oracle'", ",", "\n", "choices", "=", "[", "'oracle'", ",", "'pgd'", "]", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"-noise_budget\"", ",", "help", "=", "\"noise budget\"", ",", "type", "=", "float", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"-pgd_iters\"", ",", "help", "=", "'number of iterations to run (projected gradient descent)'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-name\"", ",", "help", "=", "'name (used to name results directory)'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", "arguments", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'experiment_results/'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'experiment_results/'", ")", "\n", "\n", "", "exp_dir", "=", "'experiment_results/'", "+", "args", ".", "name", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "exp_dir", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "exp_dir", ")", "\n", "\n", "", "log", ".", "basicConfig", "(", "format", "=", "'%(asctime)s: %(message)s'", ",", "level", "=", "log", ".", "INFO", ",", "datefmt", "=", "'%m/%d/%Y %I:%M:%S %p'", ",", "\n", "filename", "=", "exp_dir", "+", "\"/results.log\"", ",", "filemode", "=", "'w'", ")", "\n", "log", ".", "info", "(", "\"Experiment Type {}\"", ".", "format", "(", "args", ".", "exp_type", ")", ")", "\n", "log", ".", "info", "(", "'Noise Function {}'", ".", "format", "(", "args", ".", "noise_function", ")", ")", "\n", "log", ".", "info", "(", "\"MWU Iters {} \"", ".", "format", "(", "args", ".", "mwu_iters", ")", ")", "\n", "\n", "if", "args", ".", "pgd_iters", ":", "\n", "        ", "log", ".", "info", "(", "\"PGD Iters {}\"", ".", "format", "(", "args", ".", "pgd_iters", ")", ")", "\n", "\n", "", "log", ".", "info", "(", "\"Noise Budget {}\"", ".", "format", "(", "args", ".", "noise_budget", ")", ")", "\n", "\n", "# load data, setup attack", "\n", "if", "args", ".", "exp_type", "==", "'imagenet'", ":", "\n", "        ", "exp_data", "=", "torch", ".", "load", "(", "'experiment_data/imagenet/imagenet_images.pt'", ")", "[", ":", "100", "]", "\n", "exp_labels", "=", "torch", ".", "load", "(", "'experiment_data/imagenet/imagenet_labels.pt'", ")", "[", ":", "100", "]", "\n", "num_labels", "=", "1000", "\n", "cuda", "=", "True", "\n", "\n", "", "elif", "args", ".", "exp_type", "==", "'mnist_binary'", ":", "\n", "        ", "exp_data", "=", "torch", ".", "load", "(", "'experiment_data/linear/binary/mnist_images.pt'", ")", "\n", "exp_labels", "=", "torch", ".", "load", "(", "'experiment_data/linear/binary/mnist_labels.pt'", ")", "\n", "num_labels", "=", "2", "\n", "cuda", "=", "False", "\n", "\n", "", "elif", "args", ".", "exp_type", "==", "'mnist_multi'", ":", "\n", "        ", "exp_data", "=", "torch", ".", "load", "(", "'experiment_data/linear/multi/mnist_images.pt'", ")", "\n", "exp_labels", "=", "torch", ".", "load", "(", "'experiment_data/linear/multi/mnist_labels.pt'", ")", "\n", "num_labels", "=", "3", "\n", "cuda", "=", "False", "\n", "\n", "", "models", "=", "load_models", "(", "args", ".", "exp_type", ")", "\n", "\n", "log", ".", "info", "(", "\"Num Points {}\"", ".", "format", "(", "exp_data", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "log", ".", "info", "(", "'Num Classifiers {}'", ".", "format", "(", "len", "(", "models", ")", ")", ")", "\n", "\n", "if", "args", ".", "noise_function", "==", "'pgd'", ":", "\n", "        ", "adversary", "=", "partial", "(", "attacks", ".", "pgd", ",", "iters", "=", "args", ".", "pgd_iters", ",", "cuda", "=", "cuda", ")", "\n", "parallel", "=", "False", "\n", "", "else", ":", "\n", "        ", "parallel", "=", "True", "\n", "if", "args", ".", "exp_type", "==", "'mnist_binary'", ":", "\n", "            ", "adversary", "=", "attacks", ".", "distributional_oracle_binary", "\n", "", "elif", "args", ".", "exp_type", "==", "'mnist_multi'", ":", "\n", "            ", "adversary", "=", "attacks", ".", "distributional_oracle_multi", "\n", "", "for", "model", "in", "models", ":", "\n", "            ", "model", ".", "oracle", "=", "True", "\n", "\n", "", "", "noise_vectors", ",", "weights", ",", "expected_losses", ",", "minimum_losses", "=", "run_mwu", "(", "models", ",", "args", ".", "mwu_iters", ",", "exp_data", ",", "exp_labels", ",", "\n", "args", ".", "noise_budget", ",", "adversary", ",", "cuda", ",", "parallel", ",", "num_labels", ")", "\n", "torch", ".", "save", "(", "noise_vectors", ",", "exp_dir", "+", "'/noise_vectors.pt'", ")", "\n", "\n", "np", ".", "save", "(", "exp_dir", "+", "\"/weights.npy\"", ",", "weights", ")", "\n", "np", ".", "save", "(", "exp_dir", "+", "\"/expected_losses.npy\"", ",", "expected_losses", ")", "\n", "np", ".", "save", "(", "exp_dir", "+", "\"/minimum_losses.npy\"", ",", "minimum_losses", ")", "\n", "\n", "log", ".", "info", "(", "\"Finished!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.baselines.compute_model_accs_per_point": [[3, 12], ["len", "range", "numpy.array", "images[].unsqueeze", "noise_vectors[].unsqueeze", "model_accs_per_point.append", "model.accuracy"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["def", "compute_model_accs_per_point", "(", "models", ",", "images", ",", "noise_vectors", ",", "labels", ")", ":", "\n", "    ", "model_accs_per_point", "=", "[", "]", "\n", "num_points", "=", "len", "(", "images", ")", "\n", "for", "i", "in", "range", "(", "num_points", ")", ":", "\n", "        ", "x", "=", "images", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "\n", "v", "=", "noise_vectors", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "labels", "[", "i", "]", "\n", "model_accs_per_point", ".", "append", "(", "[", "model", ".", "accuracy", "(", "x", "+", "v", ",", "y", ")", "for", "model", "in", "models", "]", ")", "\n", "", "return", "np", ".", "array", "(", "model_accs_per_point", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.baselines.compute_best_individual_baseline": [[13, 28], ["numpy.array", "range", "mean_max.append", "baselines.compute_model_accs_per_point", "len", "range", "overall.append", "numpy.mean", "range", "len", "summary", "point_accuracy_per_model.append", "min", "len"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.baselines.compute_model_accs_per_point"], ["", "def", "compute_best_individual_baseline", "(", "models", ",", "images", ",", "individual_noise_vectors", ",", "labels", ")", ":", "\n", "    ", "individual_accs_per_model", "=", "np", ".", "array", "(", "[", "compute_model_accs_per_point", "(", "models", ",", "images", ",", "\n", "individual_noise_vectors", "[", "i", "]", ",", "labels", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "models", ")", ")", "]", ")", "\n", "mean_max", "=", "[", "]", "\n", "for", "summary", "in", "[", "np", ".", "mean", ",", "np", ".", "max", "]", ":", "\n", "        ", "overall", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "            ", "point_accuracy_per_model", "=", "[", "]", "\n", "for", "m", "in", "range", "(", "len", "(", "models", ")", ")", ":", "\n", "                ", "r", "=", "summary", "(", "individual_accs_per_model", "[", "m", "]", "[", "i", "]", ")", "\n", "point_accuracy_per_model", ".", "append", "(", "r", ")", "\n", "", "overall", ".", "append", "(", "min", "(", "point_accuracy_per_model", ")", ")", "\n", "", "mean_max", ".", "append", "(", "np", ".", "mean", "(", "overall", ")", ")", "\n", "", "return", "mean_max", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.multiplicative_weights.run_mwu": [[8, 94], ["len", "logging.info", "logging.info", "range", "torch.stack", "logging.info", "X.size", "numpy.sqrt", "min", "numpy.ones", "logging.info", "time.time", "range", "torch.stack", "torch.stack.append", "logging.info", "logging.info", "numpy.array", "numpy.array", "range", "range", "range", "X[].unsqueeze", "numpy.array", "expected_losses[].append", "minimum_losses[].append", "torch.stack.append", "range", "weights[].sum", "range", "time.time", "float", "torch.tensor", "torch.tensor", "X[].unsqueeze", "param_list.append", "multiprocessing.Pool", "pool.starmap", "x.cuda.cuda", "y.cuda.cuda", "adversary", "numpy.dot", "np.array.min", "adversary.cpu", "weights[].sum", "numpy.log", "model.weights.reshape", "model.loss_single().item", "model.loss_single"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.loss_single"], ["def", "run_mwu", "(", "models", ",", "iters", ",", "X", ",", "Y", ",", "noise_budget", ",", "adversary", ",", "cuda", ",", "parallel", ",", "num_labels", ",", "epsilon", "=", "None", ")", ":", "\n", "    ", "num_models", "=", "len", "(", "models", ")", "\n", "num_points", "=", "X", ".", "size", "(", ")", "[", "0", "]", "\n", "out_dim", "=", "1", "if", "num_labels", "==", "2", "else", "num_labels", "\n", "# compute epsilon as a function of the number of rounds, see paper for more details", "\n", "if", "epsilon", "is", "None", ":", "\n", "        ", "delta", "=", "np", ".", "sqrt", "(", "4", "*", "np", ".", "log", "(", "num_models", ")", "/", "float", "(", "iters", ")", ")", "\n", "epsilon", "=", "min", "(", "delta", "/", "2.0", ",", ".99", ")", "\n", "", "else", ":", "\n", "        ", "delta", "=", "2.0", "*", "epsilon", "\n", "\n", "", "log", ".", "info", "(", "\"\\nRunning MWU for {} Iterations with Epsilon {}\\n\"", ".", "format", "(", "iters", ",", "epsilon", ")", ")", "\n", "log", ".", "info", "(", "\"Guaranteed to be within {} of the minimax value \\n\"", ".", "format", "(", "delta", ")", ")", "\n", "\n", "# lets first do it for just one point and then add the rest of the functionality for multiple points", "\n", "weights", "=", "np", ".", "ones", "(", "(", "num_points", ",", "num_models", ")", ")", "/", "num_models", "\n", "expected_losses", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_points", ")", "]", "\n", "minimum_losses", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_points", ")", "]", "\n", "noise_vectors", "=", "[", "]", "\n", "\n", "#TODO", "\n", "if", "parallel", ":", "\n", "        ", "model_arrays", "=", "[", "(", "torch", ".", "tensor", "(", "model", ".", "weights", ".", "reshape", "(", "out_dim", ",", "-", "1", ")", ",", "dtype", "=", "torch", ".", "float", ")", ",", "\n", "torch", ".", "tensor", "(", "model", ".", "bias", ",", "dtype", "=", "torch", ".", "float", ")", ")", "for", "model", "in", "models", "]", "\n", "\n", "", "for", "t", "in", "range", "(", "iters", ")", ":", "\n", "        ", "log", ".", "info", "(", "\"Iteration {}\\n\"", ".", "format", "(", "t", ")", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# best response is a sequence of m vectors, m=num_points", "\n", "noise_vectors_t", "=", "[", "]", "\n", "\n", "# TODO parallelize the oracle", "\n", "if", "parallel", ":", "\n", "# print('using multiprocessing')", "\n", "            ", "param_list", "=", "[", "]", "\n", "for", "m", "in", "range", "(", "num_points", ")", ":", "\n", "                ", "x", "=", "X", "[", "m", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "Y", "[", "m", "]", "#TODO", "\n", "param_list", ".", "append", "(", "(", "weights", "[", "m", "]", ",", "model_arrays", ",", "x", ",", "y", ",", "noise_budget", ")", ")", "\n", "", "with", "multiprocessing", ".", "Pool", "(", "processes", "=", "30", ")", "as", "pool", ":", "\n", "                ", "best_responses", "=", "pool", ".", "starmap", "(", "adversary", ",", "param_list", ")", "\n", "\n", "", "", "for", "m", "in", "range", "(", "num_points", ")", ":", "\n", "\n", "            ", "x", "=", "X", "[", "m", "]", ".", "unsqueeze", "(", "0", ")", "\n", "y", "=", "Y", "[", "m", "]", "\n", "\n", "if", "cuda", ":", "\n", "                ", "x", "=", "x", ".", "cuda", "(", ")", "\n", "y", "=", "y", ".", "cuda", "(", ")", "\n", "\n", "", "if", "parallel", ":", "\n", "                ", "best_response", "=", "best_responses", "[", "m", "]", "\n", "", "else", ":", "\n", "# calculate the adversary's response given current distribution", "\n", "                ", "best_response", "=", "adversary", "(", "weights", "[", "m", "]", ",", "models", ",", "x", ",", "y", ",", "noise_budget", ")", "\n", "\n", "# compute loss of learner per expert", "\n", "", "current_loss", "=", "np", ".", "array", "(", "[", "1.0", "-", "model", ".", "loss_single", "(", "x", ",", "best_response", ",", "y", ",", "noise_budget", ")", ".", "item", "(", ")", "for", "model", "in", "models", "]", ")", "\n", "\n", "expected_losses", "[", "m", "]", ".", "append", "(", "np", ".", "dot", "(", "weights", "[", "m", "]", ",", "current_loss", ")", ")", "\n", "minimum_losses", "[", "m", "]", ".", "append", "(", "current_loss", ".", "min", "(", ")", ")", "\n", "\n", "noise_vectors_t", ".", "append", "(", "best_response", ".", "cpu", "(", ")", ")", "\n", "\n", "# penalize experts", "\n", "for", "i", "in", "range", "(", "num_models", ")", ":", "\n", "                ", "weights", "[", "m", ",", "i", "]", "=", "weights", "[", "m", ",", "i", "]", "*", "(", "1.0", "-", "epsilon", ")", "**", "current_loss", "[", "i", "]", "\n", "\n", "# normalize weights", "\n", "", "weights_sum", "=", "weights", "[", "m", "]", ".", "sum", "(", ")", "\n", "for", "i", "in", "range", "(", "num_models", "-", "1", ")", ":", "\n", "                ", "weights", "[", "m", ",", "i", "]", "=", "weights", "[", "m", ",", "i", "]", "/", "weights_sum", "\n", "", "weights", "[", "m", ",", "-", "1", "]", "=", "1.0", "-", "weights", "[", "m", ",", ":", "-", "1", "]", ".", "sum", "(", ")", "\n", "\n", "", "noise_vectors_t", "=", "torch", ".", "stack", "(", "noise_vectors_t", ")", "\n", "noise_vectors", ".", "append", "(", "noise_vectors_t", ")", "\n", "\n", "time_spent", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "log", ".", "info", "(", "\"time spent {}\"", ".", "format", "(", "time_spent", ")", ")", "\n", "log", ".", "info", "(", "\"time spent per point {}\\n\"", ".", "format", "(", "time_spent", "/", "num_points", ")", ")", "\n", "\n", "", "noise_vectors", "=", "torch", ".", "stack", "(", "noise_vectors", ")", "\n", "log", ".", "info", "(", "\"finished running multiplicative weights \"", ")", "\n", "return", "noise_vectors", ",", "weights", ",", "np", ".", "array", "(", "expected_losses", ")", ",", "np", ".", "array", "(", "minimum_losses", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.__init__": [[47, 65], ["torch.Module.__init__", "weights.norm", "weights.size", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "weights.numpy().reshape", "bias.item", "weights.numpy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "weights", ",", "bias", ")", ":", "\n", "        ", "super", "(", "BinaryClassifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# normalize weights to make distance measurements more convenient", "\n", "norm", "=", "weights", ".", "norm", "(", "2", ")", "\n", "weights", "=", "weights", "/", "norm", "\n", "bias", "=", "bias", "/", "norm", "\n", "\n", "in_dim", ",", "out_dim", "=", "weights", ".", "size", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", "\n", "self", ".", "linear", ".", "weight", "=", "nn", ".", "Parameter", "(", "weights", ")", "\n", "self", ".", "linear", ".", "bias", "=", "nn", ".", "Parameter", "(", "bias", ")", "\n", "\n", "# maintain numpy versions for (ease of) use with convex best response oracle", "\n", "self", ".", "weights", "=", "weights", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "self", ".", "bias", "=", "bias", ".", "item", "(", ")", "\n", "\n", "self", ".", "oracle", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.forward": [[66, 68], ["torch_models.BinaryClassifier.linear().reshape", "torch_models.BinaryClassifier.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "x", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.predict": [[69, 71], ["torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch_models.BinaryClassifier.forward"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "torch", ".", "sign", "(", "self", ".", "forward", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.distance": [[72, 75], ["torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch_models.BinaryClassifier.forward"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "distance", "(", "self", ",", "x", ")", ":", "\n", "# returns distance of points to the decision boundary", "\n", "        ", "return", "torch", ".", "abs", "(", "self", ".", "forward", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.accuracy": [[76, 79], ["Y.float.float.float", "torch.sign", "torch.sign", "torch.sign", "torch.sign", "torch_models.BinaryClassifier.forward"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "accuracy", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "Y", "=", "Y", ".", "float", "(", ")", "\n", "return", "(", "torch", ".", "sign", "(", "self", ".", "forward", "(", "X", ")", ")", "==", "Y", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.BinaryClassifier.loss_single": [[80, 96], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.ReLU", "torch.ReLU", "y.float.float.float", "torch_models.BinaryClassifier.accuracy", "torch.ReLU.", "torch_models.BinaryClassifier.forward", "torch_models.BinaryClassifier.forward"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "loss_single", "(", "self", ",", "x", ",", "v", ",", "y", ",", "noise_budget", ")", ":", "\n", "        ", "if", "self", ".", "oracle", ":", "\n", "            ", "return", "torch", ".", "tensor", "(", "self", ".", "accuracy", "(", "x", "+", "v", ",", "y", ")", ")", "\n", "", "else", ":", "\n", "# implements the reverse hinge loss, normalized to be bounded in the range [0,1]", "\n", "            ", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "\"\"\"\n            noise_budget * -y / ||w|| * w  is the optimal attack\n            therefore, max loss is induced by pushing in the opposite direction\n            \"\"\"", "\n", "y", "=", "y", ".", "float", "(", ")", "\n", "max_loss", "=", "(", "y", "*", "self", ".", "forward", "(", "x", "+", "y", "*", "noise_budget", "*", "self", ".", "linear", ".", "weight", ".", "data", ")", ")", ".", "item", "(", ")", "\n", "# it's possible that the max loss is less than 0 if the point is very far on the incorrect", "\n", "# side of the decision boundary", "\n", "max_loss", "=", "1", "if", "max_loss", "<", "0", "else", "max_loss", "\n", "return", "relu", "(", "y", "*", "self", ".", "forward", "(", "x", "+", "v", ")", ")", "/", "max_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.__init__": [[100, 112], ["torch.Module.__init__", "weights.size", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "weights.numpy", "bias.numpy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "weights", ",", "bias", ")", ":", "\n", "        ", "super", "(", "MultiClassifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "out_dim", ",", "in_dim", "=", "weights", ".", "size", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", "\n", "self", ".", "linear", ".", "weight", "=", "nn", ".", "Parameter", "(", "weights", ")", "\n", "self", ".", "linear", ".", "bias", "=", "nn", ".", "Parameter", "(", "bias", ")", "\n", "\n", "# maintain numpy versions for use with convex best response oracle", "\n", "self", ".", "weights", "=", "weights", ".", "numpy", "(", ")", "\n", "self", ".", "bias", "=", "bias", ".", "numpy", "(", ")", "\n", "self", ".", "oracle", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.forward": [[113, 115], ["torch_models.MultiClassifier.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.predict": [[116, 120], ["torch_models.MultiClassifier.forward", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "forward", "(", "x", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "out", ",", "1", ")", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.distance": [[121, 142], ["torch_models.MultiClassifier.predict", "X.numpy.numpy.numpy", "range", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "list", "distances.append", "range", "torch_models.try_region_multi", "dists.append", "min", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.predict", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.try_region_multi"], ["", "def", "distance", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Computes the minimum distance from a point to the decision boundary\n        by finding the optimal perturbation for each targeted attack and choosing the minium\n\n        returns: a vector of shape (num_points,) with the corresponding distances\n        \"\"\"", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "Y", "=", "self", ".", "predict", "(", "X", ")", "\n", "X", "=", "X", ".", "numpy", "(", ")", "\n", "\n", "distances", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "label_options", "=", "list", "(", "range", "(", "self", ".", "weights", ".", "shape", "[", "0", "]", ")", ")", "# create list of length num_classes", "\n", "del", "label_options", "[", "Y", "[", "i", "]", "]", "\n", "dists", "=", "[", "]", "\n", "for", "j", "in", "label_options", ":", "\n", "                ", "v", "=", "try_region_multi", "(", "[", "self", "]", ",", "[", "j", "]", ",", "X", "[", "i", "]", ")", "\n", "dists", ".", "append", "(", "np", ".", "linalg", ".", "norm", "(", "v", ")", ")", "\n", "", "distances", ".", "append", "(", "min", "(", "dists", ")", ")", "\n", "", "return", "torch", ".", "tensor", "(", "distances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.accuracy": [[143, 147], ["torch_models.MultiClassifier.forward", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "accuracy", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "out", "=", "self", ".", "forward", "(", "X", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "out", ",", "1", ")", "\n", "return", "(", "preds", "==", "Y", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.loss_single": [[148, 163], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch_models.MultiClassifier.forward", "torch_models.MultiClassifier.clone", "torch.max", "torch.max", "torch.max", "torch.max", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid", "torch.ReLU.", "torch_models.MultiClassifier.accuracy", "torch.min", "torch.min", "torch.min", "torch.min", "torch.Sigmoid.", "y.item", "y.item", "second_max_ix.item"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy"], ["", "def", "loss_single", "(", "self", ",", "x", ",", "v", ",", "y", ",", "noise_budget", ")", ":", "\n", "        ", "if", "self", ".", "oracle", ":", "\n", "            ", "return", "torch", ".", "tensor", "(", "self", ".", "accuracy", "(", "x", "+", "v", ",", "y", ")", ")", "\n", "", "else", ":", "\n", "            ", "logits", "=", "self", ".", "forward", "(", "x", "+", "v", ")", "\n", "# probs", "\n", "# true_max, max_ix = torch.max(probs, 1)", "\n", "logits2", "=", "logits", ".", "clone", "(", ")", "\n", "logits2", "[", "0", ",", "y", ".", "item", "(", ")", "]", "=", "torch", ".", "min", "(", "logits", ")", "-", "1.0", "\n", "_", ",", "second_max_ix", "=", "torch", ".", "max", "(", "logits2", ",", "1", ")", "\n", "diff", "=", "logits", "[", "0", ",", "y", ".", "item", "(", ")", "]", "-", "logits", "[", "0", ",", "second_max_ix", ".", "item", "(", ")", "]", "\n", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "loss", "=", "(", "sigmoid", "(", "diff", ")", "-", ".5", ")", "*", "2", "\n", "return", "relu", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.__init__": [[167, 174], ["torch.Module.__init__", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().pow().cuda", "torch.tensor().pow().cuda", "torch.tensor().pow().cuda", "torch.tensor().pow().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().pow", "torch.tensor().pow", "torch.tensor().pow", "torch.tensor().pow", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "cuda", "=", "True", ")", ":", "\n", "        ", "super", "(", "DNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# self.softmax = nn.Softmax(dim=1)", "\n", "self", ".", "model", "=", "model", "\n", "#         if cuda:", "\n", "self", ".", "mean", "=", "torch", ".", "tensor", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "cuda", "(", ")", "\n", "self", ".", "var", "=", "torch", ".", "tensor", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "pow", "(", "2", ")", ".", "cuda", "(", ")", "\n", "#         else:", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward": [[178, 183], ["torch.functional.batch_norm", "torch.functional.batch_norm", "torch_models.DNN.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "nn", ".", "functional", ".", "batch_norm", "(", "x", ",", "self", ".", "mean", ",", "self", ".", "var", ",", "momentum", "=", "0.0", ",", "eps", "=", "0.0", ")", "\n", "logits", "=", "self", ".", "model", "(", "x", ")", "\n", "# return self.softmax(logits)", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.loss": [[184, 197], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch_models.DNN.forward", "torch.max", "torch.max", "torch.max", "torch.max", "torch.masked_select", "torch.masked_select", "torch.masked_select", "torch.masked_select", "true_max[].clone().cpu", "torch.max", "torch.max", "torch.max", "torch.max", "second_max[].cpu", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "X.size", "range", "true_max[].clone", "X.size"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "loss", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "res", "=", "torch", ".", "zeros", "(", "X", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "probs", "=", "self", ".", "forward", "(", "X", ")", "\n", "true_max", ",", "preds", "=", "torch", ".", "max", "(", "probs", ",", "1", ")", "\n", "correct", "=", "(", "preds", "==", "Y", ")", ".", "to", "(", "torch", ".", "uint8", ")", ".", "cpu", "(", ")", "\n", "correct_ixs", "=", "torch", ".", "masked_select", "(", "torch", ".", "tensor", "(", "range", "(", "X", ".", "size", "(", ")", "[", "0", "]", ")", ",", "dtype", "=", "torch", ".", "long", ")", ",", "\n", "correct", ")", "\n", "true_max", "=", "true_max", "[", "correct_ixs", "]", ".", "clone", "(", ")", ".", "cpu", "(", ")", "\n", "probs", "[", ":", ",", "preds", "]", "=", "-", "1.0", "\n", "second_max", ",", "_", "=", "torch", ".", "max", "(", "probs", ",", "1", ")", "\n", "second_max", "=", "second_max", "[", "correct_ixs", "]", ".", "cpu", "(", ")", "\n", "res", "[", "correct_ixs", "]", "=", "true_max", "-", "second_max", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.accuracy": [[198, 211], ["zip", "numpy.mean", "torch_models.DNN.forward", "torch.max", "torch.max", "torch.max", "torch.max", "torch_models.DNN.forward", "torch.max", "torch.max", "torch.max", "torch.max", "accs.append", "x.unsqueeze", "y.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "accuracy", "(", "self", ",", "X", ",", "Y", ",", "batch", "=", "False", ")", ":", "\n", "        ", "if", "batch", ":", "\n", "            ", "accs", "=", "[", "]", "\n", "for", "x", ",", "y", "in", "zip", "(", "X", ",", "Y", ")", ":", "\n", "                ", "out", "=", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "out", ",", "1", ")", "\n", "accs", ".", "append", "(", "(", "preds", "==", "y", ".", "unsqueeze", "(", "0", ")", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "item", "(", ")", ")", "\n", "", "res", "=", "np", ".", "mean", "(", "accs", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "forward", "(", "X", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "out", ",", "1", ")", "\n", "res", "=", "(", "preds", "==", "Y", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.loss_single": [[212, 229], ["torch_models.DNN.forward", "torch_models.DNN.clone", "torch.max", "torch.max", "torch.max", "torch.max", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid", "torch.ReLU.", "torch.min", "torch.min", "torch.min", "torch.min", "torch.Sigmoid.", "y.item", "y.item", "second_max_ix.item"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.forward"], ["", "def", "loss_single", "(", "self", ",", "x", ",", "v", ",", "y", ",", "noise_budget", ")", ":", "\n", "# probs = self.forward(x + v)", "\n", "# # true_max, max_ix = torch.max(probs, 1)", "\n", "# probs2 = probs.clone()", "\n", "# probs2[0, y.item()] = -1.0", "\n", "# _, second_max_ix = torch.max(probs2, 1)", "\n", "# relu = nn.ReLU()", "\n", "# return relu(probs[0, y.item()] - probs[0, second_max_ix.item()])", "\n", "        ", "logits", "=", "self", ".", "forward", "(", "x", "+", "v", ")", "\n", "logits2", "=", "logits", ".", "clone", "(", ")", "\n", "logits2", "[", "0", ",", "y", ".", "item", "(", ")", "]", "=", "torch", ".", "min", "(", "logits", ")", "-", "1.0", "\n", "_", ",", "second_max_ix", "=", "torch", ".", "max", "(", "logits2", ",", "1", ")", "\n", "diff", "=", "logits", "[", "0", ",", "y", ".", "item", "(", ")", "]", "-", "logits", "[", "0", ",", "second_max_ix", ".", "item", "(", ")", "]", "\n", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "loss", "=", "(", "sigmoid", "(", "diff", ")", "-", ".5", ")", "*", "2", "\n", "return", "relu", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.try_region_multi": [[10, 43], ["cvxopt.matrix", "cvxopt.matrix", "len", "range", "numpy.concatenate", "cvxopt.matrix", "cvxopt.matrix", "cvxopt.solvers.qp", "numpy.identity", "numpy.zeros", "list", "numpy.concatenate", "numpy.array", "numpy.array().reshape", "torch.tensor", "torch.tensor", "range", "cvxopt.matrix.append", "cvxopt.matrix.append", "numpy.array", "numpy.identity", "sum", "print", "torch_models.try_region_multi", "numpy.identity", "numpy.array", "models[].predict().item", "range", "numpy.dot", "models[].predict"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.try_region_multi", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.predict"], ["def", "try_region_multi", "(", "models", ",", "labels", ",", "x", ",", "delta", "=", "1e-5", ",", "num_labels", "=", "3", ")", ":", "\n", "    ", "dim", "=", "x", ".", "shape", "[", "0", "]", "\n", "P", "=", "matrix", "(", "np", ".", "identity", "(", "dim", ")", ")", "\n", "q", "=", "matrix", "(", "np", ".", "zeros", "(", "dim", ")", ")", "\n", "h", "=", "[", "]", "\n", "G", "=", "[", "]", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "for", "i", "in", "range", "(", "num_models", ")", ":", "\n", "        ", "others", "=", "list", "(", "range", "(", "num_labels", ")", ")", "\n", "target", "=", "labels", "[", "i", "]", "\n", "del", "others", "[", "target", "]", "\n", "target_w", ",", "target_b", "=", "models", "[", "i", "]", ".", "weights", "[", "target", "]", ",", "models", "[", "i", "]", ".", "bias", "[", "target", "]", "\n", "for", "j", "in", "others", ":", "\n", "            ", "other_w", ",", "other_b", "=", "models", "[", "i", "]", ".", "weights", "[", "j", "]", ",", "models", "[", "i", "]", ".", "bias", "[", "j", "]", "\n", "ineq_val", "=", "np", ".", "dot", "(", "target_w", "-", "other_w", ",", "x", ")", "+", "target_b", "-", "other_b", "-", "delta", "\n", "h", ".", "append", "(", "ineq_val", ")", "\n", "G", ".", "append", "(", "other_w", "-", "target_w", ")", "\n", "", "", "G", "=", "np", ".", "concatenate", "(", "[", "np", ".", "array", "(", "G", ")", ",", "-", "1", "*", "np", ".", "identity", "(", "dim", ")", ",", "np", ".", "identity", "(", "dim", ")", "]", ")", "\n", "h", "=", "matrix", "(", "np", ".", "concatenate", "(", "[", "h", ",", "x", ",", "1.0", "-", "x", "]", ")", ")", "# assumes inputs need to lie in [0,1]", "\n", "G", "=", "matrix", "(", "np", ".", "array", "(", "G", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "solvers", ".", "options", "[", "'show_progress'", "]", "=", "False", "\n", "sol", "=", "solvers", ".", "qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "\n", "if", "sol", "[", "'status'", "]", "==", "'optimal'", ":", "\n", "        ", "v", "=", "np", ".", "array", "(", "sol", "[", "'x'", "]", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "perturbed_x", "=", "torch", ".", "tensor", "(", "(", "x", "+", "v", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "is_desired_label", "=", "[", "models", "[", "i", "]", ".", "predict", "(", "perturbed_x", ")", ".", "item", "(", ")", "==", "labels", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "]", "\n", "if", "sum", "(", "is_desired_label", ")", "==", "num_models", ":", "\n", "            ", "return", "v", "\n", "", "else", ":", "\n", "            ", "print", "(", "'looped'", ")", "\n", "return", "try_region_multi", "(", "models", ",", "labels", ",", "x", ",", "delta", "*", "1.5", ",", "num_labels", ")", "\n", "", "", "else", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.load_models": [[231, 248], ["torchvision.models.resnet18().cuda().eval", "torchvision.models.resnet50().cuda().eval", "torchvision.models.vgg13().cuda().eval", "torchvision.models.vgg19_bn().cuda().eval", "torchvision.models.densenet161().cuda().eval", "torch_models.DNN", "torch_models.DNN", "torch_models.DNN", "torch_models.DNN", "torch_models.DNN", "torchvision.models.resnet18().cuda", "torchvision.models.resnet50().cuda", "torchvision.models.vgg13().cuda", "torchvision.models.vgg19_bn().cuda", "torchvision.models.densenet161().cuda", "torch.load", "torch.load", "os.listdir", "torch.load", "torch.load", "torchvision.models.resnet18", "torchvision.models.resnet50", "torchvision.models.vgg13", "torchvision.models.vgg19_bn", "torchvision.models.densenet161", "os.listdir"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["", "", "def", "load_models", "(", "exp_type", ")", ":", "\n", "\n", "    ", "if", "exp_type", "==", "'imagenet'", ":", "\n", "        ", "resnet18", "=", "torchvision", ".", "models", ".", "resnet18", "(", "pretrained", "=", "True", ")", ".", "cuda", "(", ")", ".", "eval", "(", ")", "\n", "resnet50", "=", "torchvision", ".", "models", ".", "resnet50", "(", "pretrained", "=", "True", ")", ".", "cuda", "(", ")", ".", "eval", "(", ")", "\n", "vgg13", "=", "torchvision", ".", "models", ".", "vgg13", "(", "pretrained", "=", "True", ")", ".", "cuda", "(", ")", ".", "eval", "(", ")", "\n", "vgg19", "=", "torchvision", ".", "models", ".", "vgg19_bn", "(", "pretrained", "=", "True", ")", ".", "cuda", "(", ")", ".", "eval", "(", ")", "\n", "densenet", "=", "torchvision", ".", "models", ".", "densenet161", "(", "pretrained", "=", "True", ")", ".", "cuda", "(", ")", ".", "eval", "(", ")", "\n", "models", "=", "[", "DNN", "(", "resnet18", ")", ",", "DNN", "(", "resnet50", ")", ",", "DNN", "(", "vgg13", ")", ",", "DNN", "(", "vgg19", ")", ",", "DNN", "(", "densenet", ")", "]", "\n", "\n", "", "elif", "exp_type", "==", "\"mnist_binary\"", ":", "\n", "        ", "models", "=", "[", "torch", ".", "load", "(", "'models/binary/'", "+", "model_file", ")", "for", "model_file", "in", "os", ".", "listdir", "(", "'models/binary/'", ")", "]", "\n", "\n", "", "elif", "exp_type", "==", "'mnist_multi'", ":", "\n", "        ", "models", "=", "[", "torch", ".", "load", "(", "'models/multi/'", "+", "model_file", ")", "for", "model_file", "in", "os", ".", "listdir", "(", "'models/multi/'", ")", "]", "\n", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.pgd": [[7, 62], ["type", "torch.zeros", "range", "len", "numpy.array", "x.size", "curr_noise_vector.cuda.cuda", "len", "torch.zeros", "torch.autograd.Variable", "zip", "total_loss.cuda.backward", "grad.norm", "model.distance().item", "var_noise_vector.cuda.cuda", "total_loss.cuda.cuda", "var_noise_vector.cuda.grad.data.zero_", "torch.norm", "range", "model.loss_single", "torch.clamp", "model.distance", "range"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.DNN.loss_single", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.distance"], ["def", "pgd", "(", "weights", ",", "models", ",", "x", ",", "y", ",", "noise_budget", ",", "iters", ",", "clip_min", "=", "0.0", ",", "clip_max", "=", "1.0", ",", "cuda", "=", "True", ")", ":", "\n", "\n", "    ", "model_type", "=", "type", "(", "models", "[", "0", "]", ")", "\n", "# we should only take into consideration models that we could feasibly trick", "\n", "if", "model_type", "is", "BinaryClassifier", "or", "model_type", "is", "MultiClassifier", ":", "\n", "        ", "num_models", "=", "len", "(", "models", ")", "\n", "distances", "=", "[", "model", ".", "distance", "(", "x", ")", ".", "item", "(", ")", "for", "model", "in", "models", "]", "\n", "models", "=", "[", "models", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", "\n", "weights", "=", "np", ".", "array", "(", "[", "weights", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", ")", "\n", "\n", "", "step_size", "=", "noise_budget", "/", "(", ".8", "*", "iters", ")", "\n", "\n", "# initialize the vector we will be optimizing", "\n", "curr_noise_vector", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", ")", ")", "\n", "\n", "if", "cuda", ":", "\n", "        ", "curr_noise_vector", "=", "curr_noise_vector", ".", "cuda", "(", ")", "\n", "\n", "# can't fool anything, so return 0", "\n", "", "if", "len", "(", "models", ")", "==", "0", ":", "\n", "        ", "return", "curr_noise_vector", "\n", "\n", "", "for", "i", "in", "range", "(", "iters", ")", ":", "\n", "# variables we will be using this iteration", "\n", "        ", "total_loss", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "var_noise_vector", "=", "torch", ".", "autograd", ".", "Variable", "(", "curr_noise_vector", ",", "requires_grad", "=", "True", ")", "\n", "if", "cuda", ":", "\n", "            ", "var_noise_vector", "=", "var_noise_vector", ".", "cuda", "(", ")", "\n", "total_loss", "=", "total_loss", ".", "cuda", "(", ")", "\n", "\n", "", "if", "var_noise_vector", ".", "grad", "is", "not", "None", ":", "\n", "                ", "var_noise_vector", ".", "grad", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "# compute weighted sum of losses", "\n", "", "for", "w", ",", "model", "in", "zip", "(", "weights", ",", "models", ")", ":", "\n", "            ", "loss", "=", "w", "*", "model", ".", "loss_single", "(", "x", ",", "var_noise_vector", ",", "y", ",", "noise_budget", ")", "\n", "total_loss", "+=", "loss", "\n", "\n", "", "total_loss", ".", "backward", "(", ")", "\n", "grad", "=", "var_noise_vector", ".", "grad", ".", "data", "\n", "# upd ate variables respecting norm and box contraints", "\n", "grad_norm", "=", "grad", ".", "norm", "(", "2", ")", "\n", "if", "grad_norm", ">", "0", ":", "\n", "\n", "            ", "curr_noise_vector", "+=", "-", "1", "*", "step_size", "*", "grad", "/", "grad_norm", "\n", "noise_norm", "=", "torch", ".", "norm", "(", "curr_noise_vector", ",", "p", "=", "2", ")", "\n", "\n", "if", "noise_norm", ">", "noise_budget", ":", "\n", "                ", "curr_noise_vector", "=", "noise_budget", "*", "curr_noise_vector", "/", "noise_norm", "\n", "\n", "", "curr_noise_vector", "=", "torch", ".", "clamp", "(", "x", "+", "curr_noise_vector", ",", "min", "=", "clip_min", ",", "max", "=", "clip_max", ")", "-", "x", "\n", "\n", "", "else", ":", "\n", "            ", "break", "\n", "", "", "return", "curr_noise_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.try_region_binary": [[64, 98], ["cvxopt.matrix", "cvxopt.matrix", "len", "range", "numpy.concatenate", "cvxopt.matrix", "cvxopt.matrix", "cvxopt.solvers.qp", "numpy.identity", "numpy.zeros", "cvxopt.matrix.append", "cvxopt.matrix.append", "numpy.concatenate", "numpy.array", "numpy.array().reshape", "torch.tensor", "numpy.array", "numpy.identity", "sum", "print", "attacks.try_region_binary", "numpy.identity", "numpy.array", "numpy.sign", "range", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.try_region_binary"], ["", "def", "try_region_binary", "(", "models", ",", "signs", ",", "x", ",", "delta", "=", "1e-5", ")", ":", "\n", "    ", "\"\"\"\n    models: list of LinearBinaryClassifiers\n    signs: list of signs (+1, -1) of length num_models\n    x: np array of shape dim (a single point)\n    returns: a vector in the region denoted by the signs vector\n    \"\"\"", "\n", "dim", "=", "x", ".", "shape", "[", "0", "]", "\n", "P", "=", "matrix", "(", "np", ".", "identity", "(", "dim", ")", ")", "\n", "q", "=", "matrix", "(", "np", ".", "zeros", "(", "dim", ")", ")", "\n", "h", "=", "[", "]", "\n", "G", "=", "[", "]", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "for", "i", "in", "range", "(", "num_models", ")", ":", "\n", "        ", "weights", ",", "bias", "=", "models", "[", "i", "]", ".", "weights", ",", "models", "[", "i", "]", ".", "bias", "\n", "ineq_val", "=", "-", "1.0", "*", "delta", "+", "signs", "[", "i", "]", "*", "(", "np", ".", "dot", "(", "weights", ",", "x", ")", "+", "bias", ")", "\n", "h", ".", "append", "(", "ineq_val", ")", "\n", "G", ".", "append", "(", "-", "1.0", "*", "signs", "[", "i", "]", "*", "weights", ")", "\n", "", "G", "=", "np", ".", "concatenate", "(", "[", "np", ".", "array", "(", "G", ")", ",", "-", "1", "*", "np", ".", "identity", "(", "dim", ")", ",", "np", ".", "identity", "(", "dim", ")", "]", ")", "\n", "h", "=", "matrix", "(", "np", ".", "concatenate", "(", "[", "h", ",", "x", ",", "1.0", "-", "x", "]", ")", ")", "# assumes inputs need to lie in [0,1]", "\n", "G", "=", "matrix", "(", "np", ".", "array", "(", "G", ",", "dtype", "=", "np", ".", "float64", ")", ")", "\n", "solvers", ".", "options", "[", "'show_progress'", "]", "=", "False", "\n", "sol", "=", "solvers", ".", "qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "\n", "if", "sol", "[", "'status'", "]", "==", "'optimal'", ":", "\n", "        ", "v", "=", "np", ".", "array", "(", "sol", "[", "'x'", "]", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "perturbed_x", "=", "torch", ".", "tensor", "(", "(", "x", "+", "v", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "is_desired_sign", "=", "[", "np", ".", "sign", "(", "models", "[", "i", "]", "(", "perturbed_x", ")", ".", "item", "(", ")", ")", "==", "signs", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "]", "\n", "if", "sum", "(", "is_desired_sign", ")", "==", "num_models", ":", "\n", "            ", "return", "v", "\n", "", "else", ":", "\n", "            ", "print", "(", "'looping'", ")", "\n", "return", "try_region_binary", "(", "models", ",", "signs", ",", "x", ",", "delta", "*", "1.5", ")", "\n", "", "", "else", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.distributional_oracle_binary": [[99, 139], ["len", "numpy.array", "len", "x.numpy().reshape.numpy().reshape", "y.item.item", "itertools.product", "sorted", "torch_models.BinaryClassifier", "model.distance().item", "torch.zeros().reshape", "numpy.equal", "numpy.dot", "signs_values.append", "set", "range", "x.numpy().reshape.numpy", "attacks.try_region_binary", "torch.tensor().reshape", "model.distance", "range", "torch.zeros", "numpy.ones", "numpy.linalg.norm", "min", "feasible_candidates.append", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.try_region_binary", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.distance"], ["", "", "def", "distributional_oracle_binary", "(", "distribution", ",", "model_arrays", ",", "x", ",", "y", ",", "noise_budget", ")", ":", "\n", "    ", "\"\"\"\n    computes the optimal perturbation for the point (x,y) using convex optimization\n    \"\"\"", "\n", "models", "=", "[", "BinaryClassifier", "(", "arrays", "[", "0", "]", ",", "arrays", "[", "1", "]", ")", "for", "arrays", "in", "model_arrays", "]", "\n", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "# we should only take into consideration models that we could feasibly trick", "\n", "distances", "=", "[", "model", ".", "distance", "(", "x", ")", ".", "item", "(", ")", "for", "model", "in", "models", "]", "\n", "feasible_models", "=", "[", "models", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", "\n", "distribution", "=", "np", ".", "array", "(", "[", "distribution", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", ")", "\n", "num_models", "=", "len", "(", "feasible_models", ")", "\n", "\n", "x", "=", "x", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "y", "=", "y", ".", "item", "(", ")", "\n", "\n", "# can't trick anything", "\n", "if", "num_models", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "x", ".", "shape", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n", "", "signs_values", "=", "[", "]", "\n", "for", "signs", "in", "product", "(", "[", "-", "1.0", ",", "1.0", "]", ",", "repeat", "=", "num_models", ")", ":", "# iterate over all possible regions", "\n", "        ", "is_misclassified", "=", "np", ".", "equal", "(", "-", "1.0", "*", "y", "*", "np", ".", "ones", "(", "num_models", ")", ",", "signs", ")", "# y = -1, or 1", "\n", "value", "=", "np", ".", "dot", "(", "is_misclassified", ",", "distribution", ")", "\n", "signs_values", ".", "append", "(", "(", "signs", ",", "value", ")", ")", "\n", "\n", "", "values", "=", "sorted", "(", "set", "(", "[", "value", "for", "signs", ",", "value", "in", "signs_values", "]", ")", ",", "reverse", "=", "True", ")", "\n", "for", "value", "in", "values", ":", "\n", "        ", "feasible_candidates", "=", "[", "]", "\n", "for", "signs", "in", "[", "sign", "for", "sign", ",", "val", "in", "signs_values", "if", "val", "==", "value", "]", ":", "\n", "            ", "v", "=", "try_region_binary", "(", "feasible_models", ",", "signs", ",", "x", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "v", ")", "\n", "if", "norm", "<=", "noise_budget", ":", "\n", "                    ", "feasible_candidates", ".", "append", "(", "(", "v", ",", "norm", ")", ")", "\n", "# amongst those with the max value, return the one with the minimum norm", "\n", "", "", "", "if", "feasible_candidates", ":", "\n", "# break out of the loop since we have already found the optimal answer", "\n", "            ", "v", "=", "min", "(", "feasible_candidates", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "[", "0", "]", "\n", "return", "torch", ".", "tensor", "(", "v", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.attacks.distributional_oracle_multi": [[175, 218], ["len", "numpy.array", "len", "x.numpy().reshape.numpy().reshape", "y.item.item", "len", "itertools.product", "sorted", "torch_models.MultiClassifier", "model.distance().item", "torch.zeros().reshape", "range", "numpy.dot", "labels_values.append", "set", "range", "x.numpy().reshape.numpy", "torch_models.try_region_multi", "torch.tensor().reshape", "model.distance", "range", "torch.zeros", "numpy.linalg.norm", "min", "numpy.array", "feasible_candidates.append", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.try_region_multi", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.torch_models.MultiClassifier.distance"], ["", "", "", "def", "distributional_oracle_multi", "(", "distribution", ",", "model_arrays", ",", "x", ",", "y", ",", "noise_budget", ",", "num_labels", "=", "3", ")", ":", "\n", "    ", "\"\"\"\n    computes the optimal perturbation for x under alpha and the given distribution\n    \"\"\"", "\n", "\n", "models", "=", "[", "MultiClassifier", "(", "arrays", "[", "0", "]", ",", "arrays", "[", "1", "]", ")", "for", "arrays", "in", "model_arrays", "]", "\n", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "# we should only take into consideration models that we could feasibly trick", "\n", "distances", "=", "[", "model", ".", "distance", "(", "x", ")", ".", "item", "(", ")", "for", "model", "in", "models", "]", "\n", "models", "=", "[", "models", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", "\n", "distribution", "=", "np", ".", "array", "(", "[", "distribution", "[", "i", "]", "for", "i", "in", "range", "(", "num_models", ")", "if", "distances", "[", "i", "]", "<", "noise_budget", "]", ")", "\n", "num_models", "=", "len", "(", "models", ")", "\n", "\n", "x", "=", "x", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ",", ")", "\n", "y", "=", "y", ".", "item", "(", ")", "\n", "\n", "# can't trick anything", "\n", "if", "num_models", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "x", ".", "shape", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n", "", "num_models", "=", "len", "(", "models", ")", "\n", "labels_values", "=", "[", "]", "\n", "for", "labels", "in", "product", "(", "range", "(", "num_labels", ")", ",", "repeat", "=", "num_models", ")", ":", "# iterate over all possible regions", "\n", "        ", "is_misclassified", "=", "(", "np", ".", "array", "(", "labels", ")", "!=", "y", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "value", "=", "np", ".", "dot", "(", "is_misclassified", ",", "distribution", ")", "\n", "labels_values", ".", "append", "(", "(", "labels", ",", "value", ")", ")", "\n", "\n", "", "values", "=", "sorted", "(", "set", "(", "[", "value", "for", "label", ",", "value", "in", "labels_values", "]", ")", ",", "reverse", "=", "True", ")", "\n", "\n", "for", "curr_value", "in", "values", ":", "\n", "        ", "feasible_candidates", "=", "[", "]", "\n", "for", "labels", "in", "[", "labels", "for", "labels", ",", "val", "in", "labels_values", "if", "val", "==", "curr_value", "]", ":", "\n", "            ", "v", "=", "try_region_multi", "(", "models", ",", "labels", ",", "x", ",", "num_labels", "=", "num_labels", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "norm", "=", "np", ".", "linalg", ".", "norm", "(", "v", ")", "\n", "if", "norm", "<=", "noise_budget", ":", "\n", "                    ", "feasible_candidates", ".", "append", "(", "(", "v", ",", "norm", ")", ")", "\n", "# amongst those with the max value, return the one with the minimum norm", "\n", "", "", "", "if", "feasible_candidates", ":", "\n", "# break out of the loop since we have already found the optimal answer", "\n", "            ", "v", "=", "min", "(", "feasible_candidates", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "[", "0", "]", "\n", "return", "torch", ".", "tensor", "(", "v", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.None.imagenet_data_setup.pil_loader": [[16, 21], ["open", "PIL.Image.open", "Image.open.convert"], "function", ["None"], ["def", "pil_loader", "(", "path", ")", ":", "\n", "# open path as file to avoid ResourceWarning (https://github.com/python-pillow/Pillow/issues/835)", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "img", "=", "Image", ".", "open", "(", "f", ")", "\n", "return", "img", ".", "convert", "(", "'RGB'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_loss": [[27, 50], ["warnings.warn", "cleverhans.compat.softmax_cross_entropy_with_logits", "cleverhans.compat.reduce_mean"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["def", "model_loss", "(", "y", ",", "model", ",", "mean", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  Define loss of TF graph\n  :param y: correct labels\n  :param model: output of the model\n  :param mean: boolean indicating whether should return mean of loss\n               or vector of losses for each input of the batch\n  :return: return mean of loss if True, otherwise return vector with per\n           sample loss\n  \"\"\"", "\n", "warnings", ".", "warn", "(", "\"This function is deprecated and will be removed on or after\"", "\n", "\" 2019-04-05. Switch to cleverhans.train.train.\"", ")", "\n", "op", "=", "model", ".", "op", "\n", "if", "op", ".", "type", "==", "\"Softmax\"", ":", "\n", "    ", "logits", ",", "=", "op", ".", "inputs", "\n", "", "else", ":", "\n", "    ", "logits", "=", "model", "\n", "\n", "", "out", "=", "softmax_cross_entropy_with_logits", "(", "logits", "=", "logits", ",", "labels", "=", "y", ")", "\n", "\n", "if", "mean", ":", "\n", "    ", "out", "=", "reduce_mean", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.initialize_uninitialized_global_variables": [[52, 73], ["tensorflow.global_variables", "sess.run", "len", "tensorflow.is_variable_initialized", "sess.run", "zip", "tensorflow.variables_initializer"], "function", ["None"], ["", "def", "initialize_uninitialized_global_variables", "(", "sess", ")", ":", "\n", "  ", "\"\"\"\n  Only initializes the variables of a TensorFlow session that were not\n  already initialized.\n  :param sess: the TensorFlow session\n  :return:\n  \"\"\"", "\n", "# List all global variables", "\n", "global_vars", "=", "tf", ".", "global_variables", "(", ")", "\n", "\n", "# Find initialized status for all variables", "\n", "is_var_init", "=", "[", "tf", ".", "is_variable_initialized", "(", "var", ")", "for", "var", "in", "global_vars", "]", "\n", "is_initialized", "=", "sess", ".", "run", "(", "is_var_init", ")", "\n", "\n", "# List all variables that were not initialized previously", "\n", "not_initialized_vars", "=", "[", "var", "for", "(", "var", ",", "init", ")", "in", "\n", "zip", "(", "global_vars", ",", "is_initialized", ")", "if", "not", "init", "]", "\n", "\n", "# Initialize all uninitialized variables found, if any", "\n", "if", "len", "(", "not_initialized_vars", ")", ":", "\n", "    ", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "not_initialized_vars", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.train": [[75, 193], ["warnings.warn", "cleverhans.utils._ArgsWrapper", "loss.fprop", "numpy.random.RandomState", "tensorflow.train.AdamOptimizer", "tensorflow.control_dependencies", "tf.train.AdamOptimizer.minimize", "sess.as_default", "hasattr", "six.moves.xrange", "isinstance", "ValueError", "tensorflow.get_collection", "warnings.warn", "sess.run", "int", "list", "np.random.RandomState.shuffle", "time.time", "range", "time.time", "_logger.info", "os.path.join", "tensorflow.train.Saver", "tf.train.Saver.save", "_logger.info", "_logger.info", "tensorflow.global_variables_initializer().run", "utils_tf.initialize_uninitialized_global_variables", "tensorflow.initialize_all_variables", "math.ceil", "len", "range", "cleverhans.utils.batch_indices", "optimizer.minimize.run", "len", "evaluate", "len", "len", "feed_dict.update", "str", "tensorflow.global_variables_initializer", "float", "str", "len", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.initialize_uninitialized_global_variables", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.batch_indices"], ["", "", "def", "train", "(", "sess", ",", "loss", ",", "x", ",", "y", ",", "X_train", ",", "Y_train", ",", "save", "=", "False", ",", "\n", "init_all", "=", "False", ",", "evaluate", "=", "None", ",", "feed", "=", "None", ",", "args", "=", "None", ",", "\n", "rng", "=", "None", ",", "var_list", "=", "None", ",", "fprop_args", "=", "None", ",", "optimizer", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Train a TF graph.\n  This function is deprecated. Prefer cleverhans.train.train when possible.\n  cleverhans.train.train supports multiple GPUs but this function is still\n  needed to support legacy models that do not support calling fprop more\n  than once.\n\n  :param sess: TF session to use when training the graph\n  :param loss: tensor, the model training loss.\n  :param x: input placeholder\n  :param y: output placeholder (for labels)\n  :param X_train: numpy array with training inputs\n  :param Y_train: numpy array with training outputs\n  :param save: boolean controlling the save operation\n  :param init_all: (boolean) If set to true, all TF variables in the session\n                   are (re)initialized, otherwise only previously\n                   uninitialized variables are initialized before training.\n  :param evaluate: function that is run after each training iteration\n                   (typically to display the test/validation accuracy).\n  :param feed: An optional dictionary that is appended to the feeding\n               dictionary before the session runs. Can be used to feed\n               the learning phase of a Keras model for instance.\n  :param args: dict or argparse `Namespace` object.\n               Should contain `nb_epochs`, `learning_rate`,\n               `batch_size`\n               If save is True, should also contain 'train_dir'\n               and 'filename'\n  :param rng: Instance of numpy.random.RandomState\n  :param var_list: Optional list of parameters to train.\n  :param fprop_args: dict, extra arguments to pass to fprop (loss and model).\n  :param optimizer: Optimizer to be used for training\n  :return: True if model trained\n  \"\"\"", "\n", "warnings", ".", "warn", "(", "\"This function is deprecated and will be removed on or after\"", "\n", "\" 2019-04-05. Switch to cleverhans.train.train.\"", ")", "\n", "\n", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "fprop_args", "=", "fprop_args", "or", "{", "}", "\n", "\n", "# Check that necessary arguments were given (see doc above)", "\n", "assert", "args", ".", "nb_epochs", ",", "\"Number of epochs was not given in args dict\"", "\n", "if", "optimizer", "is", "None", ":", "\n", "    ", "assert", "args", ".", "learning_rate", "is", "not", "None", ",", "(", "\"Learning rate was not given \"", "\n", "\"in args dict\"", ")", "\n", "", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "\n", "if", "save", ":", "\n", "    ", "assert", "args", ".", "train_dir", ",", "\"Directory for save was not given in args dict\"", "\n", "assert", "args", ".", "filename", ",", "\"Filename for save was not given in args dict\"", "\n", "\n", "", "if", "rng", "is", "None", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "# Define optimizer", "\n", "", "loss_value", "=", "loss", ".", "fprop", "(", "x", ",", "y", ",", "**", "fprop_args", ")", "\n", "if", "optimizer", "is", "None", ":", "\n", "    ", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "args", ".", "learning_rate", ")", "\n", "", "else", ":", "\n", "    ", "if", "not", "isinstance", "(", "optimizer", ",", "tf", ".", "train", ".", "Optimizer", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\"optimizer object must be from a child class of \"", "\n", "\"tf.train.Optimizer\"", ")", "\n", "# Trigger update operations within the default graph (such as batch_norm).", "\n", "", "", "with", "tf", ".", "control_dependencies", "(", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "UPDATE_OPS", ")", ")", ":", "\n", "    ", "train_step", "=", "optimizer", ".", "minimize", "(", "loss_value", ",", "var_list", "=", "var_list", ")", "\n", "\n", "", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "if", "hasattr", "(", "tf", ",", "\"global_variables_initializer\"", ")", ":", "\n", "      ", "if", "init_all", ":", "\n", "        ", "tf", ".", "global_variables_initializer", "(", ")", ".", "run", "(", ")", "\n", "", "else", ":", "\n", "        ", "initialize_uninitialized_global_variables", "(", "sess", ")", "\n", "", "", "else", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Update your copy of tensorflow; future versions of \"", "\n", "\"CleverHans may drop support for this version.\"", ")", "\n", "sess", ".", "run", "(", "tf", ".", "initialize_all_variables", "(", ")", ")", "\n", "\n", "", "for", "epoch", "in", "xrange", "(", "args", ".", "nb_epochs", ")", ":", "\n", "# Compute number of batches", "\n", "      ", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "len", "(", "X_train", ")", ")", "/", "args", ".", "batch_size", ")", ")", "\n", "assert", "nb_batches", "*", "args", ".", "batch_size", ">=", "len", "(", "X_train", ")", "\n", "\n", "# Indices to shuffle training set", "\n", "index_shuf", "=", "list", "(", "range", "(", "len", "(", "X_train", ")", ")", ")", "\n", "rng", ".", "shuffle", "(", "index_shuf", ")", "\n", "\n", "prev", "=", "time", ".", "time", "(", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "\n", "# Compute batch start and end indices", "\n", "        ", "start", ",", "end", "=", "batch_indices", "(", "\n", "batch", ",", "len", "(", "X_train", ")", ",", "args", ".", "batch_size", ")", "\n", "\n", "# Perform one training step", "\n", "feed_dict", "=", "{", "x", ":", "X_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", ",", "\n", "y", ":", "Y_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "          ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "train_step", ".", "run", "(", "feed_dict", "=", "feed_dict", ")", "\n", "", "assert", "end", ">=", "len", "(", "X_train", ")", "# Check that all examples were used", "\n", "cur", "=", "time", ".", "time", "(", ")", "\n", "_logger", ".", "info", "(", "\"Epoch \"", "+", "str", "(", "epoch", ")", "+", "\" took \"", "+", "\n", "str", "(", "cur", "-", "prev", ")", "+", "\" seconds\"", ")", "\n", "if", "evaluate", "is", "not", "None", ":", "\n", "        ", "evaluate", "(", ")", "\n", "\n", "", "", "if", "save", ":", "\n", "      ", "save_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "train_dir", ",", "args", ".", "filename", ")", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "saver", ".", "save", "(", "sess", ",", "save_path", ")", "\n", "_logger", ".", "info", "(", "\"Completed model training and saved at: \"", "+", "\n", "str", "(", "save_path", ")", ")", "\n", "", "else", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Completed model training.\"", ")", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_eval": [[195, 269], ["cleverhans.utils._ArgsWrapper", "ValueError", "tensorflow.equal", "sess.as_default", "int", "numpy.zeros", "numpy.zeros", "range", "len", "tensorflow.argmax", "tensorflow.argmax", "math.ceil", "len", "min", "tf.equal.eval", "cur_corr_preds[].sum", "len", "_logger.debug", "len", "feed_dict.update", "float", "len", "str"], "function", ["None"], ["", "def", "model_eval", "(", "sess", ",", "x", ",", "y", ",", "predictions", ",", "X_test", "=", "None", ",", "Y_test", "=", "None", ",", "\n", "feed", "=", "None", ",", "args", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Compute the accuracy of a TF model on some data\n  :param sess: TF session to use\n  :param x: input placeholder\n  :param y: output placeholder (for labels)\n  :param predictions: model output predictions\n  :param X_test: numpy array with training inputs\n  :param Y_test: numpy array with training outputs\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param args: dict or argparse `Namespace` object.\n               Should contain `batch_size`\n  :return: a float with the accuracy value\n  \"\"\"", "\n", "global", "_model_eval_cache", "\n", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "\n", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "if", "X_test", "is", "None", "or", "Y_test", "is", "None", ":", "\n", "    ", "raise", "ValueError", "(", "\"X_test argument and Y_test argument \"", "\n", "\"must be supplied.\"", ")", "\n", "\n", "# Define accuracy symbolically", "\n", "", "key", "=", "(", "y", ",", "predictions", ")", "\n", "if", "key", "in", "_model_eval_cache", ":", "\n", "    ", "correct_preds", "=", "_model_eval_cache", "[", "key", "]", "\n", "", "else", ":", "\n", "    ", "correct_preds", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "y", ",", "axis", "=", "-", "1", ")", ",", "\n", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", ")", "\n", "_model_eval_cache", "[", "key", "]", "=", "correct_preds", "\n", "\n", "# Init result var", "\n", "", "accuracy", "=", "0.0", "\n", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "# Compute number of batches", "\n", "    ", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "len", "(", "X_test", ")", ")", "/", "args", ".", "batch_size", ")", ")", "\n", "assert", "nb_batches", "*", "args", ".", "batch_size", ">=", "len", "(", "X_test", ")", "\n", "\n", "X_cur", "=", "np", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", ")", "+", "X_test", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "X_test", ".", "dtype", ")", "\n", "Y_cur", "=", "np", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", ")", "+", "Y_test", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "Y_test", ".", "dtype", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "      ", "if", "batch", "%", "100", "==", "0", "and", "batch", ">", "0", ":", "\n", "        ", "_logger", ".", "debug", "(", "\"Batch \"", "+", "str", "(", "batch", ")", ")", "\n", "\n", "# Must not use the `batch_indices` function here, because it", "\n", "# repeats some examples.", "\n", "# It's acceptable to repeat during training, but not eval.", "\n", "", "start", "=", "batch", "*", "args", ".", "batch_size", "\n", "end", "=", "min", "(", "len", "(", "X_test", ")", ",", "start", "+", "args", ".", "batch_size", ")", "\n", "\n", "# The last batch may be smaller than all others. This should not", "\n", "# affect the accuarcy disproportionately.", "\n", "cur_batch_size", "=", "end", "-", "start", "\n", "X_cur", "[", ":", "cur_batch_size", "]", "=", "X_test", "[", "start", ":", "end", "]", "\n", "Y_cur", "[", ":", "cur_batch_size", "]", "=", "Y_test", "[", "start", ":", "end", "]", "\n", "feed_dict", "=", "{", "x", ":", "X_cur", ",", "y", ":", "Y_cur", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "        ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "cur_corr_preds", "=", "correct_preds", ".", "eval", "(", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "accuracy", "+=", "cur_corr_preds", "[", ":", "cur_batch_size", "]", ".", "sum", "(", ")", "\n", "\n", "", "assert", "end", ">=", "len", "(", "X_test", ")", "\n", "\n", "# Divide by number of examples to get final value", "\n", "accuracy", "/=", "len", "(", "X_test", ")", "\n", "\n", "", "return", "accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.tf_model_load": [[273, 289], ["sess.as_default", "tensorflow.train.Saver", "tf.train.Saver.restore", "ValueError"], "function", ["None"], ["def", "tf_model_load", "(", "sess", ",", "file_path", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n\n  :param sess: the session object to restore\n  :param file_path: path to the restored session, if None is\n                    taken from FLAGS.train_dir and FLAGS.filename\n  :return:\n  \"\"\"", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "if", "file_path", "is", "None", ":", "\n", "      ", "error", "=", "'file_path argument is missing.'", "\n", "raise", "ValueError", "(", "error", ")", "\n", "", "saver", ".", "restore", "(", "sess", ",", "file_path", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.batch_eval": [[291, 298], ["warnings.warn", "new_batch_eval"], "function", ["None"], ["", "def", "batch_eval", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# Inside function to avoid circular import", "\n", "  ", "from", "cleverhans", ".", "evaluation", "import", "batch_eval", "as", "new_batch_eval", "\n", "warnings", ".", "warn", "(", "\"batch_eval has moved to cleverhans.evaluation. \"", "\n", "\"batch_eval will be removed from utils_tf on or after \"", "\n", "\"2019-03-09.\"", ")", "\n", "return", "new_batch_eval", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_argmax": [[300, 321], ["sess.run", "feed_dict.update", "numpy.argmax", "numpy.argmax"], "function", ["None"], ["", "def", "model_argmax", "(", "sess", ",", "x", ",", "predictions", ",", "samples", ",", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Helper function that computes the current class prediction\n  :param sess: TF session\n  :param x: the input placeholder\n  :param predictions: the model's symbolic output\n  :param samples: numpy array with input samples (dims must match x)\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :return: the argmax output of predictions, i.e. the current predicted class\n  \"\"\"", "\n", "feed_dict", "=", "{", "x", ":", "samples", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "    ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "probabilities", "=", "sess", ".", "run", "(", "predictions", ",", "feed_dict", ")", "\n", "\n", "if", "samples", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "    ", "return", "np", ".", "argmax", "(", "probabilities", ")", "\n", "", "else", ":", "\n", "    ", "return", "np", ".", "argmax", "(", "probabilities", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.l2_batch_normalize": [[323, 338], ["tensorflow.name_scope", "tensorflow.shape", "tensorflow.contrib.layers.flatten", "cleverhans.compat.reduce_sum", "tensorflow.rsqrt", "tensorflow.multiply", "tensorflow.reshape", "cleverhans.compat.reduce_max", "tensorflow.square", "tensorflow.abs", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["", "", "def", "l2_batch_normalize", "(", "x", ",", "epsilon", "=", "1e-12", ",", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Helper function to normalize a batch of vectors.\n  :param x: the input placeholder\n  :param epsilon: stabilizes division\n  :return: the batch of l2 normalized vector\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "scope", ",", "\"l2_batch_normalize\"", ")", "as", "name_scope", ":", "\n", "    ", "x_shape", "=", "tf", ".", "shape", "(", "x", ")", "\n", "x", "=", "tf", ".", "contrib", ".", "layers", ".", "flatten", "(", "x", ")", "\n", "x", "/=", "(", "epsilon", "+", "reduce_max", "(", "tf", ".", "abs", "(", "x", ")", ",", "1", ",", "keepdims", "=", "True", ")", ")", "\n", "square_sum", "=", "reduce_sum", "(", "tf", ".", "square", "(", "x", ")", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "x_inv_norm", "=", "tf", ".", "rsqrt", "(", "np", ".", "sqrt", "(", "epsilon", ")", "+", "square_sum", ")", "\n", "x_norm", "=", "tf", ".", "multiply", "(", "x", ",", "x_inv_norm", ")", "\n", "return", "tf", ".", "reshape", "(", "x_norm", ",", "x_shape", ",", "name_scope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.kl_with_logits": [[340, 352], ["tensorflow.name_scope", "tensorflow.nn.softmax", "tensorflow.nn.log_softmax", "tensorflow.nn.log_softmax", "cleverhans.compat.reduce_mean", "tensorflow.losses.add_loss", "cleverhans.compat.reduce_sum"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "", "def", "kl_with_logits", "(", "p_logits", ",", "q_logits", ",", "scope", "=", "None", ",", "\n", "loss_collection", "=", "tf", ".", "GraphKeys", ".", "REGULARIZATION_LOSSES", ")", ":", "\n", "  ", "\"\"\"Helper function to compute kl-divergence KL(p || q)\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "scope", ",", "\"kl_divergence\"", ")", "as", "name", ":", "\n", "    ", "p", "=", "tf", ".", "nn", ".", "softmax", "(", "p_logits", ")", "\n", "p_log", "=", "tf", ".", "nn", ".", "log_softmax", "(", "p_logits", ")", "\n", "q_log", "=", "tf", ".", "nn", ".", "log_softmax", "(", "q_logits", ")", "\n", "loss", "=", "reduce_mean", "(", "reduce_sum", "(", "p", "*", "(", "p_log", "-", "q_log", ")", ",", "axis", "=", "1", ")", ",", "\n", "name", "=", "name", ")", "\n", "tf", ".", "losses", ".", "add_loss", "(", "loss", ",", "loss_collection", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta": [[354, 389], ["list", "ValueError", "six.moves.xrange", "utils_tf.clip_by_value", "tensorflow.minimum", "len", "NotImplementedError", "tensorflow.maximum", "utils_tf.div", "clip_by_value.get_shape", "cleverhans.compat.reduce_sum", "tensorflow.sqrt", "tensorflow.abs", "tensorflow.maximum", "cleverhans.compat.reduce_sum", "tensorflow.square"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.div", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "", "def", "clip_eta", "(", "eta", ",", "ord", ",", "eps", ")", ":", "\n", "  ", "\"\"\"\n  Helper function to clip the perturbation to epsilon norm ball.\n  :param eta: A tensor with the current perturbation.\n  :param ord: Order of the norm (mimics Numpy).\n              Possible values: np.inf, 1 or 2.\n  :param eps: Epsilon, bound of the perturbation.\n  \"\"\"", "\n", "\n", "# Clipping perturbation eta to self.ord norm ball", "\n", "if", "ord", "not", "in", "[", "np", ".", "inf", ",", "1", ",", "2", "]", ":", "\n", "    ", "raise", "ValueError", "(", "'ord must be np.inf, 1, or 2.'", ")", "\n", "", "reduc_ind", "=", "list", "(", "xrange", "(", "1", ",", "len", "(", "eta", ".", "get_shape", "(", ")", ")", ")", ")", "\n", "avoid_zero_div", "=", "1e-12", "\n", "if", "ord", "==", "np", ".", "inf", ":", "\n", "    ", "eta", "=", "clip_by_value", "(", "eta", ",", "-", "eps", ",", "eps", ")", "\n", "", "else", ":", "\n", "    ", "if", "ord", "==", "1", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"The expression below is not the correct way\"", "\n", "\" to project onto the L1 norm ball.\"", ")", "\n", "norm", "=", "tf", ".", "maximum", "(", "avoid_zero_div", ",", "\n", "reduce_sum", "(", "tf", ".", "abs", "(", "eta", ")", ",", "\n", "reduc_ind", ",", "keepdims", "=", "True", ")", ")", "\n", "", "elif", "ord", "==", "2", ":", "\n", "# avoid_zero_div must go inside sqrt to avoid a divide by zero", "\n", "# in the gradient through this operation", "\n", "      ", "norm", "=", "tf", ".", "sqrt", "(", "tf", ".", "maximum", "(", "avoid_zero_div", ",", "\n", "reduce_sum", "(", "tf", ".", "square", "(", "eta", ")", ",", "\n", "reduc_ind", ",", "\n", "keepdims", "=", "True", ")", ")", ")", "\n", "# We must *clip* to within the norm ball, not *normalize* onto the", "\n", "# surface of the ball", "\n", "", "factor", "=", "tf", ".", "minimum", "(", "1.", ",", "div", "(", "eps", ",", "norm", ")", ")", "\n", "eta", "=", "eta", "*", "factor", "\n", "", "return", "eta", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_train": [[391, 496], ["warnings.warn", "cleverhans.utils._ArgsWrapper", "utils_tf.model_loss", "tensorflow.train.AdamOptimizer", "train_step.minimize.minimize", "numpy.random.RandomState", "sess.as_default", "hasattr", "six.moves.xrange", "warnings.warn", "sess.run", "int", "list", "np.random.RandomState.shuffle", "time.time", "range", "time.time", "_logger.info", "os.path.join", "tensorflow.train.Saver", "tf.train.Saver.save", "_logger.info", "_logger.info", "utils_tf.model_loss", "tensorflow.global_variables_initializer().run", "utils_tf.initialize_uninitialized_global_variables", "tensorflow.initialize_all_variables", "math.ceil", "len", "range", "cleverhans.utils.batch_indices", "train_step.minimize.run", "len", "evaluate", "len", "len", "feed_dict.update", "str", "tensorflow.global_variables_initializer", "float", "str", "len", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_loss", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.model_loss", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.initialize_uninitialized_global_variables", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.batch_indices"], ["", "def", "model_train", "(", "sess", ",", "x", ",", "y", ",", "predictions", ",", "X_train", ",", "Y_train", ",", "save", "=", "False", ",", "\n", "predictions_adv", "=", "None", ",", "init_all", "=", "True", ",", "evaluate", "=", "None", ",", "\n", "feed", "=", "None", ",", "args", "=", "None", ",", "rng", "=", "None", ",", "var_list", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Train a TF graph\n  :param sess: TF session to use when training the graph\n  :param x: input placeholder\n  :param y: output placeholder (for labels)\n  :param predictions: model output predictions\n  :param X_train: numpy array with training inputs\n  :param Y_train: numpy array with training outputs\n  :param save: boolean controlling the save operation\n  :param predictions_adv: if set with the adversarial example tensor,\n                          will run adversarial training\n  :param init_all: (boolean) If set to true, all TF variables in the session\n                   are (re)initialized, otherwise only previously\n                   uninitialized variables are initialized before training.\n  :param evaluate: function that is run after each training iteration\n                   (typically to display the test/validation accuracy).\n  :param feed: An optional dictionary that is appended to the feeding\n               dictionary before the session runs. Can be used to feed\n               the learning phase of a Keras model for instance.\n  :param args: dict or argparse `Namespace` object.\n               Should contain `nb_epochs`, `learning_rate`,\n               `batch_size`\n               If save is True, should also contain 'train_dir'\n               and 'filename'\n  :param rng: Instance of numpy.random.RandomState\n  :param var_list: Optional list of parameters to train.\n  :return: True if model trained\n  \"\"\"", "\n", "warnings", ".", "warn", "(", "\"This function is deprecated and will be removed on or after\"", "\n", "\" 2019-04-05. Switch to cleverhans.train.train.\"", ")", "\n", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "\n", "# Check that necessary arguments were given (see doc above)", "\n", "assert", "args", ".", "nb_epochs", ",", "\"Number of epochs was not given in args dict\"", "\n", "assert", "args", ".", "learning_rate", ",", "\"Learning rate was not given in args dict\"", "\n", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "\n", "if", "save", ":", "\n", "    ", "assert", "args", ".", "train_dir", ",", "\"Directory for save was not given in args dict\"", "\n", "assert", "args", ".", "filename", ",", "\"Filename for save was not given in args dict\"", "\n", "\n", "", "if", "rng", "is", "None", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "# Define loss", "\n", "", "loss", "=", "model_loss", "(", "y", ",", "predictions", ")", "\n", "if", "predictions_adv", "is", "not", "None", ":", "\n", "    ", "loss", "=", "(", "loss", "+", "model_loss", "(", "y", ",", "predictions_adv", ")", ")", "/", "2", "\n", "\n", "", "train_step", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "args", ".", "learning_rate", ")", "\n", "train_step", "=", "train_step", ".", "minimize", "(", "loss", ",", "var_list", "=", "var_list", ")", "\n", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "if", "hasattr", "(", "tf", ",", "\"global_variables_initializer\"", ")", ":", "\n", "      ", "if", "init_all", ":", "\n", "        ", "tf", ".", "global_variables_initializer", "(", ")", ".", "run", "(", ")", "\n", "", "else", ":", "\n", "        ", "initialize_uninitialized_global_variables", "(", "sess", ")", "\n", "", "", "else", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Update your copy of tensorflow; future versions of \"", "\n", "\"CleverHans may drop support for this version.\"", ")", "\n", "sess", ".", "run", "(", "tf", ".", "initialize_all_variables", "(", ")", ")", "\n", "\n", "", "for", "epoch", "in", "xrange", "(", "args", ".", "nb_epochs", ")", ":", "\n", "# Compute number of batches", "\n", "      ", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "len", "(", "X_train", ")", ")", "/", "args", ".", "batch_size", ")", ")", "\n", "assert", "nb_batches", "*", "args", ".", "batch_size", ">=", "len", "(", "X_train", ")", "\n", "\n", "# Indices to shuffle training set", "\n", "index_shuf", "=", "list", "(", "range", "(", "len", "(", "X_train", ")", ")", ")", "\n", "rng", ".", "shuffle", "(", "index_shuf", ")", "\n", "\n", "prev", "=", "time", ".", "time", "(", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "\n", "# Compute batch start and end indices", "\n", "        ", "start", ",", "end", "=", "batch_indices", "(", "\n", "batch", ",", "len", "(", "X_train", ")", ",", "args", ".", "batch_size", ")", "\n", "\n", "# Perform one training step", "\n", "feed_dict", "=", "{", "x", ":", "X_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", ",", "\n", "y", ":", "Y_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "          ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "train_step", ".", "run", "(", "feed_dict", "=", "feed_dict", ")", "\n", "", "assert", "end", ">=", "len", "(", "X_train", ")", "# Check that all examples were used", "\n", "cur", "=", "time", ".", "time", "(", ")", "\n", "_logger", ".", "info", "(", "\"Epoch \"", "+", "str", "(", "epoch", ")", "+", "\" took \"", "+", "\n", "str", "(", "cur", "-", "prev", ")", "+", "\" seconds\"", ")", "\n", "if", "evaluate", "is", "not", "None", ":", "\n", "        ", "evaluate", "(", ")", "\n", "\n", "", "", "if", "save", ":", "\n", "      ", "save_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "train_dir", ",", "args", ".", "filename", ")", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "saver", ".", "save", "(", "sess", ",", "save_path", ")", "\n", "_logger", ".", "info", "(", "\"Completed model training and saved at: \"", "+", "\n", "str", "(", "save_path", ")", ")", "\n", "", "else", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Completed model training.\"", ")", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.infer_devices": [[498, 520], ["utils_tf.get_available_gpus", "len", "warnings.warn", "len", "isinstance", "type"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.get_available_gpus"], ["", "def", "infer_devices", "(", "devices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Returns the list of devices that multi-replica code should use.\n  :param devices: list of string device names, e.g. [\"/GPU:0\"]\n      If the user specifies this, `infer_devices` checks that it is\n      valid, and then uses this user-specified list.\n      If the user does not specify this, infer_devices uses:\n          - All available GPUs, if there are any\n          - CPU otherwise\n  \"\"\"", "\n", "if", "devices", "is", "None", ":", "\n", "    ", "devices", "=", "get_available_gpus", "(", ")", "\n", "if", "len", "(", "devices", ")", "==", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"No GPUS, running on CPU\"", ")", "\n", "# Set device to empy string, tf will figure out whether to use", "\n", "# XLA or not, etc., automatically", "\n", "devices", "=", "[", "\"\"", "]", "\n", "", "", "else", ":", "\n", "    ", "assert", "len", "(", "devices", ")", ">", "0", "\n", "for", "device", "in", "devices", ":", "\n", "      ", "assert", "isinstance", "(", "device", ",", "six", ".", "string_types", ")", ",", "type", "(", "device", ")", "\n", "", "", "return", "devices", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.get_available_gpus": [[522, 528], ["cleverhans.compat.device_lib.list_local_devices"], "function", ["None"], ["", "def", "get_available_gpus", "(", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of string names of all available GPUs\n  \"\"\"", "\n", "local_device_protos", "=", "device_lib", ".", "list_local_devices", "(", ")", "\n", "return", "[", "x", ".", "name", "for", "x", "in", "local_device_protos", "if", "x", ".", "device_type", "==", "'GPU'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.silence": [[530, 535], ["None"], "function", ["None"], ["", "def", "silence", "(", ")", ":", "\n", "  ", "\"\"\"\n  Silences tensorflaw's default printed messages\n  \"\"\"", "\n", "os", ".", "environ", "[", "'TF_CPP_MIN_LOG_LEVEL'", "]", "=", "'3'", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value": [[536, 551], ["utils_tf.clip_by_value.cast_clip"], "function", ["None"], ["", "def", "clip_by_value", "(", "t", ",", "clip_value_min", ",", "clip_value_max", ",", "name", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  A wrapper for clip_by_value that casts the clipping range if needed.\n  \"\"\"", "\n", "def", "cast_clip", "(", "clip", ")", ":", "\n", "    ", "if", "t", ".", "dtype", "in", "(", "tf", ".", "float32", ",", "tf", ".", "float64", ")", ":", "\n", "      ", "if", "hasattr", "(", "clip", ",", "'dtype'", ")", ":", "\n", "        ", "if", "clip", ".", "dtype", "!=", "t", ".", "dtype", ":", "\n", "          ", "return", "tf", ".", "cast", "(", "clip", ",", "t", ".", "dtype", ")", "\n", "", "", "", "return", "clip", "\n", "\n", "", "clip_value_min", "=", "cast_clip", "(", "clip_value_min", ")", "\n", "clip_value_max", "=", "cast_clip", "(", "clip_value_max", ")", "\n", "\n", "return", "tf", ".", "clip_by_value", "(", "t", ",", "clip_value_min", ",", "clip_value_max", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.mul": [[552, 560], ["utils_tf.op_with_scalar_cast"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.op_with_scalar_cast"], ["", "def", "mul", "(", "a", ",", "b", ")", ":", "\n", "  ", "\"\"\"\n  A wrapper around tf multiplication that does more automatic casting of\n  the input.\n  \"\"\"", "\n", "def", "multiply", "(", "a", ",", "b", ")", ":", "\n", "    ", "return", "a", "*", "b", "\n", "", "return", "op_with_scalar_cast", "(", "a", ",", "b", ",", "multiply", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.div": [[561, 569], ["utils_tf.op_with_scalar_cast"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.op_with_scalar_cast"], ["", "def", "div", "(", "a", ",", "b", ")", ":", "\n", "  ", "\"\"\"\n  A wrapper around tf division that does more automatic casting of\n  the input.\n  \"\"\"", "\n", "def", "divide", "(", "a", ",", "b", ")", ":", "\n", "    ", "return", "a", "/", "b", "\n", "", "return", "op_with_scalar_cast", "(", "a", ",", "b", ",", "divide", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.op_with_scalar_cast": [[570, 607], ["utils_tf.op_with_scalar_cast.is_scalar"], "function", ["None"], ["", "def", "op_with_scalar_cast", "(", "a", ",", "b", ",", "f", ")", ":", "\n", "  ", "\"\"\"\n  Builds the graph to compute f(a, b).\n  If only one of the two arguments is a scalar and the operation would\n  cause a type error without casting, casts the scalar to match the\n  tensor.\n  :param a: a tf-compatible array or scalar\n  :param b: a tf-compatible array or scalar\n  \"\"\"", "\n", "\n", "try", ":", "\n", "    ", "return", "f", "(", "a", ",", "b", ")", "\n", "", "except", "(", "TypeError", ",", "ValueError", ")", ":", "\n", "    ", "pass", "\n", "\n", "", "def", "is_scalar", "(", "x", ")", ":", "\n", "    ", "if", "hasattr", "(", "x", ",", "\"get_shape\"", ")", ":", "\n", "      ", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "return", "shape", ".", "ndims", "==", "0", "\n", "", "if", "hasattr", "(", "x", ",", "\"ndim\"", ")", ":", "\n", "      ", "return", "x", ".", "ndim", "==", "0", "\n", "", "assert", "isinstance", "(", "x", ",", "(", "int", ",", "float", ")", ")", "\n", "return", "True", "\n", "\n", "", "a_scalar", "=", "is_scalar", "(", "a", ")", "\n", "b_scalar", "=", "is_scalar", "(", "b", ")", "\n", "\n", "if", "a_scalar", "and", "b_scalar", ":", "\n", "    ", "raise", "TypeError", "(", "\"Trying to apply \"", "+", "str", "(", "f", ")", "+", "\" with mixed types\"", ")", "\n", "\n", "", "if", "a_scalar", "and", "not", "b_scalar", ":", "\n", "    ", "a", "=", "tf", ".", "cast", "(", "a", ",", "b", ".", "dtype", ")", "\n", "\n", "", "if", "b_scalar", "and", "not", "a_scalar", ":", "\n", "    ", "b", "=", "tf", ".", "cast", "(", "b", ",", "a", ".", "dtype", ")", "\n", "\n", "", "return", "f", "(", "a", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal": [[608, 616], ["tensorflow.device", "tensorflow.assert_less_equal"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal"], ["", "def", "assert_less_equal", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper for tf.assert_less_equal\n  Overrides tf.device so that the assert always goes on CPU.\n  The unwrapped version raises an exception if used with tf.device(\"/GPU:x\").\n  \"\"\"", "\n", "with", "tf", ".", "device", "(", "\"/CPU:0\"", ")", ":", "\n", "    ", "return", "tf", ".", "assert_less_equal", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal": [[617, 625], ["tensorflow.device", "tensorflow.assert_greater_equal"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal"], ["", "", "def", "assert_greater_equal", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper for tf.assert_greater_equal.\n  Overrides tf.device so that the assert always goes on CPU.\n  The unwrapped version raises an exception if used with tf.device(\"/GPU:x\").\n  \"\"\"", "\n", "with", "tf", ".", "device", "(", "\"/CPU:0\"", ")", ":", "\n", "    ", "return", "tf", ".", "assert_greater_equal", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_equal": [[626, 634], ["tensorflow.device", "tensorflow.assert_equal"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_equal"], ["", "", "def", "assert_equal", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper for tf.assert_equal.\n  Overrides tf.device so that the assert always goes on CPU.\n  The unwrapped version raises an exception if used with tf.device(\"/GPU:x\").\n  \"\"\"", "\n", "with", "tf", ".", "device", "(", "\"/CPU:0\"", ")", ":", "\n", "    ", "return", "tf", ".", "assert_equal", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReport.__init__": [[63, 75], ["collections.OrderedDict.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "iterable", "=", "None", ")", ":", "\n", "    ", "super", "(", "ConfidenceReport", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# This field tracks whether the report is completed.", "\n", "# It's important e.g. for reports that are made by bundlers and repeatedly", "\n", "# written to disk during the process. This field makes it possible to tell", "\n", "# whether a report on disk is complete or whether the bundling process", "\n", "# got killed (e.g. due to VM migration)", "\n", "self", ".", "completed", "=", "False", "\n", "if", "iterable", "is", "not", "None", ":", "\n", "# pickle sometimes wants to use this interface to unpickle the OrderedDict", "\n", "      ", "for", "key", ",", "value", "in", "iterable", ":", "\n", "        ", "self", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReport.__setitem__": [[76, 81], ["isinstance", "super().__setitem__", "isinstance", "TypeError", "str", "type", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReportEntry.__setitem__"], ["", "", "", "def", "__setitem__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "    ", "assert", "isinstance", "(", "key", ",", "six", ".", "string_types", ")", "\n", "if", "not", "isinstance", "(", "value", ",", "ConfidenceReportEntry", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"`value` must be a ConfidenceReportEntry, but got \"", "+", "str", "(", "value", ")", "+", "\" of type \"", "+", "str", "(", "type", "(", "value", ")", ")", ")", "\n", "", "super", "(", "ConfidenceReport", ",", "self", ")", ".", "__setitem__", "(", "key", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReportEntry.__init__": [[92, 104], ["isinstance", "isinstance", "numpy.issubdtype", "confidence.min", "confidence.max"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "correctness", ",", "confidence", ")", ":", "\n", "    ", "assert", "isinstance", "(", "correctness", ",", "np", ".", "ndarray", ")", "\n", "assert", "isinstance", "(", "correctness", ",", "np", ".", "ndarray", ")", "\n", "assert", "correctness", ".", "ndim", "==", "1", "\n", "assert", "confidence", ".", "ndim", "==", "1", "\n", "assert", "correctness", ".", "dtype", "==", "np", ".", "bool", "\n", "assert", "np", ".", "issubdtype", "(", "confidence", ".", "dtype", ",", "np", ".", "floating", ")", "\n", "assert", "correctness", ".", "shape", "==", "confidence", ".", "shape", "\n", "assert", "confidence", ".", "min", "(", ")", ">=", "0.", "\n", "assert", "confidence", ".", "max", "(", ")", "<=", "1.", "\n", "self", ".", "correctness", "=", "correctness", "\n", "self", ".", "confidence", "=", "confidence", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReportEntry.__getitem__": [[105, 113], ["warnings.warn"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"Dictionary confidence report entries are deprecated. \"", "\n", "\"Switch to accessing the appropriate field of \"", "\n", "\"ConfidenceReportEntry. \"", "\n", "\"Dictionary-style access will be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "assert", "key", "in", "[", "'correctness'", ",", "'confidence'", "]", "\n", "return", "self", ".", "__dict__", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.ConfidenceReportEntry.__setitem__": [[114, 122], ["warnings.warn"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"Dictionary confidence report entries are deprecated.\"", "\n", "\"Switch to accessing the appropriate field of \"", "\n", "\"ConfidenceReportEntry. \"", "\n", "\"Dictionary-style access will be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "assert", "key", "in", "[", "'correctness'", ",", "'confidence'", "]", "\n", "self", ".", "__dict__", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.make_confidence_report_bundled": [[124, 234], ["callable", "cleverhans.utils.set_log_level", "tensorflow.Session", "filepath.endswith", "factory", "factory.get_set", "getattr", "tf.Session.as_default", "cleverhans.serial.load", "len", "hasattr", "str", "x_data.max", "x_data.min", "getattr.", "getattr.", "cleverhans.serial.load.get_params", "AttributeError", "str", "NotImplementedError", "len", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_set", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["", "", "def", "make_confidence_report_bundled", "(", "filepath", ",", "train_start", "=", "TRAIN_START", ",", "\n", "train_end", "=", "TRAIN_END", ",", "test_start", "=", "TEST_START", ",", "\n", "test_end", "=", "TEST_END", ",", "which_set", "=", "WHICH_SET", ",", "\n", "recipe", "=", "RECIPE", ",", "report_path", "=", "REPORT_PATH", ",", "\n", "nb_iter", "=", "NB_ITER", ",", "base_eps", "=", "None", ",", "\n", "base_eps_iter", "=", "None", ",", "base_eps_iter_small", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Load a saved model, gather its predictions, and save a confidence report.\n  :param filepath: path to model to evaluate\n  :param train_start: index of first training set example to use\n  :param train_end: index of last training set example to use\n  :param test_start: index of first test set example to use\n  :param test_end: index of last test set example to use\n  :param which_set: 'train' or 'test'\n  :param nb_iter: int, number of iterations of attack algorithm\n    (note that different recipes will use this differently,\n     for example many will run two attacks, one with nb_iter\n     iterations and one with 25X more)\n  :param base_eps: float, epsilon parameter for threat model, on a scale of [0, 1].\n    Inferred from the dataset if not specified.\n  :param base_eps_iter: float, a step size used in different ways by different recipes.\n    Typically the step size for a PGD attack.\n    Inferred from the dataset if not specified.\n  :param base_eps_iter_small: float, a second step size for a more fine-grained attack.\n    Inferred from the dataset if not specified.\n  \"\"\"", "\n", "# Avoid circular import", "\n", "from", "cleverhans", "import", "attack_bundling", "\n", "if", "callable", "(", "recipe", ")", ":", "\n", "    ", "run_recipe", "=", "recipe", "\n", "", "else", ":", "\n", "    ", "run_recipe", "=", "getattr", "(", "attack_bundling", ",", "recipe", ")", "\n", "\n", "# Set logging level to see debug information", "\n", "", "set_log_level", "(", "logging", ".", "INFO", ")", "\n", "\n", "# Create TF session", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "\n", "assert", "filepath", ".", "endswith", "(", "'.joblib'", ")", "\n", "if", "report_path", "is", "None", ":", "\n", "    ", "report_path", "=", "filepath", "[", ":", "-", "len", "(", "'.joblib'", ")", "]", "+", "\"_bundled_report.joblib\"", "\n", "\n", "", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "model", "=", "load", "(", "filepath", ")", "\n", "", "assert", "len", "(", "model", ".", "get_params", "(", ")", ")", ">", "0", "\n", "factory", "=", "model", ".", "dataset_factory", "\n", "factory", ".", "kwargs", "[", "'train_start'", "]", "=", "train_start", "\n", "factory", ".", "kwargs", "[", "'train_end'", "]", "=", "train_end", "\n", "factory", ".", "kwargs", "[", "'test_start'", "]", "=", "test_start", "\n", "factory", ".", "kwargs", "[", "'test_end'", "]", "=", "test_end", "\n", "dataset", "=", "factory", "(", ")", "\n", "\n", "center", "=", "dataset", ".", "kwargs", "[", "'center'", "]", "\n", "if", "'max_val'", "in", "factory", ".", "kwargs", ":", "\n", "    ", "max_value", "=", "factory", ".", "kwargs", "[", "'max_val'", "]", "\n", "", "elif", "hasattr", "(", "dataset", ",", "'max_val'", ")", ":", "\n", "    ", "max_value", "=", "dataset", ".", "max_val", "\n", "", "else", ":", "\n", "    ", "raise", "AttributeError", "(", "\"Can't find max_value specification\"", ")", "\n", "", "min_value", "=", "0.", "-", "center", "*", "max_value", "\n", "value_range", "=", "max_value", "-", "min_value", "\n", "\n", "if", "'CIFAR'", "in", "str", "(", "factory", ".", "cls", ")", ":", "\n", "    ", "if", "base_eps", "is", "None", ":", "\n", "      ", "base_eps", "=", "8.", "/", "255.", "\n", "", "if", "base_eps_iter", "is", "None", ":", "\n", "      ", "base_eps_iter", "=", "2.", "/", "255.", "\n", "", "if", "base_eps_iter_small", "is", "None", ":", "\n", "      ", "base_eps_iter_small", "=", "1.", "/", "255.", "\n", "", "", "elif", "'MNIST'", "in", "str", "(", "factory", ".", "cls", ")", ":", "\n", "    ", "if", "base_eps", "is", "None", ":", "\n", "      ", "base_eps", "=", ".3", "\n", "", "if", "base_eps_iter", "is", "None", ":", "\n", "      ", "base_eps_iter", "=", ".1", "\n", "", "base_eps_iter_small", "=", "None", "\n", "", "else", ":", "\n", "# Note that it is not required to specify base_eps_iter_small", "\n", "    ", "if", "base_eps", "is", "None", "or", "base_eps_iter", "is", "None", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"Not able to infer threat model from \"", "+", "str", "(", "factory", ".", "cls", ")", ")", "\n", "\n", "", "", "eps", "=", "base_eps", "*", "value_range", "\n", "eps_iter", "=", "base_eps_iter", "*", "value_range", "\n", "if", "base_eps_iter_small", "is", "None", ":", "\n", "    ", "eps_iter_small", "=", "None", "\n", "", "else", ":", "\n", "    ", "eps_iter_small", "=", "base_eps_iter_small", "*", "value_range", "\n", "", "clip_min", "=", "min_value", "\n", "clip_max", "=", "max_value", "\n", "\n", "x_data", ",", "y_data", "=", "dataset", ".", "get_set", "(", "which_set", ")", "\n", "assert", "x_data", ".", "max", "(", ")", "<=", "max_value", "\n", "assert", "x_data", ".", "min", "(", ")", ">=", "min_value", "\n", "\n", "assert", "eps_iter", "<=", "eps", "\n", "assert", "eps_iter_small", "is", "None", "or", "eps_iter_small", "<=", "eps", "\n", "\n", "# Different recipes take different arguments.", "\n", "# For now I don't have an idea for a beautiful unifying framework, so", "\n", "# we get an if statement.", "\n", "if", "recipe", "==", "'random_search_max_confidence_recipe'", ":", "\n", "# pylint always checks against the default recipe here", "\n", "# pylint: disable=no-value-for-parameter", "\n", "    ", "run_recipe", "(", "sess", "=", "sess", ",", "model", "=", "model", ",", "x", "=", "x_data", ",", "y", "=", "y_data", ",", "eps", "=", "eps", ",", "\n", "clip_min", "=", "clip_min", ",", "clip_max", "=", "clip_max", ",", "report_path", "=", "report_path", ")", "\n", "", "else", ":", "\n", "    ", "run_recipe", "(", "sess", "=", "sess", ",", "model", "=", "model", ",", "x", "=", "x_data", ",", "y", "=", "y_data", ",", "\n", "nb_classes", "=", "dataset", ".", "NB_CLASSES", ",", "eps", "=", "eps", ",", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", ",", "eps_iter", "=", "eps_iter", ",", "nb_iter", "=", "nb_iter", ",", "\n", "report_path", "=", "report_path", ",", "eps_iter_small", "=", "eps_iter_small", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.print_stats": [[236, 269], ["correctness.mean", "numpy.maximum", "numpy.maximum", "covered.mean", "print", "print", "print", "print", "print", "print", "print", "print", "wrongness.sum", "correctness.sum", "numpy.maximum", "covered.sum"], "function", ["None"], ["", "", "def", "print_stats", "(", "correctness", ",", "confidence", ",", "name", ")", ":", "\n", "  ", "\"\"\"\n  Prints out accuracy, coverage, etc. statistics\n  :param correctness: ndarray\n    One bool per example specifying whether it was correctly classified\n  :param confidence: ndarray\n    The probability associated with each prediction\n  :param name: str\n    The name of this type of data (e.g. \"clean\", \"MaxConfidence\")\n  \"\"\"", "\n", "accuracy", "=", "correctness", ".", "mean", "(", ")", "\n", "wrongness", "=", "1", "-", "correctness", "\n", "denom1", "=", "np", ".", "maximum", "(", "1", ",", "wrongness", ".", "sum", "(", ")", ")", "\n", "ave_prob_on_mistake", "=", "(", "wrongness", "*", "confidence", ")", ".", "sum", "(", ")", "/", "denom1", "\n", "assert", "ave_prob_on_mistake", "<=", "1.", ",", "ave_prob_on_mistake", "\n", "denom2", "=", "np", ".", "maximum", "(", "1", ",", "correctness", ".", "sum", "(", ")", ")", "\n", "ave_prob_on_correct", "=", "(", "correctness", "*", "confidence", ")", ".", "sum", "(", ")", "/", "denom2", "\n", "covered", "=", "confidence", ">", "0.5", "\n", "cov_half", "=", "covered", ".", "mean", "(", ")", "\n", "acc_half", "=", "(", "correctness", "*", "covered", ")", ".", "sum", "(", ")", "/", "np", ".", "maximum", "(", "1", ",", "covered", ".", "sum", "(", ")", ")", "\n", "print", "(", "'Accuracy on %s examples: %0.4f'", "%", "(", "name", ",", "accuracy", ")", ")", "\n", "print", "(", "\"Average prob on mistakes: %0.4f\"", "%", "ave_prob_on_mistake", ")", "\n", "print", "(", "\"Average prob on correct: %0.4f\"", "%", "ave_prob_on_correct", ")", "\n", "print", "(", "\"Accuracy when prob thresholded at .5: %0.4f\"", "%", "acc_half", ")", "\n", "print", "(", "\"Coverage when prob thresholded at .5: %0.4f\"", "%", "cov_half", ")", "\n", "\n", "success_rate", "=", "acc_half", "*", "cov_half", "\n", "# Success is correctly classifying a covered example", "\n", "print", "(", "\"Success rate at .5: %0.4f\"", "%", "success_rate", ")", "\n", "# Failure is misclassifying a covered example", "\n", "failure_rate", "=", "(", "1.", "-", "acc_half", ")", "*", "cov_half", "\n", "print", "(", "\"Failure rate at .5: %0.4f\"", "%", "failure_rate", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.make_confidence_report": [[271, 403], ["tensorflow.set_random_seed", "cleverhans.utils.set_log_level", "tensorflow.Session", "factory", "factory.get_set", "confidence_report.ConfidenceReport", "cleverhans.attacks.Semantic", "cleverhans.attacks.MaxConfidence", "cleverhans.serial.save", "filepath.endswith", "tf.Session.as_default", "cleverhans.serial.load", "len", "str", "time.time", "cleverhans.evaluation.correctness_and_confidence", "time.time", "print", "confidence_report.ConfidenceReportEntry", "confidence_report.print_stats", "cleverhans.serial.load.get_params", "str", "NotImplementedError", "report_path.endswith", "cleverhans.evaluation.run_attack", "numpy.save", "str", "len", "len"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_set", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.correctness_and_confidence", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.print_stats", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.run_attack", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save"], ["", "def", "make_confidence_report", "(", "filepath", ",", "train_start", "=", "TRAIN_START", ",", "\n", "train_end", "=", "TRAIN_END", ",", "\n", "test_start", "=", "TEST_START", ",", "test_end", "=", "TEST_END", ",", "\n", "batch_size", "=", "BATCH_SIZE", ",", "which_set", "=", "WHICH_SET", ",", "\n", "mc_batch_size", "=", "MC_BATCH_SIZE", ",", "\n", "report_path", "=", "REPORT_PATH", ",", "\n", "base_eps_iter", "=", "BASE_EPS_ITER", ",", "\n", "nb_iter", "=", "NB_ITER", ",", "save_advx", "=", "SAVE_ADVX", ")", ":", "\n", "  ", "\"\"\"\n  Load a saved model, gather its predictions, and save a confidence report.\n\n\n  This function works by running a single MaxConfidence attack on each example.\n  This provides a reasonable estimate of the true failure rate quickly, so\n  long as the model does not suffer from gradient masking.\n  However, this estimate is mostly intended for development work and not\n  for publication. A more accurate estimate may be obtained by running\n  make_confidence_report_bundled.py instead.\n\n  :param filepath: path to model to evaluate\n  :param train_start: index of first training set example to use\n  :param train_end: index of last training set example to use\n  :param test_start: index of first test set example to use\n  :param test_end: index of last test set example to use\n  :param batch_size: size of evaluation batches\n  :param which_set: 'train' or 'test'\n  :param mc_batch_size: batch size for MaxConfidence attack\n  :param base_eps_iter: step size if the data were in [0,1]\n    (Step size will be rescaled proportional to the actual data range)\n  :param nb_iter: Number of iterations of PGD to run per class\n  :param save_advx: bool. If True, saves the adversarial examples to disk.\n    On by default, but can be turned off to save memory, etc.\n  \"\"\"", "\n", "\n", "# Set TF random seed to improve reproducibility", "\n", "tf", ".", "set_random_seed", "(", "1234", ")", "\n", "\n", "# Set logging level to see debug information", "\n", "set_log_level", "(", "logging", ".", "INFO", ")", "\n", "\n", "# Create TF session", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "\n", "if", "report_path", "is", "None", ":", "\n", "    ", "assert", "filepath", ".", "endswith", "(", "'.joblib'", ")", "\n", "report_path", "=", "filepath", "[", ":", "-", "len", "(", "'.joblib'", ")", "]", "+", "\"_report.joblib\"", "\n", "\n", "", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "model", "=", "load", "(", "filepath", ")", "\n", "", "assert", "len", "(", "model", ".", "get_params", "(", ")", ")", ">", "0", "\n", "factory", "=", "model", ".", "dataset_factory", "\n", "factory", ".", "kwargs", "[", "'train_start'", "]", "=", "train_start", "\n", "factory", ".", "kwargs", "[", "'train_end'", "]", "=", "train_end", "\n", "factory", ".", "kwargs", "[", "'test_start'", "]", "=", "test_start", "\n", "factory", ".", "kwargs", "[", "'test_end'", "]", "=", "test_end", "\n", "dataset", "=", "factory", "(", ")", "\n", "\n", "center", "=", "dataset", ".", "kwargs", "[", "'center'", "]", "\n", "max_val", "=", "dataset", ".", "kwargs", "[", "'max_val'", "]", "\n", "value_range", "=", "max_val", "*", "(", "1.", "+", "center", ")", "\n", "min_value", "=", "0.", "-", "center", "*", "max_val", "\n", "\n", "if", "'CIFAR'", "in", "str", "(", "factory", ".", "cls", ")", ":", "\n", "    ", "base_eps", "=", "8.", "/", "255.", "\n", "if", "base_eps_iter", "is", "None", ":", "\n", "      ", "base_eps_iter", "=", "2.", "/", "255.", "\n", "", "", "elif", "'MNIST'", "in", "str", "(", "factory", ".", "cls", ")", ":", "\n", "    ", "base_eps", "=", ".3", "\n", "if", "base_eps_iter", "is", "None", ":", "\n", "      ", "base_eps_iter", "=", ".1", "\n", "", "", "else", ":", "\n", "    ", "raise", "NotImplementedError", "(", "str", "(", "factory", ".", "cls", ")", ")", "\n", "\n", "", "mc_params", "=", "{", "'eps'", ":", "base_eps", "*", "value_range", ",", "\n", "'eps_iter'", ":", "base_eps_iter", "*", "value_range", ",", "\n", "'nb_iter'", ":", "nb_iter", ",", "\n", "'clip_min'", ":", "min_value", ",", "\n", "'clip_max'", ":", "max_val", "}", "\n", "\n", "x_data", ",", "y_data", "=", "dataset", ".", "get_set", "(", "which_set", ")", "\n", "\n", "report", "=", "ConfidenceReport", "(", ")", "\n", "\n", "semantic", "=", "Semantic", "(", "model", ",", "center", ",", "max_val", ",", "sess", ")", "\n", "mc", "=", "MaxConfidence", "(", "model", ",", "sess", "=", "sess", ")", "\n", "\n", "jobs", "=", "[", "(", "'clean'", ",", "None", ",", "None", ",", "None", ",", "False", ")", ",", "\n", "(", "'Semantic'", ",", "semantic", ",", "None", ",", "None", ",", "False", ")", ",", "\n", "(", "'mc'", ",", "mc", ",", "mc_params", ",", "mc_batch_size", ",", "True", ")", "]", "\n", "\n", "for", "job", "in", "jobs", ":", "\n", "    ", "name", ",", "attack", ",", "attack_params", ",", "job_batch_size", ",", "save_this_job", "=", "job", "\n", "if", "job_batch_size", "is", "None", ":", "\n", "      ", "job_batch_size", "=", "batch_size", "\n", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "if", "save_advx", "and", "save_this_job", ":", "\n", "# If we want to save the adversarial examples to the filesystem, we need", "\n", "# to fetch all of them. Otherwise they're just computed one batch at a", "\n", "# time and discarded", "\n", "\n", "# The path to save to", "\n", "      ", "assert", "report_path", ".", "endswith", "(", "'.joblib'", ")", "\n", "advx_path", "=", "report_path", "[", ":", "-", "len", "(", "'.joblib'", ")", "]", "+", "'_advx_'", "+", "name", "+", "'.npy'", "\n", "\n", "# Fetch the adversarial examples", "\n", "x_data", "=", "run_attack", "(", "sess", ",", "model", ",", "x_data", ",", "y_data", ",", "attack", ",", "attack_params", ",", "\n", "batch_size", "=", "job_batch_size", ",", "devices", "=", "devices", ")", "\n", "\n", "# Turn off the attack so `correctness_and_confidence` won't run it a", "\n", "# second time.", "\n", "attack", "=", "None", "\n", "attack_params", "=", "None", "\n", "\n", "# Save the adversarial examples", "\n", "np", ".", "save", "(", "advx_path", ",", "x_data", ")", "\n", "\n", "# Run correctness and confidence evaluation on adversarial examples", "\n", "", "packed", "=", "correctness_and_confidence", "(", "sess", ",", "model", ",", "x_data", ",", "y_data", ",", "\n", "batch_size", "=", "job_batch_size", ",", "\n", "devices", "=", "devices", ",", "\n", "attack", "=", "attack", ",", "\n", "attack_params", "=", "attack_params", ")", "\n", "t2", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Evaluation took\"", ",", "t2", "-", "t1", ",", "\"seconds\"", ")", "\n", "correctness", ",", "confidence", "=", "packed", "\n", "\n", "report", "[", "name", "]", "=", "ConfidenceReportEntry", "(", "correctness", "=", "correctness", ",", "\n", "confidence", "=", "confidence", ")", "\n", "\n", "print_stats", "(", "correctness", ",", "confidence", ",", "name", ")", "\n", "\n", "", "save", "(", "report_path", ",", "report", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.__init__": [[99, 111], ["model.Model.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ")", ":", "\n", "    ", "\"\"\"\n    Create a wrapper for a Keras model\n    :param model: A Keras model\n    \"\"\"", "\n", "super", "(", "KerasModelWrapper", ",", "self", ")", ".", "__init__", "(", "None", ",", "None", ",", "{", "}", ")", "\n", "\n", "if", "model", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "'model argument must be supplied.'", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "keras_model", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_softmax_name": [[112, 123], ["Exception", "layer.get_config"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.initializers.HeReLuNormalInitializer.get_config"], ["", "def", "_get_softmax_name", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Looks for the name of the softmax layer.\n    :return: Softmax layer name\n    \"\"\"", "\n", "for", "layer", "in", "self", ".", "model", ".", "layers", ":", "\n", "      ", "cfg", "=", "layer", ".", "get_config", "(", ")", "\n", "if", "'activation'", "in", "cfg", "and", "cfg", "[", "'activation'", "]", "==", "'softmax'", ":", "\n", "        ", "return", "layer", ".", "name", "\n", "\n", "", "", "raise", "Exception", "(", "\"No softmax layers found\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_logits_name": [[124, 144], ["utils_keras.KerasModelWrapper._get_softmax_name", "utils_keras.KerasModelWrapper.model.get_layer", "isinstance", "hasattr", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_softmax_name", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer"], ["", "def", "_get_logits_name", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Looks for the name of the layer producing the logits.\n    :return: name of layer producing the logits\n    \"\"\"", "\n", "softmax_name", "=", "self", ".", "_get_softmax_name", "(", ")", "\n", "softmax_layer", "=", "self", ".", "model", ".", "get_layer", "(", "softmax_name", ")", "\n", "\n", "if", "not", "isinstance", "(", "softmax_layer", ",", "Activation", ")", ":", "\n", "# In this case, the activation is part of another layer", "\n", "      ", "return", "softmax_name", "\n", "\n", "", "if", "not", "hasattr", "(", "softmax_layer", ",", "'_inbound_nodes'", ")", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"Please update keras to version >= 2.1.3\"", ")", "\n", "\n", "", "node", "=", "softmax_layer", ".", "_inbound_nodes", "[", "0", "]", "\n", "\n", "logits_name", "=", "node", ".", "inbound_layers", "[", "0", "]", ".", "name", "\n", "\n", "return", "logits_name", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.get_logits": [[145, 162], ["utils_keras.KerasModelWrapper._get_logits_name", "utils_keras.KerasModelWrapper.get_layer", "utils_keras.KerasModelWrapper._get_softmax_name", "utils_keras.KerasModelWrapper.get_layer"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_logits_name", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_softmax_name", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer"], ["", "def", "get_logits", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    :param x: A symbolic representation of the network input.\n    :return: A symbolic representation of the logits\n    \"\"\"", "\n", "logits_name", "=", "self", ".", "_get_logits_name", "(", ")", "\n", "logits_layer", "=", "self", ".", "get_layer", "(", "x", ",", "logits_name", ")", "\n", "\n", "# Need to deal with the case where softmax is part of the", "\n", "# logits layer", "\n", "if", "logits_name", "==", "self", ".", "_get_softmax_name", "(", ")", ":", "\n", "      ", "softmax_logit_layer", "=", "self", ".", "get_layer", "(", "x", ",", "logits_name", ")", "\n", "\n", "# The final op is the softmax. Return its input", "\n", "logits_layer", "=", "softmax_logit_layer", ".", "_op", ".", "inputs", "[", "0", "]", "\n", "\n", "", "return", "logits_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.get_probs": [[163, 171], ["utils_keras.KerasModelWrapper._get_softmax_name", "utils_keras.KerasModelWrapper.get_layer"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper._get_softmax_name", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer"], ["", "def", "get_probs", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    :param x: A symbolic representation of the network input.\n    :return: A symbolic representation of the probs\n    \"\"\"", "\n", "name", "=", "self", ".", "_get_softmax_name", "(", ")", "\n", "\n", "return", "self", ".", "get_layer", "(", "x", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.get_layer_names": [[172, 178], ["None"], "methods", ["None"], ["", "def", "get_layer_names", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    :return: Names of all the layers kept by Keras\n    \"\"\"", "\n", "layer_names", "=", "[", "x", ".", "name", "for", "x", "in", "self", ".", "model", ".", "layers", "]", "\n", "return", "layer_names", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.fprop": [[179, 207], ["utils_keras.KerasModelWrapper.keras_model", "dict", "utils_keras.KerasModelWrapper.model.get_input_at", "KerasModel", "len", "zip", "utils_keras.KerasModelWrapper.get_layer_names"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer_names"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    Exposes all the layers of the model returned by get_layer_names.\n    :param x: A symbolic representation of the network input\n    :return: A dictionary mapping layer names to the symbolic\n             representation of their output.\n    \"\"\"", "\n", "\n", "if", "self", ".", "keras_model", "is", "None", ":", "\n", "# Get the input layer", "\n", "      ", "new_input", "=", "self", ".", "model", ".", "get_input_at", "(", "0", ")", "\n", "\n", "# Make a new model that returns each of the layers as output", "\n", "out_layers", "=", "[", "x_layer", ".", "output", "for", "x_layer", "in", "self", ".", "model", ".", "layers", "]", "\n", "self", ".", "keras_model", "=", "KerasModel", "(", "new_input", ",", "out_layers", ")", "\n", "\n", "# and get the outputs for that model on the input x", "\n", "", "outputs", "=", "self", ".", "keras_model", "(", "x", ")", "\n", "\n", "# Keras only returns a list for outputs of length >= 1, if the model", "\n", "# is only one layer, wrap a list", "\n", "if", "len", "(", "self", ".", "model", ".", "layers", ")", "==", "1", ":", "\n", "      ", "outputs", "=", "[", "outputs", "]", "\n", "\n", "# compute the dict to return", "\n", "", "fprop_dict", "=", "dict", "(", "zip", "(", "self", ".", "get_layer_names", "(", ")", ",", "outputs", ")", ")", "\n", "\n", "return", "fprop_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.KerasModelWrapper.get_layer": [[208, 223], ["utils_keras.KerasModelWrapper.fprop", "model.NoSuchLayerError"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "get_layer", "(", "self", ",", "x", ",", "layer", ")", ":", "\n", "    ", "\"\"\"\n    Expose the hidden features of a model given a layer name.\n    :param x: A symbolic representation of the network input\n    :param layer: The name of the hidden layer to return features at.\n    :return: A symbolic representation of the hidden features\n    :raise: NoSuchLayerError if `layer` is not in the model.\n    \"\"\"", "\n", "# Return the symbolic representation for this layer.", "\n", "output", "=", "self", ".", "fprop", "(", "x", ")", "\n", "try", ":", "\n", "      ", "requested", "=", "output", "[", "layer", "]", "\n", "", "except", "KeyError", ":", "\n", "      ", "raise", "NoSuchLayerError", "(", ")", "\n", "", "return", "requested", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.conv_2d": [[16, 40], ["Conv2D", "Conv2D"], "function", ["None"], ["def", "conv_2d", "(", "filters", ",", "kernel_shape", ",", "strides", ",", "padding", ",", "input_shape", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Defines the right convolutional layer according to the\n  version of Keras that is installed.\n  :param filters: (required integer) the dimensionality of the output\n                  space (i.e. the number output of filters in the\n                  convolution)\n  :param kernel_shape: (required tuple or list of 2 integers) specifies\n                       the strides of the convolution along the width and\n                       height.\n  :param padding: (required string) can be either 'valid' (no padding around\n                  input or feature map) or 'same' (pad to ensure that the\n                  output feature map size is identical to the layer input)\n  :param input_shape: (optional) give input shape if this is the first\n                      layer of the model\n  :return: the Keras layer\n  \"\"\"", "\n", "if", "input_shape", "is", "not", "None", ":", "\n", "    ", "return", "Conv2D", "(", "filters", "=", "filters", ",", "kernel_size", "=", "kernel_shape", ",", "\n", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "\n", "input_shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "    ", "return", "Conv2D", "(", "filters", "=", "filters", ",", "kernel_size", "=", "kernel_shape", ",", "\n", "strides", "=", "strides", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.cnn_model": [[42, 89], ["Sequential", "Sequential.add", "tensorflow.keras.backend.image_data_format", "utils_keras.conv_2d", "Activation", "utils_keras.conv_2d", "Activation", "utils_keras.conv_2d", "Activation", "Flatten", "Dense", "Sequential.add", "Sequential.", "Activation", "tensorflow.keras.backend.image_data_format"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.conv_2d", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.conv_2d", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_keras.conv_2d"], ["", "", "def", "cnn_model", "(", "logits", "=", "False", ",", "input_ph", "=", "None", ",", "img_rows", "=", "28", ",", "img_cols", "=", "28", ",", "\n", "channels", "=", "1", ",", "nb_filters", "=", "64", ",", "nb_classes", "=", "10", ")", ":", "\n", "  ", "\"\"\"\n  Defines a CNN model using Keras sequential model\n  :param logits: If set to False, returns a Keras model, otherwise will also\n                  return logits tensor\n  :param input_ph: The TensorFlow tensor for the input\n                  (needed if returning logits)\n                  (\"ph\" stands for placeholder but it need not actually be a\n                  placeholder)\n  :param img_rows: number of row in the image\n  :param img_cols: number of columns in the image\n  :param channels: number of color channels (e.g., 1 for MNIST)\n  :param nb_filters: number of convolutional filters per layer\n  :param nb_classes: the number of output classes\n  :return:\n  \"\"\"", "\n", "model", "=", "Sequential", "(", ")", "\n", "\n", "# Define the layers successively (convolution layers are version dependent)", "\n", "if", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "    ", "input_shape", "=", "(", "channels", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "    ", "assert", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_last'", "\n", "input_shape", "=", "(", "img_rows", ",", "img_cols", ",", "channels", ")", "\n", "\n", "", "layers", "=", "[", "conv_2d", "(", "nb_filters", ",", "(", "8", ",", "8", ")", ",", "(", "2", ",", "2", ")", ",", "\"same\"", ",", "\n", "input_shape", "=", "input_shape", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "(", "nb_filters", "*", "2", ")", ",", "(", "6", ",", "6", ")", ",", "(", "2", ",", "2", ")", ",", "\"valid\"", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "conv_2d", "(", "(", "nb_filters", "*", "2", ")", ",", "(", "5", ",", "5", ")", ",", "(", "1", ",", "1", ")", ",", "\"valid\"", ")", ",", "\n", "Activation", "(", "'relu'", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Dense", "(", "nb_classes", ")", "]", "\n", "\n", "for", "layer", "in", "layers", ":", "\n", "    ", "model", ".", "add", "(", "layer", ")", "\n", "\n", "", "if", "logits", ":", "\n", "    ", "logits_tensor", "=", "model", "(", "input_ph", ")", "\n", "", "model", ".", "add", "(", "Activation", "(", "'softmax'", ")", ")", "\n", "\n", "if", "logits", ":", "\n", "    ", "return", "model", ",", "logits_tensor", "\n", "", "else", ":", "\n", "    ", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.train.train": [[38, 275], ["cleverhans.canary.run_canary", "cleverhans.utils._ArgsWrapper", "cleverhans.utils_tf.infer_devices", "len", "print", "train.avg_grads", "tensorflow.placeholder", "tensorflow.placeholder", "six.moves.xrange", "warnings.warn", "ValueError", "numpy.random.RandomState", "tensorflow.train.AdamOptimizer", "dataset_train.make_one_shot_iterator().get_next", "sess.run", "tensorflow.control_dependencies", "tf.train.AdamOptimizer.apply_gradients", "callable", "tensorflow.train.ExponentialMovingAverage", "sess.run", "cleverhans.utils_tf.initialize_uninitialized_global_variables", "time.time", "range", "time.time", "_logger.info", "sess.run", "ValueError", "isinstance", "ValueError", "ValueError", "tensorflow.device", "tensorflow.placeholder", "tensorflow.placeholder", "xs.append", "ys.append", "preprocessed_xs.append", "loss.fprop", "grads.append", "tensorflow.get_collection", "ema_decay.", "tensorflow.control_dependencies", "tf.train.ExponentialMovingAverage.apply", "tf.train.ExponentialMovingAverage.average", "tensorflow.Variable", "tensorflow.assign", "tensorflow.control_dependencies", "tensorflow.control_dependencies", "tensorflow.global_variables_initializer", "int", "list", "np.random.RandomState.shuffle", "six.moves.xrange", "sess.run", "evaluate", "dataset_train.make_one_shot_iterator", "x_batch_preprocessor", "tf.train.AdamOptimizer.compute_gradients", "cleverhans.utils.safe_zip", "tensorflow.assign", "tensorflow.assign", "math.ceil", "range", "list.append", "len", "sess.run", "ValueError", "feed_dict.update", "numpy.abs", "ValueError", "numpy.isnan", "numpy.isinf", "ValueError", "len", "sess.run", "sess.run", "cleverhans.utils.safe_zip", "cleverhans.utils.safe_zip", "len", "len", "np.random.RandomState.randint", "str", "str", "float", "len", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.canary.run_canary", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.infer_devices", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.train.avg_grads", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.initialize_uninitialized_global_variables", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["def", "train", "(", "sess", ",", "loss", ",", "x_train", ",", "y_train", ",", "\n", "init_all", "=", "False", ",", "evaluate", "=", "None", ",", "feed", "=", "None", ",", "args", "=", "None", ",", "\n", "rng", "=", "None", ",", "var_list", "=", "None", ",", "fprop_args", "=", "None", ",", "optimizer", "=", "None", ",", "\n", "devices", "=", "None", ",", "x_batch_preprocessor", "=", "None", ",", "use_ema", "=", "False", ",", "\n", "ema_decay", "=", ".998", ",", "run_canary", "=", "None", ",", "\n", "loss_threshold", "=", "1e5", ",", "dataset_train", "=", "None", ",", "dataset_size", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Run (optionally multi-replica, synchronous) training to minimize `loss`\n  :param sess: TF session to use when training the graph\n  :param loss: tensor, the loss to minimize\n  :param x_train: numpy array with training inputs or tf Dataset\n  :param y_train: numpy array with training outputs or tf Dataset\n  :param init_all: (boolean) If set to true, all TF variables in the session\n                   are (re)initialized, otherwise only previously\n                   uninitialized variables are initialized before training.\n  :param evaluate: function that is run after each training iteration\n                   (typically to display the test/validation accuracy).\n  :param feed: An optional dictionary that is appended to the feeding\n               dictionary before the session runs. Can be used to feed\n               the learning phase of a Keras model for instance.\n  :param args: dict or argparse `Namespace` object.\n               Should contain `nb_epochs`, `learning_rate`,\n               `batch_size`\n  :param rng: Instance of numpy.random.RandomState\n  :param var_list: Optional list of parameters to train.\n  :param fprop_args: dict, extra arguments to pass to fprop (loss and model).\n  :param optimizer: Optimizer to be used for training\n  :param devices: list of device names to use for training\n      If None, defaults to: all GPUs, if GPUs are available\n                            all devices, if no GPUs are available\n  :param x_batch_preprocessor: callable\n      Takes a single tensor containing an x_train batch as input\n      Returns a single tensor containing an x_train batch as output\n      Called to preprocess the data before passing the data to the Loss\n  :param use_ema: bool\n      If true, uses an exponential moving average of the model parameters\n  :param ema_decay: float or callable\n      The decay parameter for EMA, if EMA is used\n      If a callable rather than a float, this is a callable that takes\n      the epoch and batch as arguments and returns the ema_decay for\n      the current batch.\n  :param loss_threshold: float\n      Raise an exception if the loss exceeds this value.\n      This is intended to rapidly detect numerical problems.\n      Sometimes the loss may legitimately be higher than this value. In\n      such cases, raise the value. If needed it can be np.inf.\n  :param dataset_train: tf Dataset instance.\n      Used as a replacement for x_train, y_train for faster performance.\n    :param dataset_size: integer, the size of the dataset_train.\n  :return: True if model trained\n  \"\"\"", "\n", "\n", "# Check whether the hardware is working correctly", "\n", "canary", ".", "run_canary", "(", ")", "\n", "if", "run_canary", "is", "not", "None", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"The `run_canary` argument is deprecated. The canary \"", "\n", "\"is now much cheaper and thus runs all the time. The \"", "\n", "\"canary now uses its own loss function so it is not \"", "\n", "\"necessary to turn off the canary when training with \"", "\n", "\" a stochastic loss. Simply quit passing `run_canary`.\"", "\n", "\"Passing `run_canary` may become an error on or after \"", "\n", "\"2019-10-16.\"", ")", "\n", "\n", "", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "fprop_args", "=", "fprop_args", "or", "{", "}", "\n", "\n", "# Check that necessary arguments were given (see doc above)", "\n", "# Be sure to support 0 epochs for debugging purposes", "\n", "if", "args", ".", "nb_epochs", "is", "None", ":", "\n", "    ", "raise", "ValueError", "(", "\"`args` must specify number of epochs\"", ")", "\n", "", "if", "optimizer", "is", "None", ":", "\n", "    ", "if", "args", ".", "learning_rate", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Learning rate was not given in args dict\"", ")", "\n", "", "", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "\n", "if", "rng", "is", "None", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "", "if", "optimizer", "is", "None", ":", "\n", "    ", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "args", ".", "learning_rate", ")", "\n", "", "else", ":", "\n", "    ", "if", "not", "isinstance", "(", "optimizer", ",", "tf", ".", "train", ".", "Optimizer", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\"optimizer object must be from a child class of \"", "\n", "\"tf.train.Optimizer\"", ")", "\n", "\n", "", "", "grads", "=", "[", "]", "\n", "xs", "=", "[", "]", "\n", "preprocessed_xs", "=", "[", "]", "\n", "ys", "=", "[", "]", "\n", "if", "dataset_train", "is", "not", "None", ":", "\n", "    ", "assert", "x_train", "is", "None", "and", "y_train", "is", "None", "and", "x_batch_preprocessor", "is", "None", "\n", "if", "dataset_size", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"You must provide a dataset size\"", ")", "\n", "", "data_iterator", "=", "dataset_train", ".", "make_one_shot_iterator", "(", ")", ".", "get_next", "(", ")", "\n", "x_train", ",", "y_train", "=", "sess", ".", "run", "(", "data_iterator", ")", "\n", "\n", "", "devices", "=", "infer_devices", "(", "devices", ")", "\n", "for", "device", "in", "devices", ":", "\n", "    ", "with", "tf", ".", "device", "(", "device", ")", ":", "\n", "      ", "x", "=", "tf", ".", "placeholder", "(", "x_train", ".", "dtype", ",", "(", "None", ",", ")", "+", "x_train", ".", "shape", "[", "1", ":", "]", ")", "\n", "y", "=", "tf", ".", "placeholder", "(", "y_train", ".", "dtype", ",", "(", "None", ",", ")", "+", "y_train", ".", "shape", "[", "1", ":", "]", ")", "\n", "xs", ".", "append", "(", "x", ")", "\n", "ys", ".", "append", "(", "y", ")", "\n", "\n", "if", "x_batch_preprocessor", "is", "not", "None", ":", "\n", "        ", "x", "=", "x_batch_preprocessor", "(", "x", ")", "\n", "\n", "# We need to keep track of these so that the canary can feed", "\n", "# preprocessed values. If the canary had to feed raw values,", "\n", "# stochastic preprocessing could make the canary fail.", "\n", "", "preprocessed_xs", ".", "append", "(", "x", ")", "\n", "\n", "loss_value", "=", "loss", ".", "fprop", "(", "x", ",", "y", ",", "**", "fprop_args", ")", "\n", "\n", "grads", ".", "append", "(", "optimizer", ".", "compute_gradients", "(", "\n", "loss_value", ",", "var_list", "=", "var_list", ")", ")", "\n", "", "", "num_devices", "=", "len", "(", "devices", ")", "\n", "print", "(", "\"num_devices: \"", ",", "num_devices", ")", "\n", "\n", "grad", "=", "avg_grads", "(", "grads", ")", "\n", "# Trigger update operations within the default graph (such as batch_norm).", "\n", "with", "tf", ".", "control_dependencies", "(", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "UPDATE_OPS", ")", ")", ":", "\n", "    ", "train_step", "=", "optimizer", ".", "apply_gradients", "(", "grad", ")", "\n", "\n", "", "epoch_tf", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "]", ")", "\n", "batch_tf", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "[", "]", ")", "\n", "\n", "if", "use_ema", ":", "\n", "    ", "if", "callable", "(", "ema_decay", ")", ":", "\n", "      ", "ema_decay", "=", "ema_decay", "(", "epoch_tf", ",", "batch_tf", ")", "\n", "", "ema", "=", "tf", ".", "train", ".", "ExponentialMovingAverage", "(", "decay", "=", "ema_decay", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "train_step", "]", ")", ":", "\n", "      ", "train_step", "=", "ema", ".", "apply", "(", "var_list", ")", "\n", "# Get pointers to the EMA's running average variables", "\n", "", "avg_params", "=", "[", "ema", ".", "average", "(", "param", ")", "for", "param", "in", "var_list", "]", "\n", "# Make temporary buffers used for swapping the live and running average", "\n", "# parameters", "\n", "tmp_params", "=", "[", "tf", ".", "Variable", "(", "param", ",", "trainable", "=", "False", ")", "\n", "for", "param", "in", "var_list", "]", "\n", "# Define the swapping operation", "\n", "param_to_tmp", "=", "[", "tf", ".", "assign", "(", "tmp", ",", "param", ")", "\n", "for", "tmp", ",", "param", "in", "safe_zip", "(", "tmp_params", ",", "var_list", ")", "]", "\n", "with", "tf", ".", "control_dependencies", "(", "param_to_tmp", ")", ":", "\n", "      ", "avg_to_param", "=", "[", "tf", ".", "assign", "(", "param", ",", "avg", ")", "\n", "for", "param", ",", "avg", "in", "safe_zip", "(", "var_list", ",", "avg_params", ")", "]", "\n", "", "with", "tf", ".", "control_dependencies", "(", "avg_to_param", ")", ":", "\n", "      ", "tmp_to_avg", "=", "[", "tf", ".", "assign", "(", "avg", ",", "tmp", ")", "\n", "for", "avg", ",", "tmp", "in", "safe_zip", "(", "avg_params", ",", "tmp_params", ")", "]", "\n", "", "swap", "=", "tmp_to_avg", "\n", "\n", "", "batch_size", "=", "args", ".", "batch_size", "\n", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "device_batch_size", "=", "batch_size", "//", "num_devices", "\n", "\n", "if", "init_all", ":", "\n", "    ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "", "else", ":", "\n", "    ", "initialize_uninitialized_global_variables", "(", "sess", ")", "\n", "\n", "", "for", "epoch", "in", "xrange", "(", "args", ".", "nb_epochs", ")", ":", "\n", "    ", "if", "dataset_train", "is", "not", "None", ":", "\n", "      ", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "dataset_size", ")", "/", "batch_size", ")", ")", "\n", "", "else", ":", "\n", "# Indices to shuffle training set", "\n", "      ", "index_shuf", "=", "list", "(", "range", "(", "len", "(", "x_train", ")", ")", ")", "\n", "# Randomly repeat a few training examples each epoch to avoid", "\n", "# having a too-small batch", "\n", "while", "len", "(", "index_shuf", ")", "%", "batch_size", "!=", "0", ":", "\n", "        ", "index_shuf", ".", "append", "(", "rng", ".", "randint", "(", "len", "(", "x_train", ")", ")", ")", "\n", "", "nb_batches", "=", "len", "(", "index_shuf", ")", "//", "batch_size", "\n", "rng", ".", "shuffle", "(", "index_shuf", ")", "\n", "# Shuffling here versus inside the loop doesn't seem to affect", "\n", "# timing very much, but shuffling here makes the code slightly", "\n", "# easier to read", "\n", "x_train_shuffled", "=", "x_train", "[", "index_shuf", "]", "\n", "y_train_shuffled", "=", "y_train", "[", "index_shuf", "]", "\n", "\n", "", "prev", "=", "time", ".", "time", "(", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "      ", "if", "dataset_train", "is", "not", "None", ":", "\n", "        ", "x_train_shuffled", ",", "y_train_shuffled", "=", "sess", ".", "run", "(", "data_iterator", ")", "\n", "start", ",", "end", "=", "0", ",", "batch_size", "\n", "", "else", ":", "\n", "# Compute batch start and end indices", "\n", "        ", "start", "=", "batch", "*", "batch_size", "\n", "end", "=", "(", "batch", "+", "1", ")", "*", "batch_size", "\n", "# Perform one training step", "\n", "diff", "=", "end", "-", "start", "\n", "assert", "diff", "==", "batch_size", "\n", "\n", "", "feed_dict", "=", "{", "epoch_tf", ":", "epoch", ",", "batch_tf", ":", "batch", "}", "\n", "for", "dev_idx", "in", "xrange", "(", "num_devices", ")", ":", "\n", "        ", "cur_start", "=", "start", "+", "dev_idx", "*", "device_batch_size", "\n", "cur_end", "=", "start", "+", "(", "dev_idx", "+", "1", ")", "*", "device_batch_size", "\n", "feed_dict", "[", "xs", "[", "dev_idx", "]", "]", "=", "x_train_shuffled", "[", "cur_start", ":", "cur_end", "]", "\n", "feed_dict", "[", "ys", "[", "dev_idx", "]", "]", "=", "y_train_shuffled", "[", "cur_start", ":", "cur_end", "]", "\n", "", "if", "cur_end", "!=", "end", "and", "dataset_train", "is", "None", ":", "\n", "        ", "msg", "=", "(", "\"batch_size (%d) must be a multiple of num_devices \"", "\n", "\"(%d).\\nCUDA_VISIBLE_DEVICES: %s\"", "\n", "\"\\ndevices: %s\"", ")", "\n", "args", "=", "(", "batch_size", ",", "num_devices", ",", "\n", "os", ".", "environ", "[", "'CUDA_VISIBLE_DEVICES'", "]", ",", "\n", "str", "(", "devices", ")", ")", "\n", "raise", "ValueError", "(", "msg", "%", "args", ")", "\n", "", "if", "feed", "is", "not", "None", ":", "\n", "        ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "\n", "", "_", ",", "loss_numpy", "=", "sess", ".", "run", "(", "\n", "[", "train_step", ",", "loss_value", "]", ",", "feed_dict", "=", "feed_dict", ")", "\n", "\n", "if", "np", ".", "abs", "(", "loss_numpy", ")", ">", "loss_threshold", ":", "\n", "        ", "raise", "ValueError", "(", "\"Extreme loss during training: \"", ",", "loss_numpy", ")", "\n", "", "if", "np", ".", "isnan", "(", "loss_numpy", ")", "or", "np", ".", "isinf", "(", "loss_numpy", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"NaN/Inf loss during training\"", ")", "\n", "", "", "assert", "(", "dataset_train", "is", "not", "None", "or", "\n", "end", "==", "len", "(", "index_shuf", ")", ")", "# Check that all examples were used", "\n", "cur", "=", "time", ".", "time", "(", ")", "\n", "_logger", ".", "info", "(", "\"Epoch \"", "+", "str", "(", "epoch", ")", "+", "\" took \"", "+", "\n", "str", "(", "cur", "-", "prev", ")", "+", "\" seconds\"", ")", "\n", "if", "evaluate", "is", "not", "None", ":", "\n", "      ", "if", "use_ema", ":", "\n", "# Before running evaluation, load the running average", "\n", "# parameters into the live slot, so we can see how well", "\n", "# the EMA parameters are performing", "\n", "        ", "sess", ".", "run", "(", "swap", ")", "\n", "", "evaluate", "(", ")", "\n", "if", "use_ema", ":", "\n", "# Swap the parameters back, so that we continue training", "\n", "# on the live parameters", "\n", "        ", "sess", ".", "run", "(", "swap", ")", "\n", "", "", "", "if", "use_ema", ":", "\n", "# When training is done, swap the running average parameters into", "\n", "# the live slot, so that we use them when we deploy the model", "\n", "    ", "sess", ".", "run", "(", "swap", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.train.avg_grads": [[277, 310], ["zip", "len", "all", "average_grads.append", "tensorflow.add_n", "len"], "function", ["None"], ["", "def", "avg_grads", "(", "tower_grads", ")", ":", "\n", "  ", "\"\"\"Calculate the average gradient for each shared variable across all\n  towers.\n  Note that this function provides a synchronization point across all towers.\n  Args:\n    tower_grads: List of lists of (gradient, variable) tuples. The outer list\n      is over individual gradients. The inner list is over the gradient\n      calculation for each tower.\n  Returns:\n     List of pairs of (gradient, variable) where the gradient has been\n     averaged across all towers.\n\n  Modified from this tutorial: https://tinyurl.com/n3jr2vm\n  \"\"\"", "\n", "if", "len", "(", "tower_grads", ")", "==", "1", ":", "\n", "    ", "return", "tower_grads", "[", "0", "]", "\n", "", "average_grads", "=", "[", "]", "\n", "for", "grad_and_vars", "in", "zip", "(", "*", "tower_grads", ")", ":", "\n", "# Note that each grad_and_vars looks like the following:", "\n", "#   ((grad0_gpu0, var0_gpu0), ... , (grad0_gpuN, var0_gpuN))", "\n", "    ", "grads", "=", "[", "g", "for", "g", ",", "_", "in", "grad_and_vars", "]", "\n", "\n", "# Average over the 'tower' dimension.", "\n", "grad", "=", "tf", ".", "add_n", "(", "grads", ")", "/", "len", "(", "grads", ")", "\n", "\n", "# Keep in mind that the Variables are redundant because they are shared", "\n", "# across towers. So .. we will just return the first tower's pointer to", "\n", "# the Variable.", "\n", "v", "=", "grad_and_vars", "[", "0", "]", "[", "1", "]", "\n", "assert", "all", "(", "v", "is", "grad_and_var", "[", "1", "]", "for", "grad_and_var", "in", "grad_and_vars", ")", "\n", "grad_and_var", "=", "(", "grad", ",", "v", ")", "\n", "average_grads", ".", "append", "(", "grad_and_var", ")", "\n", "", "return", "average_grads", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.__init__": [[46, 52], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "kwargs", "=", "None", ")", ":", "\n", "    ", "if", "kwargs", "is", "None", ":", "\n", "      ", "kwargs", "=", "{", "}", "\n", "", "if", "\"self\"", "in", "kwargs", ":", "\n", "      ", "del", "kwargs", "[", "\"self\"", "]", "\n", "", "self", ".", "kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_factory": [[53, 58], ["dataset.Factory", "type"], "methods", ["None"], ["", "def", "get_factory", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns a picklable callable that recreates the dataset.\n    \"\"\"", "\n", "\n", "return", "Factory", "(", "type", "(", "self", ")", ",", "self", ".", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_set": [[59, 65], ["getattr", "getattr"], "methods", ["None"], ["", "def", "get_set", "(", "self", ",", "which_set", ")", ":", "\n", "    ", "\"\"\"Returns the training set or test set as an (x_data, y_data) tuple.\n    :param which_set: 'train' or 'test'\n    \"\"\"", "\n", "return", "(", "getattr", "(", "self", ",", "'x_'", "+", "which_set", ")", ",", "\n", "getattr", "(", "self", ",", "'y_'", "+", "which_set", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.to_tensorflow": [[66, 68], ["NotImplementedError"], "methods", ["None"], ["", "def", "to_tensorflow", "(", "self", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.in_memory_dataset": [[69, 82], ["tensorflow.data.Dataset.range", "d.shuffle.shuffle.map", "d.shuffle.shuffle.repeat", "d.shuffle.shuffle.shuffle", "tensorflow.py_func"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "in_memory_dataset", "(", "cls", ",", "x", ",", "y", ",", "shuffle", "=", "None", ",", "repeat", "=", "True", ")", ":", "\n", "    ", "assert", "x", ".", "shape", "[", "0", "]", "==", "y", ".", "shape", "[", "0", "]", "\n", "d", "=", "tf", ".", "data", ".", "Dataset", ".", "range", "(", "x", ".", "shape", "[", "0", "]", ")", "\n", "if", "repeat", ":", "\n", "      ", "d", "=", "d", ".", "repeat", "(", ")", "\n", "", "if", "shuffle", ":", "\n", "      ", "d", "=", "d", ".", "shuffle", "(", "shuffle", ")", "\n", "\n", "", "def", "lookup", "(", "p", ")", ":", "\n", "      ", "return", "x", "[", "p", "]", ",", "y", "[", "p", "]", "\n", "", "d", "=", "d", ".", "map", "(", "lambda", "i", ":", "tf", ".", "py_func", "(", "lookup", ",", "[", "i", "]", ",", "[", "tf", ".", "float32", "]", "*", "2", ")", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.MNIST.__init__": [[89, 110], ["locals", "dataset.Dataset.__init__", "dataset.data_mnist", "x_train.astype", "y_train.astype", "x_test.astype", "y_test.astype"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.data_mnist"], ["def", "__init__", "(", "self", ",", "train_start", "=", "0", ",", "train_end", "=", "60000", ",", "test_start", "=", "0", ",", "\n", "test_end", "=", "10000", ",", "center", "=", "False", ",", "max_val", "=", "1.", ")", ":", "\n", "    ", "kwargs", "=", "locals", "(", ")", "\n", "if", "'__class__'", "in", "kwargs", ":", "\n", "      ", "del", "kwargs", "[", "'__class__'", "]", "\n", "", "super", "(", "MNIST", ",", "self", ")", ".", "__init__", "(", "kwargs", ")", "\n", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", "=", "data_mnist", "(", "train_start", "=", "train_start", ",", "\n", "train_end", "=", "train_end", ",", "\n", "test_start", "=", "test_start", ",", "\n", "test_end", "=", "test_end", ")", "\n", "\n", "if", "center", ":", "\n", "      ", "x_train", "=", "x_train", "*", "2.", "-", "1.", "\n", "x_test", "=", "x_test", "*", "2.", "-", "1.", "\n", "", "x_train", "*=", "max_val", "\n", "x_test", "*=", "max_val", "\n", "\n", "self", ".", "x_train", "=", "x_train", ".", "astype", "(", "'float32'", ")", "\n", "self", ".", "y_train", "=", "y_train", ".", "astype", "(", "'float32'", ")", "\n", "self", ".", "x_test", "=", "x_test", ".", "astype", "(", "'float32'", ")", "\n", "self", ".", "y_test", "=", "y_test", ".", "astype", "(", "'float32'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.MNIST.to_tensorflow": [[111, 114], ["dataset.MNIST.in_memory_dataset", "dataset.MNIST.in_memory_dataset"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.in_memory_dataset", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.in_memory_dataset"], ["", "def", "to_tensorflow", "(", "self", ",", "shuffle", "=", "4096", ")", ":", "\n", "    ", "return", "(", "self", ".", "in_memory_dataset", "(", "self", ".", "x_train", ",", "self", ".", "y_train", ",", "shuffle", ")", ",", "\n", "self", ".", "in_memory_dataset", "(", "self", ".", "x_test", ",", "self", ".", "y_test", ",", "repeat", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.CIFAR10.__init__": [[124, 147], ["locals", "dataset.Dataset.__init__", "dataset.data_cifar10"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.data_cifar10"], ["def", "__init__", "(", "self", ",", "train_start", "=", "0", ",", "train_end", "=", "60000", ",", "test_start", "=", "0", ",", "\n", "test_end", "=", "10000", ",", "center", "=", "False", ",", "max_val", "=", "1.", ")", ":", "\n", "    ", "kwargs", "=", "locals", "(", ")", "\n", "if", "'__class__'", "in", "kwargs", ":", "\n", "      ", "del", "kwargs", "[", "'__class__'", "]", "\n", "", "super", "(", "CIFAR10", ",", "self", ")", ".", "__init__", "(", "kwargs", ")", "\n", "packed", "=", "data_cifar10", "(", "train_start", "=", "train_start", ",", "\n", "train_end", "=", "train_end", ",", "\n", "test_start", "=", "test_start", ",", "\n", "test_end", "=", "test_end", ")", "\n", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", "=", "packed", "\n", "\n", "if", "center", ":", "\n", "      ", "x_train", "=", "x_train", "*", "2.", "-", "1.", "\n", "x_test", "=", "x_test", "*", "2.", "-", "1.", "\n", "", "x_train", "*=", "max_val", "\n", "x_test", "*=", "max_val", "\n", "\n", "self", ".", "x_train", "=", "x_train", "\n", "self", ".", "y_train", "=", "y_train", "\n", "self", ".", "x_test", "=", "x_test", "\n", "self", ".", "y_test", "=", "y_test", "\n", "self", ".", "max_val", "=", "max_val", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.CIFAR10.to_tensorflow": [[148, 152], ["dataset.CIFAR10.in_memory_dataset", "dataset.CIFAR10.in_memory_dataset"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.in_memory_dataset", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.in_memory_dataset"], ["", "def", "to_tensorflow", "(", "self", ",", "shuffle", "=", "4096", ")", ":", "\n", "# This is much more efficient with data augmentation, see tutorials.", "\n", "    ", "return", "(", "self", ".", "in_memory_dataset", "(", "self", ".", "x_train", ",", "self", ".", "y_train", ",", "shuffle", ")", ",", "\n", "self", ".", "in_memory_dataset", "(", "self", ".", "x_test", ",", "self", ".", "y_test", ",", "repeat", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Factory.__init__": [[159, 162], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "cls", ",", "kwargs", ")", ":", "\n", "    ", "self", ".", "cls", "=", "cls", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Factory.__call__": [[163, 167], ["dataset.Factory.cls"], "methods", ["None"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "\"\"\"Returns the created object.\n    \"\"\"", "\n", "return", "self", ".", "cls", "(", "**", "self", ".", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.maybe_download_file": [[169, 185], ["os.path.join", "os.path.isfile", "tempfile.gettempdir", "urlretrieve", "url.rfind"], "function", ["None"], ["", "", "def", "maybe_download_file", "(", "url", ",", "datadir", "=", "None", ",", "force", "=", "False", ")", ":", "\n", "  ", "try", ":", "\n", "    ", "from", "urllib", ".", "request", "import", "urlretrieve", "\n", "", "except", "ImportError", ":", "\n", "    ", "from", "urllib", "import", "urlretrieve", "\n", "\n", "", "if", "not", "datadir", ":", "\n", "    ", "datadir", "=", "tempfile", ".", "gettempdir", "(", ")", "\n", "", "file_name", "=", "url", "[", "url", ".", "rfind", "(", "\"/\"", ")", "+", "1", ":", "]", "\n", "dest_file", "=", "os", ".", "path", ".", "join", "(", "datadir", ",", "file_name", ")", "\n", "\n", "isfile", "=", "os", ".", "path", ".", "isfile", "(", "dest_file", ")", "\n", "\n", "if", "force", "or", "not", "isfile", ":", "\n", "    ", "urlretrieve", "(", "url", ",", "dest_file", ")", "\n", "", "return", "dest_file", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.download_and_parse_mnist_file": [[187, 228], ["os.path.join", "dataset.maybe_download_file", "open_fn", "file_descriptor.read", "struct.unpack", "struct.unpack", "array.array", "array.array.byteswap", "functools.reduce", "numpy.array().reshape", "os.path.splitext", "len", "data_type.encode.encode", "file_descriptor.read", "file_descriptor.read", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.maybe_download_file"], ["", "def", "download_and_parse_mnist_file", "(", "file_name", ",", "datadir", "=", "None", ",", "force", "=", "False", ")", ":", "\n", "  ", "url", "=", "os", ".", "path", ".", "join", "(", "'http://yann.lecun.com/exdb/mnist/'", ",", "file_name", ")", "\n", "file_name", "=", "maybe_download_file", "(", "url", ",", "datadir", "=", "datadir", ",", "force", "=", "force", ")", "\n", "\n", "# Open the file and unzip it if necessary", "\n", "if", "os", ".", "path", ".", "splitext", "(", "file_name", ")", "[", "1", "]", "==", "'.gz'", ":", "\n", "    ", "open_fn", "=", "gzip", ".", "open", "\n", "", "else", ":", "\n", "    ", "open_fn", "=", "open", "\n", "\n", "# Parse the file", "\n", "", "with", "open_fn", "(", "file_name", ",", "'rb'", ")", "as", "file_descriptor", ":", "\n", "    ", "header", "=", "file_descriptor", ".", "read", "(", "4", ")", "\n", "assert", "len", "(", "header", ")", "==", "4", "\n", "\n", "zeros", ",", "data_type", ",", "n_dims", "=", "struct", ".", "unpack", "(", "'>HBB'", ",", "header", ")", "\n", "assert", "zeros", "==", "0", "\n", "\n", "hex_to_data_type", "=", "{", "\n", "0x08", ":", "'B'", ",", "\n", "0x09", ":", "'b'", ",", "\n", "0x0b", ":", "'h'", ",", "\n", "0x0c", ":", "'i'", ",", "\n", "0x0d", ":", "'f'", ",", "\n", "0x0e", ":", "'d'", "}", "\n", "data_type", "=", "hex_to_data_type", "[", "data_type", "]", "\n", "\n", "# data_type unicode to ascii conversion (Python2 fix)", "\n", "if", "sys", ".", "version_info", "[", "0", "]", "<", "3", ":", "\n", "      ", "data_type", "=", "data_type", ".", "encode", "(", "'ascii'", ",", "'ignore'", ")", "\n", "\n", "", "dim_sizes", "=", "struct", ".", "unpack", "(", "\n", "'>'", "+", "'I'", "*", "n_dims", ",", "\n", "file_descriptor", ".", "read", "(", "4", "*", "n_dims", ")", ")", "\n", "\n", "data", "=", "array", ".", "array", "(", "data_type", ",", "file_descriptor", ".", "read", "(", ")", ")", "\n", "data", ".", "byteswap", "(", ")", "\n", "\n", "desired_items", "=", "functools", ".", "reduce", "(", "operator", ".", "mul", ",", "dim_sizes", ")", "\n", "assert", "len", "(", "data", ")", "==", "desired_items", "\n", "return", "np", ".", "array", "(", "data", ")", ".", "reshape", "(", "dim_sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.data_mnist": [[230, 267], ["tempfile.gettempdir", "isinstance", "isinstance", "isinstance", "isinstance", "dataset.download_and_parse_mnist_file", "dataset.download_and_parse_mnist_file", "numpy.expand_dims", "numpy.expand_dims", "cleverhans.utils.to_categorical", "cleverhans.utils.to_categorical", "dataset.download_and_parse_mnist_file", "dataset.download_and_parse_mnist_file"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file"], ["", "", "def", "data_mnist", "(", "datadir", "=", "tempfile", ".", "gettempdir", "(", ")", ",", "train_start", "=", "0", ",", "\n", "train_end", "=", "60000", ",", "test_start", "=", "0", ",", "test_end", "=", "10000", ")", ":", "\n", "  ", "\"\"\"\n  Load and preprocess MNIST dataset\n  :param datadir: path to folder where data should be stored\n  :param train_start: index of first training set example\n  :param train_end: index of last training set example\n  :param test_start: index of first test set example\n  :param test_end: index of last test set example\n  :return: tuple of four arrays containing training data, training labels,\n           testing data and testing labels.\n  \"\"\"", "\n", "assert", "isinstance", "(", "train_start", ",", "int", ")", "\n", "assert", "isinstance", "(", "train_end", ",", "int", ")", "\n", "assert", "isinstance", "(", "test_start", ",", "int", ")", "\n", "assert", "isinstance", "(", "test_end", ",", "int", ")", "\n", "\n", "X_train", "=", "download_and_parse_mnist_file", "(", "\n", "'train-images-idx3-ubyte.gz'", ",", "datadir", "=", "datadir", ")", "/", "255.", "\n", "Y_train", "=", "download_and_parse_mnist_file", "(", "\n", "'train-labels-idx1-ubyte.gz'", ",", "datadir", "=", "datadir", ")", "\n", "X_test", "=", "download_and_parse_mnist_file", "(", "\n", "'t10k-images-idx3-ubyte.gz'", ",", "datadir", "=", "datadir", ")", "/", "255.", "\n", "Y_test", "=", "download_and_parse_mnist_file", "(", "\n", "'t10k-labels-idx1-ubyte.gz'", ",", "datadir", "=", "datadir", ")", "\n", "\n", "X_train", "=", "np", ".", "expand_dims", "(", "X_train", ",", "-", "1", ")", "\n", "X_test", "=", "np", ".", "expand_dims", "(", "X_test", ",", "-", "1", ")", "\n", "\n", "X_train", "=", "X_train", "[", "train_start", ":", "train_end", "]", "\n", "Y_train", "=", "Y_train", "[", "train_start", ":", "train_end", "]", "\n", "X_test", "=", "X_test", "[", "test_start", ":", "test_end", "]", "\n", "Y_test", "=", "Y_test", "[", "test_start", ":", "test_end", "]", "\n", "\n", "Y_train", "=", "utils", ".", "to_categorical", "(", "Y_train", ",", "nb_classes", "=", "10", ")", "\n", "Y_test", "=", "utils", ".", "to_categorical", "(", "Y_test", ",", "nb_classes", "=", "10", ")", "\n", "return", "X_train", ",", "Y_train", ",", "X_test", ",", "Y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.data_cifar10": [[269, 308], ["cifar10.load_data", "x_train.reshape.astype", "x_test.reshape.astype", "print", "print", "print", "np_utils.to_categorical", "np_utils.to_categorical", "tensorflow.keras.backend.image_data_format", "x_train.reshape.reshape", "x_test.reshape.reshape", "x_train.reshape.reshape", "x_test.reshape.reshape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical"], ["", "def", "data_cifar10", "(", "train_start", "=", "0", ",", "train_end", "=", "50000", ",", "test_start", "=", "0", ",", "test_end", "=", "10000", ")", ":", "\n", "  ", "\"\"\"\n  Preprocess CIFAR10 dataset\n  :return:\n  \"\"\"", "\n", "\n", "\n", "# These values are specific to CIFAR10", "\n", "img_rows", "=", "32", "\n", "img_cols", "=", "32", "\n", "nb_classes", "=", "10", "\n", "\n", "# the data, shuffled and split between train and test sets", "\n", "(", "x_train", ",", "y_train", ")", ",", "(", "x_test", ",", "y_test", ")", "=", "cifar10", ".", "load_data", "(", ")", "\n", "\n", "if", "keras", ".", "backend", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "    ", "x_train", "=", "x_train", ".", "reshape", "(", "x_train", ".", "shape", "[", "0", "]", ",", "3", ",", "img_rows", ",", "img_cols", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "x_test", ".", "shape", "[", "0", "]", ",", "3", ",", "img_rows", ",", "img_cols", ")", "\n", "", "else", ":", "\n", "    ", "x_train", "=", "x_train", ".", "reshape", "(", "x_train", ".", "shape", "[", "0", "]", ",", "img_rows", ",", "img_cols", ",", "3", ")", "\n", "x_test", "=", "x_test", ".", "reshape", "(", "x_test", ".", "shape", "[", "0", "]", ",", "img_rows", ",", "img_cols", ",", "3", ")", "\n", "", "x_train", "=", "x_train", ".", "astype", "(", "'float32'", ")", "\n", "x_test", "=", "x_test", ".", "astype", "(", "'float32'", ")", "\n", "x_train", "/=", "255", "\n", "x_test", "/=", "255", "\n", "print", "(", "'x_train shape:'", ",", "x_train", ".", "shape", ")", "\n", "print", "(", "x_train", ".", "shape", "[", "0", "]", ",", "'train samples'", ")", "\n", "print", "(", "x_test", ".", "shape", "[", "0", "]", ",", "'test samples'", ")", "\n", "\n", "# convert class vectors to binary class matrices", "\n", "y_train", "=", "np_utils", ".", "to_categorical", "(", "y_train", ",", "nb_classes", ")", "\n", "y_test", "=", "np_utils", ".", "to_categorical", "(", "y_test", ",", "nb_classes", ")", "\n", "\n", "x_train", "=", "x_train", "[", "train_start", ":", "train_end", ",", ":", ",", ":", ",", ":", "]", "\n", "y_train", "=", "y_train", "[", "train_start", ":", "train_end", ",", ":", "]", "\n", "x_test", "=", "x_test", "[", "test_start", ":", "test_end", ",", ":", "]", "\n", "y_test", "=", "y_test", "[", "test_start", ":", "test_end", ",", ":", "]", "\n", "\n", "return", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.Loss.__init__": [[29, 63], ["isinstance", "callable", "isinstance", "TypeError", "warnings.warn", "Wrapper", "cleverhans.model.Model", "object.__init__", "loss.Loss.f"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "hparams", "=", "None", ",", "attack", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param model: Model instance, the model on which to apply the loss.\n    :param hparams: dict, hyper-parameters for the loss.\n    :param attack: cleverhans.attacks.Attack instance\n    \"\"\"", "\n", "assert", "isinstance", "(", "model", ",", "Model", ")", "\n", "standard", "=", "attack", "is", "None", "or", "isinstance", "(", "attack", ",", "Attack", ")", "\n", "deprecated", "=", "callable", "(", "attack", ")", "\n", "if", "not", "standard", "and", "not", "deprecated", ":", "\n", "      ", "raise", "TypeError", "(", "\"`attack` must be `None` or `Attack` subclass instance\"", ")", "\n", "", "if", "deprecated", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"callable attacks are deprecated, switch to an Attack \"", "\n", "\"subclass. callable attacks will not be supported after \"", "\n", "\"2019-05-05.\"", ")", "\n", "class", "Wrapper", "(", "Attack", ")", ":", "\n", "        ", "\"\"\"\n        Temporary wrapper class to be removed when deprecated callable\n        arguments are removed.\n\n        :param f: a callable object implementing the attack\n        \"\"\"", "\n", "def", "__init__", "(", "self", ",", "f", ")", ":", "\n", "          ", "dummy_model", "=", "Model", "(", ")", "\n", "super", "(", "Wrapper", ",", "self", ")", ".", "__init__", "(", "model", "=", "dummy_model", ")", "\n", "self", ".", "f", "=", "f", "\n", "\n", "", "def", "generate", "(", "self", ",", "x", ")", ":", "\n", "          ", "return", "self", ".", "f", "(", "x", ")", "\n", "\n", "", "", "attack", "=", "Wrapper", "(", "attack", ")", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "hparams", "=", "hparams", "\n", "self", ".", "attack", "=", "attack", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.Loss.save": [[64, 70], ["json.dump", "dict", "open", "os.path.join"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "    ", "\"\"\"Save loss in json format\n    \"\"\"", "\n", "json", ".", "dump", "(", "dict", "(", "loss", "=", "self", ".", "__class__", ".", "__name__", ",", "\n", "params", "=", "self", ".", "hparams", ")", ",", "\n", "open", "(", "os", ".", "path", ".", "join", "(", "path", ",", "'loss.json'", ")", ",", "'wb'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.Loss.fprop": [[71, 82], ["None"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"Forward propagate the loss.\n    Loss should be a scalar value, independent of batch size (i.e. use\n    reduce_mean over batch axis, don't use reduce_sum or return a tensor).\n    Scalar losses are easier to add together, e.g. through `WeightedSum`.\n    Mean losses are easier to redistribute across multiple replicas without\n    needing to change learning rates, etc.\n    :param x: tensor, a batch of inputs.\n    :param y: tensor, a batch of outputs (1-hot labels typically).\n    \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.WeightedSum.__init__": [[89, 93], ["loss.Loss.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "terms", ")", ":", "\n", "    ", "self", ".", "terms", "=", "terms", "\n", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.WeightedSum.fprop": [[94, 112], ["cleverhans.utils.safe_zip", "cleverhans.utils.safe_zip", "tensorflow.add_n", "isinstance", "hasattr", "TypeError", "loss.fprop", "len", "ValueError", "cleverhans.utils.safe_zip", "str", "loss.get_shape", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "weights", ",", "loss_objects", "=", "safe_zip", "(", "*", "self", ".", "terms", ")", "\n", "for", "weight", "in", "weights", ":", "\n", "      ", "if", "isinstance", "(", "weight", ",", "float", ")", ":", "\n", "        ", "continue", "\n", "", "if", "hasattr", "(", "weight", ",", "'ndim'", ")", ":", "\n", "        ", "assert", "weight", ".", "ndim", "==", "0", "\n", "continue", "\n", "", "raise", "TypeError", "(", "\"weight of %s is not a type that this function \"", "\n", "\"knows it can accept yet\"", "%", "str", "(", "weight", ")", ")", "\n", "", "losses", "=", "[", "loss", ".", "fprop", "(", "x", ",", "y", ",", "**", "kwargs", ")", "for", "loss", "in", "loss_objects", "]", "\n", "for", "loss", ",", "loss_object", "in", "safe_zip", "(", "losses", ",", "loss_objects", ")", ":", "\n", "      ", "if", "len", "(", "loss", ".", "get_shape", "(", ")", ")", ">", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"%s.fprop returned a non-scalar value\"", "%", "\n", "str", "(", "loss_object", ")", ")", "\n", "", "", "terms", "=", "[", "weight", "*", "loss", "for", "weight", ",", "loss", "in", "safe_zip", "(", "weights", ",", "losses", ")", "]", "\n", "\n", "return", "tf", ".", "add_n", "(", "terms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.CrossEntropy.__init__": [[126, 137], ["loss.Loss.__init__", "ValueError", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "smoothing", "=", "0.", ",", "attack", "=", "None", ",", "pass_y", "=", "False", ",", "\n", "adv_coeff", "=", "0.5", ",", "attack_params", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "if", "smoothing", "<", "0", "or", "smoothing", ">", "1", ":", "\n", "      ", "raise", "ValueError", "(", "'Smoothing must be in [0, 1]'", ",", "smoothing", ")", "\n", "", "self", ".", "kwargs", "=", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ",", "attack", ")", "\n", "self", ".", "smoothing", "=", "smoothing", "\n", "self", ".", "adv_coeff", "=", "adv_coeff", "\n", "self", ".", "pass_y", "=", "pass_y", "\n", "self", ".", "attack_params", "=", "attack_params", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.CrossEntropy.fprop": [[138, 169], ["kwargs.update", "numpy.allclose", "sum", "copy.copy", "tuple", "sum", "sum.CrossEntropy.model.get_logits", "sum.CrossEntropy.attack.generate", "y.assign_sub", "tensorflow.reduce_mean", "cleverhans.utils.safe_zip", "tensorflow.cast", "cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "kwargs", ".", "update", "(", "self", ".", "kwargs", ")", "\n", "if", "self", ".", "attack", "is", "not", "None", ":", "\n", "      ", "attack_params", "=", "copy", ".", "copy", "(", "self", ".", "attack_params", ")", "\n", "if", "attack_params", "is", "None", ":", "\n", "        ", "attack_params", "=", "{", "}", "\n", "", "if", "self", ".", "pass_y", ":", "\n", "        ", "attack_params", "[", "'y'", "]", "=", "y", "\n", "", "x", "=", "x", ",", "self", ".", "attack", ".", "generate", "(", "x", ",", "**", "attack_params", ")", "\n", "coeffs", "=", "[", "1.", "-", "self", ".", "adv_coeff", ",", "self", ".", "adv_coeff", "]", "\n", "if", "self", ".", "adv_coeff", "==", "1.", ":", "\n", "        ", "x", "=", "(", "x", "[", "1", "]", ",", ")", "\n", "coeffs", "=", "(", "coeffs", "[", "1", "]", ",", ")", "\n", "", "", "else", ":", "\n", "      ", "x", "=", "tuple", "(", "[", "x", "]", ")", "\n", "coeffs", "=", "[", "1.", "]", "\n", "", "assert", "np", ".", "allclose", "(", "sum", "(", "coeffs", ")", ",", "1.", ")", "\n", "\n", "# Catching RuntimeError: Variable -= value not supported by tf.eager.", "\n", "try", ":", "\n", "      ", "y", "-=", "self", ".", "smoothing", "*", "(", "y", "-", "1.", "/", "tf", ".", "cast", "(", "y", ".", "shape", "[", "-", "1", "]", ",", "y", ".", "dtype", ")", ")", "\n", "", "except", "RuntimeError", ":", "\n", "      ", "y", ".", "assign_sub", "(", "self", ".", "smoothing", "*", "(", "y", "-", "1.", "/", "tf", ".", "cast", "(", "y", ".", "shape", "[", "-", "1", "]", ",", "\n", "y", ".", "dtype", ")", ")", ")", "\n", "\n", "", "logits", "=", "[", "self", ".", "model", ".", "get_logits", "(", "x", ",", "**", "kwargs", ")", "for", "x", "in", "x", "]", "\n", "loss", "=", "sum", "(", "\n", "coeff", "*", "tf", ".", "reduce_mean", "(", "softmax_cross_entropy_with_logits", "(", "labels", "=", "y", ",", "\n", "logits", "=", "logit", ")", ")", "\n", "for", "coeff", ",", "logit", "in", "safe_zip", "(", "coeffs", ",", "logits", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.MixUp.__init__": [[176, 180], ["loss.Loss.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "beta", ",", "**", "kwargs", ")", ":", "\n", "    ", "del", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.MixUp.fprop": [[181, 194], ["tensorflow.maximum", "tensorflow.reshape", "tf.reduce_mean.MixUp.model.get_logits", "tensorflow.reduce_mean", "tensorflow.device", "tf_distributions.Beta", "mix.sample.sample.sample", "cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.shape", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "with", "tf", ".", "device", "(", "'/CPU:0'", ")", ":", "\n", "# Prevent error complaining GPU kernels unavailable for this.", "\n", "      ", "mix", "=", "tf_distributions", ".", "Beta", "(", "self", ".", "beta", ",", "self", ".", "beta", ")", "\n", "mix", "=", "mix", ".", "sample", "(", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", "]", "+", "[", "1", "]", "*", "(", "len", "(", "x", ".", "shape", ")", "-", "1", ")", ")", "\n", "", "mix", "=", "tf", ".", "maximum", "(", "mix", ",", "1", "-", "mix", ")", "\n", "mix_label", "=", "tf", ".", "reshape", "(", "mix", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "xm", "=", "x", "+", "mix", "*", "(", "x", "[", ":", ":", "-", "1", "]", "-", "x", ")", "\n", "ym", "=", "y", "+", "mix_label", "*", "(", "y", "[", ":", ":", "-", "1", "]", "-", "y", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "xm", ",", "**", "kwargs", ")", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "softmax_cross_entropy_with_logits", "(", "labels", "=", "ym", ",", "\n", "logits", "=", "logits", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.FeaturePairing.__init__": [[203, 207], ["loss.Loss.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "weight", ",", "attack", ",", "**", "kwargs", ")", ":", "\n", "    ", "del", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ",", "attack", ")", "\n", "self", ".", "weight", "=", "weight", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.FeaturePairing.fprop": [[208, 221], ["tf.reduce_mean.FeaturePairing.attack.generate", "tf.reduce_mean.FeaturePairing.model.fprop", "tf.reduce_mean.FeaturePairing.model.fprop", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "cleverhans.compat.softmax_cross_entropy_with_logits", "cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.square", "zip"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "x_adv", "=", "self", ".", "attack", ".", "generate", "(", "x", ")", "\n", "d1", "=", "self", ".", "model", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "\n", "d2", "=", "self", ".", "model", ".", "fprop", "(", "x_adv", ",", "**", "kwargs", ")", "\n", "pairing_loss", "=", "[", "tf", ".", "reduce_mean", "(", "tf", ".", "square", "(", "a", "-", "b", ")", ")", "\n", "for", "a", ",", "b", "in", "\n", "zip", "(", "d1", "[", "Model", ".", "O_FEATURES", "]", ",", "d2", "[", "Model", ".", "O_FEATURES", "]", ")", "]", "\n", "pairing_loss", "=", "tf", ".", "reduce_mean", "(", "pairing_loss", ")", "\n", "loss", "=", "tf", ".", "reduce_mean", "(", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "y", ",", "logits", "=", "d1", "[", "Model", ".", "O_LOGITS", "]", ")", ")", "\n", "loss", "+=", "tf", ".", "reduce_mean", "(", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "y", ",", "logits", "=", "d2", "[", "Model", ".", "O_LOGITS", "]", ")", ")", "\n", "return", "loss", "+", "self", ".", "weight", "*", "pairing_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.WeightDecay.fprop": [[225, 232], ["tensorflow.add_n", "tensorflow.nn.l2_loss", "len", "loss.WeightDecay.model.get_params", "tensorflow.add_n.get_shape", "len", "param.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "terms", "=", "[", "tf", ".", "nn", ".", "l2_loss", "(", "param", ")", "\n", "for", "param", "in", "self", ".", "model", ".", "get_params", "(", ")", "\n", "if", "len", "(", "param", ".", "get_shape", "(", ")", ")", ">", "1", "]", "\n", "out", "=", "tf", ".", "add_n", "(", "terms", ")", "\n", "assert", "len", "(", "out", ".", "get_shape", "(", ")", ")", "==", "0", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossCrossEntropy.__init__": [[240, 251], ["loss.Loss.__init__", "ValueError", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "smoothing", "=", "0.", ",", "attack", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructor.\n    :param model: Model instance, the model on which to apply the loss.\n    :param smoothing: float, amount of label smoothing for cross-entropy.\n    :param attack: function, given an input x, return an attacked x'.\n    \"\"\"", "\n", "if", "smoothing", "<", "0", "or", "smoothing", ">", "1", ":", "\n", "      ", "raise", "ValueError", "(", "'Smoothing must be in [0, 1]'", ",", "smoothing", ")", "\n", "", "del", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ",", "attack", ")", "\n", "self", ".", "smoothing", "=", "smoothing", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossCrossEntropy.fprop": [[252, 274], ["sum", "warnings.warn", "tuple", "sum.LossCrossEntropy.model.get_logits", "sum.LossCrossEntropy.attack", "y.assign_sub", "cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "self", ".", "attack", "is", "not", "None", ":", "\n", "      ", "x", "=", "x", ",", "self", ".", "attack", "(", "x", ")", "\n", "", "else", ":", "\n", "      ", "x", "=", "tuple", "(", "[", "x", "]", ")", "\n", "\n", "# Catching RuntimeError: Variable -= value not supported by tf.eager.", "\n", "", "try", ":", "\n", "      ", "y", "-=", "self", ".", "smoothing", "*", "(", "y", "-", "1.", "/", "tf", ".", "cast", "(", "y", ".", "shape", "[", "-", "1", "]", ",", "tf", ".", "float32", ")", ")", "\n", "", "except", "RuntimeError", ":", "\n", "      ", "y", ".", "assign_sub", "(", "self", ".", "smoothing", "*", "(", "y", "-", "1.", "/", "tf", ".", "cast", "(", "y", ".", "shape", "[", "-", "1", "]", ",", "\n", "tf", ".", "float32", ")", ")", ")", "\n", "\n", "", "logits", "=", "[", "self", ".", "model", ".", "get_logits", "(", "x", ",", "**", "kwargs", ")", "for", "x", "in", "x", "]", "\n", "loss", "=", "sum", "(", "\n", "softmax_cross_entropy_with_logits", "(", "labels", "=", "y", ",", "\n", "logits", "=", "logit", ")", "\n", "for", "logit", "in", "logits", ")", "\n", "warnings", ".", "warn", "(", "\"LossCrossEntropy is deprecated, switch to \"", "\n", "\"CrossEntropy. LossCrossEntropy may be removed on \"", "\n", "\"or after 2019-03-06.\"", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossFeaturePairing.__init__": [[280, 289], ["loss.Loss.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "weight", ",", "attack", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructor.\n    :param model: Model instance, the model on which to apply the loss.\n    :param weight: float, with of logic pairing loss.\n    :param attack: function, given an input x, return an attacked x'.\n    \"\"\"", "\n", "del", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ",", "attack", ")", "\n", "self", ".", "weight", "=", "weight", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossFeaturePairing.fprop": [[290, 306], ["cleverhans.compat.softmax_cross_entropy_with_logits.LossFeaturePairing.attack", "cleverhans.compat.softmax_cross_entropy_with_logits.LossFeaturePairing.model.fprop", "cleverhans.compat.softmax_cross_entropy_with_logits.LossFeaturePairing.model.fprop", "tensorflow.reduce_mean", "cleverhans.compat.softmax_cross_entropy_with_logits", "cleverhans.compat.softmax_cross_entropy_with_logits", "warnings.warn", "tensorflow.reduce_mean", "tensorflow.square", "zip"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "x_adv", "=", "self", ".", "attack", "(", "x", ")", "\n", "d1", "=", "self", ".", "model", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "\n", "d2", "=", "self", ".", "model", ".", "fprop", "(", "x_adv", ",", "**", "kwargs", ")", "\n", "pairing_loss", "=", "[", "tf", ".", "reduce_mean", "(", "tf", ".", "square", "(", "a", "-", "b", ")", ")", "\n", "for", "a", ",", "b", "in", "\n", "zip", "(", "d1", "[", "Model", ".", "O_FEATURES", "]", ",", "d2", "[", "Model", ".", "O_FEATURES", "]", ")", "]", "\n", "pairing_loss", "=", "tf", ".", "reduce_mean", "(", "pairing_loss", ")", "\n", "loss", "=", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "y", ",", "logits", "=", "d1", "[", "Model", ".", "O_LOGITS", "]", ")", "\n", "loss", "+=", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "y", ",", "logits", "=", "d2", "[", "Model", ".", "O_LOGITS", "]", ")", "\n", "warnings", ".", "warn", "(", "\"LossFeaturePairing is deprecated, switch to \"", "\n", "\"FeaturePairing. LossFeaturePairing may be removed \"", "\n", "\"on or after 2019-03-06.\"", ")", "\n", "return", "loss", "+", "self", ".", "weight", "*", "pairing_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossMixUp.__init__": [[312, 320], ["loss.Loss.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "beta", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructor.\n    :param model: Model instance, the model on which to apply the loss.\n    :param beta: float, beta distribution parameter for MixUp.\n    \"\"\"", "\n", "del", "kwargs", "\n", "Loss", ".", "__init__", "(", "self", ",", "model", ",", "locals", "(", ")", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.loss.LossMixUp.fprop": [[321, 332], ["tf_distributions.Beta", "mix.sample.sample.sample", "cleverhans.compat.softmax_cross_entropy_with_logits.LossMixUp.model.get_logits", "cleverhans.compat.softmax_cross_entropy_with_logits", "warnings.warn", "tensorflow.shape", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "fprop", "(", "self", ",", "x", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "    ", "mix", "=", "tf_distributions", ".", "Beta", "(", "self", ".", "beta", ",", "self", ".", "beta", ")", "\n", "mix", "=", "mix", ".", "sample", "(", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", "]", "+", "[", "1", "]", "*", "(", "len", "(", "x", ".", "shape", ")", "-", "1", ")", ")", "\n", "xm", "=", "x", "+", "mix", "*", "(", "x", "[", ":", ":", "-", "1", "]", "-", "x", ")", "\n", "ym", "=", "y", "+", "mix", "*", "(", "y", "[", ":", ":", "-", "1", "]", "-", "y", ")", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "xm", ",", "**", "kwargs", ")", "\n", "loss", "=", "softmax_cross_entropy_with_logits", "(", "labels", "=", "ym", ",", "logits", "=", "logits", ")", "\n", "warnings", ".", "warn", "(", "\"LossMixUp is deprecated, switch to \"", "\n", "\"MixUp. LossFeaturePairing may be removed \"", "\n", "\"on or after 2019-03-06.\"", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.train": [[24, 129], ["isinstance", "utils._ArgsWrapper", "tensorflow.train.AdamOptimizer", "tfe.Variable", "tfe.Variable", "six.moves.xrange", "ValueError", "ValueError", "numpy.random.RandomState", "int", "list", "np.random.RandomState.shuffle", "time.time", "range", "time.time", "_logger.info", "os.path.join", "tensorflow.train.Saver", "tf.train.Saver.save", "_logger.info", "_logger.info", "math.ceil", "len", "range", "utils.batch_indices", "tensorflow.assign", "tensorflow.assign", "model.get_params", "tape.gradient", "tf.train.AdamOptimizer.apply_gradients", "len", "evaluate", "len", "len", "tensorflow.GradientTape", "cleverhans.loss.LossCrossEntropy", "cleverhans.loss.LossCrossEntropy.fprop", "zip", "str", "float", "attack.generate", "cleverhans.loss.LossCrossEntropy", "cleverhans.loss.LossCrossEntropy.fprop", "str", "len", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.batch_indices", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["def", "train", "(", "model", ",", "X_train", "=", "None", ",", "Y_train", "=", "None", ",", "save", "=", "False", ",", "\n", "predictions_adv", "=", "None", ",", "evaluate", "=", "None", ",", "\n", "args", "=", "None", ",", "rng", "=", "None", ",", "var_list", "=", "None", ",", "\n", "attack", "=", "None", ",", "attack_args", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Train a TF Eager model\n  :param model: cleverhans.model.Model\n  :param X_train: numpy array with training inputs\n  :param Y_train: numpy array with training outputs\n  :param save: boolean controlling the save operation\n  :param predictions_adv: if set with the adversarial example tensor,\n                          will run adversarial training\n  :param evaluate: function that is run after each training iteration\n                   (typically to display the test/validation accuracy).\n  :param args: dict or argparse `Namespace` object.\n               Should contain `nb_epochs`, `learning_rate`,\n               `batch_size`\n               If save is True, should also contain 'train_dir'\n               and 'filename'\n  :param rng: Instance of numpy.random.RandomState\n  :param var_list: List of variables to train.\n  :param attack: Instance of the class cleverhans.attacks.attacks_eager\n  :param attack_args: Parameters required for the attack.\n  :return: True if model trained\n  \"\"\"", "\n", "assert", "isinstance", "(", "model", ",", "Model", ")", "\n", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "if", "(", "(", "attack", "is", "None", ")", "!=", "(", "attack_args", "is", "None", ")", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\"attack and attack_args must be \"", "\n", "\"passed together.\"", ")", "\n", "", "if", "X_train", "is", "None", "or", "Y_train", "is", "None", ":", "\n", "    ", "raise", "ValueError", "(", "\"X_train argument and Y_train argument \"", "\n", "\"must be supplied.\"", ")", "\n", "# Check that necessary arguments were given (see doc above)", "\n", "", "assert", "args", ".", "nb_epochs", ",", "\"Number of epochs was not given in args dict\"", "\n", "assert", "args", ".", "learning_rate", ",", "\"Learning rate was not given in args dict\"", "\n", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "\n", "if", "save", ":", "\n", "    ", "assert", "args", ".", "train_dir", ",", "\"Directory for save was not given in args dict\"", "\n", "assert", "args", ".", "filename", ",", "\"Filename for save was not given in args dict\"", "\n", "\n", "", "if", "rng", "is", "None", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "# Optimizer", "\n", "", "tfe", "=", "tf", ".", "contrib", ".", "eager", "\n", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "learning_rate", "=", "args", ".", "learning_rate", ")", "\n", "batch_x", "=", "tfe", ".", "Variable", "(", "X_train", "[", "0", ":", "args", ".", "batch_size", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_y", "=", "tfe", ".", "Variable", "(", "Y_train", "[", "0", ":", "args", ".", "batch_size", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "# One epoch of training.", "\n", "for", "epoch", "in", "xrange", "(", "args", ".", "nb_epochs", ")", ":", "\n", "# Compute number of batches", "\n", "    ", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "len", "(", "X_train", ")", ")", "/", "args", ".", "batch_size", ")", ")", "\n", "assert", "nb_batches", "*", "args", ".", "batch_size", ">=", "len", "(", "X_train", ")", "\n", "\n", "# Indices to shuffle training set", "\n", "index_shuf", "=", "list", "(", "range", "(", "len", "(", "X_train", ")", ")", ")", "\n", "rng", ".", "shuffle", "(", "index_shuf", ")", "\n", "\n", "prev", "=", "time", ".", "time", "(", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "\n", "# Compute batch start and end indices", "\n", "      ", "start", ",", "end", "=", "batch_indices", "(", "\n", "batch", ",", "len", "(", "X_train", ")", ",", "args", ".", "batch_size", ")", "\n", "\n", "# Perform one training step", "\n", "tf", ".", "assign", "(", "batch_x", ",", "X_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", ")", "\n", "tf", ".", "assign", "(", "batch_y", ",", "Y_train", "[", "index_shuf", "[", "start", ":", "end", "]", "]", ")", "\n", "# Compute grads", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "# Define loss", "\n", "        ", "loss_clean_obj", "=", "LossCrossEntropy", "(", "model", ",", "smoothing", "=", "0.", ")", "\n", "loss_clean", "=", "loss_clean_obj", ".", "fprop", "(", "x", "=", "batch_x", ",", "y", "=", "batch_y", ")", "\n", "loss", "=", "loss_clean", "\n", "# Adversarial training", "\n", "if", "attack", "is", "not", "None", ":", "\n", "          ", "batch_adv_x", "=", "attack", ".", "generate", "(", "batch_x", ",", "**", "attack_args", ")", "\n", "loss_adv_obj", "=", "LossCrossEntropy", "(", "model", ",", "smoothing", "=", "0.", ")", "\n", "loss_adv", "=", "loss_adv_obj", ".", "fprop", "(", "x", "=", "batch_adv_x", ",", "y", "=", "batch_y", ")", "\n", "loss", "=", "(", "loss_clean", "+", "loss_adv", ")", "/", "2.0", "\n", "# Apply grads", "\n", "", "", "model_variables", "=", "model", ".", "get_params", "(", ")", "\n", "grads", "=", "tape", ".", "gradient", "(", "loss", ",", "model_variables", ")", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "grads", ",", "model_variables", ")", ")", "\n", "\n", "", "assert", "end", ">=", "len", "(", "X_train", ")", "# Check that all examples were used", "\n", "cur", "=", "time", ".", "time", "(", ")", "\n", "_logger", ".", "info", "(", "\"Epoch \"", "+", "str", "(", "epoch", ")", "+", "\" took \"", "+", "\n", "str", "(", "cur", "-", "prev", ")", "+", "\" seconds\"", ")", "\n", "if", "evaluate", "is", "not", "None", ":", "\n", "      ", "evaluate", "(", ")", "\n", "\n", "", "", "if", "save", ":", "\n", "    ", "save_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "train_dir", ",", "args", ".", "filename", ")", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "saver", ".", "save", "(", "save_path", ",", "model_variables", ")", "\n", "_logger", ".", "info", "(", "\"Completed model training and saved at: \"", "+", "\n", "str", "(", "save_path", ")", ")", "\n", "", "else", ":", "\n", "    ", "_logger", ".", "info", "(", "\"Completed model training.\"", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_eval": [[131, 203], ["utils._ArgsWrapper", "int", "numpy.zeros", "numpy.zeros", "tfe.Variable", "tfe.Variable", "range", "len", "ValueError", "ValueError", "math.ceil", "len", "min", "tensorflow.assign", "tensorflow.assign", "tensorflow.equal", "[].sum", "len", "_logger.debug", "len", "attack.generate", "model.get_probs", "model.get_probs", "tensorflow.argmax", "tensorflow.argmax", "float", "len", "str", "tf.equal.numpy"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs"], ["", "def", "model_eval", "(", "model", ",", "X_test", "=", "None", ",", "Y_test", "=", "None", ",", "args", "=", "None", ",", "\n", "attack", "=", "None", ",", "attack_args", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Compute the accuracy of a TF Eager model on some data\n  :param model: instance of cleverhans.model.Model_Eager\n                  with pretrained weights for evaluation.\n  :param X_test: numpy array with training inputs\n  :param Y_test: numpy array with training outputs\n  :param args: dict or argparse `Namespace` object.\n               Should contain `batch_size`\n  :param attack: instance of the class cleverhans.attacks.attacks_eager\n  :param attack_args: parameters required for the attack.\n  :return: a float with the accuracy value\n  \"\"\"", "\n", "args", "=", "_ArgsWrapper", "(", "args", "or", "{", "}", ")", "\n", "\n", "if", "(", "(", "attack", "is", "None", ")", "!=", "(", "attack_args", "is", "None", ")", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\"attack and attack_args must be \"", "\n", "\"passed together.\"", ")", "\n", "", "assert", "args", ".", "batch_size", ",", "\"Batch size was not given in args dict\"", "\n", "if", "X_test", "is", "None", "or", "Y_test", "is", "None", ":", "\n", "    ", "raise", "ValueError", "(", "\"X_test argument and Y_test argument \"", "\n", "\"must be supplied.\"", ")", "\n", "\n", "# Init result var", "\n", "", "accuracy", "=", "0.0", "\n", "\n", "# Compute number of batches", "\n", "nb_batches", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "len", "(", "X_test", ")", ")", "/", "args", ".", "batch_size", ")", ")", "\n", "assert", "nb_batches", "*", "args", ".", "batch_size", ">=", "len", "(", "X_test", ")", "\n", "\n", "X_cur", "=", "np", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", ")", "+", "X_test", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "X_test", ".", "dtype", ")", "\n", "Y_cur", "=", "np", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", ")", "+", "Y_test", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "Y_test", ".", "dtype", ")", "\n", "\n", "tfe", "=", "tf", ".", "contrib", ".", "eager", "\n", "batch_x", "=", "tfe", ".", "Variable", "(", "X_test", "[", "0", ":", "args", ".", "batch_size", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "batch_y", "=", "tfe", ".", "Variable", "(", "Y_test", "[", "0", ":", "args", ".", "batch_size", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "for", "batch", "in", "range", "(", "nb_batches", ")", ":", "\n", "    ", "if", "batch", "%", "100", "==", "0", "and", "batch", ">", "0", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"Batch \"", "+", "str", "(", "batch", ")", ")", "\n", "\n", "# Must not use the `batch_indices` function here, because it", "\n", "# repeats some examples.", "\n", "# It's acceptable to repeat during training, but not eval.", "\n", "", "start", "=", "batch", "*", "args", ".", "batch_size", "\n", "end", "=", "min", "(", "len", "(", "X_test", ")", ",", "start", "+", "args", ".", "batch_size", ")", "\n", "\n", "# The last batch may be smaller than all others. This should not", "\n", "# affect the accuarcy disproportionately.", "\n", "cur_batch_size", "=", "end", "-", "start", "\n", "X_cur", "[", ":", "cur_batch_size", "]", "=", "X_test", "[", "start", ":", "end", "]", "\n", "Y_cur", "[", ":", "cur_batch_size", "]", "=", "Y_test", "[", "start", ":", "end", "]", "\n", "tf", ".", "assign", "(", "batch_x", ",", "X_cur", ")", "\n", "tf", ".", "assign", "(", "batch_y", ",", "Y_cur", ")", "\n", "if", "attack", "is", "not", "None", ":", "\n", "      ", "batch_adv_x", "=", "attack", ".", "generate", "(", "batch_x", ",", "**", "attack_args", ")", "\n", "predictions", "=", "model", ".", "get_probs", "(", "batch_adv_x", ")", "\n", "", "else", ":", "\n", "      ", "predictions", "=", "model", ".", "get_probs", "(", "batch_x", ")", "\n", "", "cur_corr_preds", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "batch_y", ",", "axis", "=", "-", "1", ")", ",", "\n", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", ")", "\n", "\n", "accuracy", "+=", "cur_corr_preds", ".", "numpy", "(", ")", "[", ":", "cur_batch_size", "]", ".", "sum", "(", ")", "\n", "\n", "", "assert", "end", ">=", "len", "(", "X_test", ")", "\n", "\n", "# Divide by number of examples to get final value", "\n", "accuracy", "/=", "len", "(", "X_test", ")", "\n", "\n", "return", "accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax": [[205, 219], ["tfe.Variable", "model.get_probs", "tensorflow.argmax", "tensorflow.argmax"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs"], ["", "def", "model_argmax", "(", "model", ",", "samples", ")", ":", "\n", "  ", "\"\"\"\n  Helper function that computes the current class prediction\n  :param samples: numpy array with input samples (dims must match x)\n  :return: the argmax output of predictions, i.e. the current predicted class\n  \"\"\"", "\n", "tfe", "=", "tf", ".", "contrib", ".", "eager", "\n", "tf_samples", "=", "tfe", ".", "Variable", "(", "samples", ")", "\n", "probabilities", "=", "model", ".", "get_probs", "(", "tf_samples", ")", "\n", "\n", "if", "samples", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "    ", "return", "tf", ".", "argmax", "(", "probabilities", ")", "\n", "", "else", ":", "\n", "    ", "return", "tf", ".", "argmax", "(", "probabilities", ",", "axis", "=", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.PicklableModel.__init__": [[36, 39], ["cleverhans.model.Model.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "PicklableModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "del", "self", ".", "scope", "# Must not use Variable scopes / names for anything", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.PicklableModel.get_params": [[40, 42], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\" does not implement\"", "\n", "\" get_params.\"", ")", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.__hash__": [[50, 52], ["hash", "id"], "methods", ["None"], ["def", "__hash__", "(", "self", ")", ":", "\n", "    ", "return", "hash", "(", "id", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.__init__": [[53, 86], ["picklable_model.PicklableModel.__init__", "isinstance", "enumerate", "isinstance", "ValueError", "hasattr", "picklable_model.MLP.layer_names.append", "layer.set_input_shape", "layer.get_output_shape", "hasattr", "hasattr", "hasattr", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "__init__", "(", "self", ",", "layers", ",", "input_shape", ")", ":", "\n", "    ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "layers", ",", "list", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\"`layers` must be a list.\"", ")", "\n", "\n", "", "self", ".", "layer_names", "=", "[", "]", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "\n", "if", "isinstance", "(", "layers", "[", "-", "1", "]", ",", "Softmax", ")", ":", "\n", "      ", "if", "not", "hasattr", "(", "layers", "[", "-", "1", "]", ",", "'name'", ")", ":", "\n", "        ", "layers", "[", "-", "1", "]", ".", "name", "=", "'probs'", "\n", "", "if", "not", "hasattr", "(", "layers", "[", "-", "2", "]", ",", "'name'", ")", ":", "\n", "        ", "layers", "[", "-", "2", "]", ".", "name", "=", "'logits'", "\n", "", "", "else", ":", "\n", "      ", "if", "not", "hasattr", "(", "layers", "[", "-", "1", "]", ",", "'name'", ")", ":", "\n", "        ", "layers", "[", "-", "1", "]", ".", "name", "=", "'logits'", "\n", "", "", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "      ", "if", "layer", ".", "parent", "is", "None", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "          ", "layer", ".", "parent", "=", "\"input\"", "\n", "", "else", ":", "\n", "          ", "layer", ".", "parent", "=", "layers", "[", "i", "-", "1", "]", ".", "name", "\n", "", "", "if", "hasattr", "(", "layer", ",", "'name'", ")", ":", "\n", "        ", "name", "=", "layer", ".", "name", "\n", "", "else", ":", "\n", "        ", "name", "=", "layer", ".", "__class__", ".", "__name__", "+", "str", "(", "i", ")", "\n", "layer", ".", "name", "=", "name", "\n", "", "self", ".", "layer_names", ".", "append", "(", "name", ")", "\n", "\n", "layer", ".", "set_input_shape", "(", "input_shape", ")", "\n", "input_shape", "=", "layer", ".", "get_output_shape", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.get_params": [[87, 92], ["cleverhans.utils.ordered_union", "layer.get_params"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.ordered_union", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["", "", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "out", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "      ", "out", "=", "ordered_union", "(", "out", ",", "layer", ".", "get_params", "(", ")", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.fprop": [[93, 136], ["enumerate", "ValueError", "layer.fprop", "TypeError", "str", "str", "type"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "fprop", "(", "self", ",", "x", "=", "None", ",", "given", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "\n", "# Note: this currently isn't great.", "\n", "# A layer can have any parent it wants, but the parent", "\n", "# must come earlier in the list.", "\n", "# There's no way to have > 1 parent.", "\n", "# This means we can support branched structures that split,", "\n", "# e.g. for multiple output heads, but not structures", "\n", "# that converge.", "\n", "# We can feed a value in the middle using \"given\" but", "\n", "# only layers after the given one are run using the current", "\n", "# implementation, so the feed must happen before any branch", "\n", "# point.", "\n", "\n", "    ", "if", "x", "is", "None", ":", "\n", "      ", "if", "given", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"One of `x` or `given` must be specified\"", ")", "\n", "", "", "else", ":", "\n", "      ", "assert", "given", "is", "None", "\n", "given", "=", "(", "'input'", ",", "x", ")", "\n", "", "name", ",", "value", "=", "given", "\n", "out", "=", "{", "name", ":", "value", "}", "\n", "x", "=", "value", "\n", "\n", "if", "name", "==", "'input'", ":", "\n", "      ", "layers", "=", "self", ".", "layers", "\n", "", "else", ":", "\n", "      ", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", "[", ":", "-", "1", "]", ")", ":", "\n", "        ", "if", "layer", ".", "name", "==", "name", ":", "\n", "          ", "layers", "=", "self", ".", "layers", "[", "i", "+", "1", ":", "]", "\n", "break", "\n", "\n", "", "", "", "for", "layer", "in", "layers", ":", "\n", "      ", "x", "=", "out", "[", "layer", ".", "parent", "]", "\n", "try", ":", "\n", "        ", "x", "=", "layer", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "\n", "", "except", "TypeError", "as", "e", ":", "\n", "        ", "msg", "=", "\"TypeError in fprop for %s of type %s: %s\"", "\n", "msg", "=", "msg", "%", "(", "layer", ".", "name", ",", "str", "(", "type", "(", "layer", ")", ")", ",", "str", "(", "e", ")", ")", "\n", "raise", "TypeError", "(", "msg", ")", "\n", "", "assert", "x", "is", "not", "None", "\n", "out", "[", "layer", ".", "name", "]", "=", "x", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.make_input_placeholder": [[137, 139], ["tensorflow.placeholder", "tuple"], "methods", ["None"], ["", "def", "make_input_placeholder", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "tuple", "(", "self", ".", "input_shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.MLP.make_label_placeholder": [[140, 146], ["picklable_model.MLP.layers[].make_label_placeholder", "tensorflow.placeholder", "picklable_model.MLP.layers[].get_output_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "make_label_placeholder", "(", "self", ")", ":", "\n", "    ", "try", ":", "\n", "      ", "return", "self", ".", "layers", "[", "-", "1", "]", ".", "make_label_placeholder", "(", ")", "\n", "", "except", "NotImplementedError", ":", "\n", "      ", "return", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "\n", "self", ".", "layers", "[", "-", "1", "]", ".", "get_output_shape", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Layer.__init__": [[149, 154], ["picklable_model.PicklableModel.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "name", "=", "None", ",", "parent", "=", "None", ")", ":", "\n", "    ", "super", "(", "Layer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "name", "is", "not", "None", ":", "\n", "      ", "self", ".", "name", "=", "name", "\n", "", "self", ".", "parent", "=", "parent", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Layer.get_output_shape": [[155, 157], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Linear.__init__": [[169, 178], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "num_hid", ",", "init_scale", "=", "1.", ",", "init_b", "=", "0.", ",", "use_bias", "=", "True", ",", "\n", "init_mode", "=", "\"norm\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "Linear", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "num_hid", "=", "num_hid", "\n", "self", ".", "init_scale", "=", "init_scale", "\n", "self", ".", "init_b", "=", "init_b", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "self", ".", "init_mode", "=", "init_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Linear.set_input_shape": [[179, 198], ["cleverhans.serial.PicklableVariable", "tensorflow.random_normal", "cleverhans.serial.PicklableVariable", "tensorflow.sqrt", "numpy.sqrt", "tensorflow.random_uniform", "ValueError", "tensorflow.reduce_sum", "tensorflow.square", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "def", "set_input_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "batch_size", ",", "dim", "=", "input_shape", "\n", "self", ".", "input_shape", "=", "[", "batch_size", ",", "dim", "]", "\n", "self", ".", "output_shape", "=", "[", "batch_size", ",", "self", ".", "num_hid", "]", "\n", "if", "self", ".", "init_mode", "==", "\"norm\"", ":", "\n", "      ", "init", "=", "tf", ".", "random_normal", "(", "[", "dim", ",", "self", ".", "num_hid", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "init", "=", "init", "/", "tf", ".", "sqrt", "(", "1e-7", "+", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "init", ")", ",", "axis", "=", "0", ",", "\n", "keep_dims", "=", "True", ")", ")", "\n", "init", "=", "init", "*", "self", ".", "init_scale", "\n", "", "elif", "self", ".", "init_mode", "==", "\"uniform_unit_scaling\"", ":", "\n", "      ", "scale", "=", "np", ".", "sqrt", "(", "3.", "/", "dim", ")", "\n", "init", "=", "tf", ".", "random_uniform", "(", "[", "dim", ",", "self", ".", "num_hid", "]", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "minval", "=", "-", "scale", ",", "maxval", "=", "scale", ")", "\n", "", "else", ":", "\n", "      ", "raise", "ValueError", "(", "self", ".", "init_mode", ")", "\n", "", "self", ".", "W", "=", "PV", "(", "init", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "self", ".", "b", "=", "PV", "(", "(", "np", ".", "zeros", "(", "(", "self", ".", "num_hid", ",", ")", ")", "\n", "+", "self", ".", "init_b", ")", ".", "astype", "(", "'float32'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Linear.fprop": [[199, 204], ["tensorflow.matmul"], "methods", ["None"], ["", "", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "out", "=", "tf", ".", "matmul", "(", "x", ",", "self", ".", "W", ".", "var", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "out", "=", "out", "+", "self", ".", "b", ".", "var", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Linear.get_params": [[205, 210], ["out.append"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "out", "=", "[", "self", ".", "W", ".", "var", "]", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "out", ".", "append", "(", "self", ".", "b", ".", "var", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Conv2D.__init__": [[232, 238], ["picklable_model.Conv2D.__dict__.update", "picklable_model.Layer.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "output_channels", ",", "kernel_shape", ",", "strides", ",", "padding", ",", "\n", "use_bias", "=", "False", ",", "init_scale", "=", "1.", ",", "\n", "init_mode", "=", "\"norm\"", ",", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "__dict__", ".", "update", "(", "locals", "(", ")", ")", "\n", "del", "self", ".", "self", "\n", "super", "(", "Conv2D", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Conv2D.set_input_shape": [[239, 275], ["all", "cleverhans.serial.PicklableVariable", "list", "tensorflow.zeros", "picklable_model.Conv2D.fprop", "tuple", "len", "tuple", "len", "tensorflow.random_normal", "tensorflow.reduce_sum", "tensorflow.sqrt", "cleverhans.serial.PicklableVariable", "int", "isinstance", "tensorflow.square", "tensorflow.random_normal", "numpy.zeros().astype", "picklable_model.Conv2D.get_shape", "numpy.sqrt", "tensorflow.random_uniform", "ValueError", "numpy.sqrt", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "def", "set_input_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "_batch_size", ",", "_rows", ",", "_cols", ",", "input_channels", "=", "input_shape", "\n", "assert", "len", "(", "self", ".", "kernel_shape", ")", "==", "2", "\n", "kernel_shape", "=", "tuple", "(", "self", ".", "kernel_shape", ")", "+", "(", "input_channels", ",", "\n", "self", ".", "output_channels", ")", "\n", "assert", "len", "(", "kernel_shape", ")", "==", "4", "\n", "assert", "all", "(", "isinstance", "(", "e", ",", "int", ")", "for", "e", "in", "kernel_shape", ")", ",", "kernel_shape", "\n", "fan_in", "=", "self", ".", "kernel_shape", "[", "0", "]", "*", "self", ".", "kernel_shape", "[", "1", "]", "*", "input_channels", "\n", "fan_out", "=", "self", ".", "kernel_shape", "[", "0", "]", "*", "self", ".", "kernel_shape", "[", "1", "]", "*", "self", ".", "output_channels", "\n", "if", "self", ".", "init_mode", "==", "\"norm\"", ":", "\n", "      ", "init", "=", "tf", ".", "random_normal", "(", "kernel_shape", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "squared_norms", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "init", ")", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ")", ")", "\n", "denom", "=", "tf", ".", "sqrt", "(", "1e-7", "+", "squared_norms", ")", "\n", "init", "=", "self", ".", "init_scale", "*", "init", "/", "denom", "\n", "", "elif", "self", ".", "init_mode", "==", "\"inv_sqrt\"", ":", "\n", "      ", "init", "=", "tf", ".", "random_normal", "(", "kernel_shape", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "stddev", "=", "np", ".", "sqrt", "(", "2.0", "/", "fan_out", ")", ")", "\n", "", "elif", "self", ".", "init_mode", "==", "\"glorot_uniform\"", ":", "\n", "      ", "scale", "=", "np", ".", "sqrt", "(", "6.", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "init", "=", "tf", ".", "random_uniform", "(", "kernel_shape", ",", "dtype", "=", "tf", ".", "float32", ",", "\n", "minval", "=", "-", "scale", ",", "maxval", "=", "scale", ")", "\n", "", "else", ":", "\n", "      ", "raise", "ValueError", "(", "self", ".", "init_mode", ")", "\n", "", "self", ".", "kernels", "=", "PV", "(", "init", ",", "name", "=", "self", ".", "name", "+", "\"_kernels\"", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "self", ".", "b", "=", "PV", "(", "np", ".", "zeros", "(", "(", "self", ".", "output_channels", ",", ")", ")", ".", "astype", "(", "'float32'", ")", ")", "\n", "", "input_shape", "=", "list", "(", "input_shape", ")", "\n", "orig_batch_size", "=", "input_shape", "[", "0", "]", "\n", "input_shape", "[", "0", "]", "=", "1", "\n", "dummy_batch", "=", "tf", ".", "zeros", "(", "input_shape", ")", "\n", "dummy_output", "=", "self", ".", "fprop", "(", "dummy_batch", ")", "\n", "output_shape", "=", "[", "int", "(", "e", ")", "for", "e", "in", "dummy_output", ".", "get_shape", "(", ")", "]", "\n", "output_shape", "[", "0", "]", "=", "orig_batch_size", "\n", "self", ".", "output_shape", "=", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Conv2D.fprop": [[276, 283], ["tensorflow.nn.conv2d", "len", "tuple"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "len", "(", "self", ".", "strides", ")", "==", "2", "\n", "out", "=", "tf", ".", "nn", ".", "conv2d", "(", "x", ",", "self", ".", "kernels", ".", "var", ",", "\n", "(", "1", ",", ")", "+", "tuple", "(", "self", ".", "strides", ")", "+", "(", "1", ",", ")", ",", "self", ".", "padding", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "out", "=", "out", "+", "self", ".", "b", ".", "var", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Conv2D.get_params": [[284, 289], ["out.append"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "out", "=", "[", "self", ".", "kernels", ".", "var", "]", "\n", "if", "self", ".", "use_bias", ":", "\n", "      ", "out", ".", "append", "(", "self", ".", "b", ".", "var", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ReLU.__init__": [[293, 296], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "leak", "=", "0.", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "ReLU", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "leak", "=", "leak", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ReLU.set_input_shape": [[297, 300], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ReLU.get_output_shape": [[301, 303], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ReLU.fprop": [[304, 323], ["tensorflow.nn.relu", "tensorflow.where", "tensorflow.less"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "out", "=", "tf", ".", "nn", ".", "relu", "(", "x", ")", "\n", "if", "self", ".", "leak", "!=", "0.0", ":", "\n", "# The code commented below resulted in the time per epoch of", "\n", "# an 8-GPU wide resnet increasing by about 5% relative to the", "\n", "# code now in use.", "\n", "# The two different implementations have the same forward prop", "\n", "# down to machine precision on all inputs I have tested, but", "\n", "# sometimes have different derivatives.", "\n", "# Both obtain about the same training accuracy but the faster", "\n", "# version seems to also be slightly more accurate.", "\n", "# The commented code and these performance notes are included to", "\n", "# aid future revision efforts.", "\n", "#", "\n", "# out = out - self.leak * tf.nn.relu(-x)", "\n", "#", "\n", "\n", "      ", "out", "=", "tf", ".", "where", "(", "tf", ".", "less", "(", "x", ",", "0.0", ")", ",", "self", ".", "leak", "*", "x", ",", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ReLU.get_params": [[324, 326], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Sigmoid.__init__": [[330, 332], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "Sigmoid", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Sigmoid.set_input_shape": [[333, 336], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Sigmoid.get_output_shape": [[337, 339], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Sigmoid.fprop": [[340, 342], ["tensorflow.nn.sigmoid"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "sigmoid", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Sigmoid.get_params": [[343, 345], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Tanh.__init__": [[349, 351], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "Tanh", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Tanh.set_input_shape": [[352, 355], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Tanh.get_output_shape": [[356, 358], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Tanh.fprop": [[359, 361], ["tensorflow.nn.tanh"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "tanh", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Tanh.get_params": [[362, 364], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.LeakyReLU.__init__": [[368, 370], ["picklable_model.ReLU.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "leak", "=", ".2", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "LeakyReLU", ",", "self", ")", ".", "__init__", "(", "leak", "=", "leak", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ELU.set_input_shape": [[374, 377], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ELU.get_output_shape": [[378, 380], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ELU.fprop": [[381, 383], ["tensorflow.nn.elu"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "elu", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ELU.get_params": [[384, 386], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.SELU.set_input_shape": [[390, 393], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.SELU.get_output_shape": [[394, 396], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.SELU.fprop": [[397, 404], ["tensorflow.to_float", "tensorflow.exp"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "alpha", "=", "1.6732632423543772848170429916717", "\n", "scale", "=", "1.0507009873554804934193349852946", "\n", "mask", "=", "tf", ".", "to_float", "(", "x", ">=", "0.", ")", "\n", "out", "=", "mask", "*", "x", "+", "(", "1.", "-", "mask", ")", "*", "(", "alpha", "*", "tf", ".", "exp", "(", "(", "1.", "-", "mask", ")", "*", "x", ")", "-", "alpha", ")", "\n", "return", "scale", "*", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.SELU.get_params": [[405, 407], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.TanH.set_input_shape": [[411, 414], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.TanH.get_output_shape": [[415, 417], ["None"], "methods", ["None"], ["", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.TanH.fprop": [[418, 420], ["tensorflow.nn.tanh"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "tanh", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Softmax.set_input_shape": [[424, 427], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Softmax.fprop": [[428, 431], ["tensorflow.nn.softmax"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "out", "=", "tf", ".", "nn", ".", "softmax", "(", "x", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Softmax.get_params": [[432, 434], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Softmax.make_label_placeholder": [[435, 437], ["tensorflow.placeholder"], "methods", ["None"], ["", "def", "make_label_placeholder", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "self", ".", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Flatten.set_input_shape": [[441, 448], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "output_width", "=", "1", "\n", "for", "factor", "in", "shape", "[", "1", ":", "]", ":", "\n", "      ", "output_width", "*=", "factor", "\n", "", "self", ".", "output_width", "=", "output_width", "\n", "self", ".", "output_shape", "=", "[", "None", ",", "output_width", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Flatten.fprop": [[449, 451], ["tensorflow.reshape"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "self", ".", "output_width", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Flatten.get_params": [[452, 454], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Print.set_input_shape": [[458, 461], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Print.get_params": [[462, 464], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Print.fprop": [[465, 471], ["tensorflow.reduce_mean", "tensorflow.sqrt", "tensorflow.Print", "tensorflow.reduce_mean", "tensorflow.square", "tensorflow.reduce_min", "tensorflow.reduce_max"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "mean", "=", "tf", ".", "reduce_mean", "(", "x", ")", "\n", "std", "=", "tf", ".", "sqrt", "(", "tf", ".", "reduce_mean", "(", "tf", ".", "square", "(", "x", "-", "mean", ")", ")", ")", "\n", "return", "tf", ".", "Print", "(", "x", ",", "\n", "[", "tf", ".", "reduce_min", "(", "x", ")", ",", "mean", ",", "tf", ".", "reduce_max", "(", "x", ")", ",", "std", "]", ",", "\n", "\"Print layer\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Add.__hash__": [[481, 483], ["hash", "id"], "methods", ["None"], ["def", "__hash__", "(", "self", ")", ":", "\n", "    ", "return", "hash", "(", "id", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Add.set_input_shape": [[484, 491], ["layer.set_input_shape", "layer.get_output_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "shapes", "=", "{", "\"input\"", ":", "shape", "}", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "      ", "layer", ".", "set_input_shape", "(", "shapes", "[", "layer", ".", "parent", "]", ")", "\n", "shapes", "[", "layer", ".", "name", "]", "=", "layer", ".", "get_output_shape", "(", ")", "\n", "", "self", ".", "output_shape", "=", "shapes", "[", "self", ".", "layers", "[", "-", "1", "]", ".", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Add.__init__": [[492, 510], ["picklable_model.Layer.__init__", "enumerate", "hasattr", "picklable_model.Add.layer_names.append", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["", "def", "__init__", "(", "self", ",", "layers", ")", ":", "\n", "    ", "super", "(", "Add", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "layer_names", "=", "[", "]", "\n", "self", ".", "layers", "=", "layers", "\n", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "      ", "if", "layer", ".", "parent", "is", "None", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "          ", "layer", ".", "parent", "=", "\"input\"", "\n", "", "else", ":", "\n", "          ", "layer", ".", "parent", "=", "layers", "[", "i", "-", "1", "]", ".", "name", "\n", "", "", "if", "hasattr", "(", "layer", ",", "'name'", ")", ":", "\n", "        ", "name", "=", "layer", ".", "name", "\n", "", "else", ":", "\n", "        ", "name", "=", "layer", ".", "__class__", ".", "__name__", "+", "str", "(", "i", ")", "\n", "layer", ".", "name", "=", "name", "\n", "", "self", ".", "layer_names", ".", "append", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Add.get_params": [[511, 516], ["cleverhans.utils.ordered_union", "layer.get_params"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.ordered_union", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["", "", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "out", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "      ", "out", "=", "ordered_union", "(", "out", ",", "layer", ".", "get_params", "(", ")", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Add.fprop": [[517, 547], ["layer.fprop", "TypeError", "str", "str", "type"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "\n", "    ", "orig_x", "=", "x", "\n", "\n", "# Note: this currently isn't great.", "\n", "# A layer can have any parent it wants, but the parent", "\n", "# must come earlier in the list.", "\n", "# There's no way to have > 1 parent.", "\n", "# This means we can support branched structures that split,", "\n", "# e.g. for multiple output heads, but not structures", "\n", "# that converge.", "\n", "# We can feed a value in the middle using \"given\" but", "\n", "# only layers after the given one are run using the current", "\n", "# implementation, so the feed must happen before any branch", "\n", "# point.", "\n", "\n", "out", "=", "{", "'input'", ":", "x", "}", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "      ", "x", "=", "out", "[", "layer", ".", "parent", "]", "\n", "try", ":", "\n", "        ", "x", "=", "layer", ".", "fprop", "(", "x", ")", "\n", "", "except", "TypeError", "as", "e", ":", "\n", "        ", "msg", "=", "\"TypeError in fprop for layer %s of type %s: %s\"", "\n", "msg", "=", "msg", "%", "(", "layer", ".", "name", ",", "str", "(", "type", "(", "layer", ")", ")", ",", "str", "(", "e", ")", ")", "\n", "raise", "TypeError", "(", "msg", ")", "\n", "", "assert", "x", "is", "not", "None", "\n", "out", "[", "layer", ".", "name", "]", "=", "x", "\n", "\n", "", "return", "orig_x", "+", "out", "[", "self", ".", "layers", "[", "-", "1", "]", ".", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.PerImageStandardize.set_input_shape": [[551, 554], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.PerImageStandardize.get_params": [[555, 557], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.PerImageStandardize.fprop": [[558, 575], ["cleverhans.compat.reduce_mean", "tensorflow.nn.relu", "tensorflow.sqrt", "cleverhans.compat.reduce_prod", "tensorflow.rsqrt", "tensorflow.maximum", "tensorflow.subtract", "tensorflow.div", "cleverhans.compat.reduce_mean", "tensorflow.square", "tensorflow.to_float", "tensorflow.square", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_prod", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.div", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "axis", "=", "[", "1", ",", "2", ",", "3", "]", "\n", "mean", "=", "reduce_mean", "(", "x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "variance", "=", "reduce_mean", "(", "\n", "tf", ".", "square", "(", "x", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "-", "tf", ".", "square", "(", "mean", ")", "\n", "variance", "=", "tf", ".", "nn", ".", "relu", "(", "variance", ")", "\n", "stddev", "=", "tf", ".", "sqrt", "(", "variance", ")", "\n", "\n", "num_pixels", "=", "reduce_prod", "(", "tf", ".", "shape", "(", "x", ")", "[", "1", ":", "]", ")", "\n", "\n", "min_stddev", "=", "tf", ".", "rsqrt", "(", "tf", ".", "to_float", "(", "num_pixels", ")", ")", "\n", "pixel_value_scale", "=", "tf", ".", "maximum", "(", "stddev", ",", "min_stddev", ")", "\n", "pixel_value_offset", "=", "mean", "\n", "\n", "x", "=", "tf", ".", "subtract", "(", "x", ",", "pixel_value_offset", ")", "\n", "x", "=", "tf", ".", "div", "(", "x", ",", "pixel_value_scale", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Dropout.__init__": [[604, 607], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "include_prob", "=", "0.5", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "Dropout", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "include_prob", "=", "include_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Dropout.set_input_shape": [[608, 611], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Dropout.get_params": [[612, 614], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.Dropout.fprop": [[615, 639], ["tensorflow.nn.dropout"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "dropout", "=", "False", ",", "dropout_dict", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Forward propagation as either no-op or dropping random units.\n    :param x: The input to the layer\n    :param dropout: bool specifying whether to drop units\n    :param dropout_dict: dict\n        This dictionary is usually not needed.\n        In rare cases, generally for research purposes, this dictionary\n        makes it possible to run forward propagation with a different\n        dropout include probability.\n        This dictionary should be passed as a named argument to the MLP\n        class, which will then pass it to *all* layers' fprop methods.\n        Other layers will just receive this as an ignored kwargs entry.\n        Each dropout layer looks up its own name in this dictionary\n        to read out its include probability.\n    \"\"\"", "\n", "include_prob", "=", "self", ".", "include_prob", "\n", "if", "dropout_dict", "is", "not", "None", ":", "\n", "      ", "assert", "dropout", "\n", "if", "self", ".", "name", "in", "dropout_dict", ":", "\n", "        ", "include_prob", "=", "dropout_dict", "[", "self", ".", "name", "]", "\n", "", "", "if", "dropout", ":", "\n", "      ", "return", "tf", ".", "nn", ".", "dropout", "(", "x", ",", "include_prob", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithGroupNorm.__init__": [[649, 656], ["isinstance", "picklable_model.ResidualWithGroupNorm.__dict__.update", "picklable_model.LeakyReLU", "picklable_model.Layer.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "out_filter", ",", "stride", ",", "activate_before_residual", "=", "False", ",", "\n", "leak", "=", "0.1", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "isinstance", "(", "stride", ",", "int", ")", "\n", "self", ".", "__dict__", ".", "update", "(", "locals", "(", ")", ")", "\n", "del", "self", ".", "self", "\n", "self", ".", "lrelu", "=", "LeakyReLU", "(", "leak", ")", "\n", "super", "(", "ResidualWithGroupNorm", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithGroupNorm.set_input_shape": [[657, 672], ["tuple", "picklable_model.GroupNorm", "picklable_model.ResidualWithGroupNorm.gn1.set_input_shape", "picklable_model.Conv2D", "picklable_model.ResidualWithGroupNorm.conv1.set_input_shape", "picklable_model.GroupNorm", "picklable_model.ResidualWithGroupNorm.gn2.set_input_shape", "picklable_model.Conv2D", "picklable_model.ResidualWithGroupNorm.conv2.set_input_shape", "picklable_model.ResidualWithGroupNorm.conv2.get_output_shape", "picklable_model.ResidualWithGroupNorm.conv1.get_output_shape", "picklable_model.ResidualWithGroupNorm.conv1.get_output_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "tuple", "(", "shape", ")", "\n", "self", ".", "in_filter", "=", "shape", "[", "-", "1", "]", "\n", "self", ".", "gn1", "=", "GroupNorm", "(", "name", "=", "self", ".", "name", "+", "\"_gn1\"", ")", "\n", "self", ".", "gn1", ".", "set_input_shape", "(", "shape", ")", "\n", "strides", "=", "(", "self", ".", "stride", ",", "self", ".", "stride", ")", "\n", "self", ".", "conv1", "=", "Conv2D", "(", "self", ".", "out_filter", ",", "(", "3", ",", "3", ")", ",", "strides", ",", "\"SAME\"", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_conv1\"", ",", "init_mode", "=", "\"inv_sqrt\"", ")", "\n", "self", ".", "conv1", ".", "set_input_shape", "(", "shape", ")", "\n", "self", ".", "gn2", "=", "GroupNorm", "(", "name", "=", "self", ".", "name", "+", "\"_gn2\"", ")", "\n", "self", ".", "gn2", ".", "set_input_shape", "(", "self", ".", "conv1", ".", "get_output_shape", "(", ")", ")", "\n", "self", ".", "conv2", "=", "Conv2D", "(", "self", ".", "out_filter", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "\"SAME\"", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_conv2\"", ",", "init_mode", "=", "\"inv_sqrt\"", ")", "\n", "self", ".", "conv2", ".", "set_input_shape", "(", "self", ".", "conv1", ".", "get_output_shape", "(", ")", ")", "\n", "self", ".", "output_shape", "=", "self", ".", "conv2", ".", "get_output_shape", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithGroupNorm.get_params": [[673, 680], ["sublayer.get_params"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "sublayers", "=", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "gn1", ",", "self", ".", "gn2", "]", "\n", "params", "=", "[", "]", "\n", "for", "sublayer", "in", "sublayers", ":", "\n", "      ", "params", "=", "params", "+", "sublayer", ".", "get_params", "(", ")", "\n", "", "assert", "self", ".", "conv1", ".", "kernels", ".", "var", "in", "params", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithGroupNorm.fprop": [[681, 705], ["picklable_model.ResidualWithGroupNorm.conv1.fprop", "picklable_model.ResidualWithGroupNorm.gn2.fprop", "picklable_model.ResidualWithGroupNorm.lrelu.fprop", "picklable_model.ResidualWithGroupNorm.conv2.fprop", "picklable_model.ResidualWithGroupNorm.gn1.fprop", "picklable_model.ResidualWithGroupNorm.lrelu.fprop", "picklable_model.ResidualWithGroupNorm.gn1.fprop", "picklable_model.ResidualWithGroupNorm.lrelu.fprop", "tensorflow.nn.avg_pool", "tensorflow.pad"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "self", ".", "activate_before_residual", ":", "\n", "      ", "x", "=", "self", ".", "gn1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "orig_x", "=", "x", "\n", "", "else", ":", "\n", "      ", "orig_x", "=", "x", "\n", "x", "=", "self", ".", "gn1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "", "x", "=", "self", ".", "conv1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "gn2", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", ".", "fprop", "(", "x", ")", "\n", "if", "self", ".", "stride", "!=", "1", ":", "\n", "      ", "stride", "=", "[", "1", ",", "self", ".", "stride", ",", "self", ".", "stride", ",", "1", "]", "\n", "orig_x", "=", "tf", ".", "nn", ".", "avg_pool", "(", "orig_x", ",", "stride", ",", "stride", ",", "'VALID'", ")", "\n", "", "out_filter", "=", "self", ".", "out_filter", "\n", "in_filter", "=", "self", ".", "in_filter", "\n", "if", "in_filter", "!=", "out_filter", ":", "\n", "      ", "orig_x", "=", "tf", ".", "pad", "(", "orig_x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "\n", "[", "(", "out_filter", "-", "in_filter", ")", "//", "2", ",", "\n", "(", "out_filter", "-", "in_filter", ")", "//", "2", "]", "]", ")", "\n", "", "x", "=", "x", "+", "orig_x", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GlobalAveragePool.set_input_shape": [[709, 712], ["None"], "methods", ["None"], ["  ", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "[", "shape", "[", "0", "]", ",", "shape", "[", "-", "1", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GlobalAveragePool.get_params": [[713, 715], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GlobalAveragePool.fprop": [[716, 719], ["tensorflow.reduce_mean", "len", "list", "x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "len", "(", "list", "(", "x", ".", "get_shape", "(", ")", ")", ")", "==", "4", "\n", "return", "tf", ".", "reduce_mean", "(", "x", ",", "[", "1", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GroupNorm.__init__": [[728, 734], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "num_groups", "=", "32", ",", "eps", "=", "1e-3", ",", "init_gamma", "=", "1.", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "num_groups", "=", "num_groups", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "init_gamma", "=", "init_gamma", "\n", "super", "(", "GroupNorm", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GroupNorm.set_input_shape": [[735, 748], ["min", "cleverhans.serial.PicklableVariable", "cleverhans.serial.PicklableVariable", "tuple", "tuple", "numpy.ones", "numpy.zeros"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "channels", "=", "shape", "[", "-", "1", "]", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "actual_num_groups", "=", "min", "(", "self", ".", "channels", ",", "self", ".", "num_groups", ")", "\n", "extra_dims", "=", "(", "self", ".", "channels", "//", "self", ".", "actual_num_groups", ",", "\n", "self", ".", "actual_num_groups", ")", "\n", "self", ".", "expanded_shape", "=", "tuple", "(", "shape", "[", "1", ":", "3", "]", ")", "+", "tuple", "(", "extra_dims", ")", "\n", "init_value", "=", "np", ".", "ones", "(", "(", "channels", ",", ")", ",", "dtype", "=", "'float32'", ")", "*", "self", ".", "init_gamma", "\n", "self", ".", "gamma", "=", "PV", "(", "init_value", ",", "name", "=", "self", ".", "name", "+", "\"_gamma\"", ")", "\n", "self", ".", "beta", "=", "PV", "(", "np", ".", "zeros", "(", "(", "self", ".", "channels", ",", ")", ",", "dtype", "=", "'float32'", ")", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_beta\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GroupNorm.fprop": [[749, 758], ["tensorflow.shape", "tensorflow.reshape", "tensorflow.nn.moments", "tensorflow.reshape", "tensorflow.rsqrt"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "shape", "=", "tf", ".", "shape", "(", "x", ")", "\n", "batch_size", "=", "shape", "[", "0", "]", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "(", "batch_size", ",", ")", "+", "self", ".", "expanded_shape", ")", "\n", "mean", ",", "var", "=", "tf", ".", "nn", ".", "moments", "(", "x", ",", "[", "1", ",", "2", ",", "3", "]", ",", "keep_dims", "=", "True", ")", "\n", "x", "=", "(", "x", "-", "mean", ")", "*", "tf", ".", "rsqrt", "(", "var", "+", "self", ".", "eps", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "shape", ")", "\n", "x", "=", "x", "*", "self", ".", "gamma", ".", "var", "+", "self", ".", "beta", ".", "var", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.GroupNorm.get_params": [[759, 761], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "gamma", ".", "var", ",", "self", ".", "beta", ".", "var", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.BatchNorm.__init__": [[768, 773], ["picklable_model.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "eps", "=", "1e-3", ",", "init_gamma", "=", "1.", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "eps", "=", "eps", "\n", "self", ".", "init_gamma", "=", "init_gamma", "\n", "super", "(", "BatchNorm", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.BatchNorm.set_input_shape": [[774, 782], ["cleverhans.serial.PicklableVariable", "cleverhans.serial.PicklableVariable", "numpy.ones", "numpy.zeros"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "channels", "=", "shape", "[", "-", "1", "]", "\n", "init_value", "=", "np", ".", "ones", "(", "(", "channels", ",", ")", ",", "dtype", "=", "'float32'", ")", "*", "self", ".", "init_gamma", "\n", "self", ".", "gamma", "=", "PV", "(", "init_value", ",", "name", "=", "self", ".", "name", "+", "\"_gamma\"", ")", "\n", "self", ".", "beta", "=", "PV", "(", "np", ".", "zeros", "(", "(", "channels", ",", ")", ",", "dtype", "=", "'float32'", ")", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_beta\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.BatchNorm.fprop": [[783, 788], ["tensorflow.nn.moments", "tensorflow.rsqrt"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "mean", ",", "var", "=", "tf", ".", "nn", ".", "moments", "(", "x", ",", "[", "0", ",", "1", ",", "2", "]", ",", "keep_dims", "=", "True", ")", "\n", "x", "=", "(", "x", "-", "mean", ")", "*", "tf", ".", "rsqrt", "(", "var", "+", "self", ".", "eps", ")", "\n", "x", "=", "x", "*", "self", ".", "gamma", ".", "var", "+", "self", ".", "beta", ".", "var", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.BatchNorm.get_params": [[789, 791], ["None"], "methods", ["None"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "return", "[", "self", ".", "gamma", ".", "var", ",", "self", ".", "beta", ".", "var", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithBatchNorm.__init__": [[801, 808], ["isinstance", "picklable_model.ResidualWithBatchNorm.__dict__.update", "picklable_model.LeakyReLU", "picklable_model.Layer.__init__", "locals"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "out_filter", ",", "stride", ",", "activate_before_residual", "=", "False", ",", "\n", "leak", "=", "0.1", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "isinstance", "(", "stride", ",", "int", ")", "\n", "self", ".", "__dict__", ".", "update", "(", "locals", "(", ")", ")", "\n", "del", "self", ".", "self", "\n", "self", ".", "lrelu", "=", "LeakyReLU", "(", "leak", ")", "\n", "super", "(", "ResidualWithBatchNorm", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithBatchNorm.set_input_shape": [[809, 824], ["tuple", "picklable_model.BatchNorm", "picklable_model.ResidualWithBatchNorm.bn1.set_input_shape", "picklable_model.Conv2D", "picklable_model.ResidualWithBatchNorm.conv1.set_input_shape", "picklable_model.BatchNorm", "picklable_model.ResidualWithBatchNorm.bn2.set_input_shape", "picklable_model.Conv2D", "picklable_model.ResidualWithBatchNorm.conv2.set_input_shape", "picklable_model.ResidualWithBatchNorm.conv2.get_output_shape", "picklable_model.ResidualWithBatchNorm.conv1.get_output_shape", "picklable_model.ResidualWithBatchNorm.conv1.get_output_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "tuple", "(", "shape", ")", "\n", "self", ".", "in_filter", "=", "shape", "[", "-", "1", "]", "\n", "self", ".", "bn1", "=", "BatchNorm", "(", "name", "=", "self", ".", "name", "+", "\"_bn1\"", ")", "\n", "self", ".", "bn1", ".", "set_input_shape", "(", "shape", ")", "\n", "strides", "=", "(", "self", ".", "stride", ",", "self", ".", "stride", ")", "\n", "self", ".", "conv1", "=", "Conv2D", "(", "self", ".", "out_filter", ",", "(", "3", ",", "3", ")", ",", "strides", ",", "\"SAME\"", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_conv1\"", ",", "init_mode", "=", "\"inv_sqrt\"", ")", "\n", "self", ".", "conv1", ".", "set_input_shape", "(", "shape", ")", "\n", "self", ".", "bn2", "=", "BatchNorm", "(", "name", "=", "self", ".", "name", "+", "\"_bn2\"", ")", "\n", "self", ".", "bn2", ".", "set_input_shape", "(", "self", ".", "conv1", ".", "get_output_shape", "(", ")", ")", "\n", "self", ".", "conv2", "=", "Conv2D", "(", "self", ".", "out_filter", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "\"SAME\"", ",", "\n", "name", "=", "self", ".", "name", "+", "\"_conv2\"", ",", "init_mode", "=", "\"inv_sqrt\"", ")", "\n", "self", ".", "conv2", ".", "set_input_shape", "(", "self", ".", "conv1", ".", "get_output_shape", "(", ")", ")", "\n", "self", ".", "output_shape", "=", "self", ".", "conv2", ".", "get_output_shape", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithBatchNorm.get_params": [[825, 832], ["sublayer.get_params"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "sublayers", "=", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "bn1", ",", "self", ".", "bn2", "]", "\n", "params", "=", "[", "]", "\n", "for", "sublayer", "in", "sublayers", ":", "\n", "      ", "params", "=", "params", "+", "sublayer", ".", "get_params", "(", ")", "\n", "", "assert", "self", ".", "conv1", ".", "kernels", ".", "var", "in", "params", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.picklable_model.ResidualWithBatchNorm.fprop": [[833, 857], ["picklable_model.ResidualWithBatchNorm.conv1.fprop", "picklable_model.ResidualWithBatchNorm.bn2.fprop", "picklable_model.ResidualWithBatchNorm.lrelu.fprop", "picklable_model.ResidualWithBatchNorm.conv2.fprop", "picklable_model.ResidualWithBatchNorm.bn1.fprop", "picklable_model.ResidualWithBatchNorm.lrelu.fprop", "picklable_model.ResidualWithBatchNorm.bn1.fprop", "picklable_model.ResidualWithBatchNorm.lrelu.fprop", "tensorflow.nn.avg_pool", "tensorflow.pad"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "self", ".", "activate_before_residual", ":", "\n", "      ", "x", "=", "self", ".", "bn1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "orig_x", "=", "x", "\n", "", "else", ":", "\n", "      ", "orig_x", "=", "x", "\n", "x", "=", "self", ".", "bn1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "", "x", "=", "self", ".", "conv1", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", ".", "fprop", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", ".", "fprop", "(", "x", ")", "\n", "if", "self", ".", "stride", "!=", "1", ":", "\n", "      ", "stride", "=", "[", "1", ",", "self", ".", "stride", ",", "self", ".", "stride", ",", "1", "]", "\n", "orig_x", "=", "tf", ".", "nn", ".", "avg_pool", "(", "orig_x", ",", "stride", ",", "stride", ",", "'VALID'", ")", "\n", "", "out_filter", "=", "self", ".", "out_filter", "\n", "in_filter", "=", "self", ".", "in_filter", "\n", "if", "in_filter", "!=", "out_filter", ":", "\n", "      ", "orig_x", "=", "tf", ".", "pad", "(", "orig_x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "\n", "[", "(", "out_filter", "-", "in_filter", ")", "//", "2", ",", "\n", "(", "out_filter", "-", "in_filter", ")", "//", "2", "]", "]", ")", "\n", "", "x", "=", "x", "+", "orig_x", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.__init__": [[23, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "scope", "=", "None", ",", "nb_classes", "=", "None", ",", "hparams", "=", "None", ",", "\n", "needs_dummy_fprop", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Constructor.\n    :param scope: str, the name of model.\n    :param nb_classes: integer, the number of classes.\n    :param hparams: dict, hyper-parameters for the model.\n    :needs_dummy_fprop: bool, if True the model's parameters are not\n        created until fprop is called.\n    \"\"\"", "\n", "self", ".", "scope", "=", "scope", "or", "self", ".", "__class__", ".", "__name__", "\n", "self", ".", "nb_classes", "=", "nb_classes", "\n", "self", ".", "hparams", "=", "hparams", "or", "{", "}", "\n", "self", ".", "needs_dummy_fprop", "=", "needs_dummy_fprop", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.__call__": [[38, 58], ["warnings.warn", "model.Model.get_probs"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    For compatibility with functions used as model definitions (taking\n    an input tensor and returning the tensor giving the output\n    of the model on that input).\n    \"\"\"", "\n", "\n", "warnings", ".", "warn", "(", "\"Model.__call__ is deprecated. \"", "\n", "\"The call is ambiguous as to whether the output should \"", "\n", "\"be logits or probabilities, and getting the wrong one \"", "\n", "\"can cause serious problems. \"", "\n", "\"The output actually is probabilities, which are a very \"", "\n", "\"dangerous thing to use as part of any interface for \"", "\n", "\"cleverhans, because softmax probabilities are prone \"", "\n", "\"to gradient masking.\"", "\n", "\"On or after 2019-04-24, this method will change to raise \"", "\n", "\"an exception explaining why Model.__call__ should not be \"", "\n", "\"used.\"", ")", "\n", "\n", "return", "self", ".", "get_probs", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits": [[59, 71], ["model.Model.fprop", "NotImplementedError", "str", "type"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "get_logits", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param x: A symbolic representation (Tensor) of the network input\n    :return: A symbolic representation (Tensor) of the output logits\n    (i.e., the values fed as inputs to the softmax layer).\n    \"\"\"", "\n", "outputs", "=", "self", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "\n", "if", "self", ".", "O_LOGITS", "in", "outputs", ":", "\n", "      ", "return", "outputs", "[", "self", ".", "O_LOGITS", "]", "\n", "", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\"must implement `get_logits`\"", "\n", "\" or must define a \"", "+", "self", ".", "O_LOGITS", "+", "\n", "\" output in `fprop`\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_predicted_class": [[72, 78], ["tensorflow.argmax", "model.Model.get_logits"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits"], ["", "def", "get_predicted_class", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param x: A symbolic representation (Tensor) of the network input\n    :return: A symbolic representation (Tensor) of the predicted label\n    \"\"\"", "\n", "return", "tf", ".", "argmax", "(", "self", ".", "get_logits", "(", "x", ",", "**", "kwargs", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs": [[79, 101], ["model.Model.fprop", "tensorflow.reduce_min", "tensorflow.reduce_max", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.nn.softmax", "ValueError", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal"], ["", "def", "get_probs", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param x: A symbolic representation (Tensor) of the network input\n    :return: A symbolic representation (Tensor) of the output\n    probabilities (i.e., the output values produced by the softmax layer).\n    \"\"\"", "\n", "d", "=", "self", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "\n", "if", "self", ".", "O_PROBS", "in", "d", ":", "\n", "      ", "output", "=", "d", "[", "self", ".", "O_PROBS", "]", "\n", "min_prob", "=", "tf", ".", "reduce_min", "(", "output", ")", "\n", "max_prob", "=", "tf", ".", "reduce_max", "(", "output", ")", "\n", "asserts", "=", "[", "utils_tf", ".", "assert_greater_equal", "(", "min_prob", ",", "\n", "tf", ".", "cast", "(", "0.", ",", "min_prob", ".", "dtype", ")", ")", ",", "\n", "utils_tf", ".", "assert_less_equal", "(", "max_prob", ",", "\n", "tf", ".", "cast", "(", "1.", ",", "min_prob", ".", "dtype", ")", ")", "]", "\n", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "output", "=", "tf", ".", "identity", "(", "output", ")", "\n", "", "return", "output", "\n", "", "elif", "self", ".", "O_LOGITS", "in", "d", ":", "\n", "      ", "return", "tf", ".", "nn", ".", "softmax", "(", "logits", "=", "d", "[", "self", ".", "O_LOGITS", "]", ")", "\n", "", "else", ":", "\n", "      ", "raise", "ValueError", "(", "'Cannot find probs or logits.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.fprop": [[102, 110], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Forward propagation to compute the model outputs.\n    :param x: A symbolic representation of the network input\n    :return: A dictionary mapping layer names to the symbolic\n             representation of their output.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "'`fprop` not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params": [[111, 151], ["hasattr", "tensorflow.get_collection", "hasattr", "list", "tensorflow.executing_eagerly", "len", "model.Model.make_params", "tensorflow.get_collection", "len", "NotImplementedError", "len", "len", "print", "print", "print", "print", "str", "str", "len", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.make_params"], ["", "def", "get_params", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Provides access to the model's parameters.\n    :return: A list of all Variables defining the model parameters.\n    \"\"\"", "\n", "\n", "if", "hasattr", "(", "self", ",", "'params'", ")", ":", "\n", "      ", "return", "list", "(", "self", ".", "params", ")", "\n", "\n", "# Catch eager execution and assert function overload.", "\n", "", "try", ":", "\n", "      ", "if", "tf", ".", "executing_eagerly", "(", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"For Eager execution - get_params \"", "\n", "\"must be overridden.\"", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "      ", "pass", "\n", "\n", "# For graph-based execution", "\n", "", "scope_vars", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "TRAINABLE_VARIABLES", ",", "\n", "self", ".", "scope", "+", "\"/\"", ")", "\n", "\n", "if", "len", "(", "scope_vars", ")", "==", "0", ":", "\n", "      ", "self", ".", "make_params", "(", ")", "\n", "scope_vars", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "TRAINABLE_VARIABLES", ",", "\n", "self", ".", "scope", "+", "\"/\"", ")", "\n", "assert", "len", "(", "scope_vars", ")", ">", "0", "\n", "\n", "# Make sure no parameters have been added or removed", "\n", "", "if", "hasattr", "(", "self", ",", "\"num_params\"", ")", ":", "\n", "      ", "if", "self", ".", "num_params", "!=", "len", "(", "scope_vars", ")", ":", "\n", "        ", "print", "(", "\"Scope: \"", ",", "self", ".", "scope", ")", "\n", "print", "(", "\"Expected \"", "+", "str", "(", "self", ".", "num_params", ")", "+", "\" variables\"", ")", "\n", "print", "(", "\"Got \"", "+", "str", "(", "len", "(", "scope_vars", ")", ")", ")", "\n", "for", "var", "in", "scope_vars", ":", "\n", "          ", "print", "(", "\"\\t\"", "+", "str", "(", "var", ")", ")", "\n", "", "assert", "False", "\n", "", "", "else", ":", "\n", "      ", "self", ".", "num_params", "=", "len", "(", "scope_vars", ")", "\n", "\n", "", "return", "scope_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.make_params": [[152, 165], ["hasattr", "model.Model.make_input_placeholder", "model.Model.fprop"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "make_params", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Create all Variables to be returned later by get_params.\n    By default this is a no-op.\n    Models that need their fprop to be called for their params to be\n    created can set `needs_dummy_fprop=True` in the constructor.\n    \"\"\"", "\n", "\n", "if", "self", ".", "needs_dummy_fprop", ":", "\n", "      ", "if", "hasattr", "(", "self", ",", "\"_dummy_input\"", ")", ":", "\n", "        ", "return", "\n", "", "self", ".", "_dummy_input", "=", "self", ".", "make_input_placeholder", "(", ")", "\n", "self", ".", "fprop", "(", "self", ".", "_dummy_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer_names": [[166, 169], ["None"], "methods", ["None"], ["", "", "def", "get_layer_names", "(", "self", ")", ":", "\n", "    ", "\"\"\"Return the list of exposed layers for this model.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_layer": [[170, 178], ["model.Model.fprop"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "get_layer", "(", "self", ",", "x", ",", "layer", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Return a layer output.\n    :param x: tensor, the input to the network.\n    :param layer: str, the name of the layer to compute.\n    :param **kwargs: dict, extra optional params to pass to self.fprop.\n    :return: the content of layer `layer`\n    \"\"\"", "\n", "return", "self", ".", "fprop", "(", "x", ",", "**", "kwargs", ")", "[", "layer", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.make_input_placeholder": [[179, 188], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "make_input_placeholder", "(", "self", ")", ":", "\n", "    ", "\"\"\"Create and return a placeholder representing an input to the model.\n\n    This method should respect context managers (e.g. \"with tf.device\")\n    and should not just return a reference to a single pre-created\n    placeholder.\n    \"\"\"", "\n", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\" does not implement \"", "\n", "\"make_input_placeholder\"", ")", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.make_label_placeholder": [[190, 199], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "make_label_placeholder", "(", "self", ")", ":", "\n", "    ", "\"\"\"Create and return a placeholder representing class labels.\n\n    This method should respect context managers (e.g. \"with tf.device\")\n    and should not just return a reference to a single pre-created\n    placeholder.\n    \"\"\"", "\n", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\" does not implement \"", "\n", "\"make_label_placeholder\"", ")", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.__hash__": [[201, 203], ["hash", "id"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "    ", "return", "hash", "(", "id", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.__eq__": [[204, 206], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "    ", "return", "self", "is", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.CallableModelWrapper.__init__": [[211, 224], ["model.Model.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "callable_fn", ",", "output_layer", ")", ":", "\n", "    ", "\"\"\"\n    Wrap a callable function that takes a tensor as input and returns\n    a tensor as output with the given layer name.\n    :param callable_fn: The callable function taking a tensor and\n                        returning a given layer as output.\n    :param output_layer: A string of the output layer returned by the\n                         function. (Usually either \"probs\" or \"logits\".)\n    \"\"\"", "\n", "\n", "super", "(", "CallableModelWrapper", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_layer", "=", "output_layer", "\n", "self", ".", "callable_fn", "=", "callable_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.CallableModelWrapper.fprop": [[225, 244], ["model.CallableModelWrapper.callable_fn", "tensorflow.reduce_min", "tensorflow.reduce_max", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "output", "=", "self", ".", "callable_fn", "(", "x", ",", "**", "kwargs", ")", "\n", "\n", "# Do some sanity checking to reduce the chance that probs are used", "\n", "# as logits accidentally or vice versa", "\n", "if", "self", ".", "output_layer", "==", "'probs'", ":", "\n", "      ", "assert", "output", ".", "op", ".", "type", "==", "\"Softmax\"", "\n", "min_prob", "=", "tf", ".", "reduce_min", "(", "output", ")", "\n", "max_prob", "=", "tf", ".", "reduce_max", "(", "output", ")", "\n", "asserts", "=", "[", "utils_tf", ".", "assert_greater_equal", "(", "min_prob", ",", "\n", "tf", ".", "cast", "(", "0.", ",", "min_prob", ".", "dtype", ")", ")", ",", "\n", "utils_tf", ".", "assert_less_equal", "(", "max_prob", ",", "\n", "tf", ".", "cast", "(", "1.", ",", "max_prob", ".", "dtype", ")", ")", "]", "\n", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "output", "=", "tf", ".", "identity", "(", "output", ")", "\n", "", "", "elif", "self", ".", "output_layer", "==", "'logits'", ":", "\n", "      ", "assert", "output", ".", "op", ".", "type", "!=", "'Softmax'", "\n", "\n", "", "return", "{", "self", ".", "output_layer", ":", "output", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning": [[245, 262], ["warnings.warn"], "function", ["None"], ["", "", "def", "wrapper_warning", "(", ")", ":", "\n", "  ", "\"\"\"\n  Issue a deprecation warning. Used in multiple places that implemented\n  attacks by automatically wrapping a user-supplied callable with a\n  CallableModelWrapper with output_layer=\"probs\".\n  Using \"probs\" as any part of the attack interface is dangerous.\n  We can't just change output_layer to logits because:\n  - that would be a silent interface change. We'd have no way of detecting\n    code that still means to use probs. Note that we can't just check whether\n    the final output op is a softmax---for example, Inception puts a reshape\n    after the softmax.\n  - automatically wrapping user-supplied callables with output_layer='logits'\n    is even worse, see `wrapper_warning_logits`\n  Note: this function will be removed at the same time as the code that\n  calls it.\n  \"\"\"", "\n", "warnings", ".", "warn", "(", "\"Passing a callable is deprecated, because using\"", "\n", "\" probabilities is dangerous. It has a high risk \"", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning_logits": [[268, 280], ["warnings.warn"], "function", ["None"], ["", "def", "wrapper_warning_logits", "(", ")", ":", "\n", "  ", "\"\"\"\n  Issue a deprecation warning. Used in multiple places that implemented\n  attacks by automatically wrapping a user-supplied callable with a\n  CallableModelWrapper with output_layer=\"logits\".\n  This is dangerous because it is under-the-hood automagic that the user\n  may not realize has been invoked for them. If they pass a callable\n  that actually outputs probs, the probs will be treated as logits,\n  resulting in an incorrect cross-entropy loss and severe gradient\n  masking.\n  \"\"\"", "\n", "warnings", ".", "warn", "(", "\"Passing a callable is deprecated, because it runs the \"", "\n", "\"risk of accidentally using probabilities in the place \"", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.Attack.__init__": [[33, 47], ["cleverhans.attacks.Attack.__init__", "tensorflow.as_dtype", "numpy.dtype", "ValueError", "isinstance", "ValueError"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "dtypestr", "=", "'float32'", ")", ":", "\n", "    ", "super", "(", "Attack", ",", "self", ")", ".", "__init__", "(", "model", ",", "dtypestr", "=", "dtypestr", ")", "\n", "# Validate the input arguments.", "\n", "if", "dtypestr", "!=", "'float32'", "and", "dtypestr", "!=", "'float64'", ":", "\n", "      ", "raise", "ValueError", "(", "\"Unexpected input for argument dtypestr.\"", ")", "\n", "", "self", ".", "tf_dtype", "=", "tf", ".", "as_dtype", "(", "dtypestr", ")", "\n", "self", ".", "np_dtype", "=", "np", ".", "dtype", "(", "dtypestr", ")", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "raise", "ValueError", "(", "\"The model argument should be an instance of\"", "\n", "\" the cleverhans.model.Model class.\"", ")", "\n", "# Prepare attributes", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "dtypestr", "=", "dtypestr", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.Attack.construct_graph": [[48, 56], ["AttributeError"], "methods", ["None"], ["", "def", "construct_graph", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Constructs the graph required to run the attacks.\n    Is inherited from the attack class, is overloaded\n    to raise an error.\n    \"\"\"", "\n", "error", "=", "\"This method is not required for eager execution.\"", "\n", "raise", "AttributeError", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.Attack.generate_np": [[57, 69], ["tfe.Variable", "attacks_tfe.Attack.generate", "attacks_tfe.Attack.numpy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "generate_np", "(", "self", ",", "x_val", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate adversarial examples and return them as a NumPy array.\n\n    :param x_val: A NumPy array with the original inputs.\n    :param **kwargs: optional parameters used by child classes.\n    :return: A NumPy array holding the adversarial examples.\n    \"\"\"", "\n", "tfe", "=", "tf", ".", "contrib", ".", "eager", "\n", "x", "=", "tfe", ".", "Variable", "(", "x_val", ")", "\n", "adv_x", "=", "self", ".", "generate", "(", "x", ",", "**", "kwargs", ")", "\n", "return", "adv_x", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.Attack.construct_variables": [[70, 78], ["AttributeError"], "methods", ["None"], ["", "def", "construct_variables", "(", "self", ",", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Construct the inputs to the attack graph.\n    Is inherited from the attack class, is overloaded\n    to raise an error.\n    \"\"\"", "\n", "error", "=", "\"This method is not required for eager execution.\"", "\n", "raise", "AttributeError", "(", "error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.FastGradientMethod.__init__": [[91, 103], ["super().__init__", "isinstance", "cleverhans.model.wrapper_warning", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning"], ["def", "__init__", "(", "self", ",", "model", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Creates a FastGradientMethod instance in eager execution.\n    :model: cleverhans.model.Model\n    :dtypestr: datatype in the string format.\n    \"\"\"", "\n", "del", "kwargs", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'probs'", ")", "\n", "\n", "", "super", "(", "FastGradientMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "dtypestr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.FastGradientMethod.generate": [[104, 127], ["attacks_tfe.FastGradientMethod.parse_params", "attacks_tfe.FastGradientMethod.get_or_guess_labels", "attacks_tfe.FastGradientMethod.fgm"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.fgm"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generates the adversarial sample for the given input.\n    :param x: The model's inputs.\n    :param eps: (optional float) attack step size (input variation)\n    :param ord: (optional) Order of the norm (mimics NumPy).\n                Possible values: np.inf, 1 or 2.\n    :param y: (optional) A tf variable` with the model labels. Only provide\n              this parameter if you'd like to use true labels when crafting\n              adversarial samples. Otherwise, model predictions are used as\n              labels to avoid the \"label leaking\" effect (explained in this\n              paper: https://arxiv.org/abs/1611.01236). Default is None.\n              Labels should be one-hot-encoded.\n    :param y_target: (optional) A tf variable` with the labels to target.\n                        Leave y_target=None if y is also set.\n                        Labels should be one-hot-encoded.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "labels", ",", "_nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "return", "self", ".", "fgm", "(", "x", ",", "labels", "=", "labels", ",", "targeted", "=", "(", "self", ".", "y_target", "is", "not", "None", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.FastGradientMethod.fgm": [[128, 160], ["tape.gradient", "cleverhans.attacks.optimize_linear", "tensorflow.GradientTape", "tape.watch", "cleverhans.loss.LossCrossEntropy", "cleverhans.loss.LossCrossEntropy.fprop", "tensorflow.clip_by_value"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.optimize_linear", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value"], ["", "def", "fgm", "(", "self", ",", "x", ",", "labels", ",", "targeted", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    TensorFlow Eager implementation of the Fast Gradient Method.\n    :param x: the input variable\n    :param targeted: Is the attack targeted or untargeted? Untargeted, the\n                     default, will try to make the label incorrect.\n                     Targeted will instead try to move in the direction\n                     of being more like y.\n    :return: a tensor for the adversarial example\n    \"\"\"", "\n", "# Compute loss", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "# input should be watched because it may be", "\n", "# combination of trainable and non-trainable variables", "\n", "      ", "tape", ".", "watch", "(", "x", ")", "\n", "loss_obj", "=", "LossCrossEntropy", "(", "self", ".", "model", ",", "smoothing", "=", "0.", ")", "\n", "loss", "=", "loss_obj", ".", "fprop", "(", "x", "=", "x", ",", "y", "=", "labels", ")", "\n", "if", "targeted", ":", "\n", "        ", "loss", "=", "-", "loss", "\n", "\n", "# Define gradient of loss wrt input", "\n", "", "", "grad", "=", "tape", ".", "gradient", "(", "loss", ",", "x", ")", "\n", "optimal_perturbation", "=", "attacks", ".", "optimize_linear", "(", "grad", ",", "self", ".", "eps", ",", "self", ".", "ord", ")", "\n", "\n", "# Add perturbation to original example to obtain adversarial example", "\n", "adv_x", "=", "x", "+", "optimal_perturbation", "\n", "\n", "# If clipping is needed", "\n", "# reset all values outside of [clip_min, clip_max]", "\n", "if", "(", "self", ".", "clip_min", "is", "not", "None", ")", "and", "(", "self", ".", "clip_max", "is", "not", "None", ")", ":", "\n", "      ", "adv_x", "=", "tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tfe.BasicIterativeMethod.__init__": [[173, 184], ["super().__init__", "isinstance", "cleverhans.model.wrapper_warning", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning"], ["def", "__init__", "(", "self", ",", "model", ",", "dtypestr", "=", "'float32'", ")", ":", "\n", "    ", "\"\"\"\n    Creates a BasicIterativeMethod instance in eager execution.\n    :param model: cleverhans.model.Model\n    :param dtypestr: datatype in the string format.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'probs'", ")", "\n", "\n", "", "super", "(", "BasicIterativeMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "dtypestr", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackConfig.__init__": [[294, 303], ["isinstance", "isinstance", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "attack", ",", "params", "=", "None", ",", "name", "=", "None", ",", "pass_y", "=", "False", ")", ":", "\n", "    ", "self", ".", "attack", "=", "attack", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "name", "=", "name", "\n", "if", "params", "is", "not", "None", ":", "\n", "      ", "assert", "isinstance", "(", "params", ",", "dict", ")", "\n", "for", "key", "in", "params", ":", "\n", "        ", "assert", "isinstance", "(", "key", ",", "six", ".", "string_types", ")", ",", "type", "(", "key", ")", "\n", "", "", "self", ".", "pass_y", "=", "pass_y", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackConfig.__str__": [[304, 308], ["str", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "name", "is", "not", "None", ":", "\n", "      ", "return", "self", ".", "name", "\n", "", "return", "\"AttackConfig(\"", "+", "str", "(", "self", ".", "attack", ")", "+", "\", \"", "+", "str", "(", "self", ".", "params", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackConfig.__repr__": [[309, 311], ["attack_bundling.AttackConfig.__str__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackConfig.__str__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "__str__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.start": [[517, 524], ["None"], "methods", ["None"], ["def", "start", "(", "self", ",", "run_counts", ")", ":", "\n", "    ", "\"\"\"\n    Called by the bundler when it starts working on the goal.\n\n    :param run_counts: dict mapping AttackConfigs to numpy arrays reporting\n      how many times they have been run on each example.\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.get_criteria": [[525, 548], ["attack_bundling.AttackGoal.extra_criteria", "attack_bundling._CriteriaFactory", "cleverhans.evaluation.batch_eval_multi_worker", "dict", "cleverhans.utils.safe_zip"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.extra_criteria", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["", "def", "get_criteria", "(", "self", ",", "sess", ",", "model", ",", "advx", ",", "y", ",", "batch_size", "=", "BATCH_SIZE", ")", ":", "\n", "    ", "\"\"\"\n    Returns a dictionary mapping the name of each criterion to a NumPy\n    array containing the value of that criterion for each adversarial\n    example.\n    Subclasses can add extra criteria by implementing the `extra_criteria`\n    method.\n\n    :param sess: tf.session.Session\n    :param model: cleverhans.model.Model\n    :param adv_x: numpy array containing the adversarial examples made so far\n      by earlier work in the bundling process\n    :param y: numpy array containing true labels\n    :param batch_size: int, batch size\n    \"\"\"", "\n", "\n", "names", ",", "factory", "=", "self", ".", "extra_criteria", "(", ")", "\n", "factory", "=", "_CriteriaFactory", "(", "model", ",", "factory", ")", "\n", "results", "=", "batch_eval_multi_worker", "(", "sess", ",", "factory", ",", "[", "advx", ",", "y", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "devices", "=", "devices", ")", "\n", "names", "=", "[", "'correctness'", ",", "'confidence'", "]", "+", "names", "\n", "out", "=", "dict", "(", "safe_zip", "(", "names", ",", "results", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.extra_criteria": [[549, 555], ["None"], "methods", ["None"], ["", "def", "extra_criteria", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Subclasses implement this to specify any extra criteria they need to track.\n    : returns: list of criterion names, _ExtraCriteriaFactory implementing them\n    \"\"\"", "\n", "return", "[", "]", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.request_examples": [[556, 562], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "request_examples", "(", "self", ",", "attack_config", ",", "criteria", ",", "run_counts", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of integer example indices to run in the next batch.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\n", "\"needs to implement request_examples\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.is_satisfied": [[563, 569], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "is_satisfied", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "\"\"\"\n    Returns a bool indicating whether the goal has been satisfied.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\n", "\" needs to implement is_satisfied.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.print_progress": [[570, 578], ["print"], "methods", ["None"], ["", "def", "print_progress", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "\"\"\"\n    Prints a progress message about how much has been done toward the goal.\n    :param criteria: dict, of the format returned by get_criteria\n    :param run_counts: dict mapping each AttackConfig to a numpy array\n      specifying how many times it has been run for each example\n    \"\"\"", "\n", "print", "(", "\"Working on a \"", "+", "self", ".", "__class__", ".", "__name__", "+", "\" goal.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.get_attack_config": [[579, 585], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "get_attack_config", "(", "self", ",", "attack_configs", ",", "run_counts", ",", "criteria", ")", ":", "\n", "    ", "\"\"\"\n    Returns an AttackConfig to run on the next batch.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\n", "\" needs to implement get_attack_config\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.new_wins": [[586, 601], ["NotImplementedError", "str", "type"], "methods", ["None"], ["", "def", "new_wins", "(", "self", ",", "orig_criteria", ",", "orig_idx", ",", "new_criteria", ",", "new_idx", ")", ":", "\n", "    ", "\"\"\"\n    Returns a bool indicating whether a new adversarial example is better\n    than the pre-existing one for the same clean example.\n    :param orig_criteria: dict mapping names of criteria to their value\n      for each example in the whole dataset\n    :param orig_idx: The position of the pre-existing example within the\n      whole dataset.\n    :param new_criteria: dict, like orig_criteria, but with values only\n      on the latest batch of adversarial examples\n    :param new_idx: The position of the new adversarial example within\n      the batch\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "str", "(", "type", "(", "self", ")", ")", "\n", "+", "\" needs to implement new_wins.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.__init__": [[625, 632], ["object.__init__", "all", "all", "numpy.random.RandomState", "isinstance", "isinstance", "new_work_goal.keys", "new_work_goal.values"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "new_work_goal", "=", "None", ",", "break_ties", "=", "'wrong_confidence'", ")", ":", "\n", "    ", "super", "(", "Misclassify", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "new_work_goal", "=", "new_work_goal", "\n", "assert", "all", "(", "isinstance", "(", "key", ",", "AttackConfig", ")", "for", "key", "in", "new_work_goal", ".", "keys", "(", ")", ")", "\n", "assert", "all", "(", "isinstance", "(", "value", ",", "int", ")", "for", "value", "in", "new_work_goal", ".", "values", "(", ")", ")", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "10", ",", "5", ",", "9", "]", ")", "\n", "self", ".", "break_ties", "=", "break_ties", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.start": [[633, 639], ["_logger.info", "cleverhans.utils.deep_copy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deep_copy"], ["", "def", "start", "(", "self", ",", "run_counts", ")", ":", "\n", "    ", "for", "key", "in", "run_counts", ":", "\n", "      ", "value", "=", "run_counts", "[", "key", "]", "\n", "assert", "value", ".", "ndim", "==", "1", "\n", "", "_logger", ".", "info", "(", "\"Started working on a Misclassify goal\"", ")", "\n", "self", ".", "work_before", "=", "deep_copy", "(", "run_counts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.is_satisfied": [[640, 661], ["attack_bundling.Misclassify.filter", "attack_bundling.Misclassify.filter", "attack_bundling.unfinished_attack_configs", "correctness.max", "_logger.info", "len", "_logger.info"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.unfinished_attack_configs"], ["", "def", "is_satisfied", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "correctness", "=", "criteria", "[", "'correctness'", "]", "\n", "assert", "correctness", ".", "dtype", "==", "np", ".", "bool", "\n", "assert", "correctness", ".", "ndim", "==", "1", "\n", "if", "correctness", ".", "max", "(", ")", "==", "0", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Everything is misclassified! Done with Misclassify goal\"", ")", "\n", "return", "True", "\n", "", "if", "self", ".", "new_work_goal", "is", "None", ":", "\n", "      ", "return", "False", "\n", "", "correct_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "correct_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "unfinished", "=", "unfinished_attack_configs", "(", "self", ".", "new_work_goal", ",", "\n", "correct_work_before", ",", "\n", "correct_run_counts", ")", "\n", "finished", "=", "len", "(", "unfinished", ")", "==", "0", "\n", "if", "finished", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Misclassify timed out after running all requested attacks\"", ")", "\n", "", "else", ":", "\n", "      ", "pass", "\n", "# _logger.info(\"Miclassify goal still has attacks to run\")", "\n", "", "return", "finished", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.print_progress": [[662, 682], ["print", "criteria[].sum", "print", "print", "print", "attack_bundling.Misclassify.filter", "attack_bundling.Misclassify.filter", "str", "new.min", "print", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter"], ["", "def", "print_progress", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "print", "(", "\"Working on a \"", "+", "self", ".", "__class__", ".", "__name__", "+", "\" goal.\"", ")", "\n", "num_below", "=", "criteria", "[", "'correctness'", "]", ".", "sum", "(", ")", "\n", "print", "(", "str", "(", "num_below", ")", "+", "\" examples are still correctly classified.\"", ")", "\n", "if", "self", ".", "new_work_goal", "is", "None", ":", "\n", "      ", "print", "(", "\"No work goal: running all attacks indefinitely\"", ")", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"Working until all attacks have been run enough times\"", ")", "\n", "filtered_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "filtered_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "for", "ac", "in", "self", ".", "new_work_goal", ":", "\n", "        ", "goal", "=", "self", ".", "new_work_goal", "[", "ac", "]", "\n", "new", "=", "filtered_run_counts", "[", "ac", "]", "-", "filtered_work_before", "[", "ac", "]", "\n", "if", "new", ".", "size", ">", "0", ":", "\n", "          ", "min_new", "=", "new", ".", "min", "(", ")", "\n", "if", "min_new", "<", "goal", ":", "\n", "            ", "num_min", "=", "(", "new", "==", "min_new", ")", ".", "sum", "(", ")", "\n", "print", "(", "\"\\t\"", "+", "str", "(", "ac", ")", "+", "\": goal of \"", "+", "str", "(", "goal", ")", "+", "\" runs, but \"", "\n", "+", "str", "(", "num_min", ")", "+", "\" examples have been run only \"", "+", "str", "(", "min_new", ")", "\n", "+", "\" times\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.filter": [[683, 690], ["cleverhans.utils.deep_copy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deep_copy"], ["", "", "", "", "", "def", "filter", "(", "self", ",", "run_counts", ",", "criteria", ")", ":", "\n", "    ", "correctness", "=", "criteria", "[", "'correctness'", "]", "\n", "assert", "correctness", ".", "dtype", "==", "np", ".", "bool", "\n", "filtered_counts", "=", "deep_copy", "(", "run_counts", ")", "\n", "for", "key", "in", "filtered_counts", ":", "\n", "      ", "filtered_counts", "[", "key", "]", "=", "filtered_counts", "[", "key", "]", "[", "correctness", "]", "\n", "", "return", "filtered_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.get_attack_config": [[691, 700], ["attack_bundling.Misclassify.filter", "attack_bundling.Misclassify.filter", "attack_bundling.unfinished_attack_configs", "attack_bundling.Misclassify.rng.randint", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.unfinished_attack_configs"], ["", "def", "get_attack_config", "(", "self", ",", "attack_configs", ",", "run_counts", ",", "criteria", ")", ":", "\n", "    ", "if", "self", ".", "new_work_goal", "is", "not", "None", ":", "\n", "      ", "correct_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "correct_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "attack_configs", "=", "unfinished_attack_configs", "(", "self", ".", "new_work_goal", ",", "\n", "correct_work_before", ",", "\n", "correct_run_counts", ")", "\n", "", "attack_config", "=", "attack_configs", "[", "self", ".", "rng", ".", "randint", "(", "len", "(", "attack_configs", ")", ")", "]", "\n", "return", "attack_config", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.extra_criteria": [[701, 706], ["NotImplementedError", "attack_bundling._WrongConfidenceFactory"], "methods", ["None"], ["", "def", "extra_criteria", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "break_ties", "==", "\"wrong_confidence\"", ":", "\n", "      ", "return", "[", "\"wrong_confidence\"", "]", ",", "_WrongConfidenceFactory", "(", ")", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.request_examples": [[707, 736], ["correctness.sum", "numpy.arange", "list", "cleverhans.utils.safe_zip.sort", "numpy.array", "cleverhans.utils.safe_zip", "cleverhans.utils.safe_zip", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["", "", "def", "request_examples", "(", "self", ",", "attack_config", ",", "criteria", ",", "run_counts", ",", "batch_size", ")", ":", "\n", "    ", "correctness", "=", "criteria", "[", "'correctness'", "]", "\n", "assert", "correctness", ".", "dtype", "==", "np", ".", "bool", "\n", "total", "=", "correctness", ".", "size", "\n", "total_correct", "=", "correctness", ".", "sum", "(", ")", "\n", "all_idxs", "=", "np", ".", "arange", "(", "total", ")", "\n", "run_counts", "=", "run_counts", "[", "attack_config", "]", "\n", "if", "total_correct", ">", "0", ":", "\n", "      ", "correct_idxs", "=", "all_idxs", "[", "correctness", "]", "\n", "assert", "correct_idxs", ".", "size", "==", "total_correct", "\n", "run_counts", "=", "run_counts", "[", "correctness", "]", "\n", "pairs", "=", "safe_zip", "(", "correct_idxs", ",", "run_counts", ")", "\n", "", "else", ":", "\n", "      ", "pairs", "=", "safe_zip", "(", "all_idxs", ",", "run_counts", ")", "\n", "# In PY3, pairs is now an iterator.", "\n", "# To support sorting, we need to make it a list.", "\n", "", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "def", "key", "(", "pair", ")", ":", "\n", "      ", "return", "pair", "[", "1", "]", "\n", "", "pairs", ".", "sort", "(", "key", "=", "key", ")", "\n", "idxs", "=", "[", "pair", "[", "0", "]", "for", "pair", "in", "pairs", "]", "\n", "while", "len", "(", "idxs", ")", "<", "batch_size", ":", "\n", "      ", "needed", "=", "batch_size", "-", "len", "(", "idxs", ")", "\n", "idxs", "=", "idxs", "+", "idxs", "[", ":", "needed", "]", "\n", "", "if", "len", "(", "idxs", ")", ">", "batch_size", ":", "\n", "      ", "idxs", "=", "idxs", "[", ":", "batch_size", "]", "\n", "", "idxs", "=", "np", ".", "array", "(", "idxs", ")", "\n", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.Misclassify.new_wins": [[737, 751], ["NotImplementedError"], "methods", ["None"], ["", "def", "new_wins", "(", "self", ",", "orig_criteria", ",", "orig_idx", ",", "new_criteria", ",", "new_idx", ")", ":", "\n", "    ", "orig_correct", "=", "orig_criteria", "[", "'correctness'", "]", "[", "orig_idx", "]", "\n", "new_correct", "=", "new_criteria", "[", "'correctness'", "]", "[", "new_idx", "]", "\n", "if", "orig_correct", "and", "not", "new_correct", ":", "\n", "      ", "return", "True", "\n", "", "if", "(", "not", "orig_correct", ")", "and", "new_correct", ":", "\n", "      ", "return", "False", "\n", "", "assert", "orig_correct", "==", "new_correct", "\n", "if", "self", ".", "break_ties", "==", "\"wrong_confidence\"", ":", "\n", "      ", "new", "=", "new_criteria", "[", "\"wrong_confidence\"", "]", "[", "new_idx", "]", "\n", "orig", "=", "orig_criteria", "[", "'wrong_confidence'", "]", "[", "orig_idx", "]", "\n", "return", "new", ">", "orig", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "(", "self", ".", "break_ties", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.__init__": [[779, 788], ["object.__init__", "numpy.random.RandomState", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "t", "=", "1.", ",", "new_work_goal", "=", "None", ")", ":", "\n", "    ", "super", "(", "MaxConfidence", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "t", "=", "t", "\n", "self", ".", "new_work_goal", "=", "new_work_goal", "\n", "if", "new_work_goal", "is", "not", "None", ":", "\n", "      ", "for", "key", "in", "new_work_goal", ":", "\n", "        ", "assert", "isinstance", "(", "key", ",", "AttackConfig", ")", "\n", "assert", "isinstance", "(", "new_work_goal", "[", "key", "]", ",", "int", ")", "\n", "", "", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "10", ",", "7", ",", "12", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter": [[789, 796], ["cleverhans.utils.deep_copy"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deep_copy"], ["", "def", "filter", "(", "self", ",", "run_counts", ",", "criteria", ")", ":", "\n", "    ", "wrong_confidence", "=", "criteria", "[", "'wrong_confidence'", "]", "\n", "below_t", "=", "wrong_confidence", "<=", "self", ".", "t", "\n", "filtered_counts", "=", "deep_copy", "(", "run_counts", ")", "\n", "for", "key", "in", "filtered_counts", ":", "\n", "      ", "filtered_counts", "[", "key", "]", "=", "filtered_counts", "[", "key", "]", "[", "below_t", "]", "\n", "", "return", "filtered_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.extra_criteria": [[797, 799], ["attack_bundling._WrongConfidenceFactory"], "methods", ["None"], ["", "def", "extra_criteria", "(", "self", ")", ":", "\n", "    ", "return", "[", "\"wrong_confidence\"", "]", ",", "_WrongConfidenceFactory", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.is_satisfied": [[800, 821], ["attack_bundling.MaxConfidence.filter", "attack_bundling.MaxConfidence.filter", "attack_bundling.unfinished_attack_configs", "wrong_confidence.min", "_logger.info", "_logger.info", "len", "_logger.info", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.unfinished_attack_configs"], ["", "def", "is_satisfied", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "wrong_confidence", "=", "criteria", "[", "'wrong_confidence'", "]", "\n", "if", "wrong_confidence", ".", "min", "(", ")", ">", "self", ".", "t", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Everything is above threshold \"", "+", "str", "(", "self", ".", "t", ")", ")", "\n", "_logger", ".", "info", "(", "\"Done with MaxConfidence goal\"", ")", "\n", "return", "True", "\n", "", "if", "self", ".", "new_work_goal", "is", "None", ":", "\n", "      ", "return", "False", "\n", "", "filtered_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "filtered_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "unfinished", "=", "unfinished_attack_configs", "(", "self", ".", "new_work_goal", ",", "\n", "filtered_work_before", ",", "\n", "filtered_run_counts", ",", "\n", "log", "=", "False", ")", "\n", "finished", "=", "len", "(", "unfinished", ")", "==", "0", "\n", "if", "finished", ":", "\n", "      ", "_logger", ".", "info", "(", "\n", "\"MaxConfidence timed out after running all requested attacks\"", ")", "\n", "", "else", ":", "\n", "      ", "pass", "\n", "", "return", "finished", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.print_progress": [[822, 845], ["print", "print", "print", "print", "print", "print", "attack_bundling.MaxConfidence.filter", "attack_bundling.MaxConfidence.filter", "new.min", "str", "str", "print", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter"], ["", "def", "print_progress", "(", "self", ",", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "print", "(", "\"Working on a \"", "+", "self", ".", "__class__", ".", "__name__", "+", "\" goal.\"", ")", "\n", "if", "self", ".", "t", "==", "1.", ":", "\n", "      ", "print", "(", "\"Threshold of 1, so just driving up confidence of all examples.\"", ")", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"Target threshold of \"", "+", "str", "(", "self", ".", "t", ")", ")", "\n", "num_below", "=", "(", "criteria", "[", "'wrong_confidence'", "]", "<=", "self", ".", "t", ")", ".", "sum", "(", ")", "\n", "print", "(", "str", "(", "num_below", ")", "+", "\" examples are below the target threshold.\"", ")", "\n", "", "if", "self", ".", "new_work_goal", "is", "None", ":", "\n", "      ", "print", "(", "\"No work goal: running all attacks indefinitely\"", ")", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"Working until all attacks have been run enough times\"", ")", "\n", "filtered_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "filtered_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "for", "ac", "in", "self", ".", "new_work_goal", ":", "\n", "        ", "goal", "=", "self", ".", "new_work_goal", "[", "ac", "]", "\n", "new", "=", "filtered_run_counts", "[", "ac", "]", "-", "filtered_work_before", "[", "ac", "]", "\n", "min_new", "=", "new", ".", "min", "(", ")", "\n", "if", "min_new", "<", "goal", ":", "\n", "          ", "num_min", "=", "(", "new", "==", "min_new", ")", ".", "sum", "(", ")", "\n", "print", "(", "\"\\t\"", "+", "str", "(", "ac", ")", "+", "\": goal of \"", "+", "str", "(", "goal", ")", "+", "\" runs, but \"", "\n", "+", "str", "(", "num_min", ")", "+", "\" examples have been run only \"", "+", "str", "(", "min_new", ")", "\n", "+", "\" times\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.get_attack_config": [[846, 856], ["attack_bundling.MaxConfidence.filter", "attack_bundling.MaxConfidence.filter", "attack_bundling.unfinished_attack_configs", "attack_bundling.MaxConfidence.rng.randint", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.filter", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.unfinished_attack_configs"], ["", "", "", "", "def", "get_attack_config", "(", "self", ",", "attack_configs", ",", "run_counts", ",", "criteria", ")", ":", "\n", "# TODO: refactor to avoid this duplicated method", "\n", "    ", "if", "self", ".", "new_work_goal", "is", "not", "None", ":", "\n", "      ", "correct_work_before", "=", "self", ".", "filter", "(", "self", ".", "work_before", ",", "criteria", ")", "\n", "correct_run_counts", "=", "self", ".", "filter", "(", "run_counts", ",", "criteria", ")", "\n", "attack_configs", "=", "unfinished_attack_configs", "(", "self", ".", "new_work_goal", ",", "\n", "correct_work_before", ",", "\n", "correct_run_counts", ")", "\n", "", "attack_config", "=", "attack_configs", "[", "self", ".", "rng", ".", "randint", "(", "len", "(", "attack_configs", ")", ")", "]", "\n", "return", "attack_config", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.start": [[857, 868], ["_logger.info", "_logger.info", "cleverhans.utils.deep_copy", "str", "_logger.info", "_logger.info", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deep_copy"], ["", "def", "start", "(", "self", ",", "run_counts", ")", ":", "\n", "    ", "_logger", ".", "info", "(", "\"Started working on a MaxConfidence goal\"", ")", "\n", "_logger", ".", "info", "(", "\"Threshold: \"", "+", "str", "(", "self", ".", "t", ")", ")", "\n", "if", "self", ".", "new_work_goal", "is", "None", ":", "\n", "      ", "if", "self", ".", "t", ">=", "1.", ":", "\n", "        ", "_logger", ".", "info", "(", "\"This goal will run forever\"", ")", "\n", "", "else", ":", "\n", "        ", "_logger", ".", "info", "(", "\"This goal will run until all examples have confidence\"", "\n", "+", "\" greater than \"", "+", "str", "(", "self", ".", "t", ")", "+", "\", which may never\"", "\n", "+", "\" happen.\"", ")", "\n", "", "", "self", ".", "work_before", "=", "deep_copy", "(", "run_counts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.request_examples": [[869, 896], ["below_t.sum", "numpy.arange", "cleverhans.utils.safe_zip.sort", "numpy.array", "cleverhans.utils.safe_zip", "cleverhans.utils.safe_zip", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["", "def", "request_examples", "(", "self", ",", "attack_config", ",", "criteria", ",", "run_counts", ",", "batch_size", ")", ":", "\n", "    ", "wrong_confidence", "=", "criteria", "[", "'wrong_confidence'", "]", "\n", "below_t", "=", "wrong_confidence", "<=", "self", ".", "t", "\n", "assert", "below_t", ".", "dtype", "==", "np", ".", "bool", "\n", "total", "=", "below_t", ".", "size", "\n", "total_below", "=", "below_t", ".", "sum", "(", ")", "\n", "all_idxs", "=", "np", ".", "arange", "(", "total", ")", "\n", "run_counts", "=", "run_counts", "[", "attack_config", "]", "\n", "if", "total_below", ">", "0", ":", "\n", "      ", "correct_idxs", "=", "all_idxs", "[", "below_t", "]", "\n", "assert", "correct_idxs", ".", "size", "==", "total_below", "\n", "run_counts", "=", "run_counts", "[", "below_t", "]", "\n", "pairs", "=", "safe_zip", "(", "correct_idxs", ",", "run_counts", ")", "\n", "", "else", ":", "\n", "      ", "pairs", "=", "safe_zip", "(", "all_idxs", ",", "run_counts", ")", "\n", "\n", "", "def", "key", "(", "pair", ")", ":", "\n", "      ", "return", "pair", "[", "1", "]", "\n", "", "pairs", ".", "sort", "(", "key", "=", "key", ")", "\n", "idxs", "=", "[", "pair", "[", "0", "]", "for", "pair", "in", "pairs", "]", "\n", "while", "len", "(", "idxs", ")", "<", "batch_size", ":", "\n", "      ", "needed", "=", "batch_size", "-", "len", "(", "idxs", ")", "\n", "idxs", "=", "idxs", "+", "idxs", "[", ":", "needed", "]", "\n", "", "if", "len", "(", "idxs", ")", ">", "batch_size", ":", "\n", "      ", "idxs", "=", "idxs", "[", ":", "batch_size", "]", "\n", "", "idxs", "=", "np", ".", "array", "(", "idxs", ")", "\n", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.new_wins": [[897, 901], ["None"], "methods", ["None"], ["", "def", "new_wins", "(", "self", ",", "orig_criteria", ",", "orig_idx", ",", "new_criteria", ",", "new_idx", ")", ":", "\n", "    ", "new_wrong_confidence", "=", "new_criteria", "[", "'wrong_confidence'", "]", "[", "new_idx", "]", "\n", "orig_wrong_confidence", "=", "orig_criteria", "[", "'wrong_confidence'", "]", "[", "orig_idx", "]", "\n", "return", "new_wrong_confidence", ">", "orig_wrong_confidence", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._CriteriaFactory.__init__": [[957, 966], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "extra_criteria_factory", "=", "None", ")", ":", "\n", "    ", "self", ".", "model", "=", "model", "\n", "self", ".", "extra_criteria_factory", "=", "extra_criteria_factory", "\n", "properties_to_hash", "=", "(", "model", ",", ")", "\n", "if", "extra_criteria_factory", "is", "not", "None", ":", "\n", "      ", "if", "extra_criteria_factory", ".", "properties_to_hash", "is", "not", "None", ":", "\n", "        ", "extra_properties", "=", "extra_criteria_factory", ".", "properties_to_hash", "\n", "properties_to_hash", "=", "properties_to_hash", "+", "extra_properties", "\n", "", "", "self", ".", "properties_to_hash", "=", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._CriteriaFactory.__hash__": [[967, 971], ["attack_bundling._CriteriaFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._CriteriaFactory.__eq__": [[972, 981], ["isinstance", "type", "type"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_CriteriaFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "if", "(", "type", "(", "self", ".", "extra_criteria_factory", ")", "is", "not", "\n", "type", "(", "other", ".", "extra_criteria_factory", ")", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._CriteriaFactory.__call__": [[982, 999], ["attack_bundling._CriteriaFactory.model.make_input_placeholder", "attack_bundling._CriteriaFactory.model.make_label_placeholder", "attack_bundling._CriteriaFactory.model.get_probs", "tensorflow.equal", "tensorflow.reduce_max", "tensorflow.argmax", "tensorflow.argmax", "attack_bundling._CriteriaFactory.extra_criteria_factory", "tuple"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "x_batch", "=", "self", ".", "model", ".", "make_input_placeholder", "(", ")", "\n", "y_batch", "=", "self", ".", "model", ".", "make_label_placeholder", "(", ")", "\n", "\n", "predictions", "=", "self", ".", "model", ".", "get_probs", "(", "x_batch", ")", "\n", "correct", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "y_batch", ",", "axis", "=", "-", "1", ")", ",", "\n", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", ")", "\n", "max_probs", "=", "tf", ".", "reduce_max", "(", "predictions", ",", "axis", "=", "1", ")", "\n", "\n", "if", "self", ".", "extra_criteria_factory", "is", "not", "None", ":", "\n", "      ", "extra_criteria", "=", "self", ".", "extra_criteria_factory", "(", "x_batch", ",", "y_batch", ",", "\n", "predictions", ",", "correct", ",", "\n", "max_probs", ")", "\n", "", "else", ":", "\n", "      ", "extra_criteria", "=", "tuple", "(", "[", "]", ")", "\n", "\n", "", "return", "(", "x_batch", ",", "y_batch", ")", ",", "(", "correct", ",", "max_probs", ")", "+", "extra_criteria", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._ExtraCriteriaFactory.__init__": [[1006, 1008], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "properties_to_hash", "=", "None", ")", ":", "\n", "    ", "self", ".", "properties_to_hash", "=", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._ExtraCriteriaFactory.__hash__": [[1009, 1013], ["attack_bundling._ExtraCriteriaFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._ExtraCriteriaFactory.__eq__": [[1014, 1020], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_ExtraCriteriaFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._ExtraCriteriaFactory.__call__": [[1021, 1023], ["NotImplementedError"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x_batch", ",", "y_batch", ",", "predictions", ",", "correct", ",", "max_probs", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling._WrongConfidenceFactory.__call__": [[1026, 1029], ["tensorflow.reduce_max", "tuple"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["  ", "def", "__call__", "(", "self", ",", "x_batch", ",", "y_batch", ",", "predictions", ",", "correct", ",", "max_probs", ")", ":", "\n", "    ", "max_wrong_probs", "=", "tf", ".", "reduce_max", "(", "predictions", "*", "(", "1.", "-", "y_batch", ")", ",", "axis", "=", "1", ")", "\n", "return", "tuple", "(", "[", "max_wrong_probs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.single_run_max_confidence_recipe": [[42, 106], ["cleverhans.attacks.Noise", "cleverhans.attacks.ProjectedGradientDescent", "attack_bundling.AttackConfig", "copy.copy", "tensorflow.ones", "six.moves.range", "attack_bundling.bundle_attacks", "copy.copy", "tensorflow.to_float", "attack_bundling.AttackConfig", "pgd_attack_configs.append", "copy.copy", "attack_bundling.AttackConfig", "expensive_pgd.append", "attack_bundling.MaxConfidence", "tensorflow.one_hot", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks"], ["def", "single_run_max_confidence_recipe", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "nb_classes", ",", "eps", ",", "\n", "clip_min", ",", "clip_max", ",", "eps_iter", ",", "nb_iter", ",", "\n", "report_path", ",", "\n", "batch_size", "=", "BATCH_SIZE", ",", "\n", "eps_iter_small", "=", "None", ")", ":", "\n", "  ", "\"\"\"A reasonable attack bundling recipe for a max norm threat model and\n  a defender that uses confidence thresholding. This recipe uses both\n  uniform noise and randomly-initialized PGD targeted attacks.\n\n  References:\n  https://openreview.net/forum?id=H1g0piA9tQ\n\n  This version runs each attack (noise, targeted PGD for each class with\n  nb_iter iterations, target PGD for each class with 25X more iterations)\n  just once and then stops. See `basic_max_confidence_recipe` for a version\n  that runs indefinitely.\n\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param nb_classes: int, number of classes\n  :param eps: float, maximum size of perturbation (measured by max norm)\n  :param eps_iter: float, step size for one version of PGD attacks\n    (will also run another version with eps_iter_small step size)\n  :param nb_iter: int, number of iterations for the cheaper PGD attacks\n    (will also run another version with 25X more iterations)\n  :param report_path: str, the path that the report will be saved to.\n  :param batch_size: int, the total number of examples to run simultaneously\n  :param eps_iter_small: optional, float.\n    The second version of the PGD attack is run with 25 * nb_iter iterations\n    and eps_iter_small step size. If eps_iter_small is not specified it is\n    set to eps_iter / 25.\n  \"\"\"", "\n", "noise_attack", "=", "Noise", "(", "model", ",", "sess", ")", "\n", "pgd_attack", "=", "ProjectedGradientDescent", "(", "model", ",", "sess", ")", "\n", "threat_params", "=", "{", "\"eps\"", ":", "eps", ",", "\"clip_min\"", ":", "clip_min", ",", "\"clip_max\"", ":", "clip_max", "}", "\n", "noise_attack_config", "=", "AttackConfig", "(", "noise_attack", ",", "threat_params", ",", "\"noise\"", ")", "\n", "attack_configs", "=", "[", "noise_attack_config", "]", "\n", "pgd_attack_configs", "=", "[", "]", "\n", "pgd_params", "=", "copy", ".", "copy", "(", "threat_params", ")", "\n", "pgd_params", "[", "\"eps_iter\"", "]", "=", "eps_iter", "\n", "pgd_params", "[", "\"nb_iter\"", "]", "=", "nb_iter", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "dev_batch_size", "=", "batch_size", "//", "num_devices", "\n", "ones", "=", "tf", ".", "ones", "(", "dev_batch_size", ",", "tf", ".", "int32", ")", "\n", "expensive_pgd", "=", "[", "]", "\n", "if", "eps_iter_small", "is", "None", ":", "\n", "    ", "eps_iter_small", "=", "eps_iter", "/", "25.", "\n", "", "for", "cls", "in", "range", "(", "nb_classes", ")", ":", "\n", "    ", "cls_params", "=", "copy", ".", "copy", "(", "pgd_params", ")", "\n", "cls_params", "[", "'y_target'", "]", "=", "tf", ".", "to_float", "(", "tf", ".", "one_hot", "(", "ones", "*", "cls", ",", "nb_classes", ")", ")", "\n", "cls_attack_config", "=", "AttackConfig", "(", "pgd_attack", ",", "cls_params", ",", "\"pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "pgd_attack_configs", ".", "append", "(", "cls_attack_config", ")", "\n", "expensive_params", "=", "copy", ".", "copy", "(", "cls_params", ")", "\n", "expensive_params", "[", "\"eps_iter\"", "]", "=", "eps_iter_small", "\n", "expensive_params", "[", "\"nb_iter\"", "]", "*=", "25.", "\n", "expensive_config", "=", "AttackConfig", "(", "\n", "pgd_attack", ",", "expensive_params", ",", "\"expensive_pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "expensive_pgd", ".", "append", "(", "expensive_config", ")", "\n", "", "attack_configs", "=", "[", "noise_attack_config", "]", "+", "pgd_attack_configs", "+", "expensive_pgd", "\n", "new_work_goal", "=", "{", "config", ":", "1", "for", "config", "in", "attack_configs", "}", "\n", "goals", "=", "[", "MaxConfidence", "(", "t", "=", "1.", ",", "new_work_goal", "=", "new_work_goal", ")", "]", "\n", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.basic_max_confidence_recipe": [[108, 177], ["cleverhans.attacks.Noise", "cleverhans.attacks.ProjectedGradientDescent", "attack_bundling.AttackConfig", "copy.copy", "tensorflow.ones", "six.moves.range", "attack_bundling.bundle_attacks", "copy.copy", "tensorflow.to_float", "attack_bundling.AttackConfig", "pgd_attack_configs.append", "copy.copy", "attack_bundling.AttackConfig", "expensive_pgd.append", "attack_bundling.Misclassify", "attack_bundling.Misclassify", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "tensorflow.one_hot", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks"], ["", "def", "basic_max_confidence_recipe", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "nb_classes", ",", "eps", ",", "\n", "clip_min", ",", "clip_max", ",", "eps_iter", ",", "nb_iter", ",", "\n", "report_path", ",", "\n", "batch_size", "=", "BATCH_SIZE", ",", "\n", "eps_iter_small", "=", "None", ")", ":", "\n", "  ", "\"\"\"A reasonable attack bundling recipe for a max norm threat model and\n  a defender that uses confidence thresholding.\n\n  References:\n  https://openreview.net/forum?id=H1g0piA9tQ\n\n  This version runs indefinitely, updating the report on disk continuously.\n\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param nb_classes: int, number of classes\n  :param eps: float, maximum size of perturbation (measured by max norm)\n  :param eps_iter: float, step size for one version of PGD attacks\n    (will also run another version with eps_iter_small)\n  :param nb_iter: int, number of iterations for one version of PGD attacks\n    (will also run another version with 25X more iterations)\n  :param report_path: str, the path that the report will be saved to.\n  :batch_size: int, the total number of examples to run simultaneously\n  :param eps_iter_small: optional, float.\n    The second version of the PGD attack is run with 25 * nb_iter iterations\n    and eps_iter_small step size. If eps_iter_small is not specified it is\n    set to eps_iter / 25.\n  \"\"\"", "\n", "noise_attack", "=", "Noise", "(", "model", ",", "sess", ")", "\n", "pgd_attack", "=", "ProjectedGradientDescent", "(", "model", ",", "sess", ")", "\n", "threat_params", "=", "{", "\"eps\"", ":", "eps", ",", "\"clip_min\"", ":", "clip_min", ",", "\"clip_max\"", ":", "clip_max", "}", "\n", "noise_attack_config", "=", "AttackConfig", "(", "noise_attack", ",", "threat_params", ")", "\n", "attack_configs", "=", "[", "noise_attack_config", "]", "\n", "pgd_attack_configs", "=", "[", "]", "\n", "pgd_params", "=", "copy", ".", "copy", "(", "threat_params", ")", "\n", "pgd_params", "[", "\"eps_iter\"", "]", "=", "eps_iter", "\n", "pgd_params", "[", "\"nb_iter\"", "]", "=", "nb_iter", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "dev_batch_size", "=", "batch_size", "//", "num_devices", "\n", "ones", "=", "tf", ".", "ones", "(", "dev_batch_size", ",", "tf", ".", "int32", ")", "\n", "expensive_pgd", "=", "[", "]", "\n", "if", "eps_iter_small", "is", "None", ":", "\n", "    ", "eps_iter_small", "=", "eps_iter", "/", "25.", "\n", "", "for", "cls", "in", "range", "(", "nb_classes", ")", ":", "\n", "    ", "cls_params", "=", "copy", ".", "copy", "(", "pgd_params", ")", "\n", "cls_params", "[", "'y_target'", "]", "=", "tf", ".", "to_float", "(", "tf", ".", "one_hot", "(", "ones", "*", "cls", ",", "nb_classes", ")", ")", "\n", "cls_attack_config", "=", "AttackConfig", "(", "pgd_attack", ",", "cls_params", ",", "\"pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "pgd_attack_configs", ".", "append", "(", "cls_attack_config", ")", "\n", "expensive_params", "=", "copy", ".", "copy", "(", "cls_params", ")", "\n", "expensive_params", "[", "\"eps_iter\"", "]", "=", "eps_iter_small", "\n", "expensive_params", "[", "\"nb_iter\"", "]", "*=", "25.", "\n", "expensive_config", "=", "AttackConfig", "(", "\n", "pgd_attack", ",", "expensive_params", ",", "\"expensive_pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "expensive_pgd", ".", "append", "(", "expensive_config", ")", "\n", "", "attack_configs", "=", "[", "noise_attack_config", "]", "+", "pgd_attack_configs", "+", "expensive_pgd", "\n", "new_work_goal", "=", "{", "config", ":", "5", "for", "config", "in", "attack_configs", "}", "\n", "pgd_work_goal", "=", "{", "config", ":", "5", "for", "config", "in", "pgd_attack_configs", "}", "\n", "goals", "=", "[", "Misclassify", "(", "new_work_goal", "=", "{", "noise_attack_config", ":", "50", "}", ")", ",", "\n", "Misclassify", "(", "new_work_goal", "=", "pgd_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.5", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.75", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.875", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.9375", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.96875", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.984375", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "1.", ")", "]", "\n", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ")", "\n", "# This runs forever", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.fixed_max_confidence_recipe": [[180, 247], ["cleverhans.attacks.Noise", "cleverhans.attacks.ProjectedGradientDescent", "attack_bundling.AttackConfig", "copy.copy", "tensorflow.ones", "six.moves.range", "attack_bundling.bundle_attacks", "copy.copy", "tensorflow.to_float", "attack_bundling.AttackConfig", "pgd_attack_configs.append", "copy.copy", "attack_bundling.AttackConfig", "expensive_pgd.append", "attack_bundling.Misclassify", "attack_bundling.Misclassify", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "attack_bundling.MaxConfidence", "tensorflow.one_hot", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks"], ["", "def", "fixed_max_confidence_recipe", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "nb_classes", ",", "eps", ",", "\n", "clip_min", ",", "clip_max", ",", "eps_iter", ",", "nb_iter", ",", "\n", "report_path", ",", "\n", "batch_size", "=", "BATCH_SIZE", ")", ":", "\n", "  ", "\"\"\"A reasonable attack bundling recipe for a max norm threat model and\n  a defender that uses confidence thresholding.\n\n  References:\n  https://openreview.net/forum?id=H1g0piA9tQ\n\n  This version runs each attack a fixed number of times.\n  It is more exhaustive than `single_run_max_confidence_recipe` but because\n  it uses a fixed budget rather than running indefinitely it is more\n  appropriate for making fair comparisons between two models.\n\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param nb_classes: int, number of classes\n  :param eps: float, maximum size of perturbation (measured by max norm)\n  :param eps_iter: float, step size for one version of PGD attacks\n    (will also run another version with 25X smaller step size)\n  :param nb_iter: int, number of iterations for one version of PGD attacks\n    (will also run another version with 25X more iterations)\n  :param report_path: str, the path that the report will be saved to.\n  :batch_size: int, the total number of examples to run simultaneously\n  \"\"\"", "\n", "noise_attack", "=", "Noise", "(", "model", ",", "sess", ")", "\n", "pgd_attack", "=", "ProjectedGradientDescent", "(", "model", ",", "sess", ")", "\n", "threat_params", "=", "{", "\"eps\"", ":", "eps", ",", "\"clip_min\"", ":", "clip_min", ",", "\"clip_max\"", ":", "clip_max", "}", "\n", "noise_attack_config", "=", "AttackConfig", "(", "noise_attack", ",", "threat_params", ")", "\n", "attack_configs", "=", "[", "noise_attack_config", "]", "\n", "pgd_attack_configs", "=", "[", "]", "\n", "pgd_params", "=", "copy", ".", "copy", "(", "threat_params", ")", "\n", "pgd_params", "[", "\"eps_iter\"", "]", "=", "eps_iter", "\n", "pgd_params", "[", "\"nb_iter\"", "]", "=", "nb_iter", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "dev_batch_size", "=", "batch_size", "//", "num_devices", "\n", "ones", "=", "tf", ".", "ones", "(", "dev_batch_size", ",", "tf", ".", "int32", ")", "\n", "expensive_pgd", "=", "[", "]", "\n", "for", "cls", "in", "range", "(", "nb_classes", ")", ":", "\n", "    ", "cls_params", "=", "copy", ".", "copy", "(", "pgd_params", ")", "\n", "cls_params", "[", "'y_target'", "]", "=", "tf", ".", "to_float", "(", "tf", ".", "one_hot", "(", "ones", "*", "cls", ",", "nb_classes", ")", ")", "\n", "cls_attack_config", "=", "AttackConfig", "(", "pgd_attack", ",", "cls_params", ",", "\"pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "pgd_attack_configs", ".", "append", "(", "cls_attack_config", ")", "\n", "expensive_params", "=", "copy", ".", "copy", "(", "cls_params", ")", "\n", "expensive_params", "[", "\"eps_iter\"", "]", "/=", "25.", "\n", "expensive_params", "[", "\"nb_iter\"", "]", "*=", "25.", "\n", "expensive_config", "=", "AttackConfig", "(", "\n", "pgd_attack", ",", "expensive_params", ",", "\"expensive_pgd_\"", "+", "str", "(", "cls", ")", ")", "\n", "expensive_pgd", ".", "append", "(", "expensive_config", ")", "\n", "", "attack_configs", "=", "[", "noise_attack_config", "]", "+", "pgd_attack_configs", "+", "expensive_pgd", "\n", "new_work_goal", "=", "{", "config", ":", "5", "for", "config", "in", "attack_configs", "}", "\n", "pgd_work_goal", "=", "{", "config", ":", "5", "for", "config", "in", "pgd_attack_configs", "}", "\n", "# TODO: lower priority: make sure bundler won't waste time running targeted", "\n", "# attacks on examples where the target class is the true class.", "\n", "goals", "=", "[", "Misclassify", "(", "new_work_goal", "=", "{", "noise_attack_config", ":", "50", "}", ")", ",", "\n", "Misclassify", "(", "new_work_goal", "=", "pgd_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.5", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.75", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.875", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.9375", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.96875", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "0.984375", ",", "new_work_goal", "=", "new_work_goal", ")", ",", "\n", "MaxConfidence", "(", "t", "=", "1.", ",", "new_work_goal", "=", "new_work_goal", ")", "]", "\n", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.random_search_max_confidence_recipe": [[249, 283], ["cleverhans.attacks.Noise", "attack_bundling.AttackConfig", "attack_bundling.bundle_attacks", "attack_bundling.MaxConfidence"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks"], ["", "def", "random_search_max_confidence_recipe", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "eps", ",", "\n", "clip_min", ",", "clip_max", ",", "\n", "report_path", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "num_noise_points", "=", "10000", ")", ":", "\n", "  ", "\"\"\"Max confidence using random search.\n\n  References:\n  https://openreview.net/forum?id=H1g0piA9tQ\n    Describes the max_confidence procedure used for the bundling in this recipe\n  https://arxiv.org/abs/1802.00420\n    Describes using random search with 1e5 or more random points to avoid\n    gradient masking.\n\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param nb_classes: int, number of classes\n  :param eps: float, maximum size of perturbation (measured by max norm)\n  :param eps_iter: float, step size for one version of PGD attacks\n    (will also run another version with 25X smaller step size)\n  :param nb_iter: int, number of iterations for one version of PGD attacks\n    (will also run another version with 25X more iterations)\n  :param report_path: str, the path that the report will be saved to.\n  :batch_size: int, the total number of examples to run simultaneously\n  \"\"\"", "\n", "noise_attack", "=", "Noise", "(", "model", ",", "sess", ")", "\n", "threat_params", "=", "{", "\"eps\"", ":", "eps", ",", "\"clip_min\"", ":", "clip_min", ",", "\"clip_max\"", ":", "clip_max", "}", "\n", "noise_attack_config", "=", "AttackConfig", "(", "noise_attack", ",", "threat_params", ")", "\n", "attack_configs", "=", "[", "noise_attack_config", "]", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "new_work_goal", "=", "{", "noise_attack_config", ":", "num_noise_points", "}", "\n", "goals", "=", "[", "MaxConfidence", "(", "t", "=", "1.", ",", "new_work_goal", "=", "new_work_goal", ")", "]", "\n", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks": [[313, 377], ["isinstance", "isinstance", "all", "all", "isinstance", "_logger.info", "cleverhans.evaluation.correctness_and_confidence", "_logger.info", "_logger.info", "cleverhans.confidence_report.ConfidenceReport", "cleverhans.confidence_report.ConfidenceReportEntry", "x.copy", "ValueError", "numpy.zeros", "attack_bundling.bundle_attacks_with_goal", "isinstance", "isinstance", "str", "correctness.mean"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.correctness_and_confidence", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks_with_goal"], ["", "", "def", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ",", "\n", "attack_batch_size", "=", "BATCH_SIZE", ",", "eval_batch_size", "=", "BATCH_SIZE", ")", ":", "\n", "  ", "\"\"\"\n  Runs attack bundling.\n  Users of cleverhans may call this function but are more likely to call\n  one of the recipes above.\n\n  Reference: https://openreview.net/forum?id=H1g0piA9tQ\n\n  :param sess: tf.session.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param attack_configs: list of AttackConfigs to run\n  :param goals: list of AttackGoals to run\n    The bundler works through the goals in order, until each is satisfied.\n    Some goals may never be satisfied, in which case the bundler will run\n    forever, updating the report on disk as it goes.\n  :param report_path: str, the path the report will be saved to\n  :param attack_batch_size: int, batch size for generating adversarial examples\n  :param eval_batch_size: int, batch size for evaluating the model on clean / adversarial examples\n  :returns:\n    adv_x: The adversarial examples, in the same format as `x`\n    run_counts: dict mapping each AttackConfig to a numpy array reporting\n      how many times that AttackConfig was run on each example\n  \"\"\"", "\n", "assert", "isinstance", "(", "sess", ",", "tf", ".", "Session", ")", "\n", "assert", "isinstance", "(", "model", ",", "Model", ")", "\n", "assert", "all", "(", "isinstance", "(", "attack_config", ",", "AttackConfig", ")", "for", "attack_config", "\n", "in", "attack_configs", ")", "\n", "assert", "all", "(", "isinstance", "(", "goal", ",", "AttackGoal", ")", "for", "goal", "in", "goals", ")", "\n", "assert", "isinstance", "(", "report_path", ",", "six", ".", "string_types", ")", "\n", "if", "x", ".", "shape", "[", "0", "]", "!=", "y", ".", "shape", "[", "0", "]", ":", "\n", "    ", "raise", "ValueError", "(", "\"Number of input examples does not match number of labels\"", ")", "\n", "\n", "# Note: no need to precompile attacks, correctness_and_confidence", "\n", "# caches them", "\n", "\n", "", "run_counts", "=", "{", "}", "\n", "for", "attack_config", "in", "attack_configs", ":", "\n", "    ", "run_counts", "[", "attack_config", "]", "=", "np", ".", "zeros", "(", "x", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "# TODO: make an interface to pass this in if it has already been computed", "\n", "# elsewhere", "\n", "", "_logger", ".", "info", "(", "\"Running on clean data to initialize the report...\"", ")", "\n", "packed", "=", "correctness_and_confidence", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "batch_size", "=", "eval_batch_size", ",", "\n", "devices", "=", "devices", ")", "\n", "_logger", ".", "info", "(", "\"...done\"", ")", "\n", "correctness", ",", "confidence", "=", "packed", "\n", "_logger", ".", "info", "(", "\"Accuracy: \"", "+", "str", "(", "correctness", ".", "mean", "(", ")", ")", ")", "\n", "report", "=", "ConfidenceReport", "(", ")", "\n", "report", "[", "'clean'", "]", "=", "ConfidenceReportEntry", "(", "correctness", ",", "confidence", ")", "\n", "\n", "adv_x", "=", "x", ".", "copy", "(", ")", "\n", "\n", "for", "goal", "in", "goals", ":", "\n", "    ", "bundle_attacks_with_goal", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "adv_x", ",", "attack_configs", ",", "\n", "run_counts", ",", "\n", "goal", ",", "report", ",", "report_path", ",", "\n", "attack_batch_size", "=", "attack_batch_size", ",", "eval_batch_size", "=", "eval_batch_size", ")", "\n", "\n", "# Many users will set `goals` to make this run forever, so the return", "\n", "# statement is not the primary way to get information out.", "\n", "", "return", "adv_x", ",", "run_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks_with_goal": [[378, 419], ["goal.start", "_logger.info", "goal.get_criteria", "_logger.info", "attack_bundling.save", "goal.is_satisfied", "attack_bundling.run_batch_with_goal", "str", "criteria[].mean"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.start", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.get_criteria", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.is_satisfied", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.run_batch_with_goal"], ["", "def", "bundle_attacks_with_goal", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "adv_x", ",", "attack_configs", ",", "\n", "run_counts", ",", "\n", "goal", ",", "report", ",", "report_path", ",", "\n", "attack_batch_size", "=", "BATCH_SIZE", ",", "eval_batch_size", "=", "BATCH_SIZE", ")", ":", "\n", "  ", "\"\"\"\n  Runs attack bundling, working on one specific AttackGoal.\n  This function is mostly intended to be called by `bundle_attacks`.\n\n  Reference: https://openreview.net/forum?id=H1g0piA9tQ\n\n  :param sess: tf.session.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param adv_x: numpy array containing the adversarial examples made so far\n    by earlier work in the bundling process\n  :param attack_configs: list of AttackConfigs to run\n  :param run_counts: dict mapping AttackConfigs to numpy arrays specifying\n    how many times they have been run on each example\n  :param goal: AttackGoal to run\n  :param report: ConfidenceReport\n  :param report_path: str, the path the report will be saved to\n  :param attack_batch_size: int, batch size for generating adversarial examples\n  :param eval_batch_size: int, batch size for evaluating the model on adversarial examples\n  \"\"\"", "\n", "goal", ".", "start", "(", "run_counts", ")", "\n", "_logger", ".", "info", "(", "\"Running criteria for new goal...\"", ")", "\n", "criteria", "=", "goal", ".", "get_criteria", "(", "sess", ",", "model", ",", "adv_x", ",", "y", ",", "batch_size", "=", "eval_batch_size", ")", "\n", "assert", "'correctness'", "in", "criteria", "\n", "_logger", ".", "info", "(", "\"Accuracy: \"", "+", "str", "(", "criteria", "[", "'correctness'", "]", ".", "mean", "(", ")", ")", ")", "\n", "assert", "'confidence'", "in", "criteria", "\n", "while", "not", "goal", ".", "is_satisfied", "(", "criteria", ",", "run_counts", ")", ":", "\n", "    ", "run_batch_with_goal", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "adv_x", ",", "criteria", ",", "attack_configs", ",", "\n", "run_counts", ",", "\n", "goal", ",", "report", ",", "report_path", ",", "\n", "attack_batch_size", "=", "attack_batch_size", ")", "\n", "# Save after finishing all goals.", "\n", "# The incremental saves run on a timer. This save is needed so that the last", "\n", "# few attacks after the timer don't get discarded", "\n", "", "report", ".", "completed", "=", "True", "\n", "save", "(", "criteria", ",", "report", ",", "report_path", ",", "adv_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.run_batch_with_goal": [[421, 481], ["goal.get_attack_config", "goal.request_examples", "cleverhans.evaluation.run_attack", "goal.get_criteria", "enumerate", "cleverhans.confidence_report.ConfidenceReportEntry", "time.time", "hasattr", "goal.new_wins", "goal.print_progress", "attack_bundling.save", "min", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.get_attack_config", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.request_examples", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.run_attack", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.get_criteria", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.new_wins", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.print_progress", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save"], ["", "def", "run_batch_with_goal", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "adv_x_val", ",", "criteria", ",", "attack_configs", ",", "\n", "run_counts", ",", "goal", ",", "report", ",", "report_path", ",", "\n", "attack_batch_size", "=", "BATCH_SIZE", ")", ":", "\n", "  ", "\"\"\"\n  Runs attack bundling on one batch of data.\n  This function is mostly intended to be called by\n  `bundle_attacks_with_goal`.\n\n  :param sess: tf.session.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param adv_x_val: numpy array containing the adversarial examples made so far\n    by earlier work in the bundling process\n  :param criteria: dict mapping string names of criteria to numpy arrays with\n    their values for each example\n    (Different AttackGoals track different criteria)\n  :param run_counts: dict mapping AttackConfigs to numpy arrays reporting how\n    many times they have been run on each example\n  :param goal: the AttackGoal to work on\n  :param report: dict, see `bundle_attacks_with_goal`\n  :param report_path: str, path to save the report to\n  \"\"\"", "\n", "attack_config", "=", "goal", ".", "get_attack_config", "(", "attack_configs", ",", "run_counts", ",", "criteria", ")", "\n", "idxs", "=", "goal", ".", "request_examples", "(", "attack_config", ",", "criteria", ",", "run_counts", ",", "\n", "attack_batch_size", ")", "\n", "x_batch", "=", "x", "[", "idxs", "]", "\n", "assert", "x_batch", ".", "shape", "[", "0", "]", "==", "attack_batch_size", "\n", "y_batch", "=", "y", "[", "idxs", "]", "\n", "assert", "y_batch", ".", "shape", "[", "0", "]", "==", "attack_batch_size", "\n", "adv_x_batch", "=", "run_attack", "(", "sess", ",", "model", ",", "x_batch", ",", "y_batch", ",", "\n", "attack_config", ".", "attack", ",", "attack_config", ".", "params", ",", "\n", "attack_batch_size", ",", "devices", ",", "pass_y", "=", "attack_config", ".", "pass_y", ")", "\n", "criteria_batch", "=", "goal", ".", "get_criteria", "(", "sess", ",", "model", ",", "adv_x_batch", ",", "y_batch", ",", "\n", "batch_size", "=", "min", "(", "attack_batch_size", ",", "\n", "BATCH_SIZE", ")", ")", "\n", "# This can't be parallelized because some orig examples are copied more", "\n", "# than once into the batch", "\n", "cur_run_counts", "=", "run_counts", "[", "attack_config", "]", "\n", "for", "batch_idx", ",", "orig_idx", "in", "enumerate", "(", "idxs", ")", ":", "\n", "    ", "cur_run_counts", "[", "orig_idx", "]", "+=", "1", "\n", "should_copy", "=", "goal", ".", "new_wins", "(", "criteria", ",", "orig_idx", ",", "criteria_batch", ",", "batch_idx", ")", "\n", "if", "should_copy", ":", "\n", "      ", "adv_x_val", "[", "orig_idx", "]", "=", "adv_x_batch", "[", "batch_idx", "]", "\n", "for", "key", "in", "criteria", ":", "\n", "        ", "criteria", "[", "key", "]", "[", "orig_idx", "]", "=", "criteria_batch", "[", "key", "]", "[", "batch_idx", "]", "\n", "", "assert", "np", ".", "allclose", "(", "y", "[", "orig_idx", "]", ",", "y_batch", "[", "batch_idx", "]", ")", "\n", "", "", "report", "[", "'bundled'", "]", "=", "ConfidenceReportEntry", "(", "criteria", "[", "'correctness'", "]", ",", "criteria", "[", "'confidence'", "]", ")", "\n", "\n", "should_save", "=", "False", "\n", "new_time", "=", "time", ".", "time", "(", ")", "\n", "if", "hasattr", "(", "report", ",", "'time'", ")", ":", "\n", "    ", "if", "new_time", "-", "report", ".", "time", ">", "REPORT_TIME_INTERVAL", ":", "\n", "      ", "should_save", "=", "True", "\n", "", "", "else", ":", "\n", "    ", "should_save", "=", "True", "\n", "", "if", "should_save", ":", "\n", "    ", "report", ".", "time", "=", "new_time", "\n", "goal", ".", "print_progress", "(", "criteria", ",", "run_counts", ")", "\n", "save", "(", "criteria", ",", "report", ",", "report_path", ",", "adv_x_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.save": [[483, 499], ["cleverhans.confidence_report.print_stats", "print", "cleverhans.serial.save", "report_path.endswith", "numpy.save", "len"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.confidence_report.print_stats", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save"], ["", "", "def", "save", "(", "criteria", ",", "report", ",", "report_path", ",", "adv_x_val", ")", ":", "\n", "  ", "\"\"\"\n  Saves the report and adversarial examples.\n  :param criteria: dict, of the form returned by AttackGoal.get_criteria\n  :param report: dict containing a confidence report\n  :param report_path: string, filepath\n  :param adv_x_val: numpy array containing dataset of adversarial examples\n  \"\"\"", "\n", "print_stats", "(", "criteria", "[", "'correctness'", "]", ",", "criteria", "[", "'confidence'", "]", ",", "'bundled'", ")", "\n", "\n", "print", "(", "\"Saving to \"", "+", "report_path", ")", "\n", "serial", ".", "save", "(", "report_path", ",", "report", ")", "\n", "\n", "assert", "report_path", ".", "endswith", "(", "\".joblib\"", ")", "\n", "adv_x_path", "=", "report_path", "[", ":", "-", "len", "(", "\".joblib\"", ")", "]", "+", "\"_adv.npy\"", "\n", "np", ".", "save", "(", "adv_x_path", ",", "adv_x_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.unfinished_attack_configs": [[903, 950], ["isinstance", "new.min.min", "isinstance", "type", "isinstance", "type", "_logger.info", "_logger.info", "_logger.info", "attack_configs.append", "_logger.info", "str", "str", "str", "str", "done_now.mean", "str", "done_now.min", "str", "done_before.mean", "str", "str", "str"], "function", ["None"], ["", "", "def", "unfinished_attack_configs", "(", "new_work_goal", ",", "work_before", ",", "run_counts", ",", "\n", "log", "=", "False", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of attack configs that have not yet been run the desired\n  number of times.\n  :param new_work_goal: dict mapping attacks to desired number of times to run\n  :param work_before: dict mapping attacks to number of times they were run\n    before starting this new goal. Should be prefiltered to include only\n    examples that don't already meet the primary goal\n  :param run_counts: dict mapping attacks to total number of times they have\n    ever been run. Should be prefiltered to include only examples that don't\n    already meet the primary goal\n  \"\"\"", "\n", "\n", "assert", "isinstance", "(", "work_before", ",", "dict", ")", ",", "work_before", "\n", "\n", "for", "key", "in", "work_before", ":", "\n", "    ", "value", "=", "work_before", "[", "key", "]", "\n", "assert", "value", ".", "ndim", "==", "1", ",", "value", ".", "shape", "\n", "if", "key", "in", "run_counts", ":", "\n", "      ", "assert", "run_counts", "[", "key", "]", ".", "shape", "==", "value", ".", "shape", "\n", "\n", "", "", "attack_configs", "=", "[", "]", "\n", "for", "attack_config", "in", "new_work_goal", ":", "\n", "    ", "done_now", "=", "run_counts", "[", "attack_config", "]", "\n", "if", "log", ":", "\n", "      ", "_logger", ".", "info", "(", "str", "(", "attack_config", ")", "+", "\n", "\" ave run count: \"", "+", "str", "(", "done_now", ".", "mean", "(", ")", ")", ")", "\n", "_logger", ".", "info", "(", "str", "(", "attack_config", ")", "+", "\n", "\" min run count: \"", "+", "str", "(", "done_now", ".", "min", "(", ")", ")", ")", "\n", "", "done_before", "=", "work_before", "[", "attack_config", "]", "\n", "if", "log", ":", "\n", "      ", "_logger", ".", "info", "(", "str", "(", "attack_config", ")", "+", "\" mean work before: \"", "+", "\n", "str", "(", "done_before", ".", "mean", "(", ")", ")", ")", "\n", "# This is the vector for all examples", "\n", "", "new", "=", "done_now", "-", "done_before", "\n", "# The work is only done when it has been done for every example", "\n", "new", "=", "new", ".", "min", "(", ")", "\n", "assert", "isinstance", "(", "new", ",", "(", "int", ",", "np", ".", "int64", ")", ")", ",", "type", "(", "new", ")", "\n", "new_goal", "=", "new_work_goal", "[", "attack_config", "]", "\n", "assert", "isinstance", "(", "new_goal", ",", "int", ")", ",", "type", "(", "new_goal", ")", "\n", "if", "new", "<", "new_goal", ":", "\n", "      ", "if", "log", ":", "\n", "        ", "_logger", ".", "info", "(", "str", "(", "attack_config", ")", "+", "\" has run \"", "+", "\n", "str", "(", "new", ")", "+", "\" of \"", "+", "str", "(", "new_goal", ")", ")", "\n", "", "attack_configs", ".", "append", "(", "attack_config", ")", "\n", "", "", "return", "attack_configs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_examples_with_goal": [[1031, 1095], ["len", "isinstance", "all", "numpy.zeros_like", "all", "all", "_logger.info", "six.moves.range", "cleverhans.confidence_report.ConfidenceReport", "cleverhans.confidence_report.ConfidenceReportEntry", "cleverhans.serial.save", "report_path.endswith", "numpy.save", "numpy.ones", "numpy.ones", "goal.get_criteria", "_logger.info", "six.moves.range", "correctness.min", "correctness.max", "confidence.min", "confidence.max", "goal.new_wins", "str", "c[].mean", "len"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.AttackGoal.get_criteria", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.MaxConfidence.new_wins"], ["", "", "def", "bundle_examples_with_goal", "(", "sess", ",", "model", ",", "adv_x_list", ",", "y", ",", "goal", ",", "\n", "report_path", ")", ":", "\n", "  ", "\"\"\"\n  A post-processor version of attack bundling, that chooses the strongest\n  example from the output of multiple earlier bundling strategies.\n\n  :param sess: tf.session.Session\n  :param model: cleverhans.model.Model\n  :param adv_x_list: list of numpy arrays\n    Each entry in the list is the output of a previous bundler; it is an\n      adversarial version of the whole dataset.\n  :param y: numpy array containing true labels\n  :param goal: AttackGoal to use to choose the best version of each adversarial\n    example\n  :param report_path: str, the path the report will be saved to\n  \"\"\"", "\n", "\n", "# Check the input", "\n", "num_attacks", "=", "len", "(", "adv_x_list", ")", "\n", "assert", "num_attacks", ">", "0", "\n", "adv_x_0", "=", "adv_x_list", "[", "0", "]", "\n", "assert", "isinstance", "(", "adv_x_0", ",", "np", ".", "ndarray", ")", "\n", "assert", "all", "(", "adv_x", ".", "shape", "==", "adv_x_0", ".", "shape", "for", "adv_x", "in", "adv_x_list", ")", "\n", "\n", "# Allocate the output", "\n", "out", "=", "np", ".", "zeros_like", "(", "adv_x_0", ")", "\n", "m", "=", "adv_x_0", ".", "shape", "[", "0", "]", "\n", "# Initialize with negative sentinel values to make sure everything is", "\n", "# written to", "\n", "correctness", "=", "-", "np", ".", "ones", "(", "m", ",", "dtype", "=", "'int32'", ")", "\n", "confidence", "=", "-", "np", ".", "ones", "(", "m", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "# Gather criteria", "\n", "criteria", "=", "[", "goal", ".", "get_criteria", "(", "sess", ",", "model", ",", "adv_x", ",", "y", ")", "for", "adv_x", "in", "adv_x_list", "]", "\n", "assert", "all", "(", "'correctness'", "in", "c", "for", "c", "in", "criteria", ")", "\n", "assert", "all", "(", "'confidence'", "in", "c", "for", "c", "in", "criteria", ")", "\n", "_logger", ".", "info", "(", "\"Accuracy on each advx dataset: \"", ")", "\n", "for", "c", "in", "criteria", ":", "\n", "    ", "_logger", ".", "info", "(", "\"\\t\"", "+", "str", "(", "c", "[", "'correctness'", "]", ".", "mean", "(", ")", ")", ")", "\n", "\n", "", "for", "example_idx", "in", "range", "(", "m", ")", ":", "\n", "# Index of the best attack for this example", "\n", "    ", "attack_idx", "=", "0", "\n", "# Find the winner", "\n", "for", "candidate_idx", "in", "range", "(", "1", ",", "num_attacks", ")", ":", "\n", "      ", "if", "goal", ".", "new_wins", "(", "criteria", "[", "attack_idx", "]", ",", "example_idx", ",", "\n", "criteria", "[", "candidate_idx", "]", ",", "example_idx", ")", ":", "\n", "        ", "attack_idx", "=", "candidate_idx", "\n", "# Copy the winner into the output", "\n", "", "", "out", "[", "example_idx", "]", "=", "adv_x_list", "[", "attack_idx", "]", "[", "example_idx", "]", "\n", "correctness", "[", "example_idx", "]", "=", "criteria", "[", "attack_idx", "]", "[", "'correctness'", "]", "[", "example_idx", "]", "\n", "confidence", "[", "example_idx", "]", "=", "criteria", "[", "attack_idx", "]", "[", "'confidence'", "]", "[", "example_idx", "]", "\n", "\n", "", "assert", "correctness", ".", "min", "(", ")", ">=", "0", "\n", "assert", "correctness", ".", "max", "(", ")", "<=", "1", "\n", "assert", "confidence", ".", "min", "(", ")", ">=", "0.", "\n", "assert", "confidence", ".", "max", "(", ")", "<=", "1.", "\n", "\n", "report", "=", "ConfidenceReport", "(", ")", "\n", "report", "[", "'bundled'", "]", "=", "ConfidenceReportEntry", "(", "correctness", ",", "confidence", ")", "\n", "serial", ".", "save", "(", "report_path", ",", "report", ")", "\n", "assert", "report_path", ".", "endswith", "(", "'.joblib'", ")", "\n", "adv_x_path", "=", "report_path", "[", ":", "-", "len", "(", "'.joblib'", ")", "]", "+", "\"_adv_x.npy\"", "\n", "np", ".", "save", "(", "adv_x_path", ",", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.spsa_max_confidence_recipe": [[1096, 1139], ["cleverhans.attacks.SPSA", "tensorflow.ones", "six.moves.range", "attack_bundling.bundle_attacks", "copy.copy", "tensorflow.to_float", "attack_bundling.AttackConfig", "attack_configs.append", "attack_bundling.MaxConfidence", "tensorflow.one_hot", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attack_bundling.bundle_attacks"], ["", "def", "spsa_max_confidence_recipe", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "nb_classes", ",", "eps", ",", "\n", "clip_min", ",", "clip_max", ",", "nb_iter", ",", "\n", "report_path", ",", "\n", "spsa_samples", "=", "SPSA", ".", "DEFAULT_SPSA_SAMPLES", ",", "\n", "spsa_iters", "=", "SPSA", ".", "DEFAULT_SPSA_ITERS", ")", ":", "\n", "  ", "\"\"\"Runs the MaxConfidence attack using SPSA as the underlying optimizer.\n\n  Even though this runs only one attack, it must be implemented as a bundler\n  because SPSA supports only batch_size=1. The cleverhans.attacks.MaxConfidence\n  attack internally multiplies the batch size by nb_classes, so it can't take\n  SPSA as a base attacker. Insteader, we must bundle batch_size=1 calls using\n  cleverhans.attack_bundling.MaxConfidence.\n\n  References:\n  https://openreview.net/forum?id=H1g0piA9tQ\n\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing clean example inputs to attack\n  :param y: numpy array containing true labels\n  :param nb_classes: int, number of classes\n  :param eps: float, maximum size of perturbation (measured by max norm)\n  :param nb_iter: int, number of iterations for one version of PGD attacks\n    (will also run another version with 25X more iterations)\n  :param report_path: str, the path that the report will be saved to.\n  \"\"\"", "\n", "spsa", "=", "SPSA", "(", "model", ",", "sess", ")", "\n", "spsa_params", "=", "{", "\"eps\"", ":", "eps", ",", "\"clip_min\"", ":", "clip_min", ",", "\"clip_max\"", ":", "clip_max", ",", "\n", "\"nb_iter\"", ":", "nb_iter", ",", "\"spsa_samples\"", ":", "spsa_samples", ",", "\n", "\"spsa_iters\"", ":", "spsa_iters", "}", "\n", "attack_configs", "=", "[", "]", "\n", "dev_batch_size", "=", "1", "# The only batch size supported by SPSA", "\n", "batch_size", "=", "num_devices", "\n", "ones", "=", "tf", ".", "ones", "(", "dev_batch_size", ",", "tf", ".", "int32", ")", "\n", "for", "cls", "in", "range", "(", "nb_classes", ")", ":", "\n", "    ", "cls_params", "=", "copy", ".", "copy", "(", "spsa_params", ")", "\n", "cls_params", "[", "'y_target'", "]", "=", "tf", ".", "to_float", "(", "tf", ".", "one_hot", "(", "ones", "*", "cls", ",", "nb_classes", ")", ")", "\n", "cls_attack_config", "=", "AttackConfig", "(", "spsa", ",", "cls_params", ",", "\"spsa_\"", "+", "str", "(", "cls", ")", ")", "\n", "attack_configs", ".", "append", "(", "cls_attack_config", ")", "\n", "", "new_work_goal", "=", "{", "config", ":", "1", "for", "config", "in", "attack_configs", "}", "\n", "goals", "=", "[", "MaxConfidence", "(", "t", "=", "1.", ",", "new_work_goal", "=", "new_work_goal", ")", "]", "\n", "bundle_attacks", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack_configs", ",", "goals", ",", "report_path", ",", "\n", "attack_batch_size", "=", "batch_size", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.maybe_download_mnist_file": [[17, 21], ["warnings.warn", "os.path.join", "cleverhans.dataset.maybe_download_file"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.maybe_download_file"], ["def", "maybe_download_mnist_file", "(", "file_name", ",", "datadir", "=", "None", ",", "force", "=", "False", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "utils_mnist_warning", ")", "\n", "url", "=", "os", ".", "path", ".", "join", "(", "'http://yann.lecun.com/exdb/mnist/'", ",", "file_name", ")", "\n", "return", "dataset", ".", "maybe_download_file", "(", "url", ",", "datadir", "=", "None", ",", "force", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file": [[23, 27], ["warnings.warn", "cleverhans.dataset.download_and_parse_mnist_file"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.download_and_parse_mnist_file"], ["", "def", "download_and_parse_mnist_file", "(", "file_name", ",", "datadir", "=", "None", ",", "force", "=", "False", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "utils_mnist_warning", ")", "\n", "return", "dataset", ".", "download_and_parse_mnist_file", "(", "file_name", ",", "datadir", "=", "None", ",", "\n", "force", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_mnist.data_mnist": [[29, 38], ["tempfile.gettempdir", "warnings.warn", "cleverhans.dataset.MNIST", "dataset.MNIST.get_set", "dataset.MNIST.get_set"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_set", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.dataset.Dataset.get_set"], ["", "def", "data_mnist", "(", "datadir", "=", "tempfile", ".", "gettempdir", "(", ")", ",", "train_start", "=", "0", ",", "\n", "train_end", "=", "60000", ",", "test_start", "=", "0", ",", "test_end", "=", "10000", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "utils_mnist_warning", ")", "\n", "mnist", "=", "dataset", ".", "MNIST", "(", "train_start", "=", "train_start", ",", "\n", "train_end", "=", "train_end", ",", "\n", "test_start", "=", "test_start", ",", "\n", "test_end", "=", "test_end", ",", "\n", "center", "=", "False", ")", "\n", "return", "mnist", ".", "get_set", "(", "'train'", ")", "+", "mnist", ".", "get_set", "(", "'test'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.PicklableVariable.__init__": [[41, 43], ["tensorflow.Variable"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "var", "=", "tf", ".", "Variable", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.PicklableVariable.__getstate__": [[44, 50], ["tensorflow.get_default_session", "RuntimeError", "tensorflow.get_default_session.run"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "    ", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "if", "sess", "is", "None", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"PicklableVariable requires a default \"", "\n", "\"TensorFlow session\"", ")", "\n", "", "return", "{", "'var'", ":", "sess", ".", "run", "(", "self", ".", "var", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.PicklableVariable.__setstate__": [[51, 58], ["tensorflow.Variable", "tensorflow.get_default_session", "tensorflow.get_default_session.run", "RuntimeError"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "d", ")", ":", "\n", "    ", "self", ".", "var", "=", "tf", ".", "Variable", "(", "d", "[", "'var'", "]", ")", "\n", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "if", "sess", "is", "None", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"PicklableVariable requires a default \"", "\n", "\"TensorFlow session\"", ")", "\n", "", "sess", ".", "run", "(", "self", ".", "var", ".", "initializer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.NoRefModel.__getstate__": [[76, 95], ["serial.NoRefModel.__dict__.copy", "tensorflow.get_default_session", "serial.NoRefModel.get_vars", "tensorflow.get_default_session.run", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars"], ["def", "__getstate__", "(", "self", ")", ":", "\n", "# Serialize everything except the Variables", "\n", "    ", "out", "=", "self", ".", "__dict__", ".", "copy", "(", ")", "\n", "\n", "# The base Model class adds this tf reference to self", "\n", "# We mustn't pickle anything tf, this will need to be", "\n", "# regenerated after the model is reloaded.", "\n", "if", "\"_dummy_input\"", "in", "out", ":", "\n", "      ", "del", "out", "[", "\"_dummy_input\"", "]", "\n", "\n", "# Add the Variables", "\n", "", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "if", "sess", "is", "None", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"NoRefModel requires a default \"", "\n", "\"TensorFlow session\"", ")", "\n", "", "tf_variables", "=", "self", ".", "get_vars", "(", ")", "\n", "out", "[", "VARS", "]", "=", "sess", ".", "run", "(", "tf_variables", ")", "\n", "out", "[", "VAR_NAMES", "]", "=", "[", "var", ".", "name", "for", "var", "in", "tf_variables", "]", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.NoRefModel.__setstate__": [[96, 150], ["tensorflow.get_default_session", "serial.NoRefModel.get_vars", "warnings.warn", "RuntimeError", "len", "len", "print", "print", "print", "print", "len", "cleverhans.utils.safe_zip", "all", "cleverhans.utils.safe_zip", "print", "print", "print", "enumerate", "var.load", "print", "str", "str", "cur_var.load", "len", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["", "def", "__setstate__", "(", "self", ",", "d", ")", ":", "\n", "    ", "tf_variables", "=", "d", "[", "VARS", "]", "\n", "del", "d", "[", "VARS", "]", "\n", "tf_variable_names", "=", "None", "\n", "# older joblib files may not have \"_tf_variable_names\"", "\n", "if", "VAR_NAMES", "in", "d", ":", "\n", "      ", "tf_variable_names", "=", "d", "[", "VAR_NAMES", "]", "\n", "del", "d", "[", "VAR_NAMES", "]", "\n", "", "else", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"This joblib file has no \"", "+", "VAR_NAMES", "+", "\" field. \"", "\n", "\"The field may become required on or after 2019-04-11.\"", "\n", "\"You can make your file compatible with the new format by\"", "\n", "\" loading the file and re-saving it.\"", ")", "\n", "# Deserialize everything except the Variables", "\n", "", "self", ".", "__dict__", "=", "d", "\n", "# Deserialize the Variables", "\n", "sess", "=", "tf", ".", "get_default_session", "(", ")", "\n", "if", "sess", "is", "None", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"NoRefModel requires a default \"", "\n", "\"TensorFlow session\"", ")", "\n", "", "cur_vars", "=", "self", ".", "get_vars", "(", ")", "\n", "if", "len", "(", "cur_vars", ")", "!=", "len", "(", "tf_variables", ")", ":", "\n", "      ", "print", "(", "\"Model format mismatch\"", ")", "\n", "print", "(", "\"Current model has \"", "+", "str", "(", "len", "(", "cur_vars", ")", ")", "+", "\" variables\"", ")", "\n", "print", "(", "\"Saved model has \"", "+", "str", "(", "len", "(", "tf_variables", ")", ")", "+", "\" variables\"", ")", "\n", "print", "(", "\"Names of current vars:\"", ")", "\n", "for", "var", "in", "cur_vars", ":", "\n", "        ", "print", "(", "\"\\t\"", "+", "var", ".", "name", ")", "\n", "", "if", "tf_variable_names", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"Names of saved vars:\"", ")", "\n", "for", "name", "in", "tf_variable_names", ":", "\n", "          ", "print", "(", "\"\\t\"", "+", "name", ")", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "\"Saved vars use old format, no names available for them\"", ")", "\n", "", "assert", "False", "\n", "\n", "", "found", "=", "[", "False", "]", "*", "len", "(", "cur_vars", ")", "\n", "if", "tf_variable_names", "is", "not", "None", ":", "\n", "# New version using the names to handle changes in ordering", "\n", "      ", "for", "value", ",", "name", "in", "safe_zip", "(", "tf_variables", ",", "tf_variable_names", ")", ":", "\n", "        ", "value_found", "=", "False", "\n", "for", "idx", ",", "cur_var", "in", "enumerate", "(", "cur_vars", ")", ":", "\n", "          ", "if", "cur_var", ".", "name", "==", "name", ":", "\n", "            ", "assert", "not", "found", "[", "idx", "]", "\n", "value_found", "=", "True", "\n", "found", "[", "idx", "]", "=", "True", "\n", "cur_var", ".", "load", "(", "value", ",", "sess", ")", "\n", "break", "\n", "", "", "assert", "value_found", "\n", "", "assert", "all", "(", "found", ")", "\n", "", "else", ":", "\n", "# Old version that works if and only if the order doesn't change", "\n", "      ", "for", "var", ",", "value", "in", "safe_zip", "(", "cur_vars", ",", "tf_variables", ")", ":", "\n", "        ", "var", ".", "load", "(", "value", ",", "sess", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.NoRefModel.get_vars": [[151, 195], ["hasattr", "tensorflow.executing_eagerly", "tensorflow.get_collection", "tensorflow.get_collection", "cleverhans.utils.ordered_union", "len", "NotImplementedError", "len", "serial.NoRefModel.make_params", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.ordered_union", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.make_params"], ["", "", "", "def", "get_vars", "(", "self", ")", ":", "\n", "    ", "\"\"\"\n    Provides access to the model's Variables.\n    This may include Variables that are not parameters, such as batch\n    norm running moments.\n    :return: A list of all Variables defining the model.\n    \"\"\"", "\n", "\n", "# Catch eager execution and assert function overload.", "\n", "try", ":", "\n", "      ", "if", "tf", ".", "executing_eagerly", "(", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"For Eager execution - get_vars \"", "\n", "\"must be overridden.\"", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "      ", "pass", "\n", "\n", "", "done", "=", "False", "\n", "tried_to_make_params", "=", "False", "\n", "while", "not", "done", ":", "\n", "# Most models in cleverhans use only trainable variables and do not", "\n", "# make sure the other collections are updated correctly.", "\n", "      ", "trainable_vars", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "TRAINABLE_VARIABLES", ",", "\n", "self", ".", "scope", "+", "\"/\"", ")", "\n", "# When wrapping other code, such as the CIFAR 10 challenge models,", "\n", "# we need to make sure we get the batch norm running averages as well", "\n", "# as the trainable variables.", "\n", "model_vars", "=", "tf", ".", "get_collection", "(", "tf", ".", "GraphKeys", ".", "MODEL_VARIABLES", ",", "\n", "self", ".", "scope", "+", "\"/\"", ")", "\n", "scope_vars", "=", "ordered_union", "(", "trainable_vars", ",", "model_vars", ")", "\n", "\n", "if", "len", "(", "scope_vars", ")", ">", "0", ":", "\n", "        ", "done", "=", "True", "\n", "", "else", ":", "\n", "        ", "assert", "not", "tried_to_make_params", "\n", "tried_to_make_params", "=", "True", "\n", "self", ".", "make_params", "(", ")", "\n", "\n", "# Make sure no variables have been added or removed", "\n", "", "", "if", "hasattr", "(", "self", ",", "\"num_vars\"", ")", ":", "\n", "      ", "assert", "self", ".", "num_vars", "==", "len", "(", "scope_vars", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "num_vars", "=", "len", "(", "scope_vars", ")", "\n", "\n", "", "return", "scope_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save": [[197, 208], ["joblib.dump"], "function", ["None"], ["", "", "def", "save", "(", "filepath", ",", "obj", ")", ":", "\n", "  ", "\"\"\"Saves an object to the specified filepath using joblib.\n\n  joblib is like pickle but will save NumPy arrays as separate files for\n  greater efficiency.\n\n  :param filepath: str, path to save to\n  :obj filepath: object to save\n  \"\"\"", "\n", "\n", "joblib", ".", "dump", "(", "obj", ",", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load": [[210, 217], ["joblib.load"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["", "def", "load", "(", "filepath", ")", ":", "\n", "  ", "\"\"\"Returns an object stored via `save`\n  \"\"\"", "\n", "\n", "obj", "=", "joblib", ".", "load", "(", "filepath", ")", "\n", "\n", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.initializers.HeReLuNormalInitializer.__init__": [[9, 11], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "dtype", "=", "tf", ".", "float32", ")", ":", "\n", "    ", "super", "(", "HeReLuNormalInitializer", ",", "self", ")", ".", "__init__", "(", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.initializers.HeReLuNormalInitializer.get_config": [[12, 14], ["dict"], "methods", ["None"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "    ", "return", "dict", "(", "dtype", "=", "self", ".", "dtype", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.initializers.HeReLuNormalInitializer.__call__": [[15, 20], ["tensorflow.rsqrt", "tensorflow.random_normal", "tensorflow.cast", "tensorflow.reduce_prod"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_prod"], ["", "def", "__call__", "(", "self", ",", "shape", ",", "dtype", "=", "None", ",", "partition_info", "=", "None", ")", ":", "\n", "    ", "del", "partition_info", "\n", "dtype", "=", "self", ".", "dtype", "if", "dtype", "is", "None", "else", "dtype", "\n", "std", "=", "tf", ".", "rsqrt", "(", "tf", ".", "cast", "(", "tf", ".", "reduce_prod", "(", "shape", "[", ":", "-", "1", "]", ")", ",", "tf", ".", "float32", ")", "+", "1e-7", ")", "\n", "return", "tf", ".", "random_normal", "(", "shape", ",", "stddev", "=", "std", ",", "dtype", "=", "dtype", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.canary.run_canary": [[10, 70], ["time.time", "tensorflow.Graph", "tf.Graph.as_default", "cleverhans.utils_tf.infer_devices", "len", "numpy.random.RandomState().randn", "tensorflow.Variable", "tensorflow.reduce_sum", "tensorflow.Session", "tf.Session.run", "tf.Session.run", "tf.Session.close", "tensorflow.square", "tensorflow.variables_initializer", "numpy.random.RandomState", "tensorflow.device", "tensorflow.gradients", "sess.run.append", "numpy.allclose", "str", "str", "RuntimeError"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.infer_devices", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["def", "run_canary", "(", ")", ":", "\n", "  ", "\"\"\"\n  Runs some code that will crash if the GPUs / GPU driver are suffering from\n  a common bug. This helps to prevent contaminating results in the rest of\n  the library with incorrect calculations.\n  \"\"\"", "\n", "\n", "# Note: please do not edit this function unless you have access to a machine", "\n", "# with GPUs suffering from the bug and can verify that the canary still", "\n", "# crashes after your edits. Due to the transient nature of the GPU bug it is", "\n", "# not possible to unit test the canary in our continuous integration system.", "\n", "\n", "global", "last_run", "\n", "current", "=", "time", ".", "time", "(", ")", "\n", "if", "last_run", "is", "None", "or", "current", "-", "last_run", ">", "3600", ":", "\n", "    ", "last_run", "=", "current", "\n", "", "else", ":", "\n", "# Run the canary at most once per hour", "\n", "    ", "return", "\n", "\n", "# Try very hard not to let the canary affect the graph for the rest of the", "\n", "# python process", "\n", "", "canary_graph", "=", "tf", ".", "Graph", "(", ")", "\n", "with", "canary_graph", ".", "as_default", "(", ")", ":", "\n", "    ", "devices", "=", "infer_devices", "(", ")", "\n", "num_devices", "=", "len", "(", "devices", ")", "\n", "if", "num_devices", "<", "3", ":", "\n", "# We have never observed GPU failure when less than 3 GPUs were used", "\n", "      ", "return", "\n", "\n", "", "v", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "10", ",", "16", "]", ")", ".", "randn", "(", "2", ",", "2", ")", "\n", "# Try very hard not to let this Variable end up in any collections used", "\n", "# by the rest of the python process", "\n", "w", "=", "tf", ".", "Variable", "(", "v", ",", "trainable", "=", "False", ",", "collections", "=", "[", "]", ")", "\n", "loss", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "square", "(", "w", ")", ")", "\n", "\n", "grads", "=", "[", "]", "\n", "for", "device", "in", "devices", ":", "\n", "      ", "with", "tf", ".", "device", "(", "device", ")", ":", "\n", "        ", "grad", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "w", ")", "\n", "grads", ".", "append", "(", "grad", ")", "\n", "\n", "", "", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "[", "w", "]", ")", ")", "\n", "grads", "=", "sess", ".", "run", "(", "grads", ")", "\n", "first", "=", "grads", "[", "0", "]", "\n", "for", "grad", "in", "grads", "[", "1", ":", "]", ":", "\n", "      ", "if", "not", "np", ".", "allclose", "(", "first", ",", "grad", ")", ":", "\n", "        ", "first_string", "=", "str", "(", "first", ")", "\n", "grad_string", "=", "str", "(", "grad", ")", "\n", "raise", "RuntimeError", "(", "\"Something is wrong with your GPUs or GPU driver.\"", "\n", "\"%(num_devices)d different GPUS were asked to \"", "\n", "\"calculate the same 2x2 gradient. One returned \"", "\n", "\"%(first_string)s and another returned \"", "\n", "\"%(grad_string)s. This can usually be fixed by \"", "\n", "\"rebooting the machine.\"", "%", "\n", "{", "\"num_devices\"", ":", "num_devices", ",", "\n", "\"first_string\"", ":", "first_string", ",", "\n", "\"grad_string\"", ":", "grad_string", "}", ")", "\n", "", "", "sess", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.CarliniWagnerL2.__init__": [[543, 667], ["tuple", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "model.get_logits", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_max", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "set", "tensorflow.train.AdamOptimizer", "tensorflow.train.AdamOptimizer.minimize", "tensorflow.global_variables", "attacks_tf.CarliniWagnerL2.setup.append", "attacks_tf.CarliniWagnerL2.setup.append", "attacks_tf.CarliniWagnerL2.setup.append", "tensorflow.variables_initializer", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "tensorflow.square", "list", "tensorflow.maximum", "tensorflow.maximum", "attacks_tf.CarliniWagnerL2.timg.assign", "attacks_tf.CarliniWagnerL2.tlab.assign", "attacks_tf.CarliniWagnerL2.const.assign", "list", "tensorflow.tanh", "range", "attacks_tf.ZERO", "attacks_tf.ZERO", "len", "tensorflow.global_variables", "tensorflow.tanh"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO"], ["  ", "def", "__init__", "(", "self", ",", "sess", ",", "model", ",", "batch_size", ",", "confidence", ",", "targeted", ",", "\n", "learning_rate", ",", "binary_search_steps", ",", "max_iterations", ",", "\n", "abort_early", ",", "initial_const", ",", "clip_min", ",", "clip_max", ",", "num_labels", ",", "\n", "shape", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param sess: a TF session.\n    :param model: a cleverhans.model.Model object.\n    :param batch_size: Number of attacks to run simultaneously.\n    :param confidence: Confidence of adversarial examples: higher produces\n                       examples with larger l2 distortion, but more\n                       strongly classified as adversarial.\n    :param targeted: boolean controlling the behavior of the adversarial\n                     examples produced. If set to False, they will be\n                     misclassified in any wrong class. If set to True,\n                     they will be misclassified in a chosen target class.\n    :param learning_rate: The learning rate for the attack algorithm.\n                          Smaller values produce better results but are\n                          slower to converge.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the purturbation\n                                and confidence of the classification.\n    :param max_iterations: The maximum number of iterations. Setting this\n                           to a larger value will produce lower distortion\n                           results. Using only a few iterations requires\n                           a larger learning rate, and will produce larger\n                           distortion results.\n    :param abort_early: If true, allows early aborts if gradient descent\n                        is unable to make progress (i.e., gets stuck in\n                        a local minimum).\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the pururbation\n                          and confidence of classification.\n                          If binary_search_steps is large, the initial\n                          constant is not important. A smaller value of\n                          this constant gives lower distortion results.\n    :param clip_min: (optional float) Minimum input component value.\n    :param clip_max: (optional float) Maximum input component value.\n    :param num_labels: the number of classes in the model's output.\n    :param shape: the shape of the model's input tensor.\n    \"\"\"", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "TARGETED", "=", "targeted", "\n", "self", ".", "LEARNING_RATE", "=", "learning_rate", "\n", "self", ".", "MAX_ITERATIONS", "=", "max_iterations", "\n", "self", ".", "BINARY_SEARCH_STEPS", "=", "binary_search_steps", "\n", "self", ".", "ABORT_EARLY", "=", "abort_early", "\n", "self", ".", "CONFIDENCE", "=", "confidence", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "model", "=", "model", "\n", "\n", "self", ".", "repeat", "=", "binary_search_steps", ">=", "10", "\n", "\n", "self", ".", "shape", "=", "shape", "=", "tuple", "(", "[", "batch_size", "]", "+", "list", "(", "shape", ")", ")", "\n", "\n", "# the variable we're going to optimize over", "\n", "modifier", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "shape", ",", "dtype", "=", "np_dtype", ")", ")", "\n", "\n", "# these are variables to be more efficient in sending data to tf", "\n", "self", ".", "timg", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'timg'", ")", "\n", "self", ".", "tlab", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "(", "batch_size", ",", "num_labels", ")", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'tlab'", ")", "\n", "self", ".", "const", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "batch_size", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'const'", ")", "\n", "\n", "# and here's what we use to assign them", "\n", "self", ".", "assign_timg", "=", "tf", ".", "placeholder", "(", "tf_dtype", ",", "shape", ",", "name", "=", "'assign_timg'", ")", "\n", "self", ".", "assign_tlab", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "(", "batch_size", ",", "num_labels", ")", ",", "name", "=", "'assign_tlab'", ")", "\n", "self", ".", "assign_const", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "[", "batch_size", "]", ",", "name", "=", "'assign_const'", ")", "\n", "\n", "# the resulting instance, tanh'd to keep bounded from clip_min", "\n", "# to clip_max", "\n", "self", ".", "newimg", "=", "(", "tf", ".", "tanh", "(", "modifier", "+", "self", ".", "timg", ")", "+", "1", ")", "/", "2", "\n", "self", ".", "newimg", "=", "self", ".", "newimg", "*", "(", "clip_max", "-", "clip_min", ")", "+", "clip_min", "\n", "\n", "# prediction BEFORE-SOFTMAX of the model", "\n", "self", ".", "output", "=", "model", ".", "get_logits", "(", "self", ".", "newimg", ")", "\n", "\n", "# distance to the input data", "\n", "self", ".", "other", "=", "(", "tf", ".", "tanh", "(", "self", ".", "timg", ")", "+", "1", ")", "/", "2", "*", "(", "clip_max", "-", "clip_min", ")", "+", "clip_min", "\n", "self", ".", "l2dist", "=", "reduce_sum", "(", "\n", "tf", ".", "square", "(", "self", ".", "newimg", "-", "self", ".", "other", ")", ",", "list", "(", "range", "(", "1", ",", "len", "(", "shape", ")", ")", ")", ")", "\n", "\n", "# compute the probability of the label class versus the maximum other", "\n", "real", "=", "reduce_sum", "(", "(", "self", ".", "tlab", ")", "*", "self", ".", "output", ",", "1", ")", "\n", "other", "=", "reduce_max", "(", "(", "1", "-", "self", ".", "tlab", ")", "*", "self", ".", "output", "-", "self", ".", "tlab", "*", "10000", ",", "\n", "1", ")", "\n", "\n", "if", "self", ".", "TARGETED", ":", "\n", "# if targeted, optimize for making the other class most likely", "\n", "      ", "loss1", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "other", "-", "real", "+", "self", ".", "CONFIDENCE", ")", "\n", "", "else", ":", "\n", "# if untargeted, optimize for making this class least likely.", "\n", "      ", "loss1", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "real", "-", "other", "+", "self", ".", "CONFIDENCE", ")", "\n", "\n", "# sum up the losses", "\n", "", "self", ".", "loss2", "=", "reduce_sum", "(", "self", ".", "l2dist", ")", "\n", "self", ".", "loss1", "=", "reduce_sum", "(", "self", ".", "const", "*", "loss1", ")", "\n", "self", ".", "loss", "=", "self", ".", "loss1", "+", "self", ".", "loss2", "\n", "\n", "# Setup the adam optimizer and keep track of variables we're creating", "\n", "start_vars", "=", "set", "(", "x", ".", "name", "for", "x", "in", "tf", ".", "global_variables", "(", ")", ")", "\n", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "self", ".", "LEARNING_RATE", ")", "\n", "self", ".", "train", "=", "optimizer", ".", "minimize", "(", "self", ".", "loss", ",", "var_list", "=", "[", "modifier", "]", ")", "\n", "end_vars", "=", "tf", ".", "global_variables", "(", ")", "\n", "new_vars", "=", "[", "x", "for", "x", "in", "end_vars", "if", "x", ".", "name", "not", "in", "start_vars", "]", "\n", "\n", "# these are the variables to initialize when we run", "\n", "self", ".", "setup", "=", "[", "]", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "timg", ".", "assign", "(", "self", ".", "assign_timg", ")", ")", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "tlab", ".", "assign", "(", "self", ".", "assign_tlab", ")", ")", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "const", ".", "assign", "(", "self", ".", "assign_const", ")", ")", "\n", "\n", "self", ".", "init", "=", "tf", ".", "variables_initializer", "(", "var_list", "=", "[", "modifier", "]", "+", "new_vars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.CarliniWagnerL2.attack": [[668, 684], ["range", "numpy.array", "len", "_logger.debug", "r.extend", "attacks_tf.CarliniWagnerL2.attack_batch", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.attack_batch"], ["", "def", "attack", "(", "self", ",", "imgs", ",", "targets", ")", ":", "\n", "    ", "\"\"\"\n    Perform the L_2 attack on the given instance for the given targets.\n\n    If self.targeted is true, then the targets represents the target labels\n    If self.targeted is false, then targets are the original class labels\n    \"\"\"", "\n", "\n", "r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "imgs", ")", ",", "self", ".", "batch_size", ")", ":", "\n", "      ", "_logger", ".", "debug", "(", "\n", "(", "\"Running CWL2 attack on instance %s of %s\"", ",", "i", ",", "len", "(", "imgs", ")", ")", ")", "\n", "r", ".", "extend", "(", "\n", "self", ".", "attack_batch", "(", "imgs", "[", "i", ":", "i", "+", "self", ".", "batch_size", "]", ",", "\n", "targets", "[", "i", ":", "i", "+", "self", ".", "batch_size", "]", ")", ")", "\n", "", "return", "np", ".", "array", "(", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.CarliniWagnerL2.attack_batch": [[685, 808], ["numpy.clip", "numpy.clip", "numpy.arctanh", "numpy.zeros", "numpy.copy", "range", "numpy.array", "numpy.ones", "numpy.ones", "attacks_tf.CarliniWagnerL2.sess.run", "_logger.debug", "attacks_tf.CarliniWagnerL2.sess.run", "range", "range", "_logger.debug", "numpy.array", "numpy.mean", "_logger.debug", "isinstance", "numpy.copy", "numpy.argmax", "attacks_tf.CarliniWagnerL2.sess.run", "enumerate", "numpy.sqrt", "_logger.debug", "zip", "numpy.argmax", "attacks_tf.CarliniWagnerL2.attack_batch.compare"], "methods", ["None"], ["", "def", "attack_batch", "(", "self", ",", "imgs", ",", "labs", ")", ":", "\n", "    ", "\"\"\"\n    Run the attack on a batch of instance and labels.\n    \"\"\"", "\n", "\n", "def", "compare", "(", "x", ",", "y", ")", ":", "\n", "      ", "if", "not", "isinstance", "(", "x", ",", "(", "float", ",", "int", ",", "np", ".", "int64", ")", ")", ":", "\n", "        ", "x", "=", "np", ".", "copy", "(", "x", ")", "\n", "if", "self", ".", "TARGETED", ":", "\n", "          ", "x", "[", "y", "]", "-=", "self", ".", "CONFIDENCE", "\n", "", "else", ":", "\n", "          ", "x", "[", "y", "]", "+=", "self", ".", "CONFIDENCE", "\n", "", "x", "=", "np", ".", "argmax", "(", "x", ")", "\n", "", "if", "self", ".", "TARGETED", ":", "\n", "        ", "return", "x", "==", "y", "\n", "", "else", ":", "\n", "        ", "return", "x", "!=", "y", "\n", "\n", "", "", "batch_size", "=", "self", ".", "batch_size", "\n", "\n", "oimgs", "=", "np", ".", "clip", "(", "imgs", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "# re-scale instances to be within range [0, 1]", "\n", "imgs", "=", "(", "imgs", "-", "self", ".", "clip_min", ")", "/", "(", "self", ".", "clip_max", "-", "self", ".", "clip_min", ")", "\n", "imgs", "=", "np", ".", "clip", "(", "imgs", ",", "0", ",", "1", ")", "\n", "# now convert to [-1, 1]", "\n", "imgs", "=", "(", "imgs", "*", "2", ")", "-", "1", "\n", "# convert to tanh-space", "\n", "imgs", "=", "np", ".", "arctanh", "(", "imgs", "*", ".999999", ")", "\n", "\n", "# set the lower and upper bounds accordingly", "\n", "lower_bound", "=", "np", ".", "zeros", "(", "batch_size", ")", "\n", "CONST", "=", "np", ".", "ones", "(", "batch_size", ")", "*", "self", ".", "initial_const", "\n", "upper_bound", "=", "np", ".", "ones", "(", "batch_size", ")", "*", "1e10", "\n", "\n", "# placeholders for the best l2, score, and instance attack found so far", "\n", "o_bestl2", "=", "[", "1e10", "]", "*", "batch_size", "\n", "o_bestscore", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "o_bestattack", "=", "np", ".", "copy", "(", "oimgs", ")", "\n", "\n", "for", "outer_step", "in", "range", "(", "self", ".", "BINARY_SEARCH_STEPS", ")", ":", "\n", "# completely reset adam's internal state.", "\n", "      ", "self", ".", "sess", ".", "run", "(", "self", ".", "init", ")", "\n", "batch", "=", "imgs", "[", ":", "batch_size", "]", "\n", "batchlab", "=", "labs", "[", ":", "batch_size", "]", "\n", "\n", "bestl2", "=", "[", "1e10", "]", "*", "batch_size", "\n", "bestscore", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "_logger", ".", "debug", "(", "\"  Binary search step %s of %s\"", ",", "\n", "outer_step", ",", "self", ".", "BINARY_SEARCH_STEPS", ")", "\n", "\n", "# The last iteration (if we run many steps) repeat the search once.", "\n", "if", "self", ".", "repeat", "and", "outer_step", "==", "self", ".", "BINARY_SEARCH_STEPS", "-", "1", ":", "\n", "        ", "CONST", "=", "upper_bound", "\n", "\n", "# set the variables so that we don't have to send them over again", "\n", "", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "setup", ",", "{", "\n", "self", ".", "assign_timg", ":", "batch", ",", "\n", "self", ".", "assign_tlab", ":", "batchlab", ",", "\n", "self", ".", "assign_const", ":", "CONST", "\n", "}", ")", "\n", "\n", "prev", "=", "1e6", "\n", "for", "iteration", "in", "range", "(", "self", ".", "MAX_ITERATIONS", ")", ":", "\n", "# perform the attack", "\n", "        ", "_", ",", "l", ",", "l2s", ",", "scores", ",", "nimg", "=", "self", ".", "sess", ".", "run", "(", "[", "\n", "self", ".", "train", ",", "self", ".", "loss", ",", "self", ".", "l2dist", ",", "self", ".", "output", ",", "\n", "self", ".", "newimg", "\n", "]", ")", "\n", "\n", "if", "iteration", "%", "(", "(", "self", ".", "MAX_ITERATIONS", "//", "10", ")", "or", "1", ")", "==", "0", ":", "\n", "          ", "_logger", ".", "debug", "(", "(", "\"    Iteration {} of {}: loss={:.3g} \"", "+", "\n", "\"l2={:.3g} f={:.3g}\"", ")", ".", "format", "(", "\n", "iteration", ",", "self", ".", "MAX_ITERATIONS", ",", "l", ",", "\n", "np", ".", "mean", "(", "l2s", ")", ",", "np", ".", "mean", "(", "scores", ")", ")", ")", "\n", "\n", "# check if we should abort search if we're getting nowhere.", "\n", "", "if", "self", ".", "ABORT_EARLY", "and", "iteration", "%", "(", "(", "self", ".", "MAX_ITERATIONS", "//", "10", ")", "or", "1", ")", "==", "0", ":", "\n", "          ", "if", "l", ">", "prev", "*", ".9999", ":", "\n", "            ", "msg", "=", "\"    Failed to make progress; stop early\"", "\n", "_logger", ".", "debug", "(", "msg", ")", "\n", "break", "\n", "", "prev", "=", "l", "\n", "\n", "# adjust the best result found so far", "\n", "", "for", "e", ",", "(", "l2", ",", "sc", ",", "ii", ")", "in", "enumerate", "(", "zip", "(", "l2s", ",", "scores", ",", "nimg", ")", ")", ":", "\n", "          ", "lab", "=", "np", ".", "argmax", "(", "batchlab", "[", "e", "]", ")", "\n", "if", "l2", "<", "bestl2", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "            ", "bestl2", "[", "e", "]", "=", "l2", "\n", "bestscore", "[", "e", "]", "=", "np", ".", "argmax", "(", "sc", ")", "\n", "", "if", "l2", "<", "o_bestl2", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "            ", "o_bestl2", "[", "e", "]", "=", "l2", "\n", "o_bestscore", "[", "e", "]", "=", "np", ".", "argmax", "(", "sc", ")", "\n", "o_bestattack", "[", "e", "]", "=", "ii", "\n", "\n", "# adjust the constant as needed", "\n", "", "", "", "for", "e", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "if", "compare", "(", "bestscore", "[", "e", "]", ",", "np", ".", "argmax", "(", "batchlab", "[", "e", "]", ")", ")", "and", "bestscore", "[", "e", "]", "!=", "-", "1", ":", "\n", "# success, divide const by two", "\n", "          ", "upper_bound", "[", "e", "]", "=", "min", "(", "upper_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "# failure, either multiply by 10 if no solution found yet", "\n", "#          or do binary search with the known upper bound", "\n", "          ", "lower_bound", "[", "e", "]", "=", "max", "(", "lower_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "CONST", "[", "e", "]", "*=", "10", "\n", "", "", "", "_logger", ".", "debug", "(", "\"  Successfully generated adversarial examples \"", "+", "\n", "\"on {} of {} instances.\"", ".", "format", "(", "\n", "sum", "(", "upper_bound", "<", "1e9", ")", ",", "batch_size", ")", ")", "\n", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "mean", "=", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "o_bestl2", "[", "o_bestl2", "<", "1e9", "]", ")", ")", "\n", "_logger", ".", "debug", "(", "\"   Mean successful distortion: {:.4g}\"", ".", "format", "(", "mean", ")", ")", "\n", "\n", "# return the best solution found", "\n", "", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "return", "o_bestattack", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.__init__": [[811, 1018], ["tensorflow.cast", "tuple", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.Variable", "tensorflow.cast", "tensorflow.divide", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.minimum", "tensorflow.maximum", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.assign", "tensorflow.assign", "model.get_logits", "model.get_logits", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_max", "cleverhans.compat.reduce_max", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "tensorflow.train.polynomial_decay", "set", "tensorflow.train.GradientDescentOptimizer", "tensorflow.train.GradientDescentOptimizer.minimize", "tensorflow.global_variables", "attacks_tf.ElasticNetMethod.setup.append", "attacks_tf.ElasticNetMethod.setup.append", "attacks_tf.ElasticNetMethod.setup.append", "tensorflow.variables_initializer", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "tensorflow.greater", "tensorflow.less_equal", "tensorflow.less", "tensorflow.subtract", "tensorflow.cast", "tensorflow.add", "tensorflow.cast", "tensorflow.square", "list", "tensorflow.square", "list", "tensorflow.abs", "list", "tensorflow.abs", "list", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.maximum", "tensorflow.multiply", "attacks_tf.ElasticNetMethod.timg.assign", "attacks_tf.ElasticNetMethod.tlab.assign", "attacks_tf.ElasticNetMethod.const.assign", "list", "tensorflow.cast", "tensorflow.subtract", "tensorflow.abs", "tensorflow.subtract", "tensorflow.negative", "range", "range", "range", "range", "attacks_tf.ZERO", "attacks_tf.ZERO", "attacks_tf.ZERO", "attacks_tf.ZERO", "tensorflow.subtract", "len", "len", "len", "len", "tensorflow.global_variables"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO"], ["  ", "def", "__init__", "(", "self", ",", "sess", ",", "model", ",", "beta", ",", "decision_rule", ",", "batch_size", ",", "\n", "confidence", ",", "targeted", ",", "learning_rate", ",", "binary_search_steps", ",", "\n", "max_iterations", ",", "abort_early", ",", "initial_const", ",", "clip_min", ",", "\n", "clip_max", ",", "num_labels", ",", "shape", ")", ":", "\n", "    ", "\"\"\"\n    EAD Attack\n\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param sess: a TF session.\n    :param model: a cleverhans.model.Model object.\n    :param beta: Trades off L2 distortion with L1 distortion: higher\n                 produces examples with lower L1 distortion, at the\n                 cost of higher L2 (and typically Linf) distortion\n    :param decision_rule: EN or L1. Select final adversarial example from\n                          all successful examples based on the least\n                          elastic-net or L1 distortion criterion.\n    :param batch_size: Number of attacks to run simultaneously.\n    :param confidence: Confidence of adversarial examples: higher produces\n                       examples with larger l2 distortion, but more\n                       strongly classified as adversarial.\n    :param targeted: boolean controlling the behavior of the adversarial\n                     examples produced. If set to False, they will be\n                     misclassified in any wrong class. If set to True,\n                     they will be misclassified in a chosen target class.\n    :param learning_rate: The learning rate for the attack algorithm.\n                          Smaller values produce better results but are\n                          slower to converge.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the perturbation\n                                and confidence of the classification. Set\n                                'initial_const' to a large value and fix\n                                this param to 1 for speed.\n    :param max_iterations: The maximum number of iterations. Setting this\n                           to a larger value will produce lower distortion\n                           results. Using only a few iterations requires\n                           a larger learning rate, and will produce larger\n                           distortion results.\n    :param abort_early: If true, allows early abort when the total\n                        loss starts to increase (greatly speeds up attack,\n                        but hurts performance, particularly on ImageNet)\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the perturbation\n                          and confidence of classification.\n                          If binary_search_steps is large, the initial\n                          constant is not important. A smaller value of\n                          this constant gives lower distortion results.\n                          For computational efficiency, fix\n                          binary_search_steps to 1 and set this param\n                          to a large value.\n    :param clip_min: (optional float) Minimum input component value.\n    :param clip_max: (optional float) Maximum input component value.\n    :param num_labels: the number of classes in the model's output.\n    :param shape: the shape of the model's input tensor.\n    \"\"\"", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "TARGETED", "=", "targeted", "\n", "self", ".", "LEARNING_RATE", "=", "learning_rate", "\n", "self", ".", "MAX_ITERATIONS", "=", "max_iterations", "\n", "self", ".", "BINARY_SEARCH_STEPS", "=", "binary_search_steps", "\n", "self", ".", "ABORT_EARLY", "=", "abort_early", "\n", "self", ".", "CONFIDENCE", "=", "confidence", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "decision_rule", "=", "decision_rule", "\n", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "beta_t", "=", "tf", ".", "cast", "(", "self", ".", "beta", ",", "tf_dtype", ")", "\n", "\n", "self", ".", "repeat", "=", "binary_search_steps", ">=", "10", "\n", "\n", "self", ".", "shape", "=", "shape", "=", "tuple", "(", "[", "batch_size", "]", "+", "list", "(", "shape", ")", ")", "\n", "\n", "# these are variables to be more efficient in sending data to tf", "\n", "self", ".", "timg", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'timg'", ")", "\n", "self", ".", "newimg", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'newimg'", ")", "\n", "self", ".", "slack", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'slack'", ")", "\n", "self", ".", "tlab", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "(", "batch_size", ",", "num_labels", ")", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'tlab'", ")", "\n", "self", ".", "const", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "batch_size", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'const'", ")", "\n", "\n", "# and here's what we use to assign them", "\n", "self", ".", "assign_timg", "=", "tf", ".", "placeholder", "(", "tf_dtype", ",", "shape", ",", "name", "=", "'assign_timg'", ")", "\n", "self", ".", "assign_newimg", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "shape", ",", "name", "=", "'assign_newimg'", ")", "\n", "self", ".", "assign_slack", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "shape", ",", "name", "=", "'assign_slack'", ")", "\n", "self", ".", "assign_tlab", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "(", "batch_size", ",", "num_labels", ")", ",", "name", "=", "'assign_tlab'", ")", "\n", "self", ".", "assign_const", "=", "tf", ".", "placeholder", "(", "\n", "tf_dtype", ",", "[", "batch_size", "]", ",", "name", "=", "'assign_const'", ")", "\n", "\n", "self", ".", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ")", "\n", "self", ".", "global_step_t", "=", "tf", ".", "cast", "(", "self", ".", "global_step", ",", "tf_dtype", ")", "\n", "\n", "# Fast Iterative Shrinkage Thresholding", "\n", "self", ".", "zt", "=", "tf", ".", "divide", "(", "self", ".", "global_step_t", ",", "\n", "self", ".", "global_step_t", "+", "tf", ".", "cast", "(", "3", ",", "tf_dtype", ")", ")", "\n", "cond1", "=", "tf", ".", "cast", "(", "tf", ".", "greater", "(", "tf", ".", "subtract", "(", "self", ".", "slack", ",", "self", ".", "timg", ")", ",", "\n", "self", ".", "beta_t", ")", ",", "tf_dtype", ")", "\n", "cond2", "=", "tf", ".", "cast", "(", "tf", ".", "less_equal", "(", "tf", ".", "abs", "(", "tf", ".", "subtract", "(", "self", ".", "slack", ",", "\n", "self", ".", "timg", ")", ")", ",", "\n", "self", ".", "beta_t", ")", ",", "tf_dtype", ")", "\n", "cond3", "=", "tf", ".", "cast", "(", "tf", ".", "less", "(", "tf", ".", "subtract", "(", "self", ".", "slack", ",", "self", ".", "timg", ")", ",", "\n", "tf", ".", "negative", "(", "self", ".", "beta_t", ")", ")", ",", "tf_dtype", ")", "\n", "\n", "upper", "=", "tf", ".", "minimum", "(", "tf", ".", "subtract", "(", "self", ".", "slack", ",", "self", ".", "beta_t", ")", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "tf_dtype", ")", ")", "\n", "lower", "=", "tf", ".", "maximum", "(", "tf", ".", "add", "(", "self", ".", "slack", ",", "self", ".", "beta_t", ")", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "tf_dtype", ")", ")", "\n", "\n", "self", ".", "assign_newimg", "=", "tf", ".", "multiply", "(", "cond1", ",", "upper", ")", "\n", "self", ".", "assign_newimg", "+=", "tf", ".", "multiply", "(", "cond2", ",", "self", ".", "timg", ")", "\n", "self", ".", "assign_newimg", "+=", "tf", ".", "multiply", "(", "cond3", ",", "lower", ")", "\n", "\n", "self", ".", "assign_slack", "=", "self", ".", "assign_newimg", "\n", "self", ".", "assign_slack", "+=", "tf", ".", "multiply", "(", "self", ".", "zt", ",", "\n", "self", ".", "assign_newimg", "-", "self", ".", "newimg", ")", "\n", "\n", "# --------------------------------", "\n", "self", ".", "setter", "=", "tf", ".", "assign", "(", "self", ".", "newimg", ",", "self", ".", "assign_newimg", ")", "\n", "self", ".", "setter_y", "=", "tf", ".", "assign", "(", "self", ".", "slack", ",", "self", ".", "assign_slack", ")", "\n", "\n", "# prediction BEFORE-SOFTMAX of the model", "\n", "self", ".", "output", "=", "model", ".", "get_logits", "(", "self", ".", "newimg", ")", "\n", "self", ".", "output_y", "=", "model", ".", "get_logits", "(", "self", ".", "slack", ")", "\n", "\n", "# distance to the input data", "\n", "self", ".", "l2dist", "=", "reduce_sum", "(", "tf", ".", "square", "(", "self", ".", "newimg", "-", "self", ".", "timg", ")", ",", "\n", "list", "(", "range", "(", "1", ",", "len", "(", "shape", ")", ")", ")", ")", "\n", "self", ".", "l2dist_y", "=", "reduce_sum", "(", "tf", ".", "square", "(", "self", ".", "slack", "-", "self", ".", "timg", ")", ",", "\n", "list", "(", "range", "(", "1", ",", "len", "(", "shape", ")", ")", ")", ")", "\n", "self", ".", "l1dist", "=", "reduce_sum", "(", "tf", ".", "abs", "(", "self", ".", "newimg", "-", "self", ".", "timg", ")", ",", "\n", "list", "(", "range", "(", "1", ",", "len", "(", "shape", ")", ")", ")", ")", "\n", "self", ".", "l1dist_y", "=", "reduce_sum", "(", "tf", ".", "abs", "(", "self", ".", "slack", "-", "self", ".", "timg", ")", ",", "\n", "list", "(", "range", "(", "1", ",", "len", "(", "shape", ")", ")", ")", ")", "\n", "self", ".", "elasticdist", "=", "self", ".", "l2dist", "+", "tf", ".", "multiply", "(", "self", ".", "l1dist", ",", "\n", "self", ".", "beta_t", ")", "\n", "self", ".", "elasticdist_y", "=", "self", ".", "l2dist_y", "+", "tf", ".", "multiply", "(", "self", ".", "l1dist_y", ",", "\n", "self", ".", "beta_t", ")", "\n", "if", "self", ".", "decision_rule", "==", "'EN'", ":", "\n", "      ", "self", ".", "crit", "=", "self", ".", "elasticdist", "\n", "self", ".", "crit_p", "=", "'Elastic'", "\n", "", "else", ":", "\n", "      ", "self", ".", "crit", "=", "self", ".", "l1dist", "\n", "self", ".", "crit_p", "=", "'L1'", "\n", "\n", "# compute the probability of the label class versus the maximum other", "\n", "", "real", "=", "reduce_sum", "(", "(", "self", ".", "tlab", ")", "*", "self", ".", "output", ",", "1", ")", "\n", "real_y", "=", "reduce_sum", "(", "(", "self", ".", "tlab", ")", "*", "self", ".", "output_y", ",", "1", ")", "\n", "other", "=", "reduce_max", "(", "(", "1", "-", "self", ".", "tlab", ")", "*", "self", ".", "output", "-", "\n", "(", "self", ".", "tlab", "*", "10000", ")", ",", "1", ")", "\n", "other_y", "=", "reduce_max", "(", "(", "1", "-", "self", ".", "tlab", ")", "*", "self", ".", "output_y", "-", "\n", "(", "self", ".", "tlab", "*", "10000", ")", ",", "1", ")", "\n", "\n", "if", "self", ".", "TARGETED", ":", "\n", "# if targeted, optimize for making the other class most likely", "\n", "      ", "loss1", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "other", "-", "real", "+", "self", ".", "CONFIDENCE", ")", "\n", "loss1_y", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "other_y", "-", "real_y", "+", "self", ".", "CONFIDENCE", ")", "\n", "", "else", ":", "\n", "# if untargeted, optimize for making this class least likely.", "\n", "      ", "loss1", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "real", "-", "other", "+", "self", ".", "CONFIDENCE", ")", "\n", "loss1_y", "=", "tf", ".", "maximum", "(", "ZERO", "(", ")", ",", "real_y", "-", "other_y", "+", "self", ".", "CONFIDENCE", ")", "\n", "\n", "# sum up the losses", "\n", "", "self", ".", "loss21", "=", "reduce_sum", "(", "self", ".", "l1dist", ")", "\n", "self", ".", "loss21_y", "=", "reduce_sum", "(", "self", ".", "l1dist_y", ")", "\n", "self", ".", "loss2", "=", "reduce_sum", "(", "self", ".", "l2dist", ")", "\n", "self", ".", "loss2_y", "=", "reduce_sum", "(", "self", ".", "l2dist_y", ")", "\n", "self", ".", "loss1", "=", "reduce_sum", "(", "self", ".", "const", "*", "loss1", ")", "\n", "self", ".", "loss1_y", "=", "reduce_sum", "(", "self", ".", "const", "*", "loss1_y", ")", "\n", "self", ".", "loss_opt", "=", "self", ".", "loss1_y", "+", "self", ".", "loss2_y", "\n", "self", ".", "loss", "=", "self", ".", "loss1", "+", "self", ".", "loss2", "+", "tf", ".", "multiply", "(", "self", ".", "beta_t", ",", "self", ".", "loss21", ")", "\n", "\n", "self", ".", "learning_rate", "=", "tf", ".", "train", ".", "polynomial_decay", "(", "\n", "self", ".", "LEARNING_RATE", ",", "\n", "self", ".", "global_step", ",", "\n", "self", ".", "MAX_ITERATIONS", ",", "\n", "0", ",", "\n", "power", "=", "0.5", ")", "\n", "\n", "# Setup the optimizer and keep track of variables we're creating", "\n", "start_vars", "=", "set", "(", "x", ".", "name", "for", "x", "in", "tf", ".", "global_variables", "(", ")", ")", "\n", "optimizer", "=", "tf", ".", "train", ".", "GradientDescentOptimizer", "(", "self", ".", "learning_rate", ")", "\n", "self", ".", "train", "=", "optimizer", ".", "minimize", "(", "self", ".", "loss_opt", ",", "\n", "var_list", "=", "[", "self", ".", "slack", "]", ",", "\n", "global_step", "=", "self", ".", "global_step", ")", "\n", "end_vars", "=", "tf", ".", "global_variables", "(", ")", "\n", "new_vars", "=", "[", "x", "for", "x", "in", "end_vars", "if", "x", ".", "name", "not", "in", "start_vars", "]", "\n", "\n", "# these are the variables to initialize when we run", "\n", "self", ".", "setup", "=", "[", "]", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "timg", ".", "assign", "(", "self", ".", "assign_timg", ")", ")", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "tlab", ".", "assign", "(", "self", ".", "assign_tlab", ")", ")", "\n", "self", ".", "setup", ".", "append", "(", "self", ".", "const", ".", "assign", "(", "self", ".", "assign_const", ")", ")", "\n", "\n", "var_list", "=", "[", "self", ".", "global_step", "]", "+", "[", "self", ".", "slack", "]", "+", "[", "self", ".", "newimg", "]", "+", "new_vars", "\n", "self", ".", "init", "=", "tf", ".", "variables_initializer", "(", "var_list", "=", "var_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.attack": [[1019, 1050], ["range", "numpy.array", "_logger.debug", "r.extend", "_logger.debug", "numpy.zeros", "numpy.zeros", "attacks_tf.ElasticNetMethod.attack_batch", "r.extend", "len", "attacks_tf.ElasticNetMethod.attack_batch", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.attack_batch", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.attack_batch"], ["", "def", "attack", "(", "self", ",", "imgs", ",", "targets", ")", ":", "\n", "    ", "\"\"\"\n    Perform the EAD attack on the given instance for the given targets.\n\n    If self.targeted is true, then the targets represents the target labels\n    If self.targeted is false, then targets are the original class labels\n    \"\"\"", "\n", "\n", "batch_size", "=", "self", ".", "batch_size", "\n", "r", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "imgs", ")", "//", "batch_size", ")", ":", "\n", "      ", "_logger", ".", "debug", "(", "\n", "(", "\"Running EAD attack on instance %s of %s\"", ",", "\n", "i", "*", "batch_size", ",", "len", "(", "imgs", ")", ")", ")", "\n", "r", ".", "extend", "(", "\n", "self", ".", "attack_batch", "(", "\n", "imgs", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ",", "\n", "targets", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ")", ")", "\n", "", "if", "len", "(", "imgs", ")", "%", "batch_size", "!=", "0", ":", "\n", "      ", "last_elements", "=", "len", "(", "imgs", ")", "-", "(", "len", "(", "imgs", ")", "%", "batch_size", ")", "\n", "_logger", ".", "debug", "(", "\n", "(", "\"Running EAD attack on instance %s of %s\"", ",", "\n", "last_elements", ",", "len", "(", "imgs", ")", ")", ")", "\n", "temp_imgs", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "imgs", ".", "shape", "[", "2", ":", "]", ")", "\n", "temp_targets", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", "+", "targets", ".", "shape", "[", "2", ":", "]", ")", "\n", "temp_imgs", "[", ":", "(", "len", "(", "imgs", ")", "%", "batch_size", ")", "]", "=", "imgs", "[", "last_elements", ":", "]", "\n", "temp_targets", "[", ":", "(", "len", "(", "imgs", ")", "%", "batch_size", ")", "]", "=", "targets", "[", "last_elements", ":", "]", "\n", "temp_data", "=", "self", ".", "attack_batch", "(", "temp_imgs", ",", "temp_targets", ")", "\n", "r", ".", "extend", "(", "temp_data", "[", ":", "(", "len", "(", "imgs", ")", "%", "batch_size", ")", "]", ",", "\n", "targets", "[", "last_elements", ":", "]", ")", "\n", "", "return", "np", ".", "array", "(", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ElasticNetMethod.attack_batch": [[1051, 1172], ["numpy.clip", "numpy.zeros", "numpy.copy", "range", "numpy.array", "numpy.ones", "numpy.ones", "attacks_tf.ElasticNetMethod.sess.run", "_logger.debug", "attacks_tf.ElasticNetMethod.sess.run", "attacks_tf.ElasticNetMethod.sess.run", "attacks_tf.ElasticNetMethod.sess.run", "range", "range", "_logger.debug", "numpy.array", "numpy.mean", "_logger.debug", "isinstance", "numpy.copy", "numpy.argmax", "attacks_tf.ElasticNetMethod.sess.run", "attacks_tf.ElasticNetMethod.sess.run", "attacks_tf.ElasticNetMethod.sess.run", "enumerate", "numpy.sqrt", "_logger.debug", "zip", "numpy.argmax", "attacks_tf.ElasticNetMethod.attack_batch.compare"], "methods", ["None"], ["", "def", "attack_batch", "(", "self", ",", "imgs", ",", "labs", ")", ":", "\n", "    ", "\"\"\"\n    Run the attack on a batch of instance and labels.\n    \"\"\"", "\n", "\n", "def", "compare", "(", "x", ",", "y", ")", ":", "\n", "      ", "if", "not", "isinstance", "(", "x", ",", "(", "float", ",", "int", ",", "np", ".", "int64", ")", ")", ":", "\n", "        ", "x", "=", "np", ".", "copy", "(", "x", ")", "\n", "if", "self", ".", "TARGETED", ":", "\n", "          ", "x", "[", "y", "]", "-=", "self", ".", "CONFIDENCE", "\n", "", "else", ":", "\n", "          ", "x", "[", "y", "]", "+=", "self", ".", "CONFIDENCE", "\n", "", "x", "=", "np", ".", "argmax", "(", "x", ")", "\n", "", "if", "self", ".", "TARGETED", ":", "\n", "        ", "return", "x", "==", "y", "\n", "", "else", ":", "\n", "        ", "return", "x", "!=", "y", "\n", "\n", "", "", "batch_size", "=", "self", ".", "batch_size", "\n", "\n", "imgs", "=", "np", ".", "clip", "(", "imgs", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "# set the lower and upper bounds accordingly", "\n", "lower_bound", "=", "np", ".", "zeros", "(", "batch_size", ")", "\n", "CONST", "=", "np", ".", "ones", "(", "batch_size", ")", "*", "self", ".", "initial_const", "\n", "upper_bound", "=", "np", ".", "ones", "(", "batch_size", ")", "*", "1e10", "\n", "\n", "# placeholders for the best en, score, and instance attack found so far", "\n", "o_bestdst", "=", "[", "1e10", "]", "*", "batch_size", "\n", "o_bestscore", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "o_bestattack", "=", "np", ".", "copy", "(", "imgs", ")", "\n", "\n", "for", "outer_step", "in", "range", "(", "self", ".", "BINARY_SEARCH_STEPS", ")", ":", "\n", "# completely reset the optimizer's internal state.", "\n", "      ", "self", ".", "sess", ".", "run", "(", "self", ".", "init", ")", "\n", "batch", "=", "imgs", "[", ":", "batch_size", "]", "\n", "batchlab", "=", "labs", "[", ":", "batch_size", "]", "\n", "\n", "bestdst", "=", "[", "1e10", "]", "*", "batch_size", "\n", "bestscore", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "_logger", ".", "debug", "(", "\"  Binary search step %s of %s\"", ",", "\n", "outer_step", ",", "self", ".", "BINARY_SEARCH_STEPS", ")", "\n", "\n", "# The last iteration (if we run many steps) repeat the search once.", "\n", "if", "self", ".", "repeat", "and", "outer_step", "==", "self", ".", "BINARY_SEARCH_STEPS", "-", "1", ":", "\n", "        ", "CONST", "=", "upper_bound", "\n", "\n", "# set the variables so that we don't have to send them over again", "\n", "", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "setup", ",", "{", "\n", "self", ".", "assign_timg", ":", "batch", ",", "\n", "self", ".", "assign_tlab", ":", "batchlab", ",", "\n", "self", ".", "assign_const", ":", "CONST", "\n", "}", ")", "\n", "self", ".", "sess", ".", "run", "(", "self", ".", "setter", ",", "{", "self", ".", "assign_newimg", ":", "batch", "}", ")", "\n", "self", ".", "sess", ".", "run", "(", "self", ".", "setter_y", ",", "{", "self", ".", "assign_slack", ":", "batch", "}", ")", "\n", "prev", "=", "1e6", "\n", "for", "iteration", "in", "range", "(", "self", ".", "MAX_ITERATIONS", ")", ":", "\n", "# perform the attack", "\n", "        ", "self", ".", "sess", ".", "run", "(", "[", "self", ".", "train", "]", ")", "\n", "self", ".", "sess", ".", "run", "(", "[", "self", ".", "setter", ",", "self", ".", "setter_y", "]", ")", "\n", "l", ",", "l2s", ",", "l1s", ",", "crit", ",", "scores", ",", "nimg", "=", "self", ".", "sess", ".", "run", "(", "[", "self", ".", "loss", ",", "\n", "self", ".", "l2dist", ",", "\n", "self", ".", "l1dist", ",", "\n", "self", ".", "crit", ",", "\n", "self", ".", "output", ",", "\n", "self", ".", "newimg", "]", ")", "\n", "if", "iteration", "%", "(", "(", "self", ".", "MAX_ITERATIONS", "//", "10", ")", "or", "1", ")", "==", "0", ":", "\n", "          ", "_logger", ".", "debug", "(", "(", "\"    Iteration {} of {}: loss={:.3g} \"", "+", "\n", "\"l2={:.3g} l1={:.3g} f={:.3g}\"", ")", ".", "format", "(", "\n", "iteration", ",", "self", ".", "MAX_ITERATIONS", ",", "l", ",", "\n", "np", ".", "mean", "(", "l2s", ")", ",", "np", ".", "mean", "(", "l1s", ")", ",", "\n", "np", ".", "mean", "(", "scores", ")", ")", ")", "\n", "\n", "# check if we should abort search if we're getting nowhere.", "\n", "", "if", "self", ".", "ABORT_EARLY", "and", "iteration", "%", "(", "(", "self", ".", "MAX_ITERATIONS", "//", "10", ")", "or", "1", ")", "==", "0", ":", "\n", "          ", "if", "l", ">", "prev", "*", ".9999", ":", "\n", "            ", "msg", "=", "\"    Failed to make progress; stop early\"", "\n", "_logger", ".", "debug", "(", "msg", ")", "\n", "break", "\n", "", "prev", "=", "l", "\n", "\n", "# adjust the best result found so far", "\n", "", "for", "e", ",", "(", "dst", ",", "sc", ",", "ii", ")", "in", "enumerate", "(", "zip", "(", "crit", ",", "scores", ",", "nimg", ")", ")", ":", "\n", "          ", "lab", "=", "np", ".", "argmax", "(", "batchlab", "[", "e", "]", ")", "\n", "if", "dst", "<", "bestdst", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "            ", "bestdst", "[", "e", "]", "=", "dst", "\n", "bestscore", "[", "e", "]", "=", "np", ".", "argmax", "(", "sc", ")", "\n", "", "if", "dst", "<", "o_bestdst", "[", "e", "]", "and", "compare", "(", "sc", ",", "lab", ")", ":", "\n", "            ", "o_bestdst", "[", "e", "]", "=", "dst", "\n", "o_bestscore", "[", "e", "]", "=", "np", ".", "argmax", "(", "sc", ")", "\n", "o_bestattack", "[", "e", "]", "=", "ii", "\n", "\n", "# adjust the constant as needed", "\n", "", "", "", "for", "e", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "if", "compare", "(", "bestscore", "[", "e", "]", ",", "np", ".", "argmax", "(", "batchlab", "[", "e", "]", ")", ")", "and", "bestscore", "[", "e", "]", "!=", "-", "1", ":", "\n", "# success, divide const by two", "\n", "          ", "upper_bound", "[", "e", "]", "=", "min", "(", "upper_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "# failure, either multiply by 10 if no solution found yet", "\n", "#          or do binary search with the known upper bound", "\n", "          ", "lower_bound", "[", "e", "]", "=", "max", "(", "lower_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "CONST", "[", "e", "]", "*=", "10", "\n", "", "", "", "_logger", ".", "debug", "(", "\"  Successfully generated adversarial examples \"", "+", "\n", "\"on {} of {} instances.\"", ".", "format", "(", "\n", "sum", "(", "upper_bound", "<", "1e9", ")", ",", "batch_size", ")", ")", "\n", "o_bestdst", "=", "np", ".", "array", "(", "o_bestdst", ")", "\n", "mean", "=", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "o_bestdst", "[", "o_bestdst", "<", "1e9", "]", ")", ")", "\n", "_logger", ".", "debug", "(", "self", ".", "crit_p", "+", "\n", "\" Mean successful distortion: {:.4g}\"", ".", "format", "(", "mean", ")", ")", "\n", "\n", "# return the best solution found", "\n", "", "o_bestdst", "=", "np", ".", "array", "(", "o_bestdst", ")", "\n", "return", "o_bestattack", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.LBFGS_attack.__init__": [[1315, 1370], ["warnings.warn", "tuple", "tensorflow.Variable", "tensorflow.Variable", "cleverhans.compat.softmax_cross_entropy_with_logits", "cleverhans.compat.reduce_sum", "tensorflow.gradients", "numpy.zeros", "numpy.zeros", "tensorflow.square", "cleverhans.compat.reduce_sum", "list", "attacks_tf.LBFGS_attack.x.get_shape().as_list", "attacks_tf.LBFGS_attack.x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["  ", "def", "__init__", "(", "self", ",", "sess", ",", "x", ",", "model_preds", ",", "targeted_label", ",", "\n", "binary_search_steps", ",", "max_iterations", ",", "initial_const", ",", "clip_min", ",", "\n", "clip_max", ",", "nb_classes", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param sess: a TF session.\n    :param x: A tensor with the inputs.\n    :param model_preds: A tensor with model's predictions.\n    :param targeted_label: A tensor with the target labels.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the purturbation\n                                and cross-entropy loss of classification.\n    :param max_iterations: The maximum number of iterations.\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the purturbation\n                          and cross-entropy loss of the classification.\n    :param clip_min: Minimum input component value\n    :param clip_max: Maximum input component value\n    :param num_labels: The number of classes in the model's output.\n    :param batch_size: Number of attacks to run simultaneously.\n\n    \"\"\"", "\n", "warnings", ".", "warn", "(", "\"This class is deprecated and will be removed on or after \"", "\n", "\"2019-04-10. Switch to cleverhans.attacks.LBFGS_impl. \"", "\n", "\"Note that it uses *logits* not *probabilities*.\"", ")", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "model_preds", "=", "model_preds", "\n", "self", ".", "targeted_label", "=", "targeted_label", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "self", ".", "repeat", "=", "self", ".", "binary_search_steps", ">=", "10", "\n", "self", ".", "shape", "=", "tuple", "(", "[", "self", ".", "batch_size", "]", "+", "\n", "list", "(", "self", ".", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", ")", "\n", "self", ".", "ori_img", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "self", ".", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'ori_img'", ")", "\n", "self", ".", "const", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'const'", ")", "\n", "\n", "assert", "self", ".", "model_preds", ".", "op", ".", "type", "==", "'Softmax'", "\n", "logits", ",", "=", "self", ".", "model_preds", ".", "op", ".", "inputs", "\n", "self", ".", "score", "=", "softmax_cross_entropy_with_logits", "(", "labels", "=", "self", ".", "targeted_label", ",", "\n", "logits", "=", "logits", ")", "\n", "self", ".", "l2dist", "=", "reduce_sum", "(", "tf", ".", "square", "(", "self", ".", "x", "-", "self", ".", "ori_img", ")", ")", "\n", "# small self.const will result small adversarial perturbation", "\n", "self", ".", "loss", "=", "reduce_sum", "(", "self", ".", "score", "*", "self", ".", "const", ")", "+", "self", ".", "l2dist", "\n", "self", ".", "grad", ",", "=", "tf", ".", "gradients", "(", "self", ".", "loss", ",", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.LBFGS_attack.attack": [[1371, 1478], ["numpy.clip", "numpy.zeros", "list", "numpy.copy", "range", "numpy.array", "attacks_tf.LBFGS_attack.sess.run", "attacks_tf.LBFGS_attack.sess.run", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "zip", "_logger.debug", "fmin_l_bfgs_b", "adv_x.reshape.reshape.reshape", "numpy.atleast_1d", "_logger.debug", "numpy.zeros", "range", "enumerate", "range", "_logger.debug", "numpy.array", "numpy.mean", "_logger.debug", "attacks_tf.LBFGS_attack.flatten().astype", "clip_min.flatten", "clip_max.flatten", "numpy.clip.flatten().astype", "cleverhans.utils_tf.model_argmax", "numpy.sum", "zip", "numpy.sqrt", "numpy.amax", "numpy.amin", "numpy.square", "numpy.argmax", "min", "max", "adv_x.reshape.reshape.reshape", "adv_x.reshape.reshape.reshape", "attacks_tf.LBFGS_attack.flatten", "numpy.clip.flatten", "numpy.argmax", "sum"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax"], ["", "def", "attack", "(", "self", ",", "x_val", ",", "targets", ")", ":", "\n", "    ", "\"\"\"\n    Perform the attack on the given instance for the given targets.\n    \"\"\"", "\n", "\n", "def", "lbfgs_objective", "(", "adv_x", ",", "self", ",", "targets", ",", "oimgs", ",", "CONST", ")", ":", "\n", "# returns the function value and the gradient for fmin_l_bfgs_b", "\n", "      ", "loss", "=", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "loss", ",", "\n", "feed_dict", "=", "{", "\n", "self", ".", "x", ":", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", ",", "\n", "self", ".", "targeted_label", ":", "targets", ",", "\n", "self", ".", "ori_img", ":", "oimgs", ",", "\n", "self", ".", "const", ":", "CONST", "\n", "}", ")", "\n", "grad", "=", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "grad", ",", "\n", "feed_dict", "=", "{", "\n", "self", ".", "x", ":", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", ",", "\n", "self", ".", "targeted_label", ":", "targets", ",", "\n", "self", ".", "ori_img", ":", "oimgs", ",", "\n", "self", ".", "const", ":", "CONST", "\n", "}", ")", "\n", "return", "loss", ",", "grad", ".", "flatten", "(", ")", ".", "astype", "(", "float", ")", "\n", "\n", "# begin the main part for the attack", "\n", "", "from", "scipy", ".", "optimize", "import", "fmin_l_bfgs_b", "\n", "oimgs", "=", "np", ".", "clip", "(", "x_val", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "CONST", "=", "np", ".", "ones", "(", "self", ".", "batch_size", ")", "*", "self", ".", "initial_const", "\n", "\n", "# set the lower and upper bounds accordingly", "\n", "lower_bound", "=", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", "\n", "upper_bound", "=", "np", ".", "ones", "(", "self", ".", "batch_size", ")", "*", "1e10", "\n", "\n", "# set the box constraints for the optimization function", "\n", "clip_min", "=", "self", ".", "clip_min", "*", "np", ".", "ones", "(", "oimgs", ".", "shape", "[", ":", "]", ")", "\n", "clip_max", "=", "self", ".", "clip_max", "*", "np", ".", "ones", "(", "oimgs", ".", "shape", "[", ":", "]", ")", "\n", "clip_bound", "=", "list", "(", "zip", "(", "clip_min", ".", "flatten", "(", ")", ",", "clip_max", ".", "flatten", "(", ")", ")", ")", "\n", "\n", "# placeholders for the best l2 and instance attack found so far", "\n", "o_bestl2", "=", "[", "1e10", "]", "*", "self", ".", "batch_size", "\n", "o_bestattack", "=", "np", ".", "copy", "(", "oimgs", ")", "\n", "\n", "for", "outer_step", "in", "range", "(", "self", ".", "binary_search_steps", ")", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"  Binary search step %s of %s\"", ",", "\n", "outer_step", ",", "self", ".", "binary_search_steps", ")", "\n", "\n", "# The last iteration (if we run many steps) repeat the search once.", "\n", "if", "self", ".", "repeat", "and", "outer_step", "==", "self", ".", "binary_search_steps", "-", "1", ":", "\n", "        ", "CONST", "=", "upper_bound", "\n", "\n", "# optimization function", "\n", "", "adv_x", ",", "_", ",", "__", "=", "fmin_l_bfgs_b", "(", "\n", "lbfgs_objective", ",", "\n", "oimgs", ".", "flatten", "(", ")", ".", "astype", "(", "float", ")", ",", "\n", "args", "=", "(", "self", ",", "targets", ",", "oimgs", ",", "CONST", ")", ",", "\n", "bounds", "=", "clip_bound", ",", "\n", "maxiter", "=", "self", ".", "max_iterations", ",", "\n", "iprint", "=", "0", ")", "\n", "\n", "adv_x", "=", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", "\n", "assert", "np", ".", "amax", "(", "adv_x", ")", "<=", "self", ".", "clip_max", "and", "np", ".", "amin", "(", "adv_x", ")", ">=", "self", ".", "clip_min", ",", "'fmin_l_bfgs_b returns are invalid'", "\n", "\n", "# adjust the best result (i.e., the adversarial example with the", "\n", "# smallest perturbation in terms of L_2 norm) found so far", "\n", "preds", "=", "np", ".", "atleast_1d", "(", "\n", "utils_tf", ".", "model_argmax", "(", "self", ".", "sess", ",", "self", ".", "x", ",", "self", ".", "model_preds", ",", "\n", "adv_x", ")", ")", "\n", "_logger", ".", "debug", "(", "\"predicted labels are %s\"", ",", "preds", ")", "\n", "\n", "l2s", "=", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "        ", "l2s", "[", "i", "]", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "adv_x", "[", "i", "]", "-", "oimgs", "[", "i", "]", ")", ")", "\n", "\n", "", "for", "e", ",", "(", "l2", ",", "pred", ",", "ii", ")", "in", "enumerate", "(", "zip", "(", "l2s", ",", "preds", ",", "adv_x", ")", ")", ":", "\n", "        ", "if", "l2", "<", "o_bestl2", "[", "e", "]", "and", "pred", "==", "np", ".", "argmax", "(", "targets", "[", "e", "]", ")", ":", "\n", "          ", "o_bestl2", "[", "e", "]", "=", "l2", "\n", "o_bestattack", "[", "e", "]", "=", "ii", "\n", "\n", "# adjust the constant as needed", "\n", "", "", "for", "e", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "        ", "if", "preds", "[", "e", "]", "==", "np", ".", "argmax", "(", "targets", "[", "e", "]", ")", ":", "\n", "# success, divide const by two", "\n", "          ", "upper_bound", "[", "e", "]", "=", "min", "(", "upper_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "# failure, either multiply by 10 if no solution found yet", "\n", "#          or do binary search with the known upper bound", "\n", "          ", "lower_bound", "[", "e", "]", "=", "max", "(", "lower_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "CONST", "[", "e", "]", "*=", "10", "\n", "\n", "", "", "", "_logger", ".", "debug", "(", "\"  Successfully generated adversarial examples \"", "+", "\n", "\"on {} of {} instances.\"", ".", "format", "(", "\n", "sum", "(", "upper_bound", "<", "1e9", ")", ",", "self", ".", "batch_size", ")", ")", "\n", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "mean", "=", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "o_bestl2", "[", "o_bestl2", "<", "1e9", "]", ")", ")", "\n", "_logger", ".", "debug", "(", "\"   Mean successful distortion: {:.4g}\"", ".", "format", "(", "mean", ")", ")", "\n", "\n", "# return the best solution found", "\n", "", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "return", "o_bestattack", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer._compute_gradients": [[1492, 1517], ["cleverhans.compat.reduce_mean", "tensorflow.gradients", "isinstance", "loss_fn", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["def", "_compute_gradients", "(", "self", ",", "loss_fn", ",", "x", ",", "unused_optim_state", ")", ":", "\n", "    ", "\"\"\"Compute a new value of `x` to minimize `loss_fn`.\n\n    Args:\n        loss_fn: a callable that takes `x`, a batch of images, and returns\n            a batch of loss values. `x` will be optimized to minimize\n            `loss_fn(x)`.\n        x: A list of Tensors, the values to be updated. This is analogous\n            to the `var_list` argument in standard TF Optimizer.\n        unused_optim_state: A (possibly nested) dict, containing any state\n            info needed for the optimizer.\n\n    Returns:\n        new_x: A list of Tensors, the same length as `x`, which are updated\n        new_optim_state: A dict, with the same structure as `optim_state`,\n            which have been updated.\n    \"\"\"", "\n", "\n", "# Assumes `x` is a list,", "\n", "# and contains a tensor representing a batch of images", "\n", "assert", "len", "(", "x", ")", "==", "1", "and", "isinstance", "(", "x", ",", "list", ")", ",", "'x should be a list and contain only one image tensor'", "\n", "x", "=", "x", "[", "0", "]", "\n", "loss", "=", "reduce_mean", "(", "loss_fn", "(", "x", ")", ",", "axis", "=", "0", ")", "\n", "return", "tf", ".", "gradients", "(", "loss", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer._apply_gradients": [[1518, 1521], ["NotImplementedError"], "methods", ["None"], ["", "def", "_apply_gradients", "(", "self", ",", "grads", ",", "x", ",", "optim_state", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "\n", "\"_apply_gradients should be defined in each subclass\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize": [[1522, 1525], ["attacks_tf.TensorOptimizer._compute_gradients", "attacks_tf.TensorOptimizer._apply_gradients"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.SPSAAdam._compute_gradients", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorAdam._apply_gradients"], ["", "def", "minimize", "(", "self", ",", "loss_fn", ",", "x", ",", "optim_state", ")", ":", "\n", "    ", "grads", "=", "self", ".", "_compute_gradients", "(", "loss_fn", ",", "x", ",", "optim_state", ")", "\n", "return", "self", ".", "_apply_gradients", "(", "grads", ",", "x", ",", "optim_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.init_optim_state": [[1526, 1537], ["NotImplementedError"], "methods", ["None"], ["", "def", "init_optim_state", "(", "self", ",", "x", ")", ":", "\n", "    ", "\"\"\"Returns the initial state of the optimizer.\n\n    Args:\n        x: A list of Tensors, which will be optimized.\n\n    Returns:\n        A dictionary, representing the initial state of the optimizer.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"init_optim_state should be defined in each subclass\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.UnrolledOptimizer.__init__": [[1539, 1543], ["warnings.warn", "object.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"UnrolledOptimizer has been renamed to TensorOptimizer.\"", "\n", "\" The old name may be removed on or after 2019-04-25.\"", ")", "\n", "super", "(", "UnrolledOptimizer", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorGradientDescent.__init__": [[1548, 1550], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lr", ")", ":", "\n", "    ", "self", ".", "_lr", "=", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorGradientDescent.init_state": [[1551, 1553], ["None"], "methods", ["None"], ["", "def", "init_state", "(", "self", ",", "x", ")", ":", "\n", "    ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorGradientDescent._apply_gradients": [[1554, 1559], ["six.moves.xrange", "len", "len"], "methods", ["None"], ["", "def", "_apply_gradients", "(", "self", ",", "grads", ",", "x", ",", "optim_state", ")", ":", "\n", "    ", "new_x", "=", "[", "None", "]", "*", "len", "(", "x", ")", "\n", "for", "i", "in", "xrange", "(", "len", "(", "x", ")", ")", ":", "\n", "      ", "new_x", "[", "i", "]", "=", "x", "[", "i", "]", "-", "self", ".", "_lr", "*", "grads", "[", "i", "]", "\n", "", "return", "new_x", ",", "optim_state", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.UnrolledGradientDescent.__init__": [[1561, 1566], ["warnings.warn", "attacks_tf.TensorGradientDescent.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"UnrolledGradientDescent has been renamed to \"", "\n", "\"TensorGradientDescent.\"", "\n", "\" The old name may be removed on or after 2019-04-25.\"", ")", "\n", "super", "(", "UnrolledGradientDescent", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorAdam.__init__": [[1571, 1576], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lr", "=", "0.001", ",", "beta1", "=", "0.9", ",", "beta2", "=", "0.999", ",", "epsilon", "=", "1e-9", ")", ":", "\n", "    ", "self", ".", "_lr", "=", "lr", "\n", "self", ".", "_beta1", "=", "beta1", "\n", "self", ".", "_beta2", "=", "beta2", "\n", "self", ".", "_epsilon", "=", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorAdam.init_state": [[1577, 1583], ["tensorflow.zeros_like", "tensorflow.zeros_like"], "methods", ["None"], ["", "def", "init_state", "(", "self", ",", "x", ")", ":", "\n", "    ", "optim_state", "=", "{", "}", "\n", "optim_state", "[", "\"t\"", "]", "=", "0.", "\n", "optim_state", "[", "\"m\"", "]", "=", "[", "tf", ".", "zeros_like", "(", "v", ")", "for", "v", "in", "x", "]", "\n", "optim_state", "[", "\"u\"", "]", "=", "[", "tf", ".", "zeros_like", "(", "v", ")", "for", "v", "in", "x", "]", "\n", "return", "optim_state", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorAdam._apply_gradients": [[1584, 1606], ["six.moves.xrange", "len", "len", "len", "len", "tensorflow.pow", "tensorflow.pow", "tensorflow.sqrt"], "methods", ["None"], ["", "def", "_apply_gradients", "(", "self", ",", "grads", ",", "x", ",", "optim_state", ")", ":", "\n", "    ", "\"\"\"Refer to parent class documentation.\"\"\"", "\n", "new_x", "=", "[", "None", "]", "*", "len", "(", "x", ")", "\n", "new_optim_state", "=", "{", "\n", "\"t\"", ":", "optim_state", "[", "\"t\"", "]", "+", "1.", ",", "\n", "\"m\"", ":", "[", "None", "]", "*", "len", "(", "x", ")", ",", "\n", "\"u\"", ":", "[", "None", "]", "*", "len", "(", "x", ")", "\n", "}", "\n", "t", "=", "new_optim_state", "[", "\"t\"", "]", "\n", "for", "i", "in", "xrange", "(", "len", "(", "x", ")", ")", ":", "\n", "      ", "g", "=", "grads", "[", "i", "]", "\n", "m_old", "=", "optim_state", "[", "\"m\"", "]", "[", "i", "]", "\n", "u_old", "=", "optim_state", "[", "\"u\"", "]", "[", "i", "]", "\n", "new_optim_state", "[", "\"m\"", "]", "[", "i", "]", "=", "(", "\n", "self", ".", "_beta1", "*", "m_old", "+", "(", "1.", "-", "self", ".", "_beta1", ")", "*", "g", ")", "\n", "new_optim_state", "[", "\"u\"", "]", "[", "i", "]", "=", "(", "\n", "self", ".", "_beta2", "*", "u_old", "+", "(", "1.", "-", "self", ".", "_beta2", ")", "*", "g", "*", "g", ")", "\n", "m_hat", "=", "new_optim_state", "[", "\"m\"", "]", "[", "i", "]", "/", "(", "1.", "-", "tf", ".", "pow", "(", "self", ".", "_beta1", ",", "t", ")", ")", "\n", "u_hat", "=", "new_optim_state", "[", "\"u\"", "]", "[", "i", "]", "/", "(", "1.", "-", "tf", ".", "pow", "(", "self", ".", "_beta2", ",", "t", ")", ")", "\n", "new_x", "[", "i", "]", "=", "(", "\n", "x", "[", "i", "]", "-", "self", ".", "_lr", "*", "m_hat", "/", "(", "tf", ".", "sqrt", "(", "u_hat", ")", "+", "self", ".", "_epsilon", ")", ")", "\n", "", "return", "new_x", ",", "new_optim_state", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.UnrolledAdam.__init__": [[1609, 1613], ["warnings.warn", "attacks_tf.TensorAdam.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"UnrolledAdam has been renamed to TensorAdam.\"", "\n", "\" The old name may be removed on or after 2019-04-25.\"", ")", "\n", "super", "(", "UnrolledAdam", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.SPSAAdam.__init__": [[1622, 1634], ["attacks_tf.TensorAdam.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "\n", "lr", "=", "0.01", ",", "\n", "delta", "=", "0.01", ",", "\n", "num_samples", "=", "128", ",", "\n", "num_iters", "=", "1", ",", "\n", "compare_to_analytic_grad", "=", "False", ")", ":", "\n", "    ", "super", "(", "SPSAAdam", ",", "self", ")", ".", "__init__", "(", "lr", "=", "lr", ")", "\n", "assert", "num_samples", "%", "2", "==", "0", ",", "\"number of samples must be even\"", "\n", "self", ".", "_delta", "=", "delta", "\n", "self", ".", "_num_samples", "=", "num_samples", "//", "2", "# Since we mirror +/- delta later", "\n", "self", ".", "_num_iters", "=", "num_iters", "\n", "self", ".", "_compare_to_analytic_grad", "=", "compare_to_analytic_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.SPSAAdam._get_delta": [[1635, 1644], ["x.get_shape().as_list", "tensorflow.sign", "x.get_shape", "tensorflow.random_uniform"], "methods", ["None"], ["", "def", "_get_delta", "(", "self", ",", "x", ",", "delta", ")", ":", "\n", "    ", "x_shape", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "delta_x", "=", "delta", "*", "tf", ".", "sign", "(", "\n", "tf", ".", "random_uniform", "(", "\n", "[", "self", ".", "_num_samples", "]", "+", "x_shape", "[", "1", ":", "]", ",", "\n", "minval", "=", "-", "1.", ",", "\n", "maxval", "=", "1.", ",", "\n", "dtype", "=", "tf_dtype", ")", ")", "\n", "return", "delta_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.SPSAAdam._compute_gradients": [[1645, 1683], ["x[].get_shape().as_list", "x.get_shape().as_list", "tensorflow.while_loop", "cleverhans.compat.reduce_sum", "len", "tensorflow.reshape", "attacks_tf.SPSAAdam._get_delta", "tensorflow.concat", "tensorflow.reshape", "tensorflow.expand_dims", "grad_array.write", "all_grads.stack", "x[].get_shape", "x[].get_shape().as_list", "x.get_shape", "loss_fn", "cleverhans.compat.reduce_mean", "tensorflow.TensorArray", "x[].get_shape", "len"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.SPSAAdam._get_delta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "_compute_gradients", "(", "self", ",", "loss_fn", ",", "x", ",", "unused_optim_state", ")", ":", "\n", "    ", "\"\"\"Compute gradient estimates using SPSA.\"\"\"", "\n", "# Assumes `x` is a list, containing a [1, H, W, C] image", "\n", "# If static batch dimension is None, tf.reshape to batch size 1", "\n", "# so that static shape can be inferred", "\n", "assert", "len", "(", "x", ")", "==", "1", "\n", "static_x_shape", "=", "x", "[", "0", "]", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "if", "static_x_shape", "[", "0", "]", "is", "None", ":", "\n", "      ", "x", "[", "0", "]", "=", "tf", ".", "reshape", "(", "x", "[", "0", "]", ",", "[", "1", "]", "+", "static_x_shape", "[", "1", ":", "]", ")", "\n", "", "assert", "x", "[", "0", "]", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "==", "1", "\n", "x", "=", "x", "[", "0", "]", "\n", "x_shape", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "\n", "def", "body", "(", "i", ",", "grad_array", ")", ":", "\n", "      ", "delta", "=", "self", ".", "_delta", "\n", "delta_x", "=", "self", ".", "_get_delta", "(", "x", ",", "delta", ")", "\n", "delta_x", "=", "tf", ".", "concat", "(", "[", "delta_x", ",", "-", "delta_x", "]", ",", "axis", "=", "0", ")", "\n", "loss_vals", "=", "tf", ".", "reshape", "(", "\n", "loss_fn", "(", "x", "+", "delta_x", ")", ",", "\n", "[", "2", "*", "self", ".", "_num_samples", "]", "+", "[", "1", "]", "*", "(", "len", "(", "x_shape", ")", "-", "1", ")", ")", "\n", "avg_grad", "=", "reduce_mean", "(", "loss_vals", "*", "delta_x", ",", "axis", "=", "0", ")", "/", "delta", "\n", "avg_grad", "=", "tf", ".", "expand_dims", "(", "avg_grad", ",", "axis", "=", "0", ")", "\n", "new_grad_array", "=", "grad_array", ".", "write", "(", "i", ",", "avg_grad", ")", "\n", "return", "i", "+", "1", ",", "new_grad_array", "\n", "\n", "", "def", "cond", "(", "i", ",", "_", ")", ":", "\n", "      ", "return", "i", "<", "self", ".", "_num_iters", "\n", "\n", "", "_", ",", "all_grads", "=", "tf", ".", "while_loop", "(", "\n", "cond", ",", "\n", "body", ",", "\n", "loop_vars", "=", "[", "\n", "0", ",", "tf", ".", "TensorArray", "(", "size", "=", "self", ".", "_num_iters", ",", "dtype", "=", "tf_dtype", ")", "\n", "]", ",", "\n", "back_prop", "=", "False", ",", "\n", "parallel_iterations", "=", "1", ")", "\n", "avg_grad", "=", "reduce_sum", "(", "all_grads", ".", "stack", "(", ")", ",", "axis", "=", "0", ")", "\n", "return", "[", "avg_grad", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.ZERO": [[26, 28], ["numpy.asarray"], "function", ["None"], ["def", "ZERO", "(", ")", ":", "\n", "  ", "return", "np", ".", "asarray", "(", "0.", ",", "dtype", "=", "np_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.fgsm": [[30, 41], ["warnings.warn", "attacks_tf.fgm"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.fgm"], ["", "def", "fgsm", "(", "x", ",", "predictions", ",", "eps", "=", "0.3", ",", "clip_min", "=", "None", ",", "clip_max", "=", "None", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"This function is deprecated and will be removed on or after \"", "\n", "\"2019-04-09. Switch to cleverhans.attacks.FastGradientMethod.\"", ")", "\n", "return", "fgm", "(", "\n", "x", ",", "\n", "predictions", ",", "\n", "y", "=", "None", ",", "\n", "eps", "=", "eps", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.fgm": [[43, 52], ["warnings.warn", "logits_fgm", "TypeError"], "function", ["None"], ["", "def", "fgm", "(", "x", ",", "preds", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "if", "preds", ".", "op", ".", "type", "==", "'Softmax'", ":", "\n", "    ", "logits", ",", "=", "preds", ".", "op", ".", "inputs", "\n", "", "else", ":", "\n", "    ", "raise", "TypeError", "(", "\"Unclear how to get logits\"", ")", "\n", "", "warnings", ".", "warn", "(", "\"This function is deprecated. Switch to passing *logits* to\"", "\n", "\" cleverhans.attacks.fgm\"", ")", "\n", "from", "cleverhans", ".", "attacks", "import", "fgm", "as", "logits_fgm", "\n", "return", "logits_fgm", "(", "x", ",", "logits", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.vatm": [[54, 93], ["tensorflow.name_scope", "tensorflow.random_normal", "range", "tensorflow.shape", "model.get_logits", "cleverhans.utils_tf.kl_with_logits", "tensorflow.stop_gradient", "cleverhans.utils_tf.l2_batch_normalize", "tensorflow.clip_by_value", "cleverhans.utils_tf.l2_batch_normalize", "tensorflow.gradients"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.kl_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.l2_batch_normalize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.l2_batch_normalize"], ["", "def", "vatm", "(", "model", ",", "\n", "x", ",", "\n", "logits", ",", "\n", "eps", ",", "\n", "num_iterations", "=", "1", ",", "\n", "xi", "=", "1e-6", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "scope", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Tensorflow implementation of the perturbation method used for virtual\n  adversarial training: https://arxiv.org/abs/1507.00677\n  :param model: the model which returns the network unnormalized logits\n  :param x: the input placeholder\n  :param logits: the model's unnormalized output tensor (the input to\n                 the softmax layer)\n  :param eps: the epsilon (input variation parameter)\n  :param num_iterations: the number of iterations\n  :param xi: the finite difference parameter\n  :param clip_min: optional parameter that can be used to set a minimum\n                  value for components of the example returned\n  :param clip_max: optional parameter that can be used to set a maximum\n                  value for components of the example returned\n  :param seed: the seed for random generator\n  :return: a tensor for the adversarial example\n  \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "scope", ",", "\"virtual_adversarial_perturbation\"", ")", ":", "\n", "    ", "d", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "x", ")", ",", "dtype", "=", "tf_dtype", ")", "\n", "for", "_", "in", "range", "(", "num_iterations", ")", ":", "\n", "      ", "d", "=", "xi", "*", "utils_tf", ".", "l2_batch_normalize", "(", "d", ")", "\n", "logits_d", "=", "model", ".", "get_logits", "(", "x", "+", "d", ")", "\n", "kl", "=", "utils_tf", ".", "kl_with_logits", "(", "logits", ",", "logits_d", ")", "\n", "Hd", "=", "tf", ".", "gradients", "(", "kl", ",", "d", ")", "[", "0", "]", "\n", "d", "=", "tf", ".", "stop_gradient", "(", "Hd", ")", "\n", "", "d", "=", "eps", "*", "utils_tf", ".", "l2_batch_normalize", "(", "d", ")", "\n", "adv_x", "=", "x", "+", "d", "\n", "if", "(", "clip_min", "is", "not", "None", ")", "and", "(", "clip_max", "is", "not", "None", ")", ":", "\n", "      ", "adv_x", "=", "tf", ".", "clip_by_value", "(", "adv_x", ",", "clip_min", ",", "clip_max", ")", "\n", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.apply_perturbations": [[95, 118], ["numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum"], "function", ["None"], ["", "", "def", "apply_perturbations", "(", "i", ",", "j", ",", "X", ",", "increase", ",", "theta", ",", "clip_min", ",", "clip_max", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation for apply perturbations to input features based\n  on salency maps\n  :param i: index of first selected feature\n  :param j: index of second selected feature\n  :param X: a matrix containing our input features for our sample\n  :param increase: boolean; true if we are increasing pixels, false otherwise\n  :param theta: delta for each feature adjustment\n  :param clip_min: mininum value for a feature in our sample\n  :param clip_max: maximum value for a feature in our sample\n  : return: a perturbed input feature matrix for a target class\n  \"\"\"", "\n", "\n", "# perturb our input sample", "\n", "if", "increase", ":", "\n", "    ", "X", "[", "0", ",", "i", "]", "=", "np", ".", "minimum", "(", "clip_max", ",", "X", "[", "0", ",", "i", "]", "+", "theta", ")", "\n", "X", "[", "0", ",", "j", "]", "=", "np", ".", "minimum", "(", "clip_max", ",", "X", "[", "0", ",", "j", "]", "+", "theta", ")", "\n", "", "else", ":", "\n", "    ", "X", "[", "0", ",", "i", "]", "=", "np", ".", "maximum", "(", "clip_min", ",", "X", "[", "0", ",", "i", "]", "-", "theta", ")", "\n", "X", "[", "0", ",", "j", "]", "=", "np", ".", "maximum", "(", "clip_min", ",", "X", "[", "0", ",", "j", "]", "-", "theta", ")", "\n", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.saliency_map": [[120, 166], ["len", "list", "numpy.fill_diagonal", "numpy.argmax", "search_domain.discard", "search_domain.discard", "numpy.max", "numpy.max", "grads_target.reshape", "grads_target.reshape", "grads_other.reshape", "grads_other.reshape", "set", "int", "numpy.abs", "numpy.abs", "range"], "function", ["None"], ["", "def", "saliency_map", "(", "grads_target", ",", "grads_other", ",", "search_domain", ",", "increase", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation for computing saliency maps\n  :param grads_target: a matrix containing forward derivatives for the\n                       target class\n  :param grads_other: a matrix where every element is the sum of forward\n                      derivatives over all non-target classes at that index\n  :param search_domain: the set of input indices that we are considering\n  :param increase: boolean; true if we are increasing pixels, false otherwise\n  :return: (i, j, search_domain) the two input indices selected and the\n           updated search domain\n  \"\"\"", "\n", "# Compute the size of the input (the number of features)", "\n", "nf", "=", "len", "(", "grads_target", ")", "\n", "\n", "# Remove the already-used input features from the search space", "\n", "invalid", "=", "list", "(", "set", "(", "range", "(", "nf", ")", ")", "-", "search_domain", ")", "\n", "increase_coef", "=", "(", "2", "*", "int", "(", "increase", ")", "-", "1", ")", "\n", "grads_target", "[", "invalid", "]", "=", "-", "increase_coef", "*", "np", ".", "max", "(", "np", ".", "abs", "(", "grads_target", ")", ")", "\n", "grads_other", "[", "invalid", "]", "=", "increase_coef", "*", "np", ".", "max", "(", "np", ".", "abs", "(", "grads_other", ")", ")", "\n", "\n", "# Create a 2D numpy array of the sum of grads_target and grads_other", "\n", "target_sum", "=", "grads_target", ".", "reshape", "(", "(", "1", ",", "nf", ")", ")", "+", "grads_target", ".", "reshape", "(", "(", "nf", ",", "1", ")", ")", "\n", "other_sum", "=", "grads_other", ".", "reshape", "(", "(", "1", ",", "nf", ")", ")", "+", "grads_other", ".", "reshape", "(", "(", "nf", ",", "1", ")", ")", "\n", "\n", "# Create a mask to only keep features that match saliency map conditions", "\n", "if", "increase", ":", "\n", "    ", "scores_mask", "=", "(", "(", "target_sum", ">", "0", ")", "&", "(", "other_sum", "<", "0", ")", ")", "\n", "", "else", ":", "\n", "    ", "scores_mask", "=", "(", "(", "target_sum", "<", "0", ")", "&", "(", "other_sum", ">", "0", ")", ")", "\n", "\n", "# Create a 2D numpy array of the scores for each pair of candidate features", "\n", "", "scores", "=", "scores_mask", "*", "(", "-", "target_sum", "*", "other_sum", ")", "\n", "\n", "# A pixel can only be selected (and changed) once", "\n", "np", ".", "fill_diagonal", "(", "scores", ",", "0", ")", "\n", "\n", "# Extract the best two pixels", "\n", "best", "=", "np", ".", "argmax", "(", "scores", ")", "\n", "p1", ",", "p2", "=", "best", "%", "nf", ",", "best", "//", "nf", "\n", "\n", "# Remove used pixels from our search domain", "\n", "search_domain", ".", "discard", "(", "p1", ")", "\n", "search_domain", ".", "discard", "(", "p2", ")", "\n", "\n", "return", "p1", ",", "p2", ",", "search_domain", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jacobian": [[168, 197], ["numpy.zeros", "enumerate", "cleverhans.utils.other_classes", "numpy.sum", "feed_dict.update", "sess.run", "numpy.reshape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.other_classes"], ["", "def", "jacobian", "(", "sess", ",", "x", ",", "grads", ",", "target", ",", "X", ",", "nb_features", ",", "nb_classes", ",", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of the foward derivative / Jacobian\n  :param x: the input placeholder\n  :param grads: the list of TF gradients returned by jacobian_graph()\n  :param target: the target misclassification class\n  :param X: numpy array with sample input\n  :param nb_features: the number of features in the input\n  :return: matrix of forward derivatives flattened into vectors\n  \"\"\"", "\n", "# Prepare feeding dictionary for all gradient computations", "\n", "feed_dict", "=", "{", "x", ":", "X", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "    ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "\n", "# Initialize a numpy array to hold the Jacobian component values", "\n", "", "jacobian_val", "=", "np", ".", "zeros", "(", "(", "nb_classes", ",", "nb_features", ")", ",", "dtype", "=", "np_dtype", ")", "\n", "\n", "# Compute the gradients for all classes", "\n", "for", "class_ind", ",", "grad", "in", "enumerate", "(", "grads", ")", ":", "\n", "    ", "run_grad", "=", "sess", ".", "run", "(", "grad", ",", "feed_dict", ")", "\n", "jacobian_val", "[", "class_ind", "]", "=", "np", ".", "reshape", "(", "run_grad", ",", "(", "1", ",", "nb_features", ")", ")", "\n", "\n", "# Sum over all classes different from the target class to prepare for", "\n", "# saliency map computation in the next step of the attack", "\n", "", "other_classes", "=", "utils", ".", "other_classes", "(", "nb_classes", ",", "target", ")", "\n", "grad_others", "=", "np", ".", "sum", "(", "jacobian_val", "[", "other_classes", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "\n", "return", "jacobian_val", "[", "target", "]", ",", "grad_others", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jacobian_graph": [[199, 217], ["six.moves.xrange", "tensorflow.gradients", "list_derivatives.append"], "function", ["None"], ["", "def", "jacobian_graph", "(", "predictions", ",", "x", ",", "nb_classes", ")", ":", "\n", "  ", "\"\"\"\n  Create the Jacobian graph to be ran later in a TF session\n  :param predictions: the model's symbolic output (linear output,\n      pre-softmax)\n  :param x: the input placeholder\n  :param nb_classes: the number of classes the model has\n  :return:\n  \"\"\"", "\n", "# This function will return a list of TF gradients", "\n", "list_derivatives", "=", "[", "]", "\n", "\n", "# Define the TF graph elements to compute our derivatives for each class", "\n", "for", "class_ind", "in", "xrange", "(", "nb_classes", ")", ":", "\n", "    ", "derivatives", ",", "=", "tf", ".", "gradients", "(", "predictions", "[", ":", ",", "class_ind", "]", ",", "x", ")", "\n", "list_derivatives", ".", "append", "(", "derivatives", ")", "\n", "\n", "", "return", "list_derivatives", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jsma": [[219, 331], ["copy.copy", "numpy.product", "numpy.reshape", "numpy.floor", "len", "bool", "numpy.reshape", "cleverhans.utils_tf.model_argmax", "_logger.debug", "numpy.reshape", "attacks_tf.jacobian", "attacks_tf.saliency_map", "attacks_tf.apply_perturbations", "cleverhans.utils_tf.model_argmax", "_logger.info", "_logger.info", "float", "len", "_logger.debug", "numpy.reshape", "numpy.reshape", "six.moves.xrange", "six.moves.xrange", "int"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jacobian", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.saliency_map", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.apply_perturbations", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax"], ["", "def", "jsma", "(", "sess", ",", "\n", "x", ",", "\n", "predictions", ",", "\n", "grads", ",", "\n", "sample", ",", "\n", "target", ",", "\n", "theta", ",", "\n", "gamma", ",", "\n", "clip_min", ",", "\n", "clip_max", ",", "\n", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of the JSMA (see https://arxiv.org/abs/1511.07528\n  for details about the algorithm design choices).\n  :param sess: TF session\n  :param x: the input placeholder\n  :param predictions: the model's symbolic output (the attack expects the\n                probabilities, i.e., the output of the softmax, but will\n                also work with logits typically)\n  :param grads: symbolic gradients\n  :param sample: numpy array with sample input\n  :param target: target class for sample input\n  :param theta: delta for each feature adjustment\n  :param gamma: a float between 0 - 1 indicating the maximum distortion\n      percentage\n  :param clip_min: minimum value for components of the example returned\n  :param clip_max: maximum value for components of the example returned\n  :return: an adversarial sample\n  \"\"\"", "\n", "\n", "# Copy the source sample and define the maximum number of features", "\n", "# (i.e. the maximum number of iterations) that we may perturb", "\n", "adv_x", "=", "copy", ".", "copy", "(", "sample", ")", "\n", "# count the number of features. For MNIST, 1x28x28 = 784; for", "\n", "# CIFAR, 3x32x32 = 3072; etc.", "\n", "nb_features", "=", "np", ".", "product", "(", "adv_x", ".", "shape", "[", "1", ":", "]", ")", "\n", "# reshape sample for sake of standardization", "\n", "original_shape", "=", "adv_x", ".", "shape", "\n", "adv_x", "=", "np", ".", "reshape", "(", "adv_x", ",", "(", "1", ",", "nb_features", ")", ")", "\n", "# compute maximum number of iterations", "\n", "max_iters", "=", "np", ".", "floor", "(", "nb_features", "*", "gamma", "/", "2", ")", "\n", "\n", "# Find number of classes based on grads", "\n", "nb_classes", "=", "len", "(", "grads", ")", "\n", "\n", "increase", "=", "bool", "(", "theta", ">", "0", ")", "\n", "\n", "# Compute our initial search domain. We optimize the initial search domain", "\n", "# by removing all features that are already at their maximum values (if", "\n", "# increasing input features---otherwise, at their minimum value).", "\n", "if", "increase", ":", "\n", "    ", "search_domain", "=", "{", "i", "for", "i", "in", "xrange", "(", "nb_features", ")", "if", "adv_x", "[", "0", ",", "i", "]", "<", "clip_max", "}", "\n", "", "else", ":", "\n", "    ", "search_domain", "=", "{", "i", "for", "i", "in", "xrange", "(", "nb_features", ")", "if", "adv_x", "[", "0", ",", "i", "]", ">", "clip_min", "}", "\n", "\n", "# Initialize the loop variables", "\n", "", "iteration", "=", "0", "\n", "adv_x_original_shape", "=", "np", ".", "reshape", "(", "adv_x", ",", "original_shape", ")", "\n", "current", "=", "utils_tf", ".", "model_argmax", "(", "\n", "sess", ",", "x", ",", "predictions", ",", "adv_x_original_shape", ",", "feed", "=", "feed", ")", "\n", "\n", "_logger", ".", "debug", "(", "\"Starting JSMA attack up to %s iterations\"", ",", "max_iters", ")", "\n", "# Repeat this main loop until we have achieved misclassification", "\n", "while", "(", "current", "!=", "target", "and", "iteration", "<", "max_iters", "\n", "and", "len", "(", "search_domain", ")", ">", "1", ")", ":", "\n", "# Reshape the adversarial example", "\n", "    ", "adv_x_original_shape", "=", "np", ".", "reshape", "(", "adv_x", ",", "original_shape", ")", "\n", "\n", "# Compute the Jacobian components", "\n", "grads_target", ",", "grads_others", "=", "jacobian", "(", "\n", "sess", ",", "\n", "x", ",", "\n", "grads", ",", "\n", "target", ",", "\n", "adv_x_original_shape", ",", "\n", "nb_features", ",", "\n", "nb_classes", ",", "\n", "feed", "=", "feed", ")", "\n", "\n", "if", "iteration", "%", "(", "(", "max_iters", "+", "1", ")", "//", "5", ")", "==", "0", "and", "iteration", ">", "0", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"Iteration %s of %s\"", ",", "iteration", ",", "int", "(", "max_iters", ")", ")", "\n", "# Compute the saliency map for each of our target classes", "\n", "# and return the two best candidate features for perturbation", "\n", "", "i", ",", "j", ",", "search_domain", "=", "saliency_map", "(", "grads_target", ",", "grads_others", ",", "\n", "search_domain", ",", "increase", ")", "\n", "\n", "# Apply the perturbation to the two input features selected previously", "\n", "adv_x", "=", "apply_perturbations", "(", "i", ",", "j", ",", "adv_x", ",", "increase", ",", "theta", ",", "clip_min", ",", "\n", "clip_max", ")", "\n", "\n", "# Update our current prediction by querying the model", "\n", "current", "=", "utils_tf", ".", "model_argmax", "(", "\n", "sess", ",", "x", ",", "predictions", ",", "adv_x_original_shape", ",", "feed", "=", "feed", ")", "\n", "\n", "# Update loop variables", "\n", "iteration", "=", "iteration", "+", "1", "\n", "\n", "", "if", "current", "==", "target", ":", "\n", "    ", "_logger", ".", "info", "(", "\"Attack succeeded using %s iterations\"", ",", "iteration", ")", "\n", "", "else", ":", "\n", "    ", "_logger", ".", "info", "(", "\"Failed to find adversarial example after %s iterations\"", ",", "\n", "iteration", ")", "\n", "\n", "# Compute the ratio of pixels perturbed by the algorithm", "\n", "", "percent_perturbed", "=", "float", "(", "iteration", "*", "2", ")", "/", "nb_features", "\n", "\n", "# Report success when the adversarial example is misclassified in the", "\n", "# target class", "\n", "if", "current", "==", "target", ":", "\n", "    ", "return", "np", ".", "reshape", "(", "adv_x", ",", "original_shape", ")", ",", "1", ",", "percent_perturbed", "\n", "", "else", ":", "\n", "    ", "return", "np", ".", "reshape", "(", "adv_x", ",", "original_shape", ")", ",", "0", ",", "percent_perturbed", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jsma_symbolic": [[333, 482], ["int", "int", "numpy.floor", "bool", "numpy.ones", "numpy.fill_diagonal", "tensorflow.constant", "tensorflow.while_loop", "tensorflow.cast", "warnings.warn", "tensorflow.cast", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.logical_and", "model.get_probs", "tensorflow.one_hot", "six.moves.xrange", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.cast", "cleverhans.compat.reduce_sum", "cleverhans.compat.reduce_sum", "tensorflow.argmax", "tensorflow.mod", "tensorflow.floordiv", "tensorflow.one_hot", "tensorflow.one_hot", "tensorflow.equal", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.add", "cleverhans.compat.reduce_any", "numpy.product", "tensorflow.cast", "tensorflow.cast", "tensorflow.less", "tensorflow.argmax", "tensorflow.gradients", "list_derivatives.append", "tensorflow.stack", "tensorflow.transpose", "tensorflow.not_equal", "tensorflow.cast", "cleverhans.compat.reduce_max", "tensorflow.reshape", "tensorflow.reshape", "cleverhans.compat.reduce_max", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "cleverhans.compat.reduce_sum", "tensorflow.cast", "tensorflow.minimum", "tensorflow.maximum", "tensorflow.equal", "tensorflow.abs", "tensorflow.abs", "tensorflow.cast", "cleverhans.compat.reduce_sum", "int", "x_in.shape[].as_list"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_any", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "", "def", "jsma_symbolic", "(", "x", ",", "y_target", ",", "model", ",", "theta", ",", "gamma", ",", "clip_min", ",", "clip_max", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of the JSMA (see https://arxiv.org/abs/1511.07528\n  for details about the algorithm design choices).\n\n  :param x: the input placeholder\n  :param y_target: the target tensor\n  :param model: a cleverhans.model.Model object.\n  :param theta: delta for each feature adjustment\n  :param gamma: a float between 0 - 1 indicating the maximum distortion\n      percentage\n  :param clip_min: minimum value for components of the example returned\n  :param clip_max: maximum value for components of the example returned\n  :return: a tensor for the adversarial example\n  \"\"\"", "\n", "\n", "nb_classes", "=", "int", "(", "y_target", ".", "shape", "[", "-", "1", "]", ".", "value", ")", "\n", "nb_features", "=", "int", "(", "np", ".", "product", "(", "x", ".", "shape", "[", "1", ":", "]", ")", ".", "value", ")", "\n", "\n", "if", "x", ".", "dtype", "==", "tf", ".", "float32", "and", "y_target", ".", "dtype", "==", "tf", ".", "int64", ":", "\n", "    ", "y_target", "=", "tf", ".", "cast", "(", "y_target", ",", "tf", ".", "int32", ")", "\n", "\n", "", "if", "x", ".", "dtype", "==", "tf", ".", "float32", "and", "y_target", ".", "dtype", "==", "tf", ".", "float64", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"Downcasting labels---this should be harmless unless\"", "\n", "\" they are smoothed\"", ")", "\n", "y_target", "=", "tf", ".", "cast", "(", "y_target", ",", "tf", ".", "float32", ")", "\n", "\n", "", "max_iters", "=", "np", ".", "floor", "(", "nb_features", "*", "gamma", "/", "2", ")", "\n", "increase", "=", "bool", "(", "theta", ">", "0", ")", "\n", "\n", "tmp", "=", "np", ".", "ones", "(", "(", "nb_features", ",", "nb_features", ")", ",", "int", ")", "\n", "np", ".", "fill_diagonal", "(", "tmp", ",", "0", ")", "\n", "zero_diagonal", "=", "tf", ".", "constant", "(", "tmp", ",", "tf_dtype", ")", "\n", "\n", "# Compute our initial search domain. We optimize the initial search domain", "\n", "# by removing all features that are already at their maximum values (if", "\n", "# increasing input features---otherwise, at their minimum value).", "\n", "if", "increase", ":", "\n", "    ", "search_domain", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "cast", "(", "x", "<", "clip_max", ",", "tf_dtype", ")", ",", "[", "-", "1", ",", "nb_features", "]", ")", "\n", "", "else", ":", "\n", "    ", "search_domain", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "cast", "(", "x", ">", "clip_min", ",", "tf_dtype", ")", ",", "[", "-", "1", ",", "nb_features", "]", ")", "\n", "\n", "# Loop variables", "\n", "# x_in: the tensor that holds the latest adversarial outputs that are in", "\n", "#       progress.", "\n", "# y_in: the tensor for target labels", "\n", "# domain_in: the tensor that holds the latest search domain", "\n", "# cond_in: the boolean tensor to show if more iteration is needed for", "\n", "#          generating adversarial samples", "\n", "", "def", "condition", "(", "x_in", ",", "y_in", ",", "domain_in", ",", "i_in", ",", "cond_in", ")", ":", "\n", "# Repeat the loop until we have achieved misclassification or", "\n", "# reaches the maximum iterations", "\n", "    ", "return", "tf", ".", "logical_and", "(", "tf", ".", "less", "(", "i_in", ",", "max_iters", ")", ",", "cond_in", ")", "\n", "\n", "# Same loop variables as above", "\n", "", "def", "body", "(", "x_in", ",", "y_in", ",", "domain_in", ",", "i_in", ",", "cond_in", ")", ":", "\n", "\n", "    ", "preds", "=", "model", ".", "get_probs", "(", "x_in", ")", "\n", "preds_onehot", "=", "tf", ".", "one_hot", "(", "tf", ".", "argmax", "(", "preds", ",", "axis", "=", "1", ")", ",", "depth", "=", "nb_classes", ")", "\n", "\n", "# create the Jacobian graph", "\n", "list_derivatives", "=", "[", "]", "\n", "for", "class_ind", "in", "xrange", "(", "nb_classes", ")", ":", "\n", "      ", "derivatives", "=", "tf", ".", "gradients", "(", "preds", "[", ":", ",", "class_ind", "]", ",", "x_in", ")", "\n", "list_derivatives", ".", "append", "(", "derivatives", "[", "0", "]", ")", "\n", "", "grads", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "stack", "(", "list_derivatives", ")", ",", "shape", "=", "[", "nb_classes", ",", "-", "1", ",", "nb_features", "]", ")", "\n", "\n", "# Compute the Jacobian components", "\n", "# To help with the computation later, reshape the target_class", "\n", "# and other_class to [nb_classes, -1, 1].", "\n", "# The last dimention is added to allow broadcasting later.", "\n", "target_class", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "transpose", "(", "y_in", ",", "perm", "=", "[", "1", ",", "0", "]", ")", ",", "shape", "=", "[", "nb_classes", ",", "-", "1", ",", "1", "]", ")", "\n", "other_classes", "=", "tf", ".", "cast", "(", "tf", ".", "not_equal", "(", "target_class", ",", "1", ")", ",", "tf_dtype", ")", "\n", "\n", "grads_target", "=", "reduce_sum", "(", "grads", "*", "target_class", ",", "axis", "=", "0", ")", "\n", "grads_other", "=", "reduce_sum", "(", "grads", "*", "other_classes", ",", "axis", "=", "0", ")", "\n", "\n", "# Remove the already-used input features from the search space", "\n", "# Subtract 2 times the maximum value from those value so that", "\n", "# they won't be picked later", "\n", "increase_coef", "=", "(", "4", "*", "int", "(", "increase", ")", "-", "2", ")", "*", "tf", ".", "cast", "(", "tf", ".", "equal", "(", "domain_in", ",", "0", ")", ",", "tf_dtype", ")", "\n", "\n", "target_tmp", "=", "grads_target", "\n", "target_tmp", "-=", "increase_coef", "*", "reduce_max", "(", "tf", ".", "abs", "(", "grads_target", ")", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "target_sum", "=", "tf", ".", "reshape", "(", "target_tmp", ",", "shape", "=", "[", "-", "1", ",", "nb_features", ",", "1", "]", ")", "+", "tf", ".", "reshape", "(", "target_tmp", ",", "shape", "=", "[", "-", "1", ",", "1", ",", "nb_features", "]", ")", "\n", "\n", "other_tmp", "=", "grads_other", "\n", "other_tmp", "+=", "increase_coef", "*", "reduce_max", "(", "tf", ".", "abs", "(", "grads_other", ")", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "other_sum", "=", "tf", ".", "reshape", "(", "other_tmp", ",", "shape", "=", "[", "-", "1", ",", "nb_features", ",", "1", "]", ")", "+", "tf", ".", "reshape", "(", "other_tmp", ",", "shape", "=", "[", "-", "1", ",", "1", ",", "nb_features", "]", ")", "\n", "\n", "# Create a mask to only keep features that match conditions", "\n", "if", "increase", ":", "\n", "      ", "scores_mask", "=", "(", "(", "target_sum", ">", "0", ")", "&", "(", "other_sum", "<", "0", ")", ")", "\n", "", "else", ":", "\n", "      ", "scores_mask", "=", "(", "(", "target_sum", "<", "0", ")", "&", "(", "other_sum", ">", "0", ")", ")", "\n", "\n", "# Create a 2D numpy array of scores for each pair of candidate features", "\n", "", "scores", "=", "tf", ".", "cast", "(", "scores_mask", ",", "tf_dtype", ")", "*", "(", "-", "target_sum", "*", "other_sum", ")", "*", "zero_diagonal", "\n", "\n", "# Extract the best two pixels", "\n", "best", "=", "tf", ".", "argmax", "(", "\n", "tf", ".", "reshape", "(", "scores", ",", "shape", "=", "[", "-", "1", ",", "nb_features", "*", "nb_features", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "p1", "=", "tf", ".", "mod", "(", "best", ",", "nb_features", ")", "\n", "p2", "=", "tf", ".", "floordiv", "(", "best", ",", "nb_features", ")", "\n", "p1_one_hot", "=", "tf", ".", "one_hot", "(", "p1", ",", "depth", "=", "nb_features", ")", "\n", "p2_one_hot", "=", "tf", ".", "one_hot", "(", "p2", ",", "depth", "=", "nb_features", ")", "\n", "\n", "# Check if more modification is needed for each sample", "\n", "mod_not_done", "=", "tf", ".", "equal", "(", "reduce_sum", "(", "y_in", "*", "preds_onehot", ",", "axis", "=", "1", ")", ",", "0", ")", "\n", "cond", "=", "mod_not_done", "&", "(", "reduce_sum", "(", "domain_in", ",", "axis", "=", "1", ")", ">=", "2", ")", "\n", "\n", "# Update the search domain", "\n", "cond_float", "=", "tf", ".", "reshape", "(", "tf", ".", "cast", "(", "cond", ",", "tf_dtype", ")", ",", "shape", "=", "[", "-", "1", ",", "1", "]", ")", "\n", "to_mod", "=", "(", "p1_one_hot", "+", "p2_one_hot", ")", "*", "cond_float", "\n", "\n", "domain_out", "=", "domain_in", "-", "to_mod", "\n", "\n", "# Apply the modification to the images", "\n", "to_mod_reshape", "=", "tf", ".", "reshape", "(", "\n", "to_mod", ",", "shape", "=", "(", "[", "-", "1", "]", "+", "x_in", ".", "shape", "[", "1", ":", "]", ".", "as_list", "(", ")", ")", ")", "\n", "if", "increase", ":", "\n", "      ", "x_out", "=", "tf", ".", "minimum", "(", "clip_max", ",", "x_in", "+", "to_mod_reshape", "*", "theta", ")", "\n", "", "else", ":", "\n", "      ", "x_out", "=", "tf", ".", "maximum", "(", "clip_min", ",", "x_in", "-", "to_mod_reshape", "*", "theta", ")", "\n", "\n", "# Increase the iterator, and check if all misclassifications are done", "\n", "", "i_out", "=", "tf", ".", "add", "(", "i_in", ",", "1", ")", "\n", "cond_out", "=", "reduce_any", "(", "cond", ")", "\n", "\n", "return", "x_out", ",", "y_in", ",", "domain_out", ",", "i_out", ",", "cond_out", "\n", "\n", "# Run loop to do JSMA", "\n", "", "x_adv", ",", "_", ",", "_", ",", "_", ",", "_", "=", "tf", ".", "while_loop", "(", "\n", "condition", ",", "\n", "body", ",", "[", "x", ",", "y_target", ",", "search_domain", ",", "0", ",", "True", "]", ",", "\n", "parallel_iterations", "=", "1", ")", "\n", "\n", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jacobian_augmentation": [[484, 540], ["min", "list", "numpy.vstack", "range", "len", "len", "len", "len", "len", "x.get_shape", "zip", "x.get_shape", "numpy.shape", "numpy.max", "feed_dict.update", "sess.run", "range", "range", "tensorflow.sign"], "function", ["None"], ["", "def", "jacobian_augmentation", "(", "sess", ",", "\n", "x", ",", "\n", "X_sub_prev", ",", "\n", "Y_sub", ",", "\n", "grads", ",", "\n", "lmbda", ",", "\n", "aug_batch_size", "=", "512", ",", "\n", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Augment an adversary's substitute training set using the Jacobian\n  of a substitute model to generate new synthetic inputs.\n  See https://arxiv.org/abs/1602.02697 for more details.\n  See cleverhans_tutorials/mnist_blackbox.py for example use case\n  :param sess: TF session in which the substitute model is defined\n  :param x: input TF placeholder for the substitute model\n  :param X_sub_prev: substitute training data available to the adversary\n                     at the previous iteration\n  :param Y_sub: substitute training labels available to the adversary\n                at the previous iteration\n  :param grads: Jacobian symbolic graph for the substitute\n                (should be generated using attacks_tf.jacobian_graph)\n  :return: augmented substitute data (will need to be labeled by oracle)\n  \"\"\"", "\n", "assert", "len", "(", "x", ".", "get_shape", "(", ")", ")", "==", "len", "(", "np", ".", "shape", "(", "X_sub_prev", ")", ")", "\n", "assert", "len", "(", "grads", ")", ">=", "np", ".", "max", "(", "Y_sub", ")", "+", "1", "\n", "assert", "len", "(", "X_sub_prev", ")", "==", "len", "(", "Y_sub", ")", "\n", "\n", "aug_batch_size", "=", "min", "(", "aug_batch_size", ",", "X_sub_prev", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# Prepare input_shape (outside loop) for feeding dictionary below", "\n", "input_shape", "=", "list", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "input_shape", "[", "0", "]", "=", "1", "\n", "\n", "# Create new numpy array for adversary training data", "\n", "# with twice as many components on the first dimension.", "\n", "X_sub", "=", "np", ".", "vstack", "(", "[", "X_sub_prev", ",", "X_sub_prev", "]", ")", "\n", "num_samples", "=", "X_sub_prev", ".", "shape", "[", "0", "]", "\n", "\n", "# Creating and processing as batch", "\n", "for", "p_idxs", "in", "range", "(", "0", ",", "num_samples", ",", "aug_batch_size", ")", ":", "\n", "    ", "X_batch", "=", "X_sub_prev", "[", "p_idxs", ":", "p_idxs", "+", "aug_batch_size", ",", "...", "]", "\n", "feed_dict", "=", "{", "x", ":", "X_batch", "}", "\n", "if", "feed", "is", "not", "None", ":", "\n", "      ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "\n", "# Compute sign matrix", "\n", "", "grad_val", "=", "sess", ".", "run", "(", "[", "tf", ".", "sign", "(", "grads", ")", "]", ",", "feed_dict", "=", "feed_dict", ")", "[", "0", "]", "\n", "\n", "# Create new synthetic point in adversary substitute training set", "\n", "for", "(", "indx", ",", "ind", ")", "in", "zip", "(", "range", "(", "p_idxs", ",", "p_idxs", "+", "X_batch", ".", "shape", "[", "0", "]", ")", ",", "\n", "range", "(", "X_batch", ".", "shape", "[", "0", "]", ")", ")", ":", "\n", "      ", "X_sub", "[", "num_samples", "+", "indx", "]", "=", "(", "\n", "X_batch", "[", "ind", "]", "+", "lmbda", "*", "grad_val", "[", "Y_sub", "[", "indx", "]", ",", "ind", ",", "...", "]", ")", "\n", "\n", "# Return augmented training data (needs to be labeled afterwards)", "\n", "", "", "return", "X_sub", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.deepfool_batch": [[1174, 1225], ["attacks_tf.deepfool_attack", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.deepfool_attack"], ["", "", "def", "deepfool_batch", "(", "sess", ",", "\n", "x", ",", "\n", "pred", ",", "\n", "logits", ",", "\n", "grads", ",", "\n", "X", ",", "\n", "nb_candidate", ",", "\n", "overshoot", ",", "\n", "max_iter", ",", "\n", "clip_min", ",", "\n", "clip_max", ",", "\n", "nb_classes", ",", "\n", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Applies DeepFool to a batch of inputs\n  :param sess: TF session\n  :param x: The input placeholder\n  :param pred: The model's sorted symbolic output of logits, only the top\n               nb_candidate classes are contained\n  :param logits: The model's unnormalized output tensor (the input to\n                 the softmax layer)\n  :param grads: Symbolic gradients of the top nb_candidate classes, procuded\n                from gradient_graph\n  :param X: Numpy array with sample inputs\n  :param nb_candidate: The number of classes to test against, i.e.,\n                       deepfool only consider nb_candidate classes when\n                       attacking(thus accelerate speed). The nb_candidate\n                       classes are chosen according to the prediction\n                       confidence during implementation.\n  :param overshoot: A termination criterion to prevent vanishing updates\n  :param max_iter: Maximum number of iteration for DeepFool\n  :param clip_min: Minimum value for components of the example returned\n  :param clip_max: Maximum value for components of the example returned\n  :param nb_classes: Number of model output classes\n  :return: Adversarial examples\n  \"\"\"", "\n", "X_adv", "=", "deepfool_attack", "(", "\n", "sess", ",", "\n", "x", ",", "\n", "pred", ",", "\n", "logits", ",", "\n", "grads", ",", "\n", "X", ",", "\n", "nb_candidate", ",", "\n", "overshoot", ",", "\n", "max_iter", ",", "\n", "clip_min", ",", "\n", "clip_max", ",", "\n", "feed", "=", "feed", ")", "\n", "\n", "return", "np", ".", "asarray", "(", "X_adv", ",", "dtype", "=", "np_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.deepfool_attack": [[1227, 1312], ["copy.copy", "cleverhans.utils_tf.model_argmax", "numpy.squeeze", "numpy.zeros", "_logger.debug", "_logger.info", "_logger.info", "numpy.clip", "numpy.array", "numpy.zeros", "numpy.any", "sess.run", "sess.run", "range", "numpy.clip", "cleverhans.utils_tf.model_argmax", "sum", "_logger.info", "range", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "abs", "w_k.flatten"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax"], ["", "def", "deepfool_attack", "(", "sess", ",", "\n", "x", ",", "\n", "predictions", ",", "\n", "logits", ",", "\n", "grads", ",", "\n", "sample", ",", "\n", "nb_candidate", ",", "\n", "overshoot", ",", "\n", "max_iter", ",", "\n", "clip_min", ",", "\n", "clip_max", ",", "\n", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of DeepFool.\n  Paper link: see https://arxiv.org/pdf/1511.04599.pdf\n  :param sess: TF session\n  :param x: The input placeholder\n  :param predictions: The model's sorted symbolic output of logits, only the\n                     top nb_candidate classes are contained\n  :param logits: The model's unnormalized output tensor (the input to\n                 the softmax layer)\n  :param grads: Symbolic gradients of the top nb_candidate classes, procuded\n               from gradient_graph\n  :param sample: Numpy array with sample input\n  :param nb_candidate: The number of classes to test against, i.e.,\n                       deepfool only consider nb_candidate classes when\n                       attacking(thus accelerate speed). The nb_candidate\n                       classes are chosen according to the prediction\n                       confidence during implementation.\n  :param overshoot: A termination criterion to prevent vanishing updates\n  :param max_iter: Maximum number of iteration for DeepFool\n  :param clip_min: Minimum value for components of the example returned\n  :param clip_max: Maximum value for components of the example returned\n  :return: Adversarial examples\n  \"\"\"", "\n", "adv_x", "=", "copy", ".", "copy", "(", "sample", ")", "\n", "# Initialize the loop variables", "\n", "iteration", "=", "0", "\n", "current", "=", "utils_tf", ".", "model_argmax", "(", "sess", ",", "x", ",", "logits", ",", "adv_x", ",", "feed", "=", "feed", ")", "\n", "if", "current", ".", "shape", "==", "(", ")", ":", "\n", "    ", "current", "=", "np", ".", "array", "(", "[", "current", "]", ")", "\n", "", "w", "=", "np", ".", "squeeze", "(", "np", ".", "zeros", "(", "sample", ".", "shape", "[", "1", ":", "]", ")", ")", "# same shape as original image", "\n", "r_tot", "=", "np", ".", "zeros", "(", "sample", ".", "shape", ")", "\n", "original", "=", "current", "# use original label as the reference", "\n", "\n", "_logger", ".", "debug", "(", "\n", "\"Starting DeepFool attack up to %s iterations\"", ",", "max_iter", ")", "\n", "# Repeat this main loop until we have achieved misclassification", "\n", "while", "(", "np", ".", "any", "(", "current", "==", "original", ")", "and", "iteration", "<", "max_iter", ")", ":", "\n", "\n", "    ", "if", "iteration", "%", "5", "==", "0", "and", "iteration", ">", "0", ":", "\n", "      ", "_logger", ".", "info", "(", "\"Attack result at iteration %s is %s\"", ",", "iteration", ",", "current", ")", "\n", "", "gradients", "=", "sess", ".", "run", "(", "grads", ",", "feed_dict", "=", "{", "x", ":", "adv_x", "}", ")", "\n", "predictions_val", "=", "sess", ".", "run", "(", "predictions", ",", "feed_dict", "=", "{", "x", ":", "adv_x", "}", ")", "\n", "for", "idx", "in", "range", "(", "sample", ".", "shape", "[", "0", "]", ")", ":", "\n", "      ", "pert", "=", "np", ".", "inf", "\n", "if", "current", "[", "idx", "]", "!=", "original", "[", "idx", "]", ":", "\n", "        ", "continue", "\n", "", "for", "k", "in", "range", "(", "1", ",", "nb_candidate", ")", ":", "\n", "        ", "w_k", "=", "gradients", "[", "idx", ",", "k", ",", "...", "]", "-", "gradients", "[", "idx", ",", "0", ",", "...", "]", "\n", "f_k", "=", "predictions_val", "[", "idx", ",", "k", "]", "-", "predictions_val", "[", "idx", ",", "0", "]", "\n", "# adding value 0.00001 to prevent f_k = 0", "\n", "pert_k", "=", "(", "abs", "(", "f_k", ")", "+", "0.00001", ")", "/", "np", ".", "linalg", ".", "norm", "(", "w_k", ".", "flatten", "(", ")", ")", "\n", "if", "pert_k", "<", "pert", ":", "\n", "          ", "pert", "=", "pert_k", "\n", "w", "=", "w_k", "\n", "", "", "r_i", "=", "pert", "*", "w", "/", "np", ".", "linalg", ".", "norm", "(", "w", ")", "\n", "r_tot", "[", "idx", ",", "...", "]", "=", "r_tot", "[", "idx", ",", "...", "]", "+", "r_i", "\n", "\n", "", "adv_x", "=", "np", ".", "clip", "(", "r_tot", "+", "sample", ",", "clip_min", ",", "clip_max", ")", "\n", "current", "=", "utils_tf", ".", "model_argmax", "(", "sess", ",", "x", ",", "logits", ",", "adv_x", ",", "feed", "=", "feed", ")", "\n", "if", "current", ".", "shape", "==", "(", ")", ":", "\n", "      ", "current", "=", "np", ".", "array", "(", "[", "current", "]", ")", "\n", "# Update loop variables", "\n", "", "iteration", "=", "iteration", "+", "1", "\n", "\n", "# need more revision, including info like how many succeed", "\n", "", "_logger", ".", "info", "(", "\"Attack result at iteration %s is %s\"", ",", "iteration", ",", "current", ")", "\n", "_logger", ".", "info", "(", "\"%s out of %s become adversarial examples at iteration %s\"", ",", "\n", "sum", "(", "current", "!=", "original", ")", ",", "\n", "sample", ".", "shape", "[", "0", "]", ",", "\n", "iteration", ")", "\n", "# need to clip this image into the given range", "\n", "adv_x", "=", "np", ".", "clip", "(", "(", "1", "+", "overshoot", ")", "*", "r_tot", "+", "sample", ",", "clip_min", ",", "clip_max", ")", "\n", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.pgd_attack": [[1687, 1694], ["warnings.warn", "projected_optimization"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.projected_optimization"], ["", "", "def", "pgd_attack", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"cleverhans.attacks_tf.pgd_attack has been renamed to \"", "\n", "\"cleverhans.attacks.projected_optimization. \"", "\n", "\"Please switch to the new name. The current name will \"", "\n", "\"become unsupport on or after 2019-04-24.\"", ")", "\n", "from", "cleverhans", ".", "attacks", "import", "projected_optimization", "\n", "return", "projected_optimization", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.margin_logit_loss": [[1697, 1727], ["cleverhans.compat.reduce_max", "warnings.warn", "str", "tensorflow.one_hot", "str", "tensorflow.to_float", "cleverhans.compat.reduce_sum", "TypeError", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "def", "margin_logit_loss", "(", "model_logits", ",", "label", ",", "nb_classes", "=", "10", ",", "num_classes", "=", "None", ")", ":", "\n", "  ", "\"\"\"Computes difference between logit for `label` and next highest logit.\n\n  The loss is high when `label` is unlikely (targeted by default).\n  This follows the same interface as `loss_fn` for TensorOptimizer and\n  projected_optimization, i.e. it returns a batch of loss values.\n  \"\"\"", "\n", "if", "num_classes", "is", "not", "None", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"`num_classes` is depreciated. Switch to `nb_classes`.\"", "\n", "\" `num_classes` may be removed on or after 2019-04-23.\"", ")", "\n", "nb_classes", "=", "num_classes", "\n", "del", "num_classes", "\n", "", "if", "'int'", "in", "str", "(", "label", ".", "dtype", ")", ":", "\n", "    ", "logit_mask", "=", "tf", ".", "one_hot", "(", "label", ",", "depth", "=", "nb_classes", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "    ", "logit_mask", "=", "label", "\n", "", "if", "'int'", "in", "str", "(", "logit_mask", ".", "dtype", ")", ":", "\n", "    ", "logit_mask", "=", "tf", ".", "to_float", "(", "logit_mask", ")", "\n", "", "try", ":", "\n", "    ", "label_logits", "=", "reduce_sum", "(", "logit_mask", "*", "model_logits", ",", "axis", "=", "-", "1", ")", "\n", "", "except", "TypeError", ":", "\n", "    ", "raise", "TypeError", "(", "\"Could not take row-wise dot product between \"", "\n", "\"logit mask, of dtype \"", "+", "str", "(", "logit_mask", ".", "dtype", ")", "\n", "+", "\" and model_logits, of dtype \"", "\n", "+", "str", "(", "model_logits", ".", "dtype", ")", ")", "\n", "", "logits_with_target_label_neg_inf", "=", "model_logits", "-", "logit_mask", "*", "99999", "\n", "highest_nonlabel_logits", "=", "reduce_max", "(", "\n", "logits_with_target_label_neg_inf", ",", "axis", "=", "-", "1", ")", "\n", "loss", "=", "highest_nonlabel_logits", "-", "label_logits", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf._apply_black_border": [[1729, 1739], ["tensorflow.image.resize_images", "tensorflow.pad", "tf.image.resize_images.get_shape().as_list", "tf.image.resize_images.get_shape().as_list", "tf.image.resize_images.get_shape", "tf.image.resize_images.get_shape"], "function", ["None"], ["", "def", "_apply_black_border", "(", "x", ",", "border_size", ")", ":", "\n", "  ", "orig_height", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", "\n", "orig_width", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "2", "]", "\n", "x", "=", "tf", ".", "image", ".", "resize_images", "(", "x", ",", "(", "orig_width", "-", "2", "*", "border_size", ",", "\n", "orig_height", "-", "2", "*", "border_size", ")", ")", "\n", "\n", "return", "tf", ".", "pad", "(", "x", ",", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "border_size", ",", "border_size", "]", ",", "\n", "[", "border_size", ",", "border_size", "]", ",", "\n", "[", "0", ",", "0", "]", "]", ",", "'CONSTANT'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf._apply_transformation": [[1741, 1775], ["numpy.ceil().astype", "tensorflow.pad", "tensorflow.contrib.image.rotate", "tensorflow.convert_to_tensor", "tensorflow.contrib.image.translate", "tensorflow.image.resize_image_with_crop_or_pad", "tf.contrib.image.translate.get_shape().as_list", "tf.contrib.image.translate.get_shape().as_list", "numpy.sqrt", "float", "tensorflow.contrib.image.translate", "numpy.min", "numpy.ceil", "print", "tf.contrib.image.translate.get_shape", "tf.contrib.image.translate.get_shape"], "function", ["None"], ["", "def", "_apply_transformation", "(", "inputs", ")", ":", "\n", "  ", "x", ",", "trans", "=", "inputs", "[", "0", "]", ",", "inputs", "[", "1", "]", "\n", "dx", ",", "dy", ",", "angle", "=", "trans", "[", "0", "]", ",", "trans", "[", "1", "]", ",", "trans", "[", "2", "]", "\n", "height", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", "\n", "width", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "2", "]", "\n", "\n", "# Pad the image to prevent two-step rotation / translation from truncating", "\n", "# corners", "\n", "max_dist_from_center", "=", "np", ".", "sqrt", "(", "height", "**", "2", "+", "width", "**", "2", ")", "/", "2", "\n", "min_edge_from_center", "=", "float", "(", "np", ".", "min", "(", "[", "height", ",", "width", "]", ")", ")", "/", "2", "\n", "padding", "=", "np", ".", "ceil", "(", "max_dist_from_center", "-", "\n", "min_edge_from_center", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "x", "=", "tf", ".", "pad", "(", "x", ",", "[", "[", "0", ",", "0", "]", ",", "\n", "[", "padding", ",", "padding", "]", ",", "\n", "[", "padding", ",", "padding", "]", ",", "\n", "[", "0", ",", "0", "]", "]", ",", "\n", "'CONSTANT'", ")", "\n", "\n", "# Apply rotation", "\n", "angle", "*=", "np", ".", "pi", "/", "180", "\n", "x", "=", "tf", ".", "contrib", ".", "image", ".", "rotate", "(", "x", ",", "angle", ",", "interpolation", "=", "'BILINEAR'", ")", "\n", "\n", "# Apply translation", "\n", "dx_in_px", "=", "-", "dx", "*", "height", "\n", "dy_in_px", "=", "-", "dy", "*", "width", "\n", "translation", "=", "tf", ".", "convert_to_tensor", "(", "[", "dx_in_px", ",", "dy_in_px", "]", ")", "\n", "\n", "try", ":", "\n", "    ", "x", "=", "tf", ".", "contrib", ".", "image", ".", "translate", "(", "x", ",", "translation", ",", "interpolation", "=", "'BILINEAR'", ")", "\n", "", "except", "AttributeError", "as", "e", ":", "\n", "    ", "print", "(", "\"WARNING: SpatialAttack requires tf 1.6 or higher\"", ")", "\n", "raise", "e", "\n", "", "x", "=", "tf", ".", "contrib", ".", "image", ".", "translate", "(", "x", ",", "translation", ",", "interpolation", "=", "'BILINEAR'", ")", "\n", "return", "tf", ".", "image", ".", "resize_image_with_crop_or_pad", "(", "x", ",", "height", ",", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.spm": [[1777, 1835], ["numpy.linspace", "numpy.linspace", "numpy.linspace", "attacks_tf.parallel_apply_transformations", "tensorflow.map_fn", "tensorflow.stack", "tensorflow.argmax", "tensorflow.stack", "tensorflow.einsum", "tensorflow.gather_nd", "model.get_probs", "cleverhans.compat.reduce_max", "tensorflow.to_float", "tensorflow.stop_gradient", "cleverhans.compat.reduce_sum", "list", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "zip", "model.get_logits", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "tensorflow.shape", "tensorflow.equal", "itertools.product", "tensorflow.range", "tensorflow.cast"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.parallel_apply_transformations", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits"], ["", "def", "spm", "(", "x", ",", "model", ",", "y", "=", "None", ",", "n_samples", "=", "None", ",", "dx_min", "=", "-", "0.1", ",", "\n", "dx_max", "=", "0.1", ",", "n_dxs", "=", "5", ",", "dy_min", "=", "-", "0.1", ",", "dy_max", "=", "0.1", ",", "n_dys", "=", "5", ",", "\n", "angle_min", "=", "-", "30", ",", "angle_max", "=", "30", ",", "n_angles", "=", "31", ",", "black_border_size", "=", "0", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of the Spatial Transformation Method.\n  :return: a tensor for the adversarial example\n  \"\"\"", "\n", "if", "y", "is", "None", ":", "\n", "    ", "preds", "=", "model", ".", "get_probs", "(", "x", ")", "\n", "# Using model predictions as ground truth to avoid label leaking", "\n", "preds_max", "=", "reduce_max", "(", "preds", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "y", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "preds", ",", "preds_max", ")", ")", "\n", "y", "=", "tf", ".", "stop_gradient", "(", "y", ")", "\n", "del", "preds", "\n", "", "y", "=", "y", "/", "reduce_sum", "(", "y", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "# Define the range of transformations", "\n", "dxs", "=", "np", ".", "linspace", "(", "dx_min", ",", "dx_max", ",", "n_dxs", ")", "\n", "dys", "=", "np", ".", "linspace", "(", "dy_min", ",", "dy_max", ",", "n_dys", ")", "\n", "angles", "=", "np", ".", "linspace", "(", "angle_min", ",", "angle_max", ",", "n_angles", ")", "\n", "\n", "if", "n_samples", "is", "None", ":", "\n", "    ", "import", "itertools", "\n", "transforms", "=", "list", "(", "itertools", ".", "product", "(", "*", "[", "dxs", ",", "dys", ",", "angles", "]", ")", ")", "\n", "", "else", ":", "\n", "    ", "sampled_dxs", "=", "np", ".", "random", ".", "choice", "(", "dxs", ",", "n_samples", ")", "\n", "sampled_dys", "=", "np", ".", "random", ".", "choice", "(", "dys", ",", "n_samples", ")", "\n", "sampled_angles", "=", "np", ".", "random", ".", "choice", "(", "angles", ",", "n_samples", ")", "\n", "transforms", "=", "zip", "(", "sampled_dxs", ",", "sampled_dys", ",", "sampled_angles", ")", "\n", "", "transformed_ims", "=", "parallel_apply_transformations", "(", "\n", "x", ",", "transforms", ",", "black_border_size", ")", "\n", "\n", "def", "_compute_xent", "(", "x", ")", ":", "\n", "    ", "preds", "=", "model", ".", "get_logits", "(", "x", ")", "\n", "return", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "\n", "labels", "=", "y", ",", "logits", "=", "preds", ")", "\n", "\n", "", "all_xents", "=", "tf", ".", "map_fn", "(", "\n", "_compute_xent", ",", "\n", "transformed_ims", ",", "\n", "parallel_iterations", "=", "1", ")", "# Must be 1 to avoid keras race conditions", "\n", "\n", "# Return the adv_x with worst accuracy", "\n", "\n", "# all_xents is n_total_samples x batch_size (SB)", "\n", "all_xents", "=", "tf", ".", "stack", "(", "all_xents", ")", "# SB", "\n", "\n", "# We want the worst case sample, with the largest xent_loss", "\n", "worst_sample_idx", "=", "tf", ".", "argmax", "(", "all_xents", ",", "axis", "=", "0", ")", "# B", "\n", "\n", "batch_size", "=", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", "\n", "keys", "=", "tf", ".", "stack", "(", "[", "\n", "tf", ".", "range", "(", "batch_size", ",", "dtype", "=", "tf", ".", "int32", ")", ",", "\n", "tf", ".", "cast", "(", "worst_sample_idx", ",", "tf", ".", "int32", ")", "\n", "]", ",", "axis", "=", "1", ")", "\n", "transformed_ims_bshwc", "=", "tf", ".", "einsum", "(", "'sbhwc->bshwc'", ",", "transformed_ims", ")", "\n", "after_lookup", "=", "tf", ".", "gather_nd", "(", "transformed_ims_bshwc", ",", "keys", ")", "# BHWC", "\n", "return", "after_lookup", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.parallel_apply_transformations": [[1837, 1857], ["tensorflow.convert_to_tensor", "attacks_tf._apply_black_border", "tensorflow.reshape", "tensorflow.map_fn", "tf.convert_to_tensor.get_shape().as_list", "_apply_black_border.get_shape().as_list", "tensorflow.tile", "tf.convert_to_tensor.get_shape", "_apply_black_border.get_shape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf._apply_black_border"], ["", "def", "parallel_apply_transformations", "(", "x", ",", "transforms", ",", "black_border_size", "=", "0", ")", ":", "\n", "  ", "transforms", "=", "tf", ".", "convert_to_tensor", "(", "transforms", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "x", "=", "_apply_black_border", "(", "x", ",", "black_border_size", ")", "\n", "\n", "num_transforms", "=", "transforms", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "\n", "im_shape", "=", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", "\n", "\n", "# Pass a copy of x and a transformation to each iteration of the map_fn", "\n", "# callable", "\n", "tiled_x", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "tile", "(", "x", ",", "[", "num_transforms", ",", "1", ",", "1", ",", "1", "]", ")", ",", "\n", "[", "num_transforms", ",", "-", "1", "]", "+", "im_shape", ")", "\n", "elems", "=", "[", "tiled_x", ",", "transforms", "]", "\n", "transformed_ims", "=", "tf", ".", "map_fn", "(", "\n", "_apply_transformation", ",", "\n", "elems", ",", "\n", "dtype", "=", "tf", ".", "float32", ",", "\n", "parallel_iterations", "=", "1", ",", "# Must be 1 to avoid keras race conditions", "\n", ")", "\n", "return", "transformed_ims", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils._ArgsWrapper.__init__": [[30, 34], ["isinstance", "vars"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "args", ",", "dict", ")", ":", "\n", "      ", "args", "=", "vars", "(", "args", ")", "\n", "", "self", ".", "args", "=", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils._ArgsWrapper.__getattr__": [[35, 37], ["utils._ArgsWrapper.args.get"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "    ", "return", "self", ".", "args", ".", "get", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.AccuracyReport.__init__": [[47, 58], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "clean_train_clean_eval", "=", "0.", "\n", "self", ".", "clean_train_adv_eval", "=", "0.", "\n", "self", ".", "adv_train_clean_eval", "=", "0.", "\n", "self", ".", "adv_train_adv_eval", "=", "0.", "\n", "\n", "# Training data accuracy results to be used by tutorials", "\n", "self", ".", "train_clean_train_clean_eval", "=", "0.", "\n", "self", ".", "train_clean_train_adv_eval", "=", "0.", "\n", "self", ".", "train_adv_train_clean_eval", "=", "0.", "\n", "self", ".", "train_adv_train_adv_eval", "=", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.TemporaryLogLevel.__init__": [[227, 230], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "level", ",", "name", ")", ":", "\n", "    ", "self", ".", "name", "=", "name", "\n", "self", ".", "level", "=", "level", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.TemporaryLogLevel.__enter__": [[231, 234], ["utils.get_log_level", "utils.set_log_level"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.get_log_level", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "    ", "self", ".", "old_level", "=", "get_log_level", "(", "self", ".", "name", ")", "\n", "set_log_level", "(", "self", ".", "level", ",", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.TemporaryLogLevel.__exit__": [[235, 238], ["utils.set_log_level"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "    ", "set_log_level", "(", "self", ".", "old_level", ",", "self", ".", "name", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.batch_indices": [[60, 80], ["int", "int"], "function", ["None"], ["", "", "def", "batch_indices", "(", "batch_nb", ",", "data_length", ",", "batch_size", ")", ":", "\n", "  ", "\"\"\"\n  This helper function computes a batch start and end index\n  :param batch_nb: the batch number\n  :param data_length: the total length of the data being parsed by batches\n  :param batch_size: the number of inputs in each batch\n  :return: pair of (start, end) indices\n  \"\"\"", "\n", "# Batch start and end index", "\n", "start", "=", "int", "(", "batch_nb", "*", "batch_size", ")", "\n", "end", "=", "int", "(", "(", "batch_nb", "+", "1", ")", "*", "batch_size", ")", "\n", "\n", "# When there are not enough inputs left, we reuse some to complete the", "\n", "# batch", "\n", "if", "end", ">", "data_length", ":", "\n", "    ", "shift", "=", "end", "-", "data_length", "\n", "start", "-=", "shift", "\n", "end", "-=", "shift", "\n", "\n", "", "return", "start", ",", "end", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.other_classes": [[82, 97], ["list", "list.remove", "ValueError", "range"], "function", ["None"], ["", "def", "other_classes", "(", "nb_classes", ",", "class_ind", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of class indices excluding the class indexed by class_ind\n  :param nb_classes: number of classes in the task\n  :param class_ind: the class index to be omitted\n  :return: list of class indices excluding the class indexed by class_ind\n  \"\"\"", "\n", "if", "class_ind", "<", "0", "or", "class_ind", ">=", "nb_classes", ":", "\n", "    ", "error_str", "=", "\"class_ind must be within the range (0, nb_classes - 1)\"", "\n", "raise", "ValueError", "(", "error_str", ")", "\n", "\n", "", "other_classes_list", "=", "list", "(", "range", "(", "nb_classes", ")", ")", "\n", "other_classes_list", ".", "remove", "(", "class_ind", ")", "\n", "\n", "return", "other_classes_list", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical": [[99, 122], ["numpy.array().ravel", "numpy.zeros", "warnings.warn", "ValueError", "numpy.array", "numpy.arange"], "function", ["None"], ["", "def", "to_categorical", "(", "y", ",", "nb_classes", ",", "num_classes", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Converts a class vector (integers) to binary class matrix.\n  This is adapted from the Keras function with the same name.\n  :param y: class vector to be converted into a matrix\n            (integers from 0 to nb_classes).\n  :param nb_classes: nb_classes: total number of classes.\n  :param num_classses: depricated version of nb_classes\n  :return: A binary matrix representation of the input.\n  \"\"\"", "\n", "if", "num_classes", "is", "not", "None", ":", "\n", "    ", "if", "nb_classes", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Should not specify both nb_classes and its deprecated \"", "\n", "\"alias, num_classes\"", ")", "\n", "", "warnings", ".", "warn", "(", "\"`num_classes` is deprecated. Switch to `nb_classes`.\"", "\n", "\" `num_classes` may be removed on or after 2019-04-23.\"", ")", "\n", "nb_classes", "=", "num_classes", "\n", "del", "num_classes", "\n", "", "y", "=", "np", ".", "array", "(", "y", ",", "dtype", "=", "'int'", ")", ".", "ravel", "(", ")", "\n", "n", "=", "y", ".", "shape", "[", "0", "]", "\n", "categorical", "=", "np", ".", "zeros", "(", "(", "n", ",", "nb_classes", ")", ")", "\n", "categorical", "[", "np", ".", "arange", "(", "n", ")", ",", "y", "]", "=", "1", "\n", "return", "categorical", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.random_targets": [[124, 162], ["numpy.zeros", "six.moves.xrange", "utils.to_categorical", "result.astype.astype", "len", "numpy.argmax", "numpy.sum", "utils.other_classes", "numpy.random.choice"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.other_classes"], ["", "def", "random_targets", "(", "gt", ",", "nb_classes", ")", ":", "\n", "  ", "\"\"\"\n  Take in an array of correct labels and randomly select a different label\n  for each label in the array. This is typically used to randomly select a\n  target class in targeted adversarial examples attacks (i.e., when the\n  search algorithm takes in both a source class and target class to compute\n  the adversarial example).\n  :param gt: the ground truth (correct) labels. They can be provided as a\n             1D vector or 2D array of one-hot encoded labels.\n  :param nb_classes: The number of classes for this task. The random class\n                     will be chosen between 0 and nb_classes such that it\n                     is different from the correct class.\n  :return: A numpy array holding the randomly-selected target classes\n           encoded as one-hot labels.\n  \"\"\"", "\n", "# If the ground truth labels are encoded as one-hot, convert to labels.", "\n", "if", "len", "(", "gt", ".", "shape", ")", "==", "2", ":", "\n", "    ", "gt", "=", "np", ".", "argmax", "(", "gt", ",", "axis", "=", "1", ")", "\n", "\n", "# This vector will hold the randomly selected labels.", "\n", "", "result", "=", "np", ".", "zeros", "(", "gt", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "for", "class_ind", "in", "xrange", "(", "nb_classes", ")", ":", "\n", "# Compute all indices in that class.", "\n", "    ", "in_cl", "=", "gt", "==", "class_ind", "\n", "size", "=", "np", ".", "sum", "(", "in_cl", ")", "\n", "\n", "# Compute the set of potential targets for this class.", "\n", "potential_targets", "=", "other_classes", "(", "nb_classes", ",", "class_ind", ")", "\n", "\n", "# Draw with replacement random targets among the potential targets.", "\n", "result", "[", "in_cl", "]", "=", "np", ".", "random", ".", "choice", "(", "potential_targets", ",", "size", "=", "size", ")", "\n", "\n", "# Encode vector of random labels as one-hot labels.", "\n", "", "result", "=", "to_categorical", "(", "result", ",", "nb_classes", ")", "\n", "result", "=", "result", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.pair_visual": [[164, 170], ["warnings.warn", "new_pair_visual"], "function", ["None"], ["", "def", "pair_visual", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`pair_visual` has moved to `cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.pair_visual may be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "pair_visual", "as", "new_pair_visual", "\n", "return", "new_pair_visual", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.grid_visual": [[172, 178], ["warnings.warn", "new_grid_visual"], "function", ["None"], ["", "def", "grid_visual", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`grid_visual` has moved to `cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.grid_visual may be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "grid_visual", "as", "new_grid_visual", "\n", "return", "new_grid_visual", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.get_logits_over_interval": [[180, 188], ["warnings.warn", "new_get_logits_over_interval"], "function", ["None"], ["", "def", "get_logits_over_interval", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`get_logits_over_interval` has moved to \"", "\n", "\"`cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.get_logits_over_interval may be removed on \"", "\n", "\"or after 2019-04-24.\"", ")", "\n", "# pylint:disable=line-too-long", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "get_logits_over_interval", "as", "new_get_logits_over_interval", "\n", "return", "new_get_logits_over_interval", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.linear_extrapolation_plot": [[190, 198], ["warnings.warn", "new_linear_extrapolation_plot"], "function", ["None"], ["", "def", "linear_extrapolation_plot", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`linear_extrapolation_plot` has moved to \"", "\n", "\"`cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.linear_extrapolation_plot may be removed on \"", "\n", "\"or after 2019-04-24.\"", ")", "\n", "# pylint:disable=line-too-long", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "linear_extrapolation_plot", "as", "new_linear_extrapolation_plot", "\n", "return", "new_linear_extrapolation_plot", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level": [[200, 208], ["logging.getLogger().setLevel", "logging.getLogger"], "function", ["None"], ["", "def", "set_log_level", "(", "level", ",", "name", "=", "\"cleverhans\"", ")", ":", "\n", "  ", "\"\"\"\n  Sets the threshold for the cleverhans logger to level\n  :param level: the logger threshold. You can find values here:\n                https://docs.python.org/2/library/logging.html#levels\n  :param name: the name used for the cleverhans logger\n  \"\"\"", "\n", "logging", ".", "getLogger", "(", "name", ")", ".", "setLevel", "(", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.get_log_level": [[210, 216], ["logging.getLogger().getEffectiveLevel", "logging.getLogger"], "function", ["None"], ["", "def", "get_log_level", "(", "name", "=", "\"cleverhans\"", ")", ":", "\n", "  ", "\"\"\"\n  Gets the current threshold for the cleverhans logger\n  :param name: the name used for the cleverhans logger\n  \"\"\"", "\n", "return", "logging", ".", "getLogger", "(", "name", ")", ".", "getEffectiveLevel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.create_logger": [[240, 256], ["logging.getLogger", "len", "logging.StreamHandler", "logging.Formatter", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler"], "function", ["None"], ["", "", "def", "create_logger", "(", "name", ")", ":", "\n", "  ", "\"\"\"\n  Create a logger object with the given name.\n\n  If this is the first time that we call this method, then initialize the\n  formatter.\n  \"\"\"", "\n", "base", "=", "logging", ".", "getLogger", "(", "\"cleverhans\"", ")", "\n", "if", "len", "(", "base", ".", "handlers", ")", "==", "0", ":", "\n", "    ", "ch", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "'[%(levelname)s %(asctime)s %(name)s] '", "+", "\n", "'%(message)s'", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "base", ".", "addHandler", "(", "ch", ")", "\n", "\n", "", "return", "base", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deterministic_dict": [[258, 266], ["collections.OrderedDict", "sorted", "normal_dict.keys"], "function", ["None"], ["", "def", "deterministic_dict", "(", "normal_dict", ")", ":", "\n", "  ", "\"\"\"\n  Returns a version of `normal_dict` whose iteration order is always the same\n  \"\"\"", "\n", "out", "=", "OrderedDict", "(", ")", "\n", "for", "key", "in", "sorted", "(", "normal_dict", ".", "keys", "(", ")", ")", ":", "\n", "    ", "out", "[", "key", "]", "=", "normal_dict", "[", "key", "]", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.ordered_union": [[268, 282], ["out.append"], "function", ["None"], ["", "def", "ordered_union", "(", "l1", ",", "l2", ")", ":", "\n", "  ", "\"\"\"\n  Return the union of l1 and l2, with a deterministic ordering.\n  (Union of python sets does not necessarily have a consisten iteration\n  order)\n  :param l1: list of items\n  :param l2: list of items\n  :returns: list containing one copy of each item that is in l1 or in l2\n  \"\"\"", "\n", "out", "=", "[", "]", "\n", "for", "e", "in", "l1", "+", "l2", ":", "\n", "    ", "if", "e", "not", "in", "out", ":", "\n", "      ", "out", ".", "append", "(", "e", ")", "\n", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip": [[284, 293], ["len", "zip", "all", "ValueError", "str", "len", "len"], "function", ["None"], ["", "def", "safe_zip", "(", "*", "args", ")", ":", "\n", "  ", "\"\"\"zip, with a guarantee that all arguments are the same length.\n  (normal zip silently drops entries to make them the same length)\n  \"\"\"", "\n", "length", "=", "len", "(", "args", "[", "0", "]", ")", "\n", "if", "not", "all", "(", "len", "(", "arg", ")", "==", "length", "for", "arg", "in", "args", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\"Lengths of arguments do not match: \"", "\n", "+", "str", "(", "[", "len", "(", "arg", ")", "for", "arg", "in", "args", "]", ")", ")", "\n", "", "return", "zip", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.shell_call": [[295, 331], ["re.compile", "list", "range", "logging.debug", "subprocess.check_output", "len", "re.compile.match", "CMD_VARIABLE_RE.match.group"], "function", ["None"], ["", "def", "shell_call", "(", "command", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"Calls shell command with argument substitution.\n\n  Args:\n    command: command represented as a list. Each element of the list is one\n      token of the command. For example \"cp a b\" becomes ['cp', 'a', 'b']\n      If any element of the list looks like '${NAME}' then it will be replaced\n      by value from **kwargs with key 'NAME'.\n    **kwargs: dictionary with argument substitution\n\n  Returns:\n    output of the command\n\n  Raises:\n    subprocess.CalledProcessError if command return value is not zero\n\n  This function is useful when you need to do variable substitution prior\n  running the command. Below are few examples of how it works:\n\n    shell_call(['cp', 'a', 'b'], a='asd') calls command 'cp a b'\n\n    shell_call(['cp', '${a}', 'b'], a='asd') calls command 'cp asd b',\n    '${a}; was replaced with 'asd' before calling the command\n  \"\"\"", "\n", "# Regular expression to find instances of '${NAME}' in a string", "\n", "CMD_VARIABLE_RE", "=", "re", ".", "compile", "(", "'^\\\\$\\\\{(\\\\w+)\\\\}$'", ")", "\n", "command", "=", "list", "(", "command", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "command", ")", ")", ":", "\n", "    ", "m", "=", "CMD_VARIABLE_RE", ".", "match", "(", "command", "[", "i", "]", ")", "\n", "if", "m", ":", "\n", "      ", "var_id", "=", "m", ".", "group", "(", "1", ")", "\n", "if", "var_id", "in", "kwargs", ":", "\n", "        ", "command", "[", "i", "]", "=", "kwargs", "[", "var_id", "]", "\n", "", "", "", "str_command", "=", "' '", ".", "join", "(", "command", ")", "\n", "logging", ".", "debug", "(", "'Executing shell command: %s'", "%", "str_command", ")", "\n", "return", "subprocess", ".", "check_output", "(", "command", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.deep_copy": [[332, 341], ["numpy_dict[].copy"], "function", ["None"], ["", "def", "deep_copy", "(", "numpy_dict", ")", ":", "\n", "  ", "\"\"\"\n  Returns a copy of a dictionary whose values are numpy arrays.\n  Copies their values rather than copying references to them.\n  \"\"\"", "\n", "out", "=", "{", "}", "\n", "for", "key", "in", "numpy_dict", ":", "\n", "    ", "out", "[", "key", "]", "=", "numpy_dict", "[", "key", "]", ".", "copy", "(", ")", "\n", "", "return", "out", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.augmentation.random_shift": [[19, 26], ["tensorflow.pad", "tensorflow.random_crop", "tensorflow.shape", "x.get_shape"], "function", ["None"], ["def", "random_shift", "(", "x", ",", "pad", "=", "(", "4", ",", "4", ")", ",", "mode", "=", "'REFLECT'", ")", ":", "\n", "  ", "\"\"\"Pad a single image and then crop to the original size with a random\n  offset.\"\"\"", "\n", "assert", "mode", "in", "'REFLECT SYMMETRIC CONSTANT'", ".", "split", "(", ")", "\n", "assert", "x", ".", "get_shape", "(", ")", ".", "ndims", "==", "3", "\n", "xp", "=", "tf", ".", "pad", "(", "x", ",", "[", "[", "pad", "[", "0", "]", ",", "pad", "[", "0", "]", "]", ",", "[", "pad", "[", "1", "]", ",", "pad", "[", "1", "]", "]", ",", "[", "0", ",", "0", "]", "]", ",", "mode", ")", "\n", "return", "tf", ".", "random_crop", "(", "xp", ",", "tf", ".", "shape", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.augmentation.batch_augment": [[28, 38], ["tensorflow.device", "tensorflow.map_fn"], "function", ["None"], ["", "def", "batch_augment", "(", "x", ",", "func", ",", "device", "=", "'/CPU:0'", ")", ":", "\n", "  ", "\"\"\"\n  Apply dataset augmentation to a batch of exmaples.\n  :param x: Tensor representing a batch of examples.\n  :param func: Callable implementing dataset augmentation, operating on\n    a single image.\n  :param device: String specifying which device to use.\n  \"\"\"", "\n", "with", "tf", ".", "device", "(", "device", ")", ":", "\n", "    ", "return", "tf", ".", "map_fn", "(", "func", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.augmentation.random_crop_and_flip": [[40, 59], ["tensorflow.shape", "tensorflow.shape", "tf.image.random_flip_left_right.get_shape", "tensorflow.random_crop", "tensorflow.device", "tensorflow.image.resize_image_with_crop_or_pad", "tensorflow.map_fn", "tensorflow.image.random_flip_left_right"], "function", ["None"], ["", "", "def", "random_crop_and_flip", "(", "x", ",", "pad_rows", "=", "4", ",", "pad_cols", "=", "4", ")", ":", "\n", "  ", "\"\"\"Augment a batch by randomly cropping and horizontally flipping it.\"\"\"", "\n", "rows", "=", "tf", ".", "shape", "(", "x", ")", "[", "1", "]", "\n", "cols", "=", "tf", ".", "shape", "(", "x", ")", "[", "2", "]", "\n", "channels", "=", "x", ".", "get_shape", "(", ")", "[", "3", "]", "\n", "\n", "def", "_rand_crop_img", "(", "img", ")", ":", "\n", "    ", "\"\"\"Randomly crop an individual image\"\"\"", "\n", "return", "tf", ".", "random_crop", "(", "img", ",", "[", "rows", ",", "cols", ",", "channels", "]", ")", "\n", "\n", "# Some of these ops are only on CPU.", "\n", "# This function will often be called with the device set to GPU.", "\n", "# We need to set it to CPU temporarily to avoid an exception.", "\n", "", "with", "tf", ".", "device", "(", "'/CPU:0'", ")", ":", "\n", "    ", "x", "=", "tf", ".", "image", ".", "resize_image_with_crop_or_pad", "(", "x", ",", "rows", "+", "pad_rows", ",", "\n", "cols", "+", "pad_cols", ")", "\n", "x", "=", "tf", ".", "map_fn", "(", "_rand_crop_img", ",", "x", ")", "\n", "x", "=", "tf", ".", "image", ".", "random_flip_left_right", "(", "x", ")", "\n", "", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectFactory.__init__": [[500, 509], ["tuple", "sorted", "attack_params.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "attack", "=", "None", ",", "attack_params", "=", "None", ")", ":", "\n", "    ", "if", "attack_params", "is", "None", ":", "\n", "      ", "attack_params", "=", "{", "}", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "attack", "=", "attack", "\n", "self", ".", "attack_params", "=", "attack_params", "\n", "hashable_attack_params", "=", "tuple", "(", "(", "key", ",", "attack_params", "[", "key", "]", ")", "for", "key", "\n", "in", "sorted", "(", "attack_params", ".", "keys", "(", ")", ")", ")", "\n", "self", ".", "properties_to_hash", "=", "(", "model", ",", "attack", ",", "hashable_attack_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectFactory.__hash__": [[510, 514], ["evaluation._CorrectFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectFactory.__eq__": [[515, 521], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_CorrectFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectFactory.__call__": [[522, 542], ["evaluation._CorrectFactory.model.make_input_placeholder", "evaluation._CorrectFactory.model.make_label_placeholder", "evaluation._CorrectFactory.model.get_probs", "tensorflow.equal", "distutils.version.LooseVersion", "distutils.version.LooseVersion", "NotImplementedError", "evaluation._CorrectFactory.attack.generate", "tensorflow.argmax", "tensorflow.argmax"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "x_batch", "=", "self", ".", "model", ".", "make_input_placeholder", "(", ")", "\n", "y_batch", "=", "self", ".", "model", ".", "make_label_placeholder", "(", ")", "\n", "\n", "if", "LooseVersion", "(", "tf", ".", "__version__", ")", "<", "LooseVersion", "(", "'1.0.0'", ")", ":", "\n", "      ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "if", "self", ".", "attack", "is", "None", ":", "\n", "      ", "x_input", "=", "x_batch", "\n", "", "else", ":", "\n", "      ", "attack_params", "=", "self", ".", "attack_params", "\n", "if", "attack_params", "is", "None", ":", "\n", "        ", "attack_params", "=", "{", "}", "\n", "", "x_input", "=", "self", ".", "attack", ".", "generate", "(", "x_batch", ",", "y", "=", "y_batch", ",", "**", "attack_params", ")", "\n", "\n", "", "predictions", "=", "self", ".", "model", ".", "get_probs", "(", "x_input", ")", "\n", "correct", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "y_batch", ",", "axis", "=", "-", "1", ")", ",", "\n", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", ")", "\n", "\n", "return", "(", "x_batch", ",", "y_batch", ")", ",", "(", "correct", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._ClassAndProbFactory.__init__": [[552, 561], ["tuple", "sorted", "attack_params.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "attack", "=", "None", ",", "attack_params", "=", "None", ")", ":", "\n", "    ", "if", "attack_params", "is", "None", ":", "\n", "      ", "attack_params", "=", "{", "}", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "attack", "=", "attack", "\n", "self", ".", "attack_params", "=", "attack_params", "\n", "hashable_attack_params", "=", "tuple", "(", "(", "key", ",", "attack_params", "[", "key", "]", ")", "for", "key", "\n", "in", "sorted", "(", "attack_params", ".", "keys", "(", ")", ")", ")", "\n", "self", ".", "properties_to_hash", "=", "(", "model", ",", "attack", ",", "hashable_attack_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._ClassAndProbFactory.__hash__": [[562, 566], ["evaluation._ClassAndProbFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._ClassAndProbFactory.__eq__": [[567, 573], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_ClassAndProbFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._ClassAndProbFactory.__call__": [[574, 596], ["evaluation._ClassAndProbFactory.model.make_input_placeholder", "evaluation._ClassAndProbFactory.model.get_probs", "tensorflow.argmax", "tensorflow.reduce_max", "distutils.version.LooseVersion", "distutils.version.LooseVersion", "NotImplementedError", "evaluation._ClassAndProbFactory.model.make_label_placeholder", "inputs.append", "evaluation._ClassAndProbFactory.attack.generate", "tuple"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "x_batch", "=", "self", ".", "model", ".", "make_input_placeholder", "(", ")", "\n", "inputs", "=", "[", "x_batch", "]", "\n", "\n", "if", "LooseVersion", "(", "tf", ".", "__version__", ")", "<", "LooseVersion", "(", "'1.0.0'", ")", ":", "\n", "      ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "if", "self", ".", "attack", "is", "None", ":", "\n", "      ", "x_input", "=", "x_batch", "\n", "", "else", ":", "\n", "      ", "y_batch", "=", "self", ".", "model", ".", "make_label_placeholder", "(", ")", "\n", "inputs", ".", "append", "(", "y_batch", ")", "\n", "attack_params", "=", "self", ".", "attack_params", "\n", "if", "attack_params", "is", "None", ":", "\n", "        ", "attack_params", "=", "{", "}", "\n", "", "x_input", "=", "self", ".", "attack", ".", "generate", "(", "x_batch", ",", "y", "=", "y_batch", ",", "**", "attack_params", ")", "\n", "\n", "", "predictions", "=", "self", ".", "model", ".", "get_probs", "(", "x_input", ")", "\n", "classes", "=", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", "\n", "max_probs", "=", "tf", ".", "reduce_max", "(", "predictions", ",", "axis", "=", "1", ")", "\n", "\n", "return", "tuple", "(", "inputs", ")", ",", "(", "classes", ",", "max_probs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectAndProbFactory.__init__": [[606, 615], ["tuple", "sorted", "attack_params.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "attack", "=", "None", ",", "attack_params", "=", "None", ")", ":", "\n", "    ", "if", "attack_params", "is", "None", ":", "\n", "      ", "attack_params", "=", "{", "}", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "attack", "=", "attack", "\n", "self", ".", "attack_params", "=", "attack_params", "\n", "hashable_attack_params", "=", "tuple", "(", "(", "key", ",", "attack_params", "[", "key", "]", ")", "for", "key", "\n", "in", "sorted", "(", "attack_params", ".", "keys", "(", ")", ")", ")", "\n", "self", ".", "properties_to_hash", "=", "(", "model", ",", "attack", ",", "hashable_attack_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectAndProbFactory.__hash__": [[616, 620], ["evaluation._CorrectAndProbFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectAndProbFactory.__eq__": [[621, 627], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_CorrectAndProbFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._CorrectAndProbFactory.__call__": [[628, 649], ["evaluation._CorrectAndProbFactory.model.make_input_placeholder", "evaluation._CorrectAndProbFactory.model.make_label_placeholder", "evaluation._CorrectAndProbFactory.model.get_probs", "tensorflow.equal", "tensorflow.reduce_max", "distutils.version.LooseVersion", "distutils.version.LooseVersion", "NotImplementedError", "evaluation._CorrectAndProbFactory.attack.generate", "tensorflow.argmax", "tensorflow.argmax"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "x_batch", "=", "self", ".", "model", ".", "make_input_placeholder", "(", ")", "\n", "y_batch", "=", "self", ".", "model", ".", "make_label_placeholder", "(", ")", "\n", "\n", "if", "LooseVersion", "(", "tf", ".", "__version__", ")", "<", "LooseVersion", "(", "'1.0.0'", ")", ":", "\n", "      ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "if", "self", ".", "attack", "is", "None", ":", "\n", "      ", "x_input", "=", "x_batch", "\n", "", "else", ":", "\n", "      ", "attack_params", "=", "self", ".", "attack_params", "\n", "if", "attack_params", "is", "None", ":", "\n", "        ", "attack_params", "=", "{", "}", "\n", "", "x_input", "=", "self", ".", "attack", ".", "generate", "(", "x_batch", ",", "y", "=", "y_batch", ",", "**", "attack_params", ")", "\n", "\n", "", "predictions", "=", "self", ".", "model", ".", "get_probs", "(", "x_input", ")", "\n", "correct", "=", "tf", ".", "equal", "(", "tf", ".", "argmax", "(", "y_batch", ",", "axis", "=", "-", "1", ")", ",", "\n", "tf", ".", "argmax", "(", "predictions", ",", "axis", "=", "-", "1", ")", ")", "\n", "max_probs", "=", "tf", ".", "reduce_max", "(", "predictions", ",", "axis", "=", "1", ")", "\n", "\n", "return", "(", "x_batch", ",", "y_batch", ")", ",", "(", "correct", ",", "max_probs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__init__": [[663, 679], ["isinstance", "tuple", "isinstance", "TypeError", "sorted", "str", "str", "attack_params.keys", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "attack", ",", "attack_params", "=", "None", ",", "pass_y", "=", "False", ")", ":", "\n", "    ", "assert", "isinstance", "(", "model", ",", "cleverhans", ".", "model", ".", "Model", ")", "\n", "if", "not", "isinstance", "(", "attack", ",", "cleverhans", ".", "attacks", ".", "Attack", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"`attack` must be an instance of cleverhans.attacks.\"", "\n", "\"attack. Got %s with type %s \"", "%", "(", "str", "(", "attack", ")", ",", "\n", "str", "(", "type", "(", "attack", ")", ")", ")", ")", "\n", "\n", "", "if", "attack_params", "is", "None", ":", "\n", "      ", "attack_params", "=", "{", "}", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "attack", "=", "attack", "\n", "self", ".", "attack_params", "=", "attack_params", "\n", "self", ".", "pass_y", "=", "pass_y", "\n", "hashable_attack_params", "=", "tuple", "(", "(", "key", ",", "attack_params", "[", "key", "]", ")", "for", "key", "\n", "in", "sorted", "(", "attack_params", ".", "keys", "(", ")", ")", ")", "\n", "self", ".", "properties_to_hash", "=", "(", "model", ",", "attack", ",", "hashable_attack_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__": [[680, 684], ["evaluation._AttackFactory.properties_to_hash.__hash__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__hash__"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "return", "self", ".", "properties_to_hash", ".", "__hash__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__eq__": [[685, 691], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "# Make factory hashable so that no two factories for the", "\n", "# same model will be used to build redundant tf graphs", "\n", "    ", "if", "not", "isinstance", "(", "other", ",", "_AttackFactory", ")", ":", "\n", "      ", "return", "False", "\n", "", "return", "self", ".", "properties_to_hash", "==", "other", ".", "properties_to_hash", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._AttackFactory.__call__": [[692, 708], ["evaluation._AttackFactory.model.make_input_placeholder", "evaluation._AttackFactory.model.make_label_placeholder", "evaluation._AttackFactory.attack.generate", "evaluation._AttackFactory.attack.generate", "tuple"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "__call__", "(", "self", ")", ":", "\n", "    ", "x_batch", "=", "self", ".", "model", ".", "make_input_placeholder", "(", ")", "\n", "y_batch", "=", "self", ".", "model", ".", "make_label_placeholder", "(", ")", "\n", "\n", "attack_params", "=", "self", ".", "attack_params", "\n", "if", "attack_params", "is", "None", ":", "\n", "      ", "attack_params", "=", "{", "}", "\n", "", "if", "self", ".", "pass_y", ":", "\n", "      ", "x_adv", "=", "self", ".", "attack", ".", "generate", "(", "x_batch", ",", "y", "=", "y_batch", ",", "**", "attack_params", ")", "\n", "", "else", ":", "\n", "# Some code checks the keys of kwargs, rather than checking if", "\n", "# y is None, so we need to truly not pass y at all, rather than", "\n", "# just passing a None value for it.", "\n", "      ", "x_adv", "=", "self", ".", "attack", ".", "generate", "(", "x_batch", ",", "**", "attack_params", ")", "\n", "\n", "", "return", "(", "x_batch", ",", "y_batch", ")", ",", "tuple", "(", "[", "x_adv", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.accuracy": [[18, 61], ["evaluation._check_x", "evaluation._check_y", "evaluation._CorrectFactory", "evaluation.batch_eval_multi_worker", "correct.mean", "ValueError"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_x", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_y", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker"], ["def", "accuracy", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "batch_size", "=", "None", ",", "devices", "=", "None", ",", "feed", "=", "None", ",", "\n", "attack", "=", "None", ",", "attack_params", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Compute the accuracy of a TF model on some data\n  :param sess: TF session to use when training the graph\n  :param model: cleverhans.model.Model instance\n  :param x: numpy array containing input examples (e.g. MNIST().x_test )\n  :param y: numpy array containing example labels (e.g. MNIST().y_test )\n  :param batch_size: Number of examples to use in a single evaluation batch.\n      If not specified, this function will use a reasonable guess and\n      may run out of memory.\n      When choosing the batch size, keep in mind that the batch will\n      be divided up evenly among available devices. If you can fit 128\n      examples in memory on one GPU and you have 8 GPUs, you probably\n      want to use a batch size of 1024 (unless a different batch size\n      runs faster with the ops you are using, etc.)\n  :param devices: An optional list of string device names to use.\n    If not specified, this function will use all visible GPUs.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param attack: cleverhans.attack.Attack\n    Optional. If no attack specified, evaluates the model on clean data.\n    If attack is specified, evaluates the model on adversarial examples\n    created by the attack.\n  :param attack_params: dictionary\n    If attack is specified, this dictionary is passed to attack.generate\n    as keyword arguments.\n  :return: a float with the accuracy value\n  \"\"\"", "\n", "\n", "_check_x", "(", "x", ")", "\n", "_check_y", "(", "y", ")", "\n", "if", "x", ".", "shape", "[", "0", "]", "!=", "y", ".", "shape", "[", "0", "]", ":", "\n", "    ", "raise", "ValueError", "(", "\"Number of input examples and labels do not match.\"", ")", "\n", "\n", "", "factory", "=", "_CorrectFactory", "(", "model", ",", "attack", ",", "attack_params", ")", "\n", "\n", "correct", ",", "=", "batch_eval_multi_worker", "(", "sess", ",", "factory", ",", "[", "x", ",", "y", "]", ",", "\n", "batch_size", "=", "batch_size", ",", "devices", "=", "devices", ",", "\n", "feed", "=", "feed", ")", "\n", "\n", "return", "correct", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.class_and_confidence": [[63, 127], ["evaluation._check_x", "evaluation._ClassAndProbFactory", "evaluation.batch_eval_multi_worker", "confidence.min", "confidence.max", "confidence.min", "inputs.append", "evaluation._check_y", "ValueError", "ValueError", "confidence.min", "ValueError", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_x", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_y"], ["", "def", "class_and_confidence", "(", "sess", ",", "model", ",", "x", ",", "y", "=", "None", ",", "batch_size", "=", "None", ",", "\n", "devices", "=", "None", ",", "feed", "=", "None", ",", "attack", "=", "None", ",", "\n", "attack_params", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Return the model's classification of the input data, and the confidence\n  (probability) assigned to each example.\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing input examples (e.g. MNIST().x_test )\n  :param y: numpy array containing true labels\n    (Needed only if using an attack that avoids these labels)\n  :param batch_size: Number of examples to use in a single evaluation batch.\n      If not specified, this function will use a reasonable guess and\n      may run out of memory.\n      When choosing the batch size, keep in mind that the batch will\n      be divided up evenly among available devices. If you can fit 128\n      examples in memory on one GPU and you have 8 GPUs, you probably\n      want to use a batch size of 1024 (unless a different batch size\n      runs faster with the ops you are using, etc.)\n  :param devices: An optional list of string device names to use.\n    If not specified, this function will use all visible GPUs.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param attack: cleverhans.attack.Attack\n    Optional. If no attack specified, evaluates the model on clean data.\n    If attack is specified, evaluates the model on adversarial examples\n    created by the attack.\n  :param attack_params: dictionary\n    If attack is specified, this dictionary is passed to attack.generate\n    as keyword arguments.\n  :return:\n    an ndarray of ints indicating the class assigned to each example\n    an ndarray of probabilities assigned to the prediction for each example\n  \"\"\"", "\n", "\n", "_check_x", "(", "x", ")", "\n", "inputs", "=", "[", "x", "]", "\n", "if", "attack", "is", "not", "None", ":", "\n", "    ", "inputs", ".", "append", "(", "y", ")", "\n", "_check_y", "(", "y", ")", "\n", "if", "x", ".", "shape", "[", "0", "]", "!=", "y", ".", "shape", "[", "0", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Number of input examples and labels do not match.\"", ")", "\n", "\n", "", "", "factory", "=", "_ClassAndProbFactory", "(", "model", ",", "attack", ",", "attack_params", ")", "\n", "\n", "out", "=", "batch_eval_multi_worker", "(", "sess", ",", "factory", ",", "inputs", ",", "batch_size", "=", "batch_size", ",", "\n", "devices", "=", "devices", ",", "feed", "=", "feed", ")", "\n", "\n", "classes", ",", "confidence", "=", "out", "\n", "\n", "assert", "classes", ".", "shape", "==", "(", "x", ".", "shape", "[", "0", "]", ",", ")", "\n", "assert", "confidence", ".", "shape", "==", "(", "x", ".", "shape", "[", "0", "]", ",", ")", "\n", "min_confidence", "=", "confidence", ".", "min", "(", ")", "\n", "if", "min_confidence", "<", "0.", ":", "\n", "    ", "raise", "ValueError", "(", "\"Model does not return valid probabilities: \"", "+", "\n", "str", "(", "min_confidence", ")", ")", "\n", "", "max_confidence", "=", "confidence", ".", "max", "(", ")", "\n", "if", "max_confidence", ">", "1.", ":", "\n", "    ", "raise", "ValueError", "(", "\"Model does not return valid probablities: \"", "+", "\n", "str", "(", "max_confidence", ")", ")", "\n", "", "assert", "confidence", ".", "min", "(", ")", ">=", "0.", ",", "confidence", ".", "min", "(", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.correctness_and_confidence": [[129, 189], ["evaluation._check_x", "evaluation._check_y", "evaluation._CorrectAndProbFactory", "evaluation.batch_eval_multi_worker", "confidence.min", "confidence.max", "confidence.min", "ValueError", "ValueError", "ValueError", "confidence.min", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_x", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_y", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker"], ["", "def", "correctness_and_confidence", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "batch_size", "=", "None", ",", "\n", "devices", "=", "None", ",", "feed", "=", "None", ",", "attack", "=", "None", ",", "\n", "attack_params", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Report whether the model is correct and its confidence on each example in\n  a dataset.\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing input examples (e.g. MNIST().x_test )\n  :param y: numpy array containing example labels (e.g. MNIST().y_test )\n  :param batch_size: Number of examples to use in a single evaluation batch.\n      If not specified, this function will use a reasonable guess and\n      may run out of memory.\n      When choosing the batch size, keep in mind that the batch will\n      be divided up evenly among available devices. If you can fit 128\n      examples in memory on one GPU and you have 8 GPUs, you probably\n      want to use a batch size of 1024 (unless a different batch size\n      runs faster with the ops you are using, etc.)\n  :param devices: An optional list of string device names to use.\n    If not specified, this function will use all visible GPUs.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param attack: cleverhans.attack.Attack\n    Optional. If no attack specified, evaluates the model on clean data.\n    If attack is specified, evaluates the model on adversarial examples\n    created by the attack.\n  :param attack_params: dictionary\n    If attack is specified, this dictionary is passed to attack.generate\n    as keyword arguments.\n  :return:\n    an ndarray of bools indicating whether each example is correct\n    an ndarray of probabilities assigned to the prediction for each example\n  \"\"\"", "\n", "\n", "_check_x", "(", "x", ")", "\n", "_check_y", "(", "y", ")", "\n", "if", "x", ".", "shape", "[", "0", "]", "!=", "y", ".", "shape", "[", "0", "]", ":", "\n", "    ", "raise", "ValueError", "(", "\"Number of input examples and labels do not match.\"", ")", "\n", "\n", "", "factory", "=", "_CorrectAndProbFactory", "(", "model", ",", "attack", ",", "attack_params", ")", "\n", "\n", "out", "=", "batch_eval_multi_worker", "(", "sess", ",", "factory", ",", "[", "x", ",", "y", "]", ",", "batch_size", "=", "batch_size", ",", "\n", "devices", "=", "devices", ",", "feed", "=", "feed", ")", "\n", "\n", "correctness", ",", "confidence", "=", "out", "\n", "\n", "assert", "correctness", ".", "shape", "==", "(", "x", ".", "shape", "[", "0", "]", ",", ")", "\n", "assert", "confidence", ".", "shape", "==", "(", "x", ".", "shape", "[", "0", "]", ",", ")", "\n", "min_confidence", "=", "confidence", ".", "min", "(", ")", "\n", "if", "min_confidence", "<", "0.", ":", "\n", "    ", "raise", "ValueError", "(", "\"Model does not return valid probabilities: \"", "+", "\n", "str", "(", "min_confidence", ")", ")", "\n", "", "max_confidence", "=", "confidence", ".", "max", "(", ")", "\n", "if", "max_confidence", ">", "1.", ":", "\n", "    ", "raise", "ValueError", "(", "\"Model does not return valid probablities: \"", "+", "\n", "str", "(", "max_confidence", ")", ")", "\n", "", "assert", "confidence", ".", "min", "(", ")", ">=", "0.", ",", "confidence", ".", "min", "(", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.run_attack": [[191, 229], ["evaluation._check_x", "evaluation._check_y", "evaluation._AttackFactory", "evaluation.batch_eval_multi_worker"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_x", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_y", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker"], ["", "def", "run_attack", "(", "sess", ",", "model", ",", "x", ",", "y", ",", "attack", ",", "attack_params", ",", "batch_size", "=", "None", ",", "\n", "devices", "=", "None", ",", "feed", "=", "None", ",", "pass_y", "=", "False", ")", ":", "\n", "  ", "\"\"\"\n  Run attack on every example in a dataset.\n  :param sess: tf.Session\n  :param model: cleverhans.model.Model\n  :param x: numpy array containing input examples (e.g. MNIST().x_test )\n  :param y: numpy array containing example labels (e.g. MNIST().y_test )\n  :param attack: cleverhans.attack.Attack\n  :param attack_params: dictionary\n    passed to attack.generate as keyword arguments.\n  :param batch_size: Number of examples to use in a single evaluation batch.\n      If not specified, this function will use a reasonable guess and\n      may run out of memory.\n      When choosing the batch size, keep in mind that the batch will\n      be divided up evenly among available devices. If you can fit 128\n      examples in memory on one GPU and you have 8 GPUs, you probably\n      want to use a batch size of 1024 (unless a different batch size\n      runs faster with the ops you are using, etc.)\n  :param devices: An optional list of string device names to use.\n    If not specified, this function will use all visible GPUs.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param pass_y: bool. If true pass 'y' to `attack.generate`\n  :return:\n    an ndarray of bools indicating whether each example is correct\n    an ndarray of probabilities assigned to the prediction for each example\n  \"\"\"", "\n", "\n", "_check_x", "(", "x", ")", "\n", "_check_y", "(", "y", ")", "\n", "\n", "factory", "=", "_AttackFactory", "(", "model", ",", "attack", ",", "attack_params", ",", "pass_y", ")", "\n", "\n", "out", ",", "=", "batch_eval_multi_worker", "(", "sess", ",", "factory", ",", "[", "x", ",", "y", "]", ",", "batch_size", "=", "batch_size", ",", "\n", "devices", "=", "devices", ",", "feed", "=", "feed", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval_multi_worker": [[231, 412], ["cleverhans.canary.run_canary", "cleverhans.utils_tf.infer_devices", "len", "six.moves.range", "len", "six.moves.range", "six.moves.range", "int", "six.moves.range", "tuple", "len", "out.append", "six.moves.range", "numpy.ceil", "NotImplementedError", "evaluation.batch_eval_multi_worker.pad"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.canary.run_canary", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.infer_devices"], ["", "def", "batch_eval_multi_worker", "(", "sess", ",", "graph_factory", ",", "numpy_inputs", ",", "batch_size", "=", "None", ",", "\n", "devices", "=", "None", ",", "feed", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Generic computation engine for evaluating an expression across a whole\n  dataset, divided into batches.\n\n  This function assumes that the work can be parallelized with one worker\n  device handling one batch of data. If you need multiple devices per\n  batch, use `batch_eval`.\n\n  The tensorflow graph for multiple workers is large, so the first few\n  runs of the graph will be very slow. If you expect to run the graph\n  few times (few calls to `batch_eval_multi_worker` that each run few\n  batches) the startup cost might dominate the runtime, and it might be\n  preferable to use the single worker `batch_eval` just because its\n  startup cost will be lower.\n\n  :param sess: tensorflow Session\n  :param graph_factory: callable\n      When called, returns (tf_inputs, tf_outputs) where:\n          tf_inputs is a list of placeholders to feed from the dataset\n          tf_outputs is a list of tf tensors to calculate\n      Example: tf_inputs is [x, y] placeholders, tf_outputs is [accuracy].\n      This factory must make new tensors when called, rather than, e.g.\n      handing out a reference to existing tensors.\n      This factory must make exactly equivalent expressions every time\n      it is called, otherwise the results of `batch_eval` will vary\n      depending on how work is distributed to devices.\n      This factory must respect \"with tf.device()\" context managers\n      that are active when it is called, otherwise work will not be\n      distributed to devices correctly.\n  :param numpy_inputs:\n      A list of numpy arrays defining the dataset to be evaluated.\n      The list should have the same length as tf_inputs.\n      Each array should have the same number of examples (shape[0]).\n      Example: numpy_inputs is [MNIST().x_test, MNIST().y_test]\n  :param batch_size: Number of examples to use in a single evaluation batch.\n      If not specified, this function will use a reasonable guess and\n      may run out of memory.\n      When choosing the batch size, keep in mind that the batch will\n      be divided up evenly among available devices. If you can fit 128\n      examples in memory on one GPU and you have 8 GPUs, you probably\n      want to use a batch size of 1024 (unless a different batch size\n      runs faster with the ops you are using, etc.)\n  :param devices: List of devices to run on. If unspecified, uses all\n      available GPUs if any GPUS are available, otherwise uses CPUs.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :returns: List of numpy arrays corresponding to the outputs produced by\n      the graph_factory\n  \"\"\"", "\n", "canary", ".", "run_canary", "(", ")", "\n", "global", "_batch_eval_multi_worker_cache", "\n", "\n", "devices", "=", "infer_devices", "(", "devices", ")", "\n", "\n", "if", "batch_size", "is", "None", ":", "\n", "# For big models this might result in OOM and then the user", "\n", "# should just specify batch_size", "\n", "    ", "batch_size", "=", "len", "(", "devices", ")", "*", "DEFAULT_EXAMPLES_PER_DEVICE", "\n", "\n", "", "n", "=", "len", "(", "numpy_inputs", ")", "\n", "assert", "n", ">", "0", "\n", "m", "=", "numpy_inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "    ", "m_i", "=", "numpy_inputs", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "if", "m", "!=", "m_i", ":", "\n", "      ", "raise", "ValueError", "(", "\"All of numpy_inputs must have the same number of examples, but the first one has \"", "+", "str", "(", "m", ")", "\n", "+", "\" examples and input \"", "+", "str", "(", "i", ")", "+", "\" has \"", "+", "str", "(", "m_i", ")", "+", "\"examples.\"", ")", "\n", "", "", "out", "=", "[", "]", "\n", "\n", "replicated_tf_inputs", "=", "[", "]", "\n", "replicated_tf_outputs", "=", "[", "]", "\n", "p", "=", "None", "\n", "\n", "num_devices", "=", "len", "(", "devices", ")", "\n", "assert", "batch_size", "%", "num_devices", "==", "0", "\n", "device_batch_size", "=", "batch_size", "//", "num_devices", "\n", "\n", "cache_key", "=", "(", "graph_factory", ",", "tuple", "(", "devices", ")", ")", "\n", "if", "cache_key", "in", "_batch_eval_multi_worker_cache", ":", "\n", "# Retrieve graph for multi-GPU inference from cache.", "\n", "# This avoids adding tf ops to the graph", "\n", "    ", "packed", "=", "_batch_eval_multi_worker_cache", "[", "cache_key", "]", "\n", "replicated_tf_inputs", ",", "replicated_tf_outputs", "=", "packed", "\n", "p", "=", "len", "(", "replicated_tf_outputs", "[", "0", "]", ")", "\n", "assert", "p", ">", "0", "\n", "", "else", ":", "\n", "# This graph has not been built before.", "\n", "# Build it now.", "\n", "\n", "    ", "for", "device", "in", "devices", ":", "\n", "      ", "with", "tf", ".", "device", "(", "device", ")", ":", "\n", "        ", "tf_inputs", ",", "tf_outputs", "=", "graph_factory", "(", ")", "\n", "assert", "len", "(", "tf_inputs", ")", "==", "n", "\n", "if", "p", "is", "None", ":", "\n", "          ", "p", "=", "len", "(", "tf_outputs", ")", "\n", "assert", "p", ">", "0", "\n", "", "else", ":", "\n", "          ", "assert", "len", "(", "tf_outputs", ")", "==", "p", "\n", "", "replicated_tf_inputs", ".", "append", "(", "tf_inputs", ")", "\n", "replicated_tf_outputs", ".", "append", "(", "tf_outputs", ")", "\n", "", "", "del", "tf_inputs", "\n", "del", "tf_outputs", "\n", "# Store the result in the cache", "\n", "packed", "=", "replicated_tf_inputs", ",", "replicated_tf_outputs", "\n", "_batch_eval_multi_worker_cache", "[", "cache_key", "]", "=", "packed", "\n", "", "for", "_", "in", "range", "(", "p", ")", ":", "\n", "    ", "out", ".", "append", "(", "[", "]", ")", "\n", "", "flat_tf_outputs", "=", "[", "]", "\n", "for", "output", "in", "range", "(", "p", ")", ":", "\n", "    ", "for", "dev_idx", "in", "range", "(", "num_devices", ")", ":", "\n", "      ", "flat_tf_outputs", ".", "append", "(", "replicated_tf_outputs", "[", "dev_idx", "]", "[", "output", "]", ")", "\n", "\n", "# pad data to have # examples be multiple of batch size", "\n", "# we discard the excess later", "\n", "", "", "num_batches", "=", "int", "(", "np", ".", "ceil", "(", "float", "(", "m", ")", "/", "batch_size", ")", ")", "\n", "needed_m", "=", "num_batches", "*", "batch_size", "\n", "excess", "=", "needed_m", "-", "m", "\n", "if", "excess", ">", "m", ":", "\n", "    ", "raise", "NotImplementedError", "(", "(", "\"Your batch size (%(batch_size)d) is bigger\"", "\n", "\" than the dataset (%(m)d), this function is \"", "\n", "\"probably overkill.\"", ")", "%", "locals", "(", ")", ")", "\n", "\n", "", "def", "pad", "(", "array", ")", ":", "\n", "    ", "\"\"\"Pads an array with replicated examples to have `excess` more entries\"\"\"", "\n", "if", "excess", ">", "0", ":", "\n", "      ", "array", "=", "np", ".", "concatenate", "(", "(", "array", ",", "array", "[", ":", "excess", "]", ")", ",", "axis", "=", "0", ")", "\n", "", "return", "array", "\n", "", "numpy_inputs", "=", "[", "pad", "(", "numpy_input", ")", "for", "numpy_input", "in", "numpy_inputs", "]", "\n", "orig_m", "=", "m", "\n", "m", "=", "needed_m", "\n", "\n", "for", "start", "in", "range", "(", "0", ",", "m", ",", "batch_size", ")", ":", "\n", "    ", "batch", "=", "start", "//", "batch_size", "\n", "if", "batch", "%", "100", "==", "0", "and", "batch", ">", "0", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"Batch \"", "+", "str", "(", "batch", ")", ")", "\n", "\n", "# Compute batch start and end indices", "\n", "", "end", "=", "start", "+", "batch_size", "\n", "numpy_input_batches", "=", "[", "numpy_input", "[", "start", ":", "end", "]", "\n", "for", "numpy_input", "in", "numpy_inputs", "]", "\n", "feed_dict", "=", "{", "}", "\n", "for", "dev_idx", ",", "tf_inputs", "in", "enumerate", "(", "replicated_tf_inputs", ")", ":", "\n", "      ", "for", "tf_input", ",", "numpy_input", "in", "zip", "(", "tf_inputs", ",", "numpy_input_batches", ")", ":", "\n", "        ", "dev_start", "=", "dev_idx", "*", "device_batch_size", "\n", "dev_end", "=", "(", "dev_idx", "+", "1", ")", "*", "device_batch_size", "\n", "value", "=", "numpy_input", "[", "dev_start", ":", "dev_end", "]", "\n", "assert", "value", ".", "shape", "[", "0", "]", "==", "device_batch_size", "\n", "feed_dict", "[", "tf_input", "]", "=", "value", "\n", "", "", "if", "feed", "is", "not", "None", ":", "\n", "      ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "flat_output_batches", "=", "sess", ".", "run", "(", "flat_tf_outputs", ",", "feed_dict", "=", "feed_dict", ")", "\n", "for", "e", "in", "flat_output_batches", ":", "\n", "      ", "assert", "e", ".", "shape", "[", "0", "]", "==", "device_batch_size", ",", "e", ".", "shape", "\n", "\n", "", "output_batches", "=", "[", "]", "\n", "for", "output", "in", "range", "(", "p", ")", ":", "\n", "      ", "o_start", "=", "output", "*", "num_devices", "\n", "o_end", "=", "(", "output", "+", "1", ")", "*", "num_devices", "\n", "device_values", "=", "flat_output_batches", "[", "o_start", ":", "o_end", "]", "\n", "assert", "len", "(", "device_values", ")", "==", "num_devices", "\n", "output_batches", ".", "append", "(", "device_values", ")", "\n", "\n", "", "for", "out_elem", ",", "device_values", "in", "zip", "(", "out", ",", "output_batches", ")", ":", "\n", "      ", "assert", "len", "(", "device_values", ")", "==", "num_devices", ",", "(", "len", "(", "device_values", ")", ",", "\n", "num_devices", ")", "\n", "for", "device_value", "in", "device_values", ":", "\n", "        ", "assert", "device_value", ".", "shape", "[", "0", "]", "==", "device_batch_size", "\n", "", "out_elem", ".", "extend", "(", "device_values", ")", "\n", "\n", "", "", "out", "=", "[", "np", ".", "concatenate", "(", "x", ",", "axis", "=", "0", ")", "for", "x", "in", "out", "]", "\n", "for", "e", "in", "out", ":", "\n", "    ", "assert", "e", ".", "shape", "[", "0", "]", "==", "m", ",", "e", ".", "shape", "\n", "\n", "# Trim off the examples we used to pad up to batch size", "\n", "", "out", "=", "[", "e", "[", ":", "orig_m", "]", "for", "e", "in", "out", "]", "\n", "assert", "len", "(", "out", ")", "==", "p", ",", "(", "len", "(", "out", ")", ",", "p", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation.batch_eval": [[414, 489], ["len", "six.moves.range", "six.moves.range", "warnings.warn", "len", "out.append", "dict", "sess.run", "zip", "numpy.concatenate", "_logger.debug", "zip", "dict.update", "out_elem.append", "str"], "function", ["None"], ["", "def", "batch_eval", "(", "sess", ",", "tf_inputs", ",", "tf_outputs", ",", "numpy_inputs", ",", "batch_size", "=", "None", ",", "\n", "feed", "=", "None", ",", "\n", "args", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  A helper function that computes a tensor on numpy inputs by batches.\n  This version uses exactly the tensorflow graph constructed by the\n  caller, so the caller can place specific ops on specific devices\n  to implement model parallelism.\n  Most users probably prefer `batch_eval_multi_worker` which maps\n  a single-device expression to multiple devices in order to evaluate\n  faster by parallelizing across data.\n\n  :param sess: tf Session to use\n  :param tf_inputs: list of tf Placeholders to feed from the dataset\n  :param tf_outputs: list of tf tensors to calculate\n  :param numpy_inputs: list of numpy arrays defining the dataset\n  :param batch_size: int, batch size to use for evaluation\n      If not specified, this function will try to guess the batch size,\n      but might get an out of memory error or run the model with an\n      unsupported batch size, etc.\n  :param feed: An optional dictionary that is appended to the feeding\n           dictionary before the session runs. Can be used to feed\n           the learning phase of a Keras model for instance.\n  :param args: dict or argparse `Namespace` object.\n              Deprecated and included only for backwards compatibility.\n               Should contain `batch_size`\n  \"\"\"", "\n", "\n", "if", "args", "is", "not", "None", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"`args` is deprecated and will be removed on or \"", "\n", "\"after 2019-03-09. Pass `batch_size` directly.\"", ")", "\n", "if", "\"batch_size\"", "in", "args", ":", "\n", "      ", "assert", "batch_size", "is", "None", "\n", "batch_size", "=", "args", "[", "\"batch_size\"", "]", "\n", "\n", "", "", "if", "batch_size", "is", "None", ":", "\n", "    ", "batch_size", "=", "DEFAULT_EXAMPLES_PER_DEVICE", "\n", "\n", "", "n", "=", "len", "(", "numpy_inputs", ")", "\n", "assert", "n", ">", "0", "\n", "assert", "n", "==", "len", "(", "tf_inputs", ")", "\n", "m", "=", "numpy_inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "    ", "assert", "numpy_inputs", "[", "i", "]", ".", "shape", "[", "0", "]", "==", "m", "\n", "", "out", "=", "[", "]", "\n", "for", "_", "in", "tf_outputs", ":", "\n", "    ", "out", ".", "append", "(", "[", "]", ")", "\n", "", "for", "start", "in", "range", "(", "0", ",", "m", ",", "batch_size", ")", ":", "\n", "    ", "batch", "=", "start", "//", "batch_size", "\n", "if", "batch", "%", "100", "==", "0", "and", "batch", ">", "0", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"Batch \"", "+", "str", "(", "batch", ")", ")", "\n", "\n", "# Compute batch start and end indices", "\n", "", "start", "=", "batch", "*", "batch_size", "\n", "end", "=", "start", "+", "batch_size", "\n", "numpy_input_batches", "=", "[", "numpy_input", "[", "start", ":", "end", "]", "\n", "for", "numpy_input", "in", "numpy_inputs", "]", "\n", "cur_batch_size", "=", "numpy_input_batches", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "assert", "cur_batch_size", "<=", "batch_size", "\n", "for", "e", "in", "numpy_input_batches", ":", "\n", "      ", "assert", "e", ".", "shape", "[", "0", "]", "==", "cur_batch_size", "\n", "\n", "", "feed_dict", "=", "dict", "(", "zip", "(", "tf_inputs", ",", "numpy_input_batches", ")", ")", "\n", "if", "feed", "is", "not", "None", ":", "\n", "      ", "feed_dict", ".", "update", "(", "feed", ")", "\n", "", "numpy_output_batches", "=", "sess", ".", "run", "(", "tf_outputs", ",", "feed_dict", "=", "feed_dict", ")", "\n", "for", "e", "in", "numpy_output_batches", ":", "\n", "      ", "assert", "e", ".", "shape", "[", "0", "]", "==", "cur_batch_size", ",", "e", ".", "shape", "\n", "", "for", "out_elem", ",", "numpy_output_batch", "in", "zip", "(", "out", ",", "numpy_output_batches", ")", ":", "\n", "      ", "out_elem", ".", "append", "(", "numpy_output_batch", ")", "\n", "\n", "", "", "out", "=", "[", "np", ".", "concatenate", "(", "x", ",", "axis", "=", "0", ")", "for", "x", "in", "out", "]", "\n", "for", "e", "in", "out", ":", "\n", "    ", "assert", "e", ".", "shape", "[", "0", "]", "==", "m", ",", "e", ".", "shape", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_x": [[717, 723], ["isinstance", "TypeError"], "function", ["None"], ["def", "_check_x", "(", "x", ")", ":", "\n", "  ", "\"\"\"\n  Makes sure an `x` argument is a valid numpy dataset.\n  \"\"\"", "\n", "if", "not", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "    ", "raise", "TypeError", "(", "\"x must be a numpy array. Typically x contains \"", "\n", "\"the entire test set inputs.\"", ")", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.evaluation._check_y": [[726, 733], ["isinstance", "TypeError", "str", "type", "str"], "function", ["None"], ["", "", "def", "_check_y", "(", "y", ")", ":", "\n", "  ", "\"\"\"\n  Makes sure a `y` argument is a vliad numpy dataset.\n  \"\"\"", "\n", "if", "not", "isinstance", "(", "y", ",", "np", ".", "ndarray", ")", ":", "\n", "    ", "raise", "TypeError", "(", "\"y must be numpy array. Typically y contains \"", "\n", "\"the entire test set labels. Got \"", "+", "str", "(", "y", ")", "+", "\" of type \"", "+", "str", "(", "type", "(", "y", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_pytorch._py_func_with_gradient": [[11, 36], ["tensorflow.get_default_graph", "tensorflow.RegisterGradient", "tf.get_default_graph.gradient_override_map", "tensorflow.py_func", "random.getrandbits"], "function", ["None"], ["def", "_py_func_with_gradient", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "True", ",", "name", "=", "None", ",", "\n", "grad_func", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  PyFunc defined as given by Tensorflow\n  :param func: Custom Function\n  :param inp: Function Inputs\n  :param Tout: Ouput Type of out Custom Function\n  :param stateful: Calculate Gradients when stateful is True\n  :param name: Name of the PyFunction\n  :param grad: Custom Gradient Function\n  :return:\n  \"\"\"", "\n", "# Generate random name in order to avoid conflicts with inbuilt names", "\n", "rnd_name", "=", "'PyFuncGrad-'", "+", "'%0x'", "%", "getrandbits", "(", "30", "*", "4", ")", "\n", "\n", "# Register Tensorflow Gradient", "\n", "tf", ".", "RegisterGradient", "(", "rnd_name", ")", "(", "grad_func", ")", "\n", "\n", "# Get current graph", "\n", "g", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "\n", "# Add gradient override map", "\n", "with", "g", ".", "gradient_override_map", "(", "{", "\"PyFunc\"", ":", "rnd_name", ",", "\n", "\"PyFuncStateless\"", ":", "rnd_name", "}", ")", ":", "\n", "    ", "return", "tf", ".", "py_func", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_pytorch.convert_pytorch_model_to_tf": [[38, 89], ["torch.Tensor", "torch.cuda.is_available", "torch.autograd.Variable", "model", "torch_state[].data.cpu().numpy", "utils_pytorch.convert_pytorch_model_to_tf._fprop_fn"], "function", ["None"], ["", "", "def", "convert_pytorch_model_to_tf", "(", "model", ",", "out_dims", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Convert a pytorch model into a tensorflow op that allows backprop\n  :param model: A pytorch nn.Module object\n  :param out_dims: The number of output dimensions (classes) for the model\n  :return: A model function that maps an input (tf.Tensor) to the\n  output of the model (tf.Tensor)\n  \"\"\"", "\n", "torch_state", "=", "{", "\n", "'logits'", ":", "None", ",", "\n", "'x'", ":", "None", ",", "\n", "}", "\n", "if", "not", "out_dims", ":", "\n", "    ", "out_dims", "=", "list", "(", "model", ".", "modules", "(", ")", ")", "[", "-", "1", "]", ".", "out_features", "\n", "\n", "", "def", "_fprop_fn", "(", "x_np", ")", ":", "\n", "    ", "\"\"\"TODO: write this\"\"\"", "\n", "x_tensor", "=", "torch", ".", "Tensor", "(", "x_np", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "      ", "x_tensor", "=", "x_tensor", ".", "cuda", "(", ")", "\n", "", "torch_state", "[", "'x'", "]", "=", "Variable", "(", "x_tensor", ",", "requires_grad", "=", "True", ")", "\n", "torch_state", "[", "'logits'", "]", "=", "model", "(", "torch_state", "[", "'x'", "]", ")", "\n", "return", "torch_state", "[", "'logits'", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "def", "_bprop_fn", "(", "x_np", ",", "grads_in_np", ")", ":", "\n", "    ", "\"\"\"TODO: write this\"\"\"", "\n", "_fprop_fn", "(", "x_np", ")", "\n", "\n", "grads_in_tensor", "=", "torch", ".", "Tensor", "(", "grads_in_np", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "      ", "grads_in_tensor", "=", "grads_in_tensor", ".", "cuda", "(", ")", "\n", "\n", "# Run our backprop through our logits to our xs", "\n", "", "loss", "=", "torch", ".", "sum", "(", "torch_state", "[", "'logits'", "]", "*", "grads_in_tensor", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "return", "torch_state", "[", "'x'", "]", ".", "grad", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "\n", "", "def", "_tf_gradient_fn", "(", "op", ",", "grads_in", ")", ":", "\n", "    ", "\"\"\"TODO: write this\"\"\"", "\n", "return", "tf", ".", "py_func", "(", "_bprop_fn", ",", "[", "op", ".", "inputs", "[", "0", "]", ",", "grads_in", "]", ",", "\n", "Tout", "=", "[", "tf", ".", "float32", "]", ")", "\n", "\n", "", "def", "tf_model_fn", "(", "x_op", ")", ":", "\n", "    ", "\"\"\"TODO: write this\"\"\"", "\n", "out", "=", "_py_func_with_gradient", "(", "_fprop_fn", ",", "[", "x_op", "]", ",", "Tout", "=", "[", "tf", ".", "float32", "]", ",", "\n", "stateful", "=", "True", ",", "\n", "grad_func", "=", "_tf_gradient_fn", ")", "[", "0", "]", "\n", "out", ".", "set_shape", "(", "[", "None", ",", "out_dims", "]", ")", "\n", "return", "out", "\n", "\n", "", "return", "tf_model_fn", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function": [[15, 46], ["distutils.version.LooseVersion", "distutils.version.LooseVersion", "warnings.warn", "distutils.version.LooseVersion", "tensorflow.tf.reduce_sum", "tensorflow.tf.reduce_max", "tensorflow.tf.reduce_min", "tensorflow.tf.reduce_mean", "tensorflow.tf.reduce_prod", "tensorflow.tf.reduce_any"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_prod", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_any"], ["def", "reduce_function", "(", "op_func", ",", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Handler function for Tensorflow depreciation of keep_dims for tf 1.8\n  and above, but tf 1.4 requires keep_dims\n  :param op_func: expects the function to handle eg: tf.reduce_sum.\n  :param input_tensor: The tensor to reduce. Should have numeric type.\n  :param axis: The dimensions to reduce. If None (the default),\n          reduces all dimensions. Must be in the range\n          [-rank(input_tensor), rank(input_tensor)).\n  :param keepdims: If true, retains reduced dimensions with length 1.\n  :param name: A name for the operation (optional).\n  :param reduction_indices: The old (deprecated) name for axis.\n  :param keep_dims: Deprecated alias for keepdims.\n  :return: outputs same value as op_func.\n  \"\"\"", "\n", "\n", "if", "LooseVersion", "(", "tf", ".", "__version__", ")", "<", "LooseVersion", "(", "'1.8.0'", ")", ":", "\n", "    ", "warning", "=", "\"Running on tensorflow version \"", "+", "LooseVersion", "(", "tf", ".", "__version__", ")", ".", "vstring", "+", "\". Support for this version in CleverHans is deprecated \"", "+", "\"and may be removed on or after 2019-01-26\"", "\n", "warnings", ".", "warn", "(", "warning", ")", "\n", "out", "=", "op_func", "(", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keep_dims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "", "else", ":", "\n", "    ", "out", "=", "op_func", "(", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum": [[48, 56], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_sum", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_sum to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_sum", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max": [[58, 66], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_max", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_max to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_max", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min": [[68, 76], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_min", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_min to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_min", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean": [[78, 86], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_mean", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_mean to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_mean", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_prod": [[88, 96], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_prod", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_prod to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_prod", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_any": [[98, 106], ["compat.reduce_function"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_function"], ["", "def", "reduce_any", "(", "input_tensor", ",", "axis", "=", "None", ",", "keepdims", "=", "None", ",", "\n", "name", "=", "None", ",", "reduction_indices", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around the tf.reduce_any to handle argument keep_dims\n  \"\"\"", "\n", "return", "reduce_function", "(", "tf", ".", "reduce_any", ",", "input_tensor", ",", "axis", "=", "axis", ",", "\n", "keepdims", "=", "keepdims", ",", "name", "=", "name", ",", "\n", "reduction_indices", "=", "reduction_indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits": [[108, 139], ["ValueError", "ValueError", "tensorflow.stop_gradient", "tensorflow.nn.softmax_cross_entropy_with_logits_v2", "warnings.warn", "tensorflow.nn.softmax_cross_entropy_with_logits", "distutils.version.LooseVersion"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits"], ["", "def", "softmax_cross_entropy_with_logits", "(", "sentinel", "=", "None", ",", "\n", "labels", "=", "None", ",", "\n", "logits", "=", "None", ",", "\n", "dim", "=", "-", "1", ")", ":", "\n", "  ", "\"\"\"\n  Wrapper around tf.nn.softmax_cross_entropy_with_logits_v2 to handle\n  deprecated warning\n  \"\"\"", "\n", "# Make sure that all arguments were passed as named arguments.", "\n", "if", "sentinel", "is", "not", "None", ":", "\n", "    ", "name", "=", "\"softmax_cross_entropy_with_logits\"", "\n", "raise", "ValueError", "(", "\"Only call `%s` with \"", "\n", "\"named arguments (labels=..., logits=..., ...)\"", "\n", "%", "name", ")", "\n", "", "if", "labels", "is", "None", "or", "logits", "is", "None", ":", "\n", "    ", "raise", "ValueError", "(", "\"Both labels and logits must be provided.\"", ")", "\n", "\n", "", "try", ":", "\n", "    ", "labels", "=", "tf", ".", "stop_gradient", "(", "labels", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits_v2", "(", "\n", "labels", "=", "labels", ",", "logits", "=", "logits", ",", "dim", "=", "dim", ")", "\n", "", "except", "AttributeError", ":", "\n", "    ", "warning", "=", "\"Running on tensorflow version \"", "+", "LooseVersion", "(", "tf", ".", "__version__", ")", ".", "vstring", "+", "\". Support for this version in CleverHans is deprecated \"", "+", "\"and may be removed on or after 2019-01-26\"", "\n", "warnings", ".", "warn", "(", "warning", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "labels", ",", "logits", "=", "logits", ",", "dim", "=", "dim", ")", "\n", "\n", "", "return", "loss", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.lbfgs.LBFGS.__init__": [[28, 43], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "cleverhans.model.wrapper_warning", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'probs'", ")", "\n", "\n", "", "super", "(", "LBFGS", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'y_target'", ",", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'batch_size'", ",", "'binary_search_steps'", ",", "'max_iterations'", ",", "\n", "'initial_const'", ",", "'clip_min'", ",", "'clip_max'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.lbfgs.LBFGS.generate": [[45, 71], ["lbfgs.LBFGS.parse_params", "lbfgs.LBFGS.get_or_guess_labels", "lbfgs.LBFGS_impl", "tensorflow.py_func", "tensorflow.py_func.set_shape", "lbfgs.LBFGS.model.get_logits", "numpy.array", "x.get_shape", "lbfgs.LBFGS_impl.attack"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param x: (required) A tensor with the inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "assert", "self", ".", "sess", "is", "not", "None", ",", "'Cannot use `generate` when no `sess` was provided'", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "_", ",", "nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "\n", "attack", "=", "LBFGS_impl", "(", "\n", "self", ".", "sess", ",", "x", ",", "self", ".", "model", ".", "get_logits", "(", "x", ")", ",", "self", ".", "y_target", ",", "\n", "self", ".", "binary_search_steps", ",", "self", ".", "max_iterations", ",", "self", ".", "initial_const", ",", "\n", "self", ".", "clip_min", ",", "self", ".", "clip_max", ",", "nb_classes", ",", "self", ".", "batch_size", ")", "\n", "\n", "def", "lbfgs_wrap", "(", "x_val", ",", "y_val", ")", ":", "\n", "      ", "return", "np", ".", "array", "(", "attack", ".", "attack", "(", "x_val", ",", "y_val", ")", ",", "dtype", "=", "self", ".", "np_dtype", ")", "\n", "\n", "", "wrap", "=", "tf", ".", "py_func", "(", "lbfgs_wrap", ",", "[", "x", ",", "self", ".", "y_target", "]", ",", "self", ".", "tf_dtype", ")", "\n", "wrap", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "\n", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.lbfgs.LBFGS.parse_params": [[72, 102], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "y_target", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "binary_search_steps", "=", "5", ",", "\n", "max_iterations", "=", "1000", ",", "\n", "initial_const", "=", "1e-2", ",", "\n", "clip_min", "=", "0", ",", "\n", "clip_max", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    :param y_target: (optional) A tensor with the one-hot target labels.\n    :param batch_size: The number of inputs to include in a batch and\n                       process simultaneously.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the purturbation\n                                and cross-entropy loss of classification.\n    :param max_iterations: The maximum number of iterations.\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the perturbation\n                          and cross-entropy loss of the classification.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.lbfgs.LBFGS_impl.__init__": [[105, 156], ["tuple", "tensorflow.Variable", "tensorflow.Variable", "cleverhans.compat.softmax_cross_entropy_with_logits", "cleverhans.compat.reduce_sum", "tensorflow.gradients", "numpy.zeros", "numpy.zeros", "tensorflow.square", "cleverhans.compat.reduce_sum", "list", "lbfgs.LBFGS_impl.x.get_shape().as_list", "lbfgs.LBFGS_impl.x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["  ", "def", "__init__", "(", "self", ",", "sess", ",", "x", ",", "logits", ",", "targeted_label", ",", "\n", "binary_search_steps", ",", "max_iterations", ",", "initial_const", ",", "clip_min", ",", "\n", "clip_max", ",", "nb_classes", ",", "batch_size", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param sess: a TF session.\n    :param x: A tensor with the inputs.\n    :param logits: A tensor with model's output logits.\n    :param targeted_label: A tensor with the target labels.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the purturbation\n                                and cross-entropy loss of classification.\n    :param max_iterations: The maximum number of iterations.\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the purturbation\n                          and cross-entropy loss of the classification.\n    :param clip_min: Minimum input component value\n    :param clip_max: Maximum input component value\n    :param num_labels: The number of classes in the model's output.\n    :param batch_size: Number of attacks to run simultaneously.\n\n    \"\"\"", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "logits", "=", "logits", "\n", "assert", "logits", ".", "op", ".", "type", "!=", "'Softmax'", "\n", "self", ".", "targeted_label", "=", "targeted_label", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "self", ".", "repeat", "=", "self", ".", "binary_search_steps", ">=", "10", "\n", "self", ".", "shape", "=", "tuple", "(", "[", "self", ".", "batch_size", "]", "+", "\n", "list", "(", "self", ".", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", ")", "\n", "self", ".", "ori_img", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "self", ".", "shape", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'ori_img'", ")", "\n", "self", ".", "const", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", ",", "dtype", "=", "tf_dtype", ",", "name", "=", "'const'", ")", "\n", "\n", "self", ".", "score", "=", "softmax_cross_entropy_with_logits", "(", "\n", "labels", "=", "self", ".", "targeted_label", ",", "logits", "=", "self", ".", "logits", ")", "\n", "self", ".", "l2dist", "=", "reduce_sum", "(", "tf", ".", "square", "(", "self", ".", "x", "-", "self", ".", "ori_img", ")", ")", "\n", "# small self.const will result small adversarial perturbation", "\n", "self", ".", "loss", "=", "reduce_sum", "(", "self", ".", "score", "*", "self", ".", "const", ")", "+", "self", ".", "l2dist", "\n", "self", ".", "grad", ",", "=", "tf", ".", "gradients", "(", "self", ".", "loss", ",", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.lbfgs.LBFGS_impl.attack": [[157, 264], ["numpy.clip", "numpy.zeros", "list", "numpy.copy", "range", "numpy.array", "lbfgs.LBFGS_impl.sess.run", "lbfgs.LBFGS_impl.sess.run", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "zip", "_logger.debug", "fmin_l_bfgs_b", "adv_x.reshape.reshape.reshape", "numpy.atleast_1d", "_logger.debug", "numpy.zeros", "range", "enumerate", "range", "_logger.debug", "numpy.array", "numpy.mean", "_logger.debug", "lbfgs.LBFGS_impl.flatten().astype", "clip_min.flatten", "clip_max.flatten", "numpy.clip.flatten().astype", "cleverhans.utils_tf.model_argmax", "numpy.sum", "zip", "sum", "numpy.sqrt", "numpy.amax", "numpy.amin", "numpy.square", "numpy.argmax", "min", "max", "adv_x.reshape.reshape.reshape", "adv_x.reshape.reshape.reshape", "lbfgs.LBFGS_impl.flatten", "numpy.clip.flatten", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tfe.model_argmax"], ["", "def", "attack", "(", "self", ",", "x_val", ",", "targets", ")", ":", "\n", "    ", "\"\"\"\n    Perform the attack on the given instance for the given targets.\n    \"\"\"", "\n", "\n", "def", "lbfgs_objective", "(", "adv_x", ",", "self", ",", "targets", ",", "oimgs", ",", "CONST", ")", ":", "\n", "# returns the function value and the gradient for fmin_l_bfgs_b", "\n", "      ", "loss", "=", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "loss", ",", "\n", "feed_dict", "=", "{", "\n", "self", ".", "x", ":", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", ",", "\n", "self", ".", "targeted_label", ":", "targets", ",", "\n", "self", ".", "ori_img", ":", "oimgs", ",", "\n", "self", ".", "const", ":", "CONST", "\n", "}", ")", "\n", "grad", "=", "self", ".", "sess", ".", "run", "(", "\n", "self", ".", "grad", ",", "\n", "feed_dict", "=", "{", "\n", "self", ".", "x", ":", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", ",", "\n", "self", ".", "targeted_label", ":", "targets", ",", "\n", "self", ".", "ori_img", ":", "oimgs", ",", "\n", "self", ".", "const", ":", "CONST", "\n", "}", ")", "\n", "return", "loss", ",", "grad", ".", "flatten", "(", ")", ".", "astype", "(", "float", ")", "\n", "\n", "# begin the main part for the attack", "\n", "", "from", "scipy", ".", "optimize", "import", "fmin_l_bfgs_b", "\n", "oimgs", "=", "np", ".", "clip", "(", "x_val", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "CONST", "=", "np", ".", "ones", "(", "self", ".", "batch_size", ")", "*", "self", ".", "initial_const", "\n", "\n", "# set the lower and upper bounds accordingly", "\n", "lower_bound", "=", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", "\n", "upper_bound", "=", "np", ".", "ones", "(", "self", ".", "batch_size", ")", "*", "1e10", "\n", "\n", "# set the box constraints for the optimization function", "\n", "clip_min", "=", "self", ".", "clip_min", "*", "np", ".", "ones", "(", "oimgs", ".", "shape", "[", ":", "]", ")", "\n", "clip_max", "=", "self", ".", "clip_max", "*", "np", ".", "ones", "(", "oimgs", ".", "shape", "[", ":", "]", ")", "\n", "clip_bound", "=", "list", "(", "zip", "(", "clip_min", ".", "flatten", "(", ")", ",", "clip_max", ".", "flatten", "(", ")", ")", ")", "\n", "\n", "# placeholders for the best l2 and instance attack found so far", "\n", "o_bestl2", "=", "[", "1e10", "]", "*", "self", ".", "batch_size", "\n", "o_bestattack", "=", "np", ".", "copy", "(", "oimgs", ")", "\n", "\n", "for", "outer_step", "in", "range", "(", "self", ".", "binary_search_steps", ")", ":", "\n", "      ", "_logger", ".", "debug", "(", "\"  Binary search step %s of %s\"", ",", "\n", "outer_step", ",", "self", ".", "binary_search_steps", ")", "\n", "\n", "# The last iteration (if we run many steps) repeat the search once.", "\n", "if", "self", ".", "repeat", "and", "outer_step", "==", "self", ".", "binary_search_steps", "-", "1", ":", "\n", "        ", "CONST", "=", "upper_bound", "\n", "\n", "# optimization function", "\n", "", "adv_x", ",", "_", ",", "__", "=", "fmin_l_bfgs_b", "(", "\n", "lbfgs_objective", ",", "\n", "oimgs", ".", "flatten", "(", ")", ".", "astype", "(", "float", ")", ",", "\n", "args", "=", "(", "self", ",", "targets", ",", "oimgs", ",", "CONST", ")", ",", "\n", "bounds", "=", "clip_bound", ",", "\n", "maxiter", "=", "self", ".", "max_iterations", ",", "\n", "iprint", "=", "0", ")", "\n", "\n", "adv_x", "=", "adv_x", ".", "reshape", "(", "oimgs", ".", "shape", ")", "\n", "assert", "np", ".", "amax", "(", "adv_x", ")", "<=", "self", ".", "clip_max", "and", "np", ".", "amin", "(", "adv_x", ")", ">=", "self", ".", "clip_min", ",", "'fmin_l_bfgs_b returns are invalid'", "\n", "\n", "# adjust the best result (i.e., the adversarial example with the", "\n", "# smallest perturbation in terms of L_2 norm) found so far", "\n", "preds", "=", "np", ".", "atleast_1d", "(", "\n", "utils_tf", ".", "model_argmax", "(", "self", ".", "sess", ",", "self", ".", "x", ",", "self", ".", "logits", ",", "\n", "adv_x", ")", ")", "\n", "_logger", ".", "debug", "(", "\"predicted labels are %s\"", ",", "preds", ")", "\n", "\n", "l2s", "=", "np", ".", "zeros", "(", "self", ".", "batch_size", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "        ", "l2s", "[", "i", "]", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "adv_x", "[", "i", "]", "-", "oimgs", "[", "i", "]", ")", ")", "\n", "\n", "", "for", "e", ",", "(", "l2", ",", "pred", ",", "ii", ")", "in", "enumerate", "(", "zip", "(", "l2s", ",", "preds", ",", "adv_x", ")", ")", ":", "\n", "        ", "if", "l2", "<", "o_bestl2", "[", "e", "]", "and", "pred", "==", "np", ".", "argmax", "(", "targets", "[", "e", "]", ")", ":", "\n", "          ", "o_bestl2", "[", "e", "]", "=", "l2", "\n", "o_bestattack", "[", "e", "]", "=", "ii", "\n", "\n", "# adjust the constant as needed", "\n", "", "", "for", "e", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "        ", "if", "preds", "[", "e", "]", "==", "np", ".", "argmax", "(", "targets", "[", "e", "]", ")", ":", "\n", "# success, divide const by two", "\n", "          ", "upper_bound", "[", "e", "]", "=", "min", "(", "upper_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "", "else", ":", "\n", "# failure, either multiply by 10 if no solution found yet", "\n", "#          or do binary search with the known upper bound", "\n", "          ", "lower_bound", "[", "e", "]", "=", "max", "(", "lower_bound", "[", "e", "]", ",", "CONST", "[", "e", "]", ")", "\n", "if", "upper_bound", "[", "e", "]", "<", "1e9", ":", "\n", "            ", "CONST", "[", "e", "]", "=", "(", "lower_bound", "[", "e", "]", "+", "upper_bound", "[", "e", "]", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "CONST", "[", "e", "]", "*=", "10", "\n", "\n", "", "", "", "_logger", ".", "debug", "(", "\"  Successfully generated adversarial examples \"", "\n", "\"on %s of %s instances.\"", ",", "\n", "sum", "(", "upper_bound", "<", "1e9", ")", ",", "self", ".", "batch_size", ")", "\n", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "mean", "=", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "o_bestl2", "[", "o_bestl2", "<", "1e9", "]", ")", ")", "\n", "_logger", ".", "debug", "(", "\"   Mean successful distortion: {:.4g}\"", ".", "format", "(", "mean", ")", ")", "\n", "\n", "# return the best solution found", "\n", "", "o_bestl2", "=", "np", ".", "array", "(", "o_bestl2", ")", "\n", "return", "o_bestattack", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.semantic.Semantic.__init__": [[26, 34], ["cleverhans.attacks.attack.Attack.__init__", "hasattr"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "center", ",", "max_val", "=", "1.", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "Semantic", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "center", "=", "center", "\n", "self", ".", "max_val", "=", "max_val", "\n", "if", "hasattr", "(", "model", ",", "'dataset_factory'", ")", ":", "\n", "      ", "if", "'center'", "in", "model", ".", "dataset_factory", ".", "kwargs", ":", "\n", "        ", "assert", "center", "==", "model", ".", "dataset_factory", ".", "kwargs", "[", "'center'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.semantic.Semantic.generate": [[35, 39], ["None"], "methods", ["None"], ["", "", "", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "self", ".", "center", ":", "\n", "      ", "return", "-", "x", "\n", "", "return", "self", ".", "max_val", "-", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.noise.Noise.__init__": [[31, 37], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "super", "(", "Noise", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", "=", "sess", ",", "dtypestr", "=", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'clip_min'", ",", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'ord'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.noise.Noise.generate": [[38, 58], ["noise.Noise.parse_params", "tensorflow.random_uniform", "NotImplementedError", "tensorflow.shape", "tensorflow.clip_by_value"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "if", "self", ".", "ord", "!=", "np", ".", "inf", ":", "\n", "      ", "raise", "NotImplementedError", "(", "self", ".", "ord", ")", "\n", "", "eta", "=", "tf", ".", "random_uniform", "(", "tf", ".", "shape", "(", "x", ")", ",", "-", "self", ".", "eps", ",", "self", ".", "eps", ",", "\n", "dtype", "=", "self", ".", "tf_dtype", ")", "\n", "adv_x", "=", "x", "+", "eta", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "or", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "assert", "self", ".", "clip_min", "is", "not", "None", "and", "self", ".", "clip_max", "is", "not", "None", "\n", "adv_x", "=", "tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.noise.Noise.parse_params": [[59, 93], ["ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "0.3", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float) maximum distortion of adversarial example\n                compared to original input\n    :param ord: (optional) Order of the norm (mimics Numpy).\n                Possible values: np.inf\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "\n", "# Save attack-specific parameters", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be np.inf\"", ")", "\n", "", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.elastic_net_method.ElasticNetMethod.__init__": [[26, 44], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "cleverhans.model.wrapper_warning_logits", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning_logits"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning_logits", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'logits'", ")", "\n", "\n", "", "super", "(", "ElasticNetMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'y'", ",", "'y_target'", ")", "\n", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'beta'", ",", "'decision_rule'", ",", "'batch_size'", ",", "'confidence'", ",", "\n", "'targeted'", ",", "'learning_rate'", ",", "'binary_search_steps'", ",", "\n", "'max_iterations'", ",", "'abort_early'", ",", "'initial_const'", ",", "'clip_min'", ",", "\n", "'clip_max'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.elastic_net_method.ElasticNetMethod.generate": [[46, 76], ["elastic_net_method.ElasticNetMethod.parse_params", "elastic_net_method.ElasticNetMethod.get_or_guess_labels", "EAD", "tensorflow.py_func", "tensorflow.py_func.set_shape", "numpy.array", "x.get_shape", "x.get_shape().as_list", "EAD.attack", "x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param x: (required) A tensor with the inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "assert", "self", ".", "sess", "is", "not", "None", ",", "'Cannot use `generate` when no `sess` was provided'", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "from", "cleverhans", ".", "attacks_tf", "import", "ElasticNetMethod", "as", "EAD", "\n", "labels", ",", "nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "\n", "attack", "=", "EAD", "(", "self", ".", "sess", ",", "self", ".", "model", ",", "self", ".", "beta", ",", "\n", "self", ".", "decision_rule", ",", "self", ".", "batch_size", ",", "self", ".", "confidence", ",", "\n", "'y_target'", "in", "kwargs", ",", "self", ".", "learning_rate", ",", "\n", "self", ".", "binary_search_steps", ",", "self", ".", "max_iterations", ",", "\n", "self", ".", "abort_early", ",", "self", ".", "initial_const", ",", "self", ".", "clip_min", ",", "\n", "self", ".", "clip_max", ",", "nb_classes", ",", "\n", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "\n", "def", "ead_wrap", "(", "x_val", ",", "y_val", ")", ":", "\n", "      ", "return", "np", ".", "array", "(", "attack", ".", "attack", "(", "x_val", ",", "y_val", ")", ",", "dtype", "=", "self", ".", "np_dtype", ")", "\n", "\n", "", "wrap", "=", "tf", ".", "py_func", "(", "ead_wrap", ",", "[", "x", ",", "labels", "]", ",", "self", ".", "tf_dtype", ")", "\n", "wrap", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "\n", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.elastic_net_method.ElasticNetMethod.parse_params": [[77, 149], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "y", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "beta", "=", "1e-2", ",", "\n", "decision_rule", "=", "'EN'", ",", "\n", "batch_size", "=", "1", ",", "\n", "confidence", "=", "0", ",", "\n", "learning_rate", "=", "1e-2", ",", "\n", "binary_search_steps", "=", "9", ",", "\n", "max_iterations", "=", "1000", ",", "\n", "abort_early", "=", "False", ",", "\n", "initial_const", "=", "1e-3", ",", "\n", "clip_min", "=", "0", ",", "\n", "clip_max", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    :param y: (optional) A tensor with the true labels for an untargeted\n              attack. If None (and y_target is None) then use the\n              original labels the classifier assigns.\n    :param y_target: (optional) A tensor with the target labels for a\n              targeted attack.\n    :param beta: Trades off L2 distortion with L1 distortion: higher\n                 produces examples with lower L1 distortion, at the\n                 cost of higher L2 (and typically Linf) distortion\n    :param decision_rule: EN or L1. Select final adversarial example from\n                          all successful examples based on the least\n                          elastic-net or L1 distortion criterion.\n    :param confidence: Confidence of adversarial examples: higher produces\n                       examples with larger l2 distortion, but more\n                       strongly classified as adversarial.\n    :param batch_size: Number of attacks to run simultaneously.\n    :param learning_rate: The learning rate for the attack algorithm.\n                          Smaller values produce better results but are\n                          slower to converge.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the perturbation\n                                and confidence of the classification. Set\n                                'initial_const' to a large value and fix\n                                this param to 1 for speed.\n    :param max_iterations: The maximum number of iterations. Setting this\n                           to a larger value will produce lower distortion\n                           results. Using only a few iterations requires\n                           a larger learning rate, and will produce larger\n                           distortion results.\n    :param abort_early: If true, allows early abort when the total\n                        loss starts to increase (greatly speeds up attack,\n                        but hurts performance, particularly on ImageNet)\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the perturbation\n                          and confidence of classification.\n                          If binary_search_steps is large, the initial\n                          constant is not important. A smaller value of\n                          this constant gives lower distortion results.\n                          For computational efficiency, fix\n                          binary_search_steps to 1 and set this param\n                          to a large value.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "\n", "# ignore the y and y_target argument", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "decision_rule", "=", "decision_rule", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "abort_early", "=", "abort_early", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.virtual_adversarial_method.VirtualAdversarialMethod.__init__": [[23, 37], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "cleverhans.model.wrapper_warning_logits", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning_logits"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning_logits", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'logits'", ")", "\n", "\n", "", "super", "(", "VirtualAdversarialMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "\n", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'xi'", ",", "'clip_min'", ",", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'num_iterations'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.virtual_adversarial_method.VirtualAdversarialMethod.generate": [[38, 57], ["virtual_adversarial_method.VirtualAdversarialMethod.parse_params", "virtual_adversarial_method.vatm", "virtual_adversarial_method.VirtualAdversarialMethod.model.get_logits"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.virtual_adversarial_method.vatm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "return", "vatm", "(", "\n", "self", ".", "model", ",", "\n", "x", ",", "\n", "self", ".", "model", ".", "get_logits", "(", "x", ")", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "num_iterations", "=", "self", ".", "num_iterations", ",", "\n", "xi", "=", "self", ".", "xi", ",", "\n", "clip_min", "=", "self", ".", "clip_min", ",", "\n", "clip_max", "=", "self", ".", "clip_max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.virtual_adversarial_method.VirtualAdversarialMethod.parse_params": [[58, 100], ["warnings.warn", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "2.0", ",", "\n", "nb_iter", "=", "None", ",", "\n", "xi", "=", "1e-6", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "num_iterations", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float )the epsilon (input variation parameter)\n    :param nb_iter: (optional) the number of iterations\n      Defaults to 1 if not specified\n    :param xi: (optional float) the finite difference parameter\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    :param num_iterations: Deprecated alias for `nb_iter`\n    \"\"\"", "\n", "# Save attack-specific parameters", "\n", "self", ".", "eps", "=", "eps", "\n", "if", "num_iterations", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"`num_iterations` is deprecated. Switch to `nb_iter`.\"", "\n", "\" The old name will be removed on or after 2019-04-26.\"", ")", "\n", "# Note: when we remove the deprecated alias, we can put the default", "\n", "# value of 1 for nb_iter back in the method signature", "\n", "assert", "nb_iter", "is", "None", "\n", "nb_iter", "=", "num_iterations", "\n", "", "del", "num_iterations", "\n", "if", "nb_iter", "is", "None", ":", "\n", "      ", "nb_iter", "=", "1", "\n", "", "self", ".", "num_iterations", "=", "nb_iter", "\n", "self", ".", "xi", "=", "xi", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.virtual_adversarial_method.vatm": [[101, 141], ["vatm_tf"], "function", ["None"], ["", "", "def", "vatm", "(", "model", ",", "\n", "x", ",", "\n", "logits", ",", "\n", "eps", ",", "\n", "back", "=", "'tf'", ",", "\n", "num_iterations", "=", "1", ",", "\n", "xi", "=", "1e-6", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  A wrapper for the perturbation methods used for virtual adversarial\n  training : https://arxiv.org/abs/1507.00677\n  It calls the right function, depending on the\n  user's backend.\n\n  :param model: the model which returns the network unnormalized logits\n  :param x: the input placeholder\n  :param logits: the model's unnormalized output tensor\n  :param eps: the epsilon (input variation parameter)\n  :param num_iterations: the number of iterations\n  :param xi: the finite difference parameter\n  :param clip_min: optional parameter that can be used to set a minimum\n                  value for components of the example returned\n  :param clip_max: optional parameter that can be used to set a maximum\n                  value for components of the example returned\n  :return: a tensor for the adversarial example\n\n  \"\"\"", "\n", "assert", "back", "==", "'tf'", "\n", "# Compute VATM using TensorFlow", "\n", "from", "cleverhans", ".", "attacks_tf", "import", "vatm", "as", "vatm_tf", "\n", "return", "vatm_tf", "(", "\n", "model", ",", "\n", "x", ",", "\n", "logits", ",", "\n", "eps", ",", "\n", "num_iterations", "=", "num_iterations", ",", "\n", "xi", "=", "xi", ",", "\n", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.__init__": [[28, 40], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "TypeError", "cleverhans.attacks.projected_gradient_descent.ProjectedGradientDescent", "str", "type"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "base_attacker", "=", "None", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Model must be cleverhans.model.Model, got \"", "+", "\n", "str", "(", "type", "(", "model", ")", ")", ")", "\n", "\n", "", "super", "(", "MaxConfidence", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ")", "\n", "if", "base_attacker", "is", "None", ":", "\n", "      ", "self", ".", "base_attacker", "=", "ProjectedGradientDescent", "(", "model", ",", "sess", "=", "sess", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "base_attacker", "=", "base_attacker", "\n", "", "self", ".", "structural_kwargs", "=", "self", ".", "base_attacker", ".", "structural_kwargs", "\n", "self", ".", "feedable_kwargs", "=", "self", ".", "base_attacker", ".", "feedable_kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.generate": [[41, 54], ["max_confidence.MaxConfidence.parse_params", "max_confidence.MaxConfidence.get_or_guess_labels", "max_confidence.MaxConfidence.attack"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: Keyword arguments for the base attacker\n    \"\"\"", "\n", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "labels", ",", "_nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "adv_x", "=", "self", ".", "attack", "(", "x", ",", "labels", ")", "\n", "\n", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.parse_params": [[55, 63], ["len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "y", "=", "None", ",", "nb_classes", "=", "10", ",", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "y", "=", "y", "\n", "self", ".", "nb_classes", "=", "nb_classes", "\n", "self", ".", "params", "=", "kwargs", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack": [[64, 106], ["tensorflow.argmax", "tensorflow.concat", "tensorflow.concat", "max_confidence.MaxConfidence.attack_class", "max_confidence.MaxConfidence.model.get_probs", "tensorflow.split", "tensorflow.split", "range", "tensorflow.concat", "tensorflow.argmax", "tensorflow.one_hot", "tensorflow.split", "sum", "tensorflow.shape", "tensorflow.to_float", "tensorflow.reduce_max", "tensorflow.argmax", "tensorflow.to_float", "prob_cls.append", "tensorflow.reshape", "tensorflow.one_hot", "range", "tensorflow.not_equal", "tensorflow.expand_dims", "len", "zip", "tensorflow.ones", "x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack_class", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["", "def", "attack", "(", "self", ",", "x", ",", "true_y", ")", ":", "\n", "    ", "adv_x_cls", "=", "[", "]", "\n", "prob_cls", "=", "[", "]", "\n", "m", "=", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", "\n", "true_y_idx", "=", "tf", ".", "argmax", "(", "true_y", ",", "axis", "=", "1", ")", "\n", "\n", "expanded_x", "=", "tf", ".", "concat", "(", "[", "x", "]", "*", "self", ".", "nb_classes", ",", "axis", "=", "0", ")", "\n", "target_ys", "=", "[", "tf", ".", "to_float", "(", "tf", ".", "one_hot", "(", "tf", ".", "ones", "(", "m", ",", "dtype", "=", "tf", ".", "int32", ")", "*", "cls", ",", "\n", "self", ".", "nb_classes", ")", ")", "\n", "for", "cls", "in", "range", "(", "self", ".", "nb_classes", ")", "]", "\n", "target_y", "=", "tf", ".", "concat", "(", "target_ys", ",", "axis", "=", "0", ")", "\n", "adv_x_cls", "=", "self", ".", "attack_class", "(", "expanded_x", ",", "target_y", ")", "\n", "expanded_all_probs", "=", "self", ".", "model", ".", "get_probs", "(", "adv_x_cls", ")", "\n", "\n", "adv_x_list", "=", "tf", ".", "split", "(", "adv_x_cls", ",", "self", ".", "nb_classes", ")", "\n", "all_probs_list", "=", "tf", ".", "split", "(", "expanded_all_probs", ",", "self", ".", "nb_classes", ")", "\n", "\n", "for", "cls", "in", "range", "(", "self", ".", "nb_classes", ")", ":", "\n", "      ", "target_y", "=", "target_ys", "[", "cls", "]", "\n", "all_probs", "=", "all_probs_list", "[", "cls", "]", "\n", "# We don't actually care whether we hit the target class.", "\n", "# We care about the probability of the most likely wrong class", "\n", "cur_prob_cls", "=", "tf", ".", "reduce_max", "(", "all_probs", "-", "true_y", ",", "axis", "=", "1", ")", "\n", "# Knock out examples that are correctly classified.", "\n", "# This is not needed to be optimal for t >= 0.5, but may as well do it", "\n", "# to get better failure rate at lower thresholds.", "\n", "chosen_cls", "=", "tf", ".", "argmax", "(", "all_probs", ",", "axis", "=", "1", ")", "\n", "eligible", "=", "tf", ".", "to_float", "(", "tf", ".", "not_equal", "(", "true_y_idx", ",", "chosen_cls", ")", ")", "\n", "cur_prob_cls", "=", "cur_prob_cls", "*", "eligible", "\n", "prob_cls", ".", "append", "(", "cur_prob_cls", ")", "\n", "\n", "", "probs", "=", "tf", ".", "concat", "(", "[", "tf", ".", "expand_dims", "(", "e", ",", "1", ")", "for", "e", "in", "prob_cls", "]", ",", "axis", "=", "1", ")", "\n", "# Don't need to censor here because we knocked out the true class above", "\n", "# probs = probs - true_y", "\n", "most_confident", "=", "tf", ".", "argmax", "(", "probs", ",", "axis", "=", "1", ")", "\n", "fused_mask", "=", "tf", ".", "one_hot", "(", "most_confident", ",", "self", ".", "nb_classes", ")", "\n", "masks", "=", "tf", ".", "split", "(", "fused_mask", ",", "num_or_size_splits", "=", "self", ".", "nb_classes", ",", "axis", "=", "1", ")", "\n", "shape", "=", "[", "m", "]", "+", "[", "1", "]", "*", "(", "len", "(", "x", ".", "get_shape", "(", ")", ")", "-", "1", ")", "\n", "reshaped_masks", "=", "[", "tf", ".", "reshape", "(", "mask", ",", "shape", ")", "for", "mask", "in", "masks", "]", "\n", "out", "=", "sum", "(", "adv_x", "*", "rmask", "for", "adv_x", ",", "\n", "rmask", "in", "zip", "(", "adv_x_list", ",", "reshaped_masks", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack_class": [[107, 110], ["max_confidence.MaxConfidence.base_attacker.generate"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "attack_class", "(", "self", ",", "x", ",", "target_y", ")", ":", "\n", "    ", "adv", "=", "self", ".", "base_attacker", ".", "generate", "(", "x", ",", "y_target", "=", "target_y", ",", "**", "self", ".", "params", ")", "\n", "return", "adv", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.basic_iterative_method.BasicIterativeMethod.__init__": [[8, 13], ["cleverhans.attacks.projected_gradient_descent.ProjectedGradientDescent.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "BasicIterativeMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", "=", "sess", ",", "\n", "dtypestr", "=", "dtypestr", ",", "\n", "default_rand_init", "=", "False", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.saliency_map_method.SaliencyMapMethod.__init__": [[25, 37], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a SaliencyMapMethod instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "\n", "super", "(", "SaliencyMapMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'y_target'", ",", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'theta'", ",", "'gamma'", ",", "'clip_max'", ",", "'clip_min'", ",", "'symbolic_impl'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.saliency_map_method.SaliencyMapMethod.generate": [[39, 88], ["saliency_map_method.SaliencyMapMethod.parse_params", "jsma_symbolic", "NotImplementedError", "saliency_map_method.SaliencyMapMethod.get_or_guess_labels", "tensorflow.py_func", "saliency_map_method.SaliencyMapMethod.y_target.set_shape", "gt.copy", "range", "numpy.roll", "randint"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jsma_symbolic", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "if", "self", ".", "symbolic_impl", ":", "\n", "      ", "from", "cleverhans", ".", "attacks_tf", "import", "jsma_symbolic", "\n", "\n", "# Create random targets if y_target not provided", "\n", "if", "self", ".", "y_target", "is", "None", ":", "\n", "        ", "from", "random", "import", "randint", "\n", "\n", "def", "random_targets", "(", "gt", ")", ":", "\n", "          ", "result", "=", "gt", ".", "copy", "(", ")", "\n", "nb_s", "=", "gt", ".", "shape", "[", "0", "]", "\n", "nb_classes", "=", "gt", ".", "shape", "[", "1", "]", "\n", "\n", "for", "i", "in", "range", "(", "nb_s", ")", ":", "\n", "            ", "result", "[", "i", ",", ":", "]", "=", "np", ".", "roll", "(", "result", "[", "i", ",", ":", "]", ",", "\n", "randint", "(", "1", ",", "nb_classes", "-", "1", ")", ")", "\n", "\n", "", "return", "result", "\n", "\n", "", "labels", ",", "nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "self", ".", "y_target", "=", "tf", ".", "py_func", "(", "random_targets", ",", "[", "labels", "]", ",", "\n", "self", ".", "tf_dtype", ")", "\n", "self", ".", "y_target", ".", "set_shape", "(", "[", "None", ",", "nb_classes", "]", ")", "\n", "\n", "", "x_adv", "=", "jsma_symbolic", "(", "\n", "x", ",", "\n", "model", "=", "self", ".", "model", ",", "\n", "y_target", "=", "self", ".", "y_target", ",", "\n", "theta", "=", "self", ".", "theta", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "clip_min", "=", "self", ".", "clip_min", ",", "\n", "clip_max", "=", "self", ".", "clip_max", ")", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"The jsma_batch function has been removed.\"", "\n", "\" The symbolic_impl argument to SaliencyMapMethod will be removed\"", "\n", "\" on 2019-07-18 or after. Any code that depends on the non-symbolic\"", "\n", "\" implementation of the JSMA should be revised. Consider using\"", "\n", "\" SaliencyMapMethod.generate_np() instead.\"", ")", "\n", "\n", "", "return", "x_adv", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.saliency_map_method.SaliencyMapMethod.parse_params": [[89, 122], ["len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "theta", "=", "1.", ",", "\n", "gamma", "=", "1.", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "y_target", "=", "None", ",", "\n", "symbolic_impl", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param theta: (optional float) Perturbation introduced to modified\n                  components (can be positive or negative)\n    :param gamma: (optional float) Maximum percentage of perturbed features\n    :param clip_min: (optional float) Minimum component value for clipping\n    :param clip_max: (optional float) Maximum component value for clipping\n    :param y_target: (optional) Target tensor if the attack is targeted\n    \"\"\"", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "symbolic_impl", "=", "symbolic_impl", "\n", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.saliency_map_method.jsma_batch": [[124, 127], ["NotImplementedError"], "function", ["None"], ["", "", "def", "jsma_batch", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "raise", "NotImplementedError", "(", "\n", "\"The jsma_batch function has been removed. Any code that depends on it should be revised.\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.madry_et_al.MadryEtAl.__init__": [[9, 14], ["cleverhans.attacks.projected_gradient_descent.ProjectedGradientDescent.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["  ", "def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "MadryEtAl", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", "=", "sess", ",", "\n", "dtypestr", "=", "dtypestr", ",", "\n", "default_rand_init", "=", "True", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.momentum_iterative_method.MomentumIterativeMethod.__init__": [[28, 41], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a MomentumIterativeMethod instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "\n", "super", "(", "MomentumIterativeMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'eps_iter'", ",", "'y'", ",", "'y_target'", ",", "'clip_min'", ",", "\n", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'ord'", ",", "'nb_iter'", ",", "'decay_factor'", ",", "'sanity_checks'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.momentum_iterative_method.MomentumIterativeMethod.generate": [[42, 121], ["momentum_iterative_method.MomentumIterativeMethod.parse_params", "tensorflow.zeros_like", "momentum_iterative_method.MomentumIterativeMethod.get_or_guess_labels", "tensorflow.while_loop", "asserts.append", "asserts.append", "cleverhans.compat.reduce_sum", "tensorflow.less", "momentum_iterative_method.MomentumIterativeMethod.model.get_logits", "cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.gradients", "list", "tensorflow.cast", "cleverhans.attacks.fast_gradient_method.optimize_linear", "tensorflow.stop_gradient", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "range", "tensorflow.maximum", "NotImplementedError", "cleverhans.utils_tf.clip_eta", "cleverhans.utils_tf.clip_by_value", "tensorflow.zeros", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.cast", "tensorflow.cast", "len", "cleverhans.compat.reduce_mean", "grad.get_shape", "tensorflow.abs"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.optimize_linear", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: Keyword arguments. See `parse_params` for documentation.\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "asserts", "=", "[", "]", "\n", "\n", "# If a data range was specified, check that the input was in that range", "\n", "if", "self", ".", "clip_min", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_greater_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "# Initialize loop variables", "\n", "", "momentum", "=", "tf", ".", "zeros_like", "(", "x", ")", "\n", "adv_x", "=", "x", "\n", "\n", "# Fix labels to the first model predictions for loss computation", "\n", "y", ",", "_nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "y", "=", "y", "/", "reduce_sum", "(", "y", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "targeted", "=", "(", "self", ".", "y_target", "is", "not", "None", ")", "\n", "\n", "def", "cond", "(", "i", ",", "_", ",", "__", ")", ":", "\n", "      ", "return", "tf", ".", "less", "(", "i", ",", "self", ".", "nb_iter", ")", "\n", "\n", "", "def", "body", "(", "i", ",", "ax", ",", "m", ")", ":", "\n", "      ", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "ax", ")", "\n", "loss", "=", "softmax_cross_entropy_with_logits", "(", "labels", "=", "y", ",", "logits", "=", "logits", ")", "\n", "if", "targeted", ":", "\n", "        ", "loss", "=", "-", "loss", "\n", "\n", "# Define gradient of loss wrt input", "\n", "", "grad", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "ax", ")", "\n", "\n", "# Normalize current gradient and add it to the accumulated gradient", "\n", "red_ind", "=", "list", "(", "range", "(", "1", ",", "len", "(", "grad", ".", "get_shape", "(", ")", ")", ")", ")", "\n", "avoid_zero_div", "=", "tf", ".", "cast", "(", "1e-12", ",", "grad", ".", "dtype", ")", "\n", "grad", "=", "grad", "/", "tf", ".", "maximum", "(", "\n", "avoid_zero_div", ",", "\n", "reduce_mean", "(", "tf", ".", "abs", "(", "grad", ")", ",", "red_ind", ",", "keepdims", "=", "True", ")", ")", "\n", "m", "=", "self", ".", "decay_factor", "*", "m", "+", "grad", "\n", "\n", "optimal_perturbation", "=", "optimize_linear", "(", "m", ",", "self", ".", "eps_iter", ",", "self", ".", "ord", ")", "\n", "if", "self", ".", "ord", "==", "1", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"This attack hasn't been tested for ord=1.\"", "\n", "\"It's not clear that FGM makes a good inner \"", "\n", "\"loop step for iterative optimization since \"", "\n", "\"it updates just one coordinate at a time.\"", ")", "\n", "\n", "# Update and clip adversarial example in current iteration", "\n", "", "ax", "=", "ax", "+", "optimal_perturbation", "\n", "ax", "=", "x", "+", "utils_tf", ".", "clip_eta", "(", "ax", "-", "x", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "and", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "        ", "ax", "=", "utils_tf", ".", "clip_by_value", "(", "ax", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "ax", "=", "tf", ".", "stop_gradient", "(", "ax", ")", "\n", "\n", "return", "i", "+", "1", ",", "ax", ",", "m", "\n", "\n", "", "_", ",", "adv_x", ",", "_", "=", "tf", ".", "while_loop", "(", "\n", "cond", ",", "body", ",", "(", "tf", ".", "zeros", "(", "[", "]", ")", ",", "adv_x", ",", "momentum", ")", ",", "back_prop", "=", "True", ",", "\n", "maximum_iterations", "=", "self", ".", "nb_iter", ")", "\n", "\n", "if", "self", ".", "sanity_checks", ":", "\n", "      ", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "adv_x", "=", "tf", ".", "identity", "(", "adv_x", ")", "\n", "\n", "", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.momentum_iterative_method.MomentumIterativeMethod.parse_params": [[122, 178], ["ValueError", "ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "0.3", ",", "\n", "eps_iter", "=", "0.06", ",", "\n", "nb_iter", "=", "10", ",", "\n", "y", "=", "None", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "decay_factor", "=", "1.0", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "sanity_checks", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float) maximum distortion of adversarial example\n                compared to original input\n    :param eps_iter: (optional float) step size for each attack iteration\n    :param nb_iter: (optional int) Number of attack iterations.\n    :param y: (optional) A tensor with the true labels.\n    :param y_target: (optional) A tensor with the labels to target. Leave\n                     y_target=None if y is also set. Labels should be\n                     one-hot-encoded.\n    :param ord: (optional) Order of the norm (mimics Numpy).\n                Possible values: np.inf, 1 or 2.\n    :param decay_factor: (optional) Decay factor for the momentum term.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "\n", "# Save attack-specific parameters", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "eps_iter", "=", "eps_iter", "\n", "self", ".", "nb_iter", "=", "nb_iter", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "decay_factor", "=", "decay_factor", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "sanity_checks", "=", "sanity_checks", "\n", "\n", "if", "self", ".", "y", "is", "not", "None", "and", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must not set both y and y_target\"", ")", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", ",", "1", ",", "2", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be either np.inf, 1, or 2.\"", ")", "\n", "\n", "", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.__init__": [[24, 77], ["tensorflow.as_dtype", "numpy.dtype", "tuple", "TypeError", "isinstance", "TypeError", "warnings.warn", "ValueError", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param model: An instance of the cleverhans.model.Model class.\n    :param sess: The (possibly optional) tf.Session to run graphs in.\n    :param dtypestr: Floating point precision to use (change to float64\n                     to avoid numerical instabilities).\n    :param back: (deprecated and will be removed on or after 2019-03-26).\n                 The backend to use. Currently 'tf' is the only option.\n    \"\"\"", "\n", "if", "'back'", "in", "kwargs", ":", "\n", "      ", "if", "kwargs", "[", "'back'", "]", "==", "'tf'", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Argument back to attack constructors is not needed\"", "\n", "\" anymore and will be removed on or after 2019-03-26.\"", "\n", "\" All attacks are implemented using TensorFlow.\"", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Backend argument must be 'tf' and is now deprecated\"", "\n", "\"It will be removed on or after 2019-03-26.\"", ")", "\n", "\n", "", "", "self", ".", "tf_dtype", "=", "tf", ".", "as_dtype", "(", "dtypestr", ")", "\n", "self", ".", "np_dtype", "=", "np", ".", "dtype", "(", "dtypestr", ")", "\n", "\n", "if", "sess", "is", "not", "None", "and", "not", "isinstance", "(", "sess", ",", "tf", ".", "Session", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"sess is not an instance of tf.Session\"", ")", "\n", "\n", "", "from", "cleverhans", "import", "attacks_tf", "\n", "attacks_tf", ".", "np_dtype", "=", "self", ".", "np_dtype", "\n", "attacks_tf", ".", "tf_dtype", "=", "self", ".", "tf_dtype", "\n", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"The model argument should be an instance of\"", "\n", "\" the cleverhans.model.Model class.\"", ")", "\n", "\n", "# Prepare attributes", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "dtypestr", "=", "dtypestr", "\n", "\n", "# We are going to keep track of old graphs and cache them.", "\n", "self", ".", "graphs", "=", "{", "}", "\n", "\n", "# When calling generate_np, arguments in the following set should be", "\n", "# fed into the graph, as they are not structural items that require", "\n", "# generating a new graph.", "\n", "# This dict should map names of arguments to the types they should", "\n", "# have.", "\n", "# (Usually, the target class will be a feedable keyword argument.)", "\n", "self", ".", "feedable_kwargs", "=", "tuple", "(", ")", "\n", "\n", "# When calling generate_np, arguments in the following set should NOT", "\n", "# be fed into the graph, as they ARE structural items that require", "\n", "# generating a new graph.", "\n", "# This list should contain the names of the structural arguments.", "\n", "self", ".", "structural_kwargs", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.generate": [[78, 111], ["NotImplementedError"], "methods", ["None"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate the attack's symbolic graph for adversarial examples. This\n    method should be overriden in any child class that implements an\n    attack that is expressable symbolically. Otherwise, it will wrap the\n    numerical implementation as a symbolic operator.\n\n    :param x: The model's symbolic inputs.\n    :param **kwargs: optional parameters used by child classes.\n      Each child class defines additional parameters as needed.\n      Child classes that use the following concepts should use the following\n      names:\n        clip_min: minimum feature value\n        clip_max: maximum feature value\n        eps: size of norm constraint on adversarial perturbation\n        ord: order of norm constraint\n        nb_iter: number of iterations\n        eps_iter: size of norm constraint on iteration\n        y_target: if specified, the attack is targeted.\n        y: Do not specify if y_target is specified.\n           If specified, the attack is untargeted, aims to make the output\n           class not be y.\n           If neither y_target nor y is specified, y is inferred by having\n           the model classify the input.\n      For other concepts, it's generally a good idea to read other classes\n      and check for name consistency.\n    :return: A symbolic representation of the adversarial examples.\n    \"\"\"", "\n", "\n", "error", "=", "\"Sub-classes must implement generate.\"", "\n", "raise", "NotImplementedError", "(", "error", ")", "\n", "# Include an unused return so pylint understands the method signature", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.construct_graph": [[112, 163], ["_logger.info", "list", "dict", "feedable.items", "tensorflow.placeholder", "attack.Attack.generate", "feedable.keys", "isinstance", "len", "warnings.warn", "str().split", "isinstance", "list", "fixed.items", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "ValueError", "str", "list", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate"], ["", "def", "construct_graph", "(", "self", ",", "fixed", ",", "feedable", ",", "x_val", ",", "hash_key", ")", ":", "\n", "    ", "\"\"\"\n    Construct the graph required to run the attack through generate_np.\n\n    :param fixed: Structural elements that require defining a new graph.\n    :param feedable: Arguments that can be fed to the same graph when\n                     they take different values.\n    :param x_val: symbolic adversarial example\n    :param hash_key: the key used to store this graph in our cache\n    \"\"\"", "\n", "# try our very best to create a TF placeholder for each of the", "\n", "# feedable keyword arguments, and check the types are one of", "\n", "# the allowed types", "\n", "class_name", "=", "str", "(", "self", ".", "__class__", ")", ".", "split", "(", "\".\"", ")", "[", "-", "1", "]", "[", ":", "-", "2", "]", "\n", "_logger", ".", "info", "(", "\"Constructing new graph for attack \"", "+", "class_name", ")", "\n", "\n", "# remove the None arguments, they are just left blank", "\n", "for", "k", "in", "list", "(", "feedable", ".", "keys", "(", ")", ")", ":", "\n", "      ", "if", "feedable", "[", "k", "]", "is", "None", ":", "\n", "        ", "del", "feedable", "[", "k", "]", "\n", "\n", "# process all of the rest and create placeholders for them", "\n", "", "", "new_kwargs", "=", "dict", "(", "x", "for", "x", "in", "fixed", ".", "items", "(", ")", ")", "\n", "for", "name", ",", "value", "in", "feedable", ".", "items", "(", ")", ":", "\n", "      ", "given_type", "=", "value", ".", "dtype", "\n", "if", "isinstance", "(", "value", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "if", "value", ".", "ndim", "==", "0", ":", "\n", "# This is pretty clearly not a batch of data", "\n", "          ", "new_kwargs", "[", "name", "]", "=", "tf", ".", "placeholder", "(", "given_type", ",", "shape", "=", "[", "]", ",", "name", "=", "name", ")", "\n", "", "else", ":", "\n", "# Assume that this is a batch of data, make the first axis variable", "\n", "# in size", "\n", "          ", "new_shape", "=", "[", "None", "]", "+", "list", "(", "value", ".", "shape", "[", "1", ":", "]", ")", "\n", "new_kwargs", "[", "name", "]", "=", "tf", ".", "placeholder", "(", "given_type", ",", "new_shape", ",", "name", "=", "name", ")", "\n", "", "", "elif", "isinstance", "(", "value", ",", "utils", ".", "known_number_types", ")", ":", "\n", "        ", "new_kwargs", "[", "name", "]", "=", "tf", ".", "placeholder", "(", "given_type", ",", "shape", "=", "[", "]", ",", "name", "=", "name", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Could not identify type of argument \"", "+", "\n", "name", "+", "\": \"", "+", "str", "(", "value", ")", ")", "\n", "\n", "# x is a special placeholder we always want to have", "\n", "", "", "x_shape", "=", "[", "None", "]", "+", "list", "(", "x_val", ".", "shape", ")", "[", "1", ":", "]", "\n", "x", "=", "tf", ".", "placeholder", "(", "self", ".", "tf_dtype", ",", "shape", "=", "x_shape", ")", "\n", "\n", "# now we generate the graph that we want", "\n", "x_adv", "=", "self", ".", "generate", "(", "x", ",", "**", "new_kwargs", ")", "\n", "\n", "self", ".", "graphs", "[", "hash_key", "]", "=", "(", "x", ",", "new_kwargs", ",", "x_adv", ")", "\n", "\n", "if", "len", "(", "self", ".", "graphs", ")", ">=", "10", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Calling generate_np() with multiple different \"", "\n", "\"structural parameters is inefficient and should\"", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.generate_np": [[166, 200], ["attack.Attack.construct_variables", "attack.Attack.sess.run", "ValueError", "attack.Attack.construct_graph", "list", "feedable.keys"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.construct_variables", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.construct_graph"], ["", "", "def", "generate_np", "(", "self", ",", "x_val", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate adversarial examples and return them as a NumPy array.\n    Sub-classes *should not* implement this method unless they must\n    perform special handling of arguments.\n\n    :param x_val: A NumPy array with the original inputs.\n    :param **kwargs: optional parameters used by child classes.\n    :return: A NumPy array holding the adversarial examples.\n    \"\"\"", "\n", "\n", "if", "self", ".", "sess", "is", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Cannot use `generate_np` when no `sess` was\"", "\n", "\" provided\"", ")", "\n", "\n", "", "packed", "=", "self", ".", "construct_variables", "(", "kwargs", ")", "\n", "fixed", ",", "feedable", ",", "_", ",", "hash_key", "=", "packed", "\n", "\n", "if", "hash_key", "not", "in", "self", ".", "graphs", ":", "\n", "      ", "self", ".", "construct_graph", "(", "fixed", ",", "feedable", ",", "x_val", ",", "hash_key", ")", "\n", "", "else", ":", "\n", "# remove the None arguments, they are just left blank", "\n", "      ", "for", "k", "in", "list", "(", "feedable", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "feedable", "[", "k", "]", "is", "None", ":", "\n", "          ", "del", "feedable", "[", "k", "]", "\n", "\n", "", "", "", "x", ",", "new_kwargs", ",", "x_adv", "=", "self", ".", "graphs", "[", "hash_key", "]", "\n", "\n", "feed_dict", "=", "{", "x", ":", "x_val", "}", "\n", "\n", "for", "name", "in", "feedable", ":", "\n", "      ", "feed_dict", "[", "new_kwargs", "[", "name", "]", "]", "=", "feedable", "[", "name", "]", "\n", "\n", "", "return", "self", ".", "sess", ".", "run", "(", "x_adv", ",", "feed_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.construct_variables": [[201, 258], ["isinstance", "dict", "attack.arg_type", "warnings.warn", "tuple", "isinstance", "all", "sorted", "isinstance", "TypeError", "kwargs.items", "numpy.array", "ValueError", "tuple", "tuple", "attack.Attack.feedable_kwargs.keys", "kwargs.items", "isinstance", "sorted", "str", "dict.values", "dict.items", "type", "str", "str", "type", "str", "type"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.arg_type"], ["", "def", "construct_variables", "(", "self", ",", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Construct the inputs to the attack graph to be used by generate_np.\n\n    :param kwargs: Keyword arguments to generate_np.\n    :return:\n      Structural arguments\n      Feedable arguments\n      Output of `arg_type` describing feedable arguments\n      A unique key\n    \"\"\"", "\n", "if", "isinstance", "(", "self", ".", "feedable_kwargs", ",", "dict", ")", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Using a dict for `feedable_kwargs is deprecated.\"", "\n", "\"Switch to using a tuple.\"", "\n", "\"It is not longer necessary to specify the types \"", "\n", "\"of the arguments---we build a different graph \"", "\n", "\"for each received type.\"", "\n", "\"Using a dict may become an error on or after \"", "\n", "\"2019-04-18.\"", ")", "\n", "feedable_names", "=", "tuple", "(", "sorted", "(", "self", ".", "feedable_kwargs", ".", "keys", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "      ", "feedable_names", "=", "self", ".", "feedable_kwargs", "\n", "if", "not", "isinstance", "(", "feedable_names", ",", "tuple", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\"Attack.feedable_kwargs should be a tuple, but \"", "\n", "\"for subclass \"", "+", "str", "(", "type", "(", "self", ")", ")", "+", "\" it is \"", "\n", "+", "str", "(", "self", ".", "feedable_kwargs", ")", "+", "\" of type \"", "\n", "+", "str", "(", "type", "(", "self", ".", "feedable_kwargs", ")", ")", ")", "\n", "\n", "# the set of arguments that are structural properties of the attack", "\n", "# if these arguments are different, we must construct a new graph", "\n", "", "", "fixed", "=", "dict", "(", "\n", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", "in", "self", ".", "structural_kwargs", ")", "\n", "\n", "# the set of arguments that are passed as placeholders to the graph", "\n", "# on each call, and can change without constructing a new graph", "\n", "feedable", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", "in", "feedable_names", "}", "\n", "for", "k", "in", "feedable", ":", "\n", "      ", "if", "isinstance", "(", "feedable", "[", "k", "]", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "feedable", "[", "k", "]", "=", "np", ".", "array", "(", "feedable", "[", "k", "]", ")", "\n", "\n", "", "", "for", "key", "in", "kwargs", ":", "\n", "      ", "if", "key", "not", "in", "fixed", "and", "key", "not", "in", "feedable", ":", "\n", "        ", "raise", "ValueError", "(", "str", "(", "type", "(", "self", ")", ")", "+", "\": Undeclared argument: \"", "+", "key", ")", "\n", "\n", "", "", "feed_arg_type", "=", "arg_type", "(", "feedable_names", ",", "feedable", ")", "\n", "\n", "if", "not", "all", "(", "isinstance", "(", "value", ",", "collections", ".", "Hashable", ")", "\n", "for", "value", "in", "fixed", ".", "values", "(", ")", ")", ":", "\n", "# we have received a fixed value that isn't hashable", "\n", "# this means we can't cache this graph for later use,", "\n", "# and it will have to be discarded later", "\n", "      ", "hash_key", "=", "None", "\n", "", "else", ":", "\n", "# create a unique key for this set of fixed paramaters", "\n", "      ", "hash_key", "=", "tuple", "(", "sorted", "(", "fixed", ".", "items", "(", ")", ")", ")", "+", "tuple", "(", "[", "feed_arg_type", "]", ")", "\n", "\n", "", "return", "fixed", ",", "feedable", ",", "feed_arg_type", ",", "hash_key", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels": [[259, 287], ["isinstance", "ValueError", "tensorflow.stop_gradient.get_shape().as_list", "attack.Attack.model.get_probs", "cleverhans.compat.reduce_max", "tensorflow.to_float", "tensorflow.stop_gradient", "tensorflow.equal", "tensorflow.stop_gradient.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max"], ["", "def", "get_or_guess_labels", "(", "self", ",", "x", ",", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Get the label to use in generating an adversarial example for x.\n    The kwargs are fed directly from the kwargs of the attack.\n    If 'y' is in kwargs, then assume it's an untargeted attack and\n    use that as the label.\n    If 'y_target' is in kwargs and is not none, then assume it's a\n    targeted attack and use that as the label.\n    Otherwise, use the model's prediction as the label and perform an\n    untargeted attack.\n    \"\"\"", "\n", "if", "'y'", "in", "kwargs", "and", "'y_target'", "in", "kwargs", ":", "\n", "      ", "raise", "ValueError", "(", "\"Can not set both 'y' and 'y_target'.\"", ")", "\n", "", "elif", "'y'", "in", "kwargs", ":", "\n", "      ", "labels", "=", "kwargs", "[", "'y'", "]", "\n", "", "elif", "'y_target'", "in", "kwargs", "and", "kwargs", "[", "'y_target'", "]", "is", "not", "None", ":", "\n", "      ", "labels", "=", "kwargs", "[", "'y_target'", "]", "\n", "", "else", ":", "\n", "      ", "preds", "=", "self", ".", "model", ".", "get_probs", "(", "x", ")", "\n", "preds_max", "=", "reduce_max", "(", "preds", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "original_predictions", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "preds", ",", "preds_max", ")", ")", "\n", "labels", "=", "tf", ".", "stop_gradient", "(", "original_predictions", ")", "\n", "del", "preds", "\n", "", "if", "isinstance", "(", "labels", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "nb_classes", "=", "labels", ".", "shape", "[", "1", "]", "\n", "", "else", ":", "\n", "      ", "nb_classes", "=", "labels", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", "\n", "", "return", "labels", ",", "nb_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.parse_params": [[288, 301], ["warnings.warn"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "params", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    :param params: a dictionary of attack-specific parameters\n    :return: True when parsing was successful\n    \"\"\"", "\n", "\n", "if", "params", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"`params` is unused and will be removed \"", "\n", "\" on or after 2019-04-26.\"", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.arg_type": [[302, 346], ["isinstance", "tuple", "tuple", "tuple", "hasattr", "type", "isinstance", "tuple.append", "tuple.append", "tuple.append", "tuple.append", "tuple.append", "isinstance"], "function", ["None"], ["", "", "def", "arg_type", "(", "arg_names", ",", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Returns a hashable summary of the types of arg_names within kwargs.\n  :param arg_names: tuple containing names of relevant arguments\n  :param kwargs: dict mapping string argument names to values.\n    These must be values for which we can create a tf placeholder.\n    Currently supported: numpy darray or something that can ducktype it\n  returns:\n    API contract is to return a hashable object describing all\n    structural consequences of argument values that can otherwise\n    be fed into a graph of fixed structure.\n    Currently this is implemented as a tuple of tuples that track:\n      - whether each argument was passed\n      - whether each argument was passed and not None\n      - the dtype of each argument\n    Callers shouldn't rely on the exact structure of this object,\n    just its hashability and one-to-one mapping between graph structures.\n  \"\"\"", "\n", "assert", "isinstance", "(", "arg_names", ",", "tuple", ")", "\n", "passed", "=", "tuple", "(", "name", "in", "kwargs", "for", "name", "in", "arg_names", ")", "\n", "passed_and_not_none", "=", "[", "]", "\n", "for", "name", "in", "arg_names", ":", "\n", "    ", "if", "name", "in", "kwargs", ":", "\n", "      ", "passed_and_not_none", ".", "append", "(", "kwargs", "[", "name", "]", "is", "not", "None", ")", "\n", "", "else", ":", "\n", "      ", "passed_and_not_none", ".", "append", "(", "False", ")", "\n", "", "", "passed_and_not_none", "=", "tuple", "(", "passed_and_not_none", ")", "\n", "dtypes", "=", "[", "]", "\n", "for", "name", "in", "arg_names", ":", "\n", "    ", "if", "name", "not", "in", "kwargs", ":", "\n", "      ", "dtypes", ".", "append", "(", "None", ")", "\n", "continue", "\n", "", "value", "=", "kwargs", "[", "name", "]", "\n", "if", "value", "is", "None", ":", "\n", "      ", "dtypes", ".", "append", "(", "None", ")", "\n", "continue", "\n", "", "assert", "hasattr", "(", "value", ",", "'dtype'", ")", ",", "type", "(", "value", ")", "\n", "dtype", "=", "value", ".", "dtype", "\n", "if", "not", "isinstance", "(", "dtype", ",", "np", ".", "dtype", ")", ":", "\n", "      ", "dtype", "=", "dtype", ".", "as_np_dtype", "\n", "", "assert", "isinstance", "(", "dtype", ",", "np", ".", "dtype", ")", "\n", "dtypes", ".", "append", "(", "dtype", ")", "\n", "", "dtypes", "=", "tuple", "(", "dtypes", ")", "\n", "return", "(", "passed", ",", "passed_and_not_none", ",", "dtypes", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_feature_adversaries.FastFeatureAdversaries.__init__": [[31, 41], ["cleverhans.attacks.attack.Attack.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a FastFeatureAdversaries instance.\n    \"\"\"", "\n", "super", "(", "FastFeatureAdversaries", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'eps_iter'", ",", "'clip_min'", ",", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'ord'", ",", "'nb_iter'", ",", "'layer'", "]", "\n", "\n", "assert", "isinstance", "(", "self", ".", "model", ",", "Model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_feature_adversaries.FastFeatureAdversaries.parse_params": [[42, 85], ["ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "layer", "=", "None", ",", "\n", "eps", "=", "0.3", ",", "\n", "eps_iter", "=", "0.05", ",", "\n", "nb_iter", "=", "10", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param layer: (required str) name of the layer to target.\n    :param eps: (optional float) maximum distortion of adversarial example\n                compared to original input\n    :param eps_iter: (optional float) step size for each attack iteration\n    :param nb_iter: (optional int) Number of attack iterations.\n    :param ord: (optional) Order of the norm (mimics Numpy).\n                Possible values: np.inf, 1 or 2.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "\n", "# Save attack-specific parameters", "\n", "self", ".", "layer", "=", "layer", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "eps_iter", "=", "eps_iter", "\n", "self", ".", "nb_iter", "=", "nb_iter", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", ",", "1", ",", "2", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be either np.inf, 1, or 2.\"", ")", "\n", "", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_feature_adversaries.FastFeatureAdversaries.attack_single_step": [[86, 128], ["list", "tensorflow.gradients", "tensorflow.stop_gradient", "cleverhans.utils_tf.clip_eta", "fast_feature_adversaries.FastFeatureAdversaries.model.fprop", "range", "cleverhans.compat.reduce_sum", "tensorflow.sign", "tensorflow.clip_by_value", "len", "tensorflow.square"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value"], ["", "def", "attack_single_step", "(", "self", ",", "x", ",", "eta", ",", "g_feat", ")", ":", "\n", "    ", "\"\"\"\n    TensorFlow implementation of the Fast Feature Gradient. This is a\n    single step attack similar to Fast Gradient Method that attacks an\n    internal representation.\n\n    :param x: the input placeholder\n    :param eta: A tensor the same shape as x that holds the perturbation.\n    :param g_feat: model's internal tensor for guide\n    :return: a tensor for the adversarial example\n    \"\"\"", "\n", "\n", "adv_x", "=", "x", "+", "eta", "\n", "a_feat", "=", "self", ".", "model", ".", "fprop", "(", "adv_x", ")", "[", "self", ".", "layer", "]", "\n", "\n", "# feat.shape = (batch, c) or (batch, w, h, c)", "\n", "axis", "=", "list", "(", "range", "(", "1", ",", "len", "(", "a_feat", ".", "shape", ")", ")", ")", "\n", "\n", "# Compute loss", "\n", "# This is a targeted attack, hence the negative sign", "\n", "loss", "=", "-", "reduce_sum", "(", "tf", ".", "square", "(", "a_feat", "-", "g_feat", ")", ",", "axis", ")", "\n", "\n", "# Define gradient of loss wrt input", "\n", "grad", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "adv_x", ")", "\n", "\n", "# Multiply by constant epsilon", "\n", "scaled_signed_grad", "=", "self", ".", "eps_iter", "*", "tf", ".", "sign", "(", "grad", ")", "\n", "\n", "# Add perturbation to original example to obtain adversarial example", "\n", "adv_x", "=", "adv_x", "+", "scaled_signed_grad", "\n", "\n", "# If clipping is needed,", "\n", "# reset all values outside of [clip_min, clip_max]", "\n", "if", "(", "self", ".", "clip_min", "is", "not", "None", ")", "and", "(", "self", ".", "clip_max", "is", "not", "None", ")", ":", "\n", "      ", "adv_x", "=", "tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "adv_x", "=", "tf", ".", "stop_gradient", "(", "adv_x", ")", "\n", "\n", "eta", "=", "adv_x", "-", "x", "\n", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "\n", "return", "eta", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_feature_adversaries.FastFeatureAdversaries.generate": [[129, 164], ["fast_feature_adversaries.FastFeatureAdversaries.parse_params", "tensorflow.random_uniform", "cleverhans.utils_tf.clip_eta", "tensorflow.while_loop", "fast_feature_adversaries.FastFeatureAdversaries.model.fprop", "tensorflow.shape", "tensorflow.less", "fast_feature_adversaries.FastFeatureAdversaries.attack_single_step", "tensorflow.clip_by_value", "tensorflow.zeros"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_feature_adversaries.FastFeatureAdversaries.attack_single_step", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value"], ["", "def", "generate", "(", "self", ",", "x", ",", "g", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param g: The target value of the symbolic representation\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "g_feat", "=", "self", ".", "model", ".", "fprop", "(", "g", ")", "[", "self", ".", "layer", "]", "\n", "\n", "# Initialize loop variables", "\n", "eta", "=", "tf", ".", "random_uniform", "(", "\n", "tf", ".", "shape", "(", "x", ")", ",", "-", "self", ".", "eps", ",", "self", ".", "eps", ",", "dtype", "=", "self", ".", "tf_dtype", ")", "\n", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "\n", "def", "cond", "(", "i", ",", "_", ")", ":", "\n", "      ", "return", "tf", ".", "less", "(", "i", ",", "self", ".", "nb_iter", ")", "\n", "\n", "", "def", "body", "(", "i", ",", "e", ")", ":", "\n", "      ", "new_eta", "=", "self", ".", "attack_single_step", "(", "x", ",", "e", ",", "g_feat", ")", "\n", "return", "i", "+", "1", ",", "new_eta", "\n", "\n", "", "_", ",", "eta", "=", "tf", ".", "while_loop", "(", "cond", ",", "body", ",", "(", "tf", ".", "zeros", "(", "[", "]", ")", ",", "eta", ")", ",", "back_prop", "=", "True", ",", "\n", "maximum_iterations", "=", "self", ".", "nb_iter", ")", "\n", "\n", "# Define adversarial example (and clip if necessary)", "\n", "adv_x", "=", "x", "+", "eta", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "and", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "adv_x", "=", "tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "return", "adv_x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.projected_gradient_descent.ProjectedGradientDescent.__init__": [[33, 47], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "\n", "default_rand_init", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a ProjectedGradientDescent instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "\n", "super", "(", "ProjectedGradientDescent", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", "=", "sess", ",", "\n", "dtypestr", "=", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'eps_iter'", ",", "'y'", ",", "'y_target'", ",", "'clip_min'", ",", "\n", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'ord'", ",", "'nb_iter'", ",", "'rand_init'", ",", "'sanity_checks'", "]", "\n", "self", ".", "default_rand_init", "=", "default_rand_init", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.projected_gradient_descent.ProjectedGradientDescent.generate": [[48, 166], ["projected_gradient_descent.ProjectedGradientDescent.parse_params", "cleverhans.utils_tf.clip_eta", "projected_gradient_descent.ProjectedGradientDescent.FGM_CLASS", "tensorflow.while_loop", "asserts.append", "asserts.append", "asserts.append", "tensorflow.random_uniform", "tensorflow.zeros", "cleverhans.utils_tf.clip_by_value", "NotImplementedError", "tensorflow.less", "projected_gradient_descent.ProjectedGradientDescent.generate", "cleverhans.utils_tf.clip_eta", "cleverhans.utils_tf.assert_less_equal", "asserts.append", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "tensorflow.shape", "tensorflow.cast", "tensorflow.cast", "tensorflow.shape", "projected_gradient_descent.ProjectedGradientDescent.model.get_probs", "cleverhans.compat.reduce_max", "tensorflow.to_float", "tensorflow.stop_gradient", "getattr", "cleverhans.utils_tf.clip_by_value", "tensorflow.zeros", "tensorflow.cast", "tensorflow.cast", "cleverhans.utils_tf.assert_less_equal", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.cast", "tensorflow.cast", "tensorflow.equal", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_eta", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_probs", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "asserts", "=", "[", "]", "\n", "\n", "# If a data range was specified, check that the input was in that range", "\n", "if", "self", ".", "clip_min", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_greater_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "x", ",", "\n", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "# Initialize loop variables", "\n", "", "if", "self", ".", "rand_init", ":", "\n", "      ", "eta", "=", "tf", ".", "random_uniform", "(", "tf", ".", "shape", "(", "x", ")", ",", "\n", "tf", ".", "cast", "(", "-", "self", ".", "rand_minmax", ",", "x", ".", "dtype", ")", ",", "\n", "tf", ".", "cast", "(", "self", ".", "rand_minmax", ",", "x", ".", "dtype", ")", ",", "\n", "dtype", "=", "x", ".", "dtype", ")", "\n", "", "else", ":", "\n", "      ", "eta", "=", "tf", ".", "zeros", "(", "tf", ".", "shape", "(", "x", ")", ")", "\n", "\n", "# Clip eta", "\n", "", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "adv_x", "=", "x", "+", "eta", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "or", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "      ", "adv_x", "=", "utils_tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "if", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "y", "=", "self", ".", "y_target", "\n", "targeted", "=", "True", "\n", "", "elif", "self", ".", "y", "is", "not", "None", ":", "\n", "      ", "y", "=", "self", ".", "y", "\n", "targeted", "=", "False", "\n", "", "else", ":", "\n", "      ", "model_preds", "=", "self", ".", "model", ".", "get_probs", "(", "x", ")", "\n", "preds_max", "=", "reduce_max", "(", "model_preds", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "y", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "model_preds", ",", "preds_max", ")", ")", "\n", "y", "=", "tf", ".", "stop_gradient", "(", "y", ")", "\n", "targeted", "=", "False", "\n", "del", "model_preds", "\n", "\n", "", "y_kwarg", "=", "'y_target'", "if", "targeted", "else", "'y'", "\n", "fgm_params", "=", "{", "\n", "'eps'", ":", "self", ".", "eps_iter", ",", "\n", "y_kwarg", ":", "y", ",", "\n", "'ord'", ":", "self", ".", "ord", ",", "\n", "'clip_min'", ":", "self", ".", "clip_min", ",", "\n", "'clip_max'", ":", "self", ".", "clip_max", "\n", "}", "\n", "if", "self", ".", "ord", "==", "1", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"It's not clear that FGM is a good inner loop\"", "\n", "\" step for PGD when ord=1, because ord=1 FGM \"", "\n", "\" changes only one pixel at a time. We need \"", "\n", "\" to rigorously test a strong ord=1 PGD \"", "\n", "\"before enabling this feature.\"", ")", "\n", "\n", "# Use getattr() to avoid errors in eager execution attacks", "\n", "", "FGM", "=", "self", ".", "FGM_CLASS", "(", "\n", "self", ".", "model", ",", "\n", "sess", "=", "getattr", "(", "self", ",", "'sess'", ",", "None", ")", ",", "\n", "dtypestr", "=", "self", ".", "dtypestr", ")", "\n", "\n", "def", "cond", "(", "i", ",", "_", ")", ":", "\n", "      ", "return", "tf", ".", "less", "(", "i", ",", "self", ".", "nb_iter", ")", "\n", "\n", "", "def", "body", "(", "i", ",", "adv_x", ")", ":", "\n", "      ", "adv_x", "=", "FGM", ".", "generate", "(", "adv_x", ",", "**", "fgm_params", ")", "\n", "\n", "# Clipping perturbation eta to self.ord norm ball", "\n", "eta", "=", "adv_x", "-", "x", "\n", "eta", "=", "clip_eta", "(", "eta", ",", "self", ".", "ord", ",", "self", ".", "eps", ")", "\n", "adv_x", "=", "x", "+", "eta", "\n", "\n", "# Redo the clipping.", "\n", "# FGM already did it, but subtracting and re-adding eta can add some", "\n", "# small numerical error.", "\n", "if", "self", ".", "clip_min", "is", "not", "None", "or", "self", ".", "clip_max", "is", "not", "None", ":", "\n", "        ", "adv_x", "=", "utils_tf", ".", "clip_by_value", "(", "adv_x", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ")", "\n", "\n", "", "return", "i", "+", "1", ",", "adv_x", "\n", "\n", "", "_", ",", "adv_x", "=", "tf", ".", "while_loop", "(", "cond", ",", "body", ",", "(", "tf", ".", "zeros", "(", "[", "]", ")", ",", "adv_x", ")", ",", "back_prop", "=", "True", ",", "\n", "maximum_iterations", "=", "self", ".", "nb_iter", ")", "\n", "\n", "\n", "# Asserts run only on CPU.", "\n", "# When multi-GPU eval code tries to force all PGD ops onto GPU, this", "\n", "# can cause an error.", "\n", "common_dtype", "=", "tf", ".", "float64", "\n", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "tf", ".", "cast", "(", "self", ".", "eps_iter", ",", "\n", "dtype", "=", "common_dtype", ")", ",", "\n", "tf", ".", "cast", "(", "self", ".", "eps", ",", "dtype", "=", "common_dtype", ")", ")", ")", "\n", "if", "self", ".", "ord", "==", "np", ".", "inf", "and", "self", ".", "clip_min", "is", "not", "None", ":", "\n", "# The 1e-6 is needed to compensate for numerical error.", "\n", "# Without the 1e-6 this fails when e.g. eps=.2, clip_min=.5,", "\n", "# clip_max=.7", "\n", "      ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "tf", ".", "cast", "(", "self", ".", "eps", ",", "x", ".", "dtype", ")", ",", "\n", "1e-6", "+", "tf", ".", "cast", "(", "self", ".", "clip_max", ",", "\n", "x", ".", "dtype", ")", "\n", "-", "tf", ".", "cast", "(", "self", ".", "clip_min", ",", "\n", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "sanity_checks", ":", "\n", "      ", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "        ", "adv_x", "=", "tf", ".", "identity", "(", "adv_x", ")", "\n", "\n", "", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.projected_gradient_descent.ProjectedGradientDescent.parse_params": [[167, 237], ["isinstance", "isinstance", "ValueError", "ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "0.3", ",", "\n", "eps_iter", "=", "0.05", ",", "\n", "nb_iter", "=", "10", ",", "\n", "y", "=", "None", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "rand_init", "=", "None", ",", "\n", "rand_minmax", "=", "0.3", ",", "\n", "sanity_checks", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float) maximum distortion of adversarial example\n                compared to original input\n    :param eps_iter: (optional float) step size for each attack iteration\n    :param nb_iter: (optional int) Number of attack iterations.\n    :param y: (optional) A tensor with the true labels.\n    :param y_target: (optional) A tensor with the labels to target. Leave\n                     y_target=None if y is also set. Labels should be\n                     one-hot-encoded.\n    :param ord: (optional) Order of the norm (mimics Numpy).\n                Possible values: np.inf, 1 or 2.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    :param sanity_checks: bool Insert tf asserts checking values\n        (Some tests need to run with no sanity checks because the\n         tests intentionally configure the attack strangely)\n    \"\"\"", "\n", "\n", "# Save attack-specific parameters", "\n", "self", ".", "eps", "=", "eps", "\n", "if", "rand_init", "is", "None", ":", "\n", "      ", "rand_init", "=", "self", ".", "default_rand_init", "\n", "", "self", ".", "rand_init", "=", "rand_init", "\n", "if", "self", ".", "rand_init", ":", "\n", "      ", "self", ".", "rand_minmax", "=", "eps", "\n", "", "else", ":", "\n", "      ", "self", ".", "rand_minmax", "=", "0.", "\n", "", "self", ".", "eps_iter", "=", "eps_iter", "\n", "self", ".", "nb_iter", "=", "nb_iter", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "\n", "if", "isinstance", "(", "eps", ",", "float", ")", "and", "isinstance", "(", "eps_iter", ",", "float", ")", ":", "\n", "# If these are both known at compile time, we can check before anything", "\n", "# is run. If they are tf, we can't check them yet.", "\n", "      ", "assert", "eps_iter", "<=", "eps", ",", "(", "eps_iter", ",", "eps", ")", "\n", "\n", "", "if", "self", ".", "y", "is", "not", "None", "and", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must not set both y and y_target\"", ")", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", ",", "1", ",", "2", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be either np.inf, 1, or 2.\"", ")", "\n", "", "self", ".", "sanity_checks", "=", "sanity_checks", "\n", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.deep_fool.DeepFool.__init__": [[25, 37], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "cleverhans.model.wrapper_warning_logits", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning_logits"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a DeepFool instance.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning_logits", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'logits'", ")", "\n", "\n", "", "super", "(", "DeepFool", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'overshoot'", ",", "'max_iter'", ",", "'clip_max'", ",", "'clip_min'", ",", "'nb_candidate'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.deep_fool.DeepFool.generate": [[39, 74], ["deep_fool.DeepFool.parse_params", "deep_fool.DeepFool.model.get_logits", "tensorflow.reshape", "tensorflow.stack", "tensorflow.py_func", "tensorflow.py_func.set_shape", "deep_fool.DeepFool.get_shape().as_list", "jacobian_graph", "deepfool_batch", "x.get_shape", "tensorflow.nn.top_k", "deep_fool.DeepFool.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.jacobian_graph", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.deepfool_batch"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "assert", "self", ".", "sess", "is", "not", "None", ",", "'Cannot use `generate` when no `sess` was provided'", "\n", "from", "cleverhans", ".", "attacks_tf", "import", "jacobian_graph", ",", "deepfool_batch", "\n", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "# Define graph wrt to this input placeholder", "\n", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x", ")", "\n", "self", ".", "nb_classes", "=", "logits", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "-", "1", "]", "\n", "assert", "self", ".", "nb_candidate", "<=", "self", ".", "nb_classes", ",", "'nb_candidate should not be greater than nb_classes'", "\n", "preds", "=", "tf", ".", "reshape", "(", "\n", "tf", ".", "nn", ".", "top_k", "(", "logits", ",", "k", "=", "self", ".", "nb_candidate", ")", "[", "0", "]", ",", "\n", "[", "-", "1", ",", "self", ".", "nb_candidate", "]", ")", "\n", "# grads will be the shape [batch_size, nb_candidate, image_size]", "\n", "grads", "=", "tf", ".", "stack", "(", "jacobian_graph", "(", "preds", ",", "x", ",", "self", ".", "nb_candidate", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# Define graph", "\n", "def", "deepfool_wrap", "(", "x_val", ")", ":", "\n", "      ", "return", "deepfool_batch", "(", "self", ".", "sess", ",", "x", ",", "preds", ",", "logits", ",", "grads", ",", "x_val", ",", "\n", "self", ".", "nb_candidate", ",", "self", ".", "overshoot", ",", "\n", "self", ".", "max_iter", ",", "self", ".", "clip_min", ",", "self", ".", "clip_max", ",", "\n", "self", ".", "nb_classes", ")", "\n", "\n", "", "wrap", "=", "tf", ".", "py_func", "(", "deepfool_wrap", ",", "[", "x", "]", ",", "self", ".", "tf_dtype", ")", "\n", "wrap", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.deep_fool.DeepFool.parse_params": [[75, 103], ["len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "nb_candidate", "=", "10", ",", "\n", "overshoot", "=", "0.02", ",", "\n", "max_iter", "=", "50", ",", "\n", "clip_min", "=", "0.", ",", "\n", "clip_max", "=", "1.", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param nb_candidate: The number of classes to test against, i.e.,\n                         deepfool only consider nb_candidate classes when\n                         attacking(thus accelerate speed). The nb_candidate\n                         classes are chosen according to the prediction\n                         confidence during implementation.\n    :param overshoot: A termination criterion to prevent vanishing updates\n    :param max_iter: Maximum number of iteration for deepfool\n    :param clip_min: Minimum component value for clipping\n    :param clip_max: Maximum component value for clipping\n    \"\"\"", "\n", "self", ".", "nb_candidate", "=", "nb_candidate", "\n", "self", ".", "overshoot", "=", "overshoot", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.carlini_wagner_l2.CarliniWagnerL2.__init__": [[27, 44], ["cleverhans.attacks.attack.Attack.__init__", "isinstance", "cleverhans.model.wrapper_warning_logits", "cleverhans.model.CallableModelWrapper"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.wrapper_warning_logits"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "model", ",", "Model", ")", ":", "\n", "      ", "wrapper_warning_logits", "(", ")", "\n", "model", "=", "CallableModelWrapper", "(", "model", ",", "'logits'", ")", "\n", "\n", "", "super", "(", "CarliniWagnerL2", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'y'", ",", "'y_target'", ")", "\n", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'batch_size'", ",", "'confidence'", ",", "'targeted'", ",", "'learning_rate'", ",", "\n", "'binary_search_steps'", ",", "'max_iterations'", ",", "'abort_early'", ",", "\n", "'initial_const'", ",", "'clip_min'", ",", "'clip_max'", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.carlini_wagner_l2.CarliniWagnerL2.generate": [[46, 75], ["carlini_wagner_l2.CarliniWagnerL2.parse_params", "carlini_wagner_l2.CarliniWagnerL2.get_or_guess_labels", "CWL2", "tensorflow.py_func", "tensorflow.py_func.set_shape", "numpy.array", "x.get_shape", "x.get_shape().as_list", "CWL2.attack", "x.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.max_confidence.MaxConfidence.attack"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor that constructs adversarial examples for the given\n    input. Generate uses tf.py_func in order to operate over tensors.\n\n    :param x: A tensor with the inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "assert", "self", ".", "sess", "is", "not", "None", ",", "'Cannot use `generate` when no `sess` was provided'", "\n", "from", "cleverhans", ".", "attacks_tf", "import", "CarliniWagnerL2", "as", "CWL2", "\n", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "labels", ",", "nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "\n", "attack", "=", "CWL2", "(", "self", ".", "sess", ",", "self", ".", "model", ",", "self", ".", "batch_size", ",", "self", ".", "confidence", ",", "\n", "'y_target'", "in", "kwargs", ",", "self", ".", "learning_rate", ",", "\n", "self", ".", "binary_search_steps", ",", "self", ".", "max_iterations", ",", "\n", "self", ".", "abort_early", ",", "self", ".", "initial_const", ",", "self", ".", "clip_min", ",", "\n", "self", ".", "clip_max", ",", "nb_classes", ",", "\n", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ")", "\n", "\n", "def", "cw_wrap", "(", "x_val", ",", "y_val", ")", ":", "\n", "      ", "return", "np", ".", "array", "(", "attack", ".", "attack", "(", "x_val", ",", "y_val", ")", ",", "dtype", "=", "self", ".", "np_dtype", ")", "\n", "\n", "", "wrap", "=", "tf", ".", "py_func", "(", "cw_wrap", ",", "[", "x", ",", "labels", "]", ",", "self", ".", "tf_dtype", ")", "\n", "wrap", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "\n", "return", "wrap", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.carlini_wagner_l2.CarliniWagnerL2.parse_params": [[76, 133], ["None"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "y", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "batch_size", "=", "1", ",", "\n", "confidence", "=", "0", ",", "\n", "learning_rate", "=", "5e-3", ",", "\n", "binary_search_steps", "=", "5", ",", "\n", "max_iterations", "=", "1000", ",", "\n", "abort_early", "=", "True", ",", "\n", "initial_const", "=", "1e-2", ",", "\n", "clip_min", "=", "0", ",", "\n", "clip_max", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    :param y: (optional) A tensor with the true labels for an untargeted\n              attack. If None (and y_target is None) then use the\n              original labels the classifier assigns.\n    :param y_target: (optional) A tensor with the target labels for a\n              targeted attack.\n    :param confidence: Confidence of adversarial examples: higher produces\n                       examples with larger l2 distortion, but more\n                       strongly classified as adversarial.\n    :param batch_size: Number of attacks to run simultaneously.\n    :param learning_rate: The learning rate for the attack algorithm.\n                          Smaller values produce better results but are\n                          slower to converge.\n    :param binary_search_steps: The number of times we perform binary\n                                search to find the optimal tradeoff-\n                                constant between norm of the purturbation\n                                and confidence of the classification.\n    :param max_iterations: The maximum number of iterations. Setting this\n                           to a larger value will produce lower distortion\n                           results. Using only a few iterations requires\n                           a larger learning rate, and will produce larger\n                           distortion results.\n    :param abort_early: If true, allows early aborts if gradient descent\n                        is unable to make progress (i.e., gets stuck in\n                        a local minimum).\n    :param initial_const: The initial tradeoff-constant to use to tune the\n                          relative importance of size of the perturbation\n                          and confidence of classification.\n                          If binary_search_steps is large, the initial\n                          constant is not important. A smaller value of\n                          this constant gives lower distortion results.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    \"\"\"", "\n", "\n", "# ignore the y and y_target argument", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "confidence", "=", "confidence", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "binary_search_steps", "=", "binary_search_steps", "\n", "self", ".", "max_iterations", "=", "max_iterations", "\n", "self", ".", "abort_early", "=", "abort_early", "\n", "self", ".", "initial_const", "=", "initial_const", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.FastGradientMethod.__init__": [[29, 39], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a FastGradientMethod instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n    \"\"\"", "\n", "\n", "super", "(", "FastGradientMethod", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'y'", ",", "'y_target'", ",", "'clip_min'", ",", "'clip_max'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "'ord'", ",", "'sanity_checks'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.FastGradientMethod.generate": [[40, 62], ["fast_gradient_method.FastGradientMethod.parse_params", "fast_gradient_method.FastGradientMethod.get_or_guess_labels", "fast_gradient_method.fgm", "fast_gradient_method.FastGradientMethod.model.get_logits"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.fgm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Returns the graph for Fast Gradient Method adversarial examples.\n\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "labels", ",", "_nb_classes", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "\n", "return", "fgm", "(", "\n", "x", ",", "\n", "self", ".", "model", ".", "get_logits", "(", "x", ")", ",", "\n", "y", "=", "labels", ",", "\n", "eps", "=", "self", ".", "eps", ",", "\n", "ord", "=", "self", ".", "ord", ",", "\n", "clip_min", "=", "self", ".", "clip_min", ",", "\n", "clip_max", "=", "self", ".", "clip_max", ",", "\n", "targeted", "=", "(", "self", ".", "y_target", "is", "not", "None", ")", ",", "\n", "sanity_checks", "=", "self", ".", "sanity_checks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.FastGradientMethod.parse_params": [[63, 117], ["ValueError", "ValueError", "len", "warnings.warn", "int", "int", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "eps", "=", "0.3", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "y", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "sanity_checks", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n\n    Attack-specific parameters:\n\n    :param eps: (optional float) attack step size (input variation)\n    :param ord: (optional) Order of the norm (mimics NumPy).\n                Possible values: np.inf, 1 or 2.\n    :param y: (optional) A tensor with the true labels. Only provide\n              this parameter if you'd like to use true labels when crafting\n              adversarial samples. Otherwise, model predictions are used as\n              labels to avoid the \"label leaking\" effect (explained in this\n              paper: https://arxiv.org/abs/1611.01236). Default is None.\n              Labels should be one-hot-encoded.\n    :param y_target: (optional) A tensor with the labels to target. Leave\n                     y_target=None if y is also set. Labels should be\n                     one-hot-encoded.\n    :param clip_min: (optional float) Minimum input component value\n    :param clip_max: (optional float) Maximum input component value\n    :param sanity_checks: bool, if True, include asserts\n      (Turn them off to use less runtime / memory or for unit tests that\n      intentionally pass strange input)\n    \"\"\"", "\n", "# Save attack-specific parameters", "\n", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "ord", "=", "ord", "\n", "self", ".", "y", "=", "y", "\n", "self", ".", "y_target", "=", "y_target", "\n", "self", ".", "clip_min", "=", "clip_min", "\n", "self", ".", "clip_max", "=", "clip_max", "\n", "self", ".", "sanity_checks", "=", "sanity_checks", "\n", "\n", "if", "self", ".", "y", "is", "not", "None", "and", "self", ".", "y_target", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must not set both y and y_target\"", ")", "\n", "# Check if order of the norm is acceptable given current implementation", "\n", "", "if", "self", ".", "ord", "not", "in", "[", "np", ".", "inf", ",", "int", "(", "1", ")", ",", "int", "(", "2", ")", "]", ":", "\n", "      ", "raise", "ValueError", "(", "\"Norm order must be either np.inf, 1, or 2.\"", ")", "\n", "\n", "", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.fgm": [[119, 195], ["cleverhans.compat.softmax_cross_entropy_with_logits", "tensorflow.gradients", "fast_gradient_method.optimize_linear", "asserts.append", "asserts.append", "cleverhans.compat.reduce_max", "tensorflow.to_float", "tensorflow.stop_gradient", "cleverhans.compat.reduce_sum", "cleverhans.utils_tf.clip_by_value", "cleverhans.utils_tf.assert_greater_equal", "cleverhans.utils_tf.assert_less_equal", "tensorflow.equal", "tensorflow.control_dependencies", "tensorflow.identity", "tensorflow.cast", "tensorflow.cast"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.softmax_cross_entropy_with_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.optimize_linear", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal"], ["", "", "def", "fgm", "(", "x", ",", "\n", "logits", ",", "\n", "y", "=", "None", ",", "\n", "eps", "=", "0.3", ",", "\n", "ord", "=", "np", ".", "inf", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "targeted", "=", "False", ",", "\n", "sanity_checks", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  TensorFlow implementation of the Fast Gradient Method.\n  :param x: the input placeholder\n  :param logits: output of model.get_logits\n  :param y: (optional) A placeholder for the true labels. If targeted\n            is true, then provide the target label. Otherwise, only provide\n            this parameter if you'd like to use true labels when crafting\n            adversarial samples. Otherwise, model predictions are used as\n            labels to avoid the \"label leaking\" effect (explained in this\n            paper: https://arxiv.org/abs/1611.01236). Default is None.\n            Labels should be one-hot-encoded.\n  :param eps: the epsilon (input variation parameter)\n  :param ord: (optional) Order of the norm (mimics NumPy).\n              Possible values: np.inf, 1 or 2.\n  :param clip_min: Minimum float value for adversarial example components\n  :param clip_max: Maximum float value for adversarial example components\n  :param targeted: Is the attack targeted or untargeted? Untargeted, the\n                   default, will try to make the label incorrect. Targeted\n                   will instead try to move in the direction of being more\n                   like y.\n  :return: a tensor for the adversarial example\n  \"\"\"", "\n", "\n", "asserts", "=", "[", "]", "\n", "\n", "# If a data range was specified, check that the input was in that range", "\n", "if", "clip_min", "is", "not", "None", ":", "\n", "    ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_greater_equal", "(", "\n", "x", ",", "tf", ".", "cast", "(", "clip_min", ",", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "", "if", "clip_max", "is", "not", "None", ":", "\n", "    ", "asserts", ".", "append", "(", "utils_tf", ".", "assert_less_equal", "(", "x", ",", "tf", ".", "cast", "(", "clip_max", ",", "x", ".", "dtype", ")", ")", ")", "\n", "\n", "# Make sure the caller has not passed probs by accident", "\n", "", "assert", "logits", ".", "op", ".", "type", "!=", "'Softmax'", "\n", "\n", "if", "y", "is", "None", ":", "\n", "# Using model predictions as ground truth to avoid label leaking", "\n", "    ", "preds_max", "=", "reduce_max", "(", "logits", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "y", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "logits", ",", "preds_max", ")", ")", "\n", "y", "=", "tf", ".", "stop_gradient", "(", "y", ")", "\n", "", "y", "=", "y", "/", "reduce_sum", "(", "y", ",", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "# Compute loss", "\n", "loss", "=", "softmax_cross_entropy_with_logits", "(", "labels", "=", "y", ",", "logits", "=", "logits", ")", "\n", "if", "targeted", ":", "\n", "    ", "loss", "=", "-", "loss", "\n", "\n", "# Define gradient of loss wrt input", "\n", "", "grad", ",", "=", "tf", ".", "gradients", "(", "loss", ",", "x", ")", "\n", "\n", "optimal_perturbation", "=", "optimize_linear", "(", "grad", ",", "eps", ",", "ord", ")", "\n", "\n", "# Add perturbation to original example to obtain adversarial example", "\n", "adv_x", "=", "x", "+", "optimal_perturbation", "\n", "\n", "# If clipping is needed, reset all values outside of [clip_min, clip_max]", "\n", "if", "(", "clip_min", "is", "not", "None", ")", "or", "(", "clip_max", "is", "not", "None", ")", ":", "\n", "# We don't currently support one-sided clipping", "\n", "    ", "assert", "clip_min", "is", "not", "None", "and", "clip_max", "is", "not", "None", "\n", "adv_x", "=", "utils_tf", ".", "clip_by_value", "(", "adv_x", ",", "clip_min", ",", "clip_max", ")", "\n", "\n", "", "if", "sanity_checks", ":", "\n", "    ", "with", "tf", ".", "control_dependencies", "(", "asserts", ")", ":", "\n", "      ", "adv_x", "=", "tf", ".", "identity", "(", "adv_x", ")", "\n", "\n", "", "", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.fast_gradient_method.optimize_linear": [[196, 243], ["list", "cleverhans.utils_tf.mul", "range", "tensorflow.sign", "tensorflow.stop_gradient", "len", "tensorflow.abs", "tensorflow.sign", "tensorflow.reduce_max", "tensorflow.to_float", "tensorflow.reduce_sum", "grad.get_shape", "tensorflow.equal", "tensorflow.maximum", "NotImplementedError", "cleverhans.compat.reduce_sum", "tensorflow.sqrt", "tensorflow.square"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.mul", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_max", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "def", "optimize_linear", "(", "grad", ",", "eps", ",", "ord", "=", "np", ".", "inf", ")", ":", "\n", "  ", "\"\"\"\n  Solves for the optimal input to a linear function under a norm constraint.\n\n  Optimal_perturbation = argmax_{eta, ||eta||_{ord} < eps} dot(eta, grad)\n\n  :param grad: tf tensor containing a batch of gradients\n  :param eps: float scalar specifying size of constraint region\n  :param ord: int specifying order of norm\n  :returns:\n    tf tensor containing optimal perturbation\n  \"\"\"", "\n", "\n", "# In Python 2, the `list` call in the following line is redundant / harmless.", "\n", "# In Python 3, the `list` call is needed to convert the iterator returned by `range` into a list.", "\n", "red_ind", "=", "list", "(", "range", "(", "1", ",", "len", "(", "grad", ".", "get_shape", "(", ")", ")", ")", ")", "\n", "avoid_zero_div", "=", "1e-12", "\n", "if", "ord", "==", "np", ".", "inf", ":", "\n", "# Take sign of gradient", "\n", "    ", "optimal_perturbation", "=", "tf", ".", "sign", "(", "grad", ")", "\n", "# The following line should not change the numerical results.", "\n", "# It applies only because `optimal_perturbation` is the output of", "\n", "# a `sign` op, which has zero derivative anyway.", "\n", "# It should not be applied for the other norms, where the", "\n", "# perturbation has a non-zero derivative.", "\n", "optimal_perturbation", "=", "tf", ".", "stop_gradient", "(", "optimal_perturbation", ")", "\n", "", "elif", "ord", "==", "1", ":", "\n", "    ", "abs_grad", "=", "tf", ".", "abs", "(", "grad", ")", "\n", "sign", "=", "tf", ".", "sign", "(", "grad", ")", "\n", "max_abs_grad", "=", "tf", ".", "reduce_max", "(", "abs_grad", ",", "red_ind", ",", "keepdims", "=", "True", ")", "\n", "tied_for_max", "=", "tf", ".", "to_float", "(", "tf", ".", "equal", "(", "abs_grad", ",", "max_abs_grad", ")", ")", "\n", "num_ties", "=", "tf", ".", "reduce_sum", "(", "tied_for_max", ",", "red_ind", ",", "keepdims", "=", "True", ")", "\n", "optimal_perturbation", "=", "sign", "*", "tied_for_max", "/", "num_ties", "\n", "", "elif", "ord", "==", "2", ":", "\n", "    ", "square", "=", "tf", ".", "maximum", "(", "avoid_zero_div", ",", "\n", "reduce_sum", "(", "tf", ".", "square", "(", "grad", ")", ",", "\n", "reduction_indices", "=", "red_ind", ",", "\n", "keepdims", "=", "True", ")", ")", "\n", "optimal_perturbation", "=", "grad", "/", "tf", ".", "sqrt", "(", "square", ")", "\n", "", "else", ":", "\n", "    ", "raise", "NotImplementedError", "(", "\"Only L-inf, L1 and L2 norms are \"", "\n", "\"currently implemented.\"", ")", "\n", "\n", "# Scale perturbation to be the solution for the norm=eps rather than", "\n", "# norm=1 problem", "\n", "", "scaled_perturbation", "=", "utils_tf", ".", "mul", "(", "eps", ",", "optimal_perturbation", ")", "\n", "return", "scaled_perturbation", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.SPSA.__init__": [[32, 46], ["cleverhans.attacks.attack.Attack.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", "SPSA", ",", "self", ")", ".", "__init__", "(", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "feedable_kwargs", "=", "(", "'eps'", ",", "'clip_min'", ",", "'clip_max'", ",", "'y'", ",", "'y_target'", ")", "\n", "self", ".", "structural_kwargs", "=", "[", "\n", "'nb_iter'", ",", "\n", "'spsa_samples'", ",", "\n", "'spsa_iters'", ",", "\n", "'early_stop_loss_threshold'", ",", "\n", "'is_debug'", ",", "\n", "'is_targeted'", ",", "\n", "]", "\n", "\n", "assert", "isinstance", "(", "self", ".", "model", ",", "Model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.SPSA.generate": [[47, 170], ["cleverhans.attacks_tf.SPSAAdam", "spsa.projected_optimization", "warnings.warn", "warnings.warn", "ValueError", "warnings.warn", "cleverhans.utils_tf.assert_equal", "warnings.warn", "spsa.SPSA.model.get_logits", "ValueError", "ValueError", "tensorflow.identity.get_shape().as_list", "tensorflow.control_dependencies", "tensorflow.identity", "ValueError", "cleverhans.attacks_tf.margin_logit_loss", "tensorflow.shape", "tensorflow.identity.get_shape().as_list", "tensorflow.identity.get_shape", "tensorflow.identity.get_shape", "spsa.SPSA.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.projected_optimization", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.margin_logit_loss"], ["", "def", "generate", "(", "self", ",", "\n", "x", ",", "\n", "y", "=", "None", ",", "\n", "y_target", "=", "None", ",", "\n", "eps", "=", "None", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "nb_iter", "=", "None", ",", "\n", "is_targeted", "=", "None", ",", "\n", "early_stop_loss_threshold", "=", "None", ",", "\n", "learning_rate", "=", "DEFAULT_LEARNING_RATE", ",", "\n", "delta", "=", "DEFAULT_DELTA", ",", "\n", "spsa_samples", "=", "DEFAULT_SPSA_SAMPLES", ",", "\n", "batch_size", "=", "None", ",", "\n", "spsa_iters", "=", "DEFAULT_SPSA_ITERS", ",", "\n", "is_debug", "=", "False", ",", "\n", "epsilon", "=", "None", ",", "\n", "num_steps", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples.\n\n    :param x: The model's symbolic inputs. Must be a batch of size 1.\n    :param y: A Tensor or None. The index of the correct label.\n    :param y_target: A Tensor or None. The index of the target label in a\n                     targeted attack.\n    :param eps: The size of the maximum perturbation, measured in the\n                L-infinity norm.\n    :param clip_min: If specified, the minimum input value\n    :param clip_max: If specified, the maximum input value\n    :param nb_iter: The number of optimization steps.\n    :param early_stop_loss_threshold: A float or None. If specified, the\n                                      attack will end as soon as the loss\n                                      is below `early_stop_loss_threshold`.\n    :param learning_rate: Learning rate of ADAM optimizer.\n    :param delta: Perturbation size used for SPSA approximation.\n    :param spsa_samples: Number of inputs to evaluate at a single time.\n                       The true batch size (the number of evaluated\n                       inputs for each update) is `spsa_samples *\n                       spsa_iters`\n    :param batch_size: Deprecated param that is an alias for spsa_samples\n    :param spsa_iters: Number of model evaluations before performing an\n                       update, where each evaluation is on `spsa_samples`\n                       different inputs.\n    :param is_debug: If True, print the adversarial loss after each update.\n    :param epsilon: Deprecated alias for `eps`\n    :param num_steps: Deprecated alias for `nb_iter`.\n    :param is_targeted: Deprecated argument. Ignored.\n    \"\"\"", "\n", "\n", "if", "epsilon", "is", "not", "None", ":", "\n", "      ", "if", "eps", "is", "not", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Should not specify both eps and its deprecated \"", "\n", "\"alias, epsilon\"", ")", "\n", "", "warnings", ".", "warn", "(", "\"`epsilon` is deprecated. Switch to `eps`. `epsilon` may \"", "\n", "\"be removed on or after 2019-04-15.\"", ")", "\n", "eps", "=", "epsilon", "\n", "", "del", "epsilon", "\n", "\n", "if", "num_steps", "is", "not", "None", ":", "\n", "      ", "if", "nb_iter", "is", "not", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"Should not specify both nb_iter and its deprecated \"", "\n", "\"alias, num_steps\"", ")", "\n", "", "warnings", ".", "warn", "(", "\"`num_steps` is deprecated. Switch to `nb_iter`. \"", "\n", "\"`num_steps` may be removed on or after 2019-04-15.\"", ")", "\n", "nb_iter", "=", "num_steps", "\n", "", "del", "num_steps", "\n", "assert", "nb_iter", "is", "not", "None", "\n", "\n", "if", "(", "y", "is", "not", "None", ")", "+", "(", "y_target", "is", "not", "None", ")", "!=", "1", ":", "\n", "      ", "raise", "ValueError", "(", "\"Must specify exactly one of y (untargeted attack, \"", "\n", "\"cause the input not to be classified as this true \"", "\n", "\"label) and y_target (targeted attack, cause the \"", "\n", "\"input to be classified as this target label).\"", ")", "\n", "\n", "", "if", "is_targeted", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"`is_targeted` is deprecated. Simply do not specify it.\"", "\n", "\" It may become an error to specify it on or after \"", "\n", "\"2019-04-15.\"", ")", "\n", "assert", "is_targeted", "==", "y_target", "is", "not", "None", "\n", "\n", "", "is_targeted", "=", "y_target", "is", "not", "None", "\n", "\n", "if", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "is", "None", ":", "\n", "      ", "check_batch", "=", "utils_tf", ".", "assert_equal", "(", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "1", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "check_batch", "]", ")", ":", "\n", "        ", "x", "=", "tf", ".", "identity", "(", "x", ")", "\n", "", "", "elif", "x", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "!=", "1", ":", "\n", "      ", "raise", "ValueError", "(", "\"For SPSA, input tensor x must have batch_size of 1.\"", ")", "\n", "\n", "", "if", "batch_size", "is", "not", "None", ":", "\n", "      ", "warnings", ".", "warn", "(", "\n", "'The \"batch_size\" argument to SPSA is deprecated, and will '", "\n", "'be removed on 2019-03-17. '", "\n", "'Please use spsa_samples instead.'", ")", "\n", "spsa_samples", "=", "batch_size", "\n", "\n", "", "optimizer", "=", "SPSAAdam", "(", "\n", "lr", "=", "learning_rate", ",", "\n", "delta", "=", "delta", ",", "\n", "num_samples", "=", "spsa_samples", ",", "\n", "num_iters", "=", "spsa_iters", ")", "\n", "\n", "def", "loss_fn", "(", "x", ",", "label", ")", ":", "\n", "      ", "logits", "=", "self", ".", "model", ".", "get_logits", "(", "x", ")", "\n", "loss_multiplier", "=", "1", "if", "is_targeted", "else", "-", "1", "\n", "return", "loss_multiplier", "*", "margin_logit_loss", "(", "\n", "logits", ",", "label", ",", "\n", "nb_classes", "=", "self", ".", "model", ".", "nb_classes", "or", "logits", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "y_attack", "=", "y_target", "if", "is_targeted", "else", "y", "\n", "adv_x", "=", "projected_optimization", "(", "\n", "loss_fn", ",", "\n", "x", ",", "\n", "y_attack", ",", "\n", "eps", ",", "\n", "num_steps", "=", "nb_iter", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "early_stop_loss_threshold", "=", "early_stop_loss_threshold", ",", "\n", "is_debug", "=", "is_debug", ",", "\n", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", "\n", ")", "\n", "return", "adv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.SPSA.generate_np": [[171, 200], ["kwargs.pop", "zip", "numpy.concatenate", "warnings.warn", "warnings.warn", "len", "len", "numpy.expand_dims", "super().generate_np", "x_adv.append"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.SPSA.generate_np"], ["", "def", "generate_np", "(", "self", ",", "x_val", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "\"epsilon\"", "in", "kwargs", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Using deprecated argument: see `generate`\"", ")", "\n", "assert", "\"eps\"", "not", "in", "kwargs", "\n", "kwargs", "[", "\"eps\"", "]", "=", "kwargs", "[", "\"epsilon\"", "]", "\n", "del", "kwargs", "[", "\"epsilon\"", "]", "\n", "", "assert", "\"eps\"", "in", "kwargs", "\n", "\n", "if", "\"num_steps\"", "in", "kwargs", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"Using deprecated argument: see `generate`\"", ")", "\n", "assert", "\"nb_iter\"", "not", "in", "kwargs", "\n", "kwargs", "[", "\"nb_iter\"", "]", "=", "kwargs", "[", "\"num_steps\"", "]", "\n", "del", "kwargs", "[", "\"num_steps\"", "]", "\n", "\n", "", "if", "'y'", "in", "kwargs", "and", "kwargs", "[", "'y'", "]", "is", "not", "None", ":", "\n", "      ", "assert", "kwargs", "[", "'y'", "]", ".", "dtype", "==", "np", ".", "int32", "\n", "", "if", "'y_target'", "in", "kwargs", "and", "kwargs", "[", "'y_target'", "]", "is", "not", "None", ":", "\n", "      ", "assert", "kwargs", "[", "'y_target'", "]", ".", "dtype", "==", "np", ".", "int32", "\n", "\n", "# Call self.generate() sequentially for each image in the batch", "\n", "", "x_adv", "=", "[", "]", "\n", "batch_size", "=", "x_val", ".", "shape", "[", "0", "]", "\n", "y", "=", "kwargs", ".", "pop", "(", "'y'", ",", "[", "None", "]", "*", "batch_size", ")", "\n", "assert", "len", "(", "x_val", ")", "==", "len", "(", "y", ")", ",", "'# of images and labels should match'", "\n", "for", "x_single", ",", "y_single", "in", "zip", "(", "x_val", ",", "y", ")", ":", "\n", "      ", "x", "=", "np", ".", "expand_dims", "(", "x_single", ",", "axis", "=", "0", ")", "\n", "adv_img", "=", "super", "(", "SPSA", ",", "self", ")", ".", "generate_np", "(", "x", ",", "y", "=", "y_single", ",", "**", "kwargs", ")", "\n", "x_adv", ".", "append", "(", "adv_img", ")", "\n", "", "return", "np", ".", "concatenate", "(", "x_adv", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa._project_perturbation": [[201, 224], ["NotImplementedError", "tensorflow.control_dependencies", "cleverhans.utils_tf.clip_by_value", "cleverhans.utils_tf.clip_by_value", "cleverhans.utils_tf.assert_less_equal", "cleverhans.utils_tf.assert_greater_equal", "tensorflow.cast", "tensorflow.cast"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.clip_by_value", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal"], ["", "", "def", "_project_perturbation", "(", "perturbation", ",", "epsilon", ",", "input_image", ",", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ")", ":", "\n", "  ", "\"\"\"Project `perturbation` onto L-infinity ball of radius `epsilon`.\n  Also project into hypercube such that the resulting adversarial example\n  is between clip_min and clip_max, if applicable.\n  \"\"\"", "\n", "\n", "if", "clip_min", "is", "None", "or", "clip_max", "is", "None", ":", "\n", "    ", "raise", "NotImplementedError", "(", "\"_project_perturbation currently has clipping \"", "\n", "\"hard-coded in.\"", ")", "\n", "\n", "# Ensure inputs are in the correct range", "\n", "", "with", "tf", ".", "control_dependencies", "(", "[", "\n", "utils_tf", ".", "assert_less_equal", "(", "input_image", ",", "\n", "tf", ".", "cast", "(", "clip_max", ",", "input_image", ".", "dtype", ")", ")", ",", "\n", "utils_tf", ".", "assert_greater_equal", "(", "input_image", ",", "\n", "tf", ".", "cast", "(", "clip_min", ",", "input_image", ".", "dtype", ")", ")", "\n", "]", ")", ":", "\n", "    ", "clipped_perturbation", "=", "utils_tf", ".", "clip_by_value", "(", "\n", "perturbation", ",", "-", "epsilon", ",", "epsilon", ")", "\n", "new_image", "=", "utils_tf", ".", "clip_by_value", "(", "\n", "input_image", "+", "clipped_perturbation", ",", "clip_min", ",", "clip_max", ")", "\n", "return", "new_image", "-", "input_image", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spsa.projected_optimization": [[226, 371], ["cleverhans.attacks_tf.TensorAdam", "tensorflow.random_uniform", "project_perturbation", "optimizer.init_state", "nest.flatten", "tensorflow.while_loop", "tensorflow.stop_gradient", "tensorflow.shape", "nest.pack_sequence_as", "optimizer.minimize", "project_perturbation", "tensorflow.less", "cleverhans.utils_tf.assert_less_equal", "tensorflow.no_op", "NotImplementedError", "cleverhans.utils_tf.assert_less_equal", "cleverhans.utils_tf.assert_greater_equal", "tensorflow.control_dependencies", "tensorflow.device", "tensorflow.Print", "tensorflow.cast", "tensorflow.cast", "loss_fn", "cleverhans.compat.reduce_mean", "nest.flatten", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "wrapped_loss_fn"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorAdam.init_state", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_less_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils_tf.assert_greater_equal", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "", "def", "projected_optimization", "(", "loss_fn", ",", "\n", "input_image", ",", "\n", "label", ",", "\n", "epsilon", ",", "\n", "num_steps", ",", "\n", "clip_min", "=", "None", ",", "\n", "clip_max", "=", "None", ",", "\n", "optimizer", "=", "TensorAdam", "(", ")", ",", "\n", "project_perturbation", "=", "_project_perturbation", ",", "\n", "early_stop_loss_threshold", "=", "None", ",", "\n", "is_debug", "=", "False", ")", ":", "\n", "  ", "\"\"\"Generic projected optimization, generalized to work with approximate\n  gradients. Used for e.g. the SPSA attack.\n\n  Args:\n    :param loss_fn: A callable which takes `input_image` and `label` as\n                    arguments, and returns a batch of loss values. Same\n                    interface as TensorOptimizer.\n    :param input_image: Tensor, a batch of images\n    :param label: Tensor, a batch of labels\n    :param epsilon: float, the L-infinity norm of the maximum allowable\n                    perturbation\n    :param num_steps: int, the number of steps of gradient descent\n    :param clip_min: float, minimum pixel value\n    :param clip_max: float, maximum pixel value\n    :param optimizer: A `TensorOptimizer` object\n    :param project_perturbation: A function, which will be used to enforce\n                                 some constraint. It should have the same\n                                 signature as `_project_perturbation`.\n    :param early_stop_loss_threshold: A float or None. If specified, the attack will end if the loss is below\n       `early_stop_loss_threshold`.\n        Enabling this option can have several different effects:\n          - Setting the threshold to 0. guarantees that if a successful attack is found, it is returned.\n            This increases the attack success rate, because without early stopping the optimizer can accidentally\n            bounce back to a point where the attack fails.\n          - Early stopping can make the attack run faster because it may run for fewer steps.\n          - Early stopping can make the attack run slower because the loss must be calculated at each step.\n            The loss is not calculated as part of the normal SPSA optimization procedure.\n            For most reasonable choices of hyperparameters, early stopping makes the attack much faster because\n            it decreases the number of steps dramatically.\n    :param is_debug: A bool. If True, print debug info for attack progress.\n\n  Returns:\n    adversarial version of `input_image`, with L-infinity difference less than\n      epsilon, which tries to minimize loss_fn.\n\n  Note that this function is not intended as an Attack by itself. Rather, it\n  is designed as a helper function which you can use to write your own attack\n  methods. The method uses a tf.while_loop to optimize a loss function in\n  a single sess.run() call.\n  \"\"\"", "\n", "assert", "num_steps", "is", "not", "None", "\n", "if", "is_debug", ":", "\n", "    ", "with", "tf", ".", "device", "(", "\"/cpu:0\"", ")", ":", "\n", "      ", "input_image", "=", "tf", ".", "Print", "(", "\n", "input_image", ",", "[", "]", ",", "\n", "\"Starting PGD attack with epsilon: %s\"", "%", "epsilon", ")", "\n", "\n", "", "", "init_perturbation", "=", "tf", ".", "random_uniform", "(", "\n", "tf", ".", "shape", "(", "input_image", ")", ",", "\n", "minval", "=", "tf", ".", "cast", "(", "-", "epsilon", ",", "input_image", ".", "dtype", ")", ",", "\n", "maxval", "=", "tf", ".", "cast", "(", "epsilon", ",", "input_image", ".", "dtype", ")", ",", "\n", "dtype", "=", "input_image", ".", "dtype", ")", "\n", "init_perturbation", "=", "project_perturbation", "(", "init_perturbation", ",", "epsilon", ",", "\n", "input_image", ",", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", ")", "\n", "init_optim_state", "=", "optimizer", ".", "init_state", "(", "[", "init_perturbation", "]", ")", "\n", "nest", "=", "tf", ".", "contrib", ".", "framework", ".", "nest", "\n", "\n", "def", "loop_body", "(", "i", ",", "perturbation", ",", "flat_optim_state", ")", ":", "\n", "    ", "\"\"\"Update perturbation to input image.\"\"\"", "\n", "optim_state", "=", "nest", ".", "pack_sequence_as", "(", "\n", "structure", "=", "init_optim_state", ",", "flat_sequence", "=", "flat_optim_state", ")", "\n", "\n", "def", "wrapped_loss_fn", "(", "x", ")", ":", "\n", "      ", "return", "loss_fn", "(", "input_image", "+", "x", ",", "label", ")", "\n", "\n", "", "new_perturbation_list", ",", "new_optim_state", "=", "optimizer", ".", "minimize", "(", "\n", "wrapped_loss_fn", ",", "[", "perturbation", "]", ",", "optim_state", ")", "\n", "projected_perturbation", "=", "project_perturbation", "(", "new_perturbation_list", "[", "0", "]", ",", "\n", "epsilon", ",", "input_image", ",", "\n", "clip_min", "=", "clip_min", ",", "\n", "clip_max", "=", "clip_max", ")", "\n", "\n", "# Be careful with this bool. A value of 0. is a valid threshold but evaluates to False, so we must explicitly", "\n", "# check whether the value is None.", "\n", "early_stop", "=", "early_stop_loss_threshold", "is", "not", "None", "\n", "compute_loss", "=", "is_debug", "or", "early_stop", "\n", "# Don't waste time building the loss graph if we're not going to use it", "\n", "if", "compute_loss", ":", "\n", "# NOTE: this step is not actually redundant with the optimizer step.", "\n", "# SPSA calculates the loss at randomly perturbed points but doesn't calculate the loss at the current point.", "\n", "      ", "loss", "=", "reduce_mean", "(", "wrapped_loss_fn", "(", "projected_perturbation", ")", ",", "axis", "=", "0", ")", "\n", "\n", "if", "is_debug", ":", "\n", "        ", "with", "tf", ".", "device", "(", "\"/cpu:0\"", ")", ":", "\n", "          ", "loss", "=", "tf", ".", "Print", "(", "loss", ",", "[", "loss", "]", ",", "\"Total batch loss\"", ")", "\n", "\n", "", "", "if", "early_stop", ":", "\n", "        ", "i", "=", "tf", ".", "cond", "(", "tf", ".", "less", "(", "loss", ",", "early_stop_loss_threshold", ")", ",", "lambda", ":", "float", "(", "num_steps", ")", ",", "lambda", ":", "i", ")", "\n", "\n", "", "", "return", "i", "+", "1", ",", "projected_perturbation", ",", "nest", ".", "flatten", "(", "new_optim_state", ")", "\n", "\n", "", "def", "cond", "(", "i", ",", "*", "_", ")", ":", "\n", "    ", "return", "tf", ".", "less", "(", "i", ",", "num_steps", ")", "\n", "\n", "", "flat_init_optim_state", "=", "nest", ".", "flatten", "(", "init_optim_state", ")", "\n", "_", ",", "final_perturbation", ",", "_", "=", "tf", ".", "while_loop", "(", "\n", "cond", ",", "\n", "loop_body", ",", "\n", "loop_vars", "=", "(", "tf", ".", "constant", "(", "0.", ")", ",", "init_perturbation", ",", "flat_init_optim_state", ")", ",", "\n", "parallel_iterations", "=", "1", ",", "\n", "back_prop", "=", "False", ",", "\n", "maximum_iterations", "=", "num_steps", ")", "\n", "if", "project_perturbation", "is", "_project_perturbation", ":", "\n", "# TODO: this assert looks totally wrong.", "\n", "# Not bothering to fix it now because it's only an assert.", "\n", "# 1) Multiplying by 1.1 gives a huge margin of error. This should probably", "\n", "#    take the difference and allow a tolerance of 1e-6 or something like", "\n", "#    that.", "\n", "# 2) I think it should probably check the *absolute value* of", "\n", "# final_perturbation", "\n", "    ", "perturbation_max", "=", "epsilon", "*", "1.1", "\n", "check_diff", "=", "utils_tf", ".", "assert_less_equal", "(", "\n", "final_perturbation", ",", "\n", "tf", ".", "cast", "(", "perturbation_max", ",", "final_perturbation", ".", "dtype", ")", ",", "\n", "message", "=", "\"final_perturbation must change no pixel by more than \"", "\n", "\"%s\"", "%", "perturbation_max", ")", "\n", "", "else", ":", "\n", "# TODO: let caller pass in a check_diff function as well as", "\n", "# project_perturbation", "\n", "    ", "check_diff", "=", "tf", ".", "no_op", "(", ")", "\n", "\n", "", "if", "clip_min", "is", "None", "or", "clip_max", "is", "None", ":", "\n", "    ", "raise", "NotImplementedError", "(", "\"This function only supports clipping for now\"", ")", "\n", "", "check_range", "=", "[", "utils_tf", ".", "assert_less_equal", "(", "input_image", ",", "\n", "tf", ".", "cast", "(", "clip_max", ",", "\n", "input_image", ".", "dtype", ")", ")", ",", "\n", "utils_tf", ".", "assert_greater_equal", "(", "input_image", ",", "\n", "tf", ".", "cast", "(", "clip_min", ",", "\n", "input_image", ".", "dtype", ")", ")", "]", "\n", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "check_diff", "]", "+", "check_range", ")", ":", "\n", "    ", "adversarial_image", "=", "input_image", "+", "final_perturbation", "\n", "", "return", "tf", ".", "stop_gradient", "(", "adversarial_image", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.__init__": [[12, 29], ["cleverhans.attacks.attack.Attack.__init__"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "sess", "=", "None", ",", "dtypestr", "=", "'float32'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a SpatialTransformationMethod instance.\n    Note: the model parameter should be an instance of the\n    cleverhans.model.Model abstraction provided by CleverHans.\n\n  :param model: cleverhans.model.Model\n  :param sess: optional tf.Session\n  :param dtypestr: dtype of the data\n  :param kwargs: passed through to super constructor\n    \"\"\"", "\n", "\n", "super", "(", "SpatialTransformationMethod", ",", "self", ")", ".", "__init__", "(", "\n", "model", ",", "sess", ",", "dtypestr", ",", "**", "kwargs", ")", "\n", "self", ".", "feedable_kwargs", "=", "(", "'n_samples'", ",", "'dx_min'", ",", "'dx_max'", ",", "'n_dxs'", ",", "'dy_min'", ",", "\n", "'dy_max'", ",", "'n_dys'", ",", "'angle_min'", ",", "'angle_max'", ",", "\n", "'n_angles'", ",", "'black_border_size'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate": [[30, 52], ["spatial_transformation_method.SpatialTransformationMethod.parse_params", "spatial_transformation_method.SpatialTransformationMethod.get_or_guess_labels", "spm"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.attack.Attack.get_or_guess_labels", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.spm"], ["", "def", "generate", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Generate symbolic graph for adversarial examples and return.\n    :param x: The model's symbolic inputs.\n    :param kwargs: See `parse_params`\n    \"\"\"", "\n", "# Parse and save attack-specific parameters", "\n", "assert", "self", ".", "parse_params", "(", "**", "kwargs", ")", "\n", "\n", "from", "cleverhans", ".", "attacks_tf", "import", "spm", "\n", "\n", "labels", ",", "_", "=", "self", ".", "get_or_guess_labels", "(", "x", ",", "kwargs", ")", "\n", "\n", "return", "spm", "(", "\n", "x", ",", "\n", "self", ".", "model", ",", "\n", "y", "=", "labels", ",", "\n", "n_samples", "=", "self", ".", "n_samples", ",", "\n", "dx_min", "=", "self", ".", "dx_min", ",", "dx_max", "=", "self", ".", "dx_max", ",", "n_dxs", "=", "self", ".", "n_dxs", ",", "\n", "dy_min", "=", "self", ".", "dy_min", ",", "dy_max", "=", "self", ".", "dy_max", ",", "n_dys", "=", "self", ".", "n_dys", ",", "\n", "angle_min", "=", "self", ".", "angle_min", ",", "angle_max", "=", "self", ".", "angle_max", ",", "\n", "n_angles", "=", "self", ".", "n_angles", ",", "black_border_size", "=", "self", ".", "black_border_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.parse_params": [[53, 106], ["ValueError", "len", "warnings.warn", "kwargs.keys"], "methods", ["None"], ["", "def", "parse_params", "(", "self", ",", "\n", "n_samples", "=", "None", ",", "\n", "dx_min", "=", "-", "0.1", ",", "\n", "dx_max", "=", "0.1", ",", "\n", "n_dxs", "=", "2", ",", "\n", "dy_min", "=", "-", "0.1", ",", "\n", "dy_max", "=", "0.1", ",", "\n", "n_dys", "=", "2", ",", "\n", "angle_min", "=", "-", "30", ",", "\n", "angle_max", "=", "30", ",", "\n", "n_angles", "=", "6", ",", "\n", "black_border_size", "=", "0", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Take in a dictionary of parameters and applies attack-specific checks\n    before saving them as attributes.\n    :param n_samples: (optional) The number of transformations sampled to\n                      construct the attack. Set it to None to run\n                      full grid attack.\n    :param dx_min: (optional float) Minimum translation ratio along x-axis.\n    :param dx_max: (optional float) Maximum translation ratio along x-axis.\n    :param n_dxs: (optional int) Number of discretized translation ratios\n                  along x-axis.\n    :param dy_min: (optional float) Minimum translation ratio along y-axis.\n    :param dy_max: (optional float) Maximum translation ratio along y-axis.\n    :param n_dys: (optional int) Number of discretized translation ratios\n                  along y-axis.\n    :param angle_min: (optional float) Largest counter-clockwise rotation\n                      angle.\n    :param angle_max: (optional float) Largest clockwise rotation angle.\n    :param n_angles: (optional int) Number of discretized angles.\n    :param black_border_size: (optional int) size of the black border in pixels.\n    \"\"\"", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "dx_min", "=", "dx_min", "\n", "self", ".", "dx_max", "=", "dx_max", "\n", "self", ".", "n_dxs", "=", "n_dxs", "\n", "self", ".", "dy_min", "=", "dy_min", "\n", "self", ".", "dy_max", "=", "dy_max", "\n", "self", ".", "n_dys", "=", "n_dys", "\n", "self", ".", "angle_min", "=", "angle_min", "\n", "self", ".", "angle_max", "=", "angle_max", "\n", "self", ".", "n_angles", "=", "n_angles", "\n", "self", ".", "black_border_size", "=", "black_border_size", "\n", "\n", "if", "self", ".", "dx_min", "<", "-", "1", "or", "self", ".", "dy_min", "<", "-", "1", "or", "self", ".", "dx_max", ">", "1", "or", "self", ".", "dy_max", ">", "1", ":", "\n", "      ", "raise", "ValueError", "(", "\"The value of translation must be bounded \"", "\n", "\"within [-1, 1]\"", ")", "\n", "", "if", "len", "(", "kwargs", ".", "keys", "(", ")", ")", ">", "0", ":", "\n", "      ", "warnings", ".", "warn", "(", "\"kwargs is unused and will be removed on or after \"", "\n", "\"2019-04-26.\"", ")", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.__init__": [[15, 88], ["tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.reshape", "dual_formulation.DualFormulation.lower.append", "dual_formulation.DualFormulation.upper.append", "range", "range", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.nn.relu", "tensorflow.nn.relu", "dual_formulation.DualFormulation.lower.append", "dual_formulation.DualFormulation.upper.append", "dual_formulation.DualFormulation.dual_index.append", "tensorflow.size", "dual_formulation.DualFormulation.nn_params.forward_pass", "dual_formulation.DualFormulation.nn_params.forward_pass", "dual_formulation.DualFormulation.nn_params.forward_pass", "dual_formulation.DualFormulation.nn_params.forward_pass"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass"], ["def", "__init__", "(", "self", ",", "dual_var", ",", "neural_net_param_object", ",", "test_input", ",", "true_class", ",", "\n", "adv_class", ",", "input_minval", ",", "input_maxval", ",", "epsilon", ")", ":", "\n", "    ", "\"\"\"Initializes dual formulation class.\n\n    Args:\n      dual_var: dictionary of dual variables containing a) lambda_pos\n        b) lambda_neg, c) lambda_quad, d) lambda_lu\n      neural_net_param_object: NeuralNetParam object created for\n        the network under consideration\n      test_input: clean example to certify around\n      true_class: the class label of the test input\n      adv_class: the label that the adversary tried to perturb input to\n      input_minval: minimum value of valid input range\n      input_maxval: maximum value of valid input range\n      epsilon: Size of the perturbation (scaled for [0, 1] input)\n    \"\"\"", "\n", "self", ".", "nn_params", "=", "neural_net_param_object", "\n", "self", ".", "test_input", "=", "tf", ".", "convert_to_tensor", "(", "test_input", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "true_class", "=", "true_class", "\n", "self", ".", "adv_class", "=", "adv_class", "\n", "self", ".", "input_minval", "=", "tf", ".", "convert_to_tensor", "(", "input_minval", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "input_maxval", "=", "tf", ".", "convert_to_tensor", "(", "input_maxval", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "epsilon", "=", "tf", ".", "convert_to_tensor", "(", "epsilon", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "final_linear", "=", "(", "self", ".", "nn_params", ".", "final_weights", "[", "adv_class", ",", ":", "]", "\n", "-", "self", ".", "nn_params", ".", "final_weights", "[", "true_class", ",", ":", "]", ")", "\n", "self", ".", "final_linear", "=", "tf", ".", "reshape", "(", "self", ".", "final_linear", ",", "\n", "shape", "=", "[", "tf", ".", "size", "(", "self", ".", "final_linear", ")", ",", "1", "]", ")", "\n", "self", ".", "final_constant", "=", "(", "self", ".", "nn_params", ".", "final_bias", "[", "adv_class", "]", "\n", "-", "self", ".", "nn_params", ".", "final_bias", "[", "true_class", "]", ")", "\n", "\n", "# Computing lower and upper bounds", "\n", "# Note that lower and upper are of size nn_params.num_hidden_layers + 1", "\n", "self", ".", "lower", "=", "[", "]", "\n", "self", ".", "upper", "=", "[", "]", "\n", "\n", "# Initializing at the input layer with \\ell_\\infty constraints", "\n", "self", ".", "lower", ".", "append", "(", "\n", "tf", ".", "maximum", "(", "self", ".", "test_input", "-", "self", ".", "epsilon", ",", "self", ".", "input_minval", ")", ")", "\n", "self", ".", "upper", ".", "append", "(", "\n", "tf", ".", "minimum", "(", "self", ".", "test_input", "+", "self", ".", "epsilon", ",", "self", ".", "input_maxval", ")", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "nn_params", ".", "num_hidden_layers", ")", ":", "\n", "      ", "current_lower", "=", "tf", ".", "nn", ".", "relu", "(", "0.5", "*", "(", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "lower", "[", "i", "]", "+", "self", ".", "upper", "[", "i", "]", ",", "i", ")", "\n", "+", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "lower", "[", "i", "]", "-", "self", ".", "upper", "[", "i", "]", ",", "i", ",", "\n", "is_abs", "=", "True", ")", ")", "\n", "+", "self", ".", "nn_params", ".", "biases", "[", "i", "]", ")", "\n", "current_upper", "=", "tf", ".", "nn", ".", "relu", "(", "0.5", "*", "(", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "lower", "[", "i", "]", "+", "self", ".", "upper", "[", "i", "]", ",", "i", ")", "\n", "+", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "upper", "[", "i", "]", "-", "self", ".", "lower", "[", "i", "]", ",", "i", ",", "\n", "is_abs", "=", "True", ")", ")", "\n", "+", "self", ".", "nn_params", ".", "biases", "[", "i", "]", ")", "\n", "self", ".", "lower", ".", "append", "(", "current_lower", ")", "\n", "self", ".", "upper", ".", "append", "(", "current_upper", ")", "\n", "\n", "# Computing the optimization terms", "\n", "", "self", ".", "lambda_pos", "=", "[", "x", "for", "x", "in", "dual_var", "[", "'lambda_pos'", "]", "]", "\n", "self", ".", "lambda_neg", "=", "[", "x", "for", "x", "in", "dual_var", "[", "'lambda_neg'", "]", "]", "\n", "self", ".", "lambda_quad", "=", "[", "x", "for", "x", "in", "dual_var", "[", "'lambda_quad'", "]", "]", "\n", "self", ".", "lambda_lu", "=", "[", "x", "for", "x", "in", "dual_var", "[", "'lambda_lu'", "]", "]", "\n", "self", ".", "nu", "=", "dual_var", "[", "'nu'", "]", "\n", "self", ".", "vector_g", "=", "None", "\n", "self", ".", "scalar_f", "=", "None", "\n", "self", ".", "matrix_h", "=", "None", "\n", "self", ".", "matrix_m", "=", "None", "\n", "\n", "# The primal vector in the SDP can be thought of as [layer_1, layer_2..]", "\n", "# In this concatenated version, dual_index[i] that marks the start", "\n", "# of layer_i", "\n", "# This is useful while computing implicit products with matrix H", "\n", "self", ".", "dual_index", "=", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "nn_params", ".", "num_hidden_layers", "+", "1", ")", ":", "\n", "      ", "self", ".", "dual_index", ".", "append", "(", "self", ".", "dual_index", "[", "-", "1", "]", "+", "\n", "self", ".", "nn_params", ".", "sizes", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective": [[89, 139], ["range", "range", "range", "g_rows.append", "tensorflow.concat", "g_rows.append", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "dual_formulation.DualFormulation.nn_params.forward_pass", "dual_formulation.DualFormulation.nn_params.forward_pass"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass"], ["", "", "def", "set_differentiable_objective", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function that constructs minimization objective from dual variables.\"\"\"", "\n", "# Checking if graphs are already created", "\n", "if", "self", ".", "vector_g", "is", "not", "None", ":", "\n", "      ", "return", "\n", "\n", "# Computing the scalar term", "\n", "", "bias_sum", "=", "0", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "nn_params", ".", "num_hidden_layers", ")", ":", "\n", "      ", "bias_sum", "=", "bias_sum", "+", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "multiply", "(", "self", ".", "nn_params", ".", "biases", "[", "i", "]", ",", "self", ".", "lambda_pos", "[", "i", "+", "1", "]", ")", ")", "\n", "", "lu_sum", "=", "0", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "nn_params", ".", "num_hidden_layers", "+", "1", ")", ":", "\n", "      ", "lu_sum", "=", "lu_sum", "+", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "multiply", "(", "tf", ".", "multiply", "(", "self", ".", "lower", "[", "i", "]", ",", "self", ".", "upper", "[", "i", "]", ")", ",", "\n", "self", ".", "lambda_lu", "[", "i", "]", ")", ")", "\n", "\n", "", "self", ".", "scalar_f", "=", "-", "bias_sum", "-", "lu_sum", "+", "self", ".", "final_constant", "\n", "\n", "# Computing the vector term", "\n", "g_rows", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "nn_params", ".", "num_hidden_layers", ")", ":", "\n", "      ", "if", "i", ">", "0", ":", "\n", "        ", "current_row", "=", "(", "self", ".", "lambda_neg", "[", "i", "]", "+", "self", ".", "lambda_pos", "[", "i", "]", "-", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "lambda_pos", "[", "i", "+", "1", "]", ",", "\n", "i", ",", "is_transpose", "=", "True", ")", "+", "\n", "tf", ".", "multiply", "(", "self", ".", "lower", "[", "i", "]", "+", "self", ".", "upper", "[", "i", "]", ",", "\n", "self", ".", "lambda_lu", "[", "i", "]", ")", "+", "\n", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "]", ",", "\n", "self", ".", "nn_params", ".", "biases", "[", "i", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "current_row", "=", "(", "-", "self", ".", "nn_params", ".", "forward_pass", "(", "self", ".", "lambda_pos", "[", "i", "+", "1", "]", ",", "\n", "i", ",", "is_transpose", "=", "True", ")", "\n", "+", "tf", ".", "multiply", "(", "self", ".", "lower", "[", "i", "]", "+", "self", ".", "upper", "[", "i", "]", ",", "\n", "self", ".", "lambda_lu", "[", "i", "]", ")", ")", "\n", "", "g_rows", ".", "append", "(", "current_row", ")", "\n", "\n", "# Term for final linear term", "\n", "", "g_rows", ".", "append", "(", "(", "self", ".", "lambda_pos", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "self", ".", "lambda_neg", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "self", ".", "final_linear", "+", "\n", "tf", ".", "multiply", "(", "(", "self", ".", "lower", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "self", ".", "upper", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ")", ",", "\n", "self", ".", "lambda_lu", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ")", "\n", "+", "tf", ".", "multiply", "(", "\n", "self", ".", "lambda_quad", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ",", "\n", "self", ".", "nn_params", ".", "biases", "[", "\n", "self", ".", "nn_params", ".", "num_hidden_layers", "-", "1", "]", ")", ")", ")", "\n", "self", ".", "vector_g", "=", "tf", ".", "concat", "(", "g_rows", ",", "axis", "=", "0", ")", "\n", "self", ".", "unconstrained_objective", "=", "self", ".", "scalar_f", "+", "0.5", "*", "self", ".", "nu", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_psd_product": [[140, 195], ["tensorflow.reshape", "range", "tensorflow.concat", "dual_formulation.DualFormulation.set_differentiable_objective", "tensorflow.concat", "h_beta_rows.append", "tensorflow.multiply", "h_beta_rows.append", "tensorflow.multiply", "tensorflow.multiply", "dual_formulation.DualFormulation.nn_params.forward_pass", "dual_formulation.DualFormulation.nn_params.forward_pass", "tensorflow.reduce_sum", "tensorflow.multiply", "tensorflow.multiply", "dual_formulation.DualFormulation.nn_params.forward_pass", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply", "tensorflow.multiply"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass"], ["", "def", "get_psd_product", "(", "self", ",", "vector", ")", ":", "\n", "    ", "\"\"\"Function that provides matrix product interface with PSD matrix.\n\n    Args:\n      vector: the vector to be multiplied with matrix M\n\n\n    Returns:\n      result_product: Matrix product of M and vector\n    \"\"\"", "\n", "# For convenience, think of x as [\\alpha, \\beta]", "\n", "alpha", "=", "tf", ".", "reshape", "(", "vector", "[", "0", "]", ",", "shape", "=", "[", "1", ",", "1", "]", ")", "\n", "beta", "=", "vector", "[", "1", ":", "]", "\n", "# Computing the product of matrix_h with beta part of vector", "\n", "# At first layer, h is simply diagonal", "\n", "h_beta_rows", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "nn_params", ".", "num_hidden_layers", ")", ":", "\n", "# Split beta of this block into [gamma, delta]", "\n", "      ", "gamma", "=", "beta", "[", "self", ".", "dual_index", "[", "i", "]", ":", "self", ".", "dual_index", "[", "i", "+", "1", "]", "]", "\n", "delta", "=", "beta", "[", "self", ".", "dual_index", "[", "i", "+", "1", "]", ":", "self", ".", "dual_index", "[", "i", "+", "2", "]", "]", "\n", "\n", "# Expanding the product with diagonal matrices", "\n", "if", "i", "==", "0", ":", "\n", "        ", "h_beta_rows", ".", "append", "(", "tf", ".", "multiply", "(", "2", "*", "self", ".", "lambda_lu", "[", "i", "]", ",", "gamma", ")", "-", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "\n", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "+", "1", "]", ",", "delta", ")", ",", "\n", "i", ",", "is_transpose", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "        ", "h_beta_rows", "[", "i", "]", "=", "(", "h_beta_rows", "[", "i", "]", "+", "\n", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "]", "+", "\n", "self", ".", "lambda_lu", "[", "i", "]", ",", "gamma", ")", "-", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "\n", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "+", "1", "]", ",", "delta", ")", ",", "\n", "i", ",", "is_transpose", "=", "True", ")", ")", "\n", "\n", "", "new_row", "=", "(", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "+", "1", "]", "+", "self", ".", "lambda_lu", "[", "i", "+", "1", "]", ",", "delta", ")", "\n", "-", "tf", ".", "multiply", "(", "self", ".", "lambda_quad", "[", "i", "+", "1", "]", ",", "\n", "self", ".", "nn_params", ".", "forward_pass", "(", "gamma", ",", "i", ")", ")", ")", "\n", "h_beta_rows", ".", "append", "(", "new_row", ")", "\n", "\n", "# Last boundary case", "\n", "", "h_beta_rows", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "=", "(", "\n", "h_beta_rows", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "tf", ".", "multiply", "(", "(", "self", ".", "lambda_quad", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "self", ".", "lambda_lu", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ")", ",", "\n", "delta", ")", ")", "\n", "\n", "h_beta", "=", "tf", ".", "concat", "(", "h_beta_rows", ",", "axis", "=", "0", ")", "\n", "\n", "# Constructing final result using vector_g", "\n", "self", ".", "set_differentiable_objective", "(", ")", "\n", "result", "=", "tf", ".", "concat", "(", "[", "alpha", "*", "self", ".", "nu", "+", "tf", ".", "reduce_sum", "(", "\n", "tf", ".", "multiply", "(", "beta", ",", "self", ".", "vector_g", ")", ")", "\n", ",", "tf", ".", "multiply", "(", "alpha", ",", "self", ".", "vector_g", ")", "+", "h_beta", "]", ",", "axis", "=", "0", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.compute_certificate": [[196, 207], ["dual_formulation.DualFormulation.set_differentiable_objective", "dual_formulation.DualFormulation.get_full_psd_matrix", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.transpose", "tensorflow.matrix_inverse"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix"], ["", "def", "compute_certificate", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function to compute the certificate associated with feasible solution.\"\"\"", "\n", "self", ".", "set_differentiable_objective", "(", ")", "\n", "self", ".", "get_full_psd_matrix", "(", ")", "\n", "# TODO: replace matrix_inverse with functin which uses matrix-vector product", "\n", "projected_certificate", "=", "(", "\n", "self", ".", "scalar_f", "+", "\n", "0.5", "*", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "tf", ".", "transpose", "(", "self", ".", "vector_g", ")", ",", "\n", "tf", ".", "matrix_inverse", "(", "self", ".", "matrix_h", ")", ")", ",", "\n", "self", ".", "vector_g", ")", ")", "\n", "return", "projected_certificate", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.project_dual": [[208, 287], ["tensorflow.identity", "dual_formulation.DualFormulation", "dual_formulation.DualFormulation.compute_certificate", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.identity", "tensorflow.where", "tensorflow.matmul", "tensorflow.self_adjoint_eigvals", "tensorflow.reduce_min", "tensorflow.self_adjoint_eigvals", "tensorflow.reduce_min", "range", "tensorflow.divide", "tensorflow.is_nan", "tensorflow.zeros_like", "tensorflow.matmul", "cleverhans.experimental.certification.utils.diag", "tensorflow.square", "tensorflow.transpose", "cleverhans.experimental.certification.utils.diag", "tensorflow.transpose", "tensorflow.maximum", "tensorflow.maximum"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.compute_certificate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_min", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag"], ["", "def", "project_dual", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function that projects the input dual variables onto the feasible set.\n\n    Returns:\n      projected_dual: Feasible dual solution corresponding to current dual\n      projected_certificate: Objective value of feasible dual\n    \"\"\"", "\n", "# TODO: consider whether we can use shallow copy of the lists without", "\n", "# using tf.identity", "\n", "projected_lambda_pos", "=", "[", "tf", ".", "identity", "(", "x", ")", "for", "x", "in", "self", ".", "lambda_pos", "]", "\n", "projected_lambda_neg", "=", "[", "tf", ".", "identity", "(", "x", ")", "for", "x", "in", "self", ".", "lambda_neg", "]", "\n", "projected_lambda_quad", "=", "[", "tf", ".", "identity", "(", "x", ")", "for", "x", "in", "self", ".", "lambda_quad", "]", "\n", "projected_lambda_lu", "=", "[", "tf", ".", "identity", "(", "x", ")", "for", "x", "in", "self", ".", "lambda_lu", "]", "\n", "projected_nu", "=", "tf", ".", "identity", "(", "self", ".", "nu", ")", "\n", "\n", "# TODO: get rid of the special case for one hidden layer", "\n", "# Different projection for 1 hidden layer", "\n", "if", "self", ".", "nn_params", ".", "num_hidden_layers", "==", "1", ":", "\n", "# Creating equivalent PSD matrix for H by Schur complements", "\n", "      ", "diag_entries", "=", "0.5", "*", "tf", ".", "divide", "(", "\n", "tf", ".", "square", "(", "self", ".", "lambda_quad", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ")", ",", "\n", "(", "self", ".", "lambda_quad", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", "+", "\n", "self", ".", "lambda_lu", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "]", ")", ")", "\n", "# If lambda_quad[i], lambda_lu[i] are 0, entry is NaN currently,", "\n", "# but we want to set that to 0", "\n", "diag_entries", "=", "tf", ".", "where", "(", "tf", ".", "is_nan", "(", "diag_entries", ")", ",", "\n", "tf", ".", "zeros_like", "(", "diag_entries", ")", ",", "diag_entries", ")", "\n", "matrix", "=", "(", "\n", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "tf", ".", "transpose", "(", "\n", "self", ".", "nn_params", ".", "weights", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "-", "1", "]", ")", ",", "\n", "utils", ".", "diag", "(", "diag_entries", ")", ")", ",", "\n", "self", ".", "nn_params", ".", "weights", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "-", "1", "]", ")", ")", "\n", "new_matrix", "=", "utils", ".", "diag", "(", "\n", "2", "*", "self", ".", "lambda_lu", "[", "self", ".", "nn_params", ".", "num_hidden_layers", "-", "1", "]", ")", "-", "matrix", "\n", "# Making symmetric", "\n", "new_matrix", "=", "0.5", "*", "(", "new_matrix", "+", "tf", ".", "transpose", "(", "new_matrix", ")", ")", "\n", "eig_vals", "=", "tf", ".", "self_adjoint_eigvals", "(", "new_matrix", ")", "\n", "min_eig", "=", "tf", ".", "reduce_min", "(", "eig_vals", ")", "\n", "# If min_eig is positive, already feasible, so don't add", "\n", "# Otherwise add to make PSD [1E-6 is for ensuring strictly PSD (useful", "\n", "# while inverting)", "\n", "projected_lambda_lu", "[", "0", "]", "=", "(", "projected_lambda_lu", "[", "0", "]", "+", "\n", "0.5", "*", "tf", ".", "maximum", "(", "-", "min_eig", ",", "0", ")", "+", "1E-6", ")", "\n", "\n", "", "else", ":", "\n", "# Minimum eigen value of H", "\n", "# TODO: Write this in terms of matrix multiply", "\n", "# matrix H is a submatrix of M, thus we just need to extend existing code", "\n", "# for computing matrix-vector product (see get_psd_product function).", "\n", "# Then use the same trick to compute smallest eigenvalue.", "\n", "      ", "eig_vals", "=", "tf", ".", "self_adjoint_eigvals", "(", "self", ".", "matrix_h", ")", "\n", "min_eig", "=", "tf", ".", "reduce_min", "(", "eig_vals", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "nn_params", ".", "num_hidden_layers", "+", "1", ")", ":", "\n", "# Since lambda_lu appears only in diagonal terms, can subtract to", "\n", "# make PSD and feasible", "\n", "        ", "projected_lambda_lu", "[", "i", "]", "=", "(", "projected_lambda_lu", "[", "i", "]", "+", "\n", "0.5", "*", "tf", ".", "maximum", "(", "-", "min_eig", ",", "0", ")", "+", "1E-6", ")", "\n", "# Adjusting lambda_neg wherever possible so that lambda_neg + lambda_lu", "\n", "# remains close to unchanged", "\n", "# projected_lambda_neg[i] = tf.maximum(0.0, projected_lambda_neg[i] +", "\n", "#                                     (0.5*min_eig - 1E-6)*", "\n", "#                                     (self.lower[i] + self.upper[i]))", "\n", "\n", "", "", "projected_dual_var", "=", "{", "'lambda_pos'", ":", "projected_lambda_pos", ",", "\n", "'lambda_neg'", ":", "projected_lambda_neg", ",", "\n", "'lambda_lu'", ":", "projected_lambda_lu", ",", "\n", "'lambda_quad'", ":", "projected_lambda_quad", ",", "\n", "'nu'", ":", "projected_nu", "}", "\n", "projected_dual_object", "=", "DualFormulation", "(", "projected_dual_var", ",", "\n", "self", ".", "nn_params", ",", "\n", "self", ".", "test_input", ",", "\n", "self", ".", "true_class", ",", "\n", "self", ".", "adv_class", ",", "\n", "self", ".", "input_minval", ",", "\n", "self", ".", "input_maxval", ",", "\n", "self", ".", "epsilon", ")", "\n", "projected_certificate", "=", "projected_dual_object", ".", "compute_certificate", "(", ")", "\n", "return", "projected_certificate", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix": [[288, 329], ["range", "tensorflow.concat", "dual_formulation.DualFormulation.set_differentiable_objective", "tensorflow.concat", "range", "range", "tensorflow.concat", "h_columns.append", "tensorflow.transpose", "current_col_elems.append", "current_col_elems.append", "current_col_elems.append", "current_col_elems.append", "current_col_elems.append", "tensorflow.concat", "tensorflow.concat", "tensorflow.zeros", "cleverhans.experimental.certification.utils.diag", "cleverhans.experimental.certification.utils.diag", "tensorflow.matmul", "tensorflow.zeros", "cleverhans.experimental.certification.utils.diag", "tensorflow.transpose"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag"], ["", "def", "get_full_psd_matrix", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function that retuns the tf graph corresponding to the entire matrix M.\n\n\n    Returns:\n      matrix_h: unrolled version of tf matrix corresponding to H\n      matrix_m: unrolled tf matrix corresponding to M\n    \"\"\"", "\n", "# Computing the matrix term", "\n", "h_columns", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "nn_params", ".", "num_hidden_layers", "+", "1", ")", ":", "\n", "      ", "current_col_elems", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "        ", "current_col_elems", ".", "append", "(", "tf", ".", "zeros", "(", "[", "self", ".", "nn_params", ".", "sizes", "[", "j", "]", ",", "\n", "self", ".", "nn_params", ".", "sizes", "[", "i", "]", "]", ")", ")", "\n", "\n", "# For the first layer, there is no relu constraint", "\n", "", "if", "i", "==", "0", ":", "\n", "        ", "current_col_elems", ".", "append", "(", "utils", ".", "diag", "(", "self", ".", "lambda_lu", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "current_col_elems", ".", "append", "(", "utils", ".", "diag", "(", "self", ".", "lambda_lu", "[", "i", "]", "+", "\n", "self", ".", "lambda_quad", "[", "i", "]", ")", ")", "\n", "", "if", "i", "<", "self", ".", "nn_params", ".", "num_hidden_layers", ":", "\n", "        ", "current_col_elems", ".", "append", "(", "(", "\n", "(", "tf", ".", "matmul", "(", "utils", ".", "diag", "(", "-", "1", "*", "self", ".", "lambda_quad", "[", "i", "+", "1", "]", ")", ",", "\n", "self", ".", "nn_params", ".", "weights", "[", "i", "]", ")", ")", ")", ")", "\n", "", "for", "j", "in", "range", "(", "i", "+", "2", ",", "self", ".", "nn_params", ".", "num_hidden_layers", "+", "1", ")", ":", "\n", "        ", "current_col_elems", ".", "append", "(", "tf", ".", "zeros", "(", "[", "self", ".", "nn_params", ".", "sizes", "[", "j", "]", ",", "\n", "self", ".", "nn_params", ".", "sizes", "[", "i", "]", "]", ")", ")", "\n", "", "current_column", "=", "tf", ".", "concat", "(", "current_col_elems", ",", "0", ")", "\n", "h_columns", ".", "append", "(", "current_column", ")", "\n", "\n", "", "self", ".", "matrix_h", "=", "tf", ".", "concat", "(", "h_columns", ",", "1", ")", "\n", "self", ".", "set_differentiable_objective", "(", ")", "\n", "self", ".", "matrix_h", "=", "(", "self", ".", "matrix_h", "+", "tf", ".", "transpose", "(", "self", ".", "matrix_h", ")", ")", "\n", "\n", "self", ".", "matrix_m", "=", "tf", ".", "concat", "(", "[", "tf", ".", "concat", "(", "[", "self", ".", "nu", ",", "tf", ".", "transpose", "(", "self", ".", "vector_g", ")", "]", ",", "\n", "axis", "=", "1", ")", ",", "\n", "tf", ".", "concat", "(", "[", "self", ".", "vector_g", ",", "self", ".", "matrix_h", "]", ",", "\n", "axis", "=", "1", ")", "]", ",", "axis", "=", "0", ")", "\n", "return", "self", ".", "matrix_h", ",", "self", ".", "matrix_m", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.__init__": [[19, 46], ["tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.placeholder"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dual_formulation_object", ",", "sess", ",", "optimization_params", ")", ":", "\n", "    ", "\"\"\"Initialize the class variables.\n\n    Args:\n      dual_formulation_object: Instance of DualFormulation that contains the\n        dual variables and objective\n      sess: tf session to be used to run\n      optimization_params: Dictionary with the following\n        eig_num_iter - Number of iterations to run for computing minimum eigen\n          value\n        eig_learning_rate - Learning rate for minimum eigen value iterations\n        init_smooth - Starting value of the smoothness parameter (typically\n        around 0.001)\n        smooth_decay - The factor by which to decay after every outer loop epoch\n        optimizer - one of gd, adam, momentum or adagrad\n    \"\"\"", "\n", "self", ".", "dual_object", "=", "dual_formulation_object", "\n", "self", ".", "params", "=", "optimization_params", "\n", "self", ".", "penalty_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "[", "]", ")", "\n", "\n", "# The dimensionality of matrix M is the sum of sizes of all layers + 1", "\n", "# The + 1 comes due to a row and column of M representing the linear terms", "\n", "self", ".", "eig_init_vec_placeholder", "=", "tf", ".", "placeholder", "(", "\n", "tf", ".", "float32", ",", "shape", "=", "[", "1", "+", "self", ".", "dual_object", ".", "dual_index", "[", "-", "1", "]", ",", "1", "]", ")", "\n", "self", ".", "smooth_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "[", "]", ")", "\n", "self", ".", "eig_num_iter_placeholder", "=", "tf", ".", "placeholder", "(", "tf", ".", "int32", ",", "shape", "=", "[", "]", ")", "\n", "self", ".", "sess", "=", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.tf_min_eig_vec": [[47, 55], ["optimization.Optimization.dual_object.get_full_psd_matrix", "tensorflow.self_adjoint_eig", "tensorflow.argmin", "tensorflow.reshape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix"], ["", "def", "tf_min_eig_vec", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function for min eigen vector using tf's full eigen decomposition.\"\"\"", "\n", "# Full eigen decomposition requires the explicit psd matrix M", "\n", "_", ",", "matrix_m", "=", "self", ".", "dual_object", ".", "get_full_psd_matrix", "(", ")", "\n", "[", "eig_vals", ",", "eig_vectors", "]", "=", "tf", ".", "self_adjoint_eig", "(", "matrix_m", ")", "\n", "index", "=", "tf", ".", "argmin", "(", "eig_vals", ")", "\n", "return", "tf", ".", "reshape", "(", "eig_vectors", "[", ":", ",", "index", "]", ",", "\n", "shape", "=", "[", "eig_vectors", ".", "shape", "[", "0", "]", ".", "value", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.tf_smooth_eig_vec": [[56, 70], ["optimization.Optimization.dual_object.get_full_psd_matrix", "tensorflow.self_adjoint_eig", "tensorflow.exp", "tensorflow.reduce_sum", "tensorflow.divide", "tensorflow.reshape", "tensorflow.divide", "tensorflow.matmul", "tensorflow.sqrt", "tensorflow.reduce_sum", "tensorflow.diag", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag"], ["", "def", "tf_smooth_eig_vec", "(", "self", ")", ":", "\n", "    ", "\"\"\"Function that returns smoothed version of min eigen vector.\"\"\"", "\n", "_", ",", "matrix_m", "=", "self", ".", "dual_object", ".", "get_full_psd_matrix", "(", ")", "\n", "# Easier to think in terms of max so negating the matrix", "\n", "[", "eig_vals", ",", "eig_vectors", "]", "=", "tf", ".", "self_adjoint_eig", "(", "-", "matrix_m", ")", "\n", "exp_eig_vals", "=", "tf", ".", "exp", "(", "tf", ".", "divide", "(", "eig_vals", ",", "self", ".", "smooth_placeholder", ")", ")", "\n", "scaling_factor", "=", "tf", ".", "reduce_sum", "(", "exp_eig_vals", ")", "\n", "# Multiplying each eig vector by exponential of corresponding eig value", "\n", "# Scaling factor normalizes the vector to be unit norm", "\n", "eig_vec_smooth", "=", "tf", ".", "divide", "(", "tf", ".", "matmul", "(", "eig_vectors", ",", "\n", "tf", ".", "diag", "(", "tf", ".", "sqrt", "(", "exp_eig_vals", ")", ")", ")", ",", "\n", "tf", ".", "sqrt", "(", "scaling_factor", ")", ")", "\n", "return", "tf", ".", "reshape", "(", "tf", ".", "reduce_sum", "(", "eig_vec_smooth", ",", "axis", "=", "1", ")", ",", "\n", "shape", "=", "[", "eig_vec_smooth", ".", "shape", "[", "0", "]", ".", "value", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy": [[71, 99], ["tensorflow.contrib.autograph.to_graph", "tensorflow.contrib.autograph.to_graph.", "tensorflow.cond", "optimization.Optimization.dual_object.get_psd_product"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_psd_product"], ["", "def", "get_min_eig_vec_proxy", "(", "self", ",", "use_tf_eig", "=", "False", ")", ":", "\n", "    ", "\"\"\"Computes the min eigen value and corresponding vector of matrix M.\n\n    Args:\n      use_tf_eig: Whether to use tf's default full eigen decomposition\n\n    Returns:\n      eig_vec: Minimum absolute eigen value\n      eig_val: Corresponding eigen vector\n    \"\"\"", "\n", "if", "use_tf_eig", ":", "\n", "# If smoothness parameter is too small, essentially no smoothing", "\n", "# Just output the eigen vector corresponding to min", "\n", "      ", "return", "tf", ".", "cond", "(", "self", ".", "smooth_placeholder", "<", "1E-8", ",", "\n", "self", ".", "tf_min_eig_vec", ",", "\n", "self", ".", "tf_smooth_eig_vec", ")", "\n", "\n", "# Using autograph to automatically handle", "\n", "# the control flow of minimum_eigen_vector", "\n", "", "min_eigen_tf", "=", "autograph", ".", "to_graph", "(", "utils", ".", "minimum_eigen_vector", ")", "\n", "def", "_vector_prod_fn", "(", "x", ")", ":", "\n", "      ", "return", "self", ".", "dual_object", ".", "get_psd_product", "(", "x", ")", "\n", "", "estimated_eigen_vector", "=", "min_eigen_tf", "(", "\n", "x", "=", "self", ".", "eig_init_vec_placeholder", ",", "\n", "num_steps", "=", "self", ".", "eig_num_iter_placeholder", ",", "\n", "learning_rate", "=", "self", ".", "params", "[", "'eig_learning_rate'", "]", ",", "\n", "vector_prod_fn", "=", "_vector_prod_fn", ")", "\n", "return", "estimated_eigen_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.prepare_one_step": [[100, 157], ["optimization.Optimization.dual_object.set_differentiable_objective", "optimization.Optimization.get_min_eig_vec_proxy", "tensorflow.stop_gradient", "tensorflow.matmul", "tensorflow.Variable", "tensorflow.train.exponential_decay", "optimization.Optimization.optimizer.minimize", "optimization.Optimization.sess.run", "tensorflow.transpose", "optimization.Optimization.dual_object.get_psd_product", "tensorflow.train.AdamOptimizer", "tensorflow.control_dependencies", "tensorflow.group", "tensorflow.global_variables_initializer", "tensorflow.gfile.MkDir", "tensorflow.square", "tensorflow.train.AdagradOptimizer", "tensorflow.gfile.IsDirectory", "tensorflow.maximum", "tensorflow.train.MomentumOptimizer", "tensorflow.train.GradientDescentOptimizer", "v.assign", "tensorflow.maximum", "tensorflow.trainable_variables"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.attacks_tf.TensorOptimizer.minimize", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_psd_product"], ["", "def", "prepare_one_step", "(", "self", ")", ":", "\n", "    ", "\"\"\"Create tensorflow op for running one step of descent.\"\"\"", "\n", "# Create the objective", "\n", "\n", "self", ".", "dual_object", ".", "set_differentiable_objective", "(", ")", "\n", "self", ".", "eig_vec_estimate", "=", "self", ".", "get_min_eig_vec_proxy", "(", ")", "\n", "self", ".", "stopped_eig_vec_estimate", "=", "tf", ".", "stop_gradient", "(", "self", ".", "eig_vec_estimate", ")", "\n", "# Eig value is v^\\top M v, where v is eigen vector", "\n", "self", ".", "eig_val_estimate", "=", "tf", ".", "matmul", "(", "tf", ".", "transpose", "(", "\n", "self", ".", "stopped_eig_vec_estimate", ")", ",", "\n", "self", ".", "dual_object", ".", "get_psd_product", "(", "\n", "self", ".", "stopped_eig_vec_estimate", ")", ")", "\n", "# Penalizing negative of min eigen value because we want min eig value", "\n", "# to be positive", "\n", "self", ".", "total_objective", "=", "(", "self", ".", "dual_object", ".", "unconstrained_objective", "+", "\n", "0.5", "*", "(", "tf", ".", "square", "(", "\n", "tf", ".", "maximum", "(", "-", "1", "*", "self", ".", "penalty_placeholder", "*", "\n", "self", ".", "eig_val_estimate", ",", "0", ")", ")", ")", ")", "\n", "global_step", "=", "tf", ".", "Variable", "(", "0", ",", "trainable", "=", "False", ")", "\n", "# Set up learning rate", "\n", "# Learning rate decays after every outer loop", "\n", "learning_rate", "=", "tf", ".", "train", ".", "exponential_decay", "(", "\n", "self", ".", "params", "[", "'init_learning_rate'", "]", ",", "\n", "global_step", ",", "self", ".", "params", "[", "'inner_num_steps'", "]", ",", "\n", "self", ".", "params", "[", "'learning_rate_decay'", "]", ",", "staircase", "=", "True", ")", "\n", "\n", "# Set up the optimizer", "\n", "if", "self", ".", "params", "[", "'optimizer'", "]", "==", "'adam'", ":", "\n", "      ", "self", ".", "optimizer", "=", "tf", ".", "train", ".", "AdamOptimizer", "(", "\n", "learning_rate", "=", "learning_rate", ")", "\n", "", "elif", "self", ".", "params", "[", "'optimizer'", "]", "==", "'adagrad'", ":", "\n", "      ", "self", ".", "optimizer", "=", "tf", ".", "train", ".", "AdagradOptimizer", "(", "learning_rate", "=", "learning_rate", ")", "\n", "", "elif", "self", ".", "params", "[", "'optimizer'", "]", "==", "'momentum'", ":", "\n", "      ", "self", ".", "optimizer", "=", "tf", ".", "train", ".", "MomentumOptimizer", "(", "\n", "learning_rate", "=", "learning_rate", ",", "\n", "momentum", "=", "self", ".", "params", "[", "'momentum_parameter'", "]", ",", "use_nesterov", "=", "True", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "optimizer", "=", "tf", ".", "train", ".", "GradientDescentOptimizer", "(", "\n", "learning_rate", "=", "learning_rate", ")", "\n", "\n", "# Write out the projection step", "\n", "", "self", ".", "train_step", "=", "self", ".", "optimizer", ".", "minimize", "(", "self", ".", "total_objective", ",", "\n", "global_step", "=", "global_step", ")", "\n", "# All dual variables are positive", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "self", ".", "train_step", "]", ")", ":", "\n", "      ", "self", ".", "proj_step", "=", "tf", ".", "group", "(", "[", "v", ".", "assign", "(", "tf", ".", "maximum", "(", "v", ",", "0", ")", ")", "\n", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "]", ")", "\n", "\n", "# Control dependencies ensures that train_step is executed first", "\n", "", "self", ".", "opt_one_step", "=", "self", ".", "proj_step", "\n", "# Run the initialization of all variables", "\n", "# TODO: do we need to do it here or can do outside of this class?", "\n", "self", ".", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "# Create folder for saving stats if the folder is not None", "\n", "if", "(", "self", ".", "params", "[", "'stats_folder'", "]", "is", "not", "None", "and", "\n", "not", "tf", ".", "gfile", ".", "IsDirectory", "(", "self", ".", "params", "[", "'stats_folder'", "]", ")", ")", ":", "\n", "      ", "tf", ".", "gfile", ".", "MkDir", "(", "self", ".", "params", "[", "'stats_folder'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_one_step": [[158, 211], ["optimization.Optimization.sess.run", "optimization.Optimization.dual_object.project_dual", "optimization.Optimization.sess.run", "tensorflow.logging.info", "tensorflow.logging.debug", "tensorflow.logging.info", "float", "float", "float", "json.dumps", "tensorflow.gfile.Open", "file_f.write", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.project_dual"], ["", "", "def", "run_one_step", "(", "self", ",", "eig_init_vec_val", ",", "eig_num_iter_val", ",", "\n", "smooth_val", ",", "penalty_val", ")", ":", "\n", "    ", "\"\"\"Run one step of gradient descent for optimization.\n\n    Args:\n      eig_init_vec_val: Start value for eigen value computations\n      eig_num_iter_val: Number of iterations to run for eigen computations\n      smooth_val: Value of smoothness parameter\n      penalty_val: Value of penalty for the current step\n\n    Returns:\n     found_cert: True is negative certificate is found, False otherwise\n    \"\"\"", "\n", "# Project onto feasible set of dual variables", "\n", "if", "self", ".", "current_step", "%", "self", ".", "params", "[", "'projection_steps'", "]", "==", "0", ":", "\n", "\n", "      ", "projected_certificate", "=", "self", ".", "dual_object", ".", "project_dual", "(", ")", "\n", "current_certificate", "=", "self", ".", "sess", ".", "run", "(", "projected_certificate", ")", "\n", "tf", ".", "logging", ".", "info", "(", "'Inner step: %d, current value of certificate: %f'", ",", "\n", "self", ".", "current_step", ",", "current_certificate", ")", "\n", "\n", "# Sometimes due to either overflow or instability in inverses,", "\n", "# the returned certificate is large and negative -- keeping a check", "\n", "if", "LOWER_CERT_BOUND", "<", "current_certificate", "<", "0", ":", "\n", "        ", "tf", ".", "logging", ".", "info", "(", "'Found certificate of robustness!'", ")", "\n", "return", "True", "\n", "# Running step", "\n", "", "", "step_feed_dict", "=", "{", "self", ".", "eig_init_vec_placeholder", ":", "eig_init_vec_val", ",", "\n", "self", ".", "eig_num_iter_placeholder", ":", "eig_num_iter_val", ",", "\n", "self", ".", "smooth_placeholder", ":", "smooth_val", ",", "\n", "self", ".", "penalty_placeholder", ":", "penalty_val", "}", "\n", "\n", "[", "_", ",", "self", ".", "current_total_objective", ",", "self", ".", "current_unconstrained_objective", ",", "\n", "self", ".", "current_eig_vec_val", ",", "\n", "self", ".", "current_eig_val_estimate", "]", "=", "self", ".", "sess", ".", "run", "(", "\n", "[", "self", ".", "opt_one_step", ",", "self", ".", "total_objective", ",", "\n", "self", ".", "dual_object", ".", "unconstrained_objective", ",", "\n", "self", ".", "eig_vec_estimate", ",", "\n", "self", ".", "eig_val_estimate", "]", ",", "feed_dict", "=", "step_feed_dict", ")", "\n", "\n", "if", "self", ".", "current_step", "%", "self", ".", "params", "[", "'print_stats_steps'", "]", "==", "0", ":", "\n", "      ", "stats", "=", "{", "'total_objective'", ":", "float", "(", "self", ".", "current_total_objective", ")", ",", "\n", "'unconstrained_objective'", ":", "\n", "float", "(", "self", ".", "current_unconstrained_objective", ")", ",", "\n", "'min_eig_val_estimate'", ":", "float", "(", "self", ".", "current_eig_val_estimate", ")", "}", "\n", "tf", ".", "logging", ".", "debug", "(", "'Current inner step: %d, optimization stats: %s'", ",", "\n", "self", ".", "current_step", ",", "stats", ")", "\n", "if", "self", ".", "params", "[", "'stats_folder'", "]", "is", "not", "None", ":", "\n", "        ", "stats", "=", "json", ".", "dumps", "(", "stats", ")", "\n", "with", "tf", ".", "gfile", ".", "Open", "(", "(", "self", ".", "params", "[", "'stats_folder'", "]", "+", "'/'", "+", "\n", "str", "(", "self", ".", "current_step", ")", "+", "'.json'", ")", ")", "as", "file_f", ":", "\n", "          ", "file_f", ".", "write", "(", "stats", ")", "\n", "", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_optimization": [[212, 262], ["optimization.Optimization.prepare_one_step", "tensorflow.logging.info", "optimization.Optimization.run_one_step", "numpy.random.random", "optimization.Optimization.run_one_step", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.prepare_one_step", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_one_step", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_one_step"], ["", "def", "run_optimization", "(", "self", ")", ":", "\n", "    ", "\"\"\"Run the optimization, call run_one_step with suitable placeholders.\n\n    Returns:\n      True if certificate is found\n      False otherwise\n    \"\"\"", "\n", "self", ".", "prepare_one_step", "(", ")", "\n", "penalty_val", "=", "self", ".", "params", "[", "'init_penalty'", "]", "\n", "# Don't use smoothing initially - very inaccurate for large dimension", "\n", "self", ".", "smooth_on", "=", "False", "\n", "smooth_val", "=", "0", "\n", "current_outer_step", "=", "1", "\n", "while", "current_outer_step", "<=", "self", ".", "params", "[", "'outer_num_steps'", "]", ":", "\n", "      ", "tf", ".", "logging", ".", "info", "(", "'Running outer step %d with penalty %f'", ",", "\n", "current_outer_step", ",", "penalty_val", ")", "\n", "# Running inner loop of optimization with current_smooth_val,", "\n", "# current_penalty as smoothness parameters and penalty respectively", "\n", "self", ".", "current_step", "=", "0", "\n", "# Run first step with random eig initialization and large number of steps", "\n", "found_cert", "=", "self", ".", "run_one_step", "(", "\n", "np", ".", "random", ".", "random", "(", "\n", "size", "=", "(", "1", "+", "self", ".", "dual_object", ".", "dual_index", "[", "-", "1", "]", ",", "1", ")", ")", ",", "\n", "self", ".", "params", "[", "'large_eig_num_steps'", "]", ",", "\n", "smooth_val", ",", "\n", "penalty_val", ")", "\n", "if", "found_cert", ":", "\n", "        ", "return", "True", "\n", "", "while", "self", ".", "current_step", "<", "self", ".", "params", "[", "'inner_num_steps'", "]", ":", "\n", "        ", "self", ".", "current_step", "=", "self", ".", "current_step", "+", "1", "\n", "found_cert", "=", "self", ".", "run_one_step", "(", "self", ".", "current_eig_vec_val", ",", "\n", "self", ".", "params", "[", "'small_eig_num_steps'", "]", ",", "\n", "smooth_val", ",", "\n", "penalty_val", ")", "\n", "if", "found_cert", ":", "\n", "          ", "return", "-", "1", "\n", "# Update penalty only if it looks like current objective is optimizes", "\n", "", "", "if", "self", ".", "current_total_objective", "<", "-", "0.2", ":", "\n", "        ", "penalty_val", "=", "penalty_val", "*", "self", ".", "params", "[", "'beta'", "]", "\n", "", "else", ":", "\n", "# To get more accurate gradient estimate", "\n", "        ", "self", ".", "params", "[", "'small_eig_num_steps'", "]", "=", "(", "\n", "1.5", "*", "self", ".", "params", "[", "'small_eig_num_steps'", "]", ")", "\n", "\n", "# If eigen values seem small enough, turn on smoothing", "\n", "# useful only when performing full eigen decomposition", "\n", "", "if", "np", ".", "abs", "(", "self", ".", "current_eig_val_estimate", ")", "<", "0.01", ":", "\n", "        ", "smooth_val", "=", "self", ".", "params", "[", "'smoothness_parameter'", "]", "\n", "", "current_outer_step", "=", "current_outer_step", "+", "1", "\n", "", "return", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.certify.main": [[77, 140], ["tensorflow.logging.set_verbosity", "cleverhans.experimental.certification.read_weights.read_weights", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "tensorflow.logging.info", "cleverhans.experimental.certification.utils.initialize_dual", "numpy.reshape", "range", "print", "tensorflow.gfile.Open", "numpy.load", "tensorflow.logging.info", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "dual_formulation.DualFormulation.set_differentiable_objective", "dual_formulation.DualFormulation.get_full_psd_matrix", "numpy.size", "tensorflow.Session", "sess.run", "cleverhans.experimental.certification.optimization.Optimization", "optimization.Optimization.prepare_one_step", "optimization.Optimization.run_optimization", "tensorflow.global_variables_initializer", "print", "exit"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.read_weights.read_weights", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.initialize_dual", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.prepare_one_step", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_optimization"], ["def", "main", "(", "_", ")", ":", "\n", "  ", "tf", ".", "logging", ".", "set_verbosity", "(", "FLAGS", ".", "verbosity", ")", "\n", "\n", "net_weights", ",", "net_biases", ",", "net_layer_types", "=", "read_weights", ".", "read_weights", "(", "\n", "FLAGS", ".", "checkpoint", ",", "FLAGS", ".", "model_json", ")", "\n", "nn_params", "=", "neural_net_params", ".", "NeuralNetParams", "(", "\n", "net_weights", ",", "net_biases", ",", "net_layer_types", ")", "\n", "tf", ".", "logging", ".", "info", "(", "'Loaded neural network with size of layers: %s'", ",", "\n", "nn_params", ".", "sizes", ")", "\n", "dual_var", "=", "utils", ".", "initialize_dual", "(", "nn_params", ",", "FLAGS", ".", "init_dual_file", ",", "\n", "init_nu", "=", "FLAGS", ".", "init_nu", ")", "\n", "# Reading test input and reshaping", "\n", "with", "tf", ".", "gfile", ".", "Open", "(", "FLAGS", ".", "test_input", ")", "as", "f", ":", "\n", "    ", "test_input", "=", "np", ".", "load", "(", "f", ")", "\n", "", "test_input", "=", "np", ".", "reshape", "(", "test_input", ",", "[", "np", ".", "size", "(", "test_input", ")", ",", "1", "]", ")", "\n", "\n", "if", "FLAGS", ".", "adv_class", "==", "-", "1", ":", "\n", "    ", "start_class", "=", "0", "\n", "end_class", "=", "FLAGS", ".", "num_classes", "\n", "", "else", ":", "\n", "    ", "start_class", "=", "FLAGS", ".", "adv_class", "\n", "end_class", "=", "FLAGS", ".", "adv_class", "+", "1", "\n", "", "for", "adv_class", "in", "range", "(", "start_class", ",", "end_class", ")", ":", "\n", "    ", "tf", ".", "logging", ".", "info", "(", "'Running certification for adversarial class %d'", ",", "adv_class", ")", "\n", "if", "adv_class", "==", "FLAGS", ".", "true_class", ":", "\n", "      ", "continue", "\n", "", "dual", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params", ",", "\n", "test_input", ",", "\n", "FLAGS", ".", "true_class", ",", "\n", "adv_class", ",", "\n", "FLAGS", ".", "input_minval", ",", "\n", "FLAGS", ".", "input_maxval", ",", "\n", "FLAGS", ".", "epsilon", ")", "\n", "dual", ".", "set_differentiable_objective", "(", ")", "\n", "dual", ".", "get_full_psd_matrix", "(", ")", "\n", "optimization_params", "=", "{", "\n", "'init_penalty'", ":", "FLAGS", ".", "init_penalty", ",", "\n", "'large_eig_num_steps'", ":", "FLAGS", ".", "large_eig_num_steps", ",", "\n", "'small_eig_num_steps'", ":", "FLAGS", ".", "small_eig_num_steps", ",", "\n", "'inner_num_steps'", ":", "FLAGS", ".", "inner_num_steps", ",", "\n", "'outer_num_steps'", ":", "FLAGS", ".", "outer_num_steps", ",", "\n", "'beta'", ":", "FLAGS", ".", "beta", ",", "\n", "'smoothness_parameter'", ":", "FLAGS", ".", "smoothness_parameter", ",", "\n", "'eig_learning_rate'", ":", "FLAGS", ".", "eig_learning_rate", ",", "\n", "'optimizer'", ":", "FLAGS", ".", "optimizer", ",", "\n", "'init_learning_rate'", ":", "FLAGS", ".", "init_learning_rate", ",", "\n", "'learning_rate_decay'", ":", "FLAGS", ".", "learning_rate_decay", ",", "\n", "'momentum_parameter'", ":", "FLAGS", ".", "momentum_parameter", ",", "\n", "'print_stats_steps'", ":", "FLAGS", ".", "print_stats_steps", ",", "\n", "'stats_folder'", ":", "FLAGS", ".", "stats_folder", ",", "\n", "'projection_steps'", ":", "FLAGS", ".", "projection_steps", "}", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "      ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "optimization_object", "=", "optimization", ".", "Optimization", "(", "dual", ",", "\n", "sess", ",", "\n", "optimization_params", ")", "\n", "optimization_object", ".", "prepare_one_step", "(", ")", "\n", "is_cert_found", "=", "optimization_object", ".", "run_optimization", "(", ")", "\n", "if", "not", "is_cert_found", ":", "\n", "        ", "print", "(", "'Example could not be verified'", ")", "\n", "exit", "(", ")", "\n", "", "", "", "print", "(", "'Example successfully verified'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.__init__": [[14, 57], ["range", "neural_net_params.NeuralNetParams.sizes.append", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "ValueError", "ValueError", "len", "numpy.shape", "neural_net_params.NeuralNetParams.sizes.append", "neural_net_params.NeuralNetParams.weights.append", "neural_net_params.NeuralNetParams.biases.append", "neural_net_params.NeuralNetParams.layer_types.append", "int", "len", "len", "len", "len", "int", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "numpy.shape", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "net_weights", ",", "net_biases", ",", "net_layer_types", ")", ":", "\n", "    ", "\"\"\"Function to initialize NeuralNetParams class.\n\n    Args:\n       net_weights: list of numpy matrices of weights of each layer\n       [convention: x[i+1] = W[i] x[i]\n       net_biases: list of numpy arrays of biases of each layer\n       net_layer_types: type of each layer ['ff' or 'ff_relu' or 'ff_conv'\n         or 'ff_conv_relu']\n         'ff': Simple feedforward layer with no activations\n         'ff_relu': Simple feedforward layer with ReLU activations\n         'ff_conv': Convolution layer with no activation\n         'ff_conv_relu': Convolution layer with ReLU activation\n\n    Raises:\n      ValueError: the input lists of net params are not of the same length\n    \"\"\"", "\n", "if", "(", "(", "len", "(", "net_weights", ")", "!=", "len", "(", "net_biases", ")", ")", "\n", "or", "len", "(", "net_biases", ")", "!=", "len", "(", "net_layer_types", ")", ")", ":", "\n", "      ", "raise", "ValueError", "(", "'Inputs of net params are not of same length ....'", ")", "\n", "", "if", "net_layer_types", "[", "len", "(", "net_layer_types", ")", "-", "1", "]", "!=", "'ff'", ":", "\n", "      ", "raise", "ValueError", "(", "'Final layer is not linear'", ")", "\n", "", "self", ".", "num_hidden_layers", "=", "len", "(", "net_weights", ")", "-", "1", "\n", "self", ".", "weights", "=", "[", "]", "\n", "self", ".", "biases", "=", "[", "]", "\n", "self", ".", "layer_types", "=", "[", "]", "\n", "self", ".", "sizes", "=", "[", "]", "\n", "# Setting the sizes of the layers of the network", "\n", "# sizes[i] contains the size of x_i", "\n", "for", "i", "in", "range", "(", "self", ".", "num_hidden_layers", ")", ":", "\n", "      ", "shape", "=", "np", ".", "shape", "(", "net_weights", "[", "i", "]", ")", "\n", "self", ".", "sizes", ".", "append", "(", "int", "(", "shape", "[", "1", "]", ")", ")", "\n", "self", ".", "weights", ".", "append", "(", "\n", "tf", ".", "convert_to_tensor", "(", "net_weights", "[", "i", "]", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "self", ".", "biases", ".", "append", "(", "tf", ".", "convert_to_tensor", "(", "net_biases", "[", "i", "]", ",", "dtype", "=", "tf", ".", "float32", ")", ")", "\n", "self", ".", "layer_types", ".", "append", "(", "net_layer_types", "[", "i", "]", ")", "\n", "\n", "# Last layer shape", "\n", "", "self", ".", "sizes", ".", "append", "(", "int", "(", "np", ".", "shape", "(", "net_weights", "[", "self", ".", "num_hidden_layers", "-", "1", "]", ")", "[", "0", "]", ")", ")", "\n", "self", ".", "final_weights", "=", "tf", ".", "convert_to_tensor", "(", "\n", "net_weights", "[", "self", ".", "num_hidden_layers", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "self", ".", "final_bias", "=", "tf", ".", "convert_to_tensor", "(", "\n", "net_biases", "[", "self", ".", "num_hidden_layers", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass": [[58, 87], ["NotImplementedError", "ValueError", "tensorflow.matmul", "tensorflow.transpose", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.abs"], "methods", ["None"], ["", "def", "forward_pass", "(", "self", ",", "vector", ",", "layer_index", ",", "is_transpose", "=", "False", ",", "is_abs", "=", "False", ")", ":", "\n", "    ", "\"\"\"Performs forward pass through the layer weights at layer_index.\n\n    Args:\n      vector: vector that has to be passed through in forward pass\n      layer_index: index of the layer\n      is_transpose: whether the weights of the layer have to be transposed\n      is_abs: whether to take the absolute value of the weights\n\n    Returns:\n      tensor that corresponds to the forward pass through the layer\n\n    Raises:\n      ValueError: if the layer_index is negative or more than num hidden layers\n    \"\"\"", "\n", "if", "(", "layer_index", "<", "0", "or", "layer_index", ">", "self", ".", "num_hidden_layers", ")", ":", "\n", "      ", "raise", "ValueError", "(", "'Invalid layer index'", ")", "\n", "\n", "", "if", "(", "self", ".", "layer_types", "[", "layer_index", "]", "==", "'ff'", "or", "\n", "self", ".", "layer_types", "[", "layer_index", "]", "==", "'ff_relu'", ")", ":", "\n", "      ", "if", "is_transpose", ":", "\n", "        ", "return", "tf", ".", "matmul", "(", "tf", ".", "transpose", "(", "self", ".", "weights", "[", "layer_index", "]", ")", ",", "vector", ")", "\n", "", "elif", "is_abs", ":", "\n", "        ", "return", "tf", ".", "matmul", "(", "tf", ".", "abs", "(", "self", ".", "weights", "[", "layer_index", "]", ")", ",", "vector", ")", "\n", "", "else", ":", "\n", "        ", "return", "tf", ".", "matmul", "(", "self", ".", "weights", "[", "layer_index", "]", ",", "vector", ")", "\n", "\n", "", "", "raise", "NotImplementedError", "(", "'Unsupported layer type: {0}'", ".", "format", "(", "\n", "self", ".", "layer_types", "[", "layer_index", "]", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.read_weights.read_weights": [[13, 69], ["tensorflow.train.load_checkpoint", "tf.train.load_checkpoint.get_variable_to_shape_map", "reader.get_variable_to_shape_map.keys", "tensorflow.gfile.Open", "json.load", "net_layer_types.append", "tf.train.load_checkpoint.get_tensor", "tf.train.load_checkpoint.get_tensor", "net_weights.append", "net_biases.append", "ValueError", "ValueError", "numpy.transpose", "numpy.reshape", "numpy.size"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["def", "read_weights", "(", "checkpoint", ",", "model_json", ")", ":", "\n", "  ", "\"\"\"Function to read the weights from checkpoint based on json description.\n\n  Args:\n    checkpoint: tensorflow checkpoint with trained model to verify\n    model_json: path of json file with model description of the network list\n      of dictionary items for each layer containing 'type', 'weight_var',\n      'bias_var' and 'is_transpose' 'type'is one of {'ff', 'ff_relu' or\n      'conv'}; 'weight_var' is the name of tf variable for weights of layer i;\n      'bias_var' is the name of tf variable for bias of layer i;\n      'is_transpose' is set to True if the weights have to be transposed as\n      per convention\n      Note that last layer is always feedforward (verification operates at the\n      layer below the final softmax for more numerical stability)\n\n  Returns:\n    net_weights:\n    net_biases:\n    net_layer_types: all are lists containing numpy\n    version of weights\n\n  Raises:\n    ValueError: If layer_types are invalid or variable names not found in\n    checkpoint\n  \"\"\"", "\n", "# Load checkpoint", "\n", "reader", "=", "tf", ".", "train", ".", "load_checkpoint", "(", "checkpoint", ")", "\n", "variable_map", "=", "reader", ".", "get_variable_to_shape_map", "(", ")", "\n", "checkpoint_variable_names", "=", "variable_map", ".", "keys", "(", ")", "\n", "# Parse JSON file for names", "\n", "with", "tf", ".", "gfile", ".", "Open", "(", "model_json", ")", "as", "f", ":", "\n", "    ", "list_model_var", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "net_layer_types", "=", "[", "]", "\n", "net_weights", "=", "[", "]", "\n", "net_biases", "=", "[", "]", "\n", "\n", "# Checking validity of the input and adding to list", "\n", "for", "layer_model_var", "in", "list_model_var", ":", "\n", "    ", "if", "layer_model_var", "[", "'type'", "]", "not", "in", "{", "'ff'", ",", "'ff_relu'", ",", "'conv'", "}", ":", "\n", "      ", "raise", "ValueError", "(", "'Invalid layer type in description'", ")", "\n", "", "if", "(", "layer_model_var", "[", "'weight_var'", "]", "not", "in", "checkpoint_variable_names", "or", "\n", "layer_model_var", "[", "'bias_var'", "]", "not", "in", "checkpoint_variable_names", ")", ":", "\n", "      ", "raise", "ValueError", "(", "'Variable names not found in checkpoint'", ")", "\n", "", "net_layer_types", ".", "append", "(", "layer_model_var", "[", "'type'", "]", ")", "\n", "layer_weight", "=", "reader", ".", "get_tensor", "(", "layer_model_var", "[", "'weight_var'", "]", ")", "\n", "layer_bias", "=", "reader", ".", "get_tensor", "(", "layer_model_var", "[", "'bias_var'", "]", ")", "\n", "# TODO(aditirag): is there a way to automatically check when to transpose", "\n", "# We want weights W such that x^{i+1} = W^i x^i + b^i", "\n", "# Can think of a hack involving matching shapes but if shapes are equal", "\n", "# it can be ambiguous", "\n", "if", "layer_model_var", "[", "'is_transpose'", "]", ":", "\n", "      ", "layer_weight", "=", "np", ".", "transpose", "(", "layer_weight", ")", "\n", "", "net_weights", ".", "append", "(", "layer_weight", ")", "\n", "net_biases", ".", "append", "(", "np", ".", "reshape", "(", "layer_bias", ",", "(", "np", ".", "size", "(", "layer_bias", ")", ",", "1", ")", ")", ")", "\n", "", "return", "net_weights", ",", "net_biases", ",", "net_layer_types", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag": [[11, 21], ["tensorflow.diag", "tensorflow.reshape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.diag"], ["import", "subprocess", "\n", "\n", "import", "numpy", "as", "np", "\n", "from", "six", ".", "moves", "import", "xrange", "\n", "\n", "known_number_types", "=", "(", "int", ",", "float", ",", "np", ".", "float16", ",", "np", ".", "float32", ",", "np", ".", "float64", ",", "\n", "np", ".", "int8", ",", "np", ".", "int16", ",", "np", ".", "int32", ",", "np", ".", "int32", ",", "np", ".", "int64", ",", "\n", "np", ".", "uint8", ",", "np", ".", "uint16", ",", "np", ".", "uint32", ",", "np", ".", "uint64", ")", "\n", "\n", "\n", "CLEVERHANS_ROOT", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.initialize_dual": [[23, 97], ["range", "tensorflow.get_variable", "tensorflow.reshape", "numpy.load().item", "range", "tensorflow.get_variable", "tensorflow.reshape", "numpy.random.uniform().astype", "lambda_pos.append", "numpy.random.uniform().astype", "lambda_neg.append", "numpy.random.uniform().astype", "lambda_quad.append", "numpy.random.uniform().astype", "lambda_lu.append", "lambda_pos.append", "lambda_neg.append", "lambda_quad.append", "lambda_lu.append", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "numpy.load", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load"], ["\n", "class", "_ArgsWrapper", "(", "object", ")", ":", "\n", "\n", "  ", "\"\"\"\n  Wrapper that allows attribute access to dictionaries\n  \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "args", ",", "dict", ")", ":", "\n", "      ", "args", "=", "vars", "(", "args", ")", "\n", "", "self", ".", "args", "=", "args", "\n", "\n", "", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "    ", "return", "self", ".", "args", ".", "get", "(", "name", ")", "\n", "\n", "\n", "", "", "class", "AccuracyReport", "(", "object", ")", ":", "\n", "\n", "  ", "\"\"\"\n  An object summarizing the accuracy results for experiments involving\n  training on clean examples or adversarial examples, then evaluating\n  on clean or adversarial examples.\n  \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "clean_train_clean_eval", "=", "0.", "\n", "self", ".", "clean_train_adv_eval", "=", "0.", "\n", "self", ".", "adv_train_clean_eval", "=", "0.", "\n", "self", ".", "adv_train_adv_eval", "=", "0.", "\n", "\n", "# Training data accuracy results to be used by tutorials", "\n", "self", ".", "train_clean_train_clean_eval", "=", "0.", "\n", "self", ".", "train_clean_train_adv_eval", "=", "0.", "\n", "self", ".", "train_adv_train_clean_eval", "=", "0.", "\n", "self", ".", "train_adv_train_adv_eval", "=", "0.", "\n", "\n", "\n", "", "", "def", "batch_indices", "(", "batch_nb", ",", "data_length", ",", "batch_size", ")", ":", "\n", "  ", "\"\"\"\n  This helper function computes a batch start and end index\n  :param batch_nb: the batch number\n  :param data_length: the total length of the data being parsed by batches\n  :param batch_size: the number of inputs in each batch\n  :return: pair of (start, end) indices\n  \"\"\"", "\n", "# Batch start and end index", "\n", "start", "=", "int", "(", "batch_nb", "*", "batch_size", ")", "\n", "end", "=", "int", "(", "(", "batch_nb", "+", "1", ")", "*", "batch_size", ")", "\n", "\n", "# When there are not enough inputs left, we reuse some to complete the", "\n", "# batch", "\n", "if", "end", ">", "data_length", ":", "\n", "    ", "shift", "=", "end", "-", "data_length", "\n", "start", "-=", "shift", "\n", "end", "-=", "shift", "\n", "\n", "", "return", "start", ",", "end", "\n", "\n", "\n", "", "def", "other_classes", "(", "nb_classes", ",", "class_ind", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of class indices excluding the class indexed by class_ind\n  :param nb_classes: number of classes in the task\n  :param class_ind: the class index to be omitted\n  :return: list of class indices excluding the class indexed by class_ind\n  \"\"\"", "\n", "if", "class_ind", "<", "0", "or", "class_ind", ">=", "nb_classes", ":", "\n", "    ", "error_str", "=", "\"class_ind must be within the range (0, nb_classes - 1)\"", "\n", "raise", "ValueError", "(", "error_str", ")", "\n", "\n", "", "other_classes_list", "=", "list", "(", "range", "(", "nb_classes", ")", ")", "\n", "other_classes_list", ".", "remove", "(", "class_ind", ")", "\n", "\n", "return", "other_classes_list", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.eig_one_step": [[99, 164], ["tensorflow.reshape", "tensorflow.norm", "tensorflow.square", "tensorflow.reshape", "tensorflow.nn.l2_normalize", "vector_prod_fn", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.transpose", "tensorflow.transpose", "tensorflow.transpose", "vector_prod_fn", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_sum"], ["", "def", "to_categorical", "(", "y", ",", "nb_classes", ",", "num_classes", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Converts a class vector (integers) to binary class matrix.\n  This is adapted from the Keras function with the same name.\n  :param y: class vector to be converted into a matrix\n            (integers from 0 to nb_classes).\n  :param nb_classes: nb_classes: total number of classes.\n  :param num_classses: depricated version of nb_classes\n  :return: A binary matrix representation of the input.\n  \"\"\"", "\n", "if", "num_classes", "is", "not", "None", ":", "\n", "    ", "if", "nb_classes", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\"Should not specify both nb_classes and its deprecated \"", "\n", "\"alias, num_classes\"", ")", "\n", "", "warnings", ".", "warn", "(", "\"`num_classes` is deprecated. Switch to `nb_classes`.\"", "\n", "\" `num_classes` may be removed on or after 2019-04-23.\"", ")", "\n", "nb_classes", "=", "num_classes", "\n", "del", "num_classes", "\n", "", "y", "=", "np", ".", "array", "(", "y", ",", "dtype", "=", "'int'", ")", ".", "ravel", "(", ")", "\n", "n", "=", "y", ".", "shape", "[", "0", "]", "\n", "categorical", "=", "np", ".", "zeros", "(", "(", "n", ",", "nb_classes", ")", ")", "\n", "categorical", "[", "np", ".", "arange", "(", "n", ")", ",", "y", "]", "=", "1", "\n", "return", "categorical", "\n", "\n", "\n", "", "def", "random_targets", "(", "gt", ",", "nb_classes", ")", ":", "\n", "  ", "\"\"\"\n  Take in an array of correct labels and randomly select a different label\n  for each label in the array. This is typically used to randomly select a\n  target class in targeted adversarial examples attacks (i.e., when the\n  search algorithm takes in both a source class and target class to compute\n  the adversarial example).\n  :param gt: the ground truth (correct) labels. They can be provided as a\n             1D vector or 2D array of one-hot encoded labels.\n  :param nb_classes: The number of classes for this task. The random class\n                     will be chosen between 0 and nb_classes such that it\n                     is different from the correct class.\n  :return: A numpy array holding the randomly-selected target classes\n           encoded as one-hot labels.\n  \"\"\"", "\n", "# If the ground truth labels are encoded as one-hot, convert to labels.", "\n", "if", "len", "(", "gt", ".", "shape", ")", "==", "2", ":", "\n", "    ", "gt", "=", "np", ".", "argmax", "(", "gt", ",", "axis", "=", "1", ")", "\n", "\n", "# This vector will hold the randomly selected labels.", "\n", "", "result", "=", "np", ".", "zeros", "(", "gt", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "for", "class_ind", "in", "xrange", "(", "nb_classes", ")", ":", "\n", "# Compute all indices in that class.", "\n", "    ", "in_cl", "=", "gt", "==", "class_ind", "\n", "size", "=", "np", ".", "sum", "(", "in_cl", ")", "\n", "\n", "# Compute the set of potential targets for this class.", "\n", "potential_targets", "=", "other_classes", "(", "nb_classes", ",", "class_ind", ")", "\n", "\n", "# Draw with replacement random targets among the potential targets.", "\n", "result", "[", "in_cl", "]", "=", "np", ".", "random", ".", "choice", "(", "potential_targets", ",", "size", "=", "size", ")", "\n", "\n", "# Encode vector of random labels as one-hot labels.", "\n", "", "result", "=", "to_categorical", "(", "result", ",", "nb_classes", ")", "\n", "result", "=", "result", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "return", "result", "\n", "\n", "\n", "", "def", "pair_visual", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.minimum_eigen_vector": [[166, 186], ["tensorflow.nn.l2_normalize", "range", "utils.eig_one_step"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.utils.eig_one_step"], ["\"cleverhans.utils.pair_visual may be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "pair_visual", "as", "new_pair_visual", "\n", "return", "new_pair_visual", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "", "def", "grid_visual", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`grid_visual` has moved to `cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.grid_visual may be removed on or after \"", "\n", "\"2019-04-24.\"", ")", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "grid_visual", "as", "new_grid_visual", "\n", "return", "new_grid_visual", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "\n", "", "def", "get_logits_over_interval", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "  ", "warnings", ".", "warn", "(", "\"`get_logits_over_interval` has moved to \"", "\n", "\"`cleverhans.plot.pyplot_image`. \"", "\n", "\"cleverhans.utils.get_logits_over_interval may be removed on \"", "\n", "\"or after 2019-04-24.\"", ")", "\n", "# pylint:disable=line-too-long", "\n", "from", "cleverhans", ".", "plot", ".", "pyplot_image", "import", "get_logits_over_interval", "as", "new_get_logits_over_interval", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.neural_net_params_test.NeuralNetParamsTest.test_init": [[16, 37], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "neural_net_params_test.NeuralNetParamsTest.assertIsNotNone", "numpy.transpose", "numpy.transpose", "neural_net_params_test.NeuralNetParamsTest.assertRaises", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "neural_net_params_test.NeuralNetParamsTest.assertRaises", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.matrix", "numpy.matrix"], "methods", ["None"], ["  ", "def", "test_init", "(", "self", ")", ":", "\n", "# Function to test initialization of NeuralNetParams object.", "\n", "# Valid params", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "1", ",", "1", ",", "1", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "self", ".", "assertIsNotNone", "(", "nn_params1", ")", "\n", "# Invalid params : list length", "\n", "net_biases", "=", "[", "0", "]", "\n", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "      ", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "# Invalid params: layer types", "\n", "", "with", "self", ".", "assertRaises", "(", "ValueError", ")", ":", "\n", "      ", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff_relu'", "]", "\n", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.neural_net_params_test.NeuralNetParamsTest.test_forward_pass": [[38, 55], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "tensorflow.random_uniform", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams.forward_pass", "neural_net_params_test.NeuralNetParamsTest.assertEqual", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams.forward_pass", "neural_net_params_test.NeuralNetParamsTest.assertEqual", "tensorflow.random_uniform", "cleverhans.experimental.certification.neural_net_params.NeuralNetParams.forward_pass", "neural_net_params_test.NeuralNetParamsTest.assertEqual", "numpy.transpose", "numpy.transpose", "neural_net_params.NeuralNetParams.forward_pass.shape.as_list", "neural_net_params.NeuralNetParams.forward_pass.shape.as_list", "neural_net_params.NeuralNetParams.forward_pass.shape.as_list", "numpy.matrix", "numpy.matrix"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.neural_net_params.NeuralNetParams.forward_pass"], ["", "", "def", "test_forward_pass", "(", "self", ")", ":", "\n", "# Function to test forward pass of nn_params.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "1", ",", "1", ",", "1", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "input_vector", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "2", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "output_vector", "=", "nn_params", ".", "forward_pass", "(", "input_vector", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "output_vector", ".", "shape", ".", "as_list", "(", ")", ",", "[", "3", ",", "1", "]", ")", "\n", "output_vector_2", "=", "nn_params", ".", "forward_pass", "(", "input_vector", ",", "0", ",", "is_abs", "=", "True", ")", "\n", "self", ".", "assertEqual", "(", "output_vector_2", ".", "shape", ".", "as_list", "(", ")", ",", "[", "3", ",", "1", "]", ")", "\n", "input_vector_trans", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "output_vector_3", "=", "nn_params", ".", "forward_pass", "(", "input_vector_trans", ",", "0", ",", "\n", "is_transpose", "=", "True", ")", "\n", "self", ".", "assertEqual", "(", "output_vector_3", ".", "shape", ".", "as_list", "(", ")", ",", "[", "2", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.prepare_dual_object": [[17, 71], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.transpose", "tensorflow.reshape", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "numpy.transpose", "numpy.transpose", "numpy.matrix", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "numpy.matrix", "numpy.matrix", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform().astype", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform"], "methods", ["None"], ["  ", "def", "prepare_dual_object", "(", "self", ")", ":", "\n", "# Function to prepare dual object to be used for testing optimization.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "test_input", "=", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "\n", "true_class", "=", "0", "\n", "adv_class", "=", "1", "\n", "input_minval", "=", "0", "\n", "input_maxval", "=", "0", "\n", "epsilon", "=", "0.1", "\n", "\n", "# Creating dual variables to use for optimization", "\n", "lambda_pos", "=", "[", "tf", ".", "get_variable", "(", "'lambda_pos0'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "2", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "tf", ".", "get_variable", "(", "'lambda_pos1'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "3", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "]", "\n", "lambda_neg", "=", "[", "tf", ".", "get_variable", "(", "'lambda_neg0'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "2", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "tf", ".", "get_variable", "(", "'lambda_neg1'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "3", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "]", "\n", "lambda_quad", "=", "[", "tf", ".", "get_variable", "(", "'lambda_quad0'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "2", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "tf", ".", "get_variable", "(", "'lambda_quad1'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "3", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "]", "\n", "lambda_lu", "=", "[", "tf", ".", "get_variable", "(", "'lambda_lu0'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "2", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", ",", "\n", "tf", ".", "get_variable", "(", "'lambda_lu1'", ",", "\n", "initializer", "=", "np", ".", "random", ".", "uniform", "(", "\n", "0", ",", "0.1", ",", "size", "=", "(", "3", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "]", "\n", "nu", "=", "tf", ".", "reshape", "(", "tf", ".", "get_variable", "(", "'nu'", ",", "initializer", "=", "200.0", ",", "\n", "dtype", "=", "tf", ".", "float32", ")", ",", "shape", "=", "(", "1", ",", "1", ")", ")", "\n", "dual_var", "=", "{", "'lambda_pos'", ":", "lambda_pos", ",", "'lambda_neg'", ":", "lambda_neg", ",", "\n", "'lambda_quad'", ":", "lambda_quad", ",", "'lambda_lu'", ":", "lambda_lu", ",", "'nu'", ":", "nu", "}", "\n", "dual_formulation_object", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params1", ",", "\n", "test_input", ",", "\n", "true_class", ",", "\n", "adv_class", ",", "\n", "input_minval", ",", "\n", "input_maxval", ",", "\n", "epsilon", ")", "\n", "return", "dual_formulation_object", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.test_init": [[72, 87], ["optimization_test.OptimizationTest.prepare_dual_object", "optimization_test.OptimizationTest.set_differentiable_objective", "optimization_test.OptimizationTest.test_session", "sess.run", "cleverhans.experimental.certification.optimization.Optimization", "optimization_test.OptimizationTest.assertIsNotNone", "tensorflow.global_variables_initializer"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.prepare_dual_object", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective"], ["", "def", "test_init", "(", "self", ")", ":", "\n", "# Function to test initialization of OptimizationTest.", "\n", "    ", "dual_formulation_object", "=", "self", ".", "prepare_dual_object", "(", ")", "\n", "dual_formulation_object", ".", "set_differentiable_objective", "(", ")", "\n", "with", "self", ".", "test_session", "(", ")", "as", "sess", ":", "\n", "      ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "optimization_params", "=", "{", "'init_learning_rate'", ":", "0.1", ",", "\n", "'learning_rate_decay'", ":", "0.9", ",", "\n", "'eig_num_iter'", ":", "10", ",", "\n", "'eig_learning_rate'", ":", "0.01", ",", "\n", "'init_smooth'", ":", "0.5", ",", "\n", "'smooth_decay'", ":", "0.9", "}", "\n", "optimization_object", "=", "optimization", ".", "Optimization", "(", "dual_formulation_object", ",", "\n", "sess", ",", "optimization_params", ")", "\n", "self", ".", "assertIsNotNone", "(", "optimization_object", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.test_get_min_eig_vec_proxy": [[88, 148], ["optimization_test.OptimizationTest.prepare_dual_object", "optimization_test.OptimizationTest.get_full_psd_matrix", "optimization_test.OptimizationTest.test_session", "sess.run", "cleverhans.experimental.certification.optimization.Optimization", "cleverhans.experimental.certification.optimization.Optimization.get_min_eig_vec_proxy", "cleverhans.experimental.certification.optimization.Optimization.get_min_eig_vec_proxy", "optimization_test.OptimizationTest.assertIsNotNone", "sess.run", "numpy.matmul", "numpy.matmul", "numpy.linalg.eig", "optimization_test.OptimizationTest.assertLess", "optimization_test.OptimizationTest.assertLess", "cleverhans.experimental.certification.optimization.Optimization", "cleverhans.experimental.certification.optimization.Optimization.get_min_eig_vec_proxy", "cleverhans.experimental.certification.optimization.Optimization.get_min_eig_vec_proxy", "sess.run", "numpy.matmul", "numpy.matmul", "numpy.linalg.eig", "optimization_test.OptimizationTest.assertLess", "optimization_test.OptimizationTest.assertLess", "tensorflow.global_variables_initializer", "numpy.transpose", "numpy.matmul", "numpy.transpose", "numpy.matmul", "numpy.abs", "numpy.abs", "numpy.transpose", "numpy.matmul", "numpy.transpose", "numpy.matmul", "numpy.abs", "numpy.abs", "numpy.random.rand", "numpy.min", "numpy.min", "numpy.random.rand", "numpy.min", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.prepare_dual_object", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.get_min_eig_vec_proxy"], ["", "", "def", "test_get_min_eig_vec_proxy", "(", "self", ")", ":", "\n", "# Function test computing min eigen value using matrix vector products.", "\n", "    ", "dual_formulation_object", "=", "self", ".", "prepare_dual_object", "(", ")", "\n", "_", ",", "matrix_m", "=", "dual_formulation_object", ".", "get_full_psd_matrix", "(", ")", "\n", "optimization_params", "=", "{", "'init_learning_rate'", ":", "0.1", ",", "\n", "'learning_rate_decay'", ":", "0.9", ",", "\n", "'eig_num_iter'", ":", "2000", ",", "\n", "'eig_learning_rate'", ":", "0.01", ",", "\n", "'init_smooth'", ":", "0.0", ",", "\n", "'smooth_decay'", ":", "0.9", "}", "\n", "with", "self", ".", "test_session", "(", ")", "as", "sess", ":", "\n", "      ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "optimization_object", "=", "optimization", ".", "Optimization", "(", "dual_formulation_object", ",", "\n", "sess", ",", "optimization_params", ")", "\n", "eig_vec", "=", "optimization_object", ".", "get_min_eig_vec_proxy", "(", ")", "\n", "tf_eig_vec", "=", "optimization_object", ".", "get_min_eig_vec_proxy", "(", "use_tf_eig", "=", "True", ")", "\n", "self", ".", "assertIsNotNone", "(", "eig_vec", ")", "\n", "\n", "# Running the graphs and checking that minimum eigen value is correct", "\n", "# ** No smoothing", "\n", "tf_eig_vec_val", ",", "eig_vec_val", ",", "matrix_m_val", "=", "sess", ".", "run", "(", "\n", "[", "tf_eig_vec", ",", "eig_vec", ",", "matrix_m", "]", ",", "\n", "feed_dict", "=", "{", "optimization_object", ".", "eig_init_vec_placeholder", ":", "\n", "np", ".", "random", ".", "rand", "(", "6", ",", "1", ")", ",", "\n", "optimization_object", ".", "eig_num_iter_placeholder", ":", "2000", ",", "\n", "optimization_object", ".", "smooth_placeholder", ":", "0.0", "}", ")", "\n", "\n", "# Eigen value corresponding to v is v^\\top M v", "\n", "eig_val", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "eig_vec_val", ")", ",", "\n", "np", ".", "matmul", "(", "matrix_m_val", ",", "eig_vec_val", ")", ")", "\n", "tf_eig_val", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "tf_eig_vec_val", ")", ",", "\n", "np", ".", "matmul", "(", "matrix_m_val", ",", "tf_eig_vec_val", ")", ")", "\n", "[", "np_eig_values", ",", "_", "]", "=", "np", ".", "linalg", ".", "eig", "(", "matrix_m_val", ")", "\n", "self", ".", "assertLess", "(", "np", ".", "abs", "(", "np", ".", "min", "(", "np_eig_values", ")", "-", "eig_val", ")", ",", "1E-5", ")", "\n", "self", ".", "assertLess", "(", "np", ".", "abs", "(", "np", ".", "min", "(", "np_eig_values", ")", "-", "tf_eig_val", ")", ",", "1E-5", ")", "\n", "\n", "# Running the graphs and checking that minimum eigen value is correct", "\n", "# **Smoothing", "\n", "optimization_params", "[", "'init_smooth'", "]", "=", "0.0001", "\n", "optimization_object", "=", "optimization", ".", "Optimization", "(", "dual_formulation_object", ",", "\n", "sess", ",", "optimization_params", ")", "\n", "eig_vec", "=", "optimization_object", ".", "get_min_eig_vec_proxy", "(", ")", "\n", "tf_eig_vec", "=", "optimization_object", ".", "get_min_eig_vec_proxy", "(", "use_tf_eig", "=", "True", ")", "\n", "\n", "tf_eig_vec_val", ",", "eig_vec_val", ",", "matrix_m_val", "=", "sess", ".", "run", "(", "\n", "[", "tf_eig_vec", ",", "eig_vec", ",", "matrix_m", "]", ",", "\n", "feed_dict", "=", "{", "optimization_object", ".", "eig_init_vec_placeholder", ":", "\n", "np", ".", "random", ".", "rand", "(", "6", ",", "1", ")", ",", "\n", "optimization_object", ".", "smooth_placeholder", ":", "0.1", ",", "\n", "optimization_object", ".", "eig_num_iter_placeholder", ":", "2000", "}", ")", "\n", "\n", "# Eigen value corresponding to v is v^\\top M v", "\n", "eig_val", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "eig_vec_val", ")", ",", "\n", "np", ".", "matmul", "(", "matrix_m_val", ",", "eig_vec_val", ")", ")", "\n", "tf_eig_val", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "tf_eig_vec_val", ")", ",", "\n", "np", ".", "matmul", "(", "matrix_m_val", ",", "tf_eig_vec_val", ")", ")", "\n", "[", "np_eig_values", ",", "_", "]", "=", "np", ".", "linalg", ".", "eig", "(", "matrix_m_val", ")", "\n", "self", ".", "assertLess", "(", "np", ".", "abs", "(", "np", ".", "min", "(", "np_eig_values", ")", "-", "eig_val", ")", ",", "1E-5", ")", "\n", "# In general, smoothed version can be far off", "\n", "self", ".", "assertLess", "(", "np", ".", "abs", "(", "np", ".", "min", "(", "np_eig_values", ")", "-", "tf_eig_val", ")", ",", "1E-1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.test_optimization": [[149, 176], ["optimization_test.OptimizationTest.prepare_dual_object", "optimization_test.OptimizationTest.test_session", "sess.run", "cleverhans.experimental.certification.optimization.Optimization", "cleverhans.experimental.certification.optimization.Optimization.prepare_one_step", "optimization_test.OptimizationTest.assertIsNotNone", "cleverhans.experimental.certification.optimization.Optimization.run_optimization", "optimization_test.OptimizationTest.assertFalse", "tensorflow.global_variables_initializer"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.optimization_test.OptimizationTest.prepare_dual_object", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.prepare_one_step", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.optimization.Optimization.run_optimization"], ["", "", "def", "test_optimization", "(", "self", ")", ":", "\n", "# Function to test optimization.", "\n", "    ", "dual_formulation_object", "=", "self", ".", "prepare_dual_object", "(", ")", "\n", "optimization_params", "=", "{", "\n", "'init_penalty'", ":", "10000", ",", "\n", "'large_eig_num_steps'", ":", "1000", ",", "\n", "'small_eig_num_steps'", ":", "500", ",", "\n", "'inner_num_steps'", ":", "10", ",", "\n", "'outer_num_steps'", ":", "2", ",", "\n", "'beta'", ":", "2", ",", "\n", "'smoothness_parameter'", ":", "0.001", ",", "\n", "'eig_learning_rate'", ":", "0.01", ",", "\n", "'optimizer'", ":", "'adam'", ",", "\n", "'init_learning_rate'", ":", "0.1", ",", "\n", "'learning_rate_decay'", ":", "0.9", ",", "\n", "'momentum_parameter'", ":", "0.9", ",", "\n", "'print_stats_steps'", ":", "1", ",", "\n", "'stats_folder'", ":", "None", ",", "\n", "'projection_steps'", ":", "200", "}", "\n", "with", "self", ".", "test_session", "(", ")", "as", "sess", ":", "\n", "      ", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "optimization_object", "=", "optimization", ".", "Optimization", "(", "dual_formulation_object", ",", "\n", "sess", ",", "optimization_params", ")", "\n", "optimization_object", ".", "prepare_one_step", "(", ")", "\n", "self", ".", "assertIsNotNone", "(", "optimization_object", ".", "opt_one_step", ")", "\n", "is_cert_found", "=", "optimization_object", ".", "run_optimization", "(", ")", "\n", "self", ".", "assertFalse", "(", "is_cert_found", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.utils_test.UtilsTest.test_minimum_eigen_vector": [[16, 29], ["numpy.array", "numpy.array", "tensorflow.contrib.autograph.to_graph", "tensorflow.placeholder", "tensorflow.contrib.autograph.to_graph.", "numpy.testing.assert_almost_equal", "tensorflow.matmul", "utils_test.UtilsTest.test_session", "sess.run", "sess.run.flatten"], "methods", ["None"], ["  ", "def", "test_minimum_eigen_vector", "(", "self", ")", ":", "\n", "    ", "matrix", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "2.0", ",", "5.0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "initial_vec", "=", "np", ".", "array", "(", "[", "[", "1.0", "]", ",", "[", "-", "1.0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "def", "_vector_prod_fn", "(", "x", ")", ":", "\n", "      ", "return", "tf", ".", "matmul", "(", "matrix", ",", "x", ")", "\n", "", "min_eigen_fn", "=", "autograph", ".", "to_graph", "(", "utils", ".", "minimum_eigen_vector", ")", "\n", "x", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "shape", "=", "(", "2", ",", "1", ")", ")", "\n", "min_eig_vec", "=", "min_eigen_fn", "(", "x", ",", "10", ",", "0.1", ",", "_vector_prod_fn", ")", "\n", "with", "self", ".", "test_session", "(", ")", "as", "sess", ":", "\n", "      ", "v", "=", "sess", ".", "run", "(", "min_eig_vec", ",", "feed_dict", "=", "{", "x", ":", "initial_vec", "}", ")", "\n", "if", "v", ".", "flatten", "(", ")", "[", "0", "]", "<", "0", ":", "\n", "        ", "v", "=", "-", "v", "\n", "", "", "np", ".", "testing", ".", "assert_almost_equal", "(", "v", ",", "[", "[", "0.9239", "]", ",", "[", "-", "0.3827", "]", "]", ",", "decimal", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.dual_formulation_test.DualFormulationTest.test_init": [[17, 51], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.transpose", "tensorflow.random_uniform", "tensorflow.random_uniform", "tensorflow.random_uniform", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "dual_formulation_test.DualFormulationTest.assertIsNotNone", "numpy.transpose", "numpy.transpose", "numpy.matrix", "numpy.matrix", "numpy.matrix"], "methods", ["None"], ["  ", "def", "test_init", "(", "self", ")", ":", "\n", "# Function to test initialization of dual formulation class.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "test_input", "=", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "\n", "true_class", "=", "0", "\n", "adv_class", "=", "1", "\n", "input_minval", "=", "0", "\n", "input_maxval", "=", "0", "\n", "epsilon", "=", "0.1", "\n", "three_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "two_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "2", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "scalar", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "1", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "lambda_pos", "=", "[", "two_dim_tensor", ",", "three_dim_tensor", "]", "\n", "lambda_neg", "=", "lambda_pos", "\n", "lambda_quad", "=", "lambda_pos", "\n", "lambda_lu", "=", "lambda_pos", "\n", "nu", "=", "scalar", "\n", "dual_var", "=", "{", "'lambda_pos'", ":", "lambda_pos", ",", "'lambda_neg'", ":", "lambda_neg", ",", "\n", "'lambda_quad'", ":", "lambda_quad", ",", "'lambda_lu'", ":", "lambda_lu", ",", "'nu'", ":", "nu", "}", "\n", "dual_formulation_object", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params1", ",", "\n", "test_input", ",", "\n", "true_class", ",", "\n", "adv_class", ",", "\n", "input_minval", ",", "\n", "input_maxval", ",", "\n", "epsilon", ")", "\n", "self", ".", "assertIsNotNone", "(", "dual_formulation_object", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.dual_formulation_test.DualFormulationTest.test_set_differentiable_objective": [[52, 90], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.transpose", "tensorflow.random_uniform", "tensorflow.random_uniform", "tensorflow.random_uniform", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "cleverhans.experimental.certification.dual_formulation.DualFormulation.set_differentiable_objective", "dual_formulation_test.DualFormulationTest.assertEqual", "dual_formulation_test.DualFormulationTest.assertEqual", "dual_formulation_test.DualFormulationTest.assertEqual", "numpy.transpose", "numpy.transpose", "numpy.matrix", "cleverhans.experimental.certification.dual_formulation.DualFormulation.scalar_f.shape.as_list", "cleverhans.experimental.certification.dual_formulation.DualFormulation.unconstrained_objective.shape.as_list", "cleverhans.experimental.certification.dual_formulation.DualFormulation.vector_g.shape.as_list", "numpy.matrix", "numpy.matrix"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.set_differentiable_objective"], ["", "def", "test_set_differentiable_objective", "(", "self", ")", ":", "\n", "# Function to test the function that sets the differentiable objective.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "test_input", "=", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "\n", "true_class", "=", "0", "\n", "adv_class", "=", "1", "\n", "input_minval", "=", "0", "\n", "input_maxval", "=", "0", "\n", "epsilon", "=", "0.1", "\n", "three_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "two_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "2", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "scalar", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "1", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "lambda_pos", "=", "[", "two_dim_tensor", ",", "three_dim_tensor", "]", "\n", "lambda_neg", "=", "lambda_pos", "\n", "lambda_quad", "=", "lambda_pos", "\n", "lambda_lu", "=", "lambda_pos", "\n", "nu", "=", "scalar", "\n", "dual_var", "=", "{", "'lambda_pos'", ":", "lambda_pos", ",", "'lambda_neg'", ":", "lambda_neg", ",", "\n", "'lambda_quad'", ":", "lambda_quad", ",", "'lambda_lu'", ":", "lambda_lu", ",", "'nu'", ":", "nu", "}", "\n", "dual_formulation_object", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params1", ",", "\n", "test_input", ",", "\n", "true_class", ",", "\n", "adv_class", ",", "\n", "input_minval", ",", "\n", "input_maxval", ",", "\n", "epsilon", ")", "\n", "dual_formulation_object", ".", "set_differentiable_objective", "(", ")", "\n", "self", ".", "assertEqual", "(", "dual_formulation_object", ".", "scalar_f", ".", "shape", ".", "as_list", "(", ")", ",", "[", "1", "]", ")", "\n", "self", ".", "assertEqual", "(", "\n", "dual_formulation_object", ".", "unconstrained_objective", ".", "shape", ".", "as_list", "(", ")", ",", "[", "1", ",", "1", "]", ")", "\n", "self", ".", "assertEqual", "(", "dual_formulation_object", ".", "vector_g", ".", "shape", ".", "as_list", "(", ")", ",", "[", "5", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.dual_formulation_test.DualFormulationTest.test_get_full_psd_matrix": [[91, 127], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.transpose", "tensorflow.random_uniform", "tensorflow.random_uniform", "tensorflow.random_uniform", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "cleverhans.experimental.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "dual_formulation_test.DualFormulationTest.assertEqual", "dual_formulation_test.DualFormulationTest.assertEqual", "numpy.transpose", "numpy.transpose", "numpy.matrix", "matrix_h.shape.as_list", "matrix_m.shape.as_list", "numpy.matrix", "numpy.matrix"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix"], ["", "def", "test_get_full_psd_matrix", "(", "self", ")", ":", "\n", "# Function to test product with PSD matrix.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "test_input", "=", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "\n", "true_class", "=", "0", "\n", "adv_class", "=", "1", "\n", "input_minval", "=", "0", "\n", "input_maxval", "=", "0", "\n", "epsilon", "=", "0.1", "\n", "three_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "two_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "2", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "scalar", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "1", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "lambda_pos", "=", "[", "two_dim_tensor", ",", "three_dim_tensor", "]", "\n", "lambda_neg", "=", "lambda_pos", "\n", "lambda_quad", "=", "lambda_pos", "\n", "lambda_lu", "=", "lambda_pos", "\n", "nu", "=", "scalar", "\n", "dual_var", "=", "{", "'lambda_pos'", ":", "lambda_pos", ",", "'lambda_neg'", ":", "lambda_neg", ",", "\n", "'lambda_quad'", ":", "lambda_quad", ",", "'lambda_lu'", ":", "lambda_lu", ",", "'nu'", ":", "nu", "}", "\n", "dual_formulation_object", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params1", ",", "\n", "test_input", ",", "\n", "true_class", ",", "\n", "adv_class", ",", "\n", "input_minval", ",", "\n", "input_maxval", ",", "\n", "epsilon", ")", "\n", "matrix_h", ",", "matrix_m", "=", "dual_formulation_object", ".", "get_full_psd_matrix", "(", ")", "\n", "self", ".", "assertEqual", "(", "matrix_h", ".", "shape", ".", "as_list", "(", ")", ",", "[", "5", ",", "5", "]", ")", "\n", "self", ".", "assertEqual", "(", "matrix_m", ".", "shape", ".", "as_list", "(", ")", ",", "[", "6", ",", "6", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.dual_formulation_test.DualFormulationTest.test_get_psd_product": [[128, 175], ["cleverhans.experimental.certification.neural_net_params.NeuralNetParams", "numpy.transpose", "tensorflow.random_uniform", "tensorflow.random_uniform", "tensorflow.random_uniform", "cleverhans.experimental.certification.dual_formulation.DualFormulation", "cleverhans.experimental.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "tensorflow.random_uniform", "cleverhans.experimental.certification.dual_formulation.DualFormulation.get_psd_product", "tensorflow.matmul", "numpy.transpose", "numpy.transpose", "numpy.matrix", "tensorflow.Session", "sess.run", "dual_formulation_test.DualFormulationTest.assertEqual", "dual_formulation_test.DualFormulationTest.assertLess", "numpy.matrix", "numpy.matrix", "numpy.shape", "numpy.shape", "numpy.max", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_full_psd_matrix", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.certification.dual_formulation.DualFormulation.get_psd_product"], ["", "def", "test_get_psd_product", "(", "self", ")", ":", "\n", "# Function to test implicit product with PSD matrix.", "\n", "    ", "net_weights", "=", "[", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", ",", "[", "4", ",", "4", "]", "]", ",", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "]", "]", "\n", "net_biases", "=", "[", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", ",", "0", "]", ")", ")", ",", "\n", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "]", "\n", "net_layer_types", "=", "[", "'ff_relu'", ",", "'ff'", "]", "\n", "nn_params1", "=", "neural_net_params", ".", "NeuralNetParams", "(", "net_weights", ",", "net_biases", ",", "\n", "net_layer_types", ")", "\n", "\n", "test_input", "=", "np", ".", "transpose", "(", "np", ".", "matrix", "(", "[", "0", ",", "0", "]", ")", ")", "\n", "true_class", "=", "0", "\n", "adv_class", "=", "1", "\n", "input_minval", "=", "0", "\n", "input_maxval", "=", "0", "\n", "epsilon", "=", "0.1", "\n", "three_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "3", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "two_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "2", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "scalar", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "1", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "lambda_pos", "=", "[", "two_dim_tensor", ",", "three_dim_tensor", "]", "\n", "lambda_neg", "=", "lambda_pos", "\n", "lambda_quad", "=", "lambda_pos", "\n", "lambda_lu", "=", "lambda_pos", "\n", "nu", "=", "scalar", "\n", "dual_var", "=", "{", "'lambda_pos'", ":", "lambda_pos", ",", "'lambda_neg'", ":", "lambda_neg", ",", "\n", "'lambda_quad'", ":", "lambda_quad", ",", "'lambda_lu'", ":", "lambda_lu", ",", "'nu'", ":", "nu", "}", "\n", "dual_formulation_object", "=", "dual_formulation", ".", "DualFormulation", "(", "dual_var", ",", "\n", "nn_params1", ",", "\n", "test_input", ",", "\n", "true_class", ",", "\n", "adv_class", ",", "\n", "input_minval", ",", "\n", "input_maxval", ",", "\n", "epsilon", ")", "\n", "_", ",", "matrix_m", "=", "dual_formulation_object", ".", "get_full_psd_matrix", "(", ")", "\n", "\n", "# Testing if the values match", "\n", "six_dim_tensor", "=", "tf", ".", "random_uniform", "(", "shape", "=", "(", "6", ",", "1", ")", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "implicit_product", "=", "dual_formulation_object", ".", "get_psd_product", "(", "\n", "six_dim_tensor", ")", "\n", "explicit_product", "=", "tf", ".", "matmul", "(", "matrix_m", ",", "six_dim_tensor", ")", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "      ", "[", "implicit_product_value", ",", "explicit_product_value", "]", "=", "sess", ".", "run", "(", "\n", "[", "implicit_product", ",", "explicit_product", "]", ")", "\n", "self", ".", "assertEqual", "(", "np", ".", "shape", "(", "implicit_product_value", ")", ",", "\n", "np", ".", "shape", "(", "explicit_product_value", ")", ")", "\n", "self", ".", "assertLess", "(", "np", ".", "max", "(", "np", ".", "abs", "(", "\n", "implicit_product_value", "-", "explicit_product_value", ")", ")", ",", "1E-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.test_format.update_whitelist": [[23, 49], ["whitelist_pep8.extend", "whitelist_pep8.extend", "whitelist_pep8.extend", "whitelist_pep8.extend", "whitelist_pep8.extend", "whitelist_pep8.extend", "os.path.relpath", "os.path.relpath", "os.path.relpath", "os.path.relpath", "os.path.relpath", "os.path.relpath"], "function", ["None"], ["def", "update_whitelist", "(", ")", ":", "\n", "  ", "global", "whitelist_pep8", "\n", "# We don't want to test RL-attack because it has so many dependencies", "\n", "# not used elsewhere, and pylint wants to import them all", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "if", "\"RL-attack\"", "in", "path", "]", ")", "\n", "# Similarly, we don't want to require robust_vision_benchmark installed", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "\n", "if", "\"robust_vision_benchmark\"", "in", "path", "]", ")", "\n", "# Similarly, we don't want to require that cloud be installed", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "\n", "if", "\"cloud_client\"", "in", "path", "]", ")", "\n", "# This example has more dependencies too", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "\n", "if", "\"facenet_adversarial_faces\"", "in", "path", "]", ")", "\n", "# This too", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "\n", "if", "\"madry_lab_challenges\"", "in", "path", "]", ")", "\n", "# This code is no longer compatible with new versions of cleverhans / scipy and will be removed soon", "\n", "whitelist_pep8", ".", "extend", "(", "[", "os", ".", "path", ".", "relpath", "(", "path", ",", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "for", "path", "in", "all_py_files", "\n", "if", "\"nips17_adversarial_competition\"", "in", "path", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.tests.test_format.test_format_pep8": [[58, 111], ["os.path.join", "os.path.join", "os.path.exists", "os.path.relpath", "cleverhans.utils.shell_call", "files_to_check.append", "ValueError", "e.output.decode"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.shell_call"], ["def", "test_format_pep8", "(", ")", ":", "\n", "  ", "\"\"\"\n  Test if pep8 is respected.\n  \"\"\"", "\n", "files_to_check", "=", "[", "]", "\n", "module_dir", "=", "cleverhans", ".", "__path__", "[", "0", "]", "\n", "for", "path", "in", "all_py_files", ":", "\n", "    ", "rel_path", "=", "os", ".", "path", ".", "relpath", "(", "path", ",", "module_dir", ")", "\n", "if", "rel_path", "in", "whitelist_pep8", ":", "\n", "      ", "continue", "\n", "", "else", ":", "\n", "      ", "files_to_check", ".", "append", "(", "path", ")", "\n", "", "", "repo_dir", "=", "os", ".", "path", ".", "join", "(", "module_dir", ",", "os", ".", "pardir", ")", "\n", "rcpath", "=", "os", ".", "path", ".", "join", "(", "repo_dir", ",", "'.pylintrc'", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "rcpath", ")", "\n", "\n", "# We must run pylint via the command line and subprocess because of", "\n", "# problems with the pylint module.", "\n", "# The documentation claims you can run it as a python module, but", "\n", "# the documentation is wrong: https://github.com/PyCQA/pylint/issues/1870", "\n", "# If you run the version described in the linked issue, pylint", "\n", "# calls sys.exit once it is done, so it kills the test.", "\n", "\n", "# Running all files in one pylint command is important for 2 reasons:", "\n", "# 1) Correctness: pylint can detect issues that require access to multiple", "\n", "#    files, such as cyclic imports", "\n", "# 2) Speed: pylint imports modules for deep analysis, so if you run", "\n", "#    multiple subprocesses each needs to re-import tensorflow.", "\n", "# On Ian's laptop, pylint takes about 10s per file to run on the repo,", "\n", "# and there are about 90 files as of the writing of this comment.", "\n", "# Running pylint on all files simultaneously takes about 70s, so it", "\n", "# is a little better than a 10X speedup.", "\n", "\n", "# Running multiple jobs in parallel helps but far less than linearly.", "\n", "# On Ian's 4-core laptop, running 4 jobs drops the runtime from 70s", "\n", "# to 45s.", "\n", "# Some of the work is I/O, so it actually makes some sense to run", "\n", "# more jobs than cores. On Ian's 4-core laptop, running 8 jobs drops", "\n", "# the runtime to 40s.", "\n", "# There's a further complication though: I think each job needs to", "\n", "# redo imports, so the total amount of work to do increases with", "\n", "# the number of jobs. On Ian's laptop, using 64 jobs causes the", "\n", "# runtime to increase to 220s. There is not an obvious simple", "\n", "# formula like \"use one job per CPU core\" or \"use way more jobs", "\n", "# than cores to saturate I/O\". For now I'm hoping that 8 will be", "\n", "# a reasonable default: it gets good performance on my laptop,", "\n", "# and on machines with fewer than 4 cores there should still be", "\n", "# a benefit to not being blocked on I/O.", "\n", "\n", "try", ":", "\n", "    ", "shell_call", "(", "[", "'pylint'", ",", "'--rcfile'", ",", "rcpath", ",", "'--jobs'", ",", "'8'", "]", "+", "files_to_check", ")", "\n", "", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "\n", "    ", "raise", "ValueError", "(", "e", ".", "output", ".", "decode", "(", "\"utf-8\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.success_fail.plot_report_from_path": [[18, 55], ["cleverhans.serial.load", "success_fail.plot_report"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.load", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.success_fail.plot_report"], ["def", "plot_report_from_path", "(", "path", ",", "success_name", "=", "DEFAULT_SUCCESS_NAME", ",", "\n", "fail_names", "=", "DEFAULT_FAIL_NAMES", ",", "label", "=", "None", ",", "\n", "is_max_confidence", "=", "True", ",", "\n", "linewidth", "=", "LINEWIDTH", ",", "\n", "plot_upper_bound", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  Plots a success-fail curve from a confidence report stored on disk,\n  :param path: string filepath for the stored report.\n    (Should be the output of make_confidence_report*.py)\n  :param success_name: The name (confidence report key) of the data that\n    should be used to measure success rate\n  :param fail_names: A list of names (confidence report keys) of the data\n    that should be used to measure failure rate.\n    *Only one of these keys will be plotted*. Each key will be tried in\n    order until one is found in the report. This is to support both the\n    output of `make_confidence_report` and `make_confidence_report_bundled`.\n  :param label: Optional string. Name to use for this curve in the legend.\n  :param is_max_confidence: bool.\n    If True, when measuring the failure rate, treat the data as the output\n    of a maximum confidence attack procedure.\n    This means that the attack is optimal (assuming the underlying optimizer\n    is good enough, *which is probably false*, so interpret the plot\n    accordingly) for thresholds >= .5 but for lower thresholds the observed\n    failure rate is a lower bound on the true worst failure rate and the\n    observed coverage is an upper bound (assuming good enough optimization)\n    on the true failure rate.\n    The plot thus draws the threshold >= .5 portion of the curve with a solid\n    line and the upper and lower bounds with a dashed line.\n    See https://openreview.net/forum?id=H1g0piA9tQ for details.\n    If False, the attack procedure is regarded as an ad hoc way of obtaining\n    a loose lower bound, and thus the whole curve is drawn with dashed lines.\n  :param linewidth: thickness of the line to draw\n  :param plot_upper_bound: include upper bound on error rate in plot\n  \"\"\"", "\n", "report", "=", "load", "(", "path", ")", "\n", "plot_report", "(", "report", ",", "success_name", ",", "fail_names", ",", "label", ",", "is_max_confidence", ",", "\n", "linewidth", ",", "plot_upper_bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.success_fail.plot_report": [[57, 98], ["success_fail.make_curve", "numpy.array", "numpy.array", "numpy.array", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "len", "len", "matplotlib.pyplot.plot", "p.get_color", "matplotlib.pyplot.plot", "numpy.concatenate", "matplotlib.pyplot.plot", "print", "matplotlib.pyplot.plot", "gap.min", "gap.max"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.success_fail.make_curve"], ["", "def", "plot_report", "(", "report", ",", "success_name", ",", "fail_names", ",", "label", "=", "None", ",", "\n", "is_max_confidence", "=", "True", ",", "\n", "linewidth", "=", "LINEWIDTH", ",", "\n", "plot_upper_bound", "=", "True", ")", ":", "\n", "  ", "\"\"\"\n  Plot a success fail curve from a confidence report\n  :param report: A confidence report\n    (the type of object saved by make_confidence_report.py)\n  :param success_name: see plot_report_from_path\n  :param fail_names: see plot_report_from_path\n  :param label: see plot_report_from_path\n  :param is_max_confidence: see plot_report_from_path\n  :param linewidth: see plot_report_from_path\n  \"\"\"", "\n", "(", "fail_optimal", ",", "success_optimal", ",", "fail_lower_bound", ",", "fail_upper_bound", ",", "\n", "success_bounded", ")", "=", "make_curve", "(", "report", ",", "success_name", ",", "fail_names", ")", "\n", "assert", "len", "(", "fail_lower_bound", ")", "==", "len", "(", "fail_upper_bound", ")", "\n", "fail_optimal", "=", "np", ".", "array", "(", "fail_optimal", ")", "\n", "fail_lower_bound", "=", "np", ".", "array", "(", "fail_lower_bound", ")", "\n", "fail_upper_bound", "=", "np", ".", "array", "(", "fail_upper_bound", ")", "\n", "\n", "if", "is_max_confidence", ":", "\n", "    ", "p", ",", "=", "pyplot", ".", "plot", "(", "fail_optimal", ",", "success_optimal", ",", "label", "=", "label", ",", "\n", "linewidth", "=", "linewidth", ")", "\n", "color", "=", "p", ".", "get_color", "(", ")", "\n", "pyplot", ".", "plot", "(", "fail_lower_bound", ",", "success_bounded", ",", "'--'", ",", "color", "=", "color", ")", "\n", "if", "plot_upper_bound", ":", "\n", "      ", "pyplot", ".", "plot", "(", "fail_upper_bound", ",", "success_bounded", ",", "'--'", ",", "color", "=", "color", ")", "\n", "", "", "else", ":", "\n", "# If the attack was not MaxConfidence, then this whole curve is just", "\n", "# a loose lower bound", "\n", "    ", "all_fail", "=", "np", ".", "concatenate", "(", "(", "fail_optimal", ",", "fail_lower_bound", ")", ",", "axis", "=", "0", ")", "\n", "pyplot", ".", "plot", "(", "all_fail", ",", "success_optimal", "+", "success_bounded", ",", "\n", "'--'", ",", "label", "=", "label", ",", "linewidth", "=", "linewidth", ")", "\n", "\n", "", "pyplot", ".", "xlabel", "(", "\"Failure rate on adversarial examples\"", ")", "\n", "pyplot", ".", "ylabel", "(", "\"Success rate on clean examples\"", ")", "\n", "gap", "=", "fail_upper_bound", "-", "fail_lower_bound", "\n", "if", "gap", ".", "size", ">", "0", ":", "\n", "    ", "assert", "gap", ".", "min", "(", ")", ">=", "0.", "\n", "print", "(", "\"Max gap: \"", ",", "gap", ".", "max", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.success_fail.make_curve": [[100, 275], ["isinstance", "len", "len", "sorted", "ValueError", "warnings.warn", "isinstance", "warnings.warn", "warnings.warn", "len", "warnings.warn", "cleverhans.utils.safe_zip", "cleverhans.utils.safe_zip", "float", "float", "success_optimal.append", "fail_optimal.append", "success_bounded.append", "fail_lower_bound.append", "fail_upper_bound.append", "len", "str", "len", "len", "report.keys", "str", "fail_optimal.append", "success_optimal.append", "float"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.safe_zip"], ["", "", "def", "make_curve", "(", "report", ",", "success_name", ",", "fail_names", ")", ":", "\n", "  ", "\"\"\"\n  Make a success-failure curve.\n  :param report: A confidence report\n    (the type of object saved by make_confidence_report.py)\n  :param success_name: see plot_report_from_path\n  :param fail_names: see plot_report_from_path\n  :returns:\n    fail_optimal: list of failure rates on adversarial data for the optimal\n      (t >= .5) part of the curve. Each entry corresponds to a different\n      threshold. Thresholds are chosen to make the smoothest possible curve\n      from the available data, e.g. one threshold between each unique\n      confidence value observed in the data. To make sure that linear\n      interpolation between points in the curve never overestimates the\n      failure rate for a specific success rate, the curve also includes\n      extra points that increment the failure rate prior to any point\n      that increments the success rate, so the curve moves up and to the\n      right in a series of backwards \"L\" shapes rather than moving up\n      and to the right along diagonal lines. For large datasets these\n      maximally pessimistic points will usually not be visible and the\n      curve will appear smooth.\n    success_optimal: list of success rates on clean data on the optimal\n      part of the curve. Matches up with `fail_optimal`.\n    fail_lower_bound: list of observed failure rates on the t < .5 portion\n      of the curve where MaxConfidence is not optimal.\n    fail_upper_bound: list of upper bounds (assuming good enough optimization,\n      so not a true upper bound) on the failure rates on the t < .5 portion\n      of the curve where MaxConfidence is not optimal. Matches up with\n      `fail_lower_bound`.\n    success_bounded: success rates on the non-optimal part of the curve.\n      Matches up with `fail_lower_bound` and `fail_upper_bound`.\n  \"\"\"", "\n", "success_results", "=", "report", "[", "success_name", "]", "\n", "fail_name", "=", "None", "# pacify pylint", "\n", "found", "=", "False", "\n", "for", "fail_name", "in", "fail_names", ":", "\n", "    ", "if", "fail_name", "in", "report", ":", "\n", "      ", "found", "=", "True", "\n", "break", "\n", "", "", "if", "not", "found", ":", "\n", "    ", "raise", "ValueError", "(", "fail_name", "+", "\" not in report.\"", "\n", "\"Available keys: \"", "+", "str", "(", "report", ".", "keys", "(", ")", ")", ")", "\n", "", "fail_results", "=", "report", "[", "fail_name", "]", "\n", "\n", "# \"good\" means drawn from the distribution where we measure success rate.", "\n", "# \"bad\" means drawn from the distribution where we measure failure rate.", "\n", "# From here on out we use those terms, to avoid confusion between examples", "\n", "# that actually failed and examples that were drawn from the distribution", "\n", "# where we measured failure rate.", "\n", "\n", "old_all_probs_version", "=", "False", "\n", "if", "isinstance", "(", "success_results", ",", "dict", ")", ":", "\n", "# This dictionary key lookup will trigger a deprecation warning if `success_results` is not the old dictionary", "\n", "# style of report, so we don't want to do a dictionary lookup unless we really are using the old version.", "\n", "    ", "old_all_probs_version", "=", "'all_probs'", "in", "success_results", "\n", "\n", "", "if", "old_all_probs_version", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"The 'all_probs' key is included only to support \"", "\n", "\" old files from a private development codebase. \"", "\n", "\"Support for this key can be dropped at any time \"", "\n", "\" without warning.\"", ")", "\n", "good_probs", "=", "success_results", "[", "'all_probs'", "]", "\n", "bad_probs", "=", "fail_results", "[", "'all_probs'", "]", "\n", "bad_corrects", "=", "fail_results", "[", "'correctness_mask'", "]", "\n", "good_corrects", "=", "success_results", "[", "'correctness_mask'", "]", "\n", "", "else", ":", "\n", "    ", "if", "isinstance", "(", "success_results", ",", "dict", ")", ":", "\n", "# Still using dict, but using newer key names", "\n", "      ", "warnings", ".", "warn", "(", "\"Support for dictionary confidence reports is deprecated. Switch to using the classes in \"", "\n", "\"cleverhans.confidence_report. Support for old dictionary-style reports may be removed \"", "\n", "\"on or after 2019-07-19.\"", ")", "\n", "good_probs", "=", "success_results", "[", "'confidence'", "]", "\n", "bad_probs", "=", "fail_results", "[", "'confidence'", "]", "\n", "good_corrects", "=", "success_results", "[", "'correctness'", "]", "\n", "bad_corrects", "=", "fail_results", "[", "'correctness'", "]", "\n", "", "else", ":", "\n", "# current version", "\n", "      ", "good_probs", "=", "success_results", ".", "confidence", "\n", "bad_probs", "=", "fail_results", ".", "confidence", "\n", "good_corrects", "=", "success_results", ".", "correctness", "\n", "bad_corrects", "=", "fail_results", ".", "correctness", "\n", "", "", "good_triplets", "=", "[", "(", "prob", ",", "correct", ",", "True", ")", "for", "prob", ",", "correct", "\n", "in", "safe_zip", "(", "good_probs", ",", "good_corrects", ")", "]", "\n", "bad_triplets", "=", "[", "(", "prob", ",", "correct", ",", "False", ")", "for", "prob", ",", "correct", "\n", "in", "safe_zip", "(", "bad_probs", ",", "bad_corrects", ")", "]", "\n", "total_good", "=", "len", "(", "good_triplets", ")", "\n", "total_bad", "=", "len", "(", "bad_triplets", ")", "\n", "if", "total_good", "!=", "10000", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"Not using full test set? Found \"", "+", "str", "(", "total_good", ")", "+", "\n", "\" examples for measuring success rate\"", ")", "\n", "", "if", "total_bad", "!=", "10000", ":", "\n", "    ", "warnings", ".", "warn", "(", "\"Not using full test set for adversarial examples?\"", ")", "\n", "", "all_triplets", "=", "good_triplets", "+", "bad_triplets", "\n", "all_triplets", "=", "sorted", "(", "all_triplets", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "0", "]", ")", "\n", "\n", "# Start with the case for threshold t = 1.", "\n", "# Examples are covered only if prob > t (strict inequality)", "\n", "# So initially nothing is covered", "\n", "good_covered_and_correct", "=", "0", "\n", "bad_covered_and_incorrect", "=", "0", "\n", "\n", "# Number of examples that are bad, incorrect, and covered by", "\n", "# a t >= 0.5, or that were merely covered by a t < 0.5", "\n", "failure_opportunities", "=", "0", "\n", "\n", "next_idx", "=", "0", "\n", "\n", "fail_optimal", "=", "[", "]", "\n", "success_optimal", "=", "[", "]", "\n", "fail_upper_bound", "=", "[", "]", "\n", "fail_lower_bound", "=", "[", "]", "\n", "success_bounded", "=", "[", "]", "\n", "\n", "bounded", "=", "False", "\n", "\n", "# NOTE: the loop always exits via an internal break statement.", "\n", "# Copied the termination condition to the while statement for ease", "\n", "# of reading.", "\n", "while", "next_idx", "<", "len", "(", "all_triplets", ")", ":", "\n", "    ", "gs", "=", "float", "(", "good_covered_and_correct", ")", "/", "total_good", "\n", "bf", "=", "float", "(", "bad_covered_and_incorrect", ")", "/", "total_bad", "\n", "# Add results for current threshold to the list", "\n", "if", "not", "bounded", ":", "\n", "\n", "# Sometimes when there are big jumps the failure rate it makes", "\n", "# artifacts in the plot, where there's a long linear track.", "\n", "# This implies the real success-fail curve is linear when", "\n", "# actually it just isn't sampled by the data.", "\n", "# To avoid implying that the model reaches a higher success", "\n", "# rate than it actually does, we avoid these plotting artifacts", "\n", "# by introducing extra points that make the graph move horizontally", "\n", "# to the right first, then vertically.", "\n", "      ", "if", "len", "(", "fail_optimal", ")", ">", "0", ":", "\n", "        ", "prev_bf", "=", "fail_optimal", "[", "-", "1", "]", "\n", "prev_gs", "=", "success_optimal", "[", "-", "1", "]", "\n", "\n", "if", "gs", ">", "prev_gs", "and", "bf", ">", "prev_bf", ":", "\n", "          ", "fail_optimal", ".", "append", "(", "bf", ")", "\n", "success_optimal", ".", "append", "(", "prev_gs", ")", "\n", "\n", "", "", "success_optimal", ".", "append", "(", "gs", ")", "\n", "fail_optimal", ".", "append", "(", "bf", ")", "\n", "", "else", ":", "\n", "      ", "success_bounded", ".", "append", "(", "gs", ")", "\n", "fail_lower_bound", ".", "append", "(", "bf", ")", "\n", "fail_upper_bound", ".", "append", "(", "float", "(", "failure_opportunities", ")", "/", "total_bad", ")", "\n", "\n", "", "if", "next_idx", "==", "len", "(", "all_triplets", ")", ":", "\n", "      ", "break", "\n", "\n", "# next_prob_to_include is not quite the same thing as the threshold.", "\n", "# The threshold is infinitesimally smaller than this value.", "\n", "", "next_prob_to_include", "=", "all_triplets", "[", "next_idx", "]", "[", "0", "]", "\n", "\n", "# Process all ties", "\n", "while", "next_prob_to_include", "==", "all_triplets", "[", "next_idx", "]", "[", "0", "]", ":", "\n", "      ", "_prob", ",", "correct", ",", "is_good", "=", "all_triplets", "[", "next_idx", "]", "\n", "if", "is_good", ":", "\n", "        ", "good_covered_and_correct", "+=", "correct", "\n", "", "else", ":", "\n", "        ", "if", "next_prob_to_include", "<=", ".5", ":", "\n", "          ", "failure_opportunities", "+=", "1", "\n", "", "else", ":", "\n", "          ", "failure_opportunities", "+=", "1", "-", "correct", "\n", "", "bad_covered_and_incorrect", "+=", "1", "-", "correct", "\n", "", "next_idx", "+=", "1", "\n", "if", "next_idx", "==", "len", "(", "all_triplets", ")", ":", "\n", "        ", "break", "\n", "\n", "", "", "if", "next_prob_to_include", "<=", ".5", ":", "\n", "      ", "bounded", "=", "True", "\n", "\n", "", "", "out", "=", "(", "fail_optimal", ",", "success_optimal", ",", "fail_lower_bound", ",", "fail_upper_bound", ",", "\n", "success_bounded", ")", "\n", "return", "out", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.save_pdf.save_pdf": [[8, 18], ["matplotlib.backends.backend_pdf.PdfPages", "matplotlib.backends.backend_pdf.PdfPages.savefig", "matplotlib.backends.backend_pdf.PdfPages.close", "matplotlib.pyplot.gcf"], "function", ["None"], ["def", "save_pdf", "(", "path", ")", ":", "\n", "  ", "\"\"\"\n  Saves a pdf of the current matplotlib figure.\n\n  :param path: str, filepath to save to\n  \"\"\"", "\n", "\n", "pp", "=", "PdfPages", "(", "path", ")", "\n", "pp", ".", "savefig", "(", "pyplot", ".", "gcf", "(", ")", ")", "\n", "pp", ".", "close", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.pyplot_image.pair_visual": [[9, 50], ["numpy.squeeze", "numpy.squeeze", "enumerate", "plt.show", "plt.ion", "plt.figure", "plt.figure.canvas.set_window_title", "plt.figure.add_subplot", "plt.axis", "plt.pause", "len", "len", "len", "plt.imshow", "plt.imshow"], "function", ["None"], ["def", "pair_visual", "(", "original", ",", "adversarial", ",", "figure", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  This function displays two images: the original and the adversarial sample\n  :param original: the original input\n  :param adversarial: the input after perturbations have been applied\n  :param figure: if we've already displayed images, use the same plot\n  :return: the matplot figure to reuse for future samples\n  \"\"\"", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "# Squeeze the image to remove single-dimensional entries from array shape", "\n", "original", "=", "np", ".", "squeeze", "(", "original", ")", "\n", "adversarial", "=", "np", ".", "squeeze", "(", "adversarial", ")", "\n", "\n", "# Ensure our inputs are of proper shape", "\n", "assert", "(", "len", "(", "original", ".", "shape", ")", "==", "2", "or", "len", "(", "original", ".", "shape", ")", "==", "3", ")", "\n", "\n", "# To avoid creating figures per input sample, reuse the sample plot", "\n", "if", "figure", "is", "None", ":", "\n", "    ", "plt", ".", "ion", "(", ")", "\n", "figure", "=", "plt", ".", "figure", "(", ")", "\n", "figure", ".", "canvas", ".", "set_window_title", "(", "'Cleverhans: Pair Visualization'", ")", "\n", "\n", "# Add the images to the plot", "\n", "", "perturbations", "=", "adversarial", "-", "original", "\n", "for", "index", ",", "image", "in", "enumerate", "(", "(", "original", ",", "perturbations", ",", "adversarial", ")", ")", ":", "\n", "    ", "figure", ".", "add_subplot", "(", "1", ",", "3", ",", "index", "+", "1", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "\n", "# If the image is 2D, then we have 1 color channel", "\n", "if", "len", "(", "image", ".", "shape", ")", "==", "2", ":", "\n", "      ", "plt", ".", "imshow", "(", "image", ",", "cmap", "=", "'gray'", ")", "\n", "", "else", ":", "\n", "      ", "plt", ".", "imshow", "(", "image", ")", "\n", "\n", "# Give the plot some time to update", "\n", "", "plt", ".", "pause", "(", "0.01", ")", "\n", "\n", "# Draw the plot and return", "\n", "", "plt", ".", "show", "(", ")", "\n", "return", "figure", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.pyplot_image.grid_visual": [[51, 82], ["plt.ioff", "plt.figure", "plt.figure.canvas.set_window_title", "six.moves.range", "plt.show", "six.moves.range", "plt.figure.add_subplot", "plt.axis", "plt.imshow", "plt.imshow"], "function", ["None"], ["", "def", "grid_visual", "(", "data", ")", ":", "\n", "  ", "\"\"\"\n  This function displays a grid of images to show full misclassification\n  :param data: grid data of the form;\n      [nb_classes : nb_classes : img_rows : img_cols : nb_channels]\n  :return: if necessary, the matplot figure to reuse\n  \"\"\"", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "# Ensure interactive mode is disabled and initialize our graph", "\n", "plt", ".", "ioff", "(", ")", "\n", "figure", "=", "plt", ".", "figure", "(", ")", "\n", "figure", ".", "canvas", ".", "set_window_title", "(", "'Cleverhans: Grid Visualization'", ")", "\n", "\n", "# Add the images to the plot", "\n", "num_cols", "=", "data", ".", "shape", "[", "0", "]", "\n", "num_rows", "=", "data", ".", "shape", "[", "1", "]", "\n", "num_channels", "=", "data", ".", "shape", "[", "4", "]", "\n", "for", "y", "in", "range", "(", "num_rows", ")", ":", "\n", "    ", "for", "x", "in", "range", "(", "num_cols", ")", ":", "\n", "      ", "figure", ".", "add_subplot", "(", "num_rows", ",", "num_cols", ",", "(", "x", "+", "1", ")", "+", "(", "y", "*", "num_cols", ")", ")", "\n", "plt", ".", "axis", "(", "'off'", ")", "\n", "\n", "if", "num_channels", "==", "1", ":", "\n", "        ", "plt", ".", "imshow", "(", "data", "[", "x", ",", "y", ",", ":", ",", ":", ",", "0", "]", ",", "cmap", "=", "'gray'", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "imshow", "(", "data", "[", "x", ",", "y", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "\n", "# Draw the plot and return", "\n", "", "", "", "plt", ".", "show", "(", ")", "\n", "return", "figure", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.pyplot_image.get_logits_over_interval": [[84, 138], ["numpy.expand_dims", "tf.placeholder", "FastGradientMethod", "FastGradientMethod.generate", "tf.nn.l2_normalize", "tf.reshape", "model.get_logits", "ValueError", "tf.lin_space", "sess.as_default", "sess.run", "float", "float"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.attacks.spatial_transformation_method.SpatialTransformationMethod.generate", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_logits"], ["", "def", "get_logits_over_interval", "(", "sess", ",", "model", ",", "x_data", ",", "fgsm_params", ",", "\n", "min_epsilon", "=", "-", "10.", ",", "max_epsilon", "=", "10.", ",", "\n", "num_points", "=", "21", ")", ":", "\n", "  ", "\"\"\"Get logits when the input is perturbed in an interval in adv direction.\n\n  Args:\n      sess: Tf session\n      model: Model for which we wish to get logits.\n      x_data: Numpy array corresponding to single data.\n              point of shape [height, width, channels].\n      fgsm_params: Parameters for generating adversarial examples.\n      min_epsilon: Minimum value of epsilon over the interval.\n      max_epsilon: Maximum value of epsilon over the interval.\n      num_points: Number of points used to interpolate.\n\n  Returns:\n      Numpy array containing logits.\n\n  Raises:\n      ValueError if min_epsilon is larger than max_epsilon.\n  \"\"\"", "\n", "# Get the height, width and number of channels", "\n", "height", "=", "x_data", ".", "shape", "[", "0", "]", "\n", "width", "=", "x_data", ".", "shape", "[", "1", "]", "\n", "channels", "=", "x_data", ".", "shape", "[", "2", "]", "\n", "\n", "x_data", "=", "np", ".", "expand_dims", "(", "x_data", ",", "axis", "=", "0", ")", "\n", "import", "tensorflow", "as", "tf", "\n", "from", "cleverhans", ".", "attacks", "import", "FastGradientMethod", "\n", "\n", "# Define the data placeholder", "\n", "x", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "\n", "shape", "=", "[", "1", ",", "height", ",", "\n", "width", ",", "\n", "channels", "]", ",", "\n", "name", "=", "'x'", ")", "\n", "# Define adv_x", "\n", "fgsm", "=", "FastGradientMethod", "(", "model", ",", "sess", "=", "sess", ")", "\n", "adv_x", "=", "fgsm", ".", "generate", "(", "x", ",", "**", "fgsm_params", ")", "\n", "\n", "if", "min_epsilon", ">", "max_epsilon", ":", "\n", "    ", "raise", "ValueError", "(", "'Minimum epsilon is less than maximum epsilon'", ")", "\n", "\n", "", "eta", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "adv_x", "-", "x", ",", "dim", "=", "0", ")", "\n", "epsilon", "=", "tf", ".", "reshape", "(", "tf", ".", "lin_space", "(", "float", "(", "min_epsilon", ")", ",", "\n", "float", "(", "max_epsilon", ")", ",", "\n", "num_points", ")", ",", "\n", "(", "num_points", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "lin_batch", "=", "x", "+", "epsilon", "*", "eta", "\n", "logits", "=", "model", ".", "get_logits", "(", "lin_batch", ")", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "    ", "log_prob_adv_array", "=", "sess", ".", "run", "(", "logits", ",", "\n", "feed_dict", "=", "{", "x", ":", "x_data", "}", ")", "\n", "", "return", "log_prob_adv_array", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.plot.pyplot_image.linear_extrapolation_plot": [[139, 183], ["matplotlib.use", "plt.figure", "plt.figure.canvas.set_window_title", "numpy.argmax", "plt.figure", "plt.xlabel", "plt.ylabel", "numpy.linspace", "plt.xlim", "six.moves.range", "plt.legend", "plt.show", "plt.figure.savefig", "plt.clf", "plt.plot"], "function", ["None"], ["", "def", "linear_extrapolation_plot", "(", "log_prob_adv_array", ",", "y", ",", "file_name", ",", "\n", "min_epsilon", "=", "-", "10", ",", "max_epsilon", "=", "10", ",", "\n", "num_points", "=", "21", ")", ":", "\n", "  ", "\"\"\"Generate linear extrapolation plot.\n\n  Args:\n      log_prob_adv_array: Numpy array containing log probabilities\n      y: Tf placeholder for the labels\n      file_name: Plot filename\n      min_epsilon: Minimum value of epsilon over the interval\n      max_epsilon: Maximum value of epsilon over the interval\n      num_points: Number of points used to interpolate\n  \"\"\"", "\n", "import", "matplotlib", "\n", "matplotlib", ".", "use", "(", "'Agg'", ")", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "figure", "=", "plt", ".", "figure", "(", ")", "\n", "figure", ".", "canvas", ".", "set_window_title", "(", "'Cleverhans: Linear Extrapolation Plot'", ")", "\n", "\n", "correct_idx", "=", "np", ".", "argmax", "(", "y", ",", "axis", "=", "0", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "xlabel", "(", "'Epsilon'", ")", "\n", "plt", ".", "ylabel", "(", "'Logits'", ")", "\n", "x_axis", "=", "np", ".", "linspace", "(", "min_epsilon", ",", "max_epsilon", ",", "num_points", ")", "\n", "plt", ".", "xlim", "(", "min_epsilon", "-", "1", ",", "max_epsilon", "+", "1", ")", "\n", "for", "i", "in", "range", "(", "y", ".", "shape", "[", "0", "]", ")", ":", "\n", "    ", "if", "i", "==", "correct_idx", ":", "\n", "      ", "ls", "=", "'-'", "\n", "linewidth", "=", "5", "\n", "", "else", ":", "\n", "      ", "ls", "=", "'--'", "\n", "linewidth", "=", "2", "\n", "", "plt", ".", "plot", "(", "\n", "x_axis", ",", "\n", "log_prob_adv_array", "[", ":", ",", "i", "]", ",", "\n", "ls", "=", "ls", ",", "\n", "linewidth", "=", "linewidth", ",", "\n", "label", "=", "'{}'", ".", "format", "(", "i", ")", ")", "\n", "", "plt", ".", "legend", "(", "loc", "=", "'best'", ",", "fontsize", "=", "14", ")", "\n", "plt", ".", "show", "(", ")", "\n", "fig", ".", "savefig", "(", "file_name", ")", "\n", "plt", ".", "clf", "(", ")", "\n", "return", "figure", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.model_zoo.all_convolutional.ModelAllConvolutional.__init__": [[12, 22], ["cleverhans.model.Model.__init__", "all_convolutional.ModelAllConvolutional.fprop", "all_convolutional.ModelAllConvolutional.get_params", "locals", "tensorflow.placeholder"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.model.Model.get_params"], ["  ", "def", "__init__", "(", "self", ",", "scope", ",", "nb_classes", ",", "nb_filters", ",", "input_shape", ",", "**", "kwargs", ")", ":", "\n", "    ", "del", "kwargs", "\n", "Model", ".", "__init__", "(", "self", ",", "scope", ",", "nb_classes", ",", "locals", "(", ")", ")", "\n", "self", ".", "nb_filters", "=", "nb_filters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "\n", "# Do a dummy run of fprop to create the variables from the start", "\n", "self", ".", "fprop", "(", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "32", "]", "+", "input_shape", ")", ")", "\n", "# Put a reference to the params in self so that the params get pickled", "\n", "self", ".", "params", "=", "self", ".", "get_params", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.model_zoo.all_convolutional.ModelAllConvolutional.fprop": [[23, 43], ["dict", "tensorflow.variable_scope", "int", "range", "tensorflow.layers.conv2d", "tensorflow.reduce_mean", "round", "tensorflow.layers.conv2d", "tensorflow.layers.conv2d", "tensorflow.layers.average_pooling2d", "tensorflow.nn.softmax", "math.log", "math.log"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "fprop", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "del", "kwargs", "\n", "conv_args", "=", "dict", "(", "\n", "activation", "=", "tf", ".", "nn", ".", "leaky_relu", ",", "\n", "kernel_initializer", "=", "initializers", ".", "HeReLuNormalInitializer", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "'same'", ")", "\n", "y", "=", "x", "\n", "\n", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "log_resolution", "=", "int", "(", "round", "(", "\n", "math", ".", "log", "(", "self", ".", "input_shape", "[", "0", "]", ")", "/", "math", ".", "log", "(", "2", ")", ")", ")", "\n", "for", "scale", "in", "range", "(", "log_resolution", "-", "2", ")", ":", "\n", "        ", "y", "=", "tf", ".", "layers", ".", "conv2d", "(", "y", ",", "self", ".", "nb_filters", "<<", "scale", ",", "**", "conv_args", ")", "\n", "y", "=", "tf", ".", "layers", ".", "conv2d", "(", "y", ",", "self", ".", "nb_filters", "<<", "(", "scale", "+", "1", ")", ",", "**", "conv_args", ")", "\n", "y", "=", "tf", ".", "layers", ".", "average_pooling2d", "(", "y", ",", "2", ",", "2", ")", "\n", "", "y", "=", "tf", ".", "layers", ".", "conv2d", "(", "y", ",", "self", ".", "nb_classes", ",", "**", "conv_args", ")", "\n", "logits", "=", "tf", ".", "reduce_mean", "(", "y", ",", "[", "1", ",", "2", "]", ")", "\n", "return", "{", "self", ".", "O_LOGITS", ":", "logits", ",", "\n", "self", ".", "O_PROBS", ":", "tf", ".", "nn", ".", "softmax", "(", "logits", "=", "logits", ")", "}", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape": [[21, 23], ["None"], "methods", ["None"], ["  ", "def", "get_output_shape", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "output_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.__init__": [[28, 55], ["cleverhans.serial.NoRefModel.__init__", "list", "list", "cifar10_model.ResNet.build", "list", "list", "tensorflow.trainable_variables", "tensorflow.global_variables", "tensorflow.trainable_variables", "tensorflow.global_variables", "tensorflow.variable_scope", "cifar10_model.ResNet.build"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.build", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.build"], ["def", "__init__", "(", "self", ",", "layers", ",", "input_shape", ",", "scope", "=", "None", ")", ":", "\n", "    ", "\"\"\"ResNet constructor.\n\n    :param layers: a list of layers in CleverHans format\n      each with set_input_shape() and fprop() methods.\n    :param input_shape: 4-tuple describing input shape (e.g None, 32, 32, 3)\n    :param scope: string name of scope for Variables\n      This works in two ways.\n      If scope is None, the variables are not put in a scope, and the\n      model is compatible with Saver.restore from the public downloads\n      for the CIFAR10 Challenge.\n      If the scope is a string, then Saver.restore won't work, but the\n      model functions as a picklable NoRefModels that finds its variables\n      based on the scope.\n    \"\"\"", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", "scope", ",", "10", ",", "{", "}", ",", "scope", "is", "not", "None", ")", "\n", "if", "scope", "is", "None", ":", "\n", "      ", "before", "=", "list", "(", "tf", ".", "trainable_variables", "(", ")", ")", "\n", "before_vars", "=", "list", "(", "tf", ".", "global_variables", "(", ")", ")", "\n", "self", ".", "build", "(", "layers", ",", "input_shape", ")", "\n", "after", "=", "list", "(", "tf", ".", "trainable_variables", "(", ")", ")", "\n", "after_vars", "=", "list", "(", "tf", ".", "global_variables", "(", ")", ")", "\n", "self", ".", "params", "=", "[", "param", "for", "param", "in", "after", "if", "param", "not", "in", "before", "]", "\n", "self", ".", "vars", "=", "[", "var", "for", "var", "in", "after_vars", "if", "var", "not", "in", "before_vars", "]", "\n", "", "else", ":", "\n", "      ", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ")", ":", "\n", "        ", "self", ".", "build", "(", "layers", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars": [[56, 60], ["hasattr", "super().get_vars"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars"], ["", "", "", "def", "get_vars", "(", "self", ")", ":", "\n", "    ", "if", "hasattr", "(", "self", ",", "\"vars\"", ")", ":", "\n", "      ", "return", "self", ".", "vars", "\n", "", "return", "super", "(", "ResNet", ",", "self", ")", ".", "get_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.build": [[61, 80], ["isinstance", "enumerate", "hasattr", "cifar10_model.ResNet.layer_names.append", "layer.set_input_shape", "layer.get_output_shape", "str"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Layer.get_output_shape"], ["", "def", "build", "(", "self", ",", "layers", ",", "input_shape", ")", ":", "\n", "      ", "self", ".", "layer_names", "=", "[", "]", "\n", "self", ".", "layers", "=", "layers", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "if", "isinstance", "(", "layers", "[", "-", "1", "]", ",", "Softmax", ")", ":", "\n", "        ", "layers", "[", "-", "1", "]", ".", "name", "=", "'probs'", "\n", "layers", "[", "-", "2", "]", ".", "name", "=", "'logits'", "\n", "", "else", ":", "\n", "        ", "layers", "[", "-", "1", "]", ".", "name", "=", "'logits'", "\n", "", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "        ", "if", "hasattr", "(", "layer", ",", "'name'", ")", ":", "\n", "          ", "name", "=", "layer", ".", "name", "\n", "", "else", ":", "\n", "          ", "name", "=", "layer", ".", "__class__", ".", "__name__", "+", "str", "(", "i", ")", "\n", "layer", ".", "name", "=", "name", "\n", "", "self", ".", "layer_names", ".", "append", "(", "name", ")", "\n", "\n", "layer", ".", "set_input_shape", "(", "input_shape", ")", "\n", "input_shape", "=", "layer", ".", "get_output_shape", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_input_placeholder": [[81, 83], ["tensorflow.placeholder"], "methods", ["None"], ["", "", "def", "make_input_placeholder", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "(", "None", ",", "32", ",", "32", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.make_label_placeholder": [[84, 86], ["tensorflow.placeholder"], "methods", ["None"], ["", "def", "make_label_placeholder", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "(", "None", ",", "10", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.fprop": [[87, 92], ["cifar10_model.ResNet._prop", "tensorflow.variable_scope", "cifar10_model.ResNet._fprop"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet._fprop"], ["", "def", "fprop", "(", "self", ",", "x", ",", "set_ref", "=", "False", ")", ":", "\n", "    ", "if", "self", ".", "scope", "is", "not", "None", ":", "\n", "      ", "with", "tf", ".", "variable_scope", "(", "self", ".", "scope", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "return", "self", ".", "_fprop", "(", "x", ",", "set_ref", ")", "\n", "", "", "return", "self", ".", "_prop", "(", "x", ",", "set_ref", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet._fprop": [[93, 103], ["dict", "layer.fprop", "dict.append", "zip"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "_fprop", "(", "self", ",", "x", ",", "set_ref", "=", "False", ")", ":", "\n", "      ", "states", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "        ", "if", "set_ref", ":", "\n", "          ", "layer", ".", "ref", "=", "x", "\n", "", "x", "=", "layer", ".", "fprop", "(", "x", ")", "\n", "assert", "x", "is", "not", "None", "\n", "states", ".", "append", "(", "x", ")", "\n", "", "states", "=", "dict", "(", "zip", "(", "self", ".", "layer_names", ",", "states", ")", ")", "\n", "return", "states", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.add_internal_summaries": [[104, 106], ["None"], "methods", ["None"], ["", "def", "add_internal_summaries", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Input.__init__": [[115, 117], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Input.set_input_shape": [[118, 129], ["list", "tensorflow.zeros", "cifar10_model.Input.fprop", "tuple", "int", "cifar10_model.Input.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "set_input_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "batch_size", ",", "rows", ",", "cols", ",", "input_channels", "=", "input_shape", "\n", "# assert self.mode == 'train' or self.mode == 'eval'", "\n", "\"\"\"Build the core model within the graph.\"\"\"", "\n", "input_shape", "=", "list", "(", "input_shape", ")", "\n", "input_shape", "[", "0", "]", "=", "1", "\n", "dummy_batch", "=", "tf", ".", "zeros", "(", "input_shape", ")", "\n", "dummy_output", "=", "self", ".", "fprop", "(", "dummy_batch", ")", "\n", "output_shape", "=", "[", "int", "(", "e", ")", "for", "e", "in", "dummy_output", ".", "get_shape", "(", ")", "]", "\n", "output_shape", "[", "0", "]", "=", "batch_size", "\n", "self", ".", "output_shape", "=", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Input.fprop": [[130, 136], ["tensorflow.variable_scope", "tensorflow.map_fn", "cifar10_model._conv", "cifar10_model._stride_arr", "tensorflow.image.per_image_standardization"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._conv", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "'input'", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "input_standardized", "=", "tf", ".", "map_fn", "(", "\n", "lambda", "img", ":", "tf", ".", "image", ".", "per_image_standardization", "(", "img", ")", ",", "x", ")", "\n", "return", "_conv", "(", "'init_conv'", ",", "input_standardized", ",", "\n", "3", ",", "3", ",", "16", ",", "_stride_arr", "(", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Conv2D.__init__": [[140, 142], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Conv2D.set_input_shape": [[143, 157], ["list", "tensorflow.zeros", "cifar10_model.Conv2D.fprop", "tuple", "int", "cifar10_model.Conv2D.get_shape"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop"], ["", "def", "set_input_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "batch_size", ",", "rows", ",", "cols", ",", "input_channels", "=", "input_shape", "\n", "\n", "# Uncomment the following codes to use w28-10 wide residual network.", "\n", "# It is more memory efficient than very deep residual network and has", "\n", "# comparably good performance.", "\n", "# https://arxiv.org/pdf/1605.07146v1.pdf", "\n", "input_shape", "=", "list", "(", "input_shape", ")", "\n", "input_shape", "[", "0", "]", "=", "1", "\n", "dummy_batch", "=", "tf", ".", "zeros", "(", "input_shape", ")", "\n", "dummy_output", "=", "self", ".", "fprop", "(", "dummy_batch", ")", "\n", "output_shape", "=", "[", "int", "(", "e", ")", "for", "e", "in", "dummy_output", ".", "get_shape", "(", ")", "]", "\n", "output_shape", "[", "0", "]", "=", "batch_size", "\n", "self", ".", "output_shape", "=", "tuple", "(", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Conv2D.fprop": [[158, 195], ["range", "range", "range", "tensorflow.variable_scope", "res_func", "tensorflow.variable_scope", "res_func", "tensorflow.variable_scope", "res_func", "tensorflow.variable_scope", "cifar10_model._batch_norm", "cifar10_model._relu", "cifar10_model._global_avg_pool", "cifar10_model._stride_arr", "tensorflow.variable_scope", "res_func", "cifar10_model._stride_arr", "tensorflow.variable_scope", "res_func", "cifar10_model._stride_arr", "tensorflow.variable_scope", "res_func", "cifar10_model._stride_arr", "cifar10_model._stride_arr", "cifar10_model._stride_arr"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._batch_norm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._relu", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._global_avg_pool", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "\n", "# Update hps.num_residual_units to 9", "\n", "    ", "strides", "=", "[", "1", ",", "2", ",", "2", "]", "\n", "activate_before_residual", "=", "[", "True", ",", "False", ",", "False", "]", "\n", "filters", "=", "[", "16", ",", "160", ",", "320", ",", "640", "]", "\n", "res_func", "=", "_residual", "\n", "with", "tf", ".", "variable_scope", "(", "'unit_1_0'", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "_stride_arr", "(", "strides", "[", "0", "]", ")", ",", "\n", "activate_before_residual", "[", "0", "]", ")", "\n", "", "for", "i", "in", "range", "(", "1", ",", "5", ")", ":", "\n", "      ", "with", "tf", ".", "variable_scope", "(", "(", "'unit_1_%d'", "%", "i", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "1", "]", ",", "filters", "[", "1", "]", ",", "\n", "_stride_arr", "(", "1", ")", ",", "False", ")", "\n", "\n", "", "", "with", "tf", ".", "variable_scope", "(", "(", "'unit_2_0'", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "_stride_arr", "(", "strides", "[", "1", "]", ")", ",", "\n", "activate_before_residual", "[", "1", "]", ")", "\n", "", "for", "i", "in", "range", "(", "1", ",", "5", ")", ":", "\n", "      ", "with", "tf", ".", "variable_scope", "(", "(", "'unit_2_%d'", "%", "i", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "2", "]", ",", "filters", "[", "2", "]", ",", "\n", "_stride_arr", "(", "1", ")", ",", "False", ")", "\n", "\n", "", "", "with", "tf", ".", "variable_scope", "(", "(", "'unit_3_0'", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "_stride_arr", "(", "strides", "[", "2", "]", ")", ",", "\n", "activate_before_residual", "[", "2", "]", ")", "\n", "", "for", "i", "in", "range", "(", "1", ",", "5", ")", ":", "\n", "      ", "with", "tf", ".", "variable_scope", "(", "(", "'unit_3_%d'", "%", "i", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "x", "=", "res_func", "(", "x", ",", "filters", "[", "3", "]", ",", "filters", "[", "3", "]", ",", "\n", "_stride_arr", "(", "1", ")", ",", "False", ")", "\n", "\n", "", "", "with", "tf", ".", "variable_scope", "(", "(", "'unit_last'", ")", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "x", "=", "_batch_norm", "(", "'final_bn'", ",", "x", ")", "\n", "x", "=", "_relu", "(", "x", ",", "0.1", ")", "\n", "x", "=", "_global_avg_pool", "(", "x", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.__init__": [[199, 201], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "num_hid", ")", ":", "\n", "    ", "self", ".", "num_hid", "=", "num_hid", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.set_input_shape": [[202, 208], ["cifar10_model.Linear.make_vars"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.make_vars"], ["", "def", "set_input_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "    ", "batch_size", ",", "dim", "=", "input_shape", "\n", "self", ".", "input_shape", "=", "[", "batch_size", ",", "dim", "]", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "output_shape", "=", "[", "batch_size", ",", "self", ".", "num_hid", "]", "\n", "self", ".", "make_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.make_vars": [[209, 218], ["tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.initializers.variance_scaling", "tensorflow.initializers.constant"], "methods", ["None"], ["", "def", "make_vars", "(", "self", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "'logit'", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "      ", "w", "=", "tf", ".", "get_variable", "(", "\n", "'DW'", ",", "[", "self", ".", "dim", ",", "self", ".", "num_hid", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "variance_scaling", "(", "\n", "distribution", "=", "'uniform'", ")", ")", "\n", "b", "=", "tf", ".", "get_variable", "(", "'biases'", ",", "[", "self", ".", "num_hid", "]", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "constant", "(", ")", ")", "\n", "", "return", "w", ",", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.fprop": [[219, 222], ["cifar10_model.Linear.make_vars", "tensorflow.nn.xw_plus_b"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Linear.make_vars"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "    ", "w", ",", "b", "=", "self", ".", "make_vars", "(", ")", "\n", "return", "tf", ".", "nn", ".", "xw_plus_b", "(", "x", ",", "w", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Softmax.__init__": [[304, 306], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Softmax.set_input_shape": [[307, 310], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "self", ".", "output_shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Softmax.fprop": [[311, 313], ["tensorflow.nn.softmax"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "    ", "return", "tf", ".", "nn", ".", "softmax", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.__init__": [[317, 319], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.set_input_shape": [[320, 327], ["None"], "methods", ["None"], ["", "def", "set_input_shape", "(", "self", ",", "shape", ")", ":", "\n", "    ", "self", ".", "input_shape", "=", "shape", "\n", "output_width", "=", "1", "\n", "for", "factor", "in", "shape", "[", "1", ":", "]", ":", "\n", "      ", "output_width", "*=", "factor", "\n", "", "self", ".", "output_width", "=", "output_width", "\n", "self", ".", "output_shape", "=", "[", "None", ",", "output_width", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.Flatten.fprop": [[328, 330], ["tensorflow.reshape"], "methods", ["None"], ["", "def", "fprop", "(", "self", ",", "x", ")", ":", "\n", "    ", "return", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "self", ".", "output_width", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._stride_arr": [[108, 111], ["None"], "function", ["None"], ["", "", "def", "_stride_arr", "(", "stride", ")", ":", "\n", "  ", "\"\"\"Map a stride scalar to the stride array for tf.nn.conv2d.\"\"\"", "\n", "return", "[", "1", ",", "stride", ",", "stride", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._batch_norm": [[224, 235], ["tensorflow.name_scope", "tensorflow.contrib.layers.batch_norm"], "function", ["None"], ["", "", "def", "_batch_norm", "(", "name", ",", "x", ")", ":", "\n", "  ", "\"\"\"Batch normalization.\"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "name", ")", ":", "\n", "    ", "return", "tf", ".", "contrib", ".", "layers", ".", "batch_norm", "(", "\n", "inputs", "=", "x", ",", "\n", "decay", "=", ".9", ",", "\n", "center", "=", "True", ",", "\n", "scale", "=", "True", ",", "\n", "activation_fn", "=", "None", ",", "\n", "updates_collections", "=", "None", ",", "\n", "is_training", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._residual": [[237, 270], ["tensorflow.logging.debug", "tensorflow.variable_scope", "cifar10_model._conv", "tensorflow.variable_scope", "cifar10_model._batch_norm", "cifar10_model._relu", "cifar10_model._conv", "tensorflow.variable_scope", "_relu.get_shape", "tensorflow.variable_scope", "cifar10_model._batch_norm", "cifar10_model._relu", "tensorflow.variable_scope", "cifar10_model._batch_norm", "cifar10_model._relu", "tensorflow.nn.avg_pool", "tensorflow.pad"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._conv", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._batch_norm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._relu", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._conv", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._batch_norm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._relu", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._batch_norm", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._relu"], ["", "", "def", "_residual", "(", "x", ",", "in_filter", ",", "out_filter", ",", "stride", ",", "\n", "activate_before_residual", "=", "False", ")", ":", "\n", "  ", "\"\"\"Residual unit with 2 sub layers.\"\"\"", "\n", "if", "activate_before_residual", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "'shared_activation'", ")", ":", "\n", "      ", "x", "=", "_batch_norm", "(", "'init_bn'", ",", "x", ")", "\n", "x", "=", "_relu", "(", "x", ",", "0.1", ")", "\n", "orig_x", "=", "x", "\n", "", "", "else", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "'residual_only_activation'", ")", ":", "\n", "      ", "orig_x", "=", "x", "\n", "x", "=", "_batch_norm", "(", "'init_bn'", ",", "x", ")", "\n", "x", "=", "_relu", "(", "x", ",", "0.1", ")", "\n", "\n", "", "", "with", "tf", ".", "variable_scope", "(", "'sub1'", ")", ":", "\n", "    ", "x", "=", "_conv", "(", "'conv1'", ",", "x", ",", "3", ",", "in_filter", ",", "out_filter", ",", "stride", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "'sub2'", ")", ":", "\n", "    ", "x", "=", "_batch_norm", "(", "'bn2'", ",", "x", ")", "\n", "x", "=", "_relu", "(", "x", ",", "0.1", ")", "\n", "x", "=", "_conv", "(", "'conv2'", ",", "x", ",", "3", ",", "out_filter", ",", "out_filter", ",", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "'sub_add'", ")", ":", "\n", "    ", "if", "in_filter", "!=", "out_filter", ":", "\n", "      ", "orig_x", "=", "tf", ".", "nn", ".", "avg_pool", "(", "orig_x", ",", "stride", ",", "stride", ",", "'VALID'", ")", "\n", "orig_x", "=", "tf", ".", "pad", "(", "\n", "orig_x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", "]", ",", "[", "(", "out_filter", "-", "in_filter", ")", "//", "2", ",", "\n", "(", "out_filter", "-", "in_filter", ")", "//", "2", "]", "]", ")", "\n", "", "x", "+=", "orig_x", "\n", "\n", "", "tf", ".", "logging", ".", "debug", "(", "'image after unit %s'", ",", "x", ".", "get_shape", "(", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._decay": [[272, 279], ["tensorflow.trainable_variables", "tensorflow.add_n", "var.op.name.find", "costs.append", "tensorflow.nn.l2_loss"], "function", ["None"], ["", "def", "_decay", "(", ")", ":", "\n", "  ", "\"\"\"L2 weight decay loss.\"\"\"", "\n", "costs", "=", "[", "]", "\n", "for", "var", "in", "tf", ".", "trainable_variables", "(", ")", ":", "\n", "    ", "if", "var", ".", "op", ".", "name", ".", "find", "(", "'DW'", ")", ">", "0", ":", "\n", "      ", "costs", ".", "append", "(", "tf", ".", "nn", ".", "l2_loss", "(", "var", ")", ")", "\n", "", "", "return", "tf", ".", "add_n", "(", "costs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._conv": [[281, 290], ["tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.nn.conv2d", "tensorflow.random_normal_initializer", "numpy.sqrt"], "function", ["None"], ["", "def", "_conv", "(", "name", ",", "x", ",", "filter_size", ",", "in_filters", ",", "out_filters", ",", "strides", ")", ":", "\n", "  ", "\"\"\"Convolution.\"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "    ", "n", "=", "filter_size", "*", "filter_size", "*", "out_filters", "\n", "kernel", "=", "tf", ".", "get_variable", "(", "\n", "'DW'", ",", "[", "filter_size", ",", "filter_size", ",", "in_filters", ",", "out_filters", "]", ",", "\n", "tf", ".", "float32", ",", "initializer", "=", "tf", ".", "random_normal_initializer", "(", "\n", "stddev", "=", "np", ".", "sqrt", "(", "2.0", "/", "n", ")", ")", ")", "\n", "return", "tf", ".", "nn", ".", "conv2d", "(", "x", ",", "kernel", ",", "strides", ",", "padding", "=", "'SAME'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._relu": [[292, 295], ["tensorflow.where", "tensorflow.less"], "function", ["None"], ["", "", "def", "_relu", "(", "x", ",", "leakiness", "=", "0.0", ")", ":", "\n", "  ", "\"\"\"Relu, with optional leaky support.\"\"\"", "\n", "return", "tf", ".", "where", "(", "tf", ".", "less", "(", "x", ",", "0.0", ")", ",", "leakiness", "*", "x", ",", "x", ",", "name", "=", "'leaky_relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model._global_avg_pool": [[297, 300], ["tensorflow.reduce_mean", "x.get_shape"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.compat.reduce_mean"], ["", "def", "_global_avg_pool", "(", "x", ")", ":", "\n", "  ", "assert", "x", ".", "get_shape", "(", ")", ".", "ndims", "==", "4", "\n", "return", "tf", ".", "reduce_mean", "(", "x", ",", "[", "1", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.make_wresnet": [[332, 341], ["cifar10_model.ResNet", "cifar10_model.Input", "cifar10_model.Conv2D", "cifar10_model.Flatten", "cifar10_model.Linear", "cifar10_model.Softmax"], "function", ["None"], ["", "", "def", "make_wresnet", "(", "nb_classes", "=", "10", ",", "input_shape", "=", "(", "None", ",", "32", ",", "32", ",", "3", ")", ",", "scope", "=", "None", ")", ":", "\n", "  ", "layers", "=", "[", "Input", "(", ")", ",", "\n", "Conv2D", "(", ")", ",", "# the whole ResNet is basically created in this layer", "\n", "Flatten", "(", ")", ",", "\n", "Linear", "(", "nb_classes", ")", ",", "\n", "Softmax", "(", ")", "]", "\n", "\n", "model", "=", "ResNet", "(", "layers", ",", "input_shape", ",", "scope", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.make_cifar10_joblib.main": [[27, 63], ["tensorflow.train.latest_checkpoint", "cleverhans.utils.set_log_level", "tensorflow.Session", "print", "sys.exit", "tf.Session.as_default", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet", "tensorflow.train.Saver", "tf.train.Saver.restore", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet.get_vars", "all", "cleverhans.dataset.Factory", "cleverhans.serial.save", "len", "len", "len", "enumerate", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet.get_vars", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet.get_vars", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet.get_vars", "cleverhans.model_zoo.madry_lab_challenges.cifar10_model.make_wresnet.get_vars", "tf.Session.run", "tensorflow.assign"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.set_log_level", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.make_wresnet", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.make_wresnet", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.serial.save", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.madry_lab_challenges.cifar10_model.ResNet.get_vars"], ["def", "main", "(", "argv", ")", ":", "\n", "\n", "  ", "model_file", "=", "tf", ".", "train", ".", "latest_checkpoint", "(", "FLAGS", ".", "checkpoint_dir", ")", "\n", "\n", "if", "model_file", "is", "None", ":", "\n", "    ", "print", "(", "'No model found'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "set_log_level", "(", "logging", ".", "DEBUG", ")", "\n", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "with", "sess", ".", "as_default", "(", ")", ":", "\n", "\n", "    ", "model", "=", "make_wresnet", "(", ")", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "# Restore the checkpoint", "\n", "saver", ".", "restore", "(", "sess", ",", "model_file", ")", "\n", "SCOPE", "=", "\"cifar10_challenge\"", "\n", "model2", "=", "make_wresnet", "(", "scope", "=", "SCOPE", ")", "\n", "assert", "len", "(", "model", ".", "get_vars", "(", ")", ")", "==", "len", "(", "model2", ".", "get_vars", "(", ")", ")", "\n", "found", "=", "[", "False", "]", "*", "len", "(", "model2", ".", "get_vars", "(", ")", ")", "\n", "for", "var1", "in", "model", ".", "get_vars", "(", ")", ":", "\n", "      ", "var1_found", "=", "False", "\n", "var2_name", "=", "SCOPE", "+", "\"/\"", "+", "var1", ".", "name", "\n", "for", "idx", ",", "var2", "in", "enumerate", "(", "model2", ".", "get_vars", "(", ")", ")", ":", "\n", "        ", "if", "var2", ".", "name", "==", "var2_name", ":", "\n", "          ", "var1_found", "=", "True", "\n", "found", "[", "idx", "]", "=", "True", "\n", "sess", ".", "run", "(", "tf", ".", "assign", "(", "var2", ",", "var1", ")", ")", "\n", "break", "\n", "", "", "assert", "var1_found", ",", "var1", ".", "name", "\n", "", "assert", "all", "(", "found", ")", "\n", "\n", "model2", ".", "dataset_factory", "=", "Factory", "(", "CIFAR10", ",", "{", "\"max_val\"", ":", "255", "}", ")", "\n", "\n", "serial", ".", "save", "(", "\"model.joblib\"", ",", "model2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files.list_files": [[6, 39], ["os.path.abspath", "os.path.abspath", "list_files._list_files", "os.path.isdir", "os.path.join", "os.path.join", "os.path.isdir", "list_files._list_files", "os.path.join"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files._list_files", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files._list_files"], ["def", "list_files", "(", "suffix", "=", "\"\"", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of all files in CleverHans with the given suffix.\n\n  Parameters\n  ----------\n  suffix : str\n\n  Returns\n  -------\n\n  file_list : list\n      A list of all files in CleverHans whose filepath ends with `suffix`.\n  \"\"\"", "\n", "\n", "cleverhans_path", "=", "os", ".", "path", ".", "abspath", "(", "cleverhans", ".", "__path__", "[", "0", "]", ")", "\n", "# In some environments cleverhans_path does not point to a real directory.", "\n", "# In such case return empty list.", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "cleverhans_path", ")", ":", "\n", "    ", "return", "[", "]", "\n", "", "repo_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "cleverhans_path", ",", "os", ".", "pardir", ")", ")", "\n", "file_list", "=", "_list_files", "(", "cleverhans_path", ",", "suffix", ")", "\n", "\n", "extra_dirs", "=", "[", "'cleverhans_tutorials'", ",", "'examples'", ",", "'scripts'", ",", "'tests_tf'", ",", "'tests_pytorch'", "]", "\n", "\n", "for", "extra_dir", "in", "extra_dirs", ":", "\n", "    ", "extra_path", "=", "os", ".", "path", ".", "join", "(", "repo_path", ",", "extra_dir", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "extra_path", ")", ":", "\n", "      ", "extra_files", "=", "_list_files", "(", "extra_path", ",", "suffix", ")", "\n", "extra_files", "=", "[", "os", ".", "path", ".", "join", "(", "os", ".", "pardir", ",", "path", ")", "for", "path", "in", "extra_files", "]", "\n", "file_list", "=", "file_list", "+", "extra_files", "\n", "\n", "", "", "return", "file_list", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files._list_files": [[41, 72], ["os.path.isdir", "os.listdir", "os.path.exists", "path.endswith", "os.path.join", "list_files._list_files", "flattened.append"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files._list_files"], ["", "def", "_list_files", "(", "path", ",", "suffix", "=", "\"\"", ")", ":", "\n", "  ", "\"\"\"\n  Returns a list of all files ending in `suffix` contained within `path`.\n\n  Parameters\n  ----------\n  path : str\n      a filepath\n  suffix : str\n\n  Returns\n  -------\n  l : list\n      A list of all files ending in `suffix` contained within `path`.\n      (If `path` is a file rather than a directory, it is considered\n      to \"contain\" itself)\n  \"\"\"", "\n", "if", "os", ".", "path", ".", "isdir", "(", "path", ")", ":", "\n", "    ", "incomplete", "=", "os", ".", "listdir", "(", "path", ")", "\n", "complete", "=", "[", "os", ".", "path", ".", "join", "(", "path", ",", "entry", ")", "for", "entry", "in", "incomplete", "]", "\n", "lists", "=", "[", "_list_files", "(", "subpath", ",", "suffix", ")", "for", "subpath", "in", "complete", "]", "\n", "flattened", "=", "[", "]", "\n", "for", "one_list", "in", "lists", ":", "\n", "      ", "for", "elem", "in", "one_list", ":", "\n", "        ", "flattened", ".", "append", "(", "elem", ")", "\n", "", "", "return", "flattened", "\n", "", "else", ":", "\n", "    ", "assert", "os", ".", "path", ".", "exists", "(", "path", ")", ",", "\"couldn't find file '%s'\"", "%", "path", "\n", "if", "path", ".", "endswith", "(", "suffix", ")", ":", "\n", "      ", "return", "[", "path", "]", "\n", "", "return", "[", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__": [[40, 66], ["copy.copy", "cleverhans.dataset.Dataset.__init__", "mocks.SimpleDataset.__dict__.update", "numpy.random.RandomState", "numpy.random.RandomState", "numpy.random.RandomState", "numpy.random.RandomState", "cleverhans.dataset.np_utils.to_categorical", "cleverhans.dataset.np_utils.to_categorical", "locals", "numpy.random.RandomState.uniform", "numpy.random.RandomState.uniform", "numpy.random.RandomState.randint", "numpy.random.RandomState.randint"], "methods", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.SimpleDataset.__init__", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical", "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.cleverhans.utils.to_categorical"], ["def", "__init__", "(", "self", ",", "dim", "=", "2", ",", "train_start", "=", "0", ",", "train_end", "=", "3", ",", "test_start", "=", "0", ",", "test_end", "=", "5", ",", "center", "=", "False", ",", "max_val", "=", "1.", ",", "\n", "nb_classes", "=", "5", ")", ":", "\n", "    ", "kwargs", "=", "copy", ".", "copy", "(", "locals", "(", ")", ")", "\n", "del", "kwargs", "[", "'self'", "]", "\n", "if", "\"__class__\"", "in", "kwargs", ":", "\n", "      ", "del", "kwargs", "[", "\"__class__\"", "]", "\n", "", "super", "(", "SimpleDataset", ",", "self", ")", ".", "__init__", "(", "kwargs", ")", "\n", "self", ".", "__dict__", ".", "update", "(", "kwargs", ")", "\n", "train_x_rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "11", ",", "9", ",", "1", "]", ")", "\n", "# Even if train_start is not 0, we should still generate the first training examples from the rng.", "\n", "# This way the dataset looks like it is an array of deterministic data that we index using train_start.", "\n", "self", ".", "x_train", "=", "train_x_rng", ".", "uniform", "(", "-", "center", "*", "max_val", ",", "max_val", ",", "(", "train_end", ",", "dim", ")", ")", "[", "train_start", ":", "]", "\n", "# Use a second rng for the test set so that it also looks like an array of deterministic data that we", "\n", "# index into, unaffected by the number of training examples.", "\n", "test_x_rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "11", ",", "9", ",", "2", "]", ")", "\n", "self", ".", "x_test", "=", "test_x_rng", ".", "uniform", "(", "-", "center", "*", "max_val", ",", "max_val", ",", "(", "test_end", ",", "dim", ")", ")", "[", "test_start", ":", "]", "\n", "# Likewise, to keep the number of examples read from the rng affecting the values of the labels, we", "\n", "# must generate the labels from a different rng", "\n", "train_y_rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "11", ",", "9", ",", "3", "]", ")", "\n", "self", ".", "y_train", "=", "train_y_rng", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "nb_classes", ",", "size", "=", "(", "train_end", ",", "1", ")", ")", "[", "train_start", ":", "]", "\n", "test_y_rng", "=", "np", ".", "random", ".", "RandomState", "(", "[", "2018", ",", "11", ",", "9", ",", "4", "]", ")", "\n", "self", ".", "y_test", "=", "test_y_rng", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "nb_classes", ",", "size", "=", "(", "test_end", ",", "1", ")", ")", "[", "test_start", ":", "]", "\n", "assert", "self", ".", "x_train", ".", "shape", "[", "0", "]", "==", "self", ".", "y_train", ".", "shape", "[", "0", "]", "\n", "assert", "self", ".", "x_test", ".", "shape", "[", "0", "]", "==", "self", ".", "y_test", ".", "shape", "[", "0", "]", "\n", "self", ".", "y_train", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "y_train", ",", "nb_classes", ")", "\n", "self", ".", "y_test", "=", "np_utils", ".", "to_categorical", "(", "self", ".", "y_test", ",", "nb_classes", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.mocks.random_feed_dict": [[16, 33], ["rng.randn().astype", "NotImplementedError", "rng.randn"], "function", ["None"], ["def", "random_feed_dict", "(", "rng", ",", "placeholders", ")", ":", "\n", "  ", "\"\"\"\n  Returns random data to be used with `feed_dict`.\n  :param rng: A numpy.random.RandomState instance\n  :param placeholders: List of tensorflow placeholders\n  :return: A dict mapping placeholders to random numpy values\n  \"\"\"", "\n", "\n", "output", "=", "{", "}", "\n", "\n", "for", "placeholder", "in", "placeholders", ":", "\n", "    ", "if", "placeholder", ".", "dtype", "!=", "'float32'", ":", "\n", "      ", "raise", "NotImplementedError", "(", ")", "\n", "", "value", "=", "rng", ".", "randn", "(", "*", "placeholder", ".", "shape", ")", ".", "astype", "(", "'float32'", ")", "\n", "output", "[", "placeholder", "]", "=", "value", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.checks.CleverHansTest.setUp": [[18, 22], ["time.time", "numpy.random.seed"], "methods", ["None"], ["  ", "def", "setUp", "(", "self", ")", ":", "\n", "    ", "self", ".", "test_start", "=", "time", ".", "time", "(", ")", "\n", "# seed the randomness", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.checks.CleverHansTest.tearDown": [[23, 25], ["print", "checks.CleverHansTest.id", "time.time"], "methods", ["None"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "    ", "print", "(", "self", ".", "id", "(", ")", ",", "\"took\"", ",", "time", ".", "time", "(", ")", "-", "self", ".", "test_start", ",", "\"seconds\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.checks.CleverHansTest.assertClose": [[26, 30], ["numpy.allclose"], "methods", ["None"], ["", "def", "assertClose", "(", "self", ",", "x", ",", "y", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# self.assertTrue(np.allclose(x, y)) doesn't give a useful message", "\n", "# on failure", "\n", "    ", "assert", "np", ".", "allclose", "(", "x", ",", "y", ",", "*", "args", ",", "**", "kwargs", ")", ",", "(", "x", ",", "y", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.version.dev_version": [[11, 25], ["hashlib.md5", "sorted", "hashlib.md5.hexdigest", "cleverhans.devtools.list_files.list_files", "hashlib.md5.update", "open", "fobj.read"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.list_files.list_files"], ["def", "dev_version", "(", ")", ":", "\n", "  ", "\"\"\"\n  Returns a hexdigest of all the python files in the module.\n  \"\"\"", "\n", "\n", "md5_hash", "=", "hashlib", ".", "md5", "(", ")", "\n", "py_files", "=", "sorted", "(", "list_files", "(", "suffix", "=", "\".py\"", ")", ")", "\n", "if", "not", "py_files", ":", "\n", "    ", "return", "''", "\n", "", "for", "filename", "in", "py_files", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "fobj", ":", "\n", "      ", "content", "=", "fobj", ".", "read", "(", ")", "\n", "", "md5_hash", ".", "update", "(", "content", ")", "\n", "", "return", "md5_hash", ".", "hexdigest", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.version.append_dev_version": [[27, 37], ["version.dev_version"], "function", ["home.repos.pwc.inspect_result.jcperdomo_robust_attacks.devtools.version.dev_version"], ["", "def", "append_dev_version", "(", "release_version", ")", ":", "\n", "  ", "\"\"\"\n  If dev version is not empty appends it to release_version.\n  \"\"\"", "\n", "\n", "dev_version_value", "=", "dev_version", "(", ")", "\n", "if", "dev_version_value", ":", "\n", "    ", "return", "release_version", "+", "'-'", "+", "dev_version_value", "\n", "", "else", ":", "\n", "    ", "return", "release_version", "\n", "", "", ""]]}