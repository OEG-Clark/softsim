{"home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.__init__": [[41, 53], ["logger.error", "pipeline.Pipeline.ahn_reader.set_caching"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.set_caching"], ["def", "__init__", "(", "self", ",", "processors", "=", "[", "]", ",", "exclude_labels", "=", "[", "]", ",", "\n", "ahn_reader", "=", "None", ",", "caching", "=", "True", ")", ":", "\n", "        ", "if", "ahn_reader", "is", "None", "and", "caching", ":", "\n", "            ", "logger", ".", "error", "(", "\n", "'An ahn_reader must be specified when caching is enabled.'", ")", "\n", "raise", "ValueError", "\n", "", "self", ".", "processors", "=", "processors", "\n", "self", ".", "exclude_labels", "=", "exclude_labels", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "caching", "=", "caching", "\n", "if", "self", ".", "caching", ":", "\n", "            ", "self", ".", "ahn_reader", ".", "set_caching", "(", "self", ".", "caching", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline._create_mask": [[54, 62], ["numpy.ones", "len", "len"], "methods", ["None"], ["", "", "def", "_create_mask", "(", "self", ",", "mask", ",", "labels", ")", ":", "\n", "        ", "\"\"\"Create mask based on `exclude_labels`.\"\"\"", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "labels", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "", "if", "len", "(", "self", ".", "exclude_labels", ")", ">", "0", ":", "\n", "            ", "for", "exclude_label", "in", "self", ".", "exclude_labels", ":", "\n", "                ", "mask", "=", "mask", "&", "(", "labels", "!=", "exclude_label", ")", "\n", "", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.process_cloud": [[63, 98], ["pipeline.Pipeline._create_mask", "pipeline.Pipeline.ahn_reader.cache_interpolator", "time.time", "obj.get_label_mask", "obj.get_label", "logger.info", "time.time", "numpy.count_nonzero"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline._create_mask", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.cache_interpolator", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.get_label_mask", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.abstract_processor.AbstractProcessor.get_label"], ["", "def", "process_cloud", "(", "self", ",", "tilecode", ",", "points", ",", "labels", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Process a single point cloud.\n\n        Parameters\n        ----------\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points, 1)\n            All labels as int values\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=uint16 indicating the label\n        for each point.\n        \"\"\"", "\n", "mask", "=", "self", ".", "_create_mask", "(", "mask", ",", "labels", ")", "\n", "if", "self", ".", "caching", ":", "\n", "            ", "self", ".", "ahn_reader", ".", "cache_interpolator", "(", "\n", "tilecode", ",", "points", ",", "surface", "=", "'ground_surface'", ")", "\n", "\n", "", "for", "obj", "in", "self", ".", "processors", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "label_mask", "=", "obj", ".", "get_label_mask", "(", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", "\n", "labels", "[", "label_mask", "]", "=", "obj", ".", "get_label", "(", ")", "\n", "mask", "[", "label_mask", "]", "=", "False", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "logger", ".", "info", "(", "f'Processor finished in {duration:.2f}s, '", "+", "\n", "f'{np.count_nonzero(label_mask)} points labelled.'", ")", "\n", "\n", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.process_file": [[99, 139], ["logger.info", "time.time", "utils.las_utils.get_tilecode_from_filename", "utils.las_utils.read_las", "pipeline.Pipeline.process_cloud", "utils.las_utils.label_and_save_las", "analysis.analysis_tools.get_label_stats", "logger.info", "logger.info", "os.path.isfile", "logger.error", "numpy.vstack", "numpy.zeros", "time.time", "len"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.read_las", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.process_cloud", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.label_and_save_las", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.analysis.analysis_tools.get_label_stats"], ["", "def", "process_file", "(", "self", ",", "in_file", ",", "out_file", "=", "None", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Process a single LAS file and save the result as .laz file.\n\n        Parameters\n        ----------\n        in_file : str\n            The file to process.\n        out_file : str (default: None)\n            The name of the output file. If None, the input will be\n            overwritten.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        \"\"\"", "\n", "logger", ".", "info", "(", "f'Processing file {in_file}.'", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "in_file", ")", ":", "\n", "            ", "logger", ".", "error", "(", "'The input file specified does not exist'", ")", "\n", "return", "None", "\n", "\n", "", "if", "out_file", "is", "None", ":", "\n", "            ", "out_file", "=", "in_file", "\n", "\n", "", "tilecode", "=", "las_utils", ".", "get_tilecode_from_filename", "(", "in_file", ")", "\n", "pointcloud", "=", "las_utils", ".", "read_las", "(", "in_file", ")", "\n", "points", "=", "np", ".", "vstack", "(", "(", "pointcloud", ".", "x", ",", "pointcloud", ".", "y", ",", "pointcloud", ".", "z", ")", ")", ".", "T", "\n", "\n", "if", "'label'", "not", "in", "pointcloud", ".", "point_format", ".", "extra_dimension_names", ":", "\n", "            ", "labels", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "'uint16'", ")", "\n", "", "else", ":", "\n", "            ", "labels", "=", "pointcloud", ".", "label", "\n", "\n", "", "labels", "=", "self", ".", "process_cloud", "(", "tilecode", ",", "points", ",", "labels", ",", "mask", ")", "\n", "las_utils", ".", "label_and_save_las", "(", "pointcloud", ",", "labels", ",", "out_file", ")", "\n", "\n", "duration", "=", "time", ".", "time", "(", ")", "-", "start", "\n", "stats", "=", "analysis_tools", ".", "get_label_stats", "(", "labels", ")", "\n", "logger", ".", "info", "(", "'\\nSTATISTICS\\n'", "+", "stats", ")", "\n", "logger", ".", "info", "(", "f'File processed in {duration:.2f}s, '", "+", "\n", "f'output written to {out_file}.\\n'", "+", "'='", "*", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.process_folder": [[140, 197], ["logger.info", "tqdm.tqdm.tqdm", "logger.debug", "logger.info", "os.path.isdir", "logger.error", "type", "pathlib.Path", "pathlib.Path().mkdir", "tqdm.tqdm.tqdm.set_postfix_str", "os.path.splitext", "os.path.join", "pipeline.Pipeline.process_file", "pathlib.Path.glob", "filename.replace.replace.replace", "file.as_posix", "pathlib.Path", "f.name.endswith", "f.name.startswith", "len", "len"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.pipeline.Pipeline.process_file"], ["", "def", "process_folder", "(", "self", ",", "in_folder", ",", "out_folder", "=", "None", ",", "in_prefix", "=", "''", ",", "\n", "out_prefix", "=", "''", ",", "suffix", "=", "''", ",", "hide_progress", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Process a folder of LAS files and save each processed file.\n\n        Parameters\n        ----------\n        in_folder : str or Path\n           The input folder.\n        out_folder : str or Path (default: None)\n           The name of the output folder. If None, the output will be written\n           to the input folder.\n        in_prefix : str\n            Optional prefix to filter files in the input folder. Only files\n            starting with this prefix will be processed.\n        out_prefix : str\n            Optional prefix to prepend to output files. If an in_prefix is\n            given, it will be replaced by the out_prefix.\n        suffix : str or None\n            Suffix to add to the filename of processed files. A value of None\n            indicates that the same filename is kept; when out_folder=None this\n            means each file will be overwritten.\n        \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "in_folder", ")", ":", "\n", "            ", "logger", ".", "error", "(", "'The input path specified does not exist'", ")", "\n", "return", "None", "\n", "", "if", "type", "(", "in_folder", ")", "==", "str", ":", "\n", "            ", "in_folder", "=", "pathlib", ".", "Path", "(", "in_folder", ")", "\n", "", "if", "out_folder", "is", "None", ":", "\n", "            ", "out_folder", "=", "in_folder", "\n", "", "else", ":", "\n", "            ", "pathlib", ".", "Path", "(", "out_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "if", "suffix", "is", "None", ":", "\n", "            ", "suffix", "=", "''", "\n", "\n", "", "logger", ".", "info", "(", "'\\n===== PIPELINE =====\\n'", "+", "\n", "f'Processing folder {in_folder}, '", "+", "\n", "f'writing results in {out_folder}.'", ")", "\n", "\n", "files", "=", "[", "f", "for", "f", "in", "in_folder", ".", "glob", "(", "'*'", ")", "\n", "if", "f", ".", "name", ".", "endswith", "(", "self", ".", "FILE_TYPES", ")", "\n", "and", "f", ".", "name", ".", "startswith", "(", "in_prefix", ")", "]", "\n", "files_tqdm", "=", "tqdm", "(", "files", ",", "unit", "=", "\"file\"", ",", "\n", "disable", "=", "hide_progress", ",", "smoothing", "=", "0", ")", "\n", "logger", ".", "debug", "(", "f'{len(files)} files found.'", ")", "\n", "\n", "for", "file", "in", "files_tqdm", ":", "\n", "            ", "files_tqdm", ".", "set_postfix_str", "(", "file", ".", "name", ")", "\n", "filename", ",", "extension", "=", "os", ".", "path", ".", "splitext", "(", "file", ".", "name", ")", "\n", "if", "in_prefix", "and", "out_prefix", ":", "\n", "                ", "filename", "=", "filename", ".", "replace", "(", "in_prefix", ",", "out_prefix", ")", "\n", "", "elif", "out_prefix", ":", "\n", "                ", "filename", "=", "out_prefix", "+", "filename", "\n", "", "outfile", "=", "os", ".", "path", ".", "join", "(", "out_folder", ",", "filename", "+", "suffix", "+", "extension", ")", "\n", "self", ".", "process_file", "(", "file", ".", "as_posix", "(", ")", ",", "outfile", ")", "\n", "\n", "", "logger", ".", "info", "(", "f'Pipeline finished, {len(files)} processed.\\n'", "+", "'='", "*", "20", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.abstract_processor.AbstractProcessor.__init__": [[19, 22], ["abc.ABC.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ")", ":", "\n", "        ", "self", ".", "label", "=", "label", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.abstract_processor.AbstractProcessor.get_label_mask": [[23, 45], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            The labels corresponding to each point.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.abstract_processor.AbstractProcessor.get_label": [[46, 49], ["None"], "methods", ["None"], ["", "def", "get_label", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns the label of this AbstractProcessor.\"\"\"", "\n", "return", "self", ".", "label", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str": [[33, 36], ["None"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "get_str", "(", "label", ")", ":", "\n", "        ", "return", "Labels", ".", "STR_DICT", "[", "label", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing.clip_ahn_las_tile": [[32, 70], ["utils.las_utils.get_tilecode_from_filename", "utils.las_utils.get_bbox_from_tile_code", "laspy.LasData", "laspy.LasData.write", "type", "pathlib.Path", "numpy.where", "pathlib.Path().mkdir", "os.path.join", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code"], ["def", "clip_ahn_las_tile", "(", "ahn_cloud", ",", "las_file", ",", "out_folder", "=", "''", ",", "buffer", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Clip a tile from the AHN cloud to match the dimensions of a given\n    CycloMedia LAS tile, and save the result using the same naming convention.\n\n    Parameters\n    ----------\n    ahn_cloud : laspy point cloud\n        The full AHN point cloud. This is assumed to include the full area of\n        the given CycloMedia tile.\n\n    las_file : Path or str\n        The CycloMedia tile on which the clip should be based.\n\n    out_folder : str, optional\n        Output folder to which the clipped file should be saved. Defaults to\n        the current folder.\n\n    buffer : int, optional (default: 1)\n        Buffer around the CycloMedia tile (in m) to include, used for further\n        processing (e.g. interpolation).\n    \"\"\"", "\n", "if", "type", "(", "las_file", ")", "==", "str", ":", "\n", "        ", "las_file", "=", "pathlib", ".", "Path", "(", "las_file", ")", "\n", "", "tile_code", "=", "las_utils", ".", "get_tilecode_from_filename", "(", "las_file", ".", "name", ")", "\n", "\n", "(", "(", "x_min", ",", "y_max", ")", ",", "(", "x_max", ",", "y_min", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "\n", "tile_code", ",", "padding", "=", "buffer", ")", "\n", "\n", "clip_idx", "=", "np", ".", "where", "(", "(", "x_min", "<=", "ahn_cloud", ".", "x", ")", "&", "(", "ahn_cloud", ".", "x", "<=", "x_max", ")", "\n", "&", "(", "y_min", "<=", "ahn_cloud", ".", "y", ")", "&", "(", "ahn_cloud", ".", "y", "<=", "y_max", ")", ")", "[", "0", "]", "\n", "\n", "ahn_tile", "=", "laspy", ".", "LasData", "(", "ahn_cloud", ".", "header", ")", "\n", "ahn_tile", ".", "points", "=", "ahn_cloud", ".", "points", "[", "clip_idx", "]", "\n", "\n", "if", "out_folder", "!=", "''", ":", "\n", "        ", "pathlib", ".", "Path", "(", "out_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "ahn_tile", ".", "write", "(", "os", ".", "path", ".", "join", "(", "out_folder", ",", "'ahn_'", "+", "tile_code", "+", "'.laz'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing.clip_ahn_las_folder": [[72, 127], ["tqdm.tqdm", "os.path.isdir", "print", "type", "pathlib.Path", "pathlib.Path().mkdir", "set", "ahn_preprocessing.clip_ahn_las_tile", "pathlib.Path.glob", "f.name.endswith", "pathlib.Path", "pathlib.Path().glob", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing.clip_ahn_las_tile"], ["", "def", "clip_ahn_las_folder", "(", "ahn_cloud", ",", "in_folder", ",", "out_folder", "=", "None", ",", "buffer", "=", "1", ",", "\n", "resume", "=", "False", ",", "hide_progress", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Clip a tiles from the AHN cloud to match all CycloMedia LAS tiles in a\n    given folder, and save the result using the same naming convention.\n\n    Parameters\n    ----------\n    ahn_cloud : laspy point cloud\n        The full AHN point cloud. This is assumed to include the full area of\n        the given CycloMedia tiles.\n\n    in_folder : Path or str\n        The input folder (containing the point cloud tiles.)\n\n    out_folder : Path or str, optional\n        The output folder. Defaults to the input folder.\n\n    buffer : int, optional (default: 1)\n        Buffer around the CycloMedia tile (in m) to include, used for further\n        processing (e.g. interpolation).\n\n    resume : bool (default: False)\n        Whether to resume, i.e. skip existing files in the output folder. If\n        set to False, existing files will be overwritten.\n\n    hide_progress : bool (default: False)\n        Hide the progress bar.\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "in_folder", ")", ":", "\n", "        ", "print", "(", "'The input path specified does not exist'", ")", "\n", "return", "None", "\n", "\n", "", "if", "type", "(", "in_folder", ")", "==", "str", ":", "\n", "        ", "in_folder", "=", "pathlib", ".", "Path", "(", "in_folder", ")", "\n", "\n", "", "if", "out_folder", "is", "None", ":", "\n", "        ", "out_folder", "=", "in_folder", "\n", "\n", "", "if", "out_folder", "!=", "in_folder", ":", "\n", "        ", "pathlib", ".", "Path", "(", "out_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "file_types", "=", "(", "'.LAS'", ",", "'.las'", ",", "'.LAZ'", ",", "'.laz'", ")", "\n", "files", "=", "[", "f", "for", "f", "in", "in_folder", ".", "glob", "(", "'filtered_*'", ")", "\n", "if", "f", ".", "name", ".", "endswith", "(", "file_types", ")", "]", "\n", "\n", "if", "resume", ":", "\n", "# Find which files have already been processed.", "\n", "        ", "done", "=", "set", "(", "file", ".", "name", "[", "-", "13", ":", "-", "4", "]", "\n", "for", "file", "in", "pathlib", ".", "Path", "(", "out_folder", ")", ".", "glob", "(", "'ahn_*.laz'", ")", ")", "\n", "files", "=", "[", "f", "for", "f", "in", "files", "if", "f", ".", "name", "[", "-", "13", ":", "-", "4", "]", "not", "in", "done", "]", "\n", "\n", "", "for", "file", "in", "tqdm", "(", "files", ",", "unit", "=", "\"file\"", ",", "disable", "=", "hide_progress", ",", "smoothing", "=", "0", ")", ":", "\n", "        ", "clip_ahn_las_tile", "(", "ahn_cloud", ",", "file", ",", "out_folder", "=", "out_folder", ",", "\n", "buffer", "=", "buffer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing._get_ahn_surface": [[129, 186], ["utils.interpolation.SpatialInterpolator", "utils.interpolation.SpatialInterpolator.", "numpy.around().astype", "numpy.count_nonzero", "numpy.full", "numpy.vstack", "numpy.vstack", "numpy.around", "grid_x.reshape", "grid_y.reshape", "idw.reshape"], "function", ["None"], ["", "", "def", "_get_ahn_surface", "(", "ahn_las", ",", "grid_x", ",", "grid_y", ",", "si_method", ",", "ahn_label", ",", "\n", "n_neighbors", "=", "8", ",", "max_dist", "=", "1", ",", "power", "=", "2.", ",", "fill_value", "=", "np", ".", "nan", ")", ":", "\n", "    ", "\"\"\"\n    Use maximum-based interpolation or inverse distance weighted interpolation\n    (IDW) to generate a surface (grid) from a given AHN cloud.\n\n    For more information on IDW see:\n    utils.interpolation.SpatialInterpolator\n\n    Parameters\n    ----------\n    ahn_las : laspy point cloud\n        The AHN point cloud.\n\n    grid_x : list of floats\n        X-values for the interpolation grid.\n\n    grid_y : list of floats\n        Y-values for the interpolation grid.\n\n    si_method : string\n        Spatial interpolator method\n\n    ahn_label : int\n        AHN classification codes\n\n    n_neighbours : int (default: 8)\n        Maximum number of neighbours to use for IDW.\n\n    max_dist : float (default: 1.0)\n        Maximum distance of neighbours to consider for IDW.\n\n    power : float (default: 2.0)\n        Power to use for IDW.\n\n    fill_value : float (default: np.nan)\n        Fill value to use for 'empty' grid cells for which no interpolation\n        could be computed.\n\n    Returns\n    -------\n    2d array of interpolation values for each <y,x> grid cell.\n    \"\"\"", "\n", "mask", "=", "ahn_las", ".", "classification", "==", "ahn_label", "\n", "\n", "if", "np", ".", "count_nonzero", "(", "mask", ")", "<=", "1", ":", "\n", "        ", "return", "np", ".", "full", "(", "grid_x", ".", "shape", ",", "np", ".", "nan", ",", "dtype", "=", "'float16'", ")", "\n", "\n", "", "points", "=", "np", ".", "vstack", "(", "(", "ahn_las", ".", "x", ",", "ahn_las", ".", "y", ",", "ahn_las", ".", "z", ")", ")", ".", "T", "[", "mask", "]", "\n", "positions", "=", "np", ".", "vstack", "(", "(", "grid_x", ".", "reshape", "(", "-", "1", ")", ",", "grid_y", ".", "reshape", "(", "-", "1", ")", ")", ")", ".", "T", "\n", "\n", "idw", "=", "SpatialInterpolator", "(", "points", "[", ":", ",", "0", ":", "2", "]", ",", "points", "[", ":", ",", "2", "]", ",", "method", "=", "si_method", ")", "\n", "ahn_gnd_grid", "=", "idw", "(", "positions", ",", "n_neighbors", "=", "n_neighbors", ",", "max_dist", "=", "max_dist", ",", "\n", "power", "=", "power", ",", "fill_value", "=", "fill_value", ")", "\n", "\n", "return", "(", "np", ".", "around", "(", "ahn_gnd_grid", ".", "reshape", "(", "grid_x", ".", "shape", ")", ",", "decimals", "=", "2", ")", "\n", ".", "astype", "(", "'float16'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing.process_ahn_las_tile": [[188, 237], ["utils.las_utils.get_tilecode_from_filename", "utils.las_utils.get_bbox_from_tile_code", "laspy.read", "ahn_preprocessing._get_ahn_surface", "ahn_preprocessing._get_ahn_surface", "os.path.join", "numpy.savez_compressed", "type", "ahn_las_file.as_posix.as_posix", "pathlib.Path().mkdir", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing._get_ahn_surface", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing._get_ahn_surface"], ["", "def", "process_ahn_las_tile", "(", "ahn_las_file", ",", "out_folder", "=", "''", ",", "resolution", "=", "0.1", ")", ":", "\n", "    ", "\"\"\"\n    Generate ground and building surfaces (grids) for a given AHN point cloud.\n    The results are saved as .npz using the same filename convention.\n\n    Parameters\n    ----------\n    ahn_las_file : Path or str\n        The AHN point cloud file.\n\n    out_folder : Path or str, optional\n        The output folder. Defaults to the current folder.\n\n    resolution : float (default: 0.1)\n        The resolution (in m) for the surface grids.\n\n    Returns\n    -------\n    Path of the output file.\n    \"\"\"", "\n", "if", "type", "(", "ahn_las_file", ")", "==", "pathlib", ".", "PosixPath", ":", "\n", "        ", "ahn_las_file", "=", "ahn_las_file", ".", "as_posix", "(", ")", "\n", "", "tile_code", "=", "las_utils", ".", "get_tilecode_from_filename", "(", "ahn_las_file", ")", "\n", "\n", "if", "out_folder", "!=", "''", ":", "\n", "        ", "pathlib", ".", "Path", "(", "out_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "(", "(", "x_min", ",", "y_max", ")", ",", "(", "x_max", ",", "y_min", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "\n", "tile_code", ")", "\n", "\n", "ahn_las", "=", "laspy", ".", "read", "(", "ahn_las_file", ")", "\n", "\n", "# Create a grid with 0.1m resolution", "\n", "grid_y", ",", "grid_x", "=", "np", ".", "mgrid", "[", "y_max", "-", "resolution", "/", "2", ":", "y_min", ":", "-", "resolution", ",", "\n", "x_min", "+", "resolution", "/", "2", ":", "x_max", ":", "resolution", "]", "\n", "\n", "# Methods for generating surfaces (grids)", "\n", "ground_surface", "=", "_get_ahn_surface", "(", "ahn_las", ",", "grid_x", ",", "grid_y", ",", "'idw'", ",", "\n", "AHN_GROUND", ")", "\n", "building_surface", "=", "_get_ahn_surface", "(", "ahn_las", ",", "grid_x", ",", "grid_y", ",", "'max'", ",", "\n", "AHN_BUILDING", ",", "max_dist", "=", "0.5", ")", "\n", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "out_folder", ",", "'ahn_'", "+", "tile_code", "+", "'.npz'", ")", "\n", "np", ".", "savez_compressed", "(", "filename", ",", "\n", "x", "=", "grid_x", "[", "0", ",", ":", "]", ",", "\n", "y", "=", "grid_y", "[", ":", ",", "0", "]", ",", "\n", "ground", "=", "ground_surface", ",", "\n", "building", "=", "building_surface", ")", "\n", "return", "filename", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.csv_utils.write_csv": [[6, 24], ["open", "csv.writer", "csv.writer.writerow", "csv.writer.writerows"], "function", ["None"], ["def", "write_csv", "(", "csv_file", ",", "csv_content", ",", "csv_headers", ")", ":", "\n", "    ", "\"\"\"\n    Write the data to a csv file.\n\n    Parameters\n    ----------\n    csv_file : str\n        Output path of csv file\n    csv_content : 2D list\n        A nested list including the row content for the csv file\n    csv_headers : list\n        Column names\n    \"\"\"", "\n", "\n", "with", "open", "(", "csv_file", ",", "'w'", ",", "newline", "=", "''", ")", "as", "csvfile", ":", "\n", "        ", "writer", "=", "csv", ".", "writer", "(", "csvfile", ")", "\n", "writer", ".", "writerow", "(", "csv_headers", ")", "\n", "writer", ".", "writerows", "(", "csv_content", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_cloud_slice": [[50, 101], ["utils.las_utils.read_las", "utils.las_utils.get_tilecode_from_filename", "utils.las_utils.get_bbox_from_tile_code", "ahn_reader.interpolate", "numpy.unique", "matplotlib.Rectangle", "ax.add_patch", "ax.set_xlabel", "ax.set_xticks", "ax.set_xticklabels", "ax.set_ylabel", "ax.set_yticks", "ax.set_yticklabels", "ax.set_aspect", "matplotlib.subplots", "numpy.vstack", "numpy.ones", "labels.Labels.get_str", "ax.scatter", "ax.set_title", "range", "range", "range", "range", "ax.legend", "ax.legend", "matplotlib.show", "len"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.read_las", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["def", "plot_cloud_slice", "(", "las_file", ",", "ahn_reader", ",", "plane_height", "=", "1.5", ",", "hide_noise", "=", "False", ",", "\n", "ax", "=", "None", ",", "title", "=", "None", ",", "legend_below", "=", "False", ")", ":", "\n", "    ", "full_plot", "=", "False", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "constrained_layout", "=", "True", ")", "\n", "full_plot", "=", "True", "\n", "\n", "", "las", "=", "las_utils", ".", "read_las", "(", "las_file", ")", "\n", "labels", "=", "las", ".", "label", "\n", "points", "=", "np", ".", "vstack", "(", "(", "las", ".", "x", ",", "las", ".", "y", ",", "las", ".", "z", ")", ")", ".", "T", "\n", "\n", "tilecode", "=", "las_utils", ".", "get_tilecode_from_filename", "(", "las_file", ")", "\n", "(", "(", "x_min", ",", "y_max", ")", ",", "(", "x_max", ",", "y_min", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "tilecode", ")", "\n", "\n", "points_z", "=", "ahn_reader", ".", "interpolate", "(", "tilecode", ",", "points", ",", "\n", "np", ".", "ones", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", ",", "\n", "'ground_surface'", ")", "\n", "\n", "plane_mask", "=", "(", "(", "points", "[", ":", ",", "2", "]", ">=", "points_z", "+", "plane_height", "-", "0.05", ")", "\n", "&", "(", "points", "[", ":", ",", "2", "]", "<=", "points_z", "+", "plane_height", "+", "0.05", ")", ")", "\n", "label_set", "=", "np", ".", "unique", "(", "labels", "[", "plane_mask", "]", ")", "\n", "\n", "for", "label", "in", "label_set", ":", "\n", "        ", "if", "label", "==", "Labels", ".", "NOISE", "and", "hide_noise", ":", "\n", "            ", "continue", "\n", "", "label_mask", "=", "plane_mask", "&", "(", "labels", "==", "label", ")", "\n", "label_str", "=", "Labels", ".", "get_str", "(", "label", ")", "\n", "ax", ".", "scatter", "(", "points", "[", "label_mask", ",", "0", "]", ",", "points", "[", "label_mask", ",", "1", "]", ",", "\n", "c", "=", "cloud_colors", "[", "label_str", "]", ",", "marker", "=", "'.'", ",", "label", "=", "label_str", ")", "\n", "\n", "", "box", "=", "patches", ".", "Rectangle", "(", "(", "x_min", ",", "y_min", ")", ",", "x_max", "-", "x_min", ",", "y_max", "-", "y_min", ",", "\n", "linewidth", "=", "1", ",", "linestyle", "=", "'--'", ",", "edgecolor", "=", "'black'", ",", "\n", "fill", "=", "False", ")", "\n", "ax", ".", "add_patch", "(", "box", ")", "\n", "\n", "if", "title", "is", "not", "None", ":", "\n", "        ", "ax", ".", "set_title", "(", "title", ")", "\n", "", "ax", ".", "set_xlabel", "(", "'X'", ")", "\n", "ax", ".", "set_xticks", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_ylabel", "(", "'Y'", ")", "\n", "ax", ".", "set_yticks", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticklabels", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "if", "not", "legend_below", ":", "\n", "        ", "ax", ".", "legend", "(", "loc", "=", "'center left'", ",", "bbox_to_anchor", "=", "(", "1", ",", "0.5", ")", ")", "\n", "", "else", ":", "\n", "        ", "ax", ".", "legend", "(", "loc", "=", "'upper center'", ",", "bbox_to_anchor", "=", "(", "0.5", ",", "-", "0.15", ")", ",", "ncol", "=", "3", ")", "\n", "", "ax", ".", "set_aspect", "(", "'equal'", ",", "adjustable", "=", "'box'", ")", "\n", "if", "full_plot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_bgt": [[103, 185], ["utils.las_utils.get_bbox_from_tile_code", "matplotlib.Rectangle", "ax.add_patch", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "ax.set_xticks", "ax.set_xticklabels", "ax.set_yticks", "ax.set_yticklabels", "ax.set_xlim", "ax.set_ylim", "ax.set_aspect", "matplotlib.subplots", "utils.bgt_utils.get_polygons", "utils.bgt_utils.get_polygons", "utils.bgt_utils.get_points", "utils.bgt_utils.get_points", "shapely.geometry.Polygon", "ax.fill", "ax.plot", "shapely.geometry.Polygon", "ax.fill", "ax.scatter", "ax.scatter", "ax.get_legend_handles_labels", "dict", "range", "range", "range", "range", "matplotlib.show", "zip", "ax.legend", "ax.legend", "dict.values", "dict.keys", "dict.values", "dict.keys"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_polygons", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_polygons", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_points", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_points"], ["", "", "def", "plot_bgt", "(", "tilecode", ",", "building_file", "=", "None", ",", "road_file", "=", "None", ",", "pole_file", "=", "None", ",", "\n", "street_furniture_file", "=", "None", ",", "ax", "=", "None", ",", "title", "=", "None", ",", "show_legend", "=", "True", ",", "\n", "legend_below", "=", "False", ")", ":", "\n", "    ", "padding", "=", "2.5", "\n", "\n", "full_plot", "=", "False", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "width", "=", "7", "if", "show_legend", "else", "5", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "figsize", "=", "(", "width", ",", "5", ")", ",", "constrained_layout", "=", "True", ")", "\n", "full_plot", "=", "True", "\n", "\n", "", "if", "title", "is", "None", ":", "\n", "        ", "title", "=", "f'BGT tile {tilecode}'", "\n", "\n", "", "buildings", "=", "[", "]", "\n", "roads", "=", "[", "]", "\n", "poles", "=", "[", "]", "\n", "street_furniture", "=", "[", "]", "\n", "\n", "if", "building_file", ":", "\n", "        ", "buildings", "=", "bgt_utils", ".", "get_polygons", "(", "building_file", ",", "tilecode", ")", "\n", "", "if", "road_file", ":", "\n", "        ", "roads", "=", "bgt_utils", ".", "get_polygons", "(", "road_file", ",", "tilecode", ")", "\n", "", "if", "pole_file", ":", "\n", "        ", "poles", "=", "bgt_utils", ".", "get_points", "(", "pole_file", ",", "tilecode", ",", "padding", "=", "padding", ")", "\n", "", "if", "street_furniture_file", ":", "\n", "        ", "street_furniture", "=", "bgt_utils", ".", "get_points", "(", "street_furniture_file", ",", "\n", "tilecode", ",", "padding", "=", "padding", ")", "\n", "\n", "", "(", "(", "x_min", ",", "y_max", ")", ",", "(", "x_max", ",", "y_min", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "tilecode", ")", "\n", "\n", "for", "poly", "in", "[", "Polygon", "(", "bld", ")", "for", "bld", "in", "buildings", "]", ":", "\n", "        ", "x", ",", "y", "=", "poly", ".", "exterior", ".", "xy", "\n", "ax", ".", "fill", "(", "x", ",", "y", ",", "c", "=", "bgt_colors", "[", "'pand'", "]", ",", "label", "=", "bgt_labels", "[", "'pand'", "]", ",", "\n", "zorder", "=", "-", "1", ")", "\n", "ax", ".", "plot", "(", "x", ",", "y", ",", "c", "=", "bgt_colors", "[", "'pand_poly'", "]", ",", "zorder", "=", "0", ")", "\n", "\n", "", "for", "poly", "in", "[", "Polygon", "(", "rd", ")", "for", "rd", "in", "roads", "]", ":", "\n", "        ", "x", ",", "y", "=", "poly", ".", "exterior", ".", "xy", "\n", "ax", ".", "fill", "(", "x", ",", "y", ",", "c", "=", "bgt_colors", "[", "'wegdeel'", "]", ",", "label", "=", "bgt_labels", "[", "'wegdeel'", "]", ",", "\n", "zorder", "=", "-", "1", ")", "\n", "\n", "", "for", "pt", "in", "poles", ":", "\n", "        ", "ax", ".", "scatter", "(", "pt", "[", "1", "]", ",", "pt", "[", "2", "]", ",", "\n", "c", "=", "bgt_colors", "[", "pt", "[", "0", "]", "]", ",", "marker", "=", "'x'", ",", "label", "=", "bgt_labels", "[", "pt", "[", "0", "]", "]", ",", "\n", "zorder", "=", "1", ")", "\n", "\n", "", "for", "pt", "in", "street_furniture", ":", "\n", "        ", "ax", ".", "scatter", "(", "pt", "[", "1", "]", ",", "pt", "[", "2", "]", ",", "\n", "c", "=", "bgt_colors", "[", "pt", "[", "0", "]", "]", ",", "marker", "=", "'*'", ",", "label", "=", "bgt_labels", "[", "pt", "[", "0", "]", "]", ",", "\n", "zorder", "=", "1", ")", "\n", "\n", "", "box", "=", "patches", ".", "Rectangle", "(", "(", "x_min", ",", "y_min", ")", ",", "x_max", "-", "x_min", ",", "y_max", "-", "y_min", ",", "\n", "linewidth", "=", "1", ",", "linestyle", "=", "'--'", ",", "edgecolor", "=", "'black'", ",", "\n", "fill", "=", "False", ")", "\n", "ax", ".", "add_patch", "(", "box", ")", "\n", "\n", "ax", ".", "set_title", "(", "title", ")", "\n", "ax", ".", "set_xlabel", "(", "'X'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Y'", ")", "\n", "\n", "if", "show_legend", ":", "\n", "        ", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "by_label", "=", "dict", "(", "zip", "(", "labels", ",", "handles", ")", ")", "\n", "if", "not", "legend_below", ":", "\n", "            ", "ax", ".", "legend", "(", "by_label", ".", "values", "(", ")", ",", "by_label", ".", "keys", "(", ")", ",", "\n", "loc", "=", "'center left'", ",", "bbox_to_anchor", "=", "(", "1", ",", "0.5", ")", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "legend", "(", "by_label", ".", "values", "(", ")", ",", "by_label", ".", "keys", "(", ")", ",", "\n", "loc", "=", "'upper center'", ",", "bbox_to_anchor", "=", "(", "0.5", ",", "-", "0.15", ")", ",", "ncol", "=", "3", ")", "\n", "\n", "", "", "ax", ".", "set_xticks", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticks", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticklabels", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "\n", "ax", ".", "set_xlim", "(", "(", "x_min", "-", "padding", ",", "x_max", "+", "padding", ")", ")", "\n", "ax", ".", "set_ylim", "(", "(", "y_min", "-", "padding", ",", "y_max", "+", "padding", ")", ")", "\n", "ax", ".", "set_aspect", "(", "'equal'", ",", "adjustable", "=", "'box'", ")", "\n", "if", "full_plot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_bgt_and_cloudslice": [[187, 203], ["matplotlib.subplots", "plot_utils.plot_bgt", "plot_utils.plot_cloud_slice", "ax2.set_yticklabels", "ax2.yaxis.label.set_visible", "fig.suptitle", "fig.subplots_adjust", "matplotlib.show"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_bgt", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_cloud_slice"], ["", "", "def", "plot_bgt_and_cloudslice", "(", "tilecode", ",", "las_file", ",", "ahn_reader", ",", "\n", "building_file", "=", "None", ",", "road_file", "=", "None", ",", "\n", "pole_file", "=", "None", ",", "street_furniture_file", "=", "None", ",", "\n", "plane_height", "=", "1.5", ",", "hide_noise", "=", "False", ")", ":", "\n", "    ", "fig", ",", "(", "ax1", ",", "ax2", ")", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "(", "10", ",", "5.5", ")", ")", "\n", "plot_bgt", "(", "tilecode", ",", "building_file", ",", "road_file", ",", "pole_file", ",", "\n", "street_furniture_file", ",", "title", "=", "'BGT data'", ",", "ax", "=", "ax1", ",", "\n", "legend_below", "=", "True", ")", "\n", "plot_cloud_slice", "(", "las_file", ",", "ahn_reader", ",", "plane_height", "=", "plane_height", ",", "\n", "hide_noise", "=", "hide_noise", ",", "title", "=", "'LAS labels'", ",", "ax", "=", "ax2", ",", "\n", "legend_below", "=", "True", ")", "\n", "ax2", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "ax2", ".", "yaxis", ".", "label", ".", "set_visible", "(", "False", ")", "\n", "fig", ".", "suptitle", "(", "f'Tile {tilecode}'", ",", "fontsize", "=", "14", ")", "\n", "fig", ".", "subplots_adjust", "(", "top", "=", "1", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface": [[205, 234], ["int", "int", "int", "int", "ax.imshow", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "ax.set_xticks", "ax.set_xticklabels", "ax.set_yticks", "ax.set_yticklabels", "matplotlib.colorbar", "plt.colorbar.ax.set_ylabel", "matplotlib.subplots", "numpy.ceil", "numpy.ceil", "range", "range", "range", "range", "matplotlib.show"], "function", ["None"], ["", "def", "plot_ahn_surface", "(", "ahn_tile", ",", "surf", "=", "'ground_surface'", ",", "ax", "=", "None", ",", "cbar_pad", "=", "0.04", ")", ":", "\n", "    ", "cmap", "=", "{", "'ground_surface'", ":", "'gist_earth'", ",", "\n", "'building_surface'", ":", "'Oranges'", "}", "\n", "cbar_title", "=", "{", "'ground_surface'", ":", "'Ground elevation (m)'", ",", "\n", "'building_surface'", ":", "'Building height (m)'", "}", "\n", "full_plot", "=", "False", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "full_plot", "=", "True", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ")", "\n", "\n", "", "x_min", "=", "int", "(", "ahn_tile", "[", "'x'", "]", "[", "0", "]", ")", "\n", "x_max", "=", "int", "(", "np", ".", "ceil", "(", "ahn_tile", "[", "'x'", "]", "[", "-", "1", "]", ")", ")", "\n", "y_min", "=", "int", "(", "ahn_tile", "[", "'y'", "]", "[", "-", "1", "]", ")", "\n", "y_max", "=", "int", "(", "np", ".", "ceil", "(", "ahn_tile", "[", "'y'", "]", "[", "0", "]", ")", ")", "\n", "\n", "im", "=", "ax", ".", "imshow", "(", "ahn_tile", "[", "surf", "]", ",", "extent", "=", "[", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", "]", ",", "\n", "interpolation", "=", "'none'", ",", "cmap", "=", "cmap", "[", "surf", "]", ")", "\n", "\n", "ax", ".", "set_title", "(", "surf", ")", "\n", "ax", ".", "set_xlabel", "(", "'X'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Y'", ")", "\n", "ax", ".", "set_xticks", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticks", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticklabels", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "cbar", "=", "plt", ".", "colorbar", "(", "im", ",", "ax", "=", "[", "ax", "]", ",", "fraction", "=", "0.046", ",", "pad", "=", "cbar_pad", ")", "\n", "cbar", ".", "ax", ".", "set_ylabel", "(", "cbar_title", "[", "surf", "]", ",", "rotation", "=", "270", ",", "labelpad", "=", "10", ")", "\n", "if", "full_plot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_sidebyside": [[236, 245], ["ahn_reader.filter_tile", "matplotlib.subplots", "plot_utils.plot_ahn_surface", "plot_utils.plot_ahn_surface", "ax2.set_yticklabels", "ax2.yaxis.label.set_visible", "fig.suptitle", "matplotlib.show"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface"], ["", "", "def", "plot_ahn_sidebyside", "(", "tilecode", ",", "ahn_reader", ")", ":", "\n", "    ", "ahn_tile", "=", "ahn_reader", ".", "filter_tile", "(", "tilecode", ")", "\n", "fig", ",", "(", "ax1", ",", "ax2", ")", "=", "plt", ".", "subplots", "(", "1", ",", "2", ",", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "plot_ahn_surface", "(", "ahn_tile", ",", "surf", "=", "'ground_surface'", ",", "ax", "=", "ax1", ")", "\n", "plot_ahn_surface", "(", "ahn_tile", ",", "surf", "=", "'building_surface'", ",", "ax", "=", "ax2", ")", "\n", "ax2", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "ax2", ".", "yaxis", ".", "label", ".", "set_visible", "(", "False", ")", "\n", "fig", ".", "suptitle", "(", "f'AHN tile {tilecode}'", ",", "fontsize", "=", "14", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_merged": [[247, 254], ["ahn_reader.filter_tile", "matplotlib.subplots", "plot_utils.plot_ahn_surface", "plot_utils.plot_ahn_surface", "ax1.set_title", "matplotlib.show"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface"], ["", "def", "plot_ahn_merged", "(", "tilecode", ",", "ahn_reader", ")", ":", "\n", "    ", "ahn_tile", "=", "ahn_reader", ".", "filter_tile", "(", "tilecode", ")", "\n", "fig", ",", "ax1", "=", "plt", ".", "subplots", "(", "1", ",", "figsize", "=", "(", "7", ",", "5", ")", ")", "\n", "plot_ahn_surface", "(", "ahn_tile", ",", "surf", "=", "'ground_surface'", ",", "ax", "=", "ax1", ",", "cbar_pad", "=", "0.14", ")", "\n", "plot_ahn_surface", "(", "ahn_tile", ",", "surf", "=", "'building_surface'", ",", "ax", "=", "ax1", ",", "cbar_pad", "=", "0.04", ")", "\n", "ax1", ".", "set_title", "(", "f'AHN tile {tilecode}'", ",", "fontsize", "=", "14", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_buildings_ahn_bgt": [[256, 318], ["ahn_reader.filter_tile", "utils.bgt_utils.get_polygons", "utils.las_utils.get_bbox_from_tile_code", "matplotlib.subplots", "matplotlib.Rectangle", "ax.add_patch", "ax.set_title", "ax.set_xlabel", "ax.set_ylabel", "ax.set_xticks", "ax.set_xticklabels", "ax.set_yticks", "ax.set_yticklabels", "ax.set_xlim", "ax.set_ylim", "ax.set_aspect", "matplotlib.show", "utils.bgt_utils.get_polygons", "plot_utils.plot_ahn_surface", "matplotlib.LinearSegmentedColormap.from_list", "ax.imshow", "matplotlib.Patch", "ax.plot", "range", "range", "range", "range", "ax.get_legend_handles_labels", "dict", "ax.legend", "shapely.geometry.Polygon", "ax.plot", "zip", "dict.values", "dict.keys", "patches.Patch.get_label"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_polygons", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_polygons", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_ahn_surface", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.abstract_processor.AbstractProcessor.get_label"], ["", "def", "plot_buildings_ahn_bgt", "(", "tilecode", ",", "ahn_reader", ",", "building_file", ",", "offset", "=", "1", ",", "\n", "show_elevation", "=", "True", ",", "offset_only", "=", "True", ",", "title", "=", "None", ")", ":", "\n", "    ", "ahn_tile", "=", "ahn_reader", ".", "filter_tile", "(", "tilecode", ")", "\n", "buildings", "=", "bgt_utils", ".", "get_polygons", "(", "building_file", ",", "tilecode", ")", "\n", "if", "offset", ">", "0", ":", "\n", "        ", "buildings_ofs", "=", "bgt_utils", ".", "get_polygons", "(", "building_file", ",", "tilecode", ",", "\n", "offset", "=", "offset", ",", "merge", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "buildings_ofs", "=", "[", "]", "\n", "", "(", "(", "x_min", ",", "y_max", ")", ",", "(", "x_max", ",", "y_min", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "tilecode", ")", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "figsize", "=", "(", "7", ",", "5", ")", ",", "constrained_layout", "=", "True", ")", "\n", "\n", "if", "show_elevation", ":", "\n", "        ", "plot_ahn_surface", "(", "\n", "ahn_tile", ",", "surf", "=", "'building_surface'", ",", "ax", "=", "ax", ",", "cbar_pad", "=", "0.04", ")", "\n", "if", "title", "is", "None", ":", "\n", "            ", "title", "=", "'Building footprints and elevation'", "\n", "", "", "else", ":", "\n", "        ", "cmap", "=", "mcolors", ".", "LinearSegmentedColormap", ".", "from_list", "(", "'sg'", ",", "[", "'lightgrey'", "]", "*", "2", ")", "\n", "ax", ".", "imshow", "(", "ahn_tile", "[", "'building_surface'", "]", ",", "\n", "extent", "=", "[", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", "]", ",", "\n", "interpolation", "=", "'none'", ",", "cmap", "=", "cmap", ")", "\n", "dummy", "=", "patches", ".", "Patch", "(", "color", "=", "'lightgrey'", ",", "label", "=", "'AHN surface'", ")", "\n", "if", "title", "is", "None", ":", "\n", "            ", "title", "=", "'Building footprints'", "\n", "\n", "", "", "if", "not", "offset_only", ":", "\n", "        ", "for", "poly", "in", "[", "Polygon", "(", "bld", ")", "for", "bld", "in", "buildings", "]", ":", "\n", "            ", "x", ",", "y", "=", "poly", ".", "exterior", ".", "xy", "\n", "ax", ".", "plot", "(", "x", ",", "y", ",", "c", "=", "bgt_colors", "[", "'pand_poly'", "]", ",", "label", "=", "'BGT polygon'", ")", "\n", "", "", "for", "poly", "in", "buildings_ofs", ":", "\n", "        ", "x", ",", "y", "=", "poly", ".", "exterior", ".", "xy", "\n", "ax", ".", "plot", "(", "x", ",", "y", ",", "c", "=", "bgt_colors", "[", "'pand_poly'", "]", ",", "linestyle", "=", "'--'", ",", "\n", "label", "=", "'Offset polygon'", ")", "\n", "\n", "", "box", "=", "patches", ".", "Rectangle", "(", "(", "x_min", ",", "y_min", ")", ",", "x_max", "-", "x_min", ",", "y_max", "-", "y_min", ",", "\n", "linewidth", "=", "1", ",", "linestyle", "=", "'--'", ",", "edgecolor", "=", "'black'", ",", "\n", "fill", "=", "False", ")", "\n", "ax", ".", "add_patch", "(", "box", ")", "\n", "\n", "ax", ".", "set_title", "(", "title", ")", "\n", "ax", ".", "set_xlabel", "(", "'X'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Y'", ")", "\n", "ax", ".", "set_xticks", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "range", "(", "x_min", ",", "x_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticks", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "ax", ".", "set_yticklabels", "(", "range", "(", "y_min", ",", "y_max", "+", "1", ",", "10", ")", ")", "\n", "\n", "if", "not", "show_elevation", ":", "\n", "        ", "handles", ",", "labels", "=", "ax", ".", "get_legend_handles_labels", "(", ")", "\n", "by_label", "=", "dict", "(", "zip", "(", "labels", ",", "handles", ")", ")", "\n", "by_label", "[", "dummy", ".", "get_label", "(", ")", "]", "=", "dummy", "\n", "ax", ".", "legend", "(", "by_label", ".", "values", "(", ")", ",", "by_label", ".", "keys", "(", ")", ",", "\n", "loc", "=", "'center left'", ",", "bbox_to_anchor", "=", "(", "1", ",", "0.5", ")", ")", "\n", "\n", "", "padding", "=", "2.5", "\n", "ax", ".", "set_xlim", "(", "(", "x_min", "-", "padding", ",", "x_max", "+", "padding", ")", ")", "\n", "ax", ".", "set_ylim", "(", "(", "y_min", "-", "padding", ",", "y_max", "+", "padding", ")", ")", "\n", "ax", ".", "set_aspect", "(", "'equal'", ",", "adjustable", "=", "'box'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.plot_tiles_map": [[320, 363], ["pandas.DataFrame().set_index", "utils.rd_converter.RDWGS84Converter", "utils.rd_converter.RDWGS84Converter.from_rd", "folium.Figure", "folium.Map().add_to", "pd.DataFrame().set_index.iterrows", "utils.las_utils.get_bbox_from_tile_code", "int", "int", "folium.Rectangle().add_to", "pandas.DataFrame", "folium.Map", "utils.rd_converter.RDWGS84Converter.from_rd", "utils.rd_converter.RDWGS84Converter.from_rd", "folium.Rectangle", "pd.DataFrame().set_index.X1.min", "pd.DataFrame().set_index.Y1.min", "pd.DataFrame().set_index.X1.max", "pd.DataFrame().set_index.Y1.max"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.rd_converter.RDWGS84Converter.from_rd", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.rd_converter.RDWGS84Converter.from_rd", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.rd_converter.RDWGS84Converter.from_rd"], ["", "def", "plot_tiles_map", "(", "tiles", ",", "train_tiles", "=", "[", "]", ",", "width", "=", "1024", ",", "height", "=", "1024", ",", "\n", "zoom_control", "=", "True", ",", "zoom_start", "=", "14", ",", "opacity", "=", "0.25", ")", ":", "\n", "    ", "\"\"\"\n    Visualise the locations of all point cloud tiles in a given folder and\n    overlay them on an OpenStreetMap of the area. The returned map is\n    interactive, i.e. it allows panning and zooming, and tilecodes are\n    displayed as tooltip on hoovering.\n    \"\"\"", "\n", "tile_df", "=", "(", "pd", ".", "DataFrame", "(", "columns", "=", "[", "'Tilecode'", ",", "'X1'", ",", "'Y1'", ",", "'Train'", "]", ")", "\n", ".", "set_index", "(", "'Tilecode'", ")", ")", "\n", "for", "tilecode", "in", "tiles", ":", "\n", "        ", "(", "(", "x1", ",", "_", ")", ",", "(", "_", ",", "y1", ")", ")", "=", "las_utils", ".", "get_bbox_from_tile_code", "(", "tilecode", ")", "\n", "tile_df", ".", "loc", "[", "tilecode", "]", "=", "[", "x1", ",", "y1", ",", "False", "]", "\n", "", "for", "tilecode", "in", "train_tiles", ":", "\n", "        ", "tile_df", ".", "loc", "[", "tilecode", ",", "'Train'", "]", "=", "True", "\n", "\n", "", "conv", "=", "RDWGS84Converter", "(", ")", "\n", "\n", "center", "=", "conv", ".", "from_rd", "(", "int", "(", "(", "tile_df", ".", "X1", ".", "max", "(", ")", "+", "50", "+", "tile_df", ".", "X1", ".", "min", "(", ")", ")", "/", "2", ")", ",", "\n", "int", "(", "(", "tile_df", ".", "Y1", ".", "max", "(", ")", "+", "50", "+", "tile_df", ".", "Y1", ".", "min", "(", ")", ")", "/", "2", ")", ")", "\n", "\n", "f", "=", "folium", ".", "Figure", "(", "width", "=", "width", ",", "height", "=", "height", ")", "\n", "\n", "# Create Folium background map.", "\n", "tiles_map", "=", "(", "folium", ".", "Map", "(", "location", "=", "center", ",", "tiles", "=", "'cartodbpositron'", ",", "\n", "min_zoom", "=", "10", ",", "max_zoom", "=", "20", ",", "zoom_start", "=", "zoom_start", ",", "\n", "zoom_control", "=", "zoom_control", ",", "control_scale", "=", "True", ")", "\n", ".", "add_to", "(", "f", ")", ")", "\n", "\n", "for", "index", ",", "row", "in", "tile_df", ".", "iterrows", "(", ")", ":", "\n", "        ", "rect", "=", "[", "conv", ".", "from_rd", "(", "row", ".", "X1", ",", "row", ".", "Y1", ")", ",", "\n", "conv", ".", "from_rd", "(", "row", ".", "X1", "+", "50", ",", "row", ".", "Y1", "+", "50", ")", "]", "\n", "if", "row", ".", "Train", ":", "\n", "            ", "fc", "=", "'darkorange'", "\n", "fop", "=", "opacity", "\n", "", "else", ":", "\n", "            ", "fc", "=", "'royalblue'", "\n", "fop", "=", "0.1", "\n", "", "(", "folium", ".", "Rectangle", "(", "bounds", "=", "rect", ",", "tooltip", "=", "index", ",", "color", "=", "'royalblue'", ",", "\n", "weight", "=", "1", ",", "fill_color", "=", "fc", ",", "fill_opacity", "=", "fop", ")", "\n", ".", "add_to", "(", "tiles_map", ")", ")", "\n", "\n", "", "return", "tiles_map", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.plot_utils.save_tiles_map": [[365, 375], ["map.save", "subprocess.check_call", "os.path.exists", "os.remove", "os.getcwd"], "function", ["None"], ["", "def", "save_tiles_map", "(", "map", ",", "outfile", ",", "width", "=", "1024", ",", "height", "=", "1024", ")", ":", "\n", "    ", "\"\"\"Save a given tiles map to a file, e.g. as PNG.\"\"\"", "\n", "tmpfile", "=", "'tmp.html'", "\n", "tmpurl", "=", "f'file://{os.getcwd()}/{tmpfile}'", "\n", "map", ".", "save", "(", "tmpfile", ")", "\n", "subprocess", ".", "check_call", "(", "[", "'cutycapt'", ",", "'--delay=1000'", ",", "\n", "f'--min-width={width}'", ",", "f'--min-height={height}'", ",", "\n", "f'--url={tmpurl}'", ",", "f'--out={outfile}'", "]", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "tmpfile", ")", ":", "\n", "        ", "os", ".", "remove", "(", "tmpfile", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.rd_converter.RDWGS84Converter.from_rd": [[71, 83], ["sum", "sum", "builtins.enumerate", "builtins.enumerate"], "methods", ["None"], ["def", "from_rd", "(", "self", ",", "x", ":", "int", ",", "y", ":", "int", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        Converts RD coordinates into WGS84 coordinates\n        \"\"\"", "\n", "dx", "=", "1E-5", "*", "(", "x", "-", "self", ".", "x0", ")", "\n", "dy", "=", "1E-5", "*", "(", "y", "-", "self", ".", "y0", ")", "\n", "latitude", "=", "self", ".", "phi0", "+", "sum", "(", "[", "v", "*", "dx", "**", "self", ".", "Kp", "[", "i", "]", "*", "dy", "**", "self", ".", "Kq", "[", "i", "]", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "Kpq", ")", "]", ")", "/", "3600", "\n", "longitude", "=", "self", ".", "lam0", "+", "sum", "(", "[", "v", "*", "dx", "**", "self", ".", "Lp", "[", "i", "]", "*", "dy", "**", "self", ".", "Lq", "[", "i", "]", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "Lpq", ")", "]", ")", "/", "3600", "\n", "\n", "return", "latitude", ",", "longitude", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.rd_converter.RDWGS84Converter.from_wgs84": [[84, 96], ["sum", "sum", "builtins.enumerate", "builtins.enumerate"], "methods", ["None"], ["", "def", "from_wgs84", "(", "self", ",", "latitude", ":", "float", ",", "longitude", ":", "float", ")", "->", "tuple", ":", "\n", "        ", "\"\"\"\n        Converts WGS84 coordinates into RD coordinates\n        \"\"\"", "\n", "dlat", "=", "0.36", "*", "(", "latitude", "-", "self", ".", "phi0", ")", "\n", "dlon", "=", "0.36", "*", "(", "longitude", "-", "self", ".", "lam0", ")", "\n", "x", "=", "self", ".", "x0", "+", "sum", "(", "[", "v", "*", "dlat", "**", "self", ".", "Rp", "[", "i", "]", "*", "dlon", "**", "self", ".", "Rq", "[", "i", "]", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "Rpq", ")", "]", ")", "\n", "y", "=", "self", ".", "y0", "+", "sum", "(", "[", "v", "*", "dlat", "**", "self", ".", "Sp", "[", "i", "]", "*", "dlon", "**", "self", ".", "Sq", "[", "i", "]", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "self", ".", "Spq", ")", "]", ")", "\n", "\n", "return", "x", ",", "y", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.rectangle_clip": [[22, 41], ["numba.jit"], "function", ["None"], ["@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "\n", "def", "rectangle_clip", "(", "points", ",", "rect", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a rectangle.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    rect : tuple of floats\n        (x_min, y_min, x_max, y_max)\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the rectangle.\n    \"\"\"", "\n", "clip_mask", "=", "(", "(", "points", "[", ":", ",", "0", "]", ">=", "rect", "[", "0", "]", ")", "&", "(", "points", "[", ":", ",", "0", "]", "<=", "rect", "[", "2", "]", ")", "\n", "&", "(", "points", "[", ":", ",", "1", "]", ">=", "rect", "[", "1", "]", ")", "&", "(", "points", "[", ":", ",", "1", "]", "<=", "rect", "[", "3", "]", ")", ")", "\n", "return", "clip_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.box_clip": [[43, 66], ["numba.jit", "clip_utils.rectangle_clip"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.rectangle_clip"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "\n", "def", "box_clip", "(", "points", ",", "rect", ",", "bottom", "=", "-", "np", ".", "inf", ",", "top", "=", "np", ".", "inf", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a 3D box.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    rect : tuple of floats\n        (x_min, y_min, x_max, y_max)\n    bottom : float (default: -inf)\n        Bottom of the box.\n    top : float (default: inf)\n        Top of the box.\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the 3D box.\n    \"\"\"", "\n", "box_mask", "=", "rectangle_clip", "(", "points", ",", "rect", ")", "\n", "box_mask", "=", "box_mask", "&", "(", "(", "points", "[", ":", ",", "2", "]", "<=", "top", ")", "&", "(", "points", "[", ":", ",", "2", "]", ">=", "bottom", ")", ")", "\n", "return", "box_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.circle_clip": [[68, 90], ["numba.jit", "numpy.power", "numpy.power", "numpy.power"], "function", ["None"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "\n", "def", "circle_clip", "(", "points", ",", "center", ",", "radius", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a circle (or unbounded cylinder).\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    center : tuple of floats (x, y)\n        Center point of the circle.\n    radius : float\n        Radius of the circle.\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the circle.\n    \"\"\"", "\n", "clip_mask", "=", "(", "np", ".", "power", "(", "(", "points", "[", ":", ",", "0", "]", "-", "center", "[", "0", "]", ")", ",", "2", ")", "\n", "+", "np", ".", "power", "(", "(", "points", "[", ":", ",", "1", "]", "-", "center", "[", "1", "]", ")", ",", "2", ")", "\n", "<=", "np", ".", "power", "(", "radius", ",", "2", ")", ")", "\n", "return", "clip_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.cylinder_clip": [[92, 117], ["numba.jit", "clip_utils.circle_clip"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.circle_clip"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "\n", "def", "cylinder_clip", "(", "points", ",", "center", ",", "radius", ",", "bottom", "=", "-", "np", ".", "inf", ",", "top", "=", "np", ".", "inf", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a cylinder.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    center : tuple of floats (x, y)\n        Center point of the circle.\n    radius : float\n        Radius of the circle.\n    bottom : float (default: -inf)\n        Bottom of the cylinder.\n    top : float (default: inf)\n        Top of the cylinder.\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the circle.\n    \"\"\"", "\n", "clip_mask", "=", "circle_clip", "(", "points", ",", "center", ",", "radius", ")", "\n", "clip_mask", "=", "clip_mask", "&", "(", "(", "points", "[", ":", ",", "2", "]", "<=", "top", ")", "&", "(", "points", "[", ":", ",", "2", "]", ">=", "bottom", ")", ")", "\n", "return", "clip_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils._point_inside_poly": [[119, 165], ["numba.jit", "len"], "function", ["None"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ")", "\n", "def", "_point_inside_poly", "(", "polygon", ",", "point", ")", ":", "\n", "    ", "\"\"\"\n    Improved version of the Crossing Number algorithm that checks if a point is\n    inside a polygon.\n    Implementation taken from https://github.com/sasamil/PointInPolygon_Py\n    \"\"\"", "\n", "length", "=", "len", "(", "polygon", ")", "-", "1", "\n", "dy2", "=", "point", "[", "1", "]", "-", "polygon", "[", "0", "]", "[", "1", "]", "\n", "intersections", "=", "0", "\n", "ii", "=", "0", "\n", "jj", "=", "1", "\n", "\n", "while", "ii", "<", "length", ":", "\n", "        ", "dy", "=", "dy2", "\n", "dy2", "=", "point", "[", "1", "]", "-", "polygon", "[", "jj", "]", "[", "1", "]", "\n", "\n", "# consider only lines which are not completely above/below/right from", "\n", "# the point", "\n", "if", "dy", "*", "dy2", "<=", "0.0", "and", "(", "point", "[", "0", "]", ">=", "polygon", "[", "ii", "]", "[", "0", "]", "\n", "or", "point", "[", "0", "]", ">=", "polygon", "[", "jj", "]", "[", "0", "]", ")", ":", "\n", "\n", "# non-horizontal line", "\n", "            ", "if", "dy", "<", "0", "or", "dy2", "<", "0", ":", "\n", "                ", "F", "=", "(", "dy", "*", "(", "polygon", "[", "jj", "]", "[", "0", "]", "-", "polygon", "[", "ii", "]", "[", "0", "]", ")", "\n", "/", "(", "dy", "-", "dy2", ")", "+", "polygon", "[", "ii", "]", "[", "0", "]", ")", "\n", "\n", "if", "point", "[", "0", "]", ">", "F", ":", "\n", "# if line is left from the point - the ray moving towards", "\n", "# left, will intersect it", "\n", "                    ", "intersections", "+=", "1", "\n", "", "elif", "point", "[", "0", "]", "==", "F", ":", "# point on line", "\n", "                    ", "return", "2", "\n", "\n", "# point on upper peak (dy2=dx2=0) or horizontal line (dy=dy2=0 and", "\n", "# dx*dx2<=0)", "\n", "", "", "elif", "(", "dy2", "==", "0", "\n", "and", "(", "point", "[", "0", "]", "==", "polygon", "[", "jj", "]", "[", "0", "]", "\n", "or", "(", "dy", "==", "0", "and", "(", "point", "[", "0", "]", "-", "polygon", "[", "ii", "]", "[", "0", "]", ")", "\n", "*", "(", "point", "[", "0", "]", "-", "polygon", "[", "jj", "]", "[", "0", "]", ")", "<=", "0", ")", ")", ")", ":", "\n", "                ", "return", "2", "\n", "\n", "", "", "ii", "=", "jj", "\n", "jj", "+=", "1", "\n", "\n", "", "return", "intersections", "&", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.is_inside": [[167, 191], ["numba.jit", "len", "numpy.empty", "numba.prange", "clip_utils._point_inside_poly"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils._point_inside_poly"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "is_inside", "(", "x", ",", "y", ",", "polygon", ")", ":", "\n", "    ", "\"\"\"\n    Checks for each point in a list whether that point is inside a polygon.\n\n    Parameters\n    ----------\n    x : list\n        X-coordinates.\n    y : list\n        Y-coordinates.\n    polygon : list of tuples\n        Polygon as linear ring.\n\n    Returns\n    -------\n    An array of shape (len(x),) with dtype bool, where each entry indicates\n    whether the corresponding point is inside the polygon.\n    \"\"\"", "\n", "n", "=", "len", "(", "x", ")", "\n", "mask", "=", "np", ".", "empty", "(", "(", "n", ",", ")", ",", "dtype", "=", "numba", ".", "boolean", ")", "\n", "for", "i", "in", "numba", ".", "prange", "(", "n", ")", ":", "\n", "        ", "mask", "[", "i", "]", "=", "_point_inside_poly", "(", "polygon", ",", "(", "x", "[", "i", "]", ",", "y", "[", "i", "]", ")", ")", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_clip": [[193, 232], ["numpy.array", "numpy.zeros", "clip_utils.rectangle_clip", "clip_utils.is_inside", "numpy.array", "utils.math_utils.compute_bounding_box", "numpy.where", "clip_utils.rectangle_clip", "clip_utils.is_inside", "len", "utils.math_utils.compute_bounding_box", "numpy.where"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.rectangle_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.is_inside", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.compute_bounding_box", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.rectangle_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.is_inside", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.compute_bounding_box"], ["", "def", "poly_clip", "(", "points", ",", "poly", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a polygon.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    poly : shapely.geometry Polygon object\n        Polygon to clip. Can have interior gaps.\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the polygon.\n    \"\"\"", "\n", "# Convert to numpy to work with numba jit in nopython mode.", "\n", "exterior", "=", "np", ".", "array", "(", "poly", ".", "exterior", ".", "coords", ")", "\n", "interiors", "=", "[", "np", ".", "array", "(", "interior", ".", "coords", ")", "for", "interior", "in", "poly", ".", "interiors", "]", "\n", "\n", "clip_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "# Clip exterior to include points.", "\n", "bbox_mask", "=", "rectangle_clip", "(", "\n", "points", ",", "math_utils", ".", "compute_bounding_box", "(", "exterior", ")", ")", "\n", "exterior_mask", "=", "is_inside", "(", "points", "[", "bbox_mask", ",", "0", "]", ",", "points", "[", "bbox_mask", ",", "1", "]", ",", "\n", "exterior", ")", "\n", "bbox_inds", "=", "np", ".", "where", "(", "bbox_mask", ")", "[", "0", "]", "\n", "clip_mask", "[", "bbox_inds", "[", "exterior_mask", "]", "]", "=", "True", "\n", "\n", "# Clip interior(s) to exclude points.", "\n", "for", "interior", "in", "interiors", ":", "\n", "        ", "bbox_mask", "=", "rectangle_clip", "(", "\n", "points", ",", "math_utils", ".", "compute_bounding_box", "(", "interior", ")", ")", "\n", "interior_mask", "=", "is_inside", "(", "points", "[", "bbox_mask", ",", "0", "]", ",", "points", "[", "bbox_mask", ",", "1", "]", ",", "\n", "interior", ")", "\n", "bbox_inds", "=", "np", ".", "where", "(", "bbox_mask", ")", "[", "0", "]", "\n", "clip_mask", "[", "bbox_inds", "[", "interior_mask", "]", "]", "=", "False", "\n", "\n", "", "return", "clip_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_box_clip": [[234, 256], ["clip_utils.poly_clip"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_clip"], ["", "def", "poly_box_clip", "(", "points", ",", "poly", ",", "bottom", "=", "-", "np", ".", "inf", ",", "top", "=", "np", ".", "inf", ")", ":", "\n", "    ", "\"\"\"\n    Clip all points within a 3D polygon with fixed height.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The points.\n    poly : shapely.geometry Polygon object\n        Polygon to clip. Can have interior gaps.\n    bottom : float (default: -inf)\n        Bottom height of the 3D polygon.\n    top : float (default: inf)\n        Top height of the 3D polygon.\n\n    Returns\n    -------\n    A boolean mask with True entries for all points within the 3D polygon.\n    \"\"\"", "\n", "clip_mask", "=", "poly_clip", "(", "points", ",", "poly", ")", "\n", "clip_mask", "=", "clip_mask", "&", "(", "(", "points", "[", ":", ",", "2", "]", "<=", "top", ")", "&", "(", "points", "[", ":", ",", "2", "]", ">=", "bottom", ")", ")", "\n", "return", "clip_mask", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.interpolation.SpatialInterpolator.__init__": [[119, 155], ["numpy.atleast_2d", "numpy.asanyarray().ravel", "cKDTree", "numpy.transpose", "numpy.reshape", "ValueError", "ValueError", "numpy.asanyarray().ravel", "numpy.any", "numpy.asanyarray", "ValueError", "ValueError", "numpy.asanyarray"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coordinates", ",", "values", ",", "\n", "weights", "=", "None", ",", "leafsize", "=", "10", ",", "method", "=", "'idw'", ")", ":", "\n", "        ", "from", "scipy", ".", "spatial", "import", "cKDTree", "\n", "\n", "coordinates", "=", "np", ".", "atleast_2d", "(", "coordinates", ")", "\n", "if", "coordinates", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "coordinates", "=", "np", ".", "transpose", "(", "coordinates", ")", "\n", "", "if", "coordinates", ".", "ndim", "!=", "2", ":", "\n", "            ", "coordinates", "=", "np", ".", "reshape", "(", "coordinates", ",", "(", "-", "1", ",", "coordinates", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "values", "=", "np", ".", "asanyarray", "(", "values", ")", ".", "ravel", "(", ")", "\n", "\n", "ncoords", "=", "coordinates", ".", "shape", "[", "0", "]", "\n", "if", "ncoords", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'You must enter at least one data point.'", ")", "\n", "\n", "", "if", "values", ".", "shape", "[", "0", "]", "!=", "ncoords", ":", "\n", "            ", "raise", "ValueError", "(", "'The number of values must match the number '", "\n", "'of coordinates.'", ")", "\n", "\n", "", "if", "weights", "is", "not", "None", ":", "\n", "            ", "weights", "=", "np", ".", "asanyarray", "(", "weights", ")", ".", "ravel", "(", ")", "\n", "if", "weights", ".", "shape", "[", "0", "]", "!=", "ncoords", ":", "\n", "                ", "raise", "ValueError", "(", "'The number of weights must match the '", "\n", "'number of coordinates.'", ")", "\n", "", "if", "np", ".", "any", "(", "weights", "<", "0.0", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'All weight values must be non-negative '", "\n", "'numbers.'", ")", "\n", "\n", "", "", "self", ".", "coordinates", "=", "coordinates", "\n", "self", ".", "ncoords", "=", "ncoords", "\n", "self", ".", "coords_ndim", "=", "coordinates", ".", "shape", "[", "1", "]", "\n", "self", ".", "values", "=", "values", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "method", "=", "method", "\n", "self", ".", "kdtree", "=", "cKDTree", "(", "coordinates", ",", "leafsize", "=", "leafsize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.interpolation.SpatialInterpolator.__call__": [[156, 309], ["int", "numpy.asanyarray", "numpy.reshape", "interpolation.SpatialInterpolator.kdtree.query", "numpy.empty", "numpy.empty.fill", "ValueError", "numpy.isfinite", "range", "len", "ValueError", "numpy.isfinite", "ValueError", "ValueError", "numpy.sum", "numpy.any", "numpy.max", "numpy.dot"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "positions", ",", "n_neighbors", "=", "8", ",", "max_dist", "=", "np", ".", "inf", ",", "eps", "=", "0.0", ",", "\n", "power", "=", "1.0", ",", "reg", "=", "0.0", ",", "conf_dist", "=", "1e-12", ",", "fill_value", "=", "np", ".", "nan", ",", "\n", "dtype", "=", "float", ",", "workers", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the interpolator at the given positions.\n\n        Parameters\n        ----------\n        positions : float, 1D array-like, or NxM-array-like\n            Coordinates of the position(s) at which the interpolator\n            should be evaluated. In general, it is expected that these\n            coordinates are in a form of a NxM-like array where N is the\n            number of points and M is dimension of the coordinate space.\n            When M=1 (1D space), then the ``positions`` parameter may be\n            input as a 1D-like array or, if only one data point is\n            available, ``positions`` can be a scalar number representing\n            the 1D coordinate of the data point.\n\n            .. note::\n                If the dimensionality of the ``positions`` argument is\n                larger than 2, e.g., if it is of the form N1 x N2 x N3 x\n                ... x Nn x M, then it will be flattened to form an array\n                of size NxM where N = N1 * N2 * ... * Nn.\n\n            .. warning::\n                The dimensionality of ``positions`` must match the\n                dimensionality of the ``coordinates`` used during the\n                initialization of the interpolator.\n\n        n_neighbors : int, optional\n            The maximum number of nearest neighbors to use during the\n            interpolation.\n\n        max_dist : float, optional (ADDED PARAMETER)\n            The maximum radius within which neighbours are considered\n            during the interpolation.\n\n        eps : float, optional\n            Set to use approximate nearest neighbors; the kth neighbor\n            is guaranteed to be no further than (1 + ``eps``) times the\n            distance to the real *k*-th nearest neighbor. See\n            `scipy.spatial.cKDTree.query` for further information.\n\n        power : float, optional\n            The power of the inverse distance used for the interpolation\n            weights.  See the Notes section for more details.\n\n        reg : float, optional\n            The regularization parameter. It may be used to control the\n            smoothness of the interpolator. See the Notes section for\n            more details.\n\n        conf_dist : float, optional\n            The confusion distance below which the interpolator should\n            use the value of the closest data point instead of\n            attempting to interpolate. This is used to avoid\n            singularities at the known data points, especially if\n            ``reg`` is 0.0.\n\n        fill_value : float, optional. (ADDED PARAMETER)\n            Value to use when no neighbours meet the required max_dist.\n            Defaults to np.nan.\n\n        dtype : data-type, optional\n            The data type of the output interpolated values. If `None`\n            then the type will be inferred from the type of the\n            ``values`` parameter used during the initialization of the\n            interpolator.\n\n        workers : int, optional\n            How many CPU threads to use when querying the KD-tree (default 1).\n            This only has effect when len(positions) is large.\n        \"\"\"", "\n", "\n", "n_neighbors", "=", "int", "(", "n_neighbors", ")", "\n", "if", "n_neighbors", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'n_neighbors must be a positive integer'", ")", "\n", "\n", "", "if", "conf_dist", "is", "not", "None", "and", "conf_dist", "<=", "0.0", ":", "\n", "            ", "conf_dist", "=", "None", "\n", "\n", "", "positions", "=", "np", ".", "asanyarray", "(", "positions", ")", "\n", "if", "positions", ".", "ndim", "==", "0", ":", "\n", "# assume we have a single 1D coordinate", "\n", "            ", "if", "self", ".", "coords_ndim", "!=", "1", ":", "\n", "                ", "raise", "ValueError", "(", "'The dimensionality of the input position '", "\n", "'does not match the dimensionality of the '", "\n", "'coordinates used to initialize the '", "\n", "'interpolator.'", ")", "\n", "", "", "elif", "positions", ".", "ndim", "==", "1", ":", "\n", "# assume we have a single point", "\n", "            ", "if", "(", "self", ".", "coords_ndim", "!=", "1", "and", "\n", "(", "positions", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "coords_ndim", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'The input position was provided as a 1D '", "\n", "'array, but its length does not match the '", "\n", "'dimensionality of the coordinates used '", "\n", "'to initialize the interpolator.'", ")", "\n", "", "", "elif", "positions", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "ValueError", "(", "'The input positions must be an array-like '", "\n", "'object of dimensionality no larger than 2.'", ")", "\n", "\n", "", "positions", "=", "np", ".", "reshape", "(", "positions", ",", "(", "-", "1", ",", "self", ".", "coords_ndim", ")", ")", "\n", "npositions", "=", "positions", ".", "shape", "[", "0", "]", "\n", "\n", "distances", ",", "idx", "=", "self", ".", "kdtree", ".", "query", "(", "positions", ",", "k", "=", "n_neighbors", ",", "\n", "distance_upper_bound", "=", "max_dist", ",", "p", "=", "2", ",", "\n", "eps", "=", "eps", ",", "workers", "=", "workers", ")", "\n", "\n", "if", "dtype", "is", "None", ":", "\n", "            ", "dtype", "=", "self", ".", "values", ".", "dtype", "\n", "\n", "", "interp_values", "=", "np", ".", "empty", "(", "npositions", ",", "dtype", "=", "dtype", ")", "\n", "interp_values", ".", "fill", "(", "fill_value", ")", "\n", "\n", "if", "n_neighbors", "==", "1", ":", "\n", "            ", "valid_idx", "=", "np", ".", "isfinite", "(", "distances", ")", "\n", "interp_values", "[", "valid_idx", "]", "=", "self", ".", "values", "[", "valid_idx", "]", "\n", "", "else", ":", "\n", "# TODO: can this loop be optimised / parallelised (should be", "\n", "# possible, computations are independent.)", "\n", "            ", "for", "k", "in", "range", "(", "npositions", ")", ":", "\n", "                ", "valid_idx", "=", "np", ".", "isfinite", "(", "distances", "[", "k", "]", ")", "\n", "idk", "=", "idx", "[", "k", "]", "[", "valid_idx", "]", "\n", "dk", "=", "distances", "[", "k", "]", "[", "valid_idx", "]", "\n", "\n", "if", "dk", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                    ", "interp_values", "[", "k", "]", "=", "fill_value", "\n", "continue", "\n", "\n", "", "if", "self", ".", "method", "==", "'idw'", ":", "\n", "                    ", "if", "conf_dist", "is", "not", "None", ":", "\n", "# check if we are close to a known data point", "\n", "                        ", "confused", "=", "(", "dk", "<=", "conf_dist", ")", "\n", "if", "np", ".", "any", "(", "confused", ")", ":", "\n", "                            ", "interp_values", "[", "k", "]", "=", "self", ".", "values", "[", "idk", "[", "confused", "]", "[", "0", "]", "]", "\n", "continue", "\n", "\n", "", "", "w", "=", "1.0", "/", "(", "(", "dk", "**", "power", ")", "+", "reg", ")", "\n", "if", "self", ".", "weights", "is", "not", "None", ":", "\n", "                        ", "w", "*=", "self", ".", "weights", "[", "idk", "]", "\n", "\n", "", "wtot", "=", "np", ".", "sum", "(", "w", ")", "\n", "if", "wtot", ">", "0.0", ":", "\n", "                        ", "interp_values", "[", "k", "]", "=", "np", ".", "dot", "(", "w", ",", "self", ".", "values", "[", "idk", "]", ")", "/", "wtot", "\n", "", "else", ":", "\n", "                        ", "interp_values", "[", "k", "]", "=", "fill_value", "\n", "", "", "elif", "self", ".", "method", "==", "'max'", ":", "\n", "                    ", "interp_values", "[", "k", "]", "=", "np", ".", "max", "(", "self", ".", "values", "[", "idk", "]", ")", "\n", "\n", "", "", "", "if", "len", "(", "interp_values", ")", "==", "1", ":", "\n", "            ", "return", "interp_values", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "interp_values", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.interpolation.FastGridInterpolator.__init__": [[329, 335], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "grid_x", ",", "grid_y", ",", "values", ")", ":", "\n", "        ", "step_x", "=", "grid_x", "[", "1", "]", "-", "grid_x", "[", "0", "]", "\n", "step_y", "=", "grid_y", "[", "0", "]", "-", "grid_y", "[", "1", "]", "\n", "self", ".", "bin_x", "=", "grid_x", "-", "(", "step_x", "/", "2", ")", "\n", "self", ".", "bin_y", "=", "grid_y", "+", "(", "step_y", "/", "2", ")", "\n", "self", ".", "values", "=", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.interpolation.FastGridInterpolator.__call__": [[336, 349], ["numpy.digitize", "numpy.digitize"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "positions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the interpolator at the given positions.\n\n        Parameters\n        ----------\n        positions : array of shape (Np, 2)\n            Array of points to query. The first column contains the x-values,\n            the second column contains the y-values.\n        \"\"\"", "\n", "x_idx", "=", "np", ".", "digitize", "(", "positions", "[", ":", ",", "0", "]", ",", "self", ".", "bin_x", ")", "-", "1", "\n", "y_idx", "=", "np", ".", "digitize", "(", "positions", "[", ":", ",", "1", "]", ",", "self", ".", "bin_y", ",", "right", "=", "True", ")", "-", "1", "\n", "return", "self", ".", "values", "[", "y_idx", ",", "x_idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader.COLUMNS": [[34, 39], ["None"], "methods", ["None"], ["@", "property", "\n", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "COLUMNS", "(", "cls", ")", ":", "\n", "        ", "return", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader.__init__": [[40, 65], ["abc.ABC.__init__", "pandas.DataFrame", "print", "print", "print", "print", "bgt_utils.BGTReader._read_file", "os.path.isdir", "os.path.isfile", "pathlib.Path", "bgt_utils.BGTReader._read_folder", "logger.error", "type", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader._read_file", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader._read_folder"], ["", "def", "__init__", "(", "self", ",", "bgt_file", "=", "None", ",", "bgt_folder", "=", "None", ",", "file_prefix", "=", "''", ")", ":", "\n", "        ", "if", "(", "bgt_file", "is", "None", ")", "and", "(", "bgt_folder", "is", "None", ")", ":", "\n", "            ", "print", "(", "\"Provide either a bgt_file or bgt_folder to load.\"", ")", "\n", "return", "None", "\n", "", "if", "(", "bgt_file", "is", "not", "None", ")", "and", "(", "bgt_folder", "is", "not", "None", ")", ":", "\n", "            ", "print", "(", "\"Provide either a bgt_file or bgt_folder to load, not both\"", ")", "\n", "return", "None", "\n", "", "if", "(", "bgt_folder", "is", "not", "None", ")", "and", "(", "not", "os", ".", "path", ".", "isdir", "(", "bgt_folder", ")", ")", ":", "\n", "            ", "print", "(", "'The data folder specified does not exist'", ")", "\n", "return", "None", "\n", "", "if", "(", "bgt_file", "is", "not", "None", ")", "and", "(", "not", "os", ".", "path", ".", "isfile", "(", "bgt_file", ")", ")", ":", "\n", "            ", "print", "(", "'The data file specified does not exist'", ")", "\n", "return", "None", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "file_prefix", "=", "file_prefix", "\n", "self", ".", "bgt_df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "type", "(", "self", ")", ".", "COLUMNS", ")", "\n", "\n", "if", "bgt_file", "is", "not", "None", ":", "\n", "            ", "self", ".", "_read_file", "(", "Path", "(", "bgt_file", ")", ")", "\n", "", "elif", "bgt_folder", "is", "not", "None", ":", "\n", "            ", "self", ".", "_read_folder", "(", "Path", "(", "bgt_folder", ")", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "error", "(", "'No data folder or file specified. Aborting...'", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader._read_folder": [[66, 79], ["pandas.concat", "pandas.read_csv", "len", "logger.error", "path.glob", "type", "path.as_posix"], "methods", ["None"], ["", "", "def", "_read_folder", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"\n        Read the contents of the folder. Internally, a DataFrame is created\n        detailing the polygons and bounding boxes of each building found in the\n        CSV files in that folder.\n        \"\"\"", "\n", "file_match", "=", "self", ".", "file_prefix", "+", "'*.csv'", "\n", "frames", "=", "[", "pd", ".", "read_csv", "(", "file", ",", "header", "=", "0", ",", "names", "=", "type", "(", "self", ")", ".", "COLUMNS", ")", "\n", "for", "file", "in", "path", ".", "glob", "(", "file_match", ")", "]", "\n", "if", "len", "(", "frames", ")", "==", "0", ":", "\n", "            ", "logger", ".", "error", "(", "f'No data files found in {path.as_posix()}.'", ")", "\n", "return", "\n", "", "self", ".", "bgt_df", "=", "pd", ".", "concat", "(", "frames", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader._read_file": [[80, 87], ["pandas.read_csv", "type"], "methods", ["None"], ["", "def", "_read_file", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"\n        Read the contents of a file. Internally, a DataFrame is created\n        detailing the polygons and bounding boxes of each building found in the\n        CSV files in that folder.\n        \"\"\"", "\n", "self", ".", "bgt_df", "=", "pd", ".", "read_csv", "(", "path", ",", "header", "=", "0", ",", "names", "=", "type", "(", "self", ")", ".", "COLUMNS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTReader.filter_tile": [[88, 95], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "filter_tile", "(", "self", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns data for the area represented by the given CycloMedia\n        tile-code.\n        \"\"\"", "\n", "return", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTPointReader.filter_tile": [[105, 127], ["utils.las_utils.get_bbox_from_tile_code", "bgt_utils.BGTPointReader.bgt_df.query", "list", "len", "len", "bgt_utils.BGTPointReader.to_records"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code"], ["def", "filter_tile", "(", "self", ",", "tilecode", ",", "bgt_types", "=", "[", "]", ",", "exclude_types", "=", "[", "]", ",", "\n", "padding", "=", "0", ",", "return_types", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Return a list of points representing each of the objects found in the\n        area represented by the given CycloMedia tile-code.\n        \"\"\"", "\n", "(", "(", "bx_min", ",", "by_max", ")", ",", "(", "bx_max", ",", "by_min", ")", ")", "=", "get_bbox_from_tile_code", "(", "tilecode", ",", "padding", "=", "padding", ")", "\n", "type_str", "=", "''", "\n", "if", "len", "(", "bgt_types", ")", ">=", "1", ":", "\n", "            ", "type_str", "+=", "'(bgt_type == @bgt_types) & '", "\n", "", "if", "len", "(", "exclude_types", ")", ">=", "1", ":", "\n", "            ", "type_str", "+=", "'(bgt_type != @exclude_types) & '", "\n", "", "df", "=", "self", ".", "bgt_df", ".", "query", "(", "type_str", "+", "\n", "'(x <= @bx_max) & (x >= @bx_min)'", "+", "\n", "' & (y <= @by_max) & (y >= @by_min)'", ")", "\n", "bgt_points", "=", "list", "(", "df", ".", "to_records", "(", "index", "=", "False", ")", ")", "\n", "\n", "if", "return_types", ":", "\n", "            ", "return", "bgt_points", "\n", "", "else", ":", "\n", "            ", "return", "[", "(", "x", ",", "y", ")", "for", "(", "_", ",", "x", ",", "y", ")", "in", "bgt_points", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.BGTPolyReader.filter_tile": [[137, 167], ["utils.las_utils.get_bbox_from_tile_code", "bgt_utils.BGTPolyReader.bgt_df.query", "len", "len", "ast.literal_eval", "shapely.ops.unary_union", "len", "type", "list", "shapely.geometry.Polygon().buffer", "shapely.geometry.Polygon().buffer", "len", "shapely.geometry.Polygon", "shapely.geometry.Polygon"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code"], ["def", "filter_tile", "(", "self", ",", "tilecode", ",", "bgt_types", "=", "[", "]", ",", "exclude_types", "=", "[", "]", ",", "\n", "padding", "=", "0", ",", "offset", "=", "0", ",", "merge", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Return a list of polygons found in the area represented by the given\n        CycloMedia tile-code.\n        \"\"\"", "\n", "(", "(", "bx_min", ",", "by_max", ")", ",", "(", "bx_max", ",", "by_min", ")", ")", "=", "get_bbox_from_tile_code", "(", "tilecode", ",", "padding", "=", "padding", ")", "\n", "type_str", "=", "''", "\n", "if", "len", "(", "bgt_types", ")", ">=", "1", ":", "\n", "            ", "type_str", "+=", "'(bgt_type == @bgt_types) & '", "\n", "", "if", "len", "(", "exclude_types", ")", ">=", "1", ":", "\n", "            ", "type_str", "+=", "'(bgt_type != @exclude_types) & '", "\n", "", "df", "=", "self", ".", "bgt_df", ".", "query", "(", "type_str", "+", "\n", "'(x_min < @bx_max) & (x_max > @bx_min)'", "+", "\n", "' & (y_min < @by_max) & (y_max > @by_min)'", ")", "\n", "polygons", "=", "[", "ast", ".", "literal_eval", "(", "poly", ")", "for", "poly", "in", "df", ".", "polygon", ".", "values", "]", "\n", "if", "len", "(", "polygons", ")", ">", "1", "and", "merge", ":", "\n", "            ", "union", "=", "unary_union", "(", "[", "Polygon", "(", "poly", ")", ".", "buffer", "(", "offset", ")", "\n", "for", "poly", "in", "polygons", "]", ")", "\n", "if", "type", "(", "union", ")", "==", "Polygon", ":", "\n", "                ", "poly_offset", "=", "[", "union", "]", "\n", "", "else", ":", "\n", "                ", "poly_offset", "=", "list", "(", "union", ".", "geoms", ")", "\n", "", "", "else", ":", "\n", "            ", "poly_offset", "=", "[", "Polygon", "(", "poly", ")", ".", "buffer", "(", "offset", ")", "\n", "for", "poly", "in", "polygons", "]", "\n", "", "poly_valid", "=", "[", "poly", "for", "poly", "in", "poly_offset", "\n", "if", "len", "(", "poly", ".", "exterior", ".", "coords", ")", ">", "1", "]", "\n", "return", "poly_valid", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_polygons": [[169, 173], ["bgt_utils.BGTPolyReader.filter_tile", "bgt_utils.BGTPolyReader"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile"], ["", "", "def", "get_polygons", "(", "bgt_file", ",", "tilecode", ",", "padding", "=", "0", ",", "offset", "=", "0", ",", "merge", "=", "False", ")", ":", "\n", "    ", "\"\"\"Get the polygons from a bgt_file for a specific tilecode.\"\"\"", "\n", "return", "BGTPolyReader", "(", "bgt_file", "=", "bgt_file", ")", ".", "filter_tile", "(", "\n", "tilecode", ",", "padding", "=", "padding", ",", "offset", "=", "offset", ",", "merge", "=", "merge", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.bgt_utils.get_points": [[175, 179], ["bgt_utils.BGTPointReader.filter_tile", "bgt_utils.BGTPointReader"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile"], ["", "def", "get_points", "(", "bgt_file", ",", "tilecode", ",", "padding", "=", "0", ",", "return_types", "=", "True", ")", ":", "\n", "    ", "\"\"\"Get the bgt point objects from a bgt_file for a specific tilecode.\"\"\"", "\n", "return", "BGTPointReader", "(", "bgt_file", "=", "bgt_file", ")", ".", "filter_tile", "(", "\n", "tilecode", ",", "padding", "=", "padding", ",", "return_types", "=", "return_types", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.NAME": [[28, 33], ["None"], "methods", ["None"], ["@", "property", "\n", "@", "classmethod", "\n", "@", "abstractmethod", "\n", "def", "NAME", "(", "cls", ")", ":", "\n", "        ", "return", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.__init__": [[34, 42], ["abc.ABC.__init__", "pathlib.Path", "ahn_utils.AHNReader.set_caching", "ahn_utils.AHNReader._clear_cache", "ahn_utils.AHNReader.path.exists", "print"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.set_caching", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache"], ["", "def", "__init__", "(", "self", ",", "data_folder", ",", "caching", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "path", "=", "Path", "(", "data_folder", ")", "\n", "self", ".", "set_caching", "(", "caching", ")", "\n", "self", ".", "_clear_cache", "(", ")", "\n", "if", "not", "self", ".", "path", ".", "exists", "(", ")", ":", "\n", "            ", "print", "(", "'Input folder does not exist.'", ")", "\n", "raise", "ValueError", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.filter_tile": [[43, 46], ["None"], "methods", ["None"], ["", "", "@", "abstractmethod", "\n", "def", "filter_tile", "(", "self", ",", "tilecode", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.set_caching": [[47, 55], ["hasattr", "ahn_utils.AHNReader._clear_cache", "logger.debug", "logger.debug"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache"], ["", "def", "set_caching", "(", "self", ",", "state", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'caching'", ")", "or", "(", "self", ".", "caching", "is", "not", "state", ")", ":", "\n", "            ", "self", ".", "caching", "=", "state", "\n", "if", "not", "self", ".", "caching", ":", "\n", "                ", "self", ".", "_clear_cache", "(", ")", "\n", "logger", ".", "debug", "(", "'Caching disabled.'", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "debug", "(", "'Caching enabled.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache": [[56, 58], ["None"], "methods", ["None"], ["", "", "", "def", "_clear_cache", "(", "self", ")", ":", "\n", "        ", "self", ".", "cache", "=", "{", "'tilecode'", ":", "''", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.cache_interpolator": [[59, 73], ["logger.info", "ahn_utils.AHNReader.set_caching", "ahn_utils.AHNReader.filter_tile", "utils.interpolation.FastGridInterpolator", "utils.interpolation.FastGridInterpolator.", "ahn_utils.AHNReader._clear_cache", "logger.error"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.set_caching", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache"], ["", "def", "cache_interpolator", "(", "self", ",", "tilecode", ",", "points", ",", "surface", "=", "'ground_surface'", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Caching {surface} for tile {tilecode}.'", ")", "\n", "self", ".", "set_caching", "(", "True", ")", "\n", "if", "self", ".", "cache", "[", "'tilecode'", "]", "!=", "tilecode", ":", "\n", "# Clear cache.", "\n", "            ", "self", ".", "_clear_cache", "(", ")", "\n", "", "ahn_tile", "=", "self", ".", "filter_tile", "(", "tilecode", ")", "\n", "if", "surface", "not", "in", "ahn_tile", ":", "\n", "            ", "logger", ".", "error", "(", "f'Unknown surface: {surface}.'", ")", "\n", "raise", "ValueError", "\n", "", "fast_z", "=", "FastGridInterpolator", "(", "\n", "ahn_tile", "[", "'x'", "]", ",", "ahn_tile", "[", "'y'", "]", ",", "ahn_tile", "[", "surface", "]", ")", "\n", "self", ".", "cache", "[", "'tilecode'", "]", "=", "tilecode", "\n", "self", ".", "cache", "[", "surface", "]", "=", "fast_z", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate": [[74, 103], ["ahn_utils.AHNReader.filter_tile", "utils.interpolation.FastGridInterpolator", "utils.interpolation.FastGridInterpolator.", "logger.error", "logger.error", "logger.error", "logger.debug", "logger.debug"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile"], ["", "def", "interpolate", "(", "self", ",", "tilecode", ",", "points", "=", "None", ",", "mask", "=", "None", ",", "\n", "surface", "=", "'ground_surface'", ")", ":", "\n", "        ", "if", "points", "is", "None", "and", "mask", "is", "None", ":", "\n", "            ", "logger", ".", "error", "(", "'Must provide either points or mask.'", ")", "\n", "raise", "ValueError", "\n", "", "if", "self", ".", "caching", "and", "mask", "is", "not", "None", ":", "\n", "# Try retrieving cache.", "\n", "            ", "if", "self", ".", "cache", "[", "'tilecode'", "]", "==", "tilecode", ":", "\n", "                ", "if", "surface", "in", "self", ".", "cache", ":", "\n", "                    ", "return", "self", ".", "cache", "[", "surface", "]", "[", "mask", "]", "\n", "", "else", ":", "\n", "                    ", "logger", ".", "debug", "(", "\n", "f'Surface {surface} not in cache for tile {tilecode}.'", ")", "\n", "", "", "", "elif", "self", ".", "caching", ":", "\n", "            ", "logger", ".", "debug", "(", "'Caching enabled but no mask provided.'", ")", "\n", "\n", "# No cache, fall back to FastGridInterpolator.", "\n", "", "if", "self", ".", "cache", "[", "'tilecode'", "]", "!=", "tilecode", "and", "points", "is", "None", ":", "\n", "            ", "logger", ".", "error", "(", "\n", "f'Tile {tilecode} not cached and no points provided.'", ")", "\n", "raise", "ValueError", "\n", "\n", "", "ahn_tile", "=", "self", ".", "filter_tile", "(", "tilecode", ")", "\n", "if", "surface", "not", "in", "ahn_tile", ":", "\n", "            ", "logger", ".", "error", "(", "f'Unknown surface: {surface}.'", ")", "\n", "raise", "ValueError", "\n", "", "fast_z", "=", "FastGridInterpolator", "(", "\n", "ahn_tile", "[", "'x'", "]", ",", "ahn_tile", "[", "'y'", "]", ",", "ahn_tile", "[", "surface", "]", ")", "\n", "return", "fast_z", "(", "points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.NPZReader.__init__": [[120, 122], ["ahn_utils.AHNReader.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "data_folder", ",", "caching", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "data_folder", ",", "caching", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.NPZReader.filter_tile": [[123, 139], ["ahn_utils.load_ahn_tile", "ahn_utils.NPZReader._clear_cache", "ahn_utils.load_ahn_tile", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.load_ahn_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.load_ahn_tile"], ["", "def", "filter_tile", "(", "self", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns an AHN tile dict for the area represented by the given\n        CycloMedia tile-code. TODO also implement geotiff?\n        \"\"\"", "\n", "if", "self", ".", "caching", ":", "\n", "            ", "if", "self", ".", "cache", "[", "'tilecode'", "]", "!=", "tilecode", ":", "\n", "                ", "self", ".", "_clear_cache", "(", ")", "\n", "self", ".", "cache", "[", "'tilecode'", "]", "=", "tilecode", "\n", "", "if", "'ahn_tile'", "not", "in", "self", ".", "cache", ":", "\n", "                ", "self", ".", "cache", "[", "'ahn_tile'", "]", "=", "load_ahn_tile", "(", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "'ahn_'", "+", "tilecode", "+", "'.npz'", ")", ")", "\n", "", "return", "self", ".", "cache", "[", "'ahn_tile'", "]", "\n", "", "else", ":", "\n", "            ", "return", "load_ahn_tile", "(", "\n", "os", ".", "path", ".", "join", "(", "self", ".", "path", ",", "'ahn_'", "+", "tilecode", "+", "'.npz'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.__init__": [[166, 178], ["ahn_utils.AHNReader.__init__", "pandas.DataFrame().set_index", "ahn_utils.GeoTIFFReader._readfolder", "pandas.DataFrame"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._readfolder"], ["def", "__init__", "(", "self", ",", "data_folder", ",", "caching", "=", "True", ",", "\n", "fill_gaps", "=", "True", ",", "max_gap_size", "=", "50", ",", "\n", "smoothen", "=", "True", ",", "smooth_thickness", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "data_folder", ",", "caching", ")", "\n", "self", ".", "fill_gaps", "=", "fill_gaps", "\n", "self", ".", "max_gap_size", "=", "max_gap_size", "\n", "self", ".", "smoothen", "=", "smoothen", "\n", "self", ".", "smooth_thickness", "=", "smooth_thickness", "\n", "self", ".", "ahn_df", "=", "(", "pd", ".", "DataFrame", "(", "columns", "=", "[", "'Filename'", ",", "'Path'", ",", "\n", "'Xmin'", ",", "'Ymax'", ",", "'Xmax'", ",", "'Ymin'", "]", ")", "\n", ".", "set_index", "(", "'Filename'", ")", ")", "\n", "self", ".", "_readfolder", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._readfolder": [[179, 209], ["ahn_utils.GeoTIFFReader.path.glob", "len", "print", "ahn_utils.GeoTIFFReader.ahn_df.sort_values", "tifffile.TiffFile", "file.as_posix", "print", "print", "ahn_utils.GeoTIFFReader.path.as_posix", "file.as_posix", "file.as_posix", "file.as_posix"], "methods", ["None"], ["", "def", "_readfolder", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Read the contents of the folder. Internally, a DataFrame is created\n        detailing the bounding boxes of each available file to help with the\n        area extraction.\n        \"\"\"", "\n", "file_match", "=", "\"M_*.TIF\"", "\n", "\n", "for", "file", "in", "self", ".", "path", ".", "glob", "(", "file_match", ")", ":", "\n", "            ", "with", "TiffFile", "(", "file", ".", "as_posix", "(", ")", ")", "as", "tiff", ":", "\n", "                ", "if", "not", "tiff", ".", "is_geotiff", ":", "\n", "                    ", "print", "(", "f'{file.as_posix()} is not a GeoTIFF file.'", ")", "\n", "", "elif", "(", "(", "tiff", ".", "geotiff_metadata", "[", "'ModelPixelScale'", "]", "[", "0", "]", "\n", "!=", "self", ".", "RESOLUTION", ")", "\n", "or", "(", "tiff", ".", "geotiff_metadata", "[", "'ModelPixelScale'", "]", "[", "1", "]", "\n", "!=", "self", ".", "RESOLUTION", ")", ")", ":", "\n", "                    ", "print", "(", "f'{file.as_posix()} has incorrect resolution.'", ")", "\n", "", "else", ":", "\n", "                    ", "(", "x", ",", "y", ")", "=", "tiff", ".", "geotiff_metadata", "[", "'ModelTiepoint'", "]", "[", "3", ":", "5", "]", "\n", "(", "h", ",", "w", ")", "=", "tiff", ".", "pages", "[", "0", "]", ".", "shape", "\n", "x_min", "=", "x", "-", "self", ".", "RESOLUTION", "/", "2", "\n", "y_max", "=", "y", "+", "self", ".", "RESOLUTION", "/", "2", "\n", "x_max", "=", "x_min", "+", "w", "*", "self", ".", "RESOLUTION", "\n", "y_min", "=", "y_max", "-", "h", "*", "self", ".", "RESOLUTION", "\n", "self", ".", "ahn_df", ".", "loc", "[", "file", ".", "name", "]", "=", "[", "file", ".", "as_posix", "(", ")", ",", "\n", "x_min", ",", "y_max", ",", "x_max", ",", "y_min", "]", "\n", "", "", "", "if", "len", "(", "self", ".", "ahn_df", ")", "==", "0", ":", "\n", "            ", "print", "(", "f'No GeoTIFF files found in {self.path.as_posix()}.'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ahn_df", ".", "sort_values", "(", "by", "=", "[", "'Xmin'", ",", "'Ymax'", "]", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._get_df": [[210, 213], ["None"], "methods", ["None"], ["", "", "def", "_get_df", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the DataFrame.\"\"\"", "\n", "return", "self", ".", "ahn_df", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._load_tile": [[214, 252], ["utils.las_utils.get_bbox_from_tile_code", "ahn_utils.GeoTIFFReader.ahn_df.query", "len", "print", "int", "int", "int", "int", "numpy.arange", "numpy.arange", "tifffile.imread", "numpy.array", "ahn_utils.fill_gaps", "ahn_utils.smoothen_edges", "zarr.open"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.fill_gaps", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.smoothen_edges"], ["", "def", "_load_tile", "(", "self", ",", "tilecode", ",", "fill_value", ")", ":", "\n", "        ", "\"\"\"Extract one tile from the GeoTIFF data.\"\"\"", "\n", "(", "(", "bx_min", ",", "by_max", ")", ",", "(", "bx_max", ",", "by_min", ")", ")", "=", "get_bbox_from_tile_code", "(", "tilecode", ")", "\n", "\n", "ahn_tile", "=", "{", "}", "\n", "\n", "# We first check if the entire area is within a single TIF tile.", "\n", "query_str", "=", "'''(Xmin <= @bx_min) & (Xmax >= @bx_max) \\\n                        & (Ymax >= @by_max) & (Ymin <= @by_min)'''", "\n", "target_frame", "=", "self", ".", "ahn_df", ".", "query", "(", "query_str", ")", "\n", "if", "len", "(", "target_frame", ")", "==", "0", ":", "\n", "            ", "print", "(", "f'No data found for {tilecode}'", ")", "\n", "return", "None", "\n", "", "else", ":", "\n", "# The area is within a single TIF tile, so we can easily return the", "\n", "# array.", "\n", "            ", "[", "path", ",", "x", ",", "y", ",", "w", ",", "h", "]", "=", "target_frame", ".", "iloc", "[", "0", "]", ".", "values", "\n", "with", "imread", "(", "path", ",", "aszarr", "=", "True", ")", "as", "store", ":", "\n", "                ", "z_data", "=", "np", ".", "array", "(", "zarr", ".", "open", "(", "store", ",", "mode", "=", "\"r\"", ")", ")", "\n", "", "x_start", "=", "int", "(", "(", "bx_min", "-", "x", ")", "/", "self", ".", "RESOLUTION", ")", "\n", "x_end", "=", "int", "(", "(", "bx_max", "-", "x", ")", "/", "self", ".", "RESOLUTION", ")", "\n", "y_start", "=", "int", "(", "(", "y", "-", "by_max", ")", "/", "self", ".", "RESOLUTION", ")", "\n", "y_end", "=", "int", "(", "(", "y", "-", "by_min", ")", "/", "self", ".", "RESOLUTION", ")", "\n", "ahn_tile", "[", "'x'", "]", "=", "np", ".", "arange", "(", "bx_min", "+", "self", ".", "RESOLUTION", "/", "2", ",", "\n", "bx_max", ",", "self", ".", "RESOLUTION", ")", "\n", "ahn_tile", "[", "'y'", "]", "=", "np", ".", "arange", "(", "by_max", "-", "self", ".", "RESOLUTION", "/", "2", ",", "\n", "by_min", ",", "-", "self", ".", "RESOLUTION", ")", "\n", "ahn_tile", "[", "'ground_surface'", "]", "=", "z_data", "[", "y_start", ":", "y_end", ",", "x_start", ":", "x_end", "]", "\n", "fill_mask", "=", "ahn_tile", "[", "'ground_surface'", "]", ">", "1e5", "\n", "ahn_tile", "[", "'ground_surface'", "]", "[", "fill_mask", "]", "=", "fill_value", "\n", "if", "self", ".", "fill_gaps", ":", "\n", "                ", "fill_gaps", "(", "\n", "ahn_tile", ",", "max_gap_size", "=", "self", ".", "max_gap_size", ",", "inplace", "=", "True", ")", "\n", "", "if", "self", ".", "smoothen", ":", "\n", "                ", "smoothen_edges", "(", "\n", "ahn_tile", ",", "thickness", "=", "self", ".", "smooth_thickness", ",", "inplace", "=", "True", ")", "\n", "", "return", "ahn_tile", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile": [[253, 285], ["ahn_utils.GeoTIFFReader._load_tile", "ahn_utils.GeoTIFFReader._clear_cache", "ahn_utils.GeoTIFFReader._load_tile"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._load_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader._clear_cache", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader._load_tile"], ["", "", "def", "filter_tile", "(", "self", ",", "tilecode", ",", "fill_value", "=", "np", ".", "nan", ")", ":", "\n", "        ", "\"\"\"\n        Return a dictionary <X, Y, Z> representing the Z-values of the <X, Y>\n        area corresponding to the given tilecode. The points are equally spaced\n        with a resolution of 0.5m, heights are copied directly from the AHN\n        GeoTIFF data. Missing data is filled with 'fill_value'.\n\n        NOTE: This function assumes that the full tilecode is enclosed in a\n        single AHN GEoTIFF tile. This assumption is valid for standard AHN data\n        and CycloMedia tilecodes.\n\n        Parameters\n        ----------\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n        fill_value : float or np.nan (default: np.nan)\n            Value used to fill missing data.\n\n        Returns\n        -------\n        A dict containing AHN Z-values for the requested area, as well as the X\n        and Y coordinate axes.\n        \"\"\"", "\n", "if", "self", ".", "caching", ":", "\n", "            ", "if", "self", ".", "cache", "[", "'tilecode'", "]", "!=", "tilecode", ":", "\n", "                ", "self", ".", "_clear_cache", "(", ")", "\n", "self", ".", "cache", "[", "'tilecode'", "]", "=", "tilecode", "\n", "", "if", "'ahn_tile'", "not", "in", "self", ".", "cache", ":", "\n", "                ", "self", ".", "cache", "[", "'ahn_tile'", "]", "=", "self", ".", "_load_tile", "(", "tilecode", ",", "fill_value", ")", "\n", "", "return", "self", ".", "cache", "[", "'ahn_tile'", "]", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_load_tile", "(", "tilecode", ",", "fill_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.load_ahn_tile": [[287, 303], ["numpy.load", "os.path.isfile", "ahn_utils.AHNFileNotFoundError", "ahn[].astype", "ahn[].astype"], "function", ["None"], ["", "", "", "def", "load_ahn_tile", "(", "ahn_file", ")", ":", "\n", "    ", "\"\"\"\n    Load the ground and building surface grids in a given AHN .npz file and\n    return the results as a dict with keys 'x', 'y', 'ground_surface' and\n    'building_surface'.\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "ahn_file", ")", ":", "\n", "        ", "msg", "=", "f'Tried loading {ahn_file} but file does not exist.'", "\n", "raise", "AHNFileNotFoundError", "(", "msg", ")", "\n", "\n", "", "ahn", "=", "np", ".", "load", "(", "ahn_file", ")", "\n", "ahn_tile", "=", "{", "'x'", ":", "ahn", "[", "'x'", "]", ",", "\n", "'y'", ":", "ahn", "[", "'y'", "]", ",", "\n", "'ground_surface'", ":", "ahn", "[", "'ground'", "]", ".", "astype", "(", "float", ")", ",", "\n", "'building_surface'", ":", "ahn", "[", "'building'", "]", ".", "astype", "(", "float", ")", "}", "\n", "return", "ahn_tile", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils._get_gap_coordinates": [[305, 344], ["numpy.isnan", "scipy.ndimage.measurements.label", "numpy.arange", "scipy.ndimage.measurements.sum", "numpy.empty", "numpy.isnan", "numpy.vstack", "numpy.argwhere"], "function", ["None"], ["", "def", "_get_gap_coordinates", "(", "ahn_tile", ",", "max_gap_size", "=", "50", ",", "gap_flag", "=", "np", ".", "nan", ")", ":", "\n", "    ", "\"\"\"\n    Helper method. Get the coordinates of gap pixels in the AHN data. The\n    max_gap_size determines the maximum size of gaps (in AHN pixels) that will\n    be considered.\n\n    Parameters\n    ----------\n    ahn_tile : dict\n        E.g., output of GeoTIFFReader.filter_tile(.).\n    max_gap_size : int (default: 50)\n        The maximum size (in grid cells) for gaps to be considered.\n    gap_flag : float (default: np.nan)\n        Flag used for missing data.\n\n    Returns\n    -------\n    An array of shape (n_pixes, 2) containing the [x, y] coordinates of the gap\n    pixels.\n    \"\"\"", "\n", "# Create a boolean mask for gaps.", "\n", "if", "np", ".", "isnan", "(", "gap_flag", ")", ":", "\n", "        ", "gaps", "=", "np", ".", "isnan", "(", "ahn_tile", "[", "'ground_surface'", "]", ")", "\n", "", "else", ":", "\n", "        ", "gaps", "=", "(", "ahn_tile", "[", "'ground_surface'", "]", "==", "gap_flag", ")", "\n", "\n", "# Find connected components in the gaps mask and compute their sizes.", "\n", "", "gap_ids", ",", "num_gaps", "=", "measurements", ".", "label", "(", "gaps", ")", "\n", "ids", "=", "np", ".", "arange", "(", "num_gaps", "+", "1", ")", "\n", "gap_sizes", "=", "measurements", ".", "sum", "(", "gaps", ",", "gap_ids", ",", "index", "=", "ids", ")", "\n", "\n", "# Collect all gap coordinates.", "\n", "gap_coords", "=", "np", ".", "empty", "(", "shape", "=", "(", "0", ",", "2", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", "in", "ids", ":", "\n", "        ", "if", "0", "<", "gap_sizes", "[", "i", "]", "<=", "max_gap_size", ":", "\n", "# The lower bound 0 is used to ignore the 'non-gap' cluster which", "\n", "# has size 0.", "\n", "            ", "gap_coords", "=", "np", ".", "vstack", "(", "[", "gap_coords", ",", "np", ".", "argwhere", "(", "gap_ids", "==", "i", ")", "]", ")", "\n", "", "", "return", "gap_coords", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.fill_gaps": [[346, 401], ["ahn_utils._get_gap_coordinates", "numpy.isnan", "numpy.arange", "numpy.arange", "numpy.meshgrid", "scipy.interpolate.griddata", "len", "len", "copy.deepcopy", "numpy.isnan", "[].ravel"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils._get_gap_coordinates"], ["", "def", "fill_gaps", "(", "ahn_tile", ",", "max_gap_size", "=", "50", ",", "gap_flag", "=", "np", ".", "nan", ",", "inplace", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Fill gaps in the AHN ground surface by interpolation. The max_gap_size\n    determines the maximum size of gaps (in AHN pixels) that will be\n    considered. A copy of the AHN tile will be returned, unless 'inplace' is\n    set to True in which case None will be returned.\n\n    Parameters\n    ----------\n    ahn_tile : dict\n        E.g., output of GeoTIFFReader.filter_tile(.).\n    max_gap_size : int (default: 50)\n        The maximum size for gaps to be considered.\n    gap_flag : float (default: np.nan)\n        Flag used for missing data.\n    inplace: bool (default: False)\n        Whether or not to modify the AHN tile in place.\n\n    Returns\n    -------\n    If inplace=false, a copy of the AHN tile with filled gaps is returned.\n    Else, None is returned.\n    \"\"\"", "\n", "# Get the coodinates of gap pizels to consider.", "\n", "gap_coords", "=", "_get_gap_coordinates", "(", "ahn_tile", ",", "max_gap_size", "=", "max_gap_size", ",", "\n", "gap_flag", "=", "gap_flag", ")", "\n", "\n", "# Mask the z-data to exclude gaps.", "\n", "if", "np", ".", "isnan", "(", "gap_flag", ")", ":", "\n", "        ", "mask", "=", "~", "np", ".", "isnan", "(", "ahn_tile", "[", "'ground_surface'", "]", ")", "\n", "", "else", ":", "\n", "        ", "mask", "=", "~", "(", "ahn_tile", "[", "'ground_surface'", "]", "==", "gap_flag", ")", "\n", "\n", "# Get the interpolation values for the gaps.", "\n", "", "x", "=", "np", ".", "arange", "(", "0", ",", "len", "(", "ahn_tile", "[", "'x'", "]", ")", ")", "\n", "y", "=", "np", ".", "arange", "(", "0", ",", "len", "(", "ahn_tile", "[", "'y'", "]", ")", ")", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "x", ",", "y", ")", "\n", "# TODO: method='cubic' is just a default, we should check what works best", "\n", "# for us.", "\n", "int_values", "=", "interpolate", ".", "griddata", "(", "\n", "points", "=", "(", "xx", "[", "mask", "]", ",", "yy", "[", "mask", "]", ")", ",", "\n", "values", "=", "ahn_tile", "[", "'ground_surface'", "]", "[", "mask", "]", ".", "ravel", "(", ")", ",", "\n", "xi", "=", "(", "gap_coords", "[", ":", ",", "1", "]", ",", "gap_coords", "[", ":", ",", "0", "]", ")", ",", "\n", "method", "=", "'cubic'", ")", "\n", "\n", "# Return the filled AHN tile.", "\n", "if", "not", "inplace", ":", "\n", "        ", "filled_ahn", "=", "copy", ".", "deepcopy", "(", "ahn_tile", ")", "\n", "filled_ahn", "[", "'ground_surface'", "]", "[", "gap_coords", "[", ":", ",", "0", "]", ",", "gap_coords", "[", ":", ",", "1", "]", "]", "=", "int_values", "\n", "return", "filled_ahn", "\n", "", "else", ":", "\n", "        ", "ahn_tile", "[", "'ground_surface'", "]", "[", "gap_coords", "[", ":", ",", "0", "]", ",", "gap_coords", "[", ":", ",", "1", "]", "]", "=", "int_values", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.smoothen_edges": [[403, 454], ["numpy.isnan", "copy.deepcopy", "scipy.ndimage.morphology.binary_dilation", "warnings.catch_warnings", "warnings.simplefilter", "scipy.ndimage.generic_filter", "copy.deepcopy", "numpy.isnan", "numpy.ones"], "function", ["None"], ["", "", "def", "smoothen_edges", "(", "ahn_tile", ",", "thickness", "=", "1", ",", "gap_flag", "=", "np", ".", "nan", ",", "inplace", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Smoothen the edges of missing AHN ground surface data in the ahn_tile. In\n    effect, this 'pads' the ground surface around gaps by the given 'thickness'\n    and prevents small gaps around e.g. buildings when labelling a point cloud.\n    A copy of the AHN tile will be returned, unless 'inplace' is set to True in\n    which case None will be returned.\n\n    Parameters\n    ----------\n    ahn_tile : dict\n        E.g., output of GeoTIFFReader.filter_tile(.).\n    thickness : int (default: 1)\n        Thickness of the edge, for now only a value of 1 or 2 makes sense.\n    gap_flag : float (default: np.nan)\n        Flag used for missing data.\n    inplace: bool (default: False)\n        Whether or not to modify the AHN tile in place.\n\n    Returns\n    -------\n    If inplace=false, a copy of the AHN tile with smoothened edges is returned.\n    Else, None is returned.\n    \"\"\"", "\n", "if", "np", ".", "isnan", "(", "gap_flag", ")", ":", "\n", "        ", "mask", "=", "~", "np", ".", "isnan", "(", "ahn_tile", "[", "'ground_surface'", "]", ")", "\n", "z_data", "=", "ahn_tile", "[", "'ground_surface'", "]", "\n", "", "else", ":", "\n", "        ", "mask", "=", "~", "(", "ahn_tile", "[", "'ground_surface'", "]", "==", "gap_flag", ")", "\n", "z_data", "=", "copy", ".", "deepcopy", "(", "ahn_tile", "[", "'ground_surface'", "]", ")", "\n", "z_data", "[", "~", "mask", "]", "=", "np", ".", "nan", "\n", "\n", "# Find the edges of data gaps.", "\n", "", "edges", "=", "mask", "^", "binary_dilation", "(", "mask", ",", "iterations", "=", "thickness", ")", "\n", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ",", "category", "=", "RuntimeWarning", ")", "\n", "# Compute smoothened AHN data by taking the mean of surrounding pixel", "\n", "# values (ignoring NaNs).", "\n", "# TODO: a 'thickness' of more than 2 would require a bigger footprint.", "\n", "smoother", "=", "generic_filter", "(", "z_data", ",", "np", ".", "nanmean", ",", "\n", "footprint", "=", "np", ".", "ones", "(", "(", "3", ",", "3", ")", ",", "dtype", "=", "int", ")", ",", "\n", "mode", "=", "'constant'", ",", "cval", "=", "np", ".", "nan", ")", "\n", "\n", "", "if", "inplace", ":", "\n", "        ", "ahn_tile", "[", "'ground_surface'", "]", "[", "edges", "]", "=", "smoother", "[", "edges", "]", "\n", "return", "None", "\n", "", "else", ":", "\n", "        ", "smoothened_ahn", "=", "copy", ".", "deepcopy", "(", "ahn_tile", ")", "\n", "smoothened_ahn", "[", "'ground_surface'", "]", "[", "edges", "]", "=", "smoother", "[", "edges", "]", "\n", "return", "smoothened_ahn", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.vector_angle": [[9, 19], ["numba.jit", "numpy.array", "numpy.dot", "numpy.minimum", "numpy.rad2deg", "numpy.maximum", "numpy.arccos", "numpy.linalg.norm", "numpy.linalg.norm"], "function", ["None"], ["@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "vector_angle", "(", "u", ",", "v", "=", "np", ".", "array", "(", "[", "0.", ",", "0.", ",", "1.", "]", ")", ")", ":", "\n", "    ", "\"\"\"\n    Returns the angle in degrees between vectors 'u' and 'v'. If only 'u' is\n    provided, the angle between 'u' and the vertical axis is returned.\n    \"\"\"", "\n", "# see https://stackoverflow.com/a/2827466/425458", "\n", "c", "=", "np", ".", "dot", "(", "u", "/", "np", ".", "linalg", ".", "norm", "(", "u", ")", ",", "v", "/", "np", ".", "linalg", ".", "norm", "(", "v", ")", ")", "\n", "clip", "=", "np", ".", "minimum", "(", "1", ",", "np", ".", "maximum", "(", "c", ",", "-", "1", ")", ")", "\n", "return", "np", ".", "rad2deg", "(", "np", ".", "arccos", "(", "clip", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.get_octree_level": [[21, 34], ["numba.jit", "numpy.zeros", "range", "numpy.max", "numpy.rint", "numpy.int64", "numpy.max", "numpy.min", "numpy.log", "numpy.log"], "function", ["None"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "get_octree_level", "(", "points", ",", "grid_size", ")", ":", "\n", "    ", "\"\"\"Compute nearest octree level based on a desired grid_size.\"\"\"", "\n", "dims", "=", "np", ".", "zeros", "(", "(", "points", ".", "shape", "[", "1", "]", ",", ")", ")", "\n", "for", "d", "in", "range", "(", "points", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "dims", "[", "d", "]", "=", "np", ".", "max", "(", "points", "[", ":", ",", "d", "]", ")", "-", "np", ".", "min", "(", "points", "[", ":", ",", "d", "]", ")", "\n", "", "max_dim", "=", "np", ".", "max", "(", "dims", ")", "\n", "if", "max_dim", "<", "0.001", ":", "\n", "        ", "return", "0", "\n", "", "octree_level", "=", "np", ".", "rint", "(", "-", "np", ".", "log", "(", "grid_size", "/", "max_dim", ")", "/", "(", "np", ".", "log", "(", "2", ")", ")", ")", "\n", "if", "octree_level", ">", "0", ":", "\n", "        ", "return", "np", ".", "int64", "(", "octree_level", ")", "\n", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.compute_bounding_box": [[36, 58], ["numba.jit", "numpy.min", "numpy.max", "numpy.min", "numpy.max"], "function", ["None"], ["", "@", "jit", "(", "nopython", "=", "True", ",", "cache", "=", "True", ",", "parallel", "=", "True", ")", "\n", "def", "compute_bounding_box", "(", "points", ")", ":", "\n", "    ", "\"\"\"\n    Get the min/max values of a point list.\n\n    Parameters\n    ----------\n    points : array of shape (n_points, 2)\n        The (x, y) coordinates of the points. Any further dimensions will be\n        ignored.\n\n    Returns\n    -------\n    tuple\n        (x_min, y_min, x_max, y_max)\n    \"\"\"", "\n", "x_min", "=", "np", ".", "min", "(", "points", "[", ":", ",", "0", "]", ")", "\n", "x_max", "=", "np", ".", "max", "(", "points", "[", ":", ",", "0", "]", ")", "\n", "y_min", "=", "np", ".", "min", "(", "points", "[", ":", ",", "1", "]", ")", "\n", "y_max", "=", "np", ".", "max", "(", "points", "[", ":", ",", "1", "]", ")", "\n", "\n", "return", "(", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.convex_hull_poly": [[60, 64], ["shapely.geometry.Polygon", "numpy.vstack", "scipy.spatial.ConvexHull"], "function", ["None"], ["", "def", "convex_hull_poly", "(", "points", ")", ":", "\n", "    ", "\"\"\"Return convex hull as a shapely Polygon.\"\"\"", "\n", "hull", "=", "points", "[", "ConvexHull", "(", "points", ")", ".", "vertices", "]", "\n", "return", "Polygon", "(", "np", ".", "vstack", "(", "(", "hull", ",", "hull", "[", "0", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.minimum_bounding_rectangle": [[66, 132], ["numpy.zeros", "numpy.zeros", "numpy.arctan2", "numpy.abs", "numpy.unique", "rotations.reshape.reshape", "numpy.dot", "numpy.nanmin", "numpy.nanmax", "numpy.nanmin", "numpy.nanmax", "numpy.argmin", "numpy.dot", "numpy.zeros", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "len", "numpy.mod", "numpy.vstack", "min", "max", "scipy.spatial.ConvexHull", "len", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos"], "function", ["None"], ["", "def", "minimum_bounding_rectangle", "(", "points", ")", ":", "\n", "    ", "\"\"\"\n    Find the smallest bounding rectangle for a set of points.\n    Returns a set of points representing the corners of the bounding box.\n\n    :param points: an nx2 matrix of coordinates\n    :rval: an nx2 matrix of coordinates\n    \"\"\"", "\n", "pi2", "=", "np", ".", "pi", "/", "2.", "\n", "\n", "# get the convex hull for the points", "\n", "hull_points", "=", "points", "[", "ConvexHull", "(", "points", ")", ".", "vertices", "]", "\n", "\n", "# calculate edge angles", "\n", "edges", "=", "np", ".", "zeros", "(", "(", "len", "(", "hull_points", ")", "-", "1", ",", "2", ")", ")", "\n", "edges", "=", "hull_points", "[", "1", ":", "]", "-", "hull_points", "[", ":", "-", "1", "]", "\n", "\n", "angles", "=", "np", ".", "zeros", "(", "(", "len", "(", "edges", ")", ")", ")", "\n", "angles", "=", "np", ".", "arctan2", "(", "edges", "[", ":", ",", "1", "]", ",", "edges", "[", ":", ",", "0", "]", ")", "\n", "\n", "angles", "=", "np", ".", "abs", "(", "np", ".", "mod", "(", "angles", ",", "pi2", ")", ")", "\n", "angles", "=", "np", ".", "unique", "(", "angles", ")", "\n", "\n", "# find rotation matrices", "\n", "rotations", "=", "np", ".", "vstack", "(", "[", "\n", "np", ".", "cos", "(", "angles", ")", ",", "\n", "np", ".", "cos", "(", "angles", "-", "pi2", ")", ",", "\n", "np", ".", "cos", "(", "angles", "+", "pi2", ")", ",", "\n", "np", ".", "cos", "(", "angles", ")", "]", ")", ".", "T", "\n", "rotations", "=", "rotations", ".", "reshape", "(", "(", "-", "1", ",", "2", ",", "2", ")", ")", "\n", "\n", "# apply rotations to the hull", "\n", "rot_points", "=", "np", ".", "dot", "(", "rotations", ",", "hull_points", ".", "T", ")", "\n", "\n", "# find the bounding points", "\n", "min_x", "=", "np", ".", "nanmin", "(", "rot_points", "[", ":", ",", "0", "]", ",", "axis", "=", "1", ")", "\n", "max_x", "=", "np", ".", "nanmax", "(", "rot_points", "[", ":", ",", "0", "]", ",", "axis", "=", "1", ")", "\n", "min_y", "=", "np", ".", "nanmin", "(", "rot_points", "[", ":", ",", "1", "]", ",", "axis", "=", "1", ")", "\n", "max_y", "=", "np", ".", "nanmax", "(", "rot_points", "[", ":", ",", "1", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# find the box with the best area", "\n", "areas", "=", "(", "max_x", "-", "min_x", ")", "*", "(", "max_y", "-", "min_y", ")", "\n", "best_idx", "=", "np", ".", "argmin", "(", "areas", ")", "\n", "\n", "# return the best box", "\n", "x1", "=", "max_x", "[", "best_idx", "]", "\n", "x2", "=", "min_x", "[", "best_idx", "]", "\n", "y1", "=", "max_y", "[", "best_idx", "]", "\n", "y2", "=", "min_y", "[", "best_idx", "]", "\n", "r", "=", "rotations", "[", "best_idx", "]", "\n", "\n", "# Calculate center point and project onto rotated frame", "\n", "center_x", "=", "(", "x1", "+", "x2", ")", "/", "2", "\n", "center_y", "=", "(", "y1", "+", "y2", ")", "/", "2", "\n", "center_point", "=", "np", ".", "dot", "(", "[", "center_x", ",", "center_y", "]", ",", "r", ")", "\n", "\n", "min_bounding_rect", "=", "np", ".", "zeros", "(", "(", "4", ",", "2", ")", ")", "\n", "min_bounding_rect", "[", "0", "]", "=", "np", ".", "dot", "(", "[", "x1", ",", "y2", "]", ",", "r", ")", "\n", "min_bounding_rect", "[", "1", "]", "=", "np", ".", "dot", "(", "[", "x2", ",", "y2", "]", ",", "r", ")", "\n", "min_bounding_rect", "[", "2", "]", "=", "np", ".", "dot", "(", "[", "x2", ",", "y1", "]", ",", "r", ")", "\n", "min_bounding_rect", "[", "3", "]", "=", "np", ".", "dot", "(", "[", "x1", ",", "y1", "]", ",", "r", ")", "\n", "\n", "# Compute the dims of the min bounding rectangle", "\n", "dims", "=", "[", "(", "x1", "-", "x2", ")", ",", "(", "y1", "-", "y2", ")", "]", "\n", "\n", "return", "min_bounding_rect", ",", "hull_points", ",", "min", "(", "dims", ")", ",", "max", "(", "dims", ")", ",", "center_point", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.log_utils.LastPartFilter.filter": [[12, 15], ["record.name.rsplit"], "methods", ["None"], ["    ", "def", "filter", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name_last", "=", "record", ".", "name", ".", "rsplit", "(", "'.'", ",", "1", ")", "[", "-", "1", "]", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.log_utils.reset_logger": [[17, 21], ["logging.getLogger", "logging.getLogger.setLevel"], "function", ["None"], ["", "", "def", "reset_logger", "(", "base_level", "=", "BASE_LEVEL", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "BASE_NAME", ")", "\n", "logger", ".", "setLevel", "(", "base_level", ")", "\n", "logger", ".", "handlers", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.log_utils.add_console_logger": [[23, 32], ["logging.getLogger", "logging.StreamHandler", "logging.StreamHandler.set_name", "logging.StreamHandler.setLevel", "logging.Formatter", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler"], "function", ["None"], ["", "def", "add_console_logger", "(", "level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "BASE_NAME", ")", "\n", "ch", "=", "logging", ".", "StreamHandler", "(", "sys", ".", "stdout", ")", "\n", "ch", ".", "set_name", "(", "'UPCP Console Logger'", ")", "\n", "ch", ".", "setLevel", "(", "level", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\n", "'%(levelname)s - %(message)s'", ")", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.log_utils.add_file_logger": [[34, 51], ["pathlib.Path", "pathlib.Path.is_file", "logging.getLogger", "logging.FileHandler", "logging.FileHandler.set_name", "logging.FileHandler.setLevel", "logging.Formatter", "logging.FileHandler.setFormatter", "logging.FileHandler.addFilter", "logging.getLogger.addHandler", "pathlib.Path().mkdir", "log_utils.LastPartFilter", "open().close", "pathlib.Path", "open"], "function", ["None"], ["", "def", "add_file_logger", "(", "logfile", ",", "level", "=", "logging", ".", "DEBUG", ",", "clear_log", "=", "False", ")", ":", "\n", "    ", "log_path", "=", "pathlib", ".", "Path", "(", "logfile", ")", "\n", "if", "log_path", ".", "is_file", "(", ")", ":", "\n", "        ", "if", "clear_log", ":", "\n", "            ", "open", "(", "log_path", ",", "\"w\"", ")", ".", "close", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "pathlib", ".", "Path", "(", "log_path", ".", "parent", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", "BASE_NAME", ")", "\n", "fh", "=", "logging", ".", "FileHandler", "(", "log_path", ")", "\n", "fh", ".", "set_name", "(", "'UPCP File Logger'", ")", "\n", "fh", ".", "setLevel", "(", "level", ")", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\n", "'%(asctime)s - %(name)s - %(levelname)s - %(message)s'", ",", "\n", "datefmt", "=", "\"%Y-%m-%d %H:%M:%S\"", ")", "\n", "fh", ".", "setFormatter", "(", "formatter", ")", "\n", "fh", ".", "addFilter", "(", "LastPartFilter", "(", ")", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.log_utils.set_console_level": [[53, 58], ["logging.getLogger", "hl.get_name", "hl.setLevel"], "function", ["None"], ["", "def", "set_console_level", "(", "level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "BASE_NAME", ")", "\n", "for", "hl", "in", "logger", ".", "handlers", ":", "\n", "        ", "if", "hl", ".", "get_name", "(", ")", "==", "'UPCP Console Logger'", ":", "\n", "            ", "hl", ".", "setLevel", "(", "level", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename": [[11, 14], ["re.match"], "function", ["None"], ["def", "get_tilecode_from_filename", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Extract the tile code from a file name.\"\"\"", "\n", "return", "re", ".", "match", "(", "r'.*(\\d{4}_\\d{4}).*'", ",", "filename", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecodes_from_folder": [[16, 21], ["pathlib.Path().glob", "set", "pathlib.Path", "las_utils.get_tilecode_from_filename"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename"], ["", "def", "get_tilecodes_from_folder", "(", "las_folder", ",", "las_prefix", "=", "''", ")", ":", "\n", "    ", "\"\"\"Get a set of unique tilecodes for the LAS files in a given folder.\"\"\"", "\n", "files", "=", "pathlib", ".", "Path", "(", "las_folder", ")", ".", "glob", "(", "f'{las_prefix}*.laz'", ")", "\n", "tilecodes", "=", "set", "(", "[", "get_tilecode_from_filename", "(", "file", ".", "name", ")", "for", "file", "in", "files", "]", ")", "\n", "return", "tilecodes", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code": [[23, 53], ["tile_code.split", "int", "int"], "function", ["None"], ["", "def", "get_bbox_from_tile_code", "(", "tile_code", ",", "padding", "=", "0", ",", "width", "=", "50", ",", "height", "=", "50", ")", ":", "\n", "    ", "\"\"\"\n    Get the <X,Y> bounding box for a given tile code. The tile code is assumed\n    to represent the lower left corner of the tile.\n\n    Parameters\n    ----------\n    tile_code : str\n        The tile code, e.g. 2386_9702.\n    padding : float\n        Optional padding (in m) by which the bounding box will be extended.\n    width : int (default: 50)\n        The width of the tile.\n    height : int (default: 50)\n        The height of the tile.\n\n    Returns\n    -------\n    tuple of tuples\n        Bounding box with inverted y-axis: ((x_min, y_max), (x_max, y_min))\n    \"\"\"", "\n", "tile_split", "=", "tile_code", ".", "split", "(", "'_'", ")", "\n", "\n", "# The tile code of each tile is defined as", "\n", "# 'X-coordinaat/50'_'Y-coordinaat/50'", "\n", "x_min", "=", "int", "(", "tile_split", "[", "0", "]", ")", "*", "50", "\n", "y_min", "=", "int", "(", "tile_split", "[", "1", "]", ")", "*", "50", "\n", "\n", "return", "(", "(", "x_min", "-", "padding", ",", "y_min", "+", "height", "+", "padding", ")", ",", "\n", "(", "x_min", "+", "height", "+", "padding", ",", "y_min", "-", "padding", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_las_file": [[55, 77], ["las_utils.get_tilecode_from_filename", "las_utils.get_bbox_from_tile_code", "type", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_tilecode_from_filename", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_tile_code"], ["", "def", "get_bbox_from_las_file", "(", "laz_file", ",", "padding", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Get the <X,Y> bounding box for a given CycloMedia laz file, based on the\n    filename.\n\n    Parameters\n    ----------\n    laz_file : Path or str\n        the .laz filename, e.g. filtered_2386_9702.laz\n    padding : float\n        Optional padding (in m) by which the bounding box will be extended.\n\n    Returns\n    -------\n    tuple of tuples\n        Bounding box with inverted y-axis: ((x_min, y_max), (x_max, y_min))\n    \"\"\"", "\n", "if", "type", "(", "laz_file", ")", "==", "str", ":", "\n", "        ", "laz_file", "=", "pathlib", ".", "Path", "(", "laz_file", ")", "\n", "", "tile_code", "=", "get_tilecode_from_filename", "(", "laz_file", ".", "name", ")", "\n", "\n", "return", "get_bbox_from_tile_code", "(", "tile_code", ",", "padding", "=", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_las_folder": [[79, 108], ["las_utils.get_bbox_from_las_file", "min", "max", "min", "max", "glob.glob", "f.endswith", "os.path.join"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.get_bbox_from_las_file"], ["", "def", "get_bbox_from_las_folder", "(", "folder_path", ",", "padding", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Get the <X,Y> bounding box for a given folder of CycloMedia LAS files.\n\n    Parameters\n    ----------\n    folder_path : str or Path\n        The folder name.\n    padding : int (default: 0)\n        Optional padding (in meters).\n\n    Returns\n    -------\n    tuple of tuples\n        Bounding box with inverted y-axis: ((x_min, y_max), (x_max, y_min))\n    \"\"\"", "\n", "x_min", "=", "y_min", "=", "1e6", "\n", "x_max", "=", "y_max", "=", "0", "\n", "file_types", "=", "(", "'.LAS'", ",", "'.las'", ",", "'.LAZ'", ",", "'.laz'", ")", "\n", "\n", "for", "file", "in", "[", "f", "for", "f", "in", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "folder_path", ",", "'*'", ")", ")", "\n", "if", "f", ".", "endswith", "(", "file_types", ")", "]", ":", "\n", "        ", "bbox", "=", "get_bbox_from_las_file", "(", "file", ")", "\n", "x_min", "=", "min", "(", "x_min", ",", "bbox", "[", "0", "]", "[", "0", "]", ")", "\n", "x_max", "=", "max", "(", "x_max", ",", "bbox", "[", "1", "]", "[", "0", "]", ")", "\n", "y_min", "=", "min", "(", "y_min", ",", "bbox", "[", "1", "]", "[", "1", "]", ")", "\n", "y_max", "=", "max", "(", "y_max", ",", "bbox", "[", "0", "]", "[", "1", "]", ")", "\n", "\n", "", "return", "(", "(", "x_min", "-", "padding", ",", "y_max", "+", "padding", ")", ",", "(", "x_max", "+", "padding", ",", "y_min", "-", "padding", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.read_las": [[110, 113], ["laspy.read"], "function", ["None"], ["", "def", "read_las", "(", "las_file", ")", ":", "\n", "    ", "\"\"\"Read a las file and return the las object.\"\"\"", "\n", "return", "laspy", ".", "read", "(", "las_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.label_and_save_las": [[115, 123], ["las.write", "len", "las.add_extra_dim", "laspy.ExtraBytesParams"], "function", ["None"], ["", "def", "label_and_save_las", "(", "las", ",", "labels", ",", "outfile", ")", ":", "\n", "    ", "\"\"\"Label a las file using the provided class labels and save to outfile.\"\"\"", "\n", "assert", "len", "(", "labels", ")", "==", "las", ".", "header", ".", "point_count", "\n", "if", "'label'", "not", "in", "las", ".", "point_format", ".", "extra_dimension_names", ":", "\n", "        ", "las", ".", "add_extra_dim", "(", "laspy", ".", "ExtraBytesParams", "(", "name", "=", "\"label\"", ",", "type", "=", "\"uint8\"", ",", "\n", "description", "=", "\"Labels\"", ")", ")", "\n", "", "las", ".", "label", "=", "labels", "\n", "las", ".", "write", "(", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.las_utils.create_pole_las": [[125, 176], ["numpy.empty", "enumerate", "laspy.create", "numpy.min", "laspy.create.add_extra_dim", "laspy.create.write", "numpy.vstack", "isinstance", "point_labels.extend", "laspy.ExtraBytesParams", "type", "int", "int", "numpy.linspace", "numpy.linspace", "numpy.linspace", "numpy.stack", "len", "numpy.linspace"], "function", ["None"], ["", "def", "create_pole_las", "(", "outfile", ",", "point_objects", ",", "labels", "=", "0", ",", "z_step", "=", "0.1", ")", ":", "\n", "    ", "\"\"\"\n    Create a LAS file based on a set of given point objects. The LAS file will\n    contain columns of points visualising the given objects.\n\n    Parameters\n    ----------\n    outfile : str\n        Path to output file.\n    point_objects : list\n        Each entry represents one point object: (x, y, z, height) or\n        (bottom, top) as ((x, y, z), (x, y, z))\n    labels : int or list of integers (optional)\n        Either provide one label for all point objects, or a list of labels\n        (one for each object).\n    z_step : float (default: 0.1)\n        Resolution (step size) of the output columns in the z axis.\n    \"\"\"", "\n", "points", "=", "np", ".", "empty", "(", "(", "0", ",", "3", ")", ")", "\n", "point_labels", "=", "[", "]", "\n", "for", "i", ",", "obj", "in", "enumerate", "(", "point_objects", ")", ":", "\n", "        ", "if", "type", "(", "obj", "[", "1", "]", ")", "==", "int", ":", "\n", "            ", "loc", "=", "obj", "[", "0", "]", "\n", "height", "=", "obj", "[", "1", "]", "\n", "steps", "=", "int", "(", "height", "/", "z_step", ")", "\n", "obj_points", "=", "[", "[", "loc", "[", "0", "]", ",", "loc", "[", "1", "]", ",", "z", "]", "\n", "for", "z", "in", "np", ".", "linspace", "(", "loc", "[", "2", "]", ",", "loc", "[", "2", "]", "+", "height", ",", "steps", ")", "]", "\n", "", "else", ":", "\n", "            ", "bottom", "=", "obj", "[", "0", "]", "\n", "top", "=", "obj", "[", "1", "]", "\n", "steps", "=", "int", "(", "(", "top", "[", "2", "]", "-", "bottom", "[", "2", "]", ")", "/", "z_step", ")", "\n", "xs", "=", "np", ".", "linspace", "(", "bottom", "[", "0", "]", ",", "top", "[", "0", "]", ",", "steps", ")", "\n", "ys", "=", "np", ".", "linspace", "(", "bottom", "[", "1", "]", ",", "top", "[", "1", "]", ",", "steps", ")", "\n", "zs", "=", "np", ".", "linspace", "(", "bottom", "[", "2", "]", ",", "top", "[", "2", "]", ",", "steps", ")", "\n", "obj_points", "=", "np", ".", "stack", "(", "(", "xs", ",", "ys", ",", "zs", ")", ",", "axis", "=", "1", ")", "\n", "", "points", "=", "np", ".", "vstack", "(", "(", "points", ",", "obj_points", ")", ")", "\n", "if", "isinstance", "(", "labels", ",", "int", ")", ":", "\n", "            ", "obj_label", "=", "labels", "\n", "", "else", ":", "\n", "            ", "obj_label", "=", "labels", "[", "i", "]", "\n", "", "point_labels", ".", "extend", "(", "[", "obj_label", "]", "*", "len", "(", "obj_points", ")", ")", "\n", "\n", "", "las", "=", "laspy", ".", "create", "(", "file_version", "=", "\"1.2\"", ",", "point_format", "=", "3", ")", "\n", "las", ".", "header", ".", "offsets", "=", "np", ".", "min", "(", "points", ",", "axis", "=", "0", ")", "\n", "las", ".", "x", "=", "points", "[", ":", ",", "0", "]", "\n", "las", ".", "y", "=", "points", "[", ":", ",", "1", "]", "\n", "las", ".", "z", "=", "points", "[", ":", ",", "2", "]", "\n", "las", ".", "add_extra_dim", "(", "laspy", ".", "ExtraBytesParams", "(", "name", "=", "\"label\"", ",", "type", "=", "\"uint8\"", ",", "\n", "description", "=", "\"Labels\"", ")", ")", "\n", "las", ".", "label", "=", "point_labels", "\n", "las", ".", "write", "(", "outfile", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scrapers.ams_bgt_scraper.scrape_amsterdam_bgt": [[17, 49], ["requests.get", "requests.get.json", "str", "str", "str", "str"], "function", ["None"], ["def", "scrape_amsterdam_bgt", "(", "layer_name", ",", "bbox", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Scrape BGT layer information from the WFS.\n\n    Parameters\n    ----------\n    layer_name : str\n        Information about the different layers can be found at:\n        https://www.amsterdam.nl/stelselpedia/bgt-index/producten-bgt/prodspec-bgt-dgn-imgeo/\n\n    Returns\n    -------\n    The WFS response in JSON format or a dict.\n    \"\"\"", "\n", "params", "=", "'REQUEST=GetFeature&'", "'SERVICE=wfs&'", "'VERSION=2.0.0&'", "'TYPENAME='", "+", "layer_name", "+", "'&'", "\n", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "        ", "bbox_string", "=", "str", "(", "bbox", "[", "0", "]", "[", "0", "]", ")", "+", "','", "+", "str", "(", "bbox", "[", "0", "]", "[", "1", "]", ")", "+", "','", "+", "str", "(", "bbox", "[", "1", "]", "[", "0", "]", ")", "+", "','", "+", "str", "(", "bbox", "[", "1", "]", "[", "1", "]", ")", "\n", "params", "=", "params", "+", "'BBOX='", "+", "bbox_string", "+", "'&'", "\n", "\n", "", "params", "=", "params", "+", "'OUTPUTFORMAT=geojson'", "\n", "\n", "response", "=", "requests", ".", "get", "(", "WFS_URL", "+", "params", ")", "\n", "try", ":", "\n", "        ", "return", "response", ".", "json", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scrapers.ams_bgt_scraper.parse_polygons": [[51, 76], ["json_response[].split", "utils.math_utils.compute_bounding_box", "parsed_content.append", "parsed_content.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.compute_bounding_box"], ["", "", "def", "parse_polygons", "(", "json_response", ",", "include_bbox", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Parse the JSON content and transform it into a table structure.\n\n    Parameters\n    ----------\n    json_response : dict\n        JSON response from a WFS request.\n    include_bbox : bool (default: True)\n        Whether to include a bounding box for each poly.\n    \"\"\"", "\n", "parsed_content", "=", "[", "]", "\n", "name", "=", "'_'", ".", "join", "(", "json_response", "[", "'name'", "]", ".", "split", "(", "'_'", ")", "[", "2", ":", "]", ")", "\n", "for", "item", "in", "json_response", "[", "'features'", "]", ":", "\n", "# name = item['properties']['bgt_functie']", "\n", "        ", "polygon", "=", "item", "[", "'geometry'", "]", "[", "'coordinates'", "]", "[", "0", "]", "\n", "\n", "if", "include_bbox", ":", "\n", "            ", "(", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", ")", "=", "compute_bounding_box", "(", "\n", "np", ".", "array", "(", "polygon", ")", ")", "\n", "parsed_content", ".", "append", "(", "[", "name", ",", "polygon", ",", "x_min", ",", "y_max", ",", "x_max", ",", "y_min", "]", ")", "\n", "", "else", ":", "\n", "            ", "parsed_content", ".", "append", "(", "[", "name", ",", "polygon", "]", ")", "\n", "\n", "", "", "return", "parsed_content", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scrapers.ams_bgt_scraper.parse_points_bgtplus": [[78, 96], ["parsed_content.append"], "function", ["None"], ["", "def", "parse_points_bgtplus", "(", "json_response", ")", ":", "\n", "    ", "\"\"\"\n    Parse the JSON content and transform it into a table structure.\n\n    Parameters\n    ----------\n    json_response : dict\n        JSON response from a WFS request.\n    \"\"\"", "\n", "parsed_content", "=", "[", "]", "\n", "\n", "for", "item", "in", "json_response", "[", "'features'", "]", ":", "\n", "        ", "name", "=", "item", "[", "'properties'", "]", "[", "'plus_type'", "]", "\n", "point", "=", "item", "[", "'geometry'", "]", "[", "'coordinates'", "]", "\n", "\n", "parsed_content", ".", "append", "(", "[", "name", ",", "point", "[", "0", "]", ",", "point", "[", "1", "]", "]", ")", "\n", "\n", "", "return", "parsed_content", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scrapers.ndw_scraper.scrape_ndw": [[14, 31], ["requests.get", "requests.get.json"], "function", ["None"], ["def", "scrape_ndw", "(", "town_code", "=", "'GM0363'", ")", ":", "\n", "    ", "\"\"\"\n    Scrape traffic sign locations from the NDW API.\n\n    Parameters\n    ----------\n    town_code : str\n        Municipality code.\n\n    Returns\n    -------\n    The API response in JSON format or a dict.\n    \"\"\"", "\n", "base_url", "=", "URL", "+", "'town-code={}'", ".", "format", "(", "town_code", ")", "\n", "\n", "response", "=", "requests", ".", "get", "(", "base_url", ")", "\n", "return", "response", ".", "json", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scrapers.ndw_scraper.parse_traffic_signs": [[33, 61], ["parsed_content[].tolist.append", "numpy.array", "parsed_content[].astype", "parsed_content[].astype", "parsed_content[].tolist", "float", "float", "numpy.where"], "function", ["None"], ["", "def", "parse_traffic_signs", "(", "json_response", ",", "bbox", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Parse the JSON content and transform it into a table structure.\n\n    Parameters\n    ----------\n    json_response : dict\n        JSON response from a WFS request.\n    \"\"\"", "\n", "name", "=", "'verkeersbord'", "\n", "parsed_content", "=", "[", "]", "\n", "\n", "for", "item", "in", "json_response", ":", "\n", "        ", "point", "=", "item", "[", "'location'", "]", "[", "'rd'", "]", "\n", "\n", "parsed_content", ".", "append", "(", "[", "name", ",", "float", "(", "point", "[", "'x'", "]", ")", ",", "float", "(", "point", "[", "'y'", "]", ")", "]", ")", "\n", "\n", "", "if", "bbox", "is", "not", "None", ":", "\n", "# Filter for points inside the bbox", "\n", "        ", "(", "(", "bx_min", ",", "by_max", ")", ",", "(", "bx_max", ",", "by_min", ")", ")", "=", "bbox", "\n", "parsed_content", "=", "np", ".", "array", "(", "parsed_content", ")", "\n", "X", "=", "parsed_content", "[", ":", ",", "1", "]", ".", "astype", "(", "float", ")", "\n", "Y", "=", "parsed_content", "[", ":", ",", "2", "]", ".", "astype", "(", "float", ")", "\n", "\n", "mask", "=", "(", "X", "<", "bx_max", ")", "&", "(", "X", ">", "bx_min", ")", "&", "(", "Y", "<", "by_max", ")", "&", "(", "Y", ">", "by_min", ")", "\n", "parsed_content", "=", "parsed_content", "[", "np", ".", "where", "(", "mask", ")", "]", ".", "tolist", "(", ")", "\n", "\n", "", "return", "parsed_content", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing.__init__": [[20, 33], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "exclude_labels", "=", "[", "]", ",", "threshold_angle", "=", "20", ",", "\n", "threshold_curve", "=", "1.0", ",", "max_nn", "=", "30", ",", "grow_region_knn", "=", "15", ",", "\n", "grow_region_radius", "=", "0.2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "\"\"\" Init variables. \"\"\"", "\n", "self", ".", "threshold_angle", "=", "threshold_angle", "\n", "self", ".", "threshold_curve", "=", "threshold_curve", "\n", "\n", "self", ".", "max_nn", "=", "max_nn", "\n", "self", ".", "grow_region_knn", "=", "grow_region_knn", "\n", "self", ".", "grow_region_radius", "=", "grow_region_radius", "\n", "\n", "self", ".", "exclude_labels", "=", "exclude_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._set_mask": [[34, 50], ["numpy.ones", "list_of_indices.tolist", "numpy.zeros", "numpy.where", "len", "logger.debug", "numpy.where", "len", "len"], "methods", ["None"], ["", "def", "_set_mask", "(", "self", ",", "las_labels", ")", ":", "\n", "        ", "\"\"\" Configure the points that we want to perform region growing on. \"\"\"", "\n", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "las_labels", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "for", "exclude_label", "in", "self", ".", "exclude_labels", ":", "\n", "            ", "mask", "=", "mask", "&", "(", "las_labels", "!=", "exclude_label", ")", "\n", "\n", "", "list_of_indices", "=", "np", ".", "where", "(", "las_labels", "[", "mask", "]", "==", "self", ".", "label", ")", "[", "0", "]", "\n", "if", "len", "(", "list_of_indices", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "\n", "'Input point cloud does not contain any seed points.'", ")", "\n", "", "self", ".", "list_of_seed_ids", "=", "list_of_indices", ".", "tolist", "(", ")", "\n", "\n", "self", ".", "mask_indices", "=", "np", ".", "where", "(", "mask", ")", "[", "0", "]", "\n", "self", ".", "label_mask", "=", "np", ".", "zeros", "(", "len", "(", "mask", ")", ",", "dtype", "=", "bool", ")", "\n", "self", ".", "mask", "=", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._convert_input_cloud": [[51, 58], ["numpy.vstack().transpose", "open3d.geometry.PointCloud", "open3d.utility.Vector3dVector", "numpy.vstack"], "methods", ["None"], ["", "def", "_convert_input_cloud", "(", "self", ",", "las", ")", ":", "\n", "        ", "\"\"\" Function to convert to o3d point cloud. \"\"\"", "\n", "coords", "=", "np", ".", "vstack", "(", "(", "las", "[", "self", ".", "mask", ",", "0", "]", ",", "las", "[", "self", ".", "mask", ",", "1", "]", ",", "\n", "las", "[", "self", ".", "mask", ",", "2", "]", ")", ")", ".", "transpose", "(", ")", "\n", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", ")", "\n", "pcd", ".", "points", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "coords", ")", "\n", "self", ".", "pcd", "=", "pcd", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._compute_point_curvature": [[59, 74], ["open3d.utility.Vector3dVector", "open3d.geometry.PointCloud", "open3d.geometry.PointCloud.compute_mean_and_covariance", "numpy.linalg.eig", "pcd_tree.search_radius_vector_3d", "pcd_tree.search_knn_vector_3d", "eig_val.sum"], "methods", ["None"], ["", "def", "_compute_point_curvature", "(", "self", ",", "coords", ",", "pcd_tree", ",", "seed_point", ",", "method", ")", ":", "\n", "        ", "\"\"\" Compute the curvature for a given a cluster of points. \"\"\"", "\n", "if", "method", "==", "'radius'", ":", "\n", "            ", "_", ",", "idx", ",", "_", "=", "(", "pcd_tree", ".", "search_radius_vector_3d", "(", "\n", "seed_point", ",", "self", ".", "grow_region_radius", ")", ")", "\n", "", "else", ":", "\n", "            ", "_", ",", "idx", ",", "_", "=", "(", "pcd_tree", ".", "search_knn_vector_3d", "(", "\n", "seed_point", ",", "self", ".", "grow_region_knn", ")", ")", "\n", "\n", "", "neighbors", "=", "o3d", ".", "utility", ".", "Vector3dVector", "(", "coords", "[", "idx", "]", ")", "\n", "pcd", "=", "o3d", ".", "geometry", ".", "PointCloud", "(", "neighbors", ")", "\n", "_", ",", "cov", "=", "pcd", ".", "compute_mean_and_covariance", "(", ")", "\n", "eig_val", ",", "_", "=", "np", ".", "linalg", ".", "eig", "(", "cov", ")", "\n", "\n", "return", "(", "eig_val", "[", "0", "]", "/", "(", "eig_val", ".", "sum", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._region_growing": [[75, 142], ["copy.deepcopy", "open3d.geometry.KDTreeFlann", "region_growing.RegionGrowing.pcd.estimate_normals", "numpy.full", "len", "len", "open3d.geometry.KDTreeSearchParamHybrid", "open3d.geometry.KDTreeFlann.search_radius_vector_3d", "open3d.geometry.KDTreeFlann.search_knn_vector_3d", "utils.math_utils.vector_angle", "copy.deepcopy.append", "region_growing.RegionGrowing._compute_point_curvature", "numpy.asarray", "region_growing.RegionGrowing.list_of_seed_ids.append"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.vector_angle", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._compute_point_curvature"], ["", "def", "_region_growing", "(", "self", ",", "method", "=", "'knn'", ")", ":", "\n", "        ", "\"\"\"\n        The work of this region growing algorithm is based on the comparison\n        of the angles between the points normals.\n\n        The same can also be performed in Python using scipy.spatial.cKDTree\n        with query_ball_tree or query.\n        \"\"\"", "\n", "region", "=", "copy", ".", "deepcopy", "(", "self", ".", "list_of_seed_ids", ")", "\n", "\n", "# Compute the KDTree", "\n", "pcd_tree", "=", "o3d", ".", "geometry", ".", "KDTreeFlann", "(", "self", ".", "pcd", ")", "\n", "\n", "# Compute the normals for each point", "\n", "self", ".", "pcd", ".", "estimate_normals", "(", "\n", "search_param", "=", "o3d", ".", "geometry", ".", "KDTreeSearchParamHybrid", "(", "\n", "radius", "=", "self", ".", "grow_region_radius", ",", "\n", "max_nn", "=", "self", ".", "max_nn", ")", ")", "\n", "\n", "# Initialize the indexes of all seed points as processed", "\n", "processed", "=", "np", ".", "full", "(", "len", "(", "self", ".", "pcd", ".", "points", ")", ",", "False", ")", "\n", "processed", "[", "self", ".", "list_of_seed_ids", "]", "=", "True", "\n", "\n", "idx", "=", "0", "\n", "while", "idx", "<", "len", "(", "self", ".", "list_of_seed_ids", ")", ":", "\n", "            ", "seed_point", "=", "self", ".", "pcd", ".", "points", "[", "self", ".", "list_of_seed_ids", "[", "idx", "]", "]", "\n", "seed_normal", "=", "self", ".", "pcd", ".", "normals", "[", "self", ".", "list_of_seed_ids", "[", "idx", "]", "]", "\n", "\n", "# For every seed point, the algorithm finds its neighboring points", "\n", "if", "method", "==", "'radius'", ":", "\n", "                ", "k", ",", "neighbor_idx", ",", "_", "=", "(", "pcd_tree", ".", "search_radius_vector_3d", "(", "\n", "seed_point", ",", "self", ".", "grow_region_radius", ")", ")", "\n", "", "else", ":", "\n", "                ", "k", ",", "neighbor_idx", ",", "_", "=", "(", "pcd_tree", ".", "search_knn_vector_3d", "(", "seed_point", ",", "\n", "self", ".", "grow_region_knn", ")", ")", "\n", "\n", "# Remove index seed point itself", "\n", "", "neighbor_idx", "=", "neighbor_idx", "[", "1", ":", "k", "]", "\n", "\n", "for", "neighbor_id", "in", "neighbor_idx", ":", "\n", "# Is this point processed before?", "\n", "                ", "if", "processed", "[", "neighbor_id", "]", ":", "\n", "                    ", "continue", "\n", "\n", "# Compute angles between two n-dimensional vectors", "\n", "", "current_angle", "=", "vector_angle", "(", "seed_normal", ",", "\n", "self", ".", "pcd", ".", "normals", "[", "neighbor_id", "]", ")", "\n", "# The smoothness constraint in degrees", "\n", "if", "current_angle", "<", "self", ".", "threshold_angle", ":", "\n", "                    ", "region", ".", "append", "(", "neighbor_id", ")", "\n", "processed", "[", "neighbor_id", "]", "=", "True", "\n", "\n", "# Compute the curvature for a neighbor_id and its neighbors", "\n", "curvature", "=", "(", "self", ".", "_compute_point_curvature", "(", "\n", "np", ".", "asarray", "(", "self", ".", "pcd", ".", "points", ")", ",", "pcd_tree", ",", "\n", "self", ".", "pcd", ".", "points", "[", "neighbor_id", "]", ",", "method", ")", ")", "\n", "\n", "# Result is below threshold, we add it to the seed points", "\n", "if", "curvature", "<", "self", ".", "threshold_curve", ":", "\n", "                        ", "self", ".", "list_of_seed_ids", ".", "append", "(", "neighbor_id", ")", "\n", "\n", "", "", "", "idx", "=", "idx", "+", "1", "\n", "\n", "# Set the region grown points to True", "\n", "", "self", ".", "label_mask", "[", "self", ".", "mask_indices", "[", "region", "]", "]", "=", "True", "\n", "\n", "return", "self", ".", "label_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing.get_label_mask": [[143, 171], ["logger.info", "region_growing.RegionGrowing._set_mask", "region_growing.RegionGrowing._convert_input_cloud", "region_growing.RegionGrowing._region_growing", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._set_mask", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._convert_input_cloud", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.region_growing.RegionGrowing._region_growing", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            The labels corresponding to each point.\n        mask : array of shape (n_points,) with dtype=bool\n            Ignored by this class, use `exclude_labels` in the constructor\n            instead.\n        tilecode : str\n            Ignored by this class.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'KDTree based Region Growing '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "self", ".", "_set_mask", "(", "labels", ")", "\n", "self", ".", "_convert_input_cloud", "(", "points", ")", "\n", "label_mask", "=", "self", ".", "_region_growing", "(", ")", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.__init__": [[38, 47], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", "=", "-", "1", ",", "exclude_labels", "=", "[", "]", ",", "set_debug", "=", "False", ",", "\n", "grid_size", "=", "0.1", ",", "min_component_size", "=", "100", ",", "threshold", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "\"\"\" Init variables. \"\"\"", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "self", ".", "min_component_size", "=", "min_component_size", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "exclude_labels", "=", "exclude_labels", "\n", "self", ".", "debug", "=", "set_debug", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._set_mask": [[48, 52], ["None"], "methods", ["None"], ["", "def", "_set_mask", "(", "self", ")", ":", "\n", "        ", "\"\"\" Configure the points that we want to perform region growing on. \"\"\"", "\n", "for", "exclude_label", "in", "self", ".", "exclude_labels", ":", "\n", "            ", "self", ".", "mask", "=", "self", ".", "mask", "&", "(", "self", ".", "point_labels", "!=", "exclude_label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._convert_input_cloud": [[53, 80], ["points[].astype", "points[].astype", "pycc.ccPointCloud", "pycc.ccPointCloud.getScalarFieldIndexByName", "pycc.ccPointCloud.setCurrentScalarField", "utils.math_utils.get_octree_level", "numpy.zeros().astype", "points[].astype", "pycc.ccPointCloud.addScalarField", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.get_octree_level"], ["", "", "def", "_convert_input_cloud", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\" Function to convert to CloudCompare point cloud. \"\"\"", "\n", "# Be aware that CloudCompare stores coordinates on 32 bit floats.", "\n", "# To avoid losing too much precision you should 'shift' your", "\n", "# coordinates if they are 64 bit floats (which is the default in", "\n", "# python land)", "\n", "xs", "=", "(", "points", "[", "self", ".", "mask", ",", "0", "]", ")", ".", "astype", "(", "pycc", ".", "PointCoordinateType", ")", "\n", "ys", "=", "(", "points", "[", "self", ".", "mask", ",", "1", "]", ")", ".", "astype", "(", "pycc", ".", "PointCoordinateType", ")", "\n", "if", "points", ".", "shape", "[", "1", "]", "==", "2", ":", "\n", "            ", "zs", "=", "np", ".", "zeros", "(", "xs", ".", "shape", ")", ".", "astype", "(", "pycc", ".", "PointCoordinateType", ")", "\n", "", "else", ":", "\n", "            ", "zs", "=", "(", "points", "[", "self", ".", "mask", ",", "2", "]", ")", ".", "astype", "(", "pycc", ".", "PointCoordinateType", ")", "\n", "", "point_cloud", "=", "pycc", ".", "ccPointCloud", "(", "xs", ",", "ys", ",", "zs", ")", "\n", "\n", "# (Optional) Create (if it does not exists already)", "\n", "# a scalar field where we store the Labels", "\n", "labels_sf_idx", "=", "point_cloud", ".", "getScalarFieldIndexByName", "(", "'Labels'", ")", "\n", "if", "labels_sf_idx", "==", "-", "1", ":", "\n", "            ", "labels_sf_idx", "=", "point_cloud", ".", "addScalarField", "(", "'Labels'", ")", "\n", "", "point_cloud", ".", "setCurrentScalarField", "(", "labels_sf_idx", ")", "\n", "\n", "# Compute the octree level based on the grid_size", "\n", "self", ".", "octree_level", "=", "get_octree_level", "(", "points", ",", "self", ".", "grid_size", ")", "\n", "\n", "self", ".", "labels_sf_idx", "=", "labels_sf_idx", "\n", "# You can access the x,y,z fields using self.point_cloud.points()", "\n", "self", ".", "point_cloud", "=", "point_cloud", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._label_connected_comp": [[81, 98], ["cccorelib.AutoSegmentationTools.labelConnectedComponents", "label_connected_comp.LabelConnectedComp.point_cloud.getScalarField", "numpy.around", "label_connected_comp.LabelConnectedComp.asArray", "numpy.unique", "numpy.in1d"], "methods", ["None"], ["", "def", "_label_connected_comp", "(", "self", ")", ":", "\n", "        ", "\"\"\" Perform the clustering algorithm: Label Connected Components. \"\"\"", "\n", "(", "cccorelib", "\n", ".", "AutoSegmentationTools", "\n", ".", "labelConnectedComponents", "(", "self", ".", "point_cloud", ",", "level", "=", "self", ".", "octree_level", ")", ")", "\n", "\n", "# Get the scalar field with labels and points coords as numpy array", "\n", "labels_sf", "=", "self", ".", "point_cloud", ".", "getScalarField", "(", "self", ".", "labels_sf_idx", ")", "\n", "self", ".", "point_components", "=", "np", ".", "around", "(", "labels_sf", ".", "asArray", "(", ")", ")", "\n", "\n", "# Filter based on min_component_size", "\n", "if", "self", ".", "min_component_size", ">", "1", ":", "\n", "            ", "cc_labels", ",", "counts", "=", "np", ".", "unique", "(", "self", ".", "point_components", ",", "\n", "return_counts", "=", "True", ")", "\n", "cc_labels_filtered", "=", "cc_labels", "[", "counts", "<", "self", ".", "min_component_size", "]", "\n", "self", ".", "point_components", "[", "\n", "np", ".", "in1d", "(", "self", ".", "point_components", ",", "cc_labels_filtered", ")", "]", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._fill_components": [[99, 136], ["numpy.zeros", "numpy.unique", "set().difference", "logger.debug", "numpy.where", "len", "numpy.count_nonzero", "numpy.count_nonzero", "set", "float", "len"], "methods", ["None"], ["", "", "def", "_fill_components", "(", "self", ")", ":", "\n", "        ", "\"\"\" Clustering based region growing process. When one initial seed\n        point is found inside a component, make the whole component this\n        label. \"\"\"", "\n", "mask_indices", "=", "np", ".", "where", "(", "self", ".", "mask", ")", "[", "0", "]", "\n", "label_mask", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "mask", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "cc_labels", "=", "np", ".", "unique", "(", "self", ".", "point_components", ")", "\n", "cc_labels", "=", "set", "(", "cc_labels", ")", ".", "difference", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "cc_count", "=", "0", "\n", "\n", "for", "cc", "in", "cc_labels", ":", "\n", "# select points that belong to the cluster", "\n", "            ", "cc_mask", "=", "(", "self", ".", "point_components", "==", "cc", ")", "\n", "# cluster size", "\n", "# TODO is this still needed? (see line 77-80)", "\n", "cc_size", "=", "np", ".", "count_nonzero", "(", "cc_mask", ")", "\n", "if", "cc_size", "<", "self", ".", "min_component_size", ":", "\n", "                ", "continue", "\n", "# number of point in the cluster that are labelled as seed point", "\n", "", "seed_count", "=", "np", ".", "count_nonzero", "(", "\n", "self", ".", "point_labels", "[", "mask_indices", "[", "cc_mask", "]", "]", "==", "self", ".", "label", ")", "\n", "# at least X% of the cluster should be seed points", "\n", "if", "(", "float", "(", "seed_count", ")", "/", "cc_size", ")", ">", "self", ".", "threshold", ":", "\n", "                ", "label_mask", "[", "mask_indices", "[", "cc_mask", "]", "]", "=", "True", "\n", "cc_count", "+=", "1", "\n", "\n", "# Add label to the regions", "\n", "", "", "labels", "=", "self", ".", "point_labels", "\n", "labels", "[", "label_mask", "]", "=", "self", ".", "label", "\n", "\n", "logger", ".", "debug", "(", "f'Found {len(cc_labels)} clusters of '", "+", "\n", "f'>{self.min_component_size} points; '", "+", "\n", "f'{cc_count} added.'", ")", "\n", "\n", "return", "label_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_label_mask": [[137, 184], ["label_connected_comp.LabelConnectedComp._convert_input_cloud", "label_connected_comp.LabelConnectedComp._label_connected_comp", "label_connected_comp.LabelConnectedComp._fill_components", "logger.info", "logger.debug", "logger.warning", "numpy.ones", "label_connected_comp.LabelConnectedComp._set_mask", "numpy.ones", "mask.copy", "len", "len", "labels.Labels.get_str", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._convert_input_cloud", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._label_connected_comp", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._fill_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._set_mask", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", "=", "None", ",", "tilecode", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3) or (n_points, 2)\n            The point cloud <x, y, z>. If only two dimensions are provided, 'z'\n            is assumed to be all zeros.\n        labels : array of shape (n_points,)\n            The labels corresponding to each point.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points. Can be\n            overwritten by setting `exclude_labels` in the constructor.\n        tilecode : str\n            Ignored by this class.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "if", "not", "self", ".", "debug", ":", "\n", "            ", "logger", ".", "info", "(", "'Clustering based Region Growing '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "debug", "(", "'Clustering based Region Growing '", "+", "\n", "f'(label={self.label}, '", "+", "\n", "f'{Labels.get_str(self.label)}).'", ")", "\n", "", "if", "self", ".", "label", "==", "-", "1", ":", "\n", "            ", "logger", ".", "warning", "(", "'Label not set, defaulting to -1.'", ")", "\n", "", "self", ".", "point_labels", "=", "labels", "\n", "if", "self", ".", "exclude_labels", ":", "\n", "            ", "self", ".", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "self", ".", "_set_mask", "(", ")", "\n", "", "elif", "mask", "is", "None", ":", "\n", "            ", "self", ".", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mask", "=", "mask", ".", "copy", "(", ")", "\n", "# We need to un-mask all points of the desired class label.", "\n", "self", ".", "mask", "[", "labels", "==", "self", ".", "label", "]", "=", "True", "\n", "\n", "", "self", ".", "_convert_input_cloud", "(", "points", ")", "\n", "self", ".", "_label_connected_comp", "(", ")", "\n", "label_mask", "=", "self", ".", "_fill_components", "(", ")", "\n", "\n", "return", "label_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_components": [[185, 210], ["numpy.ones", "label_connected_comp.LabelConnectedComp._convert_input_cloud", "label_connected_comp.LabelConnectedComp._label_connected_comp", "label_connected_comp.LabelConnectedComp._set_mask", "len"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._convert_input_cloud", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._label_connected_comp", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp._set_mask"], ["", "def", "get_components", "(", "self", ",", "points", ",", "labels", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Simply get the components without caring about labels.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3) or (n_points, 2)\n            The point cloud <x, y, z>. If only two dimensions are provided, 'z'\n            is assumed to be all zeros.\n        labels : array of shape (n_points,)\n            The labels corresponding to each point. Optional, only used in\n            combination with `exclude_labels`.\n\n        Returns\n        -------\n        An array of shape (n_points,) with cluster labels for each point.\n        Clusters with a size less than `min_component_size` are labelled as -1.\n        \"\"\"", "\n", "self", ".", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "if", "labels", "is", "not", "None", "and", "self", ".", "exclude_labels", ":", "\n", "            ", "self", ".", "point_labels", "=", "labels", "\n", "self", ".", "_set_mask", "(", ")", "\n", "", "self", ".", "_convert_input_cloud", "(", "points", ")", "\n", "self", ".", "_label_connected_comp", "(", ")", "\n", "return", "self", ".", "point_components", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.layer_lcc.LayerLCC.__init__": [[49, 54], ["abstract_processor.AbstractProcessor.__init__", "layer_lcc.LayerLCC._set_defaults"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._set_defaults"], ["def", "__init__", "(", "self", ",", "label", ",", "ahn_reader", ",", "reset_noise", "=", "False", ",", "params", "=", "[", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "reset_noise", "=", "reset_noise", "\n", "self", ".", "params", "=", "self", ".", "_set_defaults", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.layer_lcc.LayerLCC._set_defaults": [[55, 69], ["None"], "methods", ["None"], ["", "def", "_set_defaults", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set defaults for parameters if not provided.\"\"\"", "\n", "for", "layer", "in", "params", ":", "\n", "            ", "if", "'bottom'", "not", "in", "layer", ":", "\n", "                ", "layer", "[", "'bottom'", "]", "=", "-", "np", ".", "inf", "\n", "", "if", "'top'", "not", "in", "layer", ":", "\n", "                ", "layer", "[", "'top'", "]", "=", "np", ".", "inf", "\n", "", "if", "'grid_size'", "not", "in", "layer", ":", "\n", "                ", "layer", "[", "'grid_size'", "]", "=", "0.1", "\n", "", "if", "'min_comp_size'", "not", "in", "layer", ":", "\n", "                ", "layer", "[", "'min_comp_size'", "]", "=", "100", "\n", "", "if", "'threshold'", "not", "in", "layer", ":", "\n", "                ", "layer", "[", "'threshold'", "]", "=", "0.5", "\n", "", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.layer_lcc.LayerLCC._filter_layer": [[70, 94], ["numpy.zeros", "numpy.count_nonzero", "region_growing.LabelConnectedComp", "region_growing.LabelConnectedComp.get_label_mask", "numpy.where", "len", "logger.debug", "logger.debug", "len"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.get_label_mask"], ["", "def", "_filter_layer", "(", "self", ",", "points", ",", "points_z", ",", "labels", ",", "params", ")", ":", "\n", "        ", "\"\"\"Process a layer of the region grower.\"\"\"", "\n", "height_mask_ids", "=", "np", ".", "where", "(", "\n", "(", "points", "[", ":", ",", "2", "]", ">", "points_z", "+", "params", "[", "'bottom'", "]", ")", "\n", "&", "(", "points", "[", ":", ",", "2", "]", "<=", "points_z", "+", "params", "[", "'top'", "]", ")", ")", "[", "0", "]", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "if", "len", "(", "height_mask_ids", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "\n", "f\"Empty layer: {params['bottom']} -> {params['top']}.\"", ")", "\n", "return", "mask", "\n", "", "n_valid", "=", "np", ".", "count_nonzero", "(", "labels", "[", "height_mask_ids", "]", "==", "self", ".", "label", ")", "\n", "if", "n_valid", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "f\"No marked points in layer: {params['bottom']}\"", "\n", "+", "f\" -> {params['top']}.\"", ")", "\n", "return", "mask", "\n", "\n", "", "lcc", "=", "LabelConnectedComp", "(", "self", ".", "label", ",", "set_debug", "=", "True", ",", "\n", "grid_size", "=", "params", "[", "'grid_size'", "]", ",", "\n", "min_component_size", "=", "params", "[", "'min_comp_size'", "]", ",", "\n", "threshold", "=", "params", "[", "'threshold'", "]", ")", "\n", "lcc_mask", "=", "lcc", ".", "get_label_mask", "(", "points", "=", "points", "[", "height_mask_ids", "]", ",", "\n", "labels", "=", "labels", "[", "height_mask_ids", "]", ")", "\n", "mask", "[", "height_mask_ids", "[", "lcc_mask", "]", "]", "=", "True", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.layer_lcc.LayerLCC.get_label_mask": [[95, 144], ["logger.info", "mask.copy", "layer_lcc.LayerLCC.ahn_reader.interpolate", "numpy.zeros", "numpy.zeros", "labels[].copy", "enumerate", "logger.debug", "len", "numpy.count_nonzero", "layer_lcc.LayerLCC._filter_layer", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.layer_lcc.LayerLCC._filter_layer", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            The labels corresponding to each point.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'LayerLCC '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}))'", ")", "\n", "\n", "# We need to un-mask all points of the desired class label.", "\n", "mask_copy", "=", "mask", ".", "copy", "(", ")", "\n", "mask_copy", "[", "labels", "==", "self", ".", "label", "]", "=", "True", "\n", "if", "self", ".", "reset_noise", ":", "\n", "            ", "noise_mask", "=", "labels", "==", "Labels", ".", "NOISE", "\n", "mask_copy", "[", "noise_mask", "]", "=", "True", "\n", "\n", "", "points_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask_copy", "]", ",", "mask_copy", ",", "'ground_surface'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "layer_mask", "=", "np", ".", "zeros", "(", "(", "np", ".", "count_nonzero", "(", "mask_copy", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "labels_copy", "=", "labels", "[", "mask_copy", "]", ".", "copy", "(", ")", "\n", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "params", ")", ":", "\n", "            ", "logger", ".", "debug", "(", "f'Layer {i}: {layer}'", ")", "\n", "layer_mask", "=", "layer_mask", "|", "self", ".", "_filter_layer", "(", "\n", "points", "[", "mask_copy", ",", ":", "]", ",", "points_z", ",", "\n", "labels_copy", ",", "layer", ")", "\n", "labels_copy", "[", "layer_mask", "]", "=", "self", ".", "label", "\n", "\n", "", "label_mask", "[", "mask_copy", "]", "=", "layer_mask", "\n", "if", "self", ".", "reset_noise", ":", "\n", "            ", "return", "label_mask", "&", "(", "mask", "|", "noise_mask", ")", "\n", "", "else", ":", "\n", "            ", "return", "label_mask", "&", "mask", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.analysis.analysis_tools.get_label_stats": [[8, 19], ["len", "numpy.unique", "zip", "labels.Labels.get_str", "float"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["def", "get_label_stats", "(", "labels", ")", ":", "\n", "    ", "\"\"\"Returns a string describing statistics based on labels.\"\"\"", "\n", "N", "=", "len", "(", "labels", ")", "\n", "labels", ",", "counts", "=", "np", ".", "unique", "(", "labels", ",", "return_counts", "=", "True", ")", "\n", "stats", "=", "f'Total: {N:25} points\\n'", "\n", "for", "label", ",", "cnt", "in", "zip", "(", "labels", ",", "counts", ")", ":", "\n", "        ", "name", "=", "Labels", ".", "get_str", "(", "label", ")", "\n", "perc", "=", "(", "float", "(", "cnt", ")", "/", "N", ")", "*", "100", "\n", "stats", "+=", "f'Class {label:2}, {name:14} '", "+", "f'{cnt:7} points ({perc:4.1f} %)\\n'", "\n", "", "return", "stats", "\n", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser.__init__": [[70, 88], ["abstract_processor.AbstractProcessor.__init__", "logger.warning", "logger.warning"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "bgt_type", ",", "bgt_reader", ",", "ahn_reader", "=", "None", ",", "\n", "padding", "=", "0", ",", "params", "=", "{", "}", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "bgt_type", "=", "bgt_type", "\n", "self", ".", "bgt_reader", "=", "bgt_reader", "\n", "if", "ahn_reader", "is", "None", ":", "\n", "            ", "logger", ".", "warning", "(", "'No ahn_reader specified. Assuming elevation=0.'", ")", "\n", "", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "if", "padding", ">", "0", ":", "\n", "# TODO: positive padding does not work with elevation data.", "\n", "            ", "logger", ".", "warning", "(", "'Positive padding not yet implemented.'", ")", "\n", "padding", "=", "0.", "\n", "", "self", ".", "padding", "=", "padding", "\n", "if", "'r_mult'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'r_mult'", "]", "=", "1.5", "\n", "", "if", "'label_height'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'label_height'", "]", "=", "4.", "\n", "", "self", ".", "params", "=", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser._find_point_cluster": [[89, 131], ["sklearn.cluster.DBSCAN().fit", "numpy.unique", "set().difference", "numpy.where", "len", "numpy.empty", "numpy.mean", "utils.clip_utils.cylinder_clip", "sklearn.cluster.DBSCAN", "set", "numpy.max", "c_xyr_list.append", "set", "numpy.max", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.cylinder_clip"], ["", "def", "_find_point_cluster", "(", "self", ",", "points", ",", "point", ",", "plane_height", ",", "\n", "plane_buffer", "=", "0.1", ",", "search_radius", "=", "1", ",", "max_dist", "=", "0.1", ",", "\n", "min_points", "=", "1", ",", "max_r", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Find a cluster in the point cloud that includes / is close to a\n        specified target point. The cluster is returned as a tuple (X, Y,\n        Radius).\n\n        For a description of parameters see \"Notes\" above.\n        \"\"\"", "\n", "search_ids", "=", "np", ".", "where", "(", "clip_utils", ".", "cylinder_clip", "(", "\n", "points", ",", "point", ",", "search_radius", ",", "\n", "bottom", "=", "plane_height", "-", "plane_buffer", ",", "\n", "top", "=", "plane_height", "+", "plane_buffer", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "search_ids", ")", "<", "min_points", ":", "\n", "            ", "return", "np", ".", "empty", "(", "(", "0", ",", "3", ")", ")", "\n", "# Cluster the potential seed points.", "\n", "", "clustering", "=", "(", "DBSCAN", "(", "eps", "=", "0.05", ",", "min_samples", "=", "5", ",", "p", "=", "2", ")", "\n", ".", "fit", "(", "points", "[", "search_ids", "]", ")", ")", "\n", "# Remove noise points.", "\n", "noise_mask", "=", "clustering", ".", "labels_", "!=", "-", "1", "\n", "# Get cluster labels and sizes.", "\n", "cc_labels", ",", "counts", "=", "np", ".", "unique", "(", "clustering", ".", "labels_", ",", "return_counts", "=", "True", ")", "\n", "if", "min_points", ">", "1", ":", "\n", "# Only keep clusters with size at least min_points.", "\n", "            ", "cc_labels", "=", "cc_labels", "[", "counts", ">=", "min_points", "]", "\n", "noise_mask", "=", "noise_mask", "&", "[", "label", "in", "set", "(", "cc_labels", ")", "\n", "for", "label", "in", "clustering", ".", "labels_", "]", "\n", "# Create a list of cluster centers (x,y) and radius r.", "\n", "", "c_xyr_list", "=", "[", "]", "\n", "for", "cl", "in", "set", "(", "cc_labels", ")", ".", "difference", "(", "(", "-", "1", ",", ")", ")", ":", "\n", "            ", "c_mask", "=", "clustering", ".", "labels_", "==", "cl", "\n", "(", "cx", ",", "cy", ")", "=", "np", ".", "mean", "(", "points", "[", "search_ids", "[", "c_mask", "]", ",", "0", ":", "2", "]", ",", "axis", "=", "0", ")", "\n", "cr", "=", "np", ".", "max", "(", "np", ".", "max", "(", "points", "[", "search_ids", "[", "c_mask", "]", ",", "0", ":", "2", "]", ",", "axis", "=", "0", ")", "\n", "-", "np", ".", "min", "(", "points", "[", "search_ids", "[", "c_mask", "]", ",", "0", ":", "2", "]", ",", "axis", "=", "0", ")", ")", "/", "2", "\n", "point_in_cl", "=", "(", "(", "point", "[", "0", "]", "-", "cx", ")", "**", "2", "+", "(", "point", "[", "1", "]", "-", "cy", ")", "**", "2", "\n", "<", "(", "cr", "+", "max_dist", ")", "**", "2", ")", "\n", "if", "cr", "<=", "max_r", "and", "point_in_cl", ":", "\n", "                ", "c_xyr_list", ".", "append", "(", "[", "cx", ",", "cy", ",", "cr", "]", ")", "\n", "# TODO for now we ignore possible additional clusters.", "\n", "break", "\n", "", "", "return", "c_xyr_list", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser._find_seeds_for_point_objects": [[132, 223], ["dict", "enumerate", "numpy.arange", "numpy.arange", "scipy.stats.binned_statistic_2d", "scipy.stats.binned_statistic_2d", "scipy.stats.binned_statistic_2d", "scipy.stats.binned_statistic_2d", "numpy.where", "fast_z", "numpy.where", "len", "numpy.abs", "len", "numpy.stack", "numpy.linalg.norm", "min", "pole_fuser.BGTPoleFuser._find_point_cluster", "numpy.array", "utils.clip_utils.box_clip", "len", "seeds.append", "numpy.array", "numpy.array", "numpy.argmin"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser._find_point_cluster", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.box_clip"], ["", "def", "_find_seeds_for_point_objects", "(", "self", ",", "points", ",", "point_objects", ",", "fast_z", "=", "None", ",", "\n", "search_pad", "=", "1.5", ",", "max_dist", "=", "1.2", ",", "\n", "voxel_res", "=", "0.2", ",", "seed_height", "=", "1.5", ",", "\n", "min_height", "=", "2", ",", "min_points", "=", "500", ",", "\n", "max_r", "=", "0.5", ",", "z_min", "=", "0.2", ",", "z_max", "=", "2.7", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Locate a cluster of seed points that most likely matches each target\n        point. Seed clusters are returned as a list of tuples (X, Y, Radius).\n\n        For a description of parameters see \"Notes\" above.\n        \"\"\"", "\n", "seeds", "=", "[", "]", "\n", "matches", "=", "dict", "(", ")", "\n", "for", "ind", ",", "obj", "in", "enumerate", "(", "point_objects", ")", ":", "\n", "# Assume obj = [x, y].", "\n", "            ", "if", "fast_z", "is", "None", ":", "\n", "                ", "ground_z", "=", "0.", "\n", "", "else", ":", "\n", "# Get the ground elevation.", "\n", "                ", "ground_z", "=", "fast_z", "(", "np", ".", "array", "(", "[", "obj", "]", ")", ")", "\n", "\n", "# Define the \"box\" within which to search for candidates.", "\n", "", "search_box", "=", "(", "obj", "[", "0", "]", "-", "search_pad", ",", "obj", "[", "1", "]", "-", "search_pad", ",", "\n", "obj", "[", "0", "]", "+", "search_pad", ",", "obj", "[", "1", "]", "+", "search_pad", ")", "\n", "box_ids", "=", "np", ".", "where", "(", "clip_utils", ".", "box_clip", "(", "points", ",", "search_box", ",", "\n", "bottom", "=", "ground_z", "+", "z_min", ",", "\n", "top", "=", "ground_z", "+", "z_max", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "box_ids", ")", "==", "0", ":", "\n", "# Empty search box, no match.", "\n", "                ", "matches", "[", "obj", "]", "=", "None", "\n", "continue", "\n", "\n", "# Voxelize the search box and compute statistics for each column.", "\n", "# TODO this voxelization only works when box width / height are", "\n", "# multiples of voxel_res.", "\n", "", "x_edge", "=", "np", ".", "arange", "(", "search_box", "[", "0", "]", ",", "search_box", "[", "2", "]", "+", "0.01", ",", "voxel_res", ")", "\n", "y_edge", "=", "np", ".", "arange", "(", "search_box", "[", "1", "]", ",", "search_box", "[", "3", "]", "+", "0.01", ",", "voxel_res", ")", "\n", "min_z_bin", "=", "binned_statistic_2d", "(", "\n", "points", "[", "box_ids", ",", "0", "]", ",", "points", "[", "box_ids", ",", "1", "]", ",", "points", "[", "box_ids", ",", "2", "]", ",", "\n", "bins", "=", "[", "x_edge", ",", "y_edge", "]", ",", "statistic", "=", "'min'", ")", "\n", "max_z_bin", "=", "binned_statistic_2d", "(", "\n", "points", "[", "box_ids", ",", "0", "]", ",", "points", "[", "box_ids", ",", "1", "]", ",", "points", "[", "box_ids", ",", "2", "]", ",", "\n", "bins", "=", "[", "x_edge", ",", "y_edge", "]", ",", "statistic", "=", "'max'", ")", "\n", "med_z_bin", "=", "binned_statistic_2d", "(", "\n", "points", "[", "box_ids", ",", "0", "]", ",", "points", "[", "box_ids", ",", "1", "]", ",", "points", "[", "box_ids", ",", "2", "]", ",", "\n", "bins", "=", "[", "x_edge", ",", "y_edge", "]", ",", "statistic", "=", "'median'", ")", "\n", "count_z_bin", "=", "binned_statistic_2d", "(", "\n", "points", "[", "box_ids", ",", "0", "]", ",", "points", "[", "box_ids", ",", "1", "]", ",", "points", "[", "box_ids", ",", "2", "]", ",", "\n", "bins", "=", "[", "x_edge", ",", "y_edge", "]", ",", "statistic", "=", "'count'", ")", "\n", "# Column height (max - min).", "\n", "height", "=", "max_z_bin", ".", "statistic", "-", "min_z_bin", ".", "statistic", "\n", "midpoint", "=", "(", "min_z_bin", ".", "statistic", "+", "max_z_bin", ".", "statistic", ")", "/", "2", "\n", "# Check if midpoint and median are close. This is a rough", "\n", "# approximation of checking whether the z-distribution is uniform", "\n", "# (i.e. a pole).", "\n", "med_mid", "=", "np", ".", "abs", "(", "med_z_bin", ".", "statistic", "-", "midpoint", ")", "<", "0.2", "*", "height", "\n", "\n", "# Find target locations where all criteria are met.", "\n", "x_loc", ",", "y_loc", "=", "np", ".", "where", "(", "(", "height", ">", "min_height", ")", "\n", "&", "(", "count_z_bin", ".", "statistic", ">", "min_points", ")", "\n", "&", "med_mid", ")", "\n", "if", "len", "(", "x_loc", ")", "==", "0", ":", "\n", "# No candidates found.", "\n", "                ", "matches", "[", "obj", "]", "=", "None", "\n", "continue", "\n", "", "candidates", "=", "np", ".", "stack", "(", "(", "x_edge", "[", "x_loc", "]", "+", "voxel_res", "/", "2", ",", "\n", "y_edge", "[", "y_loc", "]", "+", "voxel_res", "/", "2", ")", ")", ".", "T", "\n", "# Distances of candidates to target point.", "\n", "dist", "=", "[", "np", ".", "linalg", ".", "norm", "(", "np", ".", "array", "(", "obj", ")", "-", "np", ".", "array", "(", "[", "c", "]", ")", ")", "\n", "for", "c", "in", "candidates", "]", "\n", "# Candidate with minimum distance.", "\n", "c_prime", "=", "candidates", "[", "np", ".", "argmin", "(", "dist", ")", ",", ":", "]", "\n", "if", "min", "(", "dist", ")", "<=", "max_dist", ":", "\n", "# Find a matching cluster.", "\n", "                ", "clusters", "=", "self", ".", "_find_point_cluster", "(", "\n", "points", ",", "c_prime", ",", "seed_height", ",", "max_r", "=", "max_r", ")", "\n", "if", "len", "(", "clusters", ")", ">", "0", ":", "\n", "# We simply take the first one (usually there is only one).", "\n", "# TODO we could return a 'correspondence' so it's clear", "\n", "# which objects were located.", "\n", "                    ", "seed", "=", "clusters", "[", "0", "]", "\n", "seeds", ".", "append", "(", "seed", ")", "\n", "matches", "[", "obj", "]", "=", "(", "seed", "[", "0", "]", ",", "seed", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "# No cluster found.", "\n", "                    ", "matches", "[", "obj", "]", "=", "None", "\n", "", "", "else", ":", "\n", "# No candidates found.", "\n", "                ", "matches", "[", "obj", "]", "=", "None", "\n", "", "", "return", "seeds", ",", "matches", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser.get_label_mask": [[224, 280], ["logger.info", "numpy.zeros", "pole_fuser.BGTPoleFuser.bgt_reader.filter_tile", "pole_fuser.BGTPoleFuser.ahn_reader.filter_tile", "utils.interpolation.FastGridInterpolator", "pole_fuser.BGTPoleFuser._find_seeds_for_point_objects", "logger.debug", "logger.debug", "len", "logger.debug", "utils.clip_utils.cylinder_clip", "len", "utils.interpolation.FastGridInterpolator.", "numpy.array", "numpy.array", "matches.items", "len", "len", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.pole_fuser.BGTPoleFuser._find_seeds_for_point_objects", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.cylinder_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this class.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "f'BGT [{self.bgt_type}] point fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "bgt_points", "=", "self", ".", "bgt_reader", ".", "filter_tile", "(", "\n", "tilecode", ",", "bgt_types", "=", "[", "self", ".", "bgt_type", "]", ",", "\n", "padding", "=", "self", ".", "padding", ",", "return_types", "=", "False", ")", "\n", "if", "len", "(", "bgt_points", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "f'No {self.bgt_type} objects found in tile, '", "+", "\n", "' skipping.'", ")", "\n", "return", "label_mask", "\n", "\n", "", "ahn_tile", "=", "self", ".", "ahn_reader", ".", "filter_tile", "(", "tilecode", ")", "\n", "fast_z", "=", "FastGridInterpolator", "(", "ahn_tile", "[", "'x'", "]", ",", "ahn_tile", "[", "'y'", "]", ",", "\n", "ahn_tile", "[", "'ground_surface'", "]", ")", "\n", "\n", "# Find seed point clusters.", "\n", "seeds", ",", "matches", "=", "self", ".", "_find_seeds_for_point_objects", "(", "\n", "points", "[", "mask", "]", ",", "bgt_points", ",", "fast_z", ",", "**", "self", ".", "params", ")", "\n", "for", "seed", "in", "seeds", ":", "\n", "# Label a cylinder based on the seed cluster.", "\n", "            ", "top_height", "=", "(", "fast_z", "(", "np", ".", "array", "(", "[", "seed", "[", "0", ":", "2", "]", "]", ")", ")", "\n", "+", "self", ".", "params", "[", "'label_height'", "]", ")", "\n", "clip_mask", "=", "clip_utils", ".", "cylinder_clip", "(", "\n", "points", "[", "mask", "]", ",", "np", ".", "array", "(", "seed", "[", "0", ":", "2", "]", ")", ",", "\n", "self", ".", "params", "[", "'r_mult'", "]", "*", "seed", "[", "2", "]", ",", "\n", "top", "=", "top_height", ")", "\n", "label_mask", "[", "mask", "]", "=", "label_mask", "[", "mask", "]", "|", "clip_mask", "\n", "\n", "", "match_str", "=", "', '", ".", "join", "(", "[", "f'{obj}->{cand}'", "\n", "for", "(", "obj", ",", "cand", ")", "in", "matches", ".", "items", "(", ")", "]", ")", "\n", "logger", ".", "debug", "(", "f'{len(seeds)}/{len(bgt_points)} objects labelled.'", ")", "\n", "logger", ".", "debug", "(", "f'Matches for [{self.bgt_type}]: {match_str}'", ")", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.building_fuser.BGTBuildingFuser.__init__": [[37, 45], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "bgt_reader", ",", "offset", "=", "0", ",", "padding", "=", "0", ",", "\n", "ahn_reader", "=", "None", ",", "ahn_eps", "=", "0.2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "bgt_reader", "=", "bgt_reader", "\n", "self", ".", "offset", "=", "offset", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "ahn_eps", "=", "ahn_eps", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.building_fuser.BGTBuildingFuser.get_label_mask": [[46, 103], ["logger.info", "numpy.zeros", "building_fuser.BGTBuildingFuser.bgt_reader.filter_tile", "numpy.zeros", "logger.debug", "len", "logger.debug", "numpy.ones", "numpy.where", "utils.clip_utils.poly_clip", "building_fuser.BGTBuildingFuser.ahn_reader.interpolate", "numpy.isfinite", "len", "len", "len", "len", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this class.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'BGT building fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "building_polygons", "=", "self", ".", "bgt_reader", ".", "filter_tile", "(", "\n", "tilecode", ",", "bgt_types", "=", "[", "'pand'", "]", ",", "\n", "padding", "=", "self", ".", "padding", ",", "offset", "=", "self", ".", "offset", ",", "\n", "merge", "=", "True", ")", "\n", "if", "len", "(", "building_polygons", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "'No buildings found for tile, skipping.'", ")", "\n", "return", "label_mask", "\n", "\n", "", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "np", ".", "ones", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "", "mask_ids", "=", "np", ".", "where", "(", "mask", ")", "[", "0", "]", "\n", "\n", "building_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "mask_ids", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "polygon", "in", "building_polygons", ":", "\n", "# TODO if there are multiple buildings we could mask the points", "\n", "# iteratively to ignore points already labelled.", "\n", "            ", "clip_mask", "=", "clip_utils", ".", "poly_clip", "(", "points", "[", "mask", ",", ":", "]", ",", "polygon", ")", "\n", "building_mask", "=", "building_mask", "|", "clip_mask", "\n", "\n", "", "if", "self", ".", "ahn_reader", "is", "not", "None", ":", "\n", "            ", "bld_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", ",", ":", "]", ",", "mask", ",", "'building_surface'", ")", "\n", "bld_z_valid", "=", "np", ".", "isfinite", "(", "bld_z", ")", "\n", "ahn_mask", "=", "(", "points", "[", "mask_ids", "[", "bld_z_valid", "]", ",", "2", "]", "\n", "<=", "bld_z", "[", "bld_z_valid", "]", "+", "self", ".", "ahn_eps", ")", "\n", "building_mask", "[", "bld_z_valid", "]", "=", "building_mask", "[", "bld_z_valid", "]", "&", "ahn_mask", "\n", "\n", "", "logger", ".", "debug", "(", "f'{len(building_polygons)} building polygons labelled.'", ")", "\n", "\n", "label_mask", "[", "mask_ids", "[", "building_mask", "]", "]", "=", "True", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser.__init__": [[39, 56], ["abstract_processor.AbstractProcessor.__init__", "ahn_fuser.AHNFuser._set_defaults", "logger.error", "logger.error"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._set_defaults"], ["def", "__init__", "(", "self", ",", "label", ",", "ahn_reader", ",", "target", "=", "'ground'", ",", "epsilon", "=", "0.2", ",", "\n", "refine_ground", "=", "True", ",", "params", "=", "{", "}", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "if", "target", "not", "in", "self", ".", "TARGETS", ":", "\n", "            ", "logger", ".", "error", "(", "f'Target should be one of {self.TARGETS}.'", ")", "\n", "return", "None", "\n", "", "if", "ahn_reader", ".", "NAME", "==", "'geotiff'", "and", "target", "==", "'building'", ":", "\n", "            ", "logger", ".", "error", "(", "\n", "f'The {ahn_reader.NAME} reader cannot supply {target} data.'", ")", "\n", "return", "None", "\n", "\n", "", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "method", "=", "ahn_reader", ".", "NAME", "\n", "self", ".", "target", "=", "target", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "refine_ground", "=", "refine_ground", "\n", "self", ".", "params", "=", "self", ".", "_set_defaults", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._set_defaults": [[57, 70], ["None"], "methods", ["None"], ["", "def", "_set_defaults", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set defaults for parameters if not provided.\"\"\"", "\n", "if", "'bottom'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'bottom'", "]", "=", "0.02", "\n", "", "if", "'top'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'top'", "]", "=", "0.5", "\n", "", "if", "'grid_size'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'grid_size'", "]", "=", "0.4", "\n", "", "if", "'min_comp_size'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'min_comp_size'", "]", "=", "50", "\n", "", "if", "'buffer'", "not", "in", "params", ":", "\n", "            ", "params", "[", "'buffer'", "]", "=", "0.05", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._refine_layer": [[71, 98], ["numpy.zeros", "region_growing.LabelConnectedComp", "region_growing.LabelConnectedComp.get_components", "numpy.unique", "set().difference", "numpy.where", "numpy.where", "utils.math_utils.convex_hull_poly().buffer", "utils.clip_utils.poly_clip", "len", "set", "utils.math_utils.convex_hull_poly"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.convex_hull_poly"], ["", "def", "_refine_layer", "(", "self", ",", "points", ",", "points_z", ",", "\n", "labels", ",", "ground_mask", ",", "target_label", ")", ":", "\n", "        ", "\"\"\"Process a layer of the region grower.\"\"\"", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "label_ids", "=", "np", ".", "where", "(", "labels", "==", "target_label", ")", "[", "0", "]", "\n", "ground_ids", "=", "np", ".", "where", "(", "ground_mask", ")", "[", "0", "]", "\n", "\n", "lcc", "=", "LabelConnectedComp", "(", "\n", "target_label", ",", "grid_size", "=", "self", ".", "params", "[", "'grid_size'", "]", ",", "\n", "min_component_size", "=", "self", ".", "params", "[", "'min_comp_size'", "]", ")", "\n", "point_components", "=", "lcc", ".", "get_components", "(", "points", "[", "label_ids", "]", ")", "\n", "\n", "cc_labels", "=", "np", ".", "unique", "(", "point_components", ")", "\n", "cc_labels", "=", "set", "(", "cc_labels", ")", ".", "difference", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "for", "cc", "in", "cc_labels", ":", "\n", "# select points that belong to the cluster", "\n", "            ", "cc_mask", "=", "(", "point_components", "==", "cc", ")", "\n", "# Compute convex hull and add a small buffer", "\n", "poly", "=", "(", "math_utils", "\n", ".", "convex_hull_poly", "(", "points", "[", "label_ids", "[", "cc_mask", "]", ",", "0", ":", "2", "]", ")", "\n", ".", "buffer", "(", "self", ".", "params", "[", "'buffer'", "]", ")", ")", "\n", "# Select ground points within poly", "\n", "poly_mask", "=", "clip_utils", ".", "poly_clip", "(", "points", "[", "ground_mask", "]", ",", "poly", ")", "\n", "mask", "[", "ground_ids", "[", "poly_mask", "]", "]", "=", "True", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._refine_ground": [[99, 115], ["logger.info", "numpy.zeros", "logger.info", "numpy.count_nonzero", "ahn_fuser.AHNFuser._refine_layer", "len", "numpy.count_nonzero"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._refine_layer"], ["", "def", "_refine_ground", "(", "self", ",", "points", ",", "points_z", ",", "ground_mask", ",", "\n", "labels", ",", "target_label", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'Refining ground surface...'", ")", "\n", "\n", "mask", "=", "(", "(", "points", "[", ":", ",", "2", "]", "<=", "points_z", "+", "self", ".", "params", "[", "'top'", "]", ")", "\n", "&", "(", "points", "[", ":", ",", "2", "]", ">=", "points_z", "-", "self", ".", "params", "[", "'bottom'", "]", ")", ")", "\n", "\n", "ref_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "if", "np", ".", "count_nonzero", "(", "labels", "[", "mask", "]", "==", "target_label", ")", ">", "0", ":", "\n", "            ", "add_mask", "=", "self", ".", "_refine_layer", "(", "\n", "points", "[", "mask", ",", ":", "]", ",", "points_z", "[", "mask", "]", ",", "labels", "[", "mask", "]", ",", "\n", "ground_mask", "[", "mask", "]", ",", "target_label", ")", "\n", "ref_mask", "[", "mask", "]", "=", "add_mask", "\n", "\n", "", "logger", ".", "info", "(", "f'{np.count_nonzero(ref_mask)} points removed.'", ")", "\n", "return", "ref_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser.get_label_mask": [[116, 162], ["logger.info", "numpy.zeros", "ahn_fuser.AHNFuser.ahn_reader.interpolate", "ahn_fuser.AHNFuser.ahn_reader.interpolate", "len", "numpy.abs", "logger.info", "labels[].copy", "ahn_fuser.AHNFuser._refine_ground", "numpy.count_nonzero", "labels.Labels.get_str", "numpy.count_nonzero"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.ahn_fuser.AHNFuser._refine_ground", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this fuser.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "f'AHN [{self.method}/{self.target}] fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "if", "self", ".", "target", "==", "'ground'", ":", "\n", "            ", "target_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", ",", ":", "]", ",", "mask", ",", "'ground_surface'", ")", "\n", "", "elif", "self", ".", "target", "==", "'building'", ":", "\n", "            ", "target_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", ",", ":", "]", ",", "mask", ",", "'building_surface'", ")", "\n", "\n", "", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "if", "self", ".", "target", "==", "'ground'", ":", "\n", "            ", "ground_mask", "=", "(", "np", ".", "abs", "(", "points", "[", "mask", ",", "2", "]", "-", "target_z", ")", "<", "self", ".", "epsilon", ")", "\n", "if", "self", ".", "refine_ground", "and", "(", "np", ".", "count_nonzero", "(", "ground_mask", ")", ">", "0", ")", ":", "\n", "                ", "logger", ".", "info", "(", "f'{np.count_nonzero(ground_mask)} points added.'", ")", "\n", "tmp_labels", "=", "labels", "[", "mask", "]", ".", "copy", "(", ")", "\n", "tmp_labels", "[", "ground_mask", "]", "=", "self", ".", "label", "\n", "ref_mask", "=", "self", ".", "_refine_ground", "(", "\n", "points", "[", "mask", "]", ",", "target_z", ",", "ground_mask", ",", "\n", "tmp_labels", ",", "Labels", ".", "UNLABELLED", ")", "\n", "ground_mask", "=", "ground_mask", "&", "~", "ref_mask", "\n", "", "label_mask", "[", "mask", "]", "=", "ground_mask", "\n", "", "elif", "self", ".", "target", "==", "'building'", ":", "\n", "            ", "label_mask", "[", "mask", "]", "=", "points", "[", "mask", ",", "2", "]", "<", "target_z", "+", "self", ".", "epsilon", "\n", "\n", "", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.noise_filter.NoiseFilter.__init__": [[34, 42], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "ahn_reader", ",", "epsilon", "=", "0.2", ",", "\n", "grid_size", "=", "0.1", ",", "min_component_size", "=", "100", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "self", ".", "min_component_size", "=", "min_component_size", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.noise_filter.NoiseFilter.get_label_mask": [[43, 85], ["logger.info", "region_growing.label_connected_comp.LabelConnectedComp", "region_growing.label_connected_comp.LabelConnectedComp.get_components", "logger.debug", "noise_filter.NoiseFilter.ahn_reader.interpolate", "logger.debug", "numpy.zeros", "len", "labels.Labels.get_str", "numpy.count_nonzero", "numpy.count_nonzero"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this fuser.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'Noise filter '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "lcc", "=", "LabelConnectedComp", "(", "self", ".", "label", ",", "grid_size", "=", "self", ".", "grid_size", ",", "\n", "min_component_size", "=", "self", ".", "min_component_size", ")", "\n", "point_components", "=", "lcc", ".", "get_components", "(", "points", "[", "mask", "]", ")", "\n", "cc_mask", "=", "point_components", "==", "-", "1", "\n", "logger", ".", "debug", "(", "f'Found {np.count_nonzero(cc_mask)} noise points in '", "\n", "+", "f'clusters <{self.min_component_size} points.'", ")", "\n", "\n", "# Get the interpolated ground points of the tile", "\n", "target_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", "]", ",", "mask", ",", "'ground_surface'", ")", "\n", "ground_mask", "=", "(", "points", "[", "mask", ",", "2", "]", "-", "target_z", ")", "<", "-", "self", ".", "epsilon", "\n", "diff", "=", "ground_mask", "&", "~", "cc_mask", "\n", "logger", ".", "debug", "(", "f'Found {np.count_nonzero(diff)} noise points '", "\n", "+", "'below ground level.'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "# Label points below ground and points in small components.", "\n", "label_mask", "[", "mask", "]", "=", "cc_mask", "|", "ground_mask", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.street_furniture_fuser.BGTStreetFurnitureFuser.__init__": [[33, 45], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "bgt_type", ",", "bgt_reader", ",", "ahn_reader", ",", "\n", "grid_size", "=", "0.05", ",", "min_component_size", "=", "1500", ",", "\n", "padding", "=", "0", ",", "max_dist", "=", "1.", ",", "params", "=", "{", "}", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "bgt_type", "=", "bgt_type", "\n", "self", ".", "bgt_reader", "=", "bgt_reader", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "self", ".", "min_component_size", "=", "min_component_size", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "max_dist", "=", "max_dist", "\n", "self", ".", "params", "=", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.street_furniture_fuser.BGTStreetFurnitureFuser._label_street_furniture_like_components": [[46, 89], ["numpy.zeros", "numpy.unique", "set().difference", "logger.debug", "len", "set", "numpy.mean", "numpy.amax", "numpy.isfinite", "utils.math_utils.minimum_bounding_rectangle", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.minimum_bounding_rectangle"], ["", "def", "_label_street_furniture_like_components", "(", "self", ",", "points", ",", "ground_z", ",", "\n", "point_components", ",", "bgt_points", ",", "\n", "min_height", ",", "max_height", ",", "\n", "min_width", ",", "max_width", ",", "\n", "min_length", ",", "max_length", ")", ":", "\n", "        ", "\"\"\"\n        Based on certain properties of street furniture objects we label\n        clusters.\n        \"\"\"", "\n", "\n", "street_furniture_mask", "=", "np", ".", "zeros", "(", "len", "(", "points", ")", ",", "dtype", "=", "bool", ")", "\n", "object_count", "=", "0", "\n", "\n", "cc_labels", "=", "np", ".", "unique", "(", "point_components", ")", "\n", "\n", "cc_labels", "=", "set", "(", "cc_labels", ")", ".", "difference", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "for", "cc", "in", "cc_labels", ":", "\n", "# select points that belong to the cluster", "\n", "            ", "cc_mask", "=", "(", "point_components", "==", "cc", ")", "\n", "\n", "target_z", "=", "ground_z", "[", "cc_mask", "]", "\n", "valid_values", "=", "target_z", "[", "np", ".", "isfinite", "(", "target_z", ")", "]", "\n", "\n", "if", "valid_values", ".", "size", "!=", "0", ":", "\n", "                ", "cc_z", "=", "np", ".", "mean", "(", "valid_values", ")", "\n", "min_z", "=", "cc_z", "+", "min_height", "\n", "max_z", "=", "cc_z", "+", "max_height", "\n", "cluster_height", "=", "np", ".", "amax", "(", "points", "[", "cc_mask", "]", "[", ":", ",", "2", "]", ")", "\n", "if", "min_z", "<=", "cluster_height", "<=", "max_z", ":", "\n", "                    ", "mbrect", ",", "_", ",", "mbr_width", ",", "mbr_length", ",", "center_point", "=", "minimum_bounding_rectangle", "(", "points", "[", "cc_mask", "]", "[", ":", ",", ":", "2", "]", ")", "\n", "if", "(", "min_width", "<", "mbr_width", "<", "max_width", "and", "\n", "min_length", "<", "mbr_length", "<", "max_length", ")", ":", "\n", "                        ", "for", "bgt_point", "in", "bgt_points", ":", "\n", "                            ", "dist", "=", "np", ".", "linalg", ".", "norm", "(", "bgt_point", "-", "center_point", ")", "\n", "if", "dist", "<=", "self", ".", "max_dist", ":", "\n", "                                ", "street_furniture_mask", "[", "cc_mask", "]", "=", "True", "\n", "object_count", "+=", "1", "\n", "break", "\n", "\n", "", "", "", "", "", "", "logger", ".", "debug", "(", "f'{object_count} {self.bgt_type} objects labelled.'", ")", "\n", "return", "street_furniture_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.street_furniture_fuser.BGTStreetFurnitureFuser.get_label_mask": [[90, 138], ["logger.info", "numpy.zeros", "street_furniture_fuser.BGTStreetFurnitureFuser.bgt_reader.filter_tile", "street_furniture_fuser.BGTStreetFurnitureFuser.ahn_reader.interpolate", "region_growing.label_connected_comp.LabelConnectedComp", "region_growing.label_connected_comp.LabelConnectedComp.get_components", "street_furniture_fuser.BGTStreetFurnitureFuser._label_street_furniture_like_components", "len", "logger.debug", "len", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.street_furniture_fuser.BGTStreetFurnitureFuser._label_street_furniture_like_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this class.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'Street furniture fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "bgt_points", "=", "self", ".", "bgt_reader", ".", "filter_tile", "(", "\n", "tilecode", ",", "bgt_types", "=", "[", "self", ".", "bgt_type", "]", ",", "\n", "padding", "=", "self", ".", "padding", ",", "return_types", "=", "False", ")", "\n", "if", "len", "(", "bgt_points", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "f'No {self.bgt_type} objects found in tile, '", "+", "\n", "' skipping.'", ")", "\n", "return", "label_mask", "\n", "\n", "# Get the interpolated ground points of the tile", "\n", "", "ground_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", "]", ",", "mask", ",", "'ground_surface'", ")", "\n", "\n", "lcc", "=", "LabelConnectedComp", "(", "self", ".", "label", ",", "grid_size", "=", "self", ".", "grid_size", ",", "\n", "min_component_size", "=", "self", ".", "min_component_size", ")", "\n", "point_components", "=", "lcc", ".", "get_components", "(", "points", "[", "mask", "]", ")", "\n", "\n", "# Label street_furniture like clusters", "\n", "street_furniture_mask", "=", "(", "self", ".", "_label_street_furniture_like_components", "(", "\n", "points", "[", "mask", "]", ",", "ground_z", ",", "point_components", ",", "\n", "bgt_points", ",", "**", "self", ".", "params", ")", ")", "\n", "label_mask", "[", "mask", "]", "=", "street_furniture_mask", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.car_fuser.CarFuser.__init__": [[30, 41], ["abstract_processor.AbstractProcessor.__init__"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "ahn_reader", ",", "bgt_reader", ",", "\n", "grid_size", "=", "0.05", ",", "min_component_size", "=", "5000", ",", "\n", "overlap_perc", "=", "20", ",", "params", "=", "{", "}", ",", "exclude_types", "=", "[", "\"fietspad\"", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "ahn_reader", "=", "ahn_reader", "\n", "self", ".", "bgt_reader", "=", "bgt_reader", "\n", "self", ".", "grid_size", "=", "grid_size", "\n", "self", ".", "min_component_size", "=", "min_component_size", "\n", "self", ".", "overlap_perc", "=", "overlap_perc", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "exclude_types", "=", "exclude_types", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.car_fuser.CarFuser._label_car_like_components": [[42, 88], ["numpy.zeros", "numpy.unique", "set().difference", "logger.debug", "len", "set", "numpy.mean", "numpy.amax", "numpy.isfinite", "utils.math_utils.minimum_bounding_rectangle", "numpy.vstack", "shapely.geometry.Polygon", "shapely.geometry.Polygon.intersects", "utils.clip_utils.poly_box_clip", "shapely.geometry.Polygon.intersection"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.math_utils.minimum_bounding_rectangle", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_box_clip"], ["", "def", "_label_car_like_components", "(", "self", ",", "points", ",", "ground_z", ",", "point_components", ",", "\n", "road_polygons", ",", "min_height", ",", "max_height", ",", "\n", "min_width", ",", "max_width", ",", "min_length", ",", "\n", "max_length", ")", ":", "\n", "        ", "\"\"\" Based on certain properties of a car we label clusters.  \"\"\"", "\n", "\n", "car_mask", "=", "np", ".", "zeros", "(", "len", "(", "points", ")", ",", "dtype", "=", "bool", ")", "\n", "car_count", "=", "0", "\n", "\n", "cc_labels", "=", "np", ".", "unique", "(", "point_components", ")", "\n", "\n", "cc_labels", "=", "set", "(", "cc_labels", ")", ".", "difference", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "for", "cc", "in", "cc_labels", ":", "\n", "# select points that belong to the cluster", "\n", "            ", "cc_mask", "=", "(", "point_components", "==", "cc", ")", "\n", "\n", "target_z", "=", "ground_z", "[", "cc_mask", "]", "\n", "valid_values", "=", "target_z", "[", "np", ".", "isfinite", "(", "target_z", ")", "]", "\n", "\n", "if", "valid_values", ".", "size", "!=", "0", ":", "\n", "                ", "cc_z", "=", "np", ".", "mean", "(", "valid_values", ")", "\n", "min_z", "=", "cc_z", "+", "min_height", "\n", "max_z", "=", "cc_z", "+", "max_height", "\n", "cluster_height", "=", "np", ".", "amax", "(", "points", "[", "cc_mask", "]", "[", ":", ",", "2", "]", ")", "\n", "if", "min_z", "<=", "cluster_height", "<=", "max_z", ":", "\n", "                    ", "mbrect", ",", "_", ",", "mbr_width", ",", "mbr_length", ",", "_", "=", "minimum_bounding_rectangle", "(", "points", "[", "cc_mask", "]", "[", ":", ",", ":", "2", "]", ")", "\n", "poly", "=", "np", ".", "vstack", "(", "(", "mbrect", ",", "mbrect", "[", "0", "]", ")", ")", "\n", "if", "(", "min_width", "<", "mbr_width", "<", "max_width", "and", "\n", "min_length", "<", "mbr_length", "<", "max_length", ")", ":", "\n", "                        ", "p1", "=", "Polygon", "(", "poly", ")", "\n", "for", "p2", "in", "road_polygons", ":", "\n", "                            ", "do_overlap", "=", "p1", ".", "intersects", "(", "p2", ")", "\n", "if", "do_overlap", ":", "\n", "                                ", "intersection_perc", "=", "(", "p1", ".", "intersection", "(", "p2", ")", ".", "area", "\n", "/", "p1", ".", "area", ")", "*", "100", "\n", "if", "intersection_perc", ">", "self", ".", "overlap_perc", ":", "\n", "                                    ", "car_mask", "=", "car_mask", "|", "poly_box_clip", "(", "\n", "points", ",", "p1", ",", "bottom", "=", "cc_z", ",", "top", "=", "max_z", ")", "\n", "car_count", "+=", "1", "\n", "break", "\n", "\n", "", "", "", "", "", "", "", "logger", ".", "debug", "(", "f'{car_count} cars labelled.'", ")", "\n", "\n", "return", "car_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.car_fuser.CarFuser.get_label_mask": [[89, 136], ["logger.info", "numpy.zeros", "car_fuser.CarFuser.bgt_reader.filter_tile", "car_fuser.CarFuser.ahn_reader.interpolate", "region_growing.label_connected_comp.LabelConnectedComp", "region_growing.label_connected_comp.LabelConnectedComp.get_components", "car_fuser.CarFuser._label_car_like_components", "len", "logger.debug", "len", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.AHNReader.interpolate", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.region_growing.label_connected_comp.LabelConnectedComp.get_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.car_fuser.CarFuser._label_car_like_components", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this class.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'Car fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "points", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "road_polygons", "=", "self", ".", "bgt_reader", ".", "filter_tile", "(", "\n", "tilecode", ",", "exclude_types", "=", "self", ".", "exclude_types", ",", "merge", "=", "False", ")", "\n", "if", "len", "(", "road_polygons", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "'No road parts found for tile, skipping.'", ")", "\n", "return", "label_mask", "\n", "\n", "# Get the interpolated ground points of the tile", "\n", "", "ground_z", "=", "self", ".", "ahn_reader", ".", "interpolate", "(", "\n", "tilecode", ",", "points", "[", "mask", "]", ",", "mask", ",", "'ground_surface'", ")", "\n", "\n", "lcc", "=", "LabelConnectedComp", "(", "self", ".", "label", ",", "grid_size", "=", "self", ".", "grid_size", ",", "\n", "min_component_size", "=", "self", ".", "min_component_size", ")", "\n", "point_components", "=", "lcc", ".", "get_components", "(", "points", "[", "mask", "]", ")", "\n", "\n", "# Label car like clusters", "\n", "car_mask", "=", "self", ".", "_label_car_like_components", "(", "points", "[", "mask", "]", ",", "ground_z", ",", "\n", "point_components", ",", "\n", "road_polygons", ",", "\n", "**", "self", ".", "params", ")", "\n", "label_mask", "[", "mask", "]", "=", "car_mask", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__": [[40, 49], ["abstract_processor.AbstractProcessor.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.__init__"], ["def", "__init__", "(", "self", ",", "label", ",", "bgt_reader", ",", "bgt_types", "=", "ALL_TYPES", ",", "\n", "offset", "=", "0", ",", "padding", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "label", ")", "\n", "self", ".", "bgt_reader", "=", "bgt_reader", "\n", "if", "isinstance", "(", "bgt_types", ",", "str", ")", ":", "\n", "            ", "bgt_types", "=", "[", "bgt_types", "]", "\n", "", "self", ".", "bgt_types", "=", "bgt_types", "\n", "self", ".", "offset", "=", "offset", "\n", "self", ".", "padding", "=", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.fusion.road_fuser.BGTRoadFuser.get_label_mask": [[50, 95], ["logger.info", "numpy.zeros", "road_fuser.BGTRoadFuser.bgt_reader.filter_tile", "numpy.zeros", "logger.debug", "len", "len", "logger.debug", "numpy.where", "utils.clip_utils.poly_clip", "len", "len", "labels.Labels.get_str"], "methods", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.ahn_utils.GeoTIFFReader.filter_tile", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.utils.clip_utils.poly_clip", "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.upcp.labels.Labels.get_str"], ["", "def", "get_label_mask", "(", "self", ",", "points", ",", "labels", ",", "mask", ",", "tilecode", ")", ":", "\n", "        ", "\"\"\"\n        Returns the label mask for the given pointcloud.\n        Parameters\n        ----------\n        points : array of shape (n_points, 3)\n            The point cloud <x, y, z>.\n        labels : array of shape (n_points,)\n            Ignored by this class.\n        mask : array of shape (n_points,) with dtype=bool\n            Pre-mask used to label only a subset of the points.\n        tilecode : str\n            The CycloMedia tile-code for the given pointcloud.\n        Returns\n        -------\n        An array of shape (n_points,) with dtype=bool indicating which points\n        should be labelled according to this fuser.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'BGT road fuser '", "+", "\n", "f'(label={self.label}, {Labels.get_str(self.label)}).'", ")", "\n", "\n", "label_mask", "=", "np", ".", "zeros", "(", "len", "(", "points", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "road_polygons", "=", "self", ".", "bgt_reader", ".", "filter_tile", "(", "\n", "tilecode", ",", "bgt_types", "=", "self", ".", "bgt_types", ",", "\n", "padding", "=", "self", ".", "padding", ",", "offset", "=", "self", ".", "offset", ",", "\n", "merge", "=", "True", ")", "\n", "if", "len", "(", "road_polygons", ")", "==", "0", ":", "\n", "            ", "logger", ".", "debug", "(", "'No road parts found in tile, skipping.'", ")", "\n", "return", "label_mask", "\n", "\n", "# Already labelled ground points can be labelled as road.", "\n", "", "mask", "=", "labels", "==", "Labels", ".", "GROUND", "\n", "mask_ids", "=", "np", ".", "where", "(", "mask", ")", "[", "0", "]", "\n", "\n", "road_mask", "=", "np", ".", "zeros", "(", "(", "len", "(", "mask_ids", ")", ",", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "polygon", "in", "road_polygons", ":", "\n", "            ", "clip_mask", "=", "clip_utils", ".", "poly_clip", "(", "points", "[", "mask", ",", ":", "]", ",", "polygon", ")", "\n", "road_mask", "=", "road_mask", "|", "clip_mask", "\n", "\n", "", "logger", ".", "debug", "(", "f'{len(road_polygons)} road polygons labelled.'", ")", "\n", "\n", "label_mask", "[", "mask_ids", "[", "road_mask", "]", "]", "=", "True", "\n", "\n", "return", "label_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.scripts.ahn_batch_processor._process_file": [[16, 19], ["upcp.preprocessing.ahn_preprocessing.process_ahn_las_tile"], "function", ["home.repos.pwc.inspect_result.amsterdam-ai-team_urban_pointcloud_processing.preprocessing.ahn_preprocessing.process_ahn_las_tile"], ["def", "_process_file", "(", "args", ",", "file", ")", ":", "\n", "    ", "process_ahn_las_tile", "(", "file", ",", "out_folder", "=", "args", ".", "out_folder", ",", "\n", "resolution", "=", "args", ".", "resolution", ")", "\n", "\n"]]}