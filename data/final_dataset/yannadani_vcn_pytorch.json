{"home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.parse_args": [[19, 78], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.listdir", "os.listdir", "os.path.join", "os.path.join", "torch.device", "torch.manual_seed", "numpy.random.seed", "os.path.exists", "os.path.exists", "os.makedirs", "os.makedirs", "str", "str", "torch.cuda.is_available", "int", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Variational Causal Networks'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path'", ",", "type", "=", "str", ",", "default", "=", "'results_anneal/'", ",", "\n", "help", "=", "'Path to save result files'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_autoreg_base'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'Use factorisable disrtibution'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "10", ",", "\n", "help", "=", "'random seed (default: 10)'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_seed'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "\n", "help", "=", "'random seed for generating data(default: 20)'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "1000", ",", "\n", "help", "=", "'Batch Size for training'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "1e-2", ",", "\n", "help", "=", "'Learning rate'", ")", "\n", "parser", ".", "add_argument", "(", "'--gibbs_temp'", ",", "type", "=", "float", ",", "default", "=", "1000.0", ",", "\n", "help", "=", "'Temperature for the Graph Gibbs Distribution'", ")", "\n", "parser", ".", "add_argument", "(", "'--sparsity_factor'", ",", "type", "=", "float", ",", "default", "=", "0.001", ",", "\n", "help", "=", "'Hyperparameter for sparsity regularizer'", ")", "\n", "parser", ".", "add_argument", "(", "'--epochs'", ",", "type", "=", "int", ",", "default", "=", "30000", ",", "\n", "help", "=", "'Number of iterations to train'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_nodes'", ",", "type", "=", "int", ",", "default", "=", "2", ",", "\n", "help", "=", "'Number of nodes in the causal model'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_samples'", ",", "type", "=", "int", ",", "default", "=", "100", ",", "\n", "help", "=", "'Total number of samples in the synthetic data'", ")", "\n", "parser", ".", "add_argument", "(", "'--noise_type'", ",", "type", "=", "str", ",", "default", "=", "'isotropic-gaussian'", ",", "\n", "help", "=", "'Type of noise of causal model'", ")", "\n", "parser", ".", "add_argument", "(", "'--noise_sigma'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'Std of Noise Variables'", ")", "\n", "parser", ".", "add_argument", "(", "'--theta_mu'", ",", "type", "=", "float", ",", "default", "=", "2.0", ",", "\n", "help", "=", "'Mean of Parameter Variables'", ")", "\n", "parser", ".", "add_argument", "(", "'--theta_sigma'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'Std of Parameter Variables'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_type'", ",", "type", "=", "str", ",", "default", "=", "'er'", ",", "\n", "help", "=", "'Type of data'", ")", "\n", "parser", ".", "add_argument", "(", "'--exp_edges'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'Expected number of edges in the random graph'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_only'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'Perform Just Evaluation'", ")", "\n", "parser", ".", "add_argument", "(", "'--anneal'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'Perform gibbs temp annealing'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "args", ".", "data_size", "=", "args", ".", "num_nodes", "*", "(", "args", ".", "num_nodes", "-", "1", ")", "\n", "root", "=", "args", ".", "save_path", "\n", "list_dir", "=", "os", ".", "listdir", "(", "args", ".", "save_path", ")", "\n", "args", ".", "save_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "save_path", ",", "args", ".", "data_type", "+", "'_'", "+", "str", "(", "int", "(", "args", ".", "exp_edges", ")", ")", ",", "str", "(", "args", ".", "num_nodes", ")", "+", "'_'", "+", "str", "(", "args", ".", "seed", ")", "+", "'_'", "+", "str", "(", "args", ".", "data_seed", ")", "+", "'_'", "+", "str", "(", "args", ".", "num_samples", ")", "+", "'_'", "+", "str", "(", "args", ".", "sparsity_factor", ")", "+", "'_'", "+", "str", "(", "args", ".", "gibbs_temp", ")", "+", "'_'", "+", "str", "(", "args", ".", "no_autoreg_base", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "args", ".", "save_path", ")", "\n", "", "if", "args", ".", "num_nodes", "==", "2", ":", "\n", "        ", "args", ".", "exp_edges", "=", "0.8", "\n", "\n", "", "args", ".", "gibbs_temp_init", "=", "10.", "\n", "args", ".", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "args", ".", "seed", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.auroc": [[79, 111], ["utils.adj_mat_to_vec().numpy().squeeze", "numpy.concatenate", "numpy.mean", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "sklearn.metrics.auc", "torch.no_grad", "numpy.argsort", "numpy.zeros", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "utils.adj_mat_to_vec().numpy", "min", "np.concatenate.append", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "numpy.logical_and", "float", "float", "float", "model.graph_dist.sample().cpu().numpy().squeeze", "utils.adj_mat_to_vec", "torch.from_numpy().unsqueeze", "model.graph_dist.sample().cpu().numpy", "torch.from_numpy", "model.graph_dist.sample().cpu", "model.graph_dist.sample"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.adj_mat_to_vec", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "auroc", "(", "model", ",", "ground_truth", ",", "num_samples", "=", "1000", ")", ":", "\n", "    ", "\"\"\"Compute the AUROC of the model as given in \n    https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0009202\"\"\"", "\n", "\n", "gt", "=", "utils", ".", "adj_mat_to_vec", "(", "torch", ".", "from_numpy", "(", "ground_truth", ")", ".", "unsqueeze", "(", "0", ")", ",", "model", ".", "num_nodes", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", "\n", "num_nodes", "=", "model", ".", "num_nodes", "\n", "bs", "=", "10000", "\n", "i", "=", "0", "\n", "samples", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "while", "i", "<", "num_samples", ":", "\n", "            ", "curr", "=", "min", "(", "bs", ",", "num_samples", "-", "i", ")", "\n", "samples", ".", "append", "(", "model", ".", "graph_dist", ".", "sample", "(", "[", "curr", "]", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "squeeze", "(", ")", ")", "\n", "i", "+=", "curr", "\n", "", "", "samples", "=", "np", ".", "concatenate", "(", "samples", ",", "axis", "=", "0", ")", "\n", "samples_mean", "=", "np", ".", "mean", "(", "samples", ",", "axis", "=", "0", ")", "\n", "sorted_beliefs_index", "=", "np", ".", "argsort", "(", "samples_mean", ")", "[", ":", ":", "-", "1", "]", "\n", "fpr", "=", "np", ".", "zeros", "(", "(", "samples_mean", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "tpr", "=", "np", ".", "zeros", "(", "(", "samples_mean", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "tnr", "=", "np", ".", "zeros", "(", "(", "samples_mean", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "samples_mean", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "indexes", "=", "np", ".", "zeros", "(", "(", "samples_mean", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "indexes", "[", "sorted_beliefs_index", "[", ":", "i", "]", "]", "=", "1", "\n", "tp", "=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "gt", "==", "1", ",", "indexes", "==", "1", ")", ")", "\n", "fn", "=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "indexes", "==", "0", ",", "gt", "!=", "indexes", ")", ")", "\n", "tn", "=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "gt", "==", "0", ",", "indexes", "==", "0", ")", ")", "\n", "fp", "=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "indexes", "==", "1", ",", "gt", "!=", "indexes", ")", ")", "\n", "fpr", "[", "i", "]", "=", "float", "(", "fp", ")", "/", "(", "fp", "+", "tn", ")", "\n", "tpr", "[", "i", "]", "=", "float", "(", "tp", ")", "/", "(", "tp", "+", "fn", ")", "\n", "tnr", "[", "i", "]", "=", "float", "(", "tn", ")", "/", "(", "tn", "+", "fp", ")", "\n", "", "auroc", "=", "metrics", ".", "auc", "(", "fpr", ",", "tpr", ")", "\n", "return", "auroc", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.exp_shd": [[113, 127], ["torch.no_grad", "model.graph_dist.sample", "utils.vec_to_adj_mat", "range", "utils.shd", "G[].cpu().numpy", "G[].cpu"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.shd"], ["", "def", "exp_shd", "(", "model", ",", "ground_truth", ",", "num_samples", "=", "1000", ")", ":", "\n", "    ", "\"\"\"Compute the Expected Structural Hamming Distance of the model\"\"\"", "\n", "shd", "=", "0", "\n", "prc", "=", "0.", "\n", "rec", "=", "0.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "samples", "=", "model", ".", "graph_dist", ".", "sample", "(", "[", "num_samples", "]", ")", "\n", "G", "=", "utils", ".", "vec_to_adj_mat", "(", "samples", ",", "model", ".", "num_nodes", ")", "\n", "for", "i", "in", "range", "(", "num_samples", ")", ":", "\n", "            ", "metrics", "=", "utils", ".", "shd", "(", "G", "[", "i", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "ground_truth", ")", "\n", "shd", "+=", "metrics", "[", "'shd'", "]", "\n", "prc", "+=", "metrics", "[", "'prc'", "]", "\n", "rec", "+=", "metrics", "[", "'rec'", "]", "\n", "", "", "return", "shd", "/", "num_samples", ",", "prc", "/", "num_samples", ",", "rec", "/", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.full_kl_and_hellinger": [[128, 147], ["utils.all_combinations().astype", "utils.all_combinations().astype", "torch.zeros", "torch.zeros", "torch.zeros", "torch.distributions.categorical.Categorical", "torch.distributions.categorical.Categorical", "len", "len", "len", "torch.no_grad", "range", "range", "torch.sqrt", "torch.distributions.kl.kl_divergence().item", "hellinger.item", "utils.all_combinations", "utils.all_combinations", "len", "bge_train.log_marginal_likelihood_given_g().cpu", "model.graph_dist.log_prob().cpu().squeeze", "len", "g_dist.unnormalized_log_prob", "numpy.sqrt", "torch.distributions.kl.kl_divergence", "bge_train.log_marginal_likelihood_given_g", "model.graph_dist.log_prob().cpu", "torch.tensor().to", "model.graph_dist.log_prob", "torch.tensor().to().unsqueeze", "torch.sqrt", "torch.sqrt", "torch.tensor", "torch.tensor().to", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.unnormalized_log_prob", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob"], ["", "def", "full_kl_and_hellinger", "(", "model", ",", "bge_train", ",", "g_dist", ",", "device", ")", ":", "\n", "    ", "\"\"\"Compute the KL Divergence and Hellinger distance in lower dimensional settings (d<=4)\"\"\"", "\n", "\n", "bs", "=", "100000", "\n", "all_adj", "=", "utils", ".", "all_combinations", "(", "model", ".", "num_nodes", ",", "return_adj", "=", "True", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "all_adj_vec", "=", "utils", ".", "all_combinations", "(", "model", ".", "num_nodes", ",", "return_adj", "=", "False", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "log_posterior_graph", "=", "torch", ".", "zeros", "(", "len", "(", "all_adj", ")", ")", "\n", "log_prob_g", "=", "torch", ".", "zeros", "(", "len", "(", "all_adj", ")", ")", "\n", "log_prob_model", "=", "torch", ".", "zeros", "(", "len", "(", "all_adj", ")", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "tt", "in", "range", "(", "0", ",", "len", "(", "all_adj", ")", ",", "bs", ")", ":", "\n", "            ", "log_posterior_graph", "[", "tt", ":", "tt", "+", "bs", "]", "=", "bge_train", ".", "log_marginal_likelihood_given_g", "(", "w", "=", "torch", ".", "tensor", "(", "all_adj", "[", "tt", ":", "tt", "+", "bs", "]", ")", ".", "to", "(", "device", ")", ")", ".", "cpu", "(", ")", "#Unnormalized Log Probabilities", "\n", "log_prob_model", "[", "tt", ":", "tt", "+", "bs", "]", "=", "model", ".", "graph_dist", ".", "log_prob", "(", "torch", ".", "tensor", "(", "all_adj_vec", "[", "tt", ":", "tt", "+", "bs", "]", ")", ".", "to", "(", "device", ")", ".", "unsqueeze", "(", "2", ")", ")", ".", "cpu", "(", ")", ".", "squeeze", "(", ")", "\n", "", "for", "tt", "in", "range", "(", "len", "(", "all_adj", ")", ")", ":", "\n", "            ", "log_prob_g", "[", "tt", "]", "=", "g_dist", ".", "unnormalized_log_prob", "(", "g", "=", "all_adj", "[", "tt", "]", ")", "\n", "", "", "graph_p", "=", "torch", ".", "distributions", ".", "categorical", ".", "Categorical", "(", "logits", "=", "log_posterior_graph", "+", "log_prob_g", ")", "\n", "graph_q", "=", "torch", ".", "distributions", ".", "categorical", ".", "Categorical", "(", "logits", "=", "log_prob_model", ")", "\n", "hellinger", "=", "(", "1.", "/", "np", ".", "sqrt", "(", "2", ")", ")", "*", "torch", ".", "sqrt", "(", "(", "torch", ".", "sqrt", "(", "graph_p", ".", "probs", ")", "-", "torch", ".", "sqrt", "(", "graph_q", ".", "probs", ")", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ")", "\n", "return", "torch", ".", "distributions", ".", "kl", ".", "kl_divergence", "(", "graph_q", ",", "graph_p", ")", ".", "item", "(", ")", ",", "hellinger", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.train": [[149, 170], ["model.train", "optimizer.zero_grad", "model", "per_sample_elbo.mean", "per_sample_elbo.mean.backward", "optimizer.step", "kl_graph.mean().item", "likelihood.mean().item", "score_val.mean", "kl_graph.mean", "likelihood.mean"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.train"], ["", "def", "train", "(", "model", ",", "bge_train", ",", "optimizer", ",", "baseline", ",", "batch_size", ",", "e", ",", "device", ")", ":", "\n", "    ", "kl_graphs", "=", "0.", "\n", "losses", "=", "0.", "\n", "likelihoods", "=", "0.", "\n", "\n", "model", ".", "train", "(", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "likelihood", ",", "kl_graph", ",", "log_probs", "=", "model", "(", "batch_size", ",", "bge_train", ",", "e", ")", "#TODO: Check if additional entropy regularization is required", "\n", "score_val", "=", "(", "-", "likelihood", "+", "kl_graph", ")", ".", "detach", "(", ")", "\n", "per_sample_elbo", "=", "log_probs", "*", "(", "score_val", "-", "baseline", ")", "\n", "baseline", "=", "0.95", "*", "baseline", "+", "0.05", "*", "score_val", ".", "mean", "(", ")", "\n", "loss", "=", "(", "per_sample_elbo", ")", ".", "mean", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "likelihoods", "=", "-", "likelihood", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "kl_graphs", "=", "kl_graph", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "losses", "=", "(", "-", "likelihood", "+", "kl_graph", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "return", "losses", ",", "likelihoods", ",", "kl_graphs", ",", "baseline", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.evaluate": [[173, 183], ["model.eval", "torch.no_grad", "model", "likelihood.mean().item", "likelihood.mean"], "function", ["None"], ["", "def", "evaluate", "(", "model", ",", "bge_test", ",", "batch_size", ",", "e", ",", "device", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "        ", "likelihood", ",", "kl_graph", ",", "_", "=", "model", "(", "batch_size", ",", "bge_test", ",", "e", ")", "\n", "elbo", "=", "(", "-", "likelihood", "+", "kl_graph", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "likelihoods", "=", "-", "likelihood", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "return", "elbo", ",", "likelihoods", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.load_model": [[184, 204], ["models.vcn.VCN().to", "print", "models.autoreg_base.AutoregressiveBase().to", "models.factorised_base.FactorisedBase().to", "models.vcn.VCN", "models.autoreg_base.AutoregressiveBase", "models.factorised_base.FactorisedBase", "max"], "function", ["None"], ["", "def", "load_model", "(", "args", ")", ":", "\n", "    ", "if", "not", "args", ".", "no_autoreg_base", ":", "\n", "        ", "graph_dist", "=", "autoreg_base", ".", "AutoregressiveBase", "(", "args", ".", "num_nodes", ",", "device", "=", "args", ".", "device", ",", "temp_rsample", "=", "0.1", ")", ".", "to", "(", "args", ".", "device", ")", "\n", "", "else", ":", "\n", "        ", "graph_dist", "=", "factorised_base", ".", "FactorisedBase", "(", "args", ".", "num_nodes", ",", "device", "=", "args", ".", "device", ",", "temp_rsample", "=", "0.1", ")", ".", "to", "(", "args", ".", "device", ")", "\n", "\n", "", "def", "_gibbs_update", "(", "curr", ",", "epoch", ")", ":", "\n", "        ", "if", "epoch", "<", "args", ".", "epochs", "*", "0.05", ":", "\n", "            ", "return", "curr", "\n", "", "else", ":", "\n", "            ", "return", "args", ".", "gibbs_temp_init", "+", "(", "args", ".", "gibbs_temp", "-", "args", ".", "gibbs_temp_init", ")", "*", "(", "10", "**", "(", "-", "2", "*", "max", "(", "0", ",", "(", "args", ".", "epochs", "-", "1.1", "*", "epoch", ")", "/", "args", ".", "epochs", ")", ")", ")", "\n", "\n", "", "", "if", "args", ".", "anneal", ":", "\n", "        ", "gibbs_update", "=", "_gibbs_update", "\n", "", "else", ":", "\n", "        ", "gibbs_update", "=", "None", "\n", "\n", "", "model", "=", "vcn", ".", "VCN", "(", "num_nodes", "=", "args", ".", "num_nodes", ",", "graph_dist", "=", "graph_dist", ",", "sparsity_factor", "=", "args", ".", "sparsity_factor", ",", "gibbs_temp_init", "=", "args", ".", "gibbs_temp_init", ",", "gibbs_update", "=", "gibbs_update", ")", ".", "to", "(", "args", ".", "device", ")", "\n", "print", "(", "model", ",", "flush", "=", "True", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.load_data": [[205, 214], ["models.bge_model.BGe", "int"], "function", ["None"], ["", "def", "load_data", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "data_type", "==", "'d4'", ":", "\n", "        ", "train_data", "=", "data_map", "[", "args", ".", "data_type", "]", "(", "file_name", "=", "int", "(", "args", ".", "exp_edges", ")", ")", "\n", "", "else", ":", "\n", "        ", "train_data", "=", "data_map", "[", "args", ".", "data_type", "]", "(", "num_nodes", "=", "args", ".", "num_nodes", ",", "exp_edges", "=", "args", ".", "exp_edges", ",", "noise_type", "=", "args", ".", "noise_type", ",", "noise_sigma", "=", "args", ".", "noise_sigma", ",", "num_samples", "=", "args", ".", "num_samples", ",", "mu_prior", "=", "args", ".", "theta_mu", ",", "sigma_prior", "=", "args", ".", "theta_sigma", ",", "seed", "=", "args", ".", "data_seed", ")", "\n", "\n", "", "bge_train", "=", "bge_model", ".", "BGe", "(", "mean_obs", "=", "[", "args", ".", "theta_mu", "]", "*", "args", ".", "num_nodes", ",", "alpha_mu", "=", "1.0", ",", "alpha_lambd", "=", "args", ".", "alpha_lambd", ",", "data", "=", "train_data", ".", "samples", ",", "device", "=", "args", ".", "device", ")", "\n", "return", "bge_train", ",", "train_data", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.main": [[215, 276], ["main.load_model", "torch.optim.Adam", "main.load_data", "load_model.load_state_dict", "main.exp_shd", "print", "load_model.parameters", "data.distributions.GibbsDAGDistributionFull", "data.distributions.GibbsUniformDAGDistribution", "range", "torch.save", "main.full_kl_and_hellinger", "main.auroc", "open", "pickle.dump", "time.time", "main.train", "time_epoch.append", "main.evaluate", "val_elbo.append", "os.join", "torch.load", "os.join", "likelihood.append", "kl_graph.append", "elbo_train.append", "print", "torch.save", "load_model.state_dict", "os.join", "time.time", "main.full_kl_and_hellinger", "os.join", "numpy.sum", "load_model.state_dict"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.load_model", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.load_data", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.exp_shd", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.full_kl_and_hellinger", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.auroc", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.train", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.evaluate", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.main.full_kl_and_hellinger"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "model", "=", "load_model", "(", "args", ")", "\n", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "bge_train", ",", "train_data", "=", "load_data", "(", "args", ")", "\n", "if", "args", ".", "num_nodes", "<=", "4", ":", "\n", "        ", "g_dist", "=", "distributions", ".", "GibbsDAGDistributionFull", "(", "args", ".", "num_nodes", ",", "args", ".", "gibbs_temp", ",", "args", ".", "sparsity_factor", ")", "\n", "", "else", ":", "\n", "        ", "g_dist", "=", "distributions", ".", "GibbsUniformDAGDistribution", "(", "args", ".", "num_nodes", ",", "args", ".", "gibbs_temp", ",", "args", ".", "sparsity_factor", ")", "\n", "\n", "", "best_elbo", "=", "1e20", "\n", "likelihood", "=", "[", "]", "\n", "kl_graph", "=", "[", "]", "\n", "elbo_train", "=", "[", "]", "\n", "val_elbo", "=", "[", "]", "\n", "baseline", "=", "0.", "\n", "best_likelihood", "=", "1e20", "\n", "best_kl", "=", "1e20", "\n", "\n", "time_epoch", "=", "[", "]", "\n", "if", "not", "args", ".", "eval_only", ":", "\n", "        ", "for", "e", "in", "range", "(", "1", ",", "args", ".", "epochs", "+", "1", ")", ":", "\n", "            ", "temp_time", "=", "time", ".", "time", "(", ")", "\n", "el", ",", "li", ",", "kl_g", ",", "baseline", "=", "train", "(", "model", ",", "bge_train", ",", "optimizer", ",", "baseline", ",", "args", ".", "batch_size", ",", "e", ",", "args", ".", "device", ")", "\n", "time_epoch", ".", "append", "(", "time", ".", "time", "(", ")", "-", "temp_time", ")", "\n", "likelihood", ".", "append", "(", "li", ")", ",", "kl_graph", ".", "append", "(", "kl_g", ")", ",", "elbo_train", ".", "append", "(", "el", ")", "\n", "elbo_epoch", ",", "likelihood_epoch", "=", "evaluate", "(", "model", ",", "bge_train", ",", "args", ".", "batch_size", ",", "e", ",", "args", ".", "device", ")", "\n", "val_elbo", ".", "append", "(", "elbo_epoch", ")", "\n", "\n", "if", "e", "%", "100", "==", "0", ":", "\n", "                ", "kl_full", ",", "hellinger_full", "=", "0.", ",", "0.", "\n", "if", "args", ".", "num_nodes", "<=", "4", ":", "\n", "                    ", "kl_full", ",", "hellinger_full", "=", "full_kl_and_hellinger", "(", "model", ",", "bge_train", ",", "g_dist", ",", "args", ".", "device", ")", "\n", "\n", "", "print", "(", "'Epoch {}:  TRAIN - ELBO: {:.5f} likelihood: {:.5f} kl graph: {:.5f} VAL-ELBO: {:.5f} Temp Target {:.4f} Time {:.2f}'", ".", "format", "(", "e", ",", "el", ",", "li", ",", "kl_g", ",", "elbo_epoch", ",", "model", ".", "gibbs_temp", ",", "np", ".", "sum", "(", "time_epoch", "[", "e", "-", "100", ":", "e", "]", ")", ",", "flush", "=", "True", ")", ")", "\n", "\n", "torch", ".", "save", "(", "{", "'model'", ":", "model", ".", "state_dict", "(", ")", ",", "'best_elbo'", ":", "best_elbo", ",", "'saved_epoch'", ":", "e", ",", "'time'", ":", "time_epoch", ",", "'likelihood'", ":", "likelihood", ",", "'kl_graph'", ":", "kl_graph", ",", "'elbo_train'", ":", "elbo_train", ",", "'val_elbo'", ":", "val_elbo", ",", "'baseline'", ":", "baseline", "}", ",", "osp", ".", "join", "(", "args", ".", "save_path", ",", "'last_saved_model.pth'", ")", ")", "\n", "\n", "", "", "torch", ".", "save", "(", "{", "'model'", ":", "model", ".", "state_dict", "(", ")", ",", "'best_elbo'", ":", "best_elbo", ",", "'saved_epoch'", ":", "args", ".", "epochs", ",", "'time'", ":", "time_epoch", ",", "'likelihood'", ":", "likelihood", ",", "'kl_graph'", ":", "kl_graph", ",", "'elbo_train'", ":", "elbo_train", ",", "'val_elbo'", ":", "val_elbo", ",", "'baseline'", ":", "baseline", "}", ",", "osp", ".", "join", "(", "args", ".", "save_path", ",", "'best_model.pth'", ")", ")", "\n", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "osp", ".", "join", "(", "args", ".", "save_path", ",", "'best_model.pth'", ")", ")", "[", "'model'", "]", ")", "\n", "shd", ",", "prc", ",", "rec", "=", "exp_shd", "(", "model", ",", "train_data", ".", "adjacency_matrix", ")", "\n", "kl_full", "=", "0.", "\n", "hellinger_full", "=", "0.", "\n", "auroc_score", "=", "0.", "\n", "if", "args", ".", "num_nodes", "<=", "4", ":", "\n", "        ", "kl_full", ",", "hellinger_full", "=", "full_kl_and_hellinger", "(", "model", ",", "bge_train", ",", "g_dist", ",", "args", ".", "device", ")", "\n", "", "else", ":", "\n", "        ", "auroc_score", "=", "auroc", "(", "model", ",", "train_data", ".", "adjacency_matrix", ")", "\n", "\n", "", "print", "(", "'Exp SHD:'", ",", "shd", ",", "'Exp Precision:'", ",", "prc", ",", "'Exp Recall:'", ",", "rec", ",", "'Kl_full:'", ",", "kl_full", ",", "'hellinger_full:'", ",", "hellinger_full", ",", "'auroc:'", ",", "auroc_score", ")", "\n", "\n", "with", "open", "(", "osp", ".", "join", "(", "args", ".", "save_path", ",", "'results.pkl'", ")", ",", "'wb'", ")", "as", "bb", ":", "\n", "            ", "pkl", ".", "dump", "(", "{", "'likelihood'", ":", "likelihood", ",", "'kl_graph'", ":", "kl_graph", ",", "'elbo_train'", ":", "elbo_train", ",", "'elbo_val'", ":", "val_elbo", ",", "'kl_best_full'", ":", "kl_full", ",", "'hellinger_best_full'", ":", "hellinger_full", ",", "'time'", ":", "time_epoch", ",", "'baseline'", ":", "baseline", ",", "'exp_shd'", ":", "shd", ",", "'exp_prc'", ":", "prc", ",", "'exp_rec'", ":", "rec", ",", "'auroc'", ":", "auroc_score", "}", ",", "bb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.simulate_gaussian_sem": [[15, 31], ["torch.exp", "torch.exp", "torch.zeros().to", "torch.zeros().to", "range", "len", "networkx.topological_sort", "torch.zeros", "torch.zeros", "torch.normal", "torch.normal", "list", "len", "len", "graph.predecessors", "len"], "function", ["None"], ["def", "simulate_gaussian_sem", "(", "graphs", ",", "w_logvar", ")", ":", "\n", "\t", "std", "=", "torch", ".", "exp", "(", "0.5", "*", "w_logvar", ")", "\n", "samples", "=", "torch", ".", "zeros", "(", "len", "(", "graphs", ")", ",", "len", "(", "graphs", "[", "0", "]", ".", "nodes", ")", ")", ".", "to", "(", "w_logvar", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "graphs", ")", ")", ":", "\n", "\t\t", "graph", "=", "graphs", "[", "i", "]", "\n", "for", "j", "in", "nx", ".", "topological_sort", "(", "graph", ")", ":", "\n", "\t\t\t", "noise", "=", "torch", ".", "normal", "(", "mean", "=", "0.", ",", "std", "=", "std", "[", "i", ",", "j", "]", ")", "\n", "parents", "=", "list", "(", "graph", ".", "predecessors", "(", "j", ")", ")", "\n", "if", "len", "(", "parents", ")", "==", "0", ":", "\n", "\t\t\t\t", "samples", "[", "i", ",", "j", "]", "=", "noise", "\n", "", "else", ":", "\n", "\t\t\t\t", "curr", "=", "noise", "\n", "for", "k", "in", "parents", ":", "\n", "\t\t\t\t\t", "curr", "+=", "graph", ".", "edges", "[", "k", ",", "j", "]", "[", "'weight'", "]", "*", "samples", "[", "i", ",", "k", "]", "\n", "", "samples", "[", "i", ",", "j", "]", "=", "curr", "\n", "", "", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.matrix_poly": [[32, 35], ["torch.matrix_power", "torch.matrix_power", "torch.eye().to", "torch.eye().to", "torch.div", "torch.div", "torch.eye", "torch.eye"], "function", ["None"], ["", "def", "matrix_poly", "(", "matrix", ",", "d", ")", ":", "\n", "\t", "x", "=", "torch", ".", "eye", "(", "d", ")", ".", "to", "(", "matrix", ".", "device", ")", "+", "torch", ".", "div", "(", "matrix", ",", "d", ")", "\n", "return", "torch", ".", "matrix_power", "(", "x", ",", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.expm": [[36, 40], ["utils.matrix_poly", "matrix_poly.diagonal().sum", "matrix_poly.diagonal"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.matrix_poly"], ["", "def", "expm", "(", "A", ",", "m", ")", ":", "\n", "\t", "expm_A", "=", "matrix_poly", "(", "A", ",", "m", ")", "\n", "h_A", "=", "expm_A", ".", "diagonal", "(", "dim1", "=", "-", "2", ",", "dim2", "=", "-", "1", ")", ".", "sum", "(", "-", "1", ")", "-", "m", "\n", "return", "h_A", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.matrix_poly_np": [[41, 44], ["numpy.linalg.matrix_power", "numpy.eye", "numpy.divide"], "function", ["None"], ["", "def", "matrix_poly_np", "(", "matrix", ",", "d", ")", ":", "\n", "\t", "x", "=", "np", ".", "eye", "(", "d", ")", "+", "np", ".", "divide", "(", "matrix", ",", "d", ")", "\n", "return", "np", ".", "linalg", ".", "matrix_power", "(", "x", ",", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.expm_np": [[45, 49], ["utils.matrix_poly_np", "numpy.trace"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.matrix_poly_np"], ["", "def", "expm_np", "(", "A", ",", "m", ")", ":", "\n", "\t", "expm_A", "=", "matrix_poly_np", "(", "A", ",", "m", ")", "\n", "h_A", "=", "np", ".", "trace", "(", "expm_A", ")", "-", "m", "\n", "return", "h_A", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations": [[50, 56], ["list", "numpy.array", "itertools.product", "utils.vec_to_adj_mat_np", "list", "range"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat_np"], ["", "def", "all_combinations", "(", "num_nodes", ",", "num_classes", "=", "2", ",", "return_adj", "=", "False", ")", ":", "\n", "\t", "comb", "=", "list", "(", "product", "(", "list", "(", "range", "(", "num_classes", ")", ")", ",", "repeat", "=", "num_nodes", "*", "(", "num_nodes", "-", "1", ")", ")", ")", "\n", "comb", "=", "np", ".", "array", "(", "comb", ")", "\n", "if", "return_adj", ":", "\n", "\t\t", "comb", "=", "vec_to_adj_mat_np", "(", "comb", ",", "num_nodes", ")", "\n", "", "return", "comb", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.full_prior": [[57, 74], ["utils.all_combinations", "numpy.zeros", "numpy.zeros", "range", "numpy.sum", "len", "len", "numpy.concatenate", "range", "utils.expm_np", "numpy.exp", "len", "numpy.roll", "numpy.zeros", "comb[].reshape", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np"], ["", "def", "full_prior", "(", "num_nodes", ",", "num_classes", "=", "2", ",", "data_size", "=", "None", ",", "gibbs_temp", "=", "10.", ",", "sparsity_factor", "=", "0.", ")", ":", "\n", "\t", "if", "data_size", "is", "None", ":", "\n", "\t\t", "data_size", "=", "num_nodes", "*", "(", "num_nodes", "-", "1", ")", "\n", "", "comb", "=", "all_combinations", "(", "num_classes", ",", "data_size", ")", "\n", "\n", "ref_config", "=", "np", ".", "zeros", "(", "len", "(", "comb", ")", ")", "\n", "comb_full", "=", "np", ".", "zeros", "(", "(", "len", "(", "comb", ")", ",", "num_nodes", ",", "num_nodes", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "comb", ")", ")", ":", "\n", "#print(i, len(comb))", "\n", "\t\t", "temp_", "=", "np", ".", "concatenate", "(", "(", "np", ".", "zeros", "(", "(", "num_nodes", ",", "1", ")", ")", ",", "(", "comb", "[", "i", "]", ".", "reshape", "(", "(", "num_nodes", ",", "num_nodes", "-", "1", ")", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "for", "j", "in", "range", "(", "num_nodes", ")", ":", "\n", "\t\t\t", "comb_full", "[", "i", ",", "j", "]", "=", "np", ".", "roll", "(", "temp_", "[", "j", "]", ",", "j", ")", "\n", "", "resid", "=", "expm_np", "(", "comb_full", "[", "i", "]", ",", "num_nodes", ")", "\n", "ref_config", "[", "i", "]", "=", "np", ".", "exp", "(", "-", "gibbs_temp", "*", "resid", "-", "sparsity_factor", "*", "np", ".", "sum", "(", "temp_", ")", ")", "\n", "", "norm_factor", "=", "np", ".", "sum", "(", "ref_config", ")", "\n", "ref_config", "=", "ref_config", "/", "norm_factor", "\n", "return", "ref_config", ",", "comb", ",", "norm_factor", ",", "comb_full", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat": [[75, 81], ["matrix.view.view", "torch.cat", "torch.cat", "range", "torch.roll", "torch.roll", "torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros"], "function", ["None"], ["", "def", "vec_to_adj_mat", "(", "matrix", ",", "num_nodes", ")", ":", "\n", "\t", "matrix", "=", "matrix", ".", "view", "(", "-", "1", ",", "num_nodes", ",", "num_nodes", "-", "1", ")", "\n", "matrix_full", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros", "(", "matrix", ".", "shape", "[", "0", "]", ",", "num_nodes", ",", "1", ")", ".", "to", "(", "matrix", ".", "device", ")", ",", "matrix", ")", ",", "dim", "=", "-", "1", ")", "\n", "for", "xx", "in", "range", "(", "num_nodes", ")", ":", "\n", "\t\t", "matrix_full", "[", ":", ",", "xx", "]", "=", "torch", ".", "roll", "(", "matrix_full", "[", ":", ",", "xx", "]", ",", "xx", ",", "-", "1", ")", "\n", "", "return", "matrix_full", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat_np": [[82, 88], ["numpy.reshape", "numpy.concatenate", "range", "numpy.roll", "numpy.zeros", "scipy.special.comb"], "function", ["None"], ["", "def", "vec_to_adj_mat_np", "(", "matrix", ",", "num_nodes", ")", ":", "\n", "\t", "matrix", "=", "np", ".", "reshape", "(", "matrix", ",", "(", "-", "1", ",", "num_nodes", ",", "num_nodes", "-", "1", ")", ")", "\n", "matrix_full", "=", "np", ".", "concatenate", "(", "(", "np", ".", "zeros", "(", "(", "matrix", ".", "shape", "[", "0", "]", ",", "num_nodes", ",", "1", ")", ",", "dtype", "=", "matrix", ".", "dtype", ")", ",", "matrix", ")", ",", "axis", "=", "-", "1", ")", "\n", "for", "xx", "in", "range", "(", "num_nodes", ")", ":", "\n", "\t\t", "matrix_full", "[", ":", ",", "xx", "]", "=", "np", ".", "roll", "(", "matrix_full", "[", ":", ",", "xx", "]", ",", "xx", ",", "axis", "=", "-", "1", ")", "\n", "", "return", "matrix_full", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.adj_mat_to_vec": [[89, 94], ["range", "matrix.reshape", "torch.roll", "torch.roll"], "function", ["None"], ["", "def", "adj_mat_to_vec", "(", "matrix_full", ",", "num_nodes", ")", ":", "\n", "\t", "for", "xx", "in", "range", "(", "num_nodes", ")", ":", "\n", "\t\t", "matrix_full", "[", ":", ",", "xx", "]", "=", "torch", ".", "roll", "(", "matrix_full", "[", ":", ",", "xx", "]", ",", "-", "xx", ",", "-", "1", ")", "\n", "", "matrix", "=", "matrix_full", "[", "...", ",", "1", ":", "]", "\n", "return", "matrix", ".", "reshape", "(", "-", "1", ",", "num_nodes", "*", "(", "num_nodes", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.adj_mat_to_vec_np": [[95, 100], ["range", "numpy.reshape", "numpy.roll"], "function", ["None"], ["", "def", "adj_mat_to_vec_np", "(", "matrix_full", ",", "num_nodes", ")", ":", "\n", "\t", "for", "xx", "in", "range", "(", "num_nodes", ")", ":", "\n", "\t\t", "matrix_full", "[", ":", ",", "xx", "]", "=", "np", ".", "roll", "(", "matrix_full", "[", ":", ",", "xx", "]", ",", "-", "xx", ",", "axis", "=", "-", "1", ")", "\n", "", "matrix", "=", "np", ".", "reshape", "(", "matrix_full", "[", "...", ",", "1", ":", "]", ",", "(", "matrix_full", ".", "shape", "[", "0", "]", ",", "num_nodes", "*", "(", "num_nodes", "-", "1", ")", ")", ")", "\n", "return", "matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.shd": [[101, 166], ["numpy.flatnonzero", "numpy.flatnonzero", "numpy.flatnonzero", "numpy.flatnonzero", "numpy.concatenate", "numpy.intersect1d", "numpy.intersect1d", "numpy.concatenate", "numpy.setdiff1d", "numpy.setdiff1d", "numpy.concatenate", "numpy.setdiff1d", "numpy.intersect1d", "numpy.flatnonzero", "numpy.flatnonzero", "numpy.setdiff1d", "numpy.setdiff1d", "len", "len", "len", "float", "max", "float", "max", "float", "max", "numpy.tril", "numpy.tril", "len", "len", "float", "max", "ValueError", "ValueError", "ValueError", "len", "len", "len", "len", "len", "float", "len", "len", "len", "len", "len", "len", "len"], "function", ["None"], ["", "def", "shd", "(", "B_est", ",", "B_true", ")", ":", "\n", "\t", "\"\"\"Compute various accuracy metrics for B_est.\n\n\ttrue positive = predicted association exists in condition in correct direction\n\treverse = predicted association exists in condition in opposite direction\n\tfalse positive = predicted association does not exist in condition\n\n\tArgs:\n\t\tB_true (np.ndarray): [d, d] ground truth graph, {0, 1}\n\t\tB_est (np.ndarray): [d, d] estimate, {0, 1, -1}, -1 is undirected edge in CPDAG\n\n\tReturns:\n\t\tfdr: (reverse + false positive) / prediction positive\n\t\ttpr: (true positive) / condition positive\n\t\tfpr: (reverse + false positive) / condition negative\n\t\tshd: undirected extra + undirected missing + reverse\n\t\tnnz: prediction positive\n\n\t\tTaken from https://github.com/xunzheng/notears\n\t\"\"\"", "\n", "if", "(", "B_est", "==", "-", "1", ")", ".", "any", "(", ")", ":", "# cpdag", "\n", "\t\t", "if", "not", "(", "(", "B_est", "==", "0", ")", "|", "(", "B_est", "==", "1", ")", "|", "(", "B_est", "==", "-", "1", ")", ")", ".", "all", "(", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'B_est should take value in {0,1,-1}'", ")", "\n", "", "if", "(", "(", "B_est", "==", "-", "1", ")", "&", "(", "B_est", ".", "T", "==", "-", "1", ")", ")", ".", "any", "(", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'undirected edge should only appear once'", ")", "\n", "", "", "else", ":", "# dag", "\n", "\t\t", "if", "not", "(", "(", "B_est", "==", "0", ")", "|", "(", "B_est", "==", "1", ")", ")", ".", "all", "(", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'B_est should take value in {0,1}'", ")", "\n", "#if not is_dag(B_est):", "\n", "#    raise ValueError('B_est should be a DAG')", "\n", "", "", "d", "=", "B_true", ".", "shape", "[", "0", "]", "\n", "# linear index of nonzeros", "\n", "pred_und", "=", "np", ".", "flatnonzero", "(", "B_est", "==", "-", "1", ")", "\n", "pred", "=", "np", ".", "flatnonzero", "(", "B_est", "==", "1", ")", "\n", "cond", "=", "np", ".", "flatnonzero", "(", "B_true", ")", "\n", "cond_reversed", "=", "np", ".", "flatnonzero", "(", "B_true", ".", "T", ")", "\n", "cond_skeleton", "=", "np", ".", "concatenate", "(", "[", "cond", ",", "cond_reversed", "]", ")", "\n", "# true pos", "\n", "true_pos", "=", "np", ".", "intersect1d", "(", "pred", ",", "cond", ",", "assume_unique", "=", "True", ")", "\n", "# treat undirected edge favorably", "\n", "true_pos_und", "=", "np", ".", "intersect1d", "(", "pred_und", ",", "cond_skeleton", ",", "assume_unique", "=", "True", ")", "\n", "true_pos", "=", "np", ".", "concatenate", "(", "[", "true_pos", ",", "true_pos_und", "]", ")", "\n", "# false pos", "\n", "false_pos", "=", "np", ".", "setdiff1d", "(", "pred", ",", "cond_skeleton", ",", "assume_unique", "=", "True", ")", "\n", "false_pos_und", "=", "np", ".", "setdiff1d", "(", "pred_und", ",", "cond_skeleton", ",", "assume_unique", "=", "True", ")", "\n", "false_pos", "=", "np", ".", "concatenate", "(", "[", "false_pos", ",", "false_pos_und", "]", ")", "\n", "# reverse", "\n", "extra", "=", "np", ".", "setdiff1d", "(", "pred", ",", "cond", ",", "assume_unique", "=", "True", ")", "\n", "reverse", "=", "np", ".", "intersect1d", "(", "extra", ",", "cond_reversed", ",", "assume_unique", "=", "True", ")", "\n", "# compute ratio", "\n", "pred_size", "=", "len", "(", "pred", ")", "+", "len", "(", "pred_und", ")", "\n", "cond_neg_size", "=", "0.5", "*", "d", "*", "(", "d", "-", "1", ")", "-", "len", "(", "cond", ")", "\n", "fdr", "=", "float", "(", "len", "(", "reverse", ")", "+", "len", "(", "false_pos", ")", ")", "/", "max", "(", "pred_size", ",", "1", ")", "\n", "tpr", "=", "float", "(", "len", "(", "true_pos", ")", ")", "/", "max", "(", "len", "(", "cond", ")", ",", "1", ")", "\n", "fpr", "=", "float", "(", "len", "(", "reverse", ")", "+", "len", "(", "false_pos", ")", ")", "/", "max", "(", "cond_neg_size", ",", "1", ")", "\n", "# structural hamming distance", "\n", "pred_lower", "=", "np", ".", "flatnonzero", "(", "np", ".", "tril", "(", "B_est", "+", "B_est", ".", "T", ")", ")", "\n", "cond_lower", "=", "np", ".", "flatnonzero", "(", "np", ".", "tril", "(", "B_true", "+", "B_true", ".", "T", ")", ")", "\n", "extra_lower", "=", "np", ".", "setdiff1d", "(", "pred_lower", ",", "cond_lower", ",", "assume_unique", "=", "True", ")", "\n", "missing_lower", "=", "np", ".", "setdiff1d", "(", "cond_lower", ",", "pred_lower", ",", "assume_unique", "=", "True", ")", "\n", "shd", "=", "len", "(", "extra_lower", ")", "+", "len", "(", "missing_lower", ")", "+", "len", "(", "reverse", ")", "\n", "shd_wc", "=", "shd", "+", "len", "(", "pred_und", ")", "\n", "prc", "=", "float", "(", "len", "(", "true_pos", ")", ")", "/", "max", "(", "float", "(", "len", "(", "true_pos", ")", "+", "len", "(", "reverse", ")", "+", "len", "(", "false_pos", ")", ")", ",", "1.", ")", "\n", "rec", "=", "tpr", "\n", "return", "{", "'fdr'", ":", "fdr", ",", "'tpr'", ":", "tpr", ",", "'fpr'", ":", "fpr", ",", "'prc'", ":", "prc", ",", "'rec'", ":", "rec", ",", "'shd'", ":", "shd", ",", "'shd_wc'", ":", "shd_wc", ",", "'nnz'", ":", "pred_size", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.kl_mdag": [[167, 169], ["torch.nn.functional.kl_div", "torch.nn.functional.kl_div"], "function", ["None"], ["", "def", "kl_mdag", "(", "log_probs", ",", "probs_gt", ")", ":", "\n", "\t", "return", "torch", ".", "nn", ".", "functional", ".", "kl_div", "(", "log_probs", ",", "probs_gt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.one_hot": [[170, 179], ["inputs.flatten().unsqueeze().long.flatten().unsqueeze().long", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to.scatter_", "torch.zeros().to.view", "inputs.flatten().unsqueeze().long.max", "inputs.flatten().unsqueeze().long.flatten().unsqueeze", "torch.zeros", "torch.zeros", "len", "inputs.flatten().unsqueeze().long.flatten"], "function", ["None"], ["", "def", "one_hot", "(", "inputs", ",", "vocab_size", "=", "None", ")", ":", "\n", "\t", "\"\"\"Returns one hot of data over each element of the inputs\"\"\"", "\n", "if", "vocab_size", "is", "None", ":", "\n", "\t\t", "vocab_size", "=", "inputs", ".", "max", "(", ")", "+", "1", "\n", "", "input_shape", "=", "inputs", ".", "shape", "\n", "inputs", "=", "inputs", ".", "flatten", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "long", "(", ")", "\n", "z", "=", "torch", ".", "zeros", "(", "len", "(", "inputs", ")", ",", "vocab_size", ")", ".", "to", "(", "inputs", ".", "device", ")", "\n", "z", ".", "scatter_", "(", "1", ",", "inputs", ",", "1.", ")", "\n", "return", "z", ".", "view", "(", "*", "input_shape", ",", "vocab_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.__init__": [[6, 16], ["super().__init__", "torch.randn().clone().detach().requires_grad_().to", "torch.nn.Parameter", "torch.randn().clone().detach().requires_grad_", "torch.randn().clone().detach", "torch.randn().clone", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_nodes", ",", "temp_rsample", "=", "0.1", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_nodes", "=", "n_nodes", "\n", "self", ".", "n_dim_out", "=", "n_nodes", "*", "(", "n_nodes", "-", "1", ")", "\n", "self", ".", "temp_rsample", "=", "temp_rsample", "\n", "self", ".", "device", "=", "device", "\n", "\n", "base_log_probs", "=", "torch", ".", "randn", "(", "self", ".", "n_dim_out", ",", "1", ")", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "requires_grad_", "(", "True", ")", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "params", "=", "torch", ".", "nn", ".", "Parameter", "(", "base_log_probs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.forward": [[17, 21], ["torch.distributions.Bernoulli", "torch.distributions.Bernoulli.log_prob().sum", "torch.distributions.Bernoulli.log_prob"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "dist", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "logits", "=", "self", ".", "params", ")", "\n", "log_prob", "=", "dist", ".", "log_prob", "(", "inputs", ")", ".", "sum", "(", "dim", "=", "(", "1", ")", ")", "\n", "return", "log_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.sample": [[22, 28], ["factorised_base.FactorisedBase._sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._sample"], ["", "def", "sample", "(", "self", ",", "size", ",", "return_logprobs", "=", "False", ")", ":", "\n", "        ", "samples", ",", "logprobs", "=", "self", ".", "_sample", "(", "size", ",", "reparametrized", "=", "False", ")", "\n", "if", "return_logprobs", ":", "\n", "            ", "return", "samples", ",", "logprobs", "\n", "", "else", ":", "\n", "            ", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.rsample": [[29, 35], ["factorised_base.FactorisedBase._sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._sample"], ["", "", "def", "rsample", "(", "self", ",", "size", ",", "return_logprobs", "=", "False", ",", "temp", "=", "None", ",", "hard", "=", "False", ")", ":", "\n", "        ", "samples", ",", "logprobs", "=", "self", ".", "_sample", "(", "size", ",", "reparametrized", "=", "True", ",", "temp", "=", "temp", ",", "hard", "=", "hard", ")", "\n", "if", "return_logprobs", ":", "\n", "            ", "return", "samples", ",", "logprobs", "\n", "", "else", ":", "\n", "            ", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase._sample": [[36, 53], ["factorised_base.FactorisedBase.forward", "torch.distributions.RelaxedBernoulli().rsample", "torch.distributions.Bernoulli().sample", "utils.one_hot", "torch.argmax", "torch.distributions.RelaxedBernoulli", "torch.distributions.Bernoulli"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.forward", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.rsample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.one_hot"], ["", "", "def", "_sample", "(", "self", ",", "batch_size", ",", "reparametrized", "=", "False", ",", "temp", "=", "None", ",", "hard", "=", "False", ")", ":", "\n", "\n", "        ", "if", "temp", "is", "None", ":", "\n", "            ", "temp", "=", "self", ".", "temp_rsample", "\n", "\n", "", "if", "reparametrized", ":", "\n", "            ", "_sample", "=", "torch", ".", "distributions", ".", "RelaxedBernoulli", "(", "temperature", "=", "temp", ",", "logits", "=", "self", ".", "params", ")", ".", "rsample", "(", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "_sample", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "logits", "=", "self", ".", "params", ")", ".", "sample", "(", "batch_size", ")", "\n", "\n", "", "samples", "=", "_sample", "\n", "if", "reparametrized", "and", "hard", ":", "\n", "            ", "samples_hard", "=", "utils", ".", "one_hot", "(", "torch", ".", "argmax", "(", "_sample", ",", "-", "1", ")", ",", "2", ")", "\n", "samples", "=", "(", "samples_hard", "-", "samples", ")", ".", "detach", "(", ")", "+", "samples", "\n", "\n", "", "logprobs", "=", "self", ".", "forward", "(", "samples", ")", "\n", "return", "samples", ",", "logprobs", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.log_prob": [[55, 59], ["factorised_base.FactorisedBase.forward", "len", "value.unsqueeze.unsqueeze.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.forward"], ["", "def", "log_prob", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "len", "(", "value", ".", "shape", ")", "<", "3", ":", "\n", "            ", "value", "=", "value", ".", "unsqueeze", "(", "-", "1", ")", "\n", "", "return", "self", ".", "forward", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.entropy": [[60, 69], ["min", "torch.sum", "factorised_base.FactorisedBase.log_prob", "factorised_base.FactorisedBase.sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "entropy", "(", "self", ",", "n_samples", "=", "10", "**", "6", ")", ":", "\n", "        ", "bs", "=", "100000", "\n", "curr", "=", "0", "\n", "ent", "=", "0.", "\n", "while", "curr", "<", "n_samples", ":", "\n", "            ", "curr_batch_size", "=", "min", "(", "bs", ",", "n_samples", "-", "curr", ")", "\n", "ent", "-=", "torch", ".", "sum", "(", "self", ".", "log_prob", "(", "self", ".", "sample", "(", "[", "curr_batch_size", "]", ")", ")", ")", "\n", "curr", "+=", "curr_batch_size", "\n", "", "return", "ent", "/", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.factorised_base.FactorisedBase.mode": [[71, 80], ["factorised_base.FactorisedBase.sample", "torch.argmax", "samples[].unsqueeze", "utils.vec_to_adj_mat().squeeze", "utils.vec_to_adj_mat", "utils.vec_to_adj_mat().squeeze.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat"], ["", "def", "mode", "(", "self", ",", "n_samples", "=", "1000", ",", "return_adj", "=", "True", ",", "return_logprob", "=", "False", ")", ":", "\n", "        ", "samples", ",", "logprobs", "=", "self", ".", "sample", "(", "(", "n_samples", ",", ")", ",", "return_logprobs", "=", "True", ")", "\n", "max_idx", "=", "torch", ".", "argmax", "(", "logprobs", ")", "\n", "mode_", "=", "samples", "[", "max_idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "return_adj", ":", "\n", "            ", "mode_", "=", "utils", ".", "vec_to_adj_mat", "(", "mode_", ".", "unsqueeze", "(", "0", ")", ",", "self", ".", "n_nodes", ")", ".", "squeeze", "(", ")", "\n", "", "if", "return_logprob", ":", "\n", "            ", "return", "mode_", ",", "logprobs", "[", "max_idx", "]", "\n", "", "return", "mode_", "", "", "", ""]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.__init__": [[7, 26], ["super().__init__", "torch.nn.LSTM", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.zeros", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["def", "__init__", "(", "self", ",", "n_nodes", ",", "hidden_dim", "=", "48", ",", "n_layers", "=", "3", ",", "temp_rsample", "=", "0.1", ",", "device", "=", "'cpu'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_nodes", "=", "n_nodes", "\n", "self", ".", "n_dim_out", "=", "n_nodes", "*", "(", "n_nodes", "-", "1", ")", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_classes", "=", "1", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "temp_rsample", "=", "temp_rsample", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "rnn", "=", "torch", ".", "nn", ".", "LSTM", "(", "self", ".", "hidden_dim", ",", "self", ".", "hidden_dim", ",", "num_layers", "=", "n_layers", ",", "batch_first", "=", "True", ")", "\n", "self", ".", "proj", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "hidden_dim", ",", "self", ".", "n_classes", ")", "\n", "self", ".", "embed", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "n_classes", ",", "self", ".", "hidden_dim", ")", "\n", "\n", "self", ".", "h0", "=", "torch", ".", "nn", ".", "Parameter", "(", "1e-3", "*", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_layers", ",", "self", ".", "hidden_dim", ")", ")", "\n", "self", ".", "c0", "=", "torch", ".", "nn", ".", "Parameter", "(", "1e-3", "*", "torch", ".", "randn", "(", "1", ",", "self", ".", "n_layers", ",", "self", ".", "hidden_dim", ")", ")", "\n", "\n", "# create variable for the initial input of the LSTM", "\n", "self", ".", "_init_input_param", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "1", ",", "self", ".", "n_classes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.forward": [[27, 33], ["autoreg_base.AutoregressiveBase.embed", "autoreg_base.AutoregressiveBase.rnn", "autoreg_base.AutoregressiveBase._t", "autoreg_base.AutoregressiveBase.proj", "autoreg_base.AutoregressiveBase._t"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._t", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._t"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "state", ")", ":", "\n", "        ", "inputs", "=", "self", ".", "embed", "(", "inputs", ")", "\n", "out", ",", "state", "=", "self", ".", "rnn", "(", "inputs", ",", "self", ".", "_t", "(", "state", ")", ")", "\n", "state", "=", "self", ".", "_t", "(", "state", ")", "\n", "logit", "=", "self", ".", "proj", "(", "out", ")", "\n", "return", "logit", ",", "state", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.sample": [[34, 40], ["autoreg_base.AutoregressiveBase._sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._sample"], ["", "def", "sample", "(", "self", ",", "size", ",", "return_states", "=", "False", ",", "start_step", "=", "0", ",", "start_state", "=", "None", ",", "init_input", "=", "None", ")", ":", "\n", "        ", "samples", ",", "states", ",", "logits", "=", "self", ".", "_sample", "(", "size", ",", "reparametrized", "=", "False", ",", "start_step", "=", "start_step", ",", "start_state", "=", "start_state", ",", "init_input", "=", "init_input", ")", "\n", "if", "return_states", ":", "\n", "            ", "return", "samples", ",", "states", ",", "logits", "\n", "", "else", ":", "\n", "            ", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.rsample": [[41, 47], ["autoreg_base.AutoregressiveBase._sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._sample"], ["", "", "def", "rsample", "(", "self", ",", "size", ",", "return_states", "=", "False", ",", "temp", "=", "None", ",", "hard", "=", "False", ",", "start_step", "=", "0", ",", "start_state", "=", "None", ",", "init_input", "=", "None", ")", ":", "\n", "        ", "samples", ",", "states", ",", "logits", "=", "self", ".", "_sample", "(", "size", ",", "reparametrized", "=", "True", ",", "temp", "=", "temp", ",", "hard", "=", "hard", ",", "start_step", "=", "start_step", ",", "start_state", "=", "start_state", ",", "init_input", "=", "init_input", ")", "\n", "if", "return_states", ":", "\n", "            ", "return", "samples", ",", "states", ",", "logits", "\n", "", "else", ":", "\n", "            ", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._sample": [[48, 88], ["range", "torch.cat", "len", "autoreg_base.AutoregressiveBase._get_state", "autoreg_base.AutoregressiveBase._init_input", "autoreg_base.AutoregressiveBase.forward", "sampled_tokens.append", "state_array_1.append", "state_array_2.append", "logit_array.append", "torch.stack", "torch.stack", "utils.one_hot", "torch.distributions.RelaxedBernoulli().rsample", "torch.distributions.Bernoulli().sample", "torch.argmax", "torch.distributions.RelaxedBernoulli", "torch.distributions.Bernoulli"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._get_state", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._init_input", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.forward", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.one_hot", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.rsample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "", "def", "_sample", "(", "self", ",", "batch_size", ",", "reparametrized", "=", "False", ",", "temp", "=", "None", ",", "hard", "=", "False", ",", "start_step", "=", "0", ",", "start_state", "=", "None", ",", "init_input", "=", "None", ")", ":", "\n", "        ", "assert", "len", "(", "batch_size", ")", "==", "1", "\n", "batch_size", "=", "batch_size", "[", "0", "]", "\n", "\n", "if", "temp", "is", "None", ":", "\n", "            ", "temp", "=", "[", "self", ".", "temp_rsample", "]", "*", "self", ".", "n_dim_out", "\n", "", "if", "start_state", "is", "None", ":", "\n", "            ", "state", "=", "self", ".", "_get_state", "(", "batch_size", ")", "# hidden / cell state at t=0", "\n", "", "else", ":", "\n", "            ", "state", "=", "start_state", "\n", "", "if", "init_input", "is", "None", ":", "\n", "            ", "input", "=", "self", ".", "_init_input", "(", "batch_size", ")", "# input at t=0", "\n", "", "else", ":", "\n", "            ", "input", "=", "init_input", "\n", "\n", "", "sampled_tokens", "=", "[", "]", "\n", "state_array_1", "=", "[", "]", "\n", "state_array_2", "=", "[", "]", "\n", "logit_array", "=", "[", "]", "\n", "\n", "for", "t", "in", "range", "(", "start_step", ",", "self", ".", "n_dim_out", ")", ":", "\n", "            ", "logits", ",", "state", "=", "self", ".", "forward", "(", "input", ",", "state", ")", "\n", "if", "reparametrized", ":", "\n", "                ", "_sample", "=", "torch", ".", "distributions", ".", "RelaxedBernoulli", "(", "temperature", "=", "temp", "[", "t", "]", ",", "logits", "=", "logits", ")", ".", "rsample", "(", ")", "\n", "", "else", ":", "\n", "                ", "_sample", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "logits", "=", "logits", ")", ".", "sample", "(", ")", "\n", "", "input", "=", "_sample", "\n", "sampled_tokens", ".", "append", "(", "_sample", ")", "\n", "state_array_1", ".", "append", "(", "state", "[", "0", "]", ")", "\n", "state_array_2", ".", "append", "(", "state", "[", "1", "]", ")", "\n", "logit_array", ".", "append", "(", "logits", ")", "\n", "\n", "", "samples", "=", "torch", ".", "cat", "(", "sampled_tokens", ",", "dim", "=", "1", ")", "\n", "states", "=", "[", "torch", ".", "stack", "(", "state_array_1", ",", "dim", "=", "1", ")", ",", "torch", ".", "stack", "(", "state_array_2", ",", "dim", "=", "1", ")", "]", "\n", "logits", "=", "logit_array", "\n", "if", "reparametrized", "and", "hard", ":", "\n", "            ", "samples_hard", "=", "utils", ".", "one_hot", "(", "torch", ".", "argmax", "(", "samples", ",", "-", "1", ")", ",", "2", ")", "\n", "samples", "=", "(", "samples_hard", "-", "samples", ")", ".", "detach", "(", ")", "+", "samples", "\n", "\n", "", "return", "samples", ",", "states", ",", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob": [[90, 104], ["autoreg_base.AutoregressiveBase._get_state", "autoreg_base.AutoregressiveBase._init_input", "torch.cat", "autoreg_base.AutoregressiveBase.forward", "torch.distributions.Bernoulli().log_prob().sum", "torch.distributions.Bernoulli().log_prob", "torch.distributions.Bernoulli"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._get_state", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._init_input", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.forward", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob"], ["", "def", "log_prob", "(", "self", ",", "value", ",", "return_logits", "=", "False", ")", ":", "\n", "        ", "batch_size", ",", "n_dim_out_value", ",", "_", "=", "value", ".", "shape", "\n", "assert", "n_dim_out_value", "==", "self", ".", "n_dim_out", "\n", "# add start value", "\n", "state", "=", "self", ".", "_get_state", "(", "batch_size", ")", "# hidden / cell state at t=0", "\n", "input", "=", "self", ".", "_init_input", "(", "batch_size", ")", "# input at t=0", "\n", "value", "=", "torch", ".", "cat", "(", "[", "input", ",", "value", "]", ",", "dim", "=", "-", "2", ")", "\n", "logits", ",", "_", "=", "self", ".", "forward", "(", "value", ",", "state", ")", "\n", "logits", "=", "logits", "[", ":", ",", ":", "-", "1", ",", ":", "]", "\n", "value", "=", "value", "[", ":", ",", "1", ":", "]", "\n", "log_probs", "=", "torch", ".", "distributions", ".", "Bernoulli", "(", "logits", "=", "logits", ")", ".", "log_prob", "(", "value", ")", ".", "sum", "(", "1", ")", "\n", "if", "return_logits", ":", "\n", "            ", "return", "log_probs", ",", "logits", "\n", "", "return", "log_probs", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.entropy": [[105, 114], ["min", "torch.sum", "autoreg_base.AutoregressiveBase.log_prob", "autoreg_base.AutoregressiveBase.sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "entropy", "(", "self", ",", "n_samples", "=", "10", "**", "6", ")", ":", "\n", "        ", "bs", "=", "100000", "\n", "curr", "=", "0", "\n", "ent", "=", "0.", "\n", "while", "curr", "<", "n_samples", ":", "\n", "            ", "curr_batch_size", "=", "min", "(", "bs", ",", "n_samples", "-", "curr", ")", "\n", "ent", "-=", "torch", ".", "sum", "(", "self", ".", "log_prob", "(", "self", ".", "sample", "(", "[", "curr_batch_size", "]", ")", ")", ")", "\n", "curr", "+=", "curr_batch_size", "\n", "", "return", "ent", "/", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._get_state": [[115, 117], ["autoreg_base.AutoregressiveBase.h0.repeat", "autoreg_base.AutoregressiveBase.c0.repeat"], "methods", ["None"], ["", "def", "_get_state", "(", "self", ",", "batch_size", "=", "1", ")", ":", "\n", "        ", "return", "(", "self", ".", "h0", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", ",", "self", ".", "c0", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._init_input": [[118, 120], ["autoreg_base.AutoregressiveBase._init_input_param.expand"], "methods", ["None"], ["", "def", "_init_input", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "return", "self", ".", "_init_input_param", ".", "expand", "(", "batch_size", ",", "1", ",", "self", ".", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.mode": [[121, 130], ["autoreg_base.AutoregressiveBase.sample", "torch.argmax", "samples[].unsqueeze", "utils.vec_to_adj_mat().squeeze", "utils.vec_to_adj_mat", "utils.vec_to_adj_mat().squeeze.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat"], ["", "def", "mode", "(", "self", ",", "n_samples", "=", "1000", ",", "return_adj", "=", "True", ",", "return_logprob", "=", "False", ")", ":", "\n", "        ", "samples", ",", "logprobs", "=", "self", ".", "sample", "(", "(", "n_samples", ",", ")", ",", "return_logprobs", "=", "True", ")", "\n", "max_idx", "=", "torch", ".", "argmax", "(", "logprobs", ")", "\n", "mode_", "=", "samples", "[", "max_idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "if", "return_adj", ":", "\n", "            ", "mode_", "=", "utils", ".", "vec_to_adj_mat", "(", "mode_", ".", "unsqueeze", "(", "0", ")", ",", "self", ".", "n_nodes", ")", ".", "squeeze", "(", ")", "\n", "", "if", "return_logprob", ":", "\n", "            ", "return", "mode_", ",", "logprobs", "[", "max_idx", "]", "\n", "", "return", "mode_", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase._t": [[131, 134], ["t.transpose().contiguous", "t.transpose"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_t", "(", "a", ")", ":", "\n", "        ", "return", "[", "t", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "for", "t", "in", "a", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.__init__": [[23, 71], ["super().__init__", "torch.tensor", "torch.tensor().to.mean", "torch.matmul", "torch.arange", "isinstance", "torch.tensor().to", "torch.eye", "x_center.t", "torch.tensor", "torch.matmul", "numpy.log", "torch.special.gammaln", "numpy.log", "torch.special.gammaln", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["def", "__init__", "(", "self", ",", "*", ",", "\n", "mean_obs", ",", "\n", "alpha_mu", ",", "\n", "alpha_lambd", ",", "\n", "data", ",", "\n", "device", "=", "\"cpu\"", "\n", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tmean_obs : [num_nodes] : Mean of each Gaussian distributed variable (Prior)\n\t\talpha_mu : torch.float64 : Hyperparameter of Wishart Prior\n\t\talpha_lambd : \n\t\tdata : [n_samples, num_nodes] If provided, precomputes the posterior parameter R\n\t\t\"\"\"", "\n", "super", "(", "BGe", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mean_obs", "=", "torch", ".", "tensor", "(", "mean_obs", ")", "\n", "self", ".", "alpha_mu", "=", "alpha_mu", "\n", "self", ".", "alpha_lambd", "=", "alpha_lambd", "\n", "self", ".", "device", "=", "device", "\n", "\n", "if", "not", "isinstance", "(", "data", ",", "torch", ".", "DoubleTensor", ")", ":", "\n", "\t\t\t", "data", "=", "torch", ".", "tensor", "(", "data", ")", ".", "to", "(", "torch", ".", "float64", ")", "\n", "\n", "", "self", ".", "N", ",", "self", ".", "d", "=", "data", ".", "shape", "\n", "# pre-compute matrices", "\n", "small_t", "=", "(", "self", ".", "alpha_mu", "*", "(", "self", ".", "alpha_lambd", "-", "self", ".", "d", "-", "1", ")", ")", "/", "(", "self", ".", "alpha_mu", "+", "1", ")", "\n", "T", "=", "small_t", "*", "torch", ".", "eye", "(", "self", ".", "d", ")", "\n", "\n", "x_bar", "=", "data", ".", "mean", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "x_center", "=", "data", "-", "x_bar", "\n", "s_N", "=", "torch", ".", "matmul", "(", "x_center", ".", "t", "(", ")", ",", "x_center", ")", "# [d, d]", "\n", "\n", "# Kuipers (2014) states R wrongly in the paper, using alpha_lambd rather than alpha_mu;", "\n", "# the supplementary contains the correct term", "\n", "self", ".", "R", "=", "(", "T", "+", "s_N", "+", "(", "(", "self", ".", "N", "*", "self", ".", "alpha_mu", ")", "/", "(", "self", ".", "N", "+", "self", ".", "alpha_mu", ")", ")", "*", "(", "torch", ".", "matmul", "(", "(", "x_bar", "-", "self", ".", "mean_obs", ")", ".", "t", "(", ")", ",", "x_bar", "-", "self", ".", "mean_obs", ")", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "all_l", "=", "torch", ".", "arange", "(", "self", ".", "d", ")", "\n", "\n", "self", ".", "log_gamma_terms", "=", "(", "\n", "0.5", "*", "(", "np", ".", "log", "(", "self", ".", "alpha_mu", ")", "-", "np", ".", "log", "(", "self", ".", "N", "+", "self", ".", "alpha_mu", ")", ")", "\n", "+", "torch", ".", "special", ".", "gammaln", "(", "0.5", "*", "(", "self", ".", "N", "+", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "all_l", "+", "1", ")", ")", "\n", "-", "torch", ".", "special", ".", "gammaln", "(", "0.5", "*", "(", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "all_l", "+", "1", ")", ")", "\n", "-", "0.5", "*", "self", ".", "N", "*", "np", ".", "log", "(", "np", ".", "pi", ")", "\n", "# log det(T_JJ)^(..) / det(T_II)^(..) for default T", "\n", "+", "0.5", "*", "(", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "2", "*", "all_l", "+", "1", ")", "*", "np", ".", "log", "(", "small_t", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.slogdet_pytorch": [[72, 89], ["bge_model.BGe.unsqueeze().expand", "parents.to().to.to().to.to().to", "torch.matmul().to", "torch.where", "torch.where", "bge_model.BGe.R.clone", "torch.tensor().to", "torch.isnan", "torch.eye().unsqueeze().expand().to", "torch.linalg.slogdet", "bge_model.BGe.unsqueeze", "parents.to().to.to().to.to", "torch.matmul", "parents.to().to.to().to.unsqueeze", "parents.to().to.to().to.unsqueeze", "torch.tensor", "torch.eye().unsqueeze().expand", "torch.eye().unsqueeze", "torch.eye"], "methods", ["None"], ["", "def", "slogdet_pytorch", "(", "self", ",", "parents", ",", "R", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tBatched log determinant of a submatrix\n\t\tDone by masking everything but the submatrix and\n\t\tadding a diagonal of ones everywhere else for the \n\t\tvalid determinant\n\t\t\"\"\"", "\n", "\n", "if", "R", "is", "None", ":", "\n", "\t\t\t", "R", "=", "self", ".", "R", ".", "clone", "(", ")", "\n", "", "batch_size", "=", "parents", ".", "shape", "[", "0", "]", "\n", "R", "=", "R", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "-", "1", ",", "-", "1", ")", "\n", "parents", "=", "parents", ".", "to", "(", "torch", ".", "float64", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "mask", "=", "torch", ".", "matmul", "(", "parents", ".", "unsqueeze", "(", "2", ")", ",", "parents", ".", "unsqueeze", "(", "1", ")", ")", ".", "to", "(", "torch", ".", "bool", ")", "#[batch_size, d,d]", "\n", "R", "=", "torch", ".", "where", "(", "mask", ",", "R", ",", "torch", ".", "tensor", "(", "[", "np", ".", "nan", "]", ",", "device", "=", "self", ".", "device", ")", ".", "to", "(", "torch", ".", "float64", ")", ")", "\n", "submat", "=", "torch", ".", "where", "(", "torch", ".", "isnan", "(", "R", ")", ",", "torch", ".", "eye", "(", "self", ".", "d", ",", "dtype", "=", "torch", ".", "float64", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "-", "1", ",", "-", "1", ")", ".", "to", "(", "self", ".", "device", ")", ",", "R", ")", "\n", "return", "torch", ".", "linalg", ".", "slogdet", "(", "submat", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.log_marginal_likelihood_given_g_j": [[90, 114], ["[].long", "torch.zeros", "torch.log", "torch.abs", "bge_model.BGe.slogdet_pytorch", "bge_model.BGe.slogdet_pytorch", "w.sum", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.slogdet_pytorch", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.slogdet_pytorch"], ["", "def", "log_marginal_likelihood_given_g_j", "(", "self", ",", "j", ",", "w", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tComputes node specific terms of BGe metric\n\t\tj : Node to compute the marginal likelihood. Marginal Likelihood decomposes over each node.\n\t\tw : [batch_size, num_nodes, num_nodes] : {0,1} adjacency matrix \n\t\t\"\"\"", "\n", "\n", "batch_size", "=", "w", ".", "shape", "[", "0", "]", "\n", "isj", "=", "(", "torch", ".", "arange", "(", "self", ".", "d", ")", "==", "j", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "-", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "parents", "=", "w", "[", ":", ",", ":", ",", "j", "]", "==", "1", "\n", "parents_and_j", "=", "parents", "|", "isj", "\n", "n_parents", "=", "(", "w", ".", "sum", "(", "axis", "=", "1", ")", "[", ":", ",", "j", "]", ")", ".", "long", "(", ")", "\n", "n_parents_mask", "=", "n_parents", "==", "0", "\n", "_log_term_r_no_parents", "=", "-", "0.5", "*", "(", "self", ".", "N", "+", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "1", ")", "*", "torch", ".", "log", "(", "torch", ".", "abs", "(", "self", ".", "R", "[", "j", ",", "j", "]", ")", ")", "\n", "\n", "_log_term_r", "=", "0.5", "*", "(", "self", ".", "N", "+", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "n_parents", "[", "~", "n_parents_mask", "]", ")", "*", "self", ".", "slogdet_pytorch", "(", "parents", "[", "~", "n_parents_mask", "]", ")", "-", "0.5", "*", "(", "self", ".", "N", "+", "self", ".", "alpha_lambd", "-", "self", ".", "d", "+", "n_parents", "[", "~", "n_parents_mask", "]", "+", "1", ")", "*", "self", ".", "slogdet_pytorch", "(", "parents_and_j", "[", "~", "n_parents_mask", "]", ")", "# log det(R_II)^(..) / det(R_JJ)^(..)", "\n", "\n", "log_term_r", "=", "torch", ".", "zeros", "(", "batch_size", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "self", ".", "device", ")", "\n", "log_term_r", "[", "n_parents_mask", "]", "=", "_log_term_r_no_parents", "\n", "log_term_r", "[", "~", "n_parents_mask", "]", "=", "_log_term_r", "\n", "return", "log_term_r", "+", "self", ".", "log_gamma_terms", "[", "n_parents", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.log_marginal_likelihood_given_g": [[116, 132], ["torch.zeros", "range", "torch.zeros().to", "bge_model.BGe.log_marginal_likelihood_given_g_j", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.bge_model.BGe.log_marginal_likelihood_given_g_j"], ["", "def", "log_marginal_likelihood_given_g", "(", "self", ",", "*", ",", "w", ",", "interv_targets", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Computes log p(x | G) in closed form using conjugacy properties\n\t\t\tw:     [batch_size, num_nodes, num_nodes]\t{0,1} adjacency marix\n\t\t\tinterv_targets: [batch_size, num_nodes] boolean mask of whether or not a node was intervened on\n\t\t\t\t\tintervened nodes are ignored in likelihood computation\n\t\t\"\"\"", "\n", "batch_size", "=", "w", ".", "shape", "[", "0", "]", "\n", "if", "interv_targets", "is", "None", ":", "\n", "\t\t\t", "interv_targets", "=", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "d", ")", ".", "to", "(", "torch", ".", "bool", ")", "\n", "", "interv_targets", "=", "(", "~", "interv_targets", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# sum scores for all nodes", "\n", "mll", "=", "torch", ".", "zeros", "(", "batch_size", ",", "dtype", "=", "torch", ".", "float64", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "d", ")", ":", "\n", "#print(self.log_marginal_likelihood_given_g_j(i, w)[interv_targets[:,i]]) ", "\n", "\t\t\t", "mll", "[", "interv_targets", "[", ":", ",", "i", "]", "]", "+=", "self", ".", "log_marginal_likelihood_given_g_j", "(", "i", ",", "w", ")", "[", "interv_targets", "[", ":", ",", "i", "]", "]", "##TODO: Possible to use torch.vmap but should be okay for now ", "\n", "", "return", "mll", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.__init__": [[7, 14], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["\t", "def", "__init__", "(", "self", ",", "*", ",", "num_nodes", ",", "graph_dist", ",", "sparsity_factor", "=", "0.0", ",", "gibbs_temp_init", "=", "10.", ",", "gibbs_update", "=", "None", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_nodes", "=", "num_nodes", "\n", "self", ".", "graph_dist", "=", "graph_dist", "\n", "self", ".", "sparsity_factor", "=", "sparsity_factor", "\n", "self", ".", "gibbs_temp", "=", "gibbs_temp_init", "\n", "self", ".", "gibbs_update", "=", "gibbs_update", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.forward": [[15, 26], ["vcn.VCN.graph_dist.sample", "vcn.VCN.graph_dist.log_prob().squeeze", "utils.vec_to_adj_mat", "bge_model.log_marginal_likelihood_given_g", "utils.expm", "vcn.VCN.update_gibbs_temp", "vcn.VCN.graph_dist.log_prob", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.expm", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.update_gibbs_temp", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.autoreg_base.AutoregressiveBase.log_prob"], ["", "def", "forward", "(", "self", ",", "n_samples", ",", "bge_model", ",", "e", ",", "interv_targets", "=", "None", ")", ":", "\n", "\t\t", "samples", "=", "self", ".", "graph_dist", ".", "sample", "(", "[", "n_samples", "]", ")", "\n", "log_probs", "=", "self", ".", "graph_dist", ".", "log_prob", "(", "samples", ")", ".", "squeeze", "(", ")", "\n", "\n", "G", "=", "utils", ".", "vec_to_adj_mat", "(", "samples", ",", "self", ".", "num_nodes", ")", "\n", "likelihood", "=", "bge_model", ".", "log_marginal_likelihood_given_g", "(", "w", "=", "G", ",", "interv_targets", "=", "interv_targets", ")", "\n", "\n", "dagness", "=", "utils", ".", "expm", "(", "G", ",", "self", ".", "num_nodes", ")", "\n", "self", ".", "update_gibbs_temp", "(", "e", ")", "\n", "kl_graph", "=", "log_probs", "+", "self", ".", "gibbs_temp", "*", "dagness", "+", "self", ".", "sparsity_factor", "*", "torch", ".", "sum", "(", "G", ",", "axis", "=", "[", "-", "1", ",", "-", "2", "]", ")", "\n", "return", "likelihood", ",", "kl_graph", ",", "log_probs", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.sample": [[28, 32], ["vcn.VCN.graph_dist.sample", "utils.vec_to_adj_mat"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.vec_to_adj_mat"], ["", "def", "sample", "(", "self", ",", "num_samples", "=", "10000", ")", ":", "\n", "\t\t", "samples", "=", "self", ".", "graph_dist", ".", "sample", "(", "[", "num_samples", "]", ")", "\n", "G", "=", "utils", ".", "vec_to_adj_mat", "(", "ret", ",", "self", ".", "num_nodes", ")", "\n", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.models.vcn.VCN.update_gibbs_temp": [[33, 38], ["vcn.VCN.gibbs_update"], "methods", ["None"], ["", "def", "update_gibbs_temp", "(", "self", ",", "e", ")", ":", "\n", "\t\t", "if", "self", ".", "gibbs_update", "is", "None", ":", "\n", "\t\t\t", "return", "0", "\n", "", "else", ":", "\n", "\t\t\t", "self", ".", "gibbs_temp", "=", "self", ".", "gibbs_update", "(", "self", ".", "gibbs_temp", ",", "e", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.ER.__init__": [[20, 38], ["generator.Generator.__init__", "erdos_renyi.ER.init_sampler", "erdos_renyi.ER.sample", "float", "len", "networkx.generators.random_graphs.fast_gnp_random_graph", "networkx.generators.random_graphs.gnp_random_graph", "erdos_renyi.expm_np", "networkx.to_numpy_matrix", "erdos_renyi.num_mec"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.init_sampler", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.num_mec"], ["def", "__init__", "(", "self", ",", "num_nodes", ",", "exp_edges", "=", "1", ",", "noise_type", "=", "'isotropic-gaussian'", ",", "noise_sigma", "=", "1.0", ",", "num_samples", "=", "1000", ",", "mu_prior", "=", "2.0", ",", "sigma_prior", "=", "1.0", ",", "seed", "=", "10", ")", ":", "\n", "\t\t", "self", ".", "noise_sigma", "=", "noise_sigma", "\n", "p", "=", "float", "(", "exp_edges", ")", "/", "(", "num_nodes", "-", "1", ")", "\n", "acyclic", "=", "0", "\n", "mmec", "=", "0", "\n", "count", "=", "1", "\n", "while", "not", "(", "acyclic", "and", "mmec", ")", ":", "\n", "\t\t\t", "if", "exp_edges", "<=", "2", ":", "\n", "\t\t\t\t", "self", ".", "graph", "=", "nx", ".", "generators", ".", "random_graphs", ".", "fast_gnp_random_graph", "(", "num_nodes", ",", "p", ",", "directed", "=", "True", ",", "seed", "=", "seed", "*", "count", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "self", ".", "graph", "=", "nx", ".", "generators", ".", "random_graphs", ".", "gnp_random_graph", "(", "num_nodes", ",", "p", ",", "directed", "=", "True", ",", "seed", "=", "seed", "*", "count", ")", "\n", "", "acyclic", "=", "expm_np", "(", "nx", ".", "to_numpy_matrix", "(", "self", ".", "graph", ")", ",", "num_nodes", ")", "==", "0", "\n", "if", "acyclic", ":", "\n", "\t\t\t\t", "mmec", "=", "num_mec", "(", "self", ".", "graph", ")", ">=", "2", "\n", "", "count", "+=", "1", "\n", "", "super", "(", ")", ".", "__init__", "(", "num_nodes", ",", "len", "(", "self", ".", "graph", ".", "edges", ")", ",", "noise_type", ",", "num_samples", ",", "mu_prior", "=", "mu_prior", ",", "sigma_prior", "=", "sigma_prior", ",", "seed", "=", "seed", ")", "\n", "self", ".", "init_sampler", "(", ")", "\n", "self", ".", "samples", "=", "self", ".", "sample", "(", "self", ".", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.ER.__getitem__": [[39, 41], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "\t\t", "return", "self", ".", "samples", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.matrix_poly_np": [[42, 45], ["numpy.linalg.matrix_power", "numpy.eye"], "function", ["None"], ["", "", "def", "matrix_poly_np", "(", "matrix", ",", "d", ")", ":", "\n", "\t", "x", "=", "np", ".", "eye", "(", "d", ")", "+", "matrix", "/", "d", "\n", "return", "np", ".", "linalg", ".", "matrix_power", "(", "x", ",", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np": [[46, 50], ["erdos_renyi.matrix_poly_np", "numpy.trace"], "function", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.matrix_poly_np"], ["", "def", "expm_np", "(", "A", ",", "m", ")", ":", "\n", "\t", "expm_A", "=", "matrix_poly_np", "(", "A", ",", "m", ")", "\n", "h_A", "=", "np", ".", "trace", "(", "expm_A", ")", "-", "m", "\n", "return", "h_A", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.num_mec": [[51, 56], ["graphical_models.DAG.from_nx", "graphical_models.DAG.from_nx.cpdag", "a.cpdag.all_dags", "len"], "function", ["None"], ["", "def", "num_mec", "(", "m", ")", ":", "\n", "\t", "a", "=", "graphical_models", ".", "DAG", ".", "from_nx", "(", "m", ")", "\n", "skeleton", "=", "a", ".", "cpdag", "(", ")", "##Find the skeleton", "\n", "all_dags", "=", "skeleton", ".", "all_dags", "(", ")", "#Find all DAGs in MEC", "\n", "return", "len", "(", "all_dags", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.__init__": [[12, 25], ["generator.Generator.reseed", "generator.Generator.sample_weights", "generator.Generator.build_graph", "locals"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.reseed", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample_weights", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.build_graph"], ["def", "__init__", "(", "self", ",", "num_nodes", ",", "num_edges", ",", "noise_type", ",", "num_samples", ",", "mu_prior", "=", "None", ",", "sigma_prior", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "\t\t", "self", ".", "num_nodes", "=", "num_nodes", "\n", "self", ".", "num_edges", "=", "num_edges", "\n", "assert", "noise_type", "in", "NOISE_TYPES", ",", "'Noise types must correspond to {} but got {}'", ".", "format", "(", "NOISE_TYPES", ",", "noise_type", ")", "\n", "self", ".", "noise_type", "=", "noise_type", "\n", "self", ".", "num_samples", "=", "num_samples", "\n", "self", ".", "mu_prior", "=", "mu_prior", "\n", "self", ".", "sigma_prior", "=", "sigma_prior", "\n", "if", "seed", "is", "not", "None", ":", "\n", "\t\t\t", "self", ".", "reseed", "(", "seed", ")", "\n", "", "if", "not", "\"self.weighted_adjacency_matrix\"", "in", "locals", "(", ")", ":", "\n", "\t\t\t", "self", ".", "sample_weights", "(", ")", "\n", "self", ".", "build_graph", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.reseed": [[26, 29], ["torch.manual_seed", "numpy.random.seed"], "methods", ["None"], ["", "", "def", "reseed", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "\t\t", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.__getitem__": [[30, 32], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "\t\t", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.build_graph": [[33, 47], ["networkx.to_numpy_matrix", "generator.Generator.adjacency_matrix.copy", "networkx.topological_sort", "list", "generator.Generator.graph.predecessors", "len"], "methods", ["None"], ["", "def", "build_graph", "(", "self", ")", ":", "\n", "\t\t", "\"\"\" Initilises the adjacency matrix and the weighted adjacency matrix\"\"\"", "\n", "\n", "self", ".", "adjacency_matrix", "=", "nx", ".", "to_numpy_matrix", "(", "self", ".", "graph", ")", "\n", "self", ".", "weighted_adjacency_matrix", "=", "self", ".", "adjacency_matrix", ".", "copy", "(", ")", "\n", "edge_pointer", "=", "0", "\n", "for", "i", "in", "nx", ".", "topological_sort", "(", "self", ".", "graph", ")", ":", "\n", "\t\t\t", "parents", "=", "list", "(", "self", ".", "graph", ".", "predecessors", "(", "i", ")", ")", "\n", "if", "len", "(", "parents", ")", "==", "0", ":", "\n", "\t\t\t\t", "continue", "\n", "", "else", ":", "\n", "\t\t\t\t", "for", "j", "in", "parents", ":", "\n", "\t\t\t\t\t", "self", ".", "weighted_adjacency_matrix", "[", "j", ",", "i", "]", "=", "self", ".", "weights", "[", "edge_pointer", "]", "\n", "edge_pointer", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.init_sampler": [[48, 62], ["generator.Generator.noise_type.endswith", "range", "torch.distributions.normal.Normal", "range", "numpy.linspace", "torch.distributions.exponential.Exponential"], "methods", ["None"], ["", "", "", "", "def", "init_sampler", "(", "self", ")", ":", "\n", "\t\t", "if", "self", ".", "noise_type", ".", "endswith", "(", "'gaussian'", ")", ":", "\n", "#Identifiable", "\n", "\t\t\t", "if", "self", ".", "noise_type", "==", "'isotropic-gaussian'", ":", "\n", "\t\t\t\t", "noise_std", "=", "[", "self", ".", "noise_sigma", "]", "*", "self", ".", "num_nodes", "\n", "", "elif", "self", ".", "noise_type", "==", "'gaussian'", ":", "\n", "\t\t\t\t", "noise_std", "=", "np", ".", "linspace", "(", "0.1", ",", "3.", ",", "self", ".", "num_nodes", ")", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_nodes", ")", ":", "\n", "\t\t\t\t", "self", ".", "graph", ".", "nodes", "[", "i", "]", "[", "'sampler'", "]", "=", "torch", ".", "distributions", ".", "normal", ".", "Normal", "(", "0.", ",", "noise_std", "[", "i", "]", ")", "\n", "\n", "", "", "elif", "self", ".", "noise_type", "==", "'exponential'", ":", "\n", "\t\t\t", "noise_std", "=", "[", "self", ".", "noise_sigma", "]", "*", "self", ".", "num_nodes", "\n", "for", "i", "in", "range", "(", "self", ".", "num_nodes", ")", ":", "\n", "\t\t\t\t", "self", ".", "graph", ".", "nodes", "[", "i", "]", "[", "'sampler'", "]", "=", "torch", ".", "distributions", ".", "exponential", ".", "Exponential", "(", "noise_std", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample_weights": [[63, 79], ["print", "torch.distributions.normal.Normal().sample", "torch.distributions.uniform.Uniform", "torch.zeros", "range", "torch.distributions.normal.Normal", "torch.distributions.uniform.Uniform.sample"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "", "", "def", "sample_weights", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"Sample the edge weights\"\"\"", "\n", "\n", "if", "self", ".", "mu_prior", "is", "not", "None", ":", "\n", "\n", "\t\t\t", "self", ".", "weights", "=", "torch", ".", "distributions", ".", "normal", ".", "Normal", "(", "self", ".", "mu_prior", ",", "self", ".", "sigma_prior", ")", ".", "sample", "(", "[", "self", ".", "num_edges", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "dist", "=", "torch", ".", "distributions", ".", "uniform", ".", "Uniform", "(", "-", "5", ",", "5", ")", "\n", "self", ".", "weights", "=", "torch", ".", "zeros", "(", "self", ".", "num_edges", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "num_edges", ")", ":", "\n", "\t\t\t\t", "sample", "=", "0.", "\n", "while", "sample", ">", "-", "0.5", "and", "sample", "<", "0.5", ":", "\n", "\t\t\t\t\t", "sample", "=", "dist", ".", "sample", "(", ")", "\n", "self", ".", "weights", "[", "k", "]", "=", "sample", "\n", "\n", "", "", "", "print", "(", "self", ".", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample": [[80, 111], ["torch.zeros", "networkx.topological_sort", "list", "torch.tensor", "[].sample", "generator.Generator.graph.predecessors", "len"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "sample", "(", "self", ",", "num_samples", ",", "graph", "=", "None", ",", "node", "=", "None", ",", "value", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Sample observations given a graph\n\t\tnum_samples: Scalar\n\t\tgraph: networkx DiGraph\n\t\tnode: If intervention is performed, specify which node\n\t\tvalue: value set to node after intervention\n\n\t\tOutputs: Observations [num_samples x num_nodes]\n\t\t\"\"\"", "\n", "\n", "if", "graph", "is", "None", ":", "\n", "\t\t\t", "graph", "=", "self", ".", "graph", "\n", "\n", "", "samples", "=", "torch", ".", "zeros", "(", "num_samples", ",", "self", ".", "num_nodes", ")", "\n", "edge_pointer", "=", "0", "\n", "for", "i", "in", "nx", ".", "topological_sort", "(", "graph", ")", ":", "\n", "\t\t\t", "if", "i", "==", "node", ":", "\n", "\t\t\t\t", "noise", "=", "torch", ".", "tensor", "(", "[", "value", "]", "*", "num_samples", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "noise", "=", "self", ".", "graph", ".", "nodes", "[", "i", "]", "[", "'sampler'", "]", ".", "sample", "(", "[", "num_samples", "]", ")", "\n", "", "parents", "=", "list", "(", "self", ".", "graph", ".", "predecessors", "(", "i", ")", ")", "\n", "if", "len", "(", "parents", ")", "==", "0", ":", "\n", "\t\t\t\t", "samples", "[", ":", ",", "i", "]", "=", "noise", "\n", "", "else", ":", "\n", "\t\t\t\t", "curr", "=", "0.", "\n", "for", "j", "in", "parents", ":", "\n", "\t\t\t\t\t", "curr", "+=", "self", ".", "weighted_adjacency_matrix", "[", "j", ",", "i", "]", "*", "samples", "[", ":", ",", "j", "]", "\n", "edge_pointer", "+=", "1", "\n", "", "curr", "+=", "noise", "\n", "samples", "[", ":", ",", "i", "]", "=", "curr", "\n", "", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.intervene": [[112, 126], ["generator.Generator.adjacency_matrix.copy", "torch.randint", "torch.tensor", "generator.Generator.sample", "networkx.DiGraph", "torch.randint.item", "torch.tensor.item"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "intervene", "(", "self", ",", "num_samples", ",", "node", "=", "None", ",", "value", "=", "None", ")", ":", "\n", "\n", "\t\t", "\"\"\"Perform intervention to obtain a mutilated graph\"\"\"", "\n", "\n", "if", "node", "is", "None", ":", "\n", "\t\t\t", "node", "=", "torch", ".", "randint", "(", "self", ".", "num_nodes", ",", "(", "1", ",", ")", ")", "\n", "", "if", "value", "is", "None", ":", "\n", "#value = torch.distributions.uniform.Uniform(-5,5).sample()", "\n", "\t\t\t", "value", "=", "torch", ".", "tensor", "(", "2.0", ")", "\n", "\n", "", "mutated_graph", "=", "self", ".", "adjacency_matrix", ".", "copy", "(", ")", "\n", "mutated_graph", "[", ":", ",", "node", "]", "=", "0.", "#Cut off all the parents", "\n", "\n", "return", "self", ".", "sample", "(", "num_samples", ",", "nx", ".", "DiGraph", "(", "mutated_graph", ")", ",", "node", ".", "item", "(", ")", ",", "value", ".", "item", "(", ")", ")", ",", "node", ",", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.__len__": [[127, 129], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "\t\t", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GraphDistribution.__init__": [[17, 20], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "n_vars", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "self", ".", "n_vars", "=", "n_vars", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GraphDistribution.sample_G": [[21, 30], ["None"], "methods", ["None"], ["", "def", "sample_G", "(", "self", ",", "return_mat", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Samples graph according to distribution\n\n        n: number of vertices\n        Returns:\n            g: igraph.Graph \n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GraphDistribution.unnormalized_log_prob": [[31, 38], ["None"], "methods", ["None"], ["", "def", "unnormalized_log_prob", "(", "self", ",", "g", ")", ":", "\n", "        ", "\"\"\"\n        g: igraph.Graph object\n        Returns:\n            float   log p(G) + const, i.e. unnormalized\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GraphDistribution.log_normalization_constant": [[39, 51], ["numpy.zeros", "enumerate", "scipy.special.logsumexp", "len", "tqdm.tqdm", "distributions.GraphDistribution.unnormalized_log_prob"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.unnormalized_log_prob"], ["", "def", "log_normalization_constant", "(", "self", ",", "all_g", ")", ":", "\n", "        ", "\"\"\"\n        Computes normalization constant for log p(G), i.e. `Z = log(sum_G p(g))`\n        all_g: list of igraph.Graph objects\n        Returns:\n            float\n        \"\"\"", "\n", "log_prob_g_unn", "=", "np", ".", "zeros", "(", "len", "(", "all_g", ")", ")", "\n", "for", "i", ",", "g", "in", "enumerate", "(", "tqdm", ".", "tqdm", "(", "all_g", ",", "desc", "=", "'p(G) log_normalization_constant'", ",", "disable", "=", "not", "self", ".", "verbose", ")", ")", ":", "\n", "            ", "log_prob_g_unn", "[", "i", "]", "=", "self", ".", "unnormalized_log_prob", "(", "g", "=", "g", ")", "\n", "", "log_prob_sum_g", "=", "scipy", ".", "special", ".", "logsumexp", "(", "log_prob_g_unn", ")", "\n", "return", "log_prob_sum_g", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.UniformDAGDistributionRejection.__init__": [[62, 66], ["distributions.GraphDistribution.__init__"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["def", "__init__", "(", "self", ",", "n_vars", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", "UniformDAGDistributionRejection", ",", "self", ")", ".", "__init__", "(", "n_vars", "=", "n_vars", ",", "verbose", "=", "verbose", ")", "\n", "self", ".", "n_vars", "=", "n_vars", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.UniformDAGDistributionRejection.sample_G": [[67, 76], ["numpy.random.choice().reshape", "utils.expm_np", "numpy.random.choice", "networkx.DiGraph"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np"], ["", "def", "sample_G", "(", "self", ",", "return_mat", "=", "False", ")", ":", "\n", "        ", "\"\"\"Samples uniformly random DAG\"\"\"", "\n", "while", "True", ":", "\n", "            ", "mat", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "size", "=", "self", ".", "n_vars", "*", "self", ".", "n_vars", ")", ".", "reshape", "(", "self", ".", "n_vars", ",", "self", ".", "n_vars", ")", "\n", "if", "expm_np", "(", "mat", ")", "==", "0", ":", "\n", "                ", "if", "return_mat", ":", "\n", "                    ", "return", "mat", "\n", "", "else", ":", "\n", "                    ", "return", "nx", ".", "DiGraph", "(", "mat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.UniformDAGDistributionRejection.unnormalized_log_prob": [[77, 83], ["None"], "methods", ["None"], ["", "", "", "", "def", "unnormalized_log_prob", "(", "self", ",", "g", ")", ":", "\n", "        ", "\"\"\"\n        p(G) ~ 1\n        \"\"\"", "\n", "\n", "return", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsUniformDAGDistribution.__init__": [[89, 96], ["distributions.GraphDistribution.__init__"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__"], ["def", "__init__", "(", "self", ",", "n_vars", ",", "gibbs_temp", "=", "10.", ",", "sparsity_factor", "=", "0.0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", "GibbsUniformDAGDistribution", ",", "self", ")", ".", "__init__", "(", "n_vars", "=", "n_vars", ",", "verbose", "=", "verbose", ")", "\n", "self", ".", "n_vars", "=", "n_vars", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "gibbs_temp", "=", "gibbs_temp", "\n", "self", ".", "sparsity_factor", "=", "sparsity_factor", "\n", "self", ".", "z_g", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsUniformDAGDistribution.sample_G": [[97, 100], ["None"], "methods", ["None"], ["", "def", "sample_G", "(", "self", ",", "return_mat", "=", "False", ")", ":", "\n", "        ", "\"\"\"Samples almost uniformly random DAG\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsUniformDAGDistribution.unnormalized_log_prob": [[101, 108], ["utils.expm_np", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np"], ["", "def", "unnormalized_log_prob", "(", "self", ",", "g", ")", ":", "\n", "        ", "\"\"\"\n        p(G) ~ 1\n        \"\"\"", "\n", "mat", "=", "g", "\n", "dagness", "=", "expm_np", "(", "mat", ",", "self", ".", "n_vars", ")", "\n", "return", "-", "self", ".", "gibbs_temp", "*", "dagness", "-", "self", ".", "sparsity_factor", "*", "np", ".", "sum", "(", "mat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.__init__": [[114, 127], ["distributions.GraphDistribution.__init__", "utils.all_combinations", "numpy.zeros", "enumerate", "scipy.special.logsumexp", "len", "utils.expm_np", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np"], ["def", "__init__", "(", "self", ",", "n_vars", ",", "gibbs_temp", "=", "10.", ",", "sparsity_factor", "=", "0.0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", "GibbsDAGDistributionFull", ",", "self", ")", ".", "__init__", "(", "n_vars", "=", "n_vars", ",", "verbose", "=", "verbose", ")", "\n", "assert", "n_vars", "<=", "4", ",", "'Cannot use this for higher dimensional variables, Try UniformDAGDistributionRejection instead'", "\n", "self", ".", "n_vars", "=", "n_vars", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "gibbs_temp", "=", "gibbs_temp", "\n", "self", ".", "sparsity_factor", "=", "sparsity_factor", "\n", "all_g", "=", "all_combinations", "(", "n_vars", ",", "return_adj", "=", "True", ")", "#Do not store this in interest of memory", "\n", "dagness", "=", "np", ".", "zeros", "(", "len", "(", "all_g", ")", ")", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "all_g", ")", ":", "\n", "            ", "dagness", "[", "i", "]", "=", "expm_np", "(", "j", ",", "self", ".", "n_vars", ")", "\n", "", "self", ".", "logits", "=", "-", "gibbs_temp", "*", "dagness", "-", "sparsity_factor", "*", "np", ".", "sum", "(", "all_g", ",", "axis", "=", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "self", ".", "z_g", "=", "scipy", ".", "special", ".", "logsumexp", "(", "self", ".", "logits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.sample_G": [[128, 137], ["utils.all_combinations", "torch.distributions.Categorical().sample", "networkx.DiGraph", "torch.distributions.Categorical", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.None.utils.all_combinations", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.generator.Generator.sample"], ["", "def", "sample_G", "(", "self", ",", "return_mat", "=", "False", ")", ":", "\n", "        ", "\"\"\"Samples almost uniformly random DAG\"\"\"", "\n", "all_g", "=", "all_combinations", "(", "self", ".", "n_vars", ",", "return_adj", "=", "True", ")", "\n", "mat_id", "=", "torch", ".", "distributions", ".", "Categorical", "(", "logits", "=", "torch", ".", "tensor", "(", "self", ".", "logits", ")", ")", ".", "sample", "(", ")", "\n", "mat", "=", "all_g", "[", "mat_id", "]", "\n", "if", "return_mat", ":", "\n", "            ", "return", "mat", "\n", "", "else", ":", "\n", "            ", "return", "nx", ".", "DiGraph", "(", "mat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.unnormalized_log_prob": [[138, 145], ["utils.expm_np", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.erdos_renyi.expm_np"], ["", "", "def", "unnormalized_log_prob", "(", "self", ",", "g", ")", ":", "\n", "        ", "\"\"\"\n        p(G) ~ 1\n        \"\"\"", "\n", "mat", "=", "g", "\n", "dagness", "=", "expm_np", "(", "mat", ",", "self", ".", "n_vars", ")", "\n", "return", "-", "self", ".", "gibbs_temp", "*", "dagness", "-", "self", ".", "sparsity_factor", "*", "np", ".", "sum", "(", "mat", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__": [[26, 32], ["super().__init__", "basic.BasicModel.reseed"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.__init__", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.reseed"], ["def", "__init__", "(", "self", ",", "*", ",", "g_dist", ",", "verbose", "=", "False", ",", "seed", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "g_dist", "=", "g_dist", "\n", "self", ".", "reseed", "(", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.reseed": [[33, 38], ["numpy.random.seed", "torch.manual_seed"], "methods", ["None"], ["", "def", "reseed", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "        ", "if", "seed", "is", "None", ":", "\n", "            ", "return", "\n", "", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_parameters": [[39, 46], ["None"], "methods", ["None"], ["", "def", "sample_parameters", "(", "self", ",", "g", ")", ":", "\n", "        ", "\"\"\"Samples parameters given igraph.Graph g\n        For each variable i, sample parameters for every possible state of parents\n        Returns:\n            theta \n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_obs": [[47, 73], ["numpy.zeros", "scipy.stats.norm.rvs", "numpy.zeros.astype", "basic.BasicModel.sample_parameters", "g.topological_sorting", "g.incident", "list", "len", "len"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_parameters"], ["", "def", "sample_obs", "(", "self", ",", "n_samples", ",", "g", ",", "theta", "=", "None", ",", "toporder", "=", "None", ")", ":", "\n", "        ", "\"\"\"Samples `n_samples` observations given index i of graph and theta\n            n_samples : int\n            g : graph\n            theta : [n_edges]\n        Returns:\n            x : [n_samples, n_vars] \n        \"\"\"", "\n", "if", "theta", "is", "None", ":", "\n", "            ", "theta", "=", "self", ".", "sample_parameters", "(", "g", ")", "\n", "", "if", "toporder", "is", "None", ":", "\n", "            ", "toporder", "=", "g", ".", "topological_sorting", "(", ")", "\n", "\n", "", "x", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "len", "(", "g", ".", "vs", ")", ")", ")", "\n", "z", "=", "scipy", ".", "stats", ".", "norm", ".", "rvs", "(", "loc", "=", "0.0", ",", "scale", "=", "self", ".", "sig_obs", ",", "size", "=", "(", "n_samples", ",", "len", "(", "g", ".", "vs", ")", ")", ")", "\n", "\n", "# ancestral sampling", "\n", "for", "j", "in", "toporder", ":", "\n", "            ", "parent_edges", "=", "g", ".", "incident", "(", "j", ",", "mode", "=", "'in'", ")", "\n", "parents", "=", "list", "(", "g", ".", "es", "[", "e", "]", ".", "source", "for", "e", "in", "parent_edges", ")", "\n", "if", "parents", ":", "\n", "                ", "mean", "=", "x", "[", ":", ",", "parents", "]", "@", "theta", "[", "parents", ",", "j", "]", "\n", "x", "[", ":", ",", "j", "]", "=", "mean", "+", "z", "[", ":", ",", "j", "]", "\n", "", "else", ":", "\n", "                ", "x", "[", ":", ",", "j", "]", "=", "z", "[", ":", ",", "j", "]", "\n", "", "", "return", "x", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_prob_parameters": [[75, 79], ["None"], "methods", ["None"], ["", "def", "log_prob_parameters", "(", "self", ",", "theta", ",", "g", ")", ":", "\n", "        ", "\"\"\"Computes p(theta | G)\"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_likelihood": [[80, 84], ["None"], "methods", ["None"], ["", "def", "log_likelihood", "(", "self", ",", "x", ",", "theta", ",", "g", ")", ":", "\n", "        ", "\"\"\"Computes p(x | theta, G)\"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g": [[86, 93], ["None"], "methods", ["None"], ["", "def", "log_marginal_likelihood_given_g", "(", "self", ",", "g", ",", "x", ")", ":", "\n", "        ", "\"\"\"Computes log p(x | G) \n            x : [n_samples, n_vars]\n            g: graph\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood": [[95, 118], ["numpy.zeros", "enumerate", "scipy.special.logsumexp", "len", "basic.BasicModel.g_dist.log_normalization_constant", "tqdm.tqdm", "utils.mat_to_graph", "basic.BasicModel.log_marginal_likelihood_given_g", "basic.BasicModel.g_dist.unnormalized_log_prob"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GraphDistribution.log_normalization_constant", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.unnormalized_log_prob"], ["", "def", "log_marginal_likelihood", "(", "self", ",", "x", ",", "all_g", ",", "z_g", "=", "None", ",", "numpy", "=", "False", ")", ":", "\n", "        ", "\"\"\"Computes log p(x) in closed form using conjugacy properties of Dirichlet-Categorical\n            x : [n_samples, n_vars]\n            all_g : list of all possible igraph.Graph objects in domain; is exhaustively summed over\n        \"\"\"", "\n", "\n", "# log p(x, G)", "\n", "log_prob_obs_g", "=", "np", ".", "zeros", "(", "len", "(", "all_g", ")", ")", "\n", "\n", "# normalizing constant for log p(G) using exhaustive normalization", "\n", "if", "z_g", "is", "None", ":", "\n", "            ", "z_g", "=", "self", ".", "g_dist", ".", "log_normalization_constant", "(", "all_g", "=", "all_g", ")", "\n", "\n", "# log p(x, G)", "\n", "", "for", "i", ",", "g", "in", "enumerate", "(", "tqdm", ".", "tqdm", "(", "all_g", ",", "desc", "=", "'p(X) log_marginal_likelihood'", ",", "disable", "=", "not", "self", ".", "verbose", ")", ")", ":", "\n", "            ", "if", "numpy", ":", "\n", "                ", "g", "=", "mat_to_graph", "(", "g", ")", "\n", "# log p(x, G) = log (p(G)/Z) + log p(x | G)", "\n", "", "log_prob_obs_g", "[", "i", "]", "=", "self", ".", "g_dist", ".", "unnormalized_log_prob", "(", "g", "=", "g", ")", "-", "z_g", "+", "self", ".", "log_marginal_likelihood_given_g", "(", "g", "=", "g", ",", "x", "=", "x", ")", "\n", "\n", "# log p(x) = log(sum_G exp(log p(x, G)))", "\n", "", "return", "scipy", ".", "special", ".", "logsumexp", "(", "log_prob_obs_g", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_posterior_graph_given_obs": [[119, 131], ["basic.BasicModel.log_marginal_likelihood_given_g", "basic.BasicModel.g_dist.unnormalized_log_prob"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.unnormalized_log_prob"], ["", "def", "log_posterior_graph_given_obs", "(", "self", ",", "g", ",", "x", ",", "z_g", ",", "_log_marginal_likelihood", "=", "None", ")", ":", "\n", "        ", "\"\"\"Computes p(G | D) given the previously computed normalization constant\n            x : [..., n_vars]\n            i : int (graph)\n        \"\"\"", "\n", "\n", "log_prob_g", "=", "self", ".", "g_dist", ".", "unnormalized_log_prob", "(", "g", "=", "g", ")", "-", "z_g", "\n", "log_marginal_likelihood_given_g", "=", "self", ".", "log_marginal_likelihood_given_g", "(", "\n", "g", "=", "g", ",", "x", "=", "x", ")", "\n", "if", "_log_marginal_likelihood", "is", "None", ":", "\n", "            ", "return", "log_prob_g", "+", "log_marginal_likelihood_given_g", "\n", "", "return", "log_prob_g", "+", "log_marginal_likelihood_given_g", "-", "_log_marginal_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_posterior_weights_given_obs": [[132, 139], ["None"], "methods", ["None"], ["", "def", "sample_posterior_weights_given_obs", "(", "self", ",", "g", ",", "x", ")", ":", "\n", "        ", "\"\"\"Computes p(theta | G, D) \n            x : [..., n_vars]\n            i : int (graph)\n        \"\"\"", "\n", "\n", "raise", "NotImplementedError", "\n", "####", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_prob_parameters_mc": [[143, 166], ["range", "scipy.special.logsumexp", "int", "basic.BasicModel.g_dist.sample_G", "logliks.append", "basic.BasicModel.log_prob_parameters", "scipy.special.logsumexp", "print", "numpy.array", "numpy.log", "int", "numpy.array", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.sample_G", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_prob_parameters"], ["", "def", "log_prob_parameters_mc", "(", "self", ",", "theta", ",", "n_samples", "=", "3e4", ")", ":", "\n", "        ", "\"\"\"Approximates p(theta) using Monte Carlo integration\n            theta : parameters\n        \"\"\"", "\n", "\n", "logliks", "=", "[", "]", "\n", "for", "tt", "in", "range", "(", "int", "(", "n_samples", ")", ")", ":", "\n", "\n", "# sample from p(G)", "\n", "            ", "g", "=", "self", ".", "g_dist", ".", "sample_G", "(", ")", "\n", "\n", "# evaluate log prob p(theta | G)", "\n", "logliks", ".", "append", "(", "self", ".", "log_prob_parameters", "(", "theta", "=", "theta", ",", "g", "=", "g", ")", ")", "\n", "\n", "# print", "\n", "if", "not", "tt", "%", "int", "(", "n_samples", "/", "1000", ")", "and", "tt", ">", "0", ":", "\n", "                ", "curr", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "np", ".", "array", "(", "logliks", "[", ":", "tt", "+", "1", "]", ")", "-", "np", ".", "log", "(", "tt", "+", "1", ")", ")", "\n", "print", "(", "f'iter = {tt}: log p(theta | G) [MC] = {curr}'", ",", "end", "=", "'\\r'", ")", "\n", "\n", "", "", "log_prob_obs", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "np", ".", "array", "(", "logliks", ")", "-", "np", ".", "log", "(", "n_samples", ")", ")", "\n", "return", "log_prob_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_given_g_mc": [[167, 191], ["range", "scipy.special.logsumexp", "int", "basic.BasicModel.sample_parameters", "logliks.append", "basic.BasicModel.log_likelihood", "scipy.special.logsumexp", "print", "numpy.array", "numpy.log", "int", "numpy.array", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_parameters", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_likelihood"], ["", "def", "log_marginal_likelihood_given_g_mc", "(", "self", ",", "x", ",", "g", ",", "n_samples", "=", "3e4", ")", ":", "\n", "        ", "\"\"\"Approximates p(x | G) using Monte Carlo integration\n            x : [n_samples, n_vars]\n            g : graph\n        \"\"\"", "\n", "\n", "logliks", "=", "[", "]", "\n", "for", "tt", "in", "range", "(", "int", "(", "n_samples", ")", ")", ":", "\n", "\n", "# sample from p(theta | G)", "\n", "            ", "theta", "=", "self", ".", "sample_parameters", "(", "g", "=", "g", ")", "\n", "\n", "# evaluate likelihood log p(X | theta, G)", "\n", "logliks", ".", "append", "(", "self", ".", "log_likelihood", "(", "x", "=", "x", ",", "theta", "=", "theta", ",", "g", "=", "g", ")", ")", "\n", "\n", "# print", "\n", "if", "not", "tt", "%", "int", "(", "n_samples", "/", "1000", ")", "and", "tt", ">", "0", ":", "\n", "                ", "curr", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "np", ".", "array", "(", "logliks", "[", ":", "tt", "+", "1", "]", ")", "-", "np", ".", "log", "(", "tt", "+", "1", ")", ")", "\n", "print", "(", "f'iter = {tt}: log p(X | G) [MC] = {curr}'", ",", "end", "=", "'\\r'", ")", "\n", "\n", "", "", "log_prob_obs", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "np", ".", "array", "(", "logliks", ")", "-", "np", ".", "log", "(", "n_samples", ")", ")", "\n", "return", "log_prob_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_marginal_likelihood_mc": [[192, 215], ["range", "print", "scipy.special.logsumexp", "int", "basic.BasicModel.g_dist.sample_G", "basic.BasicModel.sample_parameters", "logliks.append", "basic.BasicModel.log_likelihood", "scipy.special.logsumexp", "print", "numpy.log", "int", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.distributions.GibbsDAGDistributionFull.sample_G", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.sample_parameters", "home.repos.pwc.inspect_result.yannadani_vcn_pytorch.data.basic.BasicModel.log_likelihood"], ["", "def", "log_marginal_likelihood_mc", "(", "self", ",", "x", ",", "n_samples", "=", "3e4", ")", ":", "\n", "        ", "\"\"\"Approximates normalization constant p(x) using Monte Carlo integration\n            x : [n_samples, n_vars]\n        \"\"\"", "\n", "\n", "logliks", "=", "[", "]", "\n", "for", "tt", "in", "range", "(", "int", "(", "n_samples", ")", ")", ":", "\n", "\n", "# sample from p(G, theta) = p(G) p(theta | G)", "\n", "            ", "g", "=", "self", ".", "g_dist", ".", "sample_G", "(", ")", "\n", "theta", "=", "self", ".", "sample_parameters", "(", "g", "=", "g", ")", "\n", "\n", "# evaluate likelihood log p(X | theta, G)", "\n", "logliks", ".", "append", "(", "self", ".", "log_likelihood", "(", "x", "=", "x", ",", "theta", "=", "theta", ",", "g", "=", "g", ")", ")", "\n", "\n", "# print", "\n", "if", "not", "tt", "%", "int", "(", "n_samples", "/", "1000", ")", "and", "tt", ">", "0", ":", "\n", "                ", "curr", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "(", "logliks", "[", ":", "tt", "+", "1", "]", "-", "np", ".", "log", "(", "tt", "+", "1", ")", ")", ")", "\n", "print", "(", "f'iter = {tt}: log p(X) [MC] = {curr}'", ",", "end", "=", "'\\r'", ")", "\n", "", "", "print", "(", ")", "\n", "log_prob_obs", "=", "scipy", ".", "special", ".", "logsumexp", "(", "(", "logliks", "-", "np", ".", "log", "(", "n_samples", ")", ")", ")", "\n", "return", "log_prob_obs", "\n", "", "", ""]]}