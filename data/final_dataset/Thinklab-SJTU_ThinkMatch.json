{"home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.train_eval_qap.train_eval_model": [[18, 178], ["print", "time.time", "len", "print", "torch.lr_scheduler.MultiStepLR", "range", "print", "next", "pathlib.Path", "checkpoint_path.exists", "checkpoint_path.mkdir", "str", "str", "len", "len", "print", "src.utils.model_sl.load_model", "len", "print", "optimizer.load_state_dict", "print", "print", "model.train", "print", "time.time", "src.utils.model_sl.save_model", "torch.save", "print", "print", "eval_qap.eval_model", "torch.mean", "tfboard_writer.add_scalars", "optim.lr_scheduler.MultiStepLR.step", "time.time", "model.parameters", "torch.load", "inputs[].cuda", "optimizer.zero_grad", "str", "optimizer.state_dict", "str", "torch.device", "src.utils.data_to_cuda.data_to_cuda", "torch.set_grad_enabled", "zip", "torch.autograd.set_detect_anomaly", "model", "model.parameters", "torch.sum.item", "tfboard_writer.add_scalars", "dict", "tfboard_writer.add_scalars", "type", "criterion", "torch.sum.backward", "optimizer.step", "l.item", "torch.sum.item", "inputs[].cuda.size", "torch.sum.item", "inputs[].cuda.size", "print", "tfboard_writer.add_scalars", "time.time", "criterion", "amp.scale_loss", "scaled_loss.backward", "torch.any", "enumerate", "torch.sum", "ValueError", "torch.isnan", "inputs[].cuda.size", "time.time", "inputs[].cuda.size"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.load_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.save_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.eval_qap.eval_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.backward", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.backward"], ["def", "train_eval_model", "(", "model", ",", "\n", "criterion", ",", "\n", "optimizer", ",", "\n", "dataloader", ",", "\n", "tfboard_writer", ",", "\n", "num_epochs", "=", "25", ",", "\n", "start_epoch", "=", "0", ")", ":", "\n", "    ", "print", "(", "'Start training...'", ")", "\n", "\n", "since", "=", "time", ".", "time", "(", ")", "\n", "dataset_size", "=", "len", "(", "dataloader", "[", "'train'", "]", ".", "dataset", ")", "\n", "\n", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "print", "(", "'model on device: {}'", ".", "format", "(", "device", ")", ")", "\n", "\n", "checkpoint_path", "=", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", "/", "'params'", "\n", "if", "not", "checkpoint_path", ".", "exists", "(", ")", ":", "\n", "        ", "checkpoint_path", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "", "model_path", ",", "optim_path", "=", "''", ",", "''", "\n", "if", "start_epoch", ">", "0", ":", "\n", "        ", "model_path", "=", "str", "(", "checkpoint_path", "/", "'params_{:04}.pt'", ".", "format", "(", "start_epoch", ")", ")", "\n", "optim_path", "=", "str", "(", "checkpoint_path", "/", "'optim_{:04}.pt'", ".", "format", "(", "start_epoch", ")", ")", "\n", "", "if", "len", "(", "cfg", ".", "PRETRAINED_PATH", ")", ">", "0", ":", "\n", "        ", "model_path", "=", "cfg", ".", "PRETRAINED_PATH", "\n", "", "if", "len", "(", "model_path", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Loading model parameters from {}'", ".", "format", "(", "model_path", ")", ")", "\n", "load_model", "(", "model", ",", "model_path", ",", "strict", "=", "False", ")", "\n", "", "if", "len", "(", "optim_path", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Loading optimizer state from {}'", ".", "format", "(", "optim_path", ")", ")", "\n", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "optim_path", ")", ")", "\n", "\n", "", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "\n", "milestones", "=", "cfg", ".", "TRAIN", ".", "LR_STEP", ",", "\n", "gamma", "=", "cfg", ".", "TRAIN", ".", "LR_DECAY", ",", "\n", "last_epoch", "=", "cfg", ".", "TRAIN", ".", "START_EPOCH", "-", "1", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "start_epoch", ",", "num_epochs", ")", ":", "\n", "        ", "print", "(", "'Epoch {}/{}'", ".", "format", "(", "epoch", ",", "num_epochs", "-", "1", ")", ")", "\n", "print", "(", "'-'", "*", "10", ")", "\n", "\n", "model", ".", "train", "(", ")", "# Set model to training mode", "\n", "\n", "print", "(", "'lr = '", "+", "', '", ".", "join", "(", "[", "'{:.2e}'", ".", "format", "(", "x", "[", "'lr'", "]", ")", "for", "x", "in", "optimizer", ".", "param_groups", "]", ")", ")", "\n", "\n", "epoch_loss", "=", "0.0", "\n", "running_loss", "=", "0.0", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "iter_num", "=", "0", "\n", "\n", "det_anomaly", "=", "False", "\n", "\n", "# Iterate over data.", "\n", "for", "inputs", "in", "dataloader", "[", "'train'", "]", ":", "\n", "            ", "if", "model", ".", "module", ".", "device", "!=", "torch", ".", "device", "(", "'cpu'", ")", ":", "\n", "                ", "inputs", "=", "data_to_cuda", "(", "inputs", ")", "\n", "\n", "", "n1_gt", ",", "n2_gt", "=", "inputs", "[", "'ns'", "]", "\n", "perm_mat", "=", "inputs", "[", "'gt_perm_mat'", "]", ".", "cuda", "(", ")", "\n", "\n", "iter_num", "=", "iter_num", "+", "1", "\n", "\n", "# zero the parameter gradients", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                ", "with", "torch", ".", "autograd", ".", "set_detect_anomaly", "(", "det_anomaly", ")", ":", "\n", "# forward", "\n", "                    ", "pred", "=", "model", "(", "inputs", ")", "\n", "s_pred", ",", "affmtx", "=", "pred", "[", "'ds_mat'", "]", ",", "pred", "[", "'aff_mat'", "]", "\n", "\n", "if", "type", "(", "s_pred", ")", "is", "list", ":", "\n", "                        ", "s_pred", "=", "s_pred", "[", "-", "1", "]", "\n", "\n", "", "multi_loss", "=", "[", "]", "\n", "if", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'perm'", "or", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'hung'", ":", "\n", "                        ", "loss", "=", "criterion", "(", "s_pred", ",", "perm_mat", ",", "n1_gt", ",", "n2_gt", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'obj'", ":", "\n", "                        ", "loss", "=", "criterion", "(", "s_pred", ",", "affmtx", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'custom'", ":", "\n", "                        ", "loss", "=", "torch", ".", "sum", "(", "pred", "[", "'loss'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "'Unknown loss function {}'", ".", "format", "(", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", ")", ")", "\n", "\n", "", "if", "cfg", ".", "FP16", ":", "\n", "                        ", "with", "amp", ".", "scale_loss", "(", "loss", ",", "optimizer", ")", "as", "scaled_loss", ":", "\n", "                            ", "scaled_loss", ".", "backward", "(", ")", "\n", "", "", "else", ":", "\n", "                        ", "loss", ".", "backward", "(", ")", "\n", "\n", "", "det_anomaly", "=", "False", "\n", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "                        ", "if", "param", ".", "grad", "is", "not", "None", "and", "torch", ".", "any", "(", "torch", ".", "isnan", "(", "param", ".", "grad", ")", ")", ":", "\n", "                            ", "det_anomaly", "=", "True", "\n", "break", "\n", "", "", "if", "not", "det_anomaly", ":", "\n", "                        ", "optimizer", ".", "step", "(", ")", "\n", "\n", "# training accuracy statistic", "\n", "#acc, _, __ = matching_accuracy(lap_solver(s_pred, n1_gt, n2_gt), perm_mat, n1_gt)", "\n", "", "acc", "=", "0", "\n", "\n", "# tfboard writer", "\n", "loss_dict", "=", "{", "'loss_{}'", ".", "format", "(", "i", ")", ":", "l", ".", "item", "(", ")", "for", "i", ",", "l", "in", "enumerate", "(", "multi_loss", ")", "}", "\n", "loss_dict", "[", "'loss'", "]", "=", "loss", ".", "item", "(", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "'loss'", ",", "loss_dict", ",", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", ")", "\n", "accdict", "=", "dict", "(", ")", "\n", "accdict", "[", "'matching accuracy'", "]", "=", "acc", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'training accuracy'", ",", "\n", "accdict", ",", "\n", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", "\n", ")", "\n", "\n", "# statistics", "\n", "running_loss", "+=", "loss", ".", "item", "(", ")", "*", "perm_mat", ".", "size", "(", "0", ")", "\n", "epoch_loss", "+=", "loss", ".", "item", "(", ")", "*", "perm_mat", ".", "size", "(", "0", ")", "\n", "\n", "if", "iter_num", "%", "cfg", ".", "STATISTIC_STEP", "==", "0", ":", "\n", "                        ", "running_speed", "=", "cfg", ".", "STATISTIC_STEP", "*", "perm_mat", ".", "size", "(", "0", ")", "/", "(", "time", ".", "time", "(", ")", "-", "running_since", ")", "\n", "print", "(", "'Epoch {:<4} Iteration {:<4} {:>4.2f}sample/s Loss={:<8.4f}'", "\n", ".", "format", "(", "epoch", ",", "iter_num", ",", "running_speed", ",", "running_loss", "/", "cfg", ".", "STATISTIC_STEP", "/", "perm_mat", ".", "size", "(", "0", ")", ")", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'speed'", ",", "\n", "{", "'speed'", ":", "running_speed", "}", ",", "\n", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", "\n", ")", "\n", "running_loss", "=", "0.0", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "", "", "", "epoch_loss", "=", "epoch_loss", "/", "dataset_size", "\n", "\n", "#loss_dict = dict()", "\n", "#loss_dict['loss'] = loss.item()", "\n", "#tfboard_writer.add_scalars('loss', loss_dict, epoch * dataset_size + iter_num)", "\n", "\n", "save_model", "(", "model", ",", "str", "(", "checkpoint_path", "/", "'params_{:04}.pt'", ".", "format", "(", "epoch", "+", "1", ")", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "str", "(", "checkpoint_path", "/", "'optim_{:04}.pt'", ".", "format", "(", "epoch", "+", "1", ")", ")", ")", "\n", "\n", "print", "(", "'Epoch {:<4} Loss: {:.4f}'", ".", "format", "(", "epoch", ",", "epoch_loss", ")", ")", "\n", "print", "(", ")", "\n", "\n", "# Eval in each epoch", "\n", "accs", "=", "eval_model", "(", "model", ",", "dataloader", "[", "'test'", "]", ")", "\n", "acc_dict", "=", "{", "\"{}\"", ".", "format", "(", "cls", ")", ":", "single_acc", "for", "cls", ",", "single_acc", "in", "zip", "(", "dataloader", "[", "'train'", "]", ".", "dataset", ".", "classes", ",", "accs", ")", "}", "\n", "acc_dict", "[", "'average'", "]", "=", "torch", ".", "mean", "(", "accs", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'Eval acc'", ",", "\n", "acc_dict", ",", "\n", "(", "epoch", "+", "1", ")", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "\n", ")", "\n", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "print", "(", "'Training complete in {:.0f}h {:.0f}m {:.0f}s'", "\n", ".", "format", "(", "time_elapsed", "//", "3600", ",", "(", "time_elapsed", "//", "60", ")", "%", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.eval.eval_model": [[17, 276], ["print", "time.time", "model.eval", "torch.zeros", "src.utils.timer.Timer", "enumerate", "print", "model.train", "enumerate", "print", "enumerate", "print", "bm.rm_gt_cache", "torch.Tensor", "next", "src.dataset.data_loader.GMDataset", "torch.manual_seed", "src.dataset.data_loader.get_dataloader", "dataloaders.append", "len", "time.time", "torch.zeros", "pred_time.append", "bm.eval", "bm.eval", "time.time", "enumerate", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "zip", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "torch.any", "print", "enumerate", "print", "print", "enumerate", "print", "print", "enumerate", "print", "print", "enumerate", "print", "xls_sheet.write", "zip", "print", "xls_sheet.write", "model.parameters", "print", "torch.cat", "cluster_acc.append", "cluster_purity.append", "cluster_ri.append", "print", "print", "recalls.append", "precisions.append", "f1s.append", "coverages.append", "recalls.append", "precisions.append", "f1s.append", "coverages.append", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "xls_sheet.write", "torch.isnan", "xls_sheet.write", "zip", "print", "xls_sheet.write", "xls_sheet.write", "zip", "print", "xls_sheet.write", "xls_sheet.write", "zip", "print", "xls_sheet.write", "xls_sheet.write", "zip", "print", "xls_sheet.write", "xls_sheet.write", "src.evaluation_metric.format_metric", "torch.mean().item", "torch.device", "src.utils.data_to_cuda.data_to_cuda", "torch.set_grad_enabled", "src.utils.timer.Timer.tick", "model", "pred_time_list.append", "range", "cluster_acc_list.append", "cluster_purity_list.append", "cluster_ri_list.append", "print", "time.time", "torch.cat", "torch.cat", "torch.cat", "bm.eval_cls", "print", "print", "print", "xls_sheet.write", "torch.mean", "torch.mean().item", "xls_sheet.write", "src.evaluation_metric.format_metric", "torch.mean().item", "xls_sheet.write", "src.evaluation_metric.format_metric", "torch.mean().item", "xls_sheet.write", "src.evaluation_metric.format_metric", "torch.mean().item", "src.evaluation_metric.format_metric", "torch.mean().item", "torch.cat", "len", "torch.full", "[].cpu", "perm_mat.numpy.numpy", "dict", "prediction.append", "prediction_cls.append", "src.evaluation_metric.objective_score", "src.evaluation_metric.objective_score", "torch.sum", "zip", "ValueError", "enumerate", "src.evaluation_metric.clustering_accuracy", "src.evaluation_metric.clustering_purity", "src.evaluation_metric.rand_index", "src.evaluation_metric.format_metric", "cls_obj.item", "src.evaluation_metric.format_metric", "torch.mean().item", "torch.cat", "src.evaluation_metric.format_metric", "torch.mean().item", "torch.cat", "src.evaluation_metric.format_metric", "torch.mean().item", "torch.cat", "torch.mean", "range", "range", "cls_gt_transpose[].append", "time.time", "src.evaluation_metric.format_metric", "src.evaluation_metric.format_metric", "src.evaluation_metric.format_metric", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.cat", "src.utils.timer.Timer.toc", "x_pred[].cpu", "perm_mat.numpy.numpy", "dict", "prediction.append", "prediction_cls.append", "torch.mean", "torch.cat", "torch.mean", "torch.cat", "torch.mean", "torch.cat"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.get_dataloader", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.timer.Timer.tick", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.clustering_accuracy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.clustering_purity", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.rand_index", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.Timer.toc", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy"], ["def", "eval_model", "(", "model", ",", "classes", ",", "bm", ",", "last_epoch", "=", "True", ",", "verbose", "=", "False", ",", "xls_sheet", "=", "None", ")", ":", "\n", "    ", "print", "(", "'Start evaluation...'", ")", "\n", "since", "=", "time", ".", "time", "(", ")", "\n", "\n", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "\n", "was_training", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "dataloaders", "=", "[", "]", "\n", "\n", "for", "cls", "in", "classes", ":", "\n", "        ", "image_dataset", "=", "GMDataset", "(", "cfg", ".", "DATASET_FULL_NAME", ",", "\n", "bm", ",", "\n", "cfg", ".", "EVAL", ".", "SAMPLES", ",", "\n", "cfg", ".", "PROBLEM", ".", "TEST_ALL_GRAPHS", ",", "\n", "cls", ",", "\n", "cfg", ".", "PROBLEM", ".", "TYPE", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "cfg", ".", "RANDOM_SEED", ")", "# Fix fetched data in test-set to prevent variance", "\n", "\n", "dataloader", "=", "get_dataloader", "(", "image_dataset", ",", "shuffle", "=", "True", ")", "\n", "dataloaders", ".", "append", "(", "dataloader", ")", "\n", "\n", "", "recalls", "=", "[", "]", "\n", "precisions", "=", "[", "]", "\n", "f1s", "=", "[", "]", "\n", "coverages", "=", "[", "]", "\n", "pred_time", "=", "[", "]", "\n", "objs", "=", "torch", ".", "zeros", "(", "len", "(", "classes", ")", ",", "device", "=", "device", ")", "\n", "cluster_acc", "=", "[", "]", "\n", "cluster_purity", "=", "[", "]", "\n", "cluster_ri", "=", "[", "]", "\n", "\n", "timer", "=", "Timer", "(", ")", "\n", "\n", "prediction", "=", "[", "]", "\n", "\n", "for", "i", ",", "cls", "in", "enumerate", "(", "classes", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'Evaluating class {}: {}/{}'", ".", "format", "(", "cls", ",", "i", ",", "len", "(", "classes", ")", ")", ")", "\n", "\n", "", "running_since", "=", "time", ".", "time", "(", ")", "\n", "iter_num", "=", "0", "\n", "\n", "pred_time_list", "=", "[", "]", "\n", "obj_total_num", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "cluster_acc_list", "=", "[", "]", "\n", "cluster_purity_list", "=", "[", "]", "\n", "cluster_ri_list", "=", "[", "]", "\n", "prediction_cls", "=", "[", "]", "\n", "\n", "for", "inputs", "in", "dataloaders", "[", "i", "]", ":", "\n", "            ", "if", "iter_num", ">=", "cfg", ".", "EVAL", ".", "SAMPLES", "/", "inputs", "[", "'batch_size'", "]", ":", "\n", "                ", "break", "\n", "", "if", "model", ".", "module", ".", "device", "!=", "torch", ".", "device", "(", "'cpu'", ")", ":", "\n", "                ", "inputs", "=", "data_to_cuda", "(", "inputs", ")", "\n", "\n", "", "batch_num", "=", "inputs", "[", "'batch_size'", "]", "\n", "\n", "iter_num", "=", "iter_num", "+", "1", "\n", "\n", "with", "torch", ".", "set_grad_enabled", "(", "False", ")", ":", "\n", "                ", "timer", ".", "tick", "(", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "pred_time_list", ".", "append", "(", "torch", ".", "full", "(", "(", "batch_num", ",", ")", ",", "timer", ".", "toc", "(", ")", "/", "batch_num", ")", ")", "\n", "\n", "# Evaluate matching accuracy", "\n", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", ":", "\n", "                ", "assert", "'perm_mat'", "in", "outputs", "\n", "\n", "for", "b", "in", "range", "(", "outputs", "[", "'perm_mat'", "]", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "perm_mat", "=", "outputs", "[", "'perm_mat'", "]", "[", "b", ",", ":", "outputs", "[", "'ns'", "]", "[", "0", "]", "[", "b", "]", ",", ":", "outputs", "[", "'ns'", "]", "[", "1", "]", "[", "b", "]", "]", ".", "cpu", "(", ")", "\n", "perm_mat", "=", "perm_mat", ".", "numpy", "(", ")", "\n", "eval_dict", "=", "dict", "(", ")", "\n", "id_pair", "=", "inputs", "[", "'id_list'", "]", "[", "0", "]", "[", "b", "]", ",", "inputs", "[", "'id_list'", "]", "[", "1", "]", "[", "b", "]", "\n", "eval_dict", "[", "'ids'", "]", "=", "id_pair", "\n", "eval_dict", "[", "'cls'", "]", "=", "cls", "\n", "eval_dict", "[", "'perm_mat'", "]", "=", "perm_mat", "\n", "prediction", ".", "append", "(", "eval_dict", ")", "\n", "prediction_cls", ".", "append", "(", "eval_dict", ")", "\n", "\n", "", "if", "'aff_mat'", "in", "outputs", ":", "\n", "                    ", "pred_obj_score", "=", "objective_score", "(", "outputs", "[", "'perm_mat'", "]", ",", "outputs", "[", "'aff_mat'", "]", ")", "\n", "gt_obj_score", "=", "objective_score", "(", "outputs", "[", "'gt_perm_mat'", "]", ",", "outputs", "[", "'aff_mat'", "]", ")", "\n", "objs", "[", "i", "]", "+=", "torch", ".", "sum", "(", "pred_obj_score", "/", "gt_obj_score", ")", "\n", "obj_total_num", "+=", "batch_num", "\n", "", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "in", "[", "'MGM'", ",", "'MGM3'", "]", ":", "\n", "                ", "assert", "'graph_indices'", "in", "outputs", "\n", "assert", "'perm_mat_list'", "in", "outputs", "\n", "\n", "ns", "=", "outputs", "[", "'ns'", "]", "\n", "idx", "=", "-", "1", "\n", "for", "x_pred", ",", "(", "idx_src", ",", "idx_tgt", ")", "in", "zip", "(", "outputs", "[", "'perm_mat_list'", "]", ",", "outputs", "[", "'graph_indices'", "]", ")", ":", "\n", "                    ", "idx", "+=", "1", "\n", "for", "b", "in", "range", "(", "x_pred", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "perm_mat", "=", "x_pred", "[", "b", ",", ":", "ns", "[", "idx_src", "]", "[", "b", "]", ",", ":", "ns", "[", "idx_tgt", "]", "[", "b", "]", "]", ".", "cpu", "(", ")", "\n", "perm_mat", "=", "perm_mat", ".", "numpy", "(", ")", "\n", "eval_dict", "=", "dict", "(", ")", "\n", "id_pair", "=", "inputs", "[", "'id_list'", "]", "[", "idx_src", "]", "[", "b", "]", ",", "inputs", "[", "'id_list'", "]", "[", "idx_tgt", "]", "[", "b", "]", "\n", "eval_dict", "[", "'ids'", "]", "=", "id_pair", "\n", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "                            ", "eval_dict", "[", "'cls'", "]", "=", "bm", ".", "data_dict", "[", "id_pair", "[", "0", "]", "]", "[", "'cls'", "]", "\n", "", "else", ":", "\n", "                            ", "eval_dict", "[", "'cls'", "]", "=", "cls", "\n", "", "eval_dict", "[", "'perm_mat'", "]", "=", "perm_mat", "\n", "prediction", ".", "append", "(", "eval_dict", ")", "\n", "prediction_cls", ".", "append", "(", "eval_dict", ")", "\n", "\n", "", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Unknown problem type {}'", ".", "format", "(", "cfg", ".", "PROBLEM", ".", "TYPE", ")", ")", "\n", "\n", "# Evaluate clustering accuracy", "\n", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "                ", "assert", "'pred_cluster'", "in", "outputs", "\n", "assert", "'cls'", "in", "outputs", "\n", "\n", "pred_cluster", "=", "outputs", "[", "'pred_cluster'", "]", "\n", "cls_gt_transpose", "=", "[", "[", "]", "for", "_", "in", "range", "(", "batch_num", ")", "]", "\n", "for", "batched_cls", "in", "outputs", "[", "'cls'", "]", ":", "\n", "                    ", "for", "b", ",", "_cls", "in", "enumerate", "(", "batched_cls", ")", ":", "\n", "                        ", "cls_gt_transpose", "[", "b", "]", ".", "append", "(", "_cls", ")", "\n", "", "", "cluster_acc_list", ".", "append", "(", "clustering_accuracy", "(", "pred_cluster", ",", "cls_gt_transpose", ")", ")", "\n", "cluster_purity_list", ".", "append", "(", "clustering_purity", "(", "pred_cluster", ",", "cls_gt_transpose", ")", ")", "\n", "cluster_ri_list", ".", "append", "(", "rand_index", "(", "pred_cluster", ",", "cls_gt_transpose", ")", ")", "\n", "\n", "", "if", "iter_num", "%", "cfg", ".", "STATISTIC_STEP", "==", "0", "and", "verbose", ":", "\n", "                ", "running_speed", "=", "cfg", ".", "STATISTIC_STEP", "*", "batch_num", "/", "(", "time", ".", "time", "(", ")", "-", "running_since", ")", "\n", "print", "(", "'Class {:<8} Iteration {:<4} {:>4.2f}sample/s'", ".", "format", "(", "cls", ",", "iter_num", ",", "running_speed", ")", ")", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "", "objs", "[", "i", "]", "=", "objs", "[", "i", "]", "/", "obj_total_num", "\n", "pred_time", ".", "append", "(", "torch", ".", "cat", "(", "pred_time_list", ")", ")", "\n", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "            ", "cluster_acc", ".", "append", "(", "torch", ".", "cat", "(", "cluster_acc_list", ")", ")", "\n", "cluster_purity", ".", "append", "(", "torch", ".", "cat", "(", "cluster_purity_list", ")", ")", "\n", "cluster_ri", ".", "append", "(", "torch", ".", "cat", "(", "cluster_ri_list", ")", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "!=", "'MGM3'", ":", "\n", "                ", "bm", ".", "eval_cls", "(", "prediction_cls", ",", "cls", ",", "verbose", "=", "verbose", ")", "\n", "", "print", "(", "'Class {} norm obj score = {:.4f}'", ".", "format", "(", "cls", ",", "objs", "[", "i", "]", ")", ")", "\n", "print", "(", "'Class {} pred time = {}s'", ".", "format", "(", "cls", ",", "format_metric", "(", "pred_time", "[", "i", "]", ")", ")", ")", "\n", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "                ", "print", "(", "'Class {} cluster acc={}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cluster_acc", "[", "i", "]", ")", ")", ")", "\n", "print", "(", "'Class {} cluster purity={}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cluster_purity", "[", "i", "]", ")", ")", ")", "\n", "print", "(", "'Class {} cluster rand index={}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cluster_ri", "[", "i", "]", ")", ")", ")", "\n", "\n", "", "", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "        ", "result", "=", "bm", ".", "eval", "(", "prediction", ",", "classes", "[", "0", "]", ",", "verbose", "=", "True", ")", "\n", "for", "cls", "in", "classes", "[", "0", "]", ":", "\n", "            ", "precision", "=", "result", "[", "cls", "]", "[", "'precision'", "]", "\n", "recall", "=", "result", "[", "cls", "]", "[", "'recall'", "]", "\n", "f1", "=", "result", "[", "cls", "]", "[", "'f1'", "]", "\n", "coverage", "=", "result", "[", "cls", "]", "[", "'coverage'", "]", "\n", "\n", "recalls", ".", "append", "(", "recall", ")", "\n", "precisions", ".", "append", "(", "precision", ")", "\n", "f1s", ".", "append", "(", "f1", ")", "\n", "coverages", ".", "append", "(", "coverage", ")", "\n", "", "", "else", ":", "\n", "        ", "result", "=", "bm", ".", "eval", "(", "prediction", ",", "classes", ",", "verbose", "=", "True", ")", "\n", "for", "cls", "in", "classes", ":", "\n", "            ", "precision", "=", "result", "[", "cls", "]", "[", "'precision'", "]", "\n", "recall", "=", "result", "[", "cls", "]", "[", "'recall'", "]", "\n", "f1", "=", "result", "[", "cls", "]", "[", "'f1'", "]", "\n", "coverage", "=", "result", "[", "cls", "]", "[", "'coverage'", "]", "\n", "\n", "recalls", ".", "append", "(", "recall", ")", "\n", "precisions", ".", "append", "(", "precision", ")", "\n", "f1s", ".", "append", "(", "f1", ")", "\n", "coverages", ".", "append", "(", "coverage", ")", "\n", "\n", "", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "print", "(", "'Evaluation complete in {:.0f}m {:.0f}s'", ".", "format", "(", "time_elapsed", "//", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "model", ".", "train", "(", "mode", "=", "was_training", ")", "\n", "\n", "if", "xls_sheet", ":", "\n", "        ", "for", "idx", ",", "cls", "in", "enumerate", "(", "classes", ")", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "0", ",", "idx", "+", "1", ",", "cls", ")", "\n", "", "xls_sheet", ".", "write", "(", "0", ",", "idx", "+", "2", ",", "'mean'", ")", "\n", "\n", "", "xls_row", "=", "1", "\n", "\n", "# show result", "\n", "if", "xls_sheet", ":", "\n", "        ", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'precision'", ")", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "1", ",", "0", ",", "'recall'", ")", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "2", ",", "0", ",", "'f1'", ")", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "3", ",", "0", ",", "'coverage'", ")", "\n", "", "for", "idx", ",", "(", "cls", ",", "cls_p", ",", "cls_r", ",", "cls_f1", ",", "cls_cvg", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "precisions", ",", "recalls", ",", "f1s", ",", "coverages", ")", ")", ":", "\n", "        ", "if", "xls_sheet", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "'{:.4f}'", ".", "format", "(", "cls_p", ")", ")", "#'{:.4f}'.format(torch.mean(cls_p)))", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "1", ",", "idx", "+", "1", ",", "'{:.4f}'", ".", "format", "(", "cls_r", ")", ")", "#'{:.4f}'.format(torch.mean(cls_r)))", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "2", ",", "idx", "+", "1", ",", "'{:.4f}'", ".", "format", "(", "cls_f1", ")", ")", "#'{:.4f}'.format(torch.mean(cls_f1)))", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "3", ",", "idx", "+", "1", ",", "'{:.4f}'", ".", "format", "(", "cls_cvg", ")", ")", "\n", "", "", "if", "xls_sheet", ":", "\n", "        ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "'{:.4f}'", ".", "format", "(", "result", "[", "'mean'", "]", "[", "'precision'", "]", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(precisions))))", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "1", ",", "idx", "+", "2", ",", "'{:.4f}'", ".", "format", "(", "result", "[", "'mean'", "]", "[", "'recall'", "]", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(recalls))))", "\n", "xls_sheet", ".", "write", "(", "xls_row", "+", "2", ",", "idx", "+", "2", ",", "'{:.4f}'", ".", "format", "(", "result", "[", "'mean'", "]", "[", "'f1'", "]", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(f1s))))", "\n", "xls_row", "+=", "4", "\n", "\n", "", "if", "not", "torch", ".", "any", "(", "torch", ".", "isnan", "(", "objs", ")", ")", ":", "\n", "        ", "print", "(", "'Normalized objective score'", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'norm objscore'", ")", "\n", "for", "idx", ",", "(", "cls", ",", "cls_obj", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "objs", ")", ")", ":", "\n", "            ", "print", "(", "'{} = {:.4f}'", ".", "format", "(", "cls", ",", "cls_obj", ")", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "cls_obj", ".", "item", "(", ")", ")", "#'{:.4f}'.format(cls_obj))", "\n", "", "print", "(", "'average objscore = {:.4f}'", ".", "format", "(", "torch", ".", "mean", "(", "objs", ")", ")", ")", "\n", "if", "xls_sheet", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "torch", ".", "mean", "(", "objs", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(objs)))", "\n", "xls_row", "+=", "1", "\n", "\n", "", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM3'", ":", "\n", "        ", "print", "(", "'Clustering accuracy'", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'cluster acc'", ")", "\n", "for", "idx", ",", "(", "cls", ",", "cls_acc", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "cluster_acc", ")", ")", ":", "\n", "            ", "print", "(", "'{} = {}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cls_acc", ")", ")", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "torch", ".", "mean", "(", "cls_acc", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(cls_acc)))", "\n", "", "print", "(", "'average clustering accuracy = {}'", ".", "format", "(", "format_metric", "(", "torch", ".", "cat", "(", "cluster_acc", ")", ")", ")", ")", "\n", "if", "xls_sheet", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "torch", ".", "mean", "(", "torch", ".", "cat", "(", "cluster_acc", ")", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(cluster_acc))))", "\n", "xls_row", "+=", "1", "\n", "\n", "", "print", "(", "'Clustering purity'", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'cluster purity'", ")", "\n", "for", "idx", ",", "(", "cls", ",", "cls_acc", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "cluster_purity", ")", ")", ":", "\n", "            ", "print", "(", "'{} = {}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cls_acc", ")", ")", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "torch", ".", "mean", "(", "cls_acc", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(cls_acc)))", "\n", "", "print", "(", "'average clustering purity = {}'", ".", "format", "(", "format_metric", "(", "torch", ".", "cat", "(", "cluster_purity", ")", ")", ")", ")", "\n", "if", "xls_sheet", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "torch", ".", "mean", "(", "torch", ".", "cat", "(", "cluster_purity", ")", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(cluster_purity))))", "\n", "xls_row", "+=", "1", "\n", "\n", "", "print", "(", "'Clustering rand index'", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'rand index'", ")", "\n", "for", "idx", ",", "(", "cls", ",", "cls_acc", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "cluster_ri", ")", ")", ":", "\n", "            ", "print", "(", "'{} = {}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cls_acc", ")", ")", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "torch", ".", "mean", "(", "cls_acc", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(cls_acc)))", "\n", "", "print", "(", "'average rand index = {}'", ".", "format", "(", "format_metric", "(", "torch", ".", "cat", "(", "cluster_ri", ")", ")", ")", ")", "\n", "if", "xls_sheet", ":", "\n", "            ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "torch", ".", "mean", "(", "torch", ".", "cat", "(", "cluster_ri", ")", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(cluster_ri))))", "\n", "xls_row", "+=", "1", "\n", "\n", "", "", "print", "(", "'Predict time'", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "0", ",", "'time'", ")", "\n", "for", "idx", ",", "(", "cls", ",", "cls_time", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "pred_time", ")", ")", ":", "\n", "        ", "print", "(", "'{} = {}'", ".", "format", "(", "cls", ",", "format_metric", "(", "cls_time", ")", ")", ")", "\n", "if", "xls_sheet", ":", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "1", ",", "torch", ".", "mean", "(", "cls_time", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(cls_time)))", "\n", "", "print", "(", "'average time = {}'", ".", "format", "(", "format_metric", "(", "torch", ".", "cat", "(", "pred_time", ")", ")", ")", ")", "\n", "if", "xls_sheet", ":", "\n", "        ", "xls_sheet", ".", "write", "(", "xls_row", ",", "idx", "+", "2", ",", "torch", ".", "mean", "(", "torch", ".", "cat", "(", "pred_time", ")", ")", ".", "item", "(", ")", ")", "#'{:.4f}'.format(torch.mean(torch.cat(pred_time))))", "\n", "xls_row", "+=", "1", "\n", "\n", "", "bm", ".", "rm_gt_cache", "(", "last_epoch", "=", "last_epoch", ")", "\n", "\n", "return", "torch", ".", "Tensor", "(", "recalls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.train_eval.train_eval_model": [[22, 233], ["print", "time.time", "len", "src.displacement_layer.Displacement", "print", "torch.lr_scheduler.MultiStepLR", "range", "print", "next", "pathlib.Path", "checkpoint_path.exists", "checkpoint_path.mkdir", "str", "str", "len", "len", "print", "src.utils.model_sl.load_model", "len", "print", "optimizer.load_state_dict", "torch.manual_seed", "src.dataset.data_loader.get_dataloader", "print", "print", "model.train", "print", "time.time", "src.utils.model_sl.save_model", "torch.save", "print", "print", "eval.eval_model", "torch.mean", "tfboard_writer.add_scalars", "wb.save", "optim.lr_scheduler.MultiStepLR.step", "time.time", "model.parameters", "torch.load", "optimizer.zero_grad", "str", "optimizer.state_dict", "str", "torch.device", "src.utils.data_to_cuda.data_to_cuda", "torch.set_grad_enabled", "model", "optimizer.step", "dict", "torch.sum.item", "tfboard_writer.add_scalars", "dict", "torch.mean", "tfboard_writer.add_scalars", "xls_wb.add_sheet", "zip", "src.evaluation_metric.matching_accuracy", "torch.sum.backward", "torch.sum.item", "torch.sum.item", "print", "tfboard_writer.add_scalars", "tfboard_writer.add_scalars", "time.time", "src.displacement_layer.Displacement.", "src.displacement_layer.Displacement.", "criterion", "torch.zeros", "zip", "len", "ValueError", "amp.scale_loss", "scaled_loss.backward", "criterion", "torch.zeros", "zip", "len", "src.evaluation_metric.matching_accuracy", "torch.sum", "time.time", "criterion", "criterion", "torch.sum", "ValueError", "enumerate", "torch.sum", "ValueError"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.load_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.get_dataloader", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.save_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.eval_qap.eval_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_accuracy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.backward", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.backward", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_accuracy"], ["def", "train_eval_model", "(", "model", ",", "\n", "criterion", ",", "\n", "optimizer", ",", "\n", "image_dataset", ",", "\n", "dataloader", ",", "\n", "tfboard_writer", ",", "\n", "benchmark", ",", "\n", "num_epochs", "=", "25", ",", "\n", "start_epoch", "=", "0", ",", "\n", "xls_wb", "=", "None", ")", ":", "\n", "    ", "print", "(", "'Start training...'", ")", "\n", "\n", "since", "=", "time", ".", "time", "(", ")", "\n", "dataset_size", "=", "len", "(", "dataloader", "[", "'train'", "]", ".", "dataset", ")", "\n", "displacement", "=", "Displacement", "(", ")", "\n", "\n", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "print", "(", "'model on device: {}'", ".", "format", "(", "device", ")", ")", "\n", "\n", "checkpoint_path", "=", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", "/", "'params'", "\n", "if", "not", "checkpoint_path", ".", "exists", "(", ")", ":", "\n", "        ", "checkpoint_path", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "", "model_path", ",", "optim_path", "=", "''", ",", "''", "\n", "if", "start_epoch", "!=", "0", ":", "\n", "        ", "model_path", "=", "str", "(", "checkpoint_path", "/", "'params_{:04}.pt'", ".", "format", "(", "start_epoch", ")", ")", "\n", "optim_path", "=", "str", "(", "checkpoint_path", "/", "'optim_{:04}.pt'", ".", "format", "(", "start_epoch", ")", ")", "\n", "", "if", "len", "(", "cfg", ".", "PRETRAINED_PATH", ")", ">", "0", ":", "\n", "        ", "model_path", "=", "cfg", ".", "PRETRAINED_PATH", "\n", "", "if", "len", "(", "model_path", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Loading model parameters from {}'", ".", "format", "(", "model_path", ")", ")", "\n", "load_model", "(", "model", ",", "model_path", ",", "strict", "=", "False", ")", "\n", "", "if", "len", "(", "optim_path", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Loading optimizer state from {}'", ".", "format", "(", "optim_path", ")", ")", "\n", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "optim_path", ")", ")", "\n", "\n", "", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", ",", "\n", "milestones", "=", "cfg", ".", "TRAIN", ".", "LR_STEP", ",", "\n", "gamma", "=", "cfg", ".", "TRAIN", ".", "LR_DECAY", ",", "\n", "last_epoch", "=", "cfg", ".", "TRAIN", ".", "START_EPOCH", "-", "1", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "start_epoch", ",", "num_epochs", ")", ":", "\n", "# Reset seed after evaluation per epoch", "\n", "        ", "torch", ".", "manual_seed", "(", "cfg", ".", "RANDOM_SEED", "+", "epoch", "+", "1", ")", "\n", "dataloader", "[", "'train'", "]", "=", "get_dataloader", "(", "image_dataset", "[", "'train'", "]", ",", "shuffle", "=", "True", ",", "fix_seed", "=", "False", ")", "\n", "print", "(", "'Epoch {}/{}'", ".", "format", "(", "epoch", ",", "num_epochs", "-", "1", ")", ")", "\n", "print", "(", "'-'", "*", "10", ")", "\n", "\n", "model", ".", "train", "(", ")", "# Set model to training mode", "\n", "\n", "print", "(", "'lr = '", "+", "', '", ".", "join", "(", "[", "'{:.2e}'", ".", "format", "(", "x", "[", "'lr'", "]", ")", "for", "x", "in", "optimizer", ".", "param_groups", "]", ")", ")", "\n", "\n", "epoch_loss", "=", "0.0", "\n", "running_loss", "=", "0.0", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "iter_num", "=", "0", "\n", "\n", "# Iterate over data.", "\n", "for", "inputs", "in", "dataloader", "[", "'train'", "]", ":", "\n", "            ", "if", "iter_num", ">=", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", ":", "\n", "                ", "break", "\n", "", "if", "model", ".", "module", ".", "device", "!=", "torch", ".", "device", "(", "'cpu'", ")", ":", "\n", "                ", "inputs", "=", "data_to_cuda", "(", "inputs", ")", "\n", "\n", "", "iter_num", "=", "iter_num", "+", "1", "\n", "\n", "# zero the parameter gradients", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "# forward", "\n", "                ", "outputs", "=", "model", "(", "inputs", ")", "\n", "\n", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", ":", "\n", "                    ", "assert", "'ds_mat'", "in", "outputs", "\n", "assert", "'perm_mat'", "in", "outputs", "\n", "assert", "'gt_perm_mat'", "in", "outputs", "\n", "\n", "# compute loss", "\n", "if", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'offset'", ":", "\n", "                        ", "d_gt", ",", "grad_mask", "=", "displacement", "(", "outputs", "[", "'gt_perm_mat'", "]", ",", "*", "outputs", "[", "'Ps'", "]", ",", "outputs", "[", "'ns'", "]", "[", "0", "]", ")", "\n", "d_pred", ",", "_", "=", "displacement", "(", "outputs", "[", "'ds_mat'", "]", ",", "*", "outputs", "[", "'Ps'", "]", ",", "outputs", "[", "'ns'", "]", "[", "0", "]", ")", "\n", "loss", "=", "criterion", "(", "d_pred", ",", "d_gt", ",", "grad_mask", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "in", "[", "'perm'", ",", "'ce'", ",", "'hung'", "]", ":", "\n", "                        ", "loss", "=", "criterion", "(", "outputs", "[", "'ds_mat'", "]", ",", "outputs", "[", "'gt_perm_mat'", "]", ",", "*", "outputs", "[", "'ns'", "]", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'hamming'", ":", "\n", "                        ", "loss", "=", "criterion", "(", "outputs", "[", "'perm_mat'", "]", ",", "outputs", "[", "'gt_perm_mat'", "]", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'custom'", ":", "\n", "                        ", "loss", "=", "torch", ".", "sum", "(", "outputs", "[", "'loss'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "\n", "'Unsupported loss function {} for problem type {}'", ".", "format", "(", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", ",", "\n", "cfg", ".", "PROBLEM", ".", "TYPE", ")", ")", "\n", "\n", "# compute accuracy", "\n", "", "acc", "=", "matching_accuracy", "(", "outputs", "[", "'perm_mat'", "]", ",", "outputs", "[", "'gt_perm_mat'", "]", ",", "outputs", "[", "'ns'", "]", "[", "0", "]", ")", "\n", "\n", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "in", "[", "'MGM'", ",", "'MGM3'", "]", ":", "\n", "                    ", "assert", "'ds_mat_list'", "in", "outputs", "\n", "assert", "'graph_indices'", "in", "outputs", "\n", "assert", "'perm_mat_list'", "in", "outputs", "\n", "if", "not", "'gt_perm_mat_list'", "in", "outputs", ":", "\n", "                        ", "assert", "'gt_perm_mat'", "in", "outputs", "\n", "gt_perm_mat_list", "=", "[", "outputs", "[", "'gt_perm_mat'", "]", "[", "idx", "]", "for", "idx", "in", "outputs", "[", "'graph_indices'", "]", "]", "\n", "", "else", ":", "\n", "                        ", "gt_perm_mat_list", "=", "outputs", "[", "'gt_perm_mat_list'", "]", "\n", "\n", "# compute loss & accuracy", "\n", "", "if", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "in", "[", "'perm'", ",", "'ce'", "'hung'", "]", ":", "\n", "                        ", "loss", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "model", ".", "module", ".", "device", ")", "\n", "ns", "=", "outputs", "[", "'ns'", "]", "\n", "for", "s_pred", ",", "x_gt", ",", "(", "idx_src", ",", "idx_tgt", ")", "in", "zip", "(", "outputs", "[", "'ds_mat_list'", "]", ",", "gt_perm_mat_list", ",", "outputs", "[", "'graph_indices'", "]", ")", ":", "\n", "                            ", "l", "=", "criterion", "(", "s_pred", ",", "x_gt", ",", "ns", "[", "idx_src", "]", ",", "ns", "[", "idx_tgt", "]", ")", "\n", "loss", "+=", "l", "\n", "", "loss", "/=", "len", "(", "outputs", "[", "'ds_mat_list'", "]", ")", "\n", "", "elif", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", "==", "'plain'", ":", "\n", "                        ", "loss", "=", "torch", ".", "sum", "(", "outputs", "[", "'loss'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "\n", "'Unsupported loss function {} for problem type {}'", ".", "format", "(", "cfg", ".", "TRAIN", ".", "LOSS_FUNC", ",", "\n", "cfg", ".", "PROBLEM", ".", "TYPE", ")", ")", "\n", "\n", "# compute accuracy", "\n", "", "acc", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "model", ".", "module", ".", "device", ")", "\n", "for", "x_pred", ",", "x_gt", ",", "(", "idx_src", ",", "idx_tgt", ")", "in", "zip", "(", "outputs", "[", "'perm_mat_list'", "]", ",", "gt_perm_mat_list", ",", "outputs", "[", "'graph_indices'", "]", ")", ":", "\n", "                        ", "a", "=", "matching_accuracy", "(", "x_pred", ",", "x_gt", ",", "ns", "[", "idx_src", "]", ")", "\n", "acc", "+=", "torch", ".", "sum", "(", "a", ")", "\n", "", "acc", "/=", "len", "(", "outputs", "[", "'perm_mat_list'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'Unknown problem type {}'", ".", "format", "(", "cfg", ".", "PROBLEM", ".", "TYPE", ")", ")", "\n", "\n", "# backward + optimize", "\n", "", "if", "cfg", ".", "FP16", ":", "\n", "                    ", "with", "amp", ".", "scale_loss", "(", "loss", ",", "optimizer", ")", "as", "scaled_loss", ":", "\n", "                        ", "scaled_loss", ".", "backward", "(", ")", "\n", "", "", "else", ":", "\n", "                    ", "loss", ".", "backward", "(", ")", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "\n", "batch_num", "=", "inputs", "[", "'batch_size'", "]", "\n", "\n", "# tfboard writer", "\n", "loss_dict", "=", "dict", "(", ")", "\n", "loss_dict", "[", "'loss'", "]", "=", "loss", ".", "item", "(", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "'loss'", ",", "loss_dict", ",", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", ")", "\n", "\n", "accdict", "=", "dict", "(", ")", "\n", "accdict", "[", "'matching accuracy'", "]", "=", "torch", ".", "mean", "(", "acc", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'training accuracy'", ",", "\n", "accdict", ",", "\n", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", "\n", ")", "\n", "\n", "# statistics", "\n", "running_loss", "+=", "loss", ".", "item", "(", ")", "*", "batch_num", "\n", "epoch_loss", "+=", "loss", ".", "item", "(", ")", "*", "batch_num", "\n", "\n", "if", "iter_num", "%", "cfg", ".", "STATISTIC_STEP", "==", "0", ":", "\n", "                    ", "running_speed", "=", "cfg", ".", "STATISTIC_STEP", "*", "batch_num", "/", "(", "time", ".", "time", "(", ")", "-", "running_since", ")", "\n", "print", "(", "'Epoch {:<4} Iteration {:<4} {:>4.2f}sample/s Loss={:<8.4f}'", "\n", ".", "format", "(", "epoch", ",", "iter_num", ",", "running_speed", ",", "running_loss", "/", "cfg", ".", "STATISTIC_STEP", "/", "batch_num", ")", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'speed'", ",", "\n", "{", "'speed'", ":", "running_speed", "}", ",", "\n", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", "\n", ")", "\n", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'learning rate'", ",", "\n", "{", "'lr_{}'", ".", "format", "(", "i", ")", ":", "x", "[", "'lr'", "]", "for", "i", ",", "x", "in", "enumerate", "(", "optimizer", ".", "param_groups", ")", "}", ",", "\n", "epoch", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "+", "iter_num", "\n", ")", "\n", "\n", "running_loss", "=", "0.0", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "", "", "epoch_loss", "=", "epoch_loss", "/", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "/", "batch_num", "\n", "\n", "save_model", "(", "model", ",", "str", "(", "checkpoint_path", "/", "'params_{:04}.pt'", ".", "format", "(", "epoch", "+", "1", ")", ")", ")", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "str", "(", "checkpoint_path", "/", "'optim_{:04}.pt'", ".", "format", "(", "epoch", "+", "1", ")", ")", ")", "\n", "\n", "print", "(", "'Epoch {:<4} Loss: {:.4f}'", ".", "format", "(", "epoch", ",", "epoch_loss", ")", ")", "\n", "print", "(", ")", "\n", "\n", "# Eval in each epoch", "\n", "if", "dataloader", "[", "'test'", "]", ".", "dataset", ".", "cls", "not", "in", "[", "'none'", ",", "'all'", ",", "None", "]", ":", "\n", "            ", "clss", "=", "[", "dataloader", "[", "'test'", "]", ".", "dataset", ".", "cls", "]", "\n", "", "else", ":", "\n", "            ", "clss", "=", "dataloader", "[", "'test'", "]", ".", "dataset", ".", "bm", ".", "classes", "\n", "", "l_e", "=", "(", "epoch", "==", "(", "num_epochs", "-", "1", ")", ")", "\n", "accs", "=", "eval_model", "(", "model", ",", "clss", ",", "benchmark", "[", "'test'", "]", ",", "l_e", ",", "\n", "xls_sheet", "=", "xls_wb", ".", "add_sheet", "(", "'epoch{}'", ".", "format", "(", "epoch", "+", "1", ")", ")", ")", "\n", "acc_dict", "=", "{", "\"{}\"", ".", "format", "(", "cls", ")", ":", "single_acc", "for", "cls", ",", "single_acc", "in", "zip", "(", "dataloader", "[", "'test'", "]", ".", "dataset", ".", "classes", ",", "accs", ")", "}", "\n", "acc_dict", "[", "'average'", "]", "=", "torch", ".", "mean", "(", "accs", ")", "\n", "tfboard_writer", ".", "add_scalars", "(", "\n", "'Eval acc'", ",", "\n", "acc_dict", ",", "\n", "(", "epoch", "+", "1", ")", "*", "cfg", ".", "TRAIN", ".", "EPOCH_ITERS", "\n", ")", "\n", "wb", ".", "save", "(", "wb", ".", "__save_path", ")", "\n", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "print", "(", "'Training complete in {:.0f}h {:.0f}m {:.0f}s'", "\n", ".", "format", "(", "time_elapsed", "//", "3600", ",", "(", "time_elapsed", "//", "60", ")", "%", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.None.eval_qap.eval_model": [[16, 128], ["print", "time.time", "model.eval", "torch.zeros", "xlwt.Workbook", "xlwt.Workbook.add_sheet", "wb.add_sheet.write", "wb.add_sheet.write", "wb.add_sheet.write", "enumerate", "print", "model.train", "print", "print", "zip", "print", "datetime.datetime.now().strftime", "xlwt.Workbook.save", "next", "str", "print", "src.utils.model_sl.load_model", "len", "time.time", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "time.time", "print", "str", "model.parameters", "print", "perm_mat.size", "time.time", "src.evaluation_metric.objective_score", "src.evaluation_metric.objective_score", "zip", "print", "float", "torch.mean", "datetime.datetime.now", "torch.device", "src.utils.data_to_cuda.data_to_cuda", "print", "torch.set_grad_enabled", "model", "time.time", "print", "wb.add_sheet.write", "wb.add_sheet.write", "wb.add_sheet.write", "print", "time.time", "pathlib.Path", "pathlib.Path", "len", "torch.isnan", "x.item", "time.time"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.load_model", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write"], ["def", "eval_model", "(", "model", ",", "dataloader", ",", "eval_epoch", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "print", "(", "'Start evaluation...'", ")", "\n", "since", "=", "time", ".", "time", "(", ")", "\n", "\n", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "\n", "\n", "if", "eval_epoch", "is", "not", "None", ":", "\n", "        ", "model_path", "=", "str", "(", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", "/", "'params'", "/", "'params_{:04}.pt'", ".", "format", "(", "eval_epoch", ")", ")", "\n", "print", "(", "'Loading model parameters from {}'", ".", "format", "(", "model_path", ")", ")", "\n", "load_model", "(", "model", ",", "model_path", ")", "\n", "\n", "", "was_training", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "ds", "=", "dataloader", ".", "dataset", "\n", "classes", "=", "ds", ".", "classes", "\n", "cls_cache", "=", "ds", ".", "cls", "\n", "\n", "accs", "=", "torch", ".", "zeros", "(", "len", "(", "classes", ")", ",", "device", "=", "device", ")", "\n", "\n", "wb", "=", "xlwt", ".", "Workbook", "(", ")", "\n", "sheet", "=", "wb", ".", "add_sheet", "(", "'QAPLIB'", ")", "\n", "name_idx", "=", "0", "\n", "score_idx", "=", "1", "\n", "time_idx", "=", "2", "\n", "sheet", ".", "write", "(", "0", ",", "name_idx", ",", "'instance'", ")", "\n", "sheet", ".", "write", "(", "0", ",", "score_idx", ",", "'score'", ")", "\n", "sheet", ".", "write", "(", "0", ",", "time_idx", ",", "'time'", ")", "\n", "wb_idx", "=", "1", "\n", "\n", "for", "i", ",", "cls", "in", "enumerate", "(", "classes", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "'Evaluating class {}: {}/{}'", ".", "format", "(", "cls", ",", "i", ",", "len", "(", "classes", ")", ")", ")", "\n", "\n", "", "running_since", "=", "time", ".", "time", "(", ")", "\n", "iter_num", "=", "0", "\n", "\n", "ds", ".", "cls", "=", "cls", "\n", "acc_match_num", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "acc_total_num", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "rel_sum", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "rel_num", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "device", ")", "\n", "for", "inputs", "in", "dataloader", ":", "\n", "            ", "if", "model", ".", "module", ".", "device", "!=", "torch", ".", "device", "(", "'cpu'", ")", ":", "\n", "                ", "inputs", "=", "data_to_cuda", "(", "inputs", ")", "\n", "\n", "", "ori_affmtx", "=", "inputs", "[", "'aff_mat'", "]", "\n", "solution", "=", "inputs", "[", "'solution'", "]", "\n", "name", "=", "inputs", "[", "'name'", "]", "\n", "n1_gt", ",", "n2_gt", "=", "inputs", "[", "'ns'", "]", "\n", "perm_mat", "=", "inputs", "[", "'gt_perm_mat'", "]", "\n", "\n", "batch_num", "=", "perm_mat", ".", "size", "(", "0", ")", "\n", "\n", "iter_num", "=", "iter_num", "+", "1", "\n", "\n", "fwd_since", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "'esc16f'", "in", "name", ":", "\n", "                ", "print", "(", "'esc16f - 0'", ")", "\n", "continue", "\n", "\n", "", "with", "torch", ".", "set_grad_enabled", "(", "False", ")", ":", "\n", "                ", "_", "=", "None", "\n", "pred", "=", "model", "(", "inputs", ")", "\n", "x_pred", ",", "affmtx", "=", "pred", "[", "'perm_mat'", "]", ",", "pred", "[", "'aff_mat'", "]", "\n", "\n", "", "fwd_time", "=", "time", ".", "time", "(", ")", "-", "fwd_since", "\n", "\n", "obj_score", "=", "objective_score", "(", "x_pred", ",", "ori_affmtx", ")", "\n", "opt_obj_score", "=", "objective_score", "(", "perm_mat", ",", "ori_affmtx", ")", "\n", "ori_obj_score", "=", "solution", "\n", "\n", "for", "n", ",", "x", ",", "y", ",", "z", "in", "zip", "(", "name", ",", "obj_score", ",", "opt_obj_score", ",", "ori_obj_score", ")", ":", "\n", "                ", "rel", "=", "(", "x", "-", "z", ")", "/", "x", "\n", "print", "(", "'{} - Solved: {:.0f}, Feas: {:.0f}, Opt/Bnd: {:.0f}, Gap: {:.0f}, Rel: {:.4f}, time: {:.3f}'", ".", "\n", "format", "(", "n", ",", "x", ",", "y", ",", "z", ",", "x", "-", "z", ",", "rel", ",", "fwd_time", ")", ")", "\n", "if", "not", "torch", ".", "isnan", "(", "rel", ")", ":", "\n", "                    ", "rel_sum", "+=", "rel", "\n", "", "sheet", ".", "write", "(", "wb_idx", ",", "name_idx", ",", "n", ")", "\n", "sheet", ".", "write", "(", "wb_idx", ",", "score_idx", ",", "x", ".", "item", "(", ")", ")", "\n", "sheet", ".", "write", "(", "wb_idx", ",", "time_idx", ",", "fwd_time", ")", "\n", "wb_idx", "+=", "1", "\n", "#rel_num += 1", "\n", "\n", "", "if", "iter_num", "%", "cfg", ".", "STATISTIC_STEP", "==", "0", "and", "verbose", ":", "\n", "                ", "running_speed", "=", "cfg", ".", "STATISTIC_STEP", "*", "batch_num", "/", "(", "time", ".", "time", "(", ")", "-", "running_since", ")", "\n", "print", "(", "'Class {:<8} Iteration {:<4} {:>4.2f}sample/s'", ".", "format", "(", "cls", ",", "iter_num", ",", "running_speed", ")", ")", "\n", "running_since", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "", "accs", "[", "i", "]", "=", "acc_match_num", "/", "acc_total_num", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Class {} acc = {:.4f}'", ".", "format", "(", "cls", ",", "accs", "[", "i", "]", ")", ")", "\n", "\n", "", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "print", "(", "'Evaluation complete in {:.0f}m {:.0f}s'", ".", "format", "(", "time_elapsed", "//", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "model", ".", "train", "(", "mode", "=", "was_training", ")", "\n", "ds", ".", "cls", "=", "cls_cache", "\n", "\n", "# print result", "\n", "print", "(", "'mean relative: {:.4f}'", ".", "format", "(", "float", "(", "rel_sum", "/", "rel_num", ")", ")", ")", "\n", "\n", "print", "(", "'Matching accuracy'", ")", "\n", "for", "cls", ",", "single_acc", "in", "zip", "(", "classes", ",", "accs", ")", ":", "\n", "        ", "print", "(", "'{} = {:.4f}'", ".", "format", "(", "cls", ",", "single_acc", ")", ")", "\n", "", "print", "(", "'average = {:.4f}'", ".", "format", "(", "torch", ".", "mean", "(", "accs", ")", ")", ")", "\n", "\n", "now_time", "=", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "'%Y-%m-%d-%H-%M-%S'", ")", "\n", "wb", ".", "save", "(", "str", "(", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", "/", "(", "'eval_'", "+", "now_time", "+", "'.xls'", ")", ")", ")", "\n", "\n", "return", "accs", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.displacement_layer.Displacement.__init__": [[24, 26], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Displacement", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.displacement_layer.Displacement.forward": [[27, 49], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "s", ":", "Tensor", ",", "P_src", ":", "Tensor", ",", "P_tgt", ":", "Tensor", ",", "ns_gt", ":", "Tensor", "=", "None", ")", ":", "\n", "        ", "r\"\"\"\n        :param s: :math:`(b\\times n_1 \\times n_2)` permutation or doubly stochastic matrix. :math:`b`: batch size.\n         :math:`n_1`: number of nodes in source image. :math:`n_2`: number of nodes in target image\n        :param P_src: :math:`(b\\times n_1 \\times 2)` point set on source image\n        :param P_tgt: :math:`(b\\times n_2 \\times 2)` point set on target image\n        :param ns_gt: :math:`(b)` number of exact pairs. We support batched instances with different number of nodes,\n         therefore ``ns_gt`` is required to specify the exact number of nodes of each instance in the batch.\n        :return: displacement matrix d,\n            mask for dummy nodes grad_mask. If ``ns_gt=None``, it will not be calculated and None is returned.\n        \"\"\"", "\n", "if", "ns_gt", "is", "None", ":", "\n", "            ", "max_n", "=", "s", ".", "shape", "[", "1", "]", "\n", "P_src", "=", "P_src", "[", ":", ",", "0", ":", "max_n", ",", ":", "]", "\n", "grad_mask", "=", "None", "\n", "", "else", ":", "\n", "            ", "grad_mask", "=", "torch", ".", "zeros_like", "(", "P_src", ")", "\n", "for", "b", ",", "n", "in", "enumerate", "(", "ns_gt", ")", ":", "\n", "                ", "grad_mask", "[", "b", ",", "0", ":", "n", "]", "=", "1", "\n", "\n", "", "", "d", "=", "torch", ".", "matmul", "(", "s", ",", "P_tgt", ")", "-", "P_src", "\n", "return", "d", ",", "grad_mask", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.RebuildFGM.forward": [[106, 127], ["ctx.save_for_backward", "Kro1.dotdiag", "Kro1.dotdiag.dot", "torch.empty_like", "range", "Ke.transpose().contiguous().view", "Kro1.transpose", "Kro2.transpose", "torch.diag", "Ke.transpose().contiguous", "Kp[].transpose().contiguous().view", "Ke.transpose", "Kp[].transpose().contiguous", "Kp[].transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.dotdiag", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "Ke", ":", "Tensor", ",", "Kp", ":", "Tensor", ",", "Kro1", ":", "CSRMatrix3d", ",", "Kro2", ":", "CSCMatrix3d", ",", "\n", "Kro1T", ":", "CSRMatrix3d", "=", "None", ",", "Kro2T", ":", "CSCMatrix3d", "=", "None", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        Forward function to compute the affinity matrix :math:`\\mathbf K`.\n        \"\"\"", "\n", "ctx", ".", "save_for_backward", "(", "Ke", ",", "Kp", ")", "\n", "if", "Kro1T", "is", "not", "None", "and", "Kro2T", "is", "not", "None", ":", "\n", "            ", "ctx", ".", "K", "=", "Kro1T", ",", "Kro2T", "\n", "", "else", ":", "\n", "            ", "ctx", ".", "K", "=", "Kro1", ".", "transpose", "(", "keep_type", "=", "True", ")", ",", "Kro2", ".", "transpose", "(", "keep_type", "=", "True", ")", "\n", "", "batch_num", "=", "Ke", ".", "shape", "[", "0", "]", "\n", "\n", "Kro1Ke", "=", "Kro1", ".", "dotdiag", "(", "Ke", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "batch_num", ",", "-", "1", ")", ")", "\n", "Kro1KeKro2", "=", "Kro1Ke", ".", "dot", "(", "Kro2", ",", "dense", "=", "True", ")", "\n", "\n", "K", "=", "torch", ".", "empty_like", "(", "Kro1KeKro2", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "K", "[", "b", "]", "=", "Kro1KeKro2", "[", "b", "]", "+", "torch", ".", "diag", "(", "Kp", "[", "b", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.RebuildFGM.backward": [[128, 146], ["src.utils.sparse.bilinear_diag_torch", "dKe.view().transpose.view().transpose.view().transpose", "torch.diagonal", "dKp.view().transpose.view().transpose.view().transpose", "dK.contiguous", "dKe.view().transpose.view().transpose.view", "dKp.view().transpose.view().transpose.view"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.bilinear_diag_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "dK", ")", ":", "\n", "        ", "r\"\"\"\n        Backward function from the affinity matrix :math:`\\mathbf K` to node-wise affinity matrix :math:`\\mathbf K_e`\n        and edge-wize affinity matrix :math:`\\mathbf K_e`.\n        \"\"\"", "\n", "device", "=", "dK", ".", "device", "\n", "Ke", ",", "Kp", "=", "ctx", ".", "saved_tensors", "\n", "Kro1t", ",", "Kro2t", "=", "ctx", ".", "K", "\n", "dKe", "=", "dKp", "=", "None", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", ":", "\n", "            ", "dKe", "=", "bilinear_diag_torch", "(", "Kro1t", ",", "dK", ".", "contiguous", "(", ")", ",", "Kro2t", ")", "\n", "dKe", "=", "dKe", ".", "view", "(", "Ke", ".", "shape", "[", "0", "]", ",", "Ke", ".", "shape", "[", "2", "]", ",", "Ke", ".", "shape", "[", "1", "]", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "            ", "dKp", "=", "torch", ".", "diagonal", "(", "dK", ",", "dim1", "=", "-", "2", ",", "dim2", "=", "-", "1", ")", "\n", "dKp", "=", "dKp", ".", "view", "(", "Kp", ".", "shape", "[", "0", "]", ",", "Kp", ".", "shape", "[", "2", "]", ",", "Kp", ".", "shape", "[", "1", "]", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "", "return", "dKe", ",", "dKp", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat": [[10, 55], ["RebuildFGM.apply"], "function", ["None"], ["def", "construct_aff_mat", "(", "Ke", ":", "Tensor", ",", "Kp", ":", "Tensor", ",", "KroG", ":", "CSRMatrix3d", ",", "KroH", ":", "CSCMatrix3d", ",", "\n", "KroGt", ":", "CSRMatrix3d", "=", "None", ",", "KroHt", ":", "CSCMatrix3d", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Construct the complete affinity matrix with edge-wise affinity matrix :math:`\\mathbf{K}_e`, node-wise matrix\n    :math:`\\mathbf{K}_p` and graph connectivity matrices :math:`\\mathbf{G}_1, \\mathbf{H}_1, \\mathbf{G}_2, \\mathbf{H}_2`\n\n    .. math ::\n        \\mathbf{K}=\\mathrm{diag}(\\mathrm{vec}(\\mathbf{K}_p)) +\n        (\\mathbf{G}_2 \\otimes_{\\mathcal{K}} \\mathbf{G}_1) \\mathrm{diag}(\\mathrm{vec}(\\mathbf{K}_e))\n        (\\mathbf{H}_2 \\otimes_{\\mathcal{K}} \\mathbf{H}_1)^\\top\n\n    where :math:`\\mathrm{diag}(\\cdot)` means building a diagonal matrix based on the given vector,\n    and :math:`\\mathrm{vec}(\\cdot)` means column-wise vectorization.\n    :math:`\\otimes_{\\mathcal{K}}` denotes Kronecker product.\n\n    This function supports batched operations. This formulation is developed by `\"F. Zhou and F. Torre. Factorized\n    Graph Matching. TPAMI 2015.\" <http://www.f-zhou.com/gm/2015_PAMI_FGM_Draft.pdf>`_\n\n    :param Ke: :math:`(b\\times n_{e_1}\\times n_{e_2})` edge-wise affinity matrix.\n     :math:`n_{e_1}`: number of edges in graph 1, :math:`n_{e_2}`: number of edges in graph 2\n    :param Kp: :math:`(b\\times n_1\\times n_2)` node-wise affinity matrix.\n     :math:`n_1`: number of nodes in graph 1, :math:`n_2`: number of nodes in graph 2\n    :param KroG: :math:`(b\\times n_1n_2 \\times n_{e_1}n_{e_2})` kronecker product of\n     :math:`\\mathbf{G}_2 (b\\times n_2 \\times n_{e_2})`, :math:`\\mathbf{G}_1 (b\\times n_1 \\times n_{e_1})`\n    :param KroH: :math:`(b\\times n_1n_2 \\times n_{e_1}n_{e_2})` kronecker product of\n     :math:`\\mathbf{H}_2 (b\\times n_2 \\times n_{e_2})`, :math:`\\mathbf{H}_1 (b\\times n_1 \\times n_{e_1})`\n    :param KroGt: transpose of KroG (should be CSR, optional)\n    :param KroHt: transpose of KroH (should be CSC, optional)\n    :return: affinity matrix :math:`\\mathbf K`\n\n    .. note ::\n        This function is optimized with sparse CSR and CSC matrices with GPU support for both forward and backward\n        computation with PyTorch. To use this function, you need to install ``ninja-build``, ``gcc-7``, ``nvcc`` (which\n        comes along with CUDA development tools) to successfully compile our customized CUDA code for CSR and CSC\n        matrices. The compiler is automatically called upon requirement.\n\n    For a graph matching problem with 5 nodes and 4 nodes,\n    the connection of :math:`\\mathbf K` and :math:`\\mathbf{K}_p, \\mathbf{K}_e` is illustrated as\n\n    .. image :: ../../images/factorized_graph_matching.png\n\n    where :math:`\\mathbf K (20 \\times 20)` is the complete affinity matrix, :math:`\\mathbf{K}_p (5 \\times 4)` is the\n    node-wise affinity matrix, :math:`\\mathbf{K}_e(16 \\times 10)` is the edge-wise affinity matrix.\n    \"\"\"", "\n", "return", "RebuildFGM", ".", "apply", "(", "Ke", ",", "Kp", ",", "KroG", ",", "KroH", ",", "KroGt", ",", "KroHt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.kronecker_torch": [[57, 82], ["torch.stack", "torch.sparse.FloatTensor", "t1.reshape.reshape", "t2.reshape.reshape", "torch.bmm", "tt.reshape.reshape", "tt.reshape.permute", "tt.reshape.reshape", "torch.repeat_interleave", "t2.reshape._indices().repeat", "torch.repeat_interleave", "t2.reshape._values().repeat", "torch.Size", "t2.reshape._nnz", "t1.reshape._nnz", "t1.reshape._values", "t2.reshape._nnz", "t1.reshape._nnz", "t1.reshape._indices", "t1.reshape._indices", "t2.reshape._indices", "t2.reshape._values"], "function", ["None"], ["", "def", "kronecker_torch", "(", "t1", ":", "Tensor", ",", "t2", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Compute the kronecker product of :math:`\\mathbf{T}_1` and :math:`\\mathbf{T}_2`.\n    This function is implemented in torch API and is not efficient for sparse {0, 1} matrix.\n\n    :param t1: input tensor 1\n    :param t2: input tensor 2\n    :return: kronecker product of :math:`\\mathbf{T}_1` and :math:`\\mathbf{T}_2`\n    \"\"\"", "\n", "batch_num", "=", "t1", ".", "shape", "[", "0", "]", "\n", "t1dim1", ",", "t1dim2", "=", "t1", ".", "shape", "[", "1", "]", ",", "t1", ".", "shape", "[", "2", "]", "\n", "t2dim1", ",", "t2dim2", "=", "t2", ".", "shape", "[", "1", "]", ",", "t2", ".", "shape", "[", "2", "]", "\n", "if", "t1", ".", "is_sparse", "and", "t2", ".", "is_sparse", ":", "\n", "        ", "tt_idx", "=", "torch", ".", "stack", "(", "t1", ".", "_indices", "(", ")", "[", "0", ",", ":", "]", "*", "t2dim1", ",", "t1", ".", "_indices", "(", ")", "[", "1", ",", ":", "]", "*", "t2dim2", ")", "\n", "tt_idx", "=", "torch", ".", "repeat_interleave", "(", "tt_idx", ",", "t2", ".", "_nnz", "(", ")", ",", "dim", "=", "1", ")", "+", "t2", ".", "_indices", "(", ")", ".", "repeat", "(", "1", ",", "t1", ".", "_nnz", "(", ")", ")", "\n", "tt_val", "=", "torch", ".", "repeat_interleave", "(", "t1", ".", "_values", "(", ")", ",", "t2", ".", "_nnz", "(", ")", ",", "dim", "=", "1", ")", "*", "t2", ".", "_values", "(", ")", ".", "repeat", "(", "1", ",", "t1", ".", "_nnz", "(", ")", ")", "\n", "tt", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "tt_idx", ",", "tt_val", ",", "torch", ".", "Size", "(", "t1dim1", "*", "t2dim1", ",", "t1dim2", "*", "t2dim2", ")", ")", "\n", "", "else", ":", "\n", "        ", "t1", "=", "t1", ".", "reshape", "(", "batch_num", ",", "-", "1", ",", "1", ")", "\n", "t2", "=", "t2", ".", "reshape", "(", "batch_num", ",", "1", ",", "-", "1", ")", "\n", "tt", "=", "torch", ".", "bmm", "(", "t1", ",", "t2", ")", "\n", "tt", "=", "tt", ".", "reshape", "(", "batch_num", ",", "t1dim1", ",", "t1dim2", ",", "t2dim1", ",", "t2dim2", ")", "\n", "tt", "=", "tt", ".", "permute", "(", "[", "0", ",", "1", ",", "3", ",", "2", ",", "4", "]", ")", "\n", "tt", "=", "tt", ".", "reshape", "(", "batch_num", ",", "t1dim1", "*", "t2dim1", ",", "t1dim2", "*", "t2dim2", ")", "\n", "", "return", "tt", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.kronecker_sparse": [[84, 97], ["scipy.coo_matrix", "scipy.coo_matrix", "scipy.kron"], "function", ["None"], ["", "def", "kronecker_sparse", "(", "arr1", ":", "np", ".", "ndarray", ",", "arr2", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "r\"\"\"\n    Compute the kronecker product of :math:`\\mathbf{T}_1` and :math:`\\mathbf{T}_2`.\n    This function is implemented in scipy.sparse API and runs on cpu.\n\n    :param arr1: input array 1\n    :param arr2: input array 2\n    :return: kronecker product of :math:`\\mathbf{T}_1` and :math:`\\mathbf{T}_2`\n    \"\"\"", "\n", "s1", "=", "ssp", ".", "coo_matrix", "(", "arr1", ")", "\n", "s2", "=", "ssp", ".", "coo_matrix", "(", "arr2", ")", "\n", "ss", "=", "ssp", ".", "kron", "(", "s1", ",", "s2", ")", "\n", "return", "ss", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Gconv.__init__": [[17, 23], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ":", "int", ",", "out_features", ":", "int", ")", ":", "\n", "        ", "super", "(", "Gconv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_inputs", "=", "in_features", "\n", "self", ".", "num_outputs", "=", "out_features", "\n", "self", ".", "a_fc", "=", "nn", ".", "Linear", "(", "self", ".", "num_inputs", ",", "self", ".", "num_outputs", ")", "\n", "self", ".", "u_fc", "=", "nn", ".", "Linear", "(", "self", ".", "num_inputs", ",", "self", ".", "num_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Gconv.forward": [[24, 39], ["gconv.Gconv.a_fc", "gconv.Gconv.u_fc", "torch.normalize", "torch.normalize", "torch.normalize", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "A", ":", "Tensor", ",", "x", ":", "Tensor", ",", "norm", ":", "bool", "=", "True", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Forward computation of graph convolution network.\n\n        :param A: :math:`(b\\times n\\times n)` {0,1} adjacency matrix. :math:`b`: batch size, :math:`n`: number of nodes\n        :param x: :math:`(b\\times n\\times d)` input node embedding. :math:`d`: feature dimension\n        :param norm: normalize connectivity matrix or not\n        :return: :math:`(b\\times n\\times d^\\prime)` new node embedding\n        \"\"\"", "\n", "if", "norm", "is", "True", ":", "\n", "            ", "A", "=", "F", ".", "normalize", "(", "A", ",", "p", "=", "1", ",", "dim", "=", "-", "2", ")", "\n", "", "ax", "=", "self", ".", "a_fc", "(", "x", ")", "\n", "ux", "=", "self", ".", "u_fc", "(", "x", ")", "\n", "x", "=", "torch", ".", "bmm", "(", "A", ",", "F", ".", "relu", "(", "ax", ")", ")", "+", "F", ".", "relu", "(", "ux", ")", "# has size (bs, N, num_outputs)", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.ChannelIndependentConv.__init__": [[52, 63], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ":", "int", ",", "out_features", ":", "int", ",", "in_edges", ":", "int", ",", "out_edges", ":", "int", "=", "None", ")", ":", "\n", "        ", "super", "(", "ChannelIndependentConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "out_edges", "is", "None", ":", "\n", "            ", "out_edges", "=", "out_features", "\n", "", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "out_edges", "=", "out_edges", "\n", "# self.node_fc = nn.Linear(in_features, out_features // self.out_edges)", "\n", "self", ".", "node_fc", "=", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ")", "\n", "self", ".", "node_sfc", "=", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ")", "\n", "self", ".", "edge_fc", "=", "nn", ".", "Linear", "(", "in_edges", ",", "self", ".", "out_edges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.ChannelIndependentConv.forward": [[64, 110], ["gconv.ChannelIndependentConv.node_fc", "gconv.ChannelIndependentConv.node_sfc", "gconv.ChannelIndependentConv.edge_fc", "torch.mul.unsqueeze", "torch.mul.unsqueeze", "torch.mul.unsqueeze", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "node_x.squeeze().transpose.squeeze().transpose.squeeze().transpose", "torch.relu", "torch.relu", "torch.relu", "torch.mul.expand_as", "torch.mul.expand_as", "torch.mul.expand_as", "torch.mul.transpose().transpose", "torch.mul.transpose().transpose", "torch.mul.transpose().transpose", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze().transpose().transpose", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "gconv.ChannelIndependentConv.node_fc", "gconv.ChannelIndependentConv.node_sfc", "gconv.ChannelIndependentConv.edge_fc", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.mul.unsqueeze", "torch.mul.unsqueeze", "torch.mul.unsqueeze", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "node_x.squeeze().transpose.squeeze().transpose.squeeze().transpose", "torch.relu", "torch.relu", "torch.relu", "ValueError", "node_x.squeeze().transpose.squeeze().transpose.squeeze", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze", "torch.mul.expand_as", "torch.mul.expand_as", "torch.mul.expand_as", "torch.mul.transpose().transpose", "torch.mul.transpose().transpose", "torch.mul.transpose().transpose", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze().transpose().transpose", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.mul.transpose", "torch.mul.transpose", "torch.mul.transpose", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze().transpose", "node_x.squeeze().transpose.squeeze().transpose.squeeze", "torch.mul.transpose", "torch.mul.transpose", "torch.mul.transpose", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze().transpose", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze", "node_x.squeeze().transpose.squeeze().transpose.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "A", ":", "Tensor", ",", "emb_node", ":", "Tensor", ",", "emb_edge", ":", "Tensor", ",", "mode", ":", "int", "=", "1", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "        ", "r\"\"\"\n        :param A: :math:`(b\\times n\\times n)` {0,1} adjacency matrix. :math:`b`: batch size, :math:`n`: number of nodes\n        :param emb_node: :math:`(b\\times n\\times d_n)` input node embedding. :math:`d_n`: node feature dimension\n        :param emb_edge: :math:`(b\\times n\\times n\\times d_e)` input edge embedding. :math:`d_e`: edge feature dimension\n        :param mode: 1 or 2, refer to the paper for details\n        :return: :math:`(b\\times n\\times d^\\prime)` new node embedding,\n         :math:`(b\\times n\\times n\\times d^\\prime)` new edge embedding\n        \"\"\"", "\n", "if", "mode", "==", "1", ":", "\n", "            ", "node_x", "=", "self", ".", "node_fc", "(", "emb_node", ")", "\n", "node_sx", "=", "self", ".", "node_sfc", "(", "emb_node", ")", "\n", "edge_x", "=", "self", ".", "edge_fc", "(", "emb_edge", ")", "\n", "\n", "A", "=", "A", ".", "unsqueeze", "(", "-", "1", ")", "\n", "A", "=", "torch", ".", "mul", "(", "A", ".", "expand_as", "(", "edge_x", ")", ",", "edge_x", ")", "\n", "\n", "node_x", "=", "torch", ".", "matmul", "(", "A", ".", "transpose", "(", "2", ",", "3", ")", ".", "transpose", "(", "1", ",", "2", ")", ",", "\n", "node_x", ".", "unsqueeze", "(", "2", ")", ".", "transpose", "(", "2", ",", "3", ")", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "node_x", "=", "node_x", ".", "squeeze", "(", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "node_x", "=", "F", ".", "relu", "(", "node_x", ")", "+", "F", ".", "relu", "(", "node_sx", ")", "\n", "edge_x", "=", "F", ".", "relu", "(", "edge_x", ")", "\n", "\n", "return", "node_x", ",", "edge_x", "\n", "\n", "", "elif", "mode", "==", "2", ":", "\n", "            ", "node_x", "=", "self", ".", "node_fc", "(", "emb_node", ")", "\n", "node_sx", "=", "self", ".", "node_sfc", "(", "emb_node", ")", "\n", "edge_x", "=", "self", ".", "edge_fc", "(", "emb_edge", ")", "\n", "\n", "d_x", "=", "node_x", ".", "unsqueeze", "(", "1", ")", "-", "node_x", ".", "unsqueeze", "(", "2", ")", "\n", "d_x", "=", "torch", ".", "sum", "(", "d_x", "**", "2", ",", "dim", "=", "3", ",", "keepdim", "=", "False", ")", "\n", "d_x", "=", "torch", ".", "exp", "(", "-", "d_x", ")", "\n", "\n", "A", "=", "A", ".", "unsqueeze", "(", "-", "1", ")", "\n", "A", "=", "torch", ".", "mul", "(", "A", ".", "expand_as", "(", "edge_x", ")", ",", "edge_x", ")", "\n", "\n", "node_x", "=", "torch", ".", "matmul", "(", "A", ".", "transpose", "(", "2", ",", "3", ")", ".", "transpose", "(", "1", ",", "2", ")", ",", "\n", "node_x", ".", "unsqueeze", "(", "2", ")", ".", "transpose", "(", "2", ",", "3", ")", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "node_x", "=", "node_x", ".", "squeeze", "(", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "node_x", "=", "F", ".", "relu", "(", "node_x", ")", "+", "F", ".", "relu", "(", "node_sx", ")", "\n", "edge_x", "=", "F", ".", "relu", "(", "edge_x", ")", "\n", "return", "node_x", ",", "edge_x", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown mode {}. Possible options: 1 or 2'", ".", "format", "(", "mode", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Siamese_Gconv.__init__": [[119, 122], ["torch.Module.__init__", "gconv.Gconv"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ",", "num_features", ")", ":", "\n", "        ", "super", "(", "Siamese_Gconv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gconv", "=", "Gconv", "(", "in_features", ",", "num_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Siamese_Gconv.forward": [[123, 141], ["gconv.Siamese_Gconv.gconv", "len", "returns.append", "gconv.Siamese_Gconv.gconv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "g1", ":", "Tuple", "[", "Tensor", ",", "Tensor", ",", "Tensor", ",", "int", "]", ",", "*", "args", ")", "->", "Union", "[", "Tensor", ",", "List", "[", "Tensor", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Forward computation of Siamese Gconv.\n\n        :param g1: The first graph, which is a tuple of (:math:`(b\\times n\\times n)` {0,1} adjacency matrix,\n         :math:`(b\\times n\\times d)` input node embedding, normalize connectivity matrix or not)\n        :param args: Other graphs\n        :return: A list of tensors composed of new node embeddings :math:`(b\\times n\\times d^\\prime)`\n        \"\"\"", "\n", "# embx are tensors of size (bs, N, num_features)", "\n", "emb1", "=", "self", ".", "gconv", "(", "*", "g1", ")", "\n", "if", "len", "(", "args", ")", "==", "0", ":", "\n", "            ", "return", "emb1", "\n", "", "else", ":", "\n", "            ", "returns", "=", "[", "emb1", "]", "\n", "for", "g", "in", "args", ":", "\n", "                ", "returns", ".", "append", "(", "self", ".", "gconv", "(", "*", "g", ")", ")", "\n", "", "return", "returns", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Siamese_ChannelIndependentConv.__init__": [[151, 155], ["torch.Module.__init__", "gconv.ChannelIndependentConv"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ",", "num_features", ",", "in_edges", ",", "out_edges", "=", "None", ")", ":", "\n", "        ", "super", "(", "Siamese_ChannelIndependentConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_feature", "=", "in_features", "\n", "self", ".", "gconv", "=", "ChannelIndependentConv", "(", "in_features", ",", "num_features", ",", "in_edges", ",", "out_edges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.gconv.Siamese_ChannelIndependentConv.forward": [[156, 174], ["gconv.Siamese_ChannelIndependentConv.gconv", "gconv.Siamese_ChannelIndependentConv.gconv", "embs.append", "emb_edges.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "g1", ":", "Tuple", "[", "Tensor", ",", "Tensor", ",", "Optional", "[", "bool", "]", "]", ",", "*", "args", ")", "->", "List", "[", "Tensor", "]", ":", "\n", "        ", "r\"\"\"\n        Forward computation of Siamese Channel Independent Conv.\n\n        :param g1: The first graph, which is a tuple of (:math:`(b\\times n\\times n)` {0,1} adjacency matrix,\n         :math:`(b\\times n\\times d_n)` input node embedding, :math:`(b\\times n\\times n\\times d_e)` input edge embedding,\n         mode (``1`` or ``2``))\n        :param args: Other graphs\n        :return: A list of tensors composed of new node embeddings :math:`(b\\times n\\times d^\\prime)`, appended with new\n         edge embeddings :math:`(b\\times n\\times n\\times d^\\prime)`\n        \"\"\"", "\n", "emb1", ",", "emb_edge1", "=", "self", ".", "gconv", "(", "*", "g1", ")", "\n", "embs", "=", "[", "emb1", "]", "\n", "emb_edges", "=", "[", "emb_edge1", "]", "\n", "for", "g", "in", "args", ":", "\n", "            ", "emb2", ",", "emb_edge2", "=", "self", ".", "gconv", "(", "*", "g", ")", "\n", "embs", ".", "append", "(", "emb2", ")", ",", "emb_edges", ".", "append", "(", "emb_edge2", ")", "\n", "", "return", "embs", "+", "emb_edges", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.initialize": [[6, 26], ["init_func"], "function", ["None"], ["def", "initialize", "(", "X", ":", "Tensor", ",", "num_clusters", ":", "int", ",", "method", ":", "str", "=", "'plus'", ")", "->", "np", ".", "array", ":", "\n", "    ", "r\"\"\"\n    Initialize cluster centers.\n\n    :param X: matrix\n    :param num_clusters: number of clusters\n    :param method: denotes different initialization strategies: ``'plus'`` (default) or ``'random'``\n    :return: initial state\n\n    .. note::\n        We support two initialization strategies: random initialization by setting ``method='random'``, or `kmeans++\n        <https://en.wikipedia.org/wiki/K-means%2B%2B>`_ by setting ``method='plus'``.\n    \"\"\"", "\n", "if", "method", "==", "'plus'", ":", "\n", "        ", "init_func", "=", "_initialize_plus", "\n", "", "elif", "method", "==", "'random'", ":", "\n", "        ", "init_func", "=", "_initialize_random", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "init_func", "(", "X", ",", "num_clusters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering._initialize_random": [[28, 36], ["len", "numpy.random.choice"], "function", ["None"], ["", "def", "_initialize_random", "(", "X", ",", "num_clusters", ")", ":", "\n", "    ", "\"\"\"\n    Initialize cluster centers randomly. See :func:`src.spectral_clustering.initialize` for details.\n    \"\"\"", "\n", "num_samples", "=", "len", "(", "X", ")", "\n", "indices", "=", "np", ".", "random", ".", "choice", "(", "num_samples", ",", "num_clusters", ",", "replace", "=", "False", ")", "\n", "initial_state", "=", "X", "[", "indices", "]", "\n", "return", "initial_state", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering._initialize_plus": [[37, 57], ["len", "numpy.zeros", "range", "numpy.random.choice", "numpy.full", "spectral_clustering._pairwise_distance", "choice_prob.detach().cpu().numpy.detach().cpu().numpy", "torch.min", "torch.sum", "choice_prob.detach().cpu().numpy.detach().cpu", "choice_prob.detach().cpu().numpy.detach"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering._pairwise_distance", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["", "def", "_initialize_plus", "(", "X", ",", "num_clusters", ")", ":", "\n", "    ", "\"\"\"\n    Initialize cluster centers by k-means++. See :func:`src.spectral_clustering.initialize` for details.\n    \"\"\"", "\n", "num_samples", "=", "len", "(", "X", ")", "\n", "centroid_index", "=", "np", ".", "zeros", "(", "num_clusters", ")", "\n", "for", "i", "in", "range", "(", "num_clusters", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "choice_prob", "=", "np", ".", "full", "(", "num_samples", ",", "1", "/", "num_samples", ")", "\n", "", "else", ":", "\n", "            ", "centroid_X", "=", "X", "[", "centroid_index", "[", ":", "i", "]", "]", "\n", "dis", "=", "_pairwise_distance", "(", "X", ",", "centroid_X", ")", "\n", "dis_to_nearest_centroid", "=", "torch", ".", "min", "(", "dis", ",", "dim", "=", "1", ")", ".", "values", "\n", "choice_prob", "=", "dis_to_nearest_centroid", "/", "torch", ".", "sum", "(", "dis_to_nearest_centroid", ")", "\n", "choice_prob", "=", "choice_prob", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "centroid_index", "[", "i", "]", "=", "np", ".", "random", ".", "choice", "(", "num_samples", ",", "1", ",", "p", "=", "choice_prob", ",", "replace", "=", "False", ")", "\n", "\n", "", "initial_state", "=", "X", "[", "centroid_index", "]", "\n", "return", "initial_state", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.kmeans": [[58, 126], ["torch.device", "X.to.float", "X.to.to", "type", "spectral_clustering.initialize", "pairwise_distance_function", "torch.argmin", "initialize.clone", "range", "torch.sum", "torch.isnan().any", "torch.argmin.cpu", "initialize.cpu", "torch.nonzero().squeeze().to", "torch.index_select", "torch.index_select.mean", "torch.sqrt", "print", "spectral_clustering.initialize", "torch.sum", "torch.isnan", "torch.nonzero().squeeze", "torch.nonzero"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.initialize", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.initialize"], ["", "def", "kmeans", "(", "\n", "X", ":", "Tensor", ",", "\n", "num_clusters", ":", "int", ",", "\n", "init_x", ":", "Union", "[", "Tensor", ",", "str", "]", "=", "'plus'", ",", "\n", "distance", ":", "str", "=", "'euclidean'", ",", "\n", "tol", ":", "float", "=", "1e-4", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "    ", "r\"\"\"\n    Perform kmeans on given data matrix :math:`\\mathbf X`.\n\n    :param X: :math:`(n\\times d)` input data matrix. :math:`n`: number of samples. :math:`d`: feature dimension\n    :param num_clusters: (int) number of clusters\n    :param init_x: how to initiate x (provide a initial state of x or define a init method) [default: 'plus']\n    :param distance: distance [options: 'euclidean', 'cosine'] [default: 'euclidean']\n    :param tol: convergence threshold [default: 0.0001]\n    :param device: computing device [default: cpu]\n    :return: cluster ids, cluster centers\n    \"\"\"", "\n", "if", "distance", "==", "'euclidean'", ":", "\n", "        ", "pairwise_distance_function", "=", "_pairwise_distance", "\n", "", "elif", "distance", "==", "'cosine'", ":", "\n", "        ", "pairwise_distance_function", "=", "_pairwise_cosine", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# convert to float", "\n", "", "X", "=", "X", ".", "float", "(", ")", "\n", "\n", "# transfer to device", "\n", "X", "=", "X", ".", "to", "(", "device", ")", "\n", "\n", "# initialize", "\n", "if", "type", "(", "init_x", ")", "is", "str", ":", "\n", "        ", "initial_state", "=", "initialize", "(", "X", ",", "num_clusters", ",", "method", "=", "init_x", ")", "\n", "", "else", ":", "\n", "        ", "initial_state", "=", "init_x", "\n", "\n", "", "iteration", "=", "0", "\n", "while", "True", ":", "\n", "        ", "dis", "=", "pairwise_distance_function", "(", "X", ",", "initial_state", ")", "\n", "\n", "choice_cluster", "=", "torch", ".", "argmin", "(", "dis", ",", "dim", "=", "1", ")", "\n", "\n", "initial_state_pre", "=", "initial_state", ".", "clone", "(", ")", "\n", "\n", "for", "index", "in", "range", "(", "num_clusters", ")", ":", "\n", "            ", "selected", "=", "torch", ".", "nonzero", "(", "choice_cluster", "==", "index", ",", "as_tuple", "=", "False", ")", ".", "squeeze", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "selected", "=", "torch", ".", "index_select", "(", "X", ",", "0", ",", "selected", ")", "\n", "initial_state", "[", "index", "]", "=", "selected", ".", "mean", "(", "dim", "=", "0", ")", "\n", "\n", "", "center_shift", "=", "torch", ".", "sum", "(", "\n", "torch", ".", "sqrt", "(", "\n", "torch", ".", "sum", "(", "(", "initial_state", "-", "initial_state_pre", ")", "**", "2", ",", "dim", "=", "1", ")", "\n", ")", ")", "\n", "\n", "# increment iteration", "\n", "iteration", "=", "iteration", "+", "1", "\n", "\n", "if", "center_shift", "**", "2", "<", "tol", ":", "\n", "            ", "break", "\n", "\n", "", "if", "torch", ".", "isnan", "(", "initial_state", ")", ".", "any", "(", ")", ":", "\n", "            ", "print", "(", "'NAN encountered in clustering. Retrying...'", ")", "\n", "initial_state", "=", "initialize", "(", "X", ",", "num_clusters", ")", "\n", "\n", "", "", "return", "choice_cluster", ".", "cpu", "(", ")", ",", "initial_state", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.kmeans_predict": [[128, 160], ["torch.device", "X.to.float", "X.to.to", "pairwise_distance_function", "torch.argmin", "torch.argmin.cpu"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["", "def", "kmeans_predict", "(", "\n", "X", ":", "Tensor", ",", "\n", "cluster_centers", ":", "Tensor", ",", "\n", "distance", ":", "str", "=", "'euclidean'", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", "\n", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Kmeans prediction using existing cluster centers.\n\n    :param X: matrix\n    :param cluster_centers: cluster centers\n    :param distance: distance [options: 'euclidean', 'cosine'] [default: 'euclidean']\n    :param device: computing device [default: 'cpu']\n    :return: cluster ids\n    \"\"\"", "\n", "if", "distance", "==", "'euclidean'", ":", "\n", "        ", "pairwise_distance_function", "=", "_pairwise_distance", "\n", "", "elif", "distance", "==", "'cosine'", ":", "\n", "        ", "pairwise_distance_function", "=", "_pairwise_cosine", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# convert to float", "\n", "", "X", "=", "X", ".", "float", "(", ")", "\n", "\n", "# transfer to device", "\n", "X", "=", "X", ".", "to", "(", "device", ")", "\n", "\n", "dis", "=", "pairwise_distance_function", "(", "X", ",", "cluster_centers", ")", "\n", "choice_cluster", "=", "torch", ".", "argmin", "(", "dis", ",", "dim", "=", "1", ")", "\n", "\n", "return", "choice_cluster", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering._pairwise_distance": [[162, 177], ["torch.device", "data1.unsqueeze", "data2.unsqueeze", "dis.sum.sum", "data1.to", "data2.to"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "_pairwise_distance", "(", "data1", ",", "data2", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"Compute pairwise Euclidean distance\"\"\"", "\n", "# transfer to device", "\n", "data1", ",", "data2", "=", "data1", ".", "to", "(", "device", ")", ",", "data2", ".", "to", "(", "device", ")", "\n", "\n", "# N*1*M", "\n", "A", "=", "data1", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "\n", "# 1*N*M", "\n", "B", "=", "data2", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "dis", "=", "(", "A", "-", "B", ")", "**", "2.0", "\n", "# return N*N matrix for pairwise distance", "\n", "dis", "=", "dis", ".", "sum", "(", "dim", "=", "-", "1", ")", "#.squeeze(-1)", "\n", "return", "dis", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering._pairwise_cosine": [[179, 199], ["torch.device", "data1.unsqueeze", "data2.unsqueeze", "data1.to", "data2.to", "data1.unsqueeze.norm", "data2.unsqueeze.norm", "cosine.sum().squeeze", "cosine.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "_pairwise_cosine", "(", "data1", ",", "data2", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"Compute pairwise cosine distance\"\"\"", "\n", "# transfer to device", "\n", "data1", ",", "data2", "=", "data1", ".", "to", "(", "device", ")", ",", "data2", ".", "to", "(", "device", ")", "\n", "\n", "# N*1*M", "\n", "A", "=", "data1", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "\n", "# 1*N*M", "\n", "B", "=", "data2", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "# normalize the points  | [0.3, 0.4] -> [0.3/sqrt(0.09 + 0.16), 0.4/sqrt(0.09 + 0.16)] = [0.3/0.5, 0.4/0.5]", "\n", "A_normalized", "=", "A", "/", "A", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "B_normalized", "=", "B", "/", "B", ".", "norm", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "cosine", "=", "A_normalized", "*", "B_normalized", "\n", "\n", "# return N*N matrix for pairwise distance", "\n", "cosine_dis", "=", "1", "-", "cosine", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "return", "cosine_dis", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.spectral_clustering": [[201, 237], ["torch.diagflat", "torch.symeig", "choice_cluster.to.to", "torch.sum", "torch.argsort", "spectral_clustering.kmeans", "torch.diag().unsqueeze", "torch.abs", "torch.diag"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.spectral_clustering.kmeans"], ["", "def", "spectral_clustering", "(", "sim_matrix", ":", "Tensor", ",", "cluster_num", ":", "int", ",", "init", ":", "Tensor", "=", "None", ",", "\n", "return_state", ":", "bool", "=", "False", ",", "normalized", ":", "bool", "=", "False", ")", ":", "\n", "    ", "r\"\"\"\n    Perform spectral clustering based on given similarity matrix.\n\n    This function firstly computes the leading eigenvectors of the given similarity matrix, and then utilizes the\n    eigenvectors as features and performs k-means clustering based on these features.\n\n    :param sim_matrix: :math:`(n\\times n)` input similarity matrix. :math:`n`: number of instances\n    :param cluster_num: number of clusters\n    :param init: the initialization technique or initial features for k-means\n    :param return_state: whether return state features (can be further used for prediction)\n    :param normalized: whether to normalize the similarity matrix by its degree\n    :return: the belonging of each instance to clusters, state features (if ``return_state==True``)\n    \"\"\"", "\n", "degree", "=", "torch", ".", "diagflat", "(", "torch", ".", "sum", "(", "sim_matrix", ",", "dim", "=", "-", "1", ")", ")", "\n", "if", "normalized", ":", "\n", "        ", "aff_matrix", "=", "(", "degree", "-", "sim_matrix", ")", "/", "torch", ".", "diag", "(", "degree", ")", ".", "unsqueeze", "(", "1", ")", "\n", "", "else", ":", "\n", "        ", "aff_matrix", "=", "degree", "-", "sim_matrix", "\n", "", "e", ",", "v", "=", "torch", ".", "symeig", "(", "aff_matrix", ",", "eigenvectors", "=", "True", ")", "\n", "topargs", "=", "torch", ".", "argsort", "(", "torch", ".", "abs", "(", "e", ")", ",", "descending", "=", "False", ")", "[", "1", ":", "cluster_num", "]", "\n", "v", "=", "v", "[", ":", ",", "topargs", "]", "\n", "\n", "if", "cluster_num", "==", "2", ":", "\n", "        ", "choice_cluster", "=", "(", "v", ">", "0", ")", ".", "to", "(", "torch", ".", "int", ")", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "        ", "choice_cluster", ",", "initial_state", "=", "kmeans", "(", "v", ",", "cluster_num", ",", "init", "if", "init", "is", "not", "None", "else", "'plus'", ",", "\n", "distance", "=", "'euclidean'", ",", "tol", "=", "1e-6", ")", "\n", "\n", "", "choice_cluster", "=", "choice_cluster", ".", "to", "(", "sim_matrix", ".", "device", ")", "\n", "\n", "if", "return_state", ":", "\n", "        ", "return", "choice_cluster", ",", "initial_state", "\n", "", "else", ":", "\n", "        ", "return", "choice_cluster", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.pck": [[6, 56], ["torch.argmax", "torch.zeros", "range", "torch.zeros", "torch.zeros", "range", "range", "torch.norm", "torch.sum().to", "ns[].to", "torch.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["def", "pck", "(", "x", ":", "Tensor", ",", "x_gt", ":", "Tensor", ",", "perm_mat", ":", "Tensor", ",", "dist_threshs", ":", "Tensor", ",", "ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Percentage of Correct Keypoints (PCK) evaluation metric.\n\n    If the distance between predicted keypoint and the ground truth keypoint is smaller than a given threshold, than it\n    is regraded as a correct matching.\n\n    This is the evaluation metric used by `\"Zanfir et al. Deep Learning of Graph Matching. CVPR 2018.\"\n    <http://openaccess.thecvf.com/content_cvpr_2018/html/Zanfir_Deep_Learning_of_CVPR_2018_paper.html>`_\n\n    :param x: :math:`(b\\times n \\times 2)` candidate coordinates. :math:`n`: number of nodes in input graph\n    :param x_gt: :math:`(b\\times n_{gt} \\times 2)` ground truth coordinates. :math:`n_{gt}`: number of nodes in ground\n     truth graph\n    :param perm_mat: :math:`(b\\times n \\times n_{gt})` permutation matrix or doubly-stochastic matrix indicating\n     node-to-node correspondence\n    :param dist_threshs: :math:`(b\\times m)` a tensor contains thresholds in pixel. :math:`m`: number of thresholds for\n     each batch\n    :param ns: :math:`(b)` number of exact pairs. We support batched instances with different number of nodes, and\n     ``ns`` is required to specify the exact number of nodes of each instance in the batch.\n    :return: :math:`(m)` the PCK values of this batch\n\n    .. note::\n        An example of ``dist_threshs`` for 4 batches and 2 thresholds:\n        ::\n\n            [[10, 20],\n             [10, 20],\n             [10, 20],\n             [10, 20]]\n    \"\"\"", "\n", "device", "=", "x", ".", "device", "\n", "batch_num", "=", "x", ".", "shape", "[", "0", "]", "\n", "thresh_num", "=", "dist_threshs", ".", "shape", "[", "1", "]", "\n", "\n", "indices", "=", "torch", ".", "argmax", "(", "perm_mat", ",", "dim", "=", "-", "1", ")", "\n", "\n", "dist", "=", "torch", ".", "zeros", "(", "batch_num", ",", "x_gt", ".", "shape", "[", "1", "]", ",", "device", "=", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "x_correspond", "=", "x", "[", "b", ",", "indices", "[", "b", "]", ",", ":", "]", "\n", "dist", "[", "b", ",", "0", ":", "ns", "[", "b", "]", "]", "=", "torch", ".", "norm", "(", "x_correspond", "-", "x_gt", "[", "b", "]", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "[", "0", ":", "ns", "[", "b", "]", "]", "\n", "\n", "", "match_num", "=", "torch", ".", "zeros", "(", "thresh_num", ",", "device", "=", "device", ")", "\n", "total_num", "=", "torch", ".", "zeros", "(", "thresh_num", ",", "device", "=", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "for", "idx", "in", "range", "(", "thresh_num", ")", ":", "\n", "            ", "matches", "=", "(", "dist", "[", "b", "]", "<", "dist_threshs", "[", "b", ",", "idx", "]", ")", "[", "0", ":", "ns", "[", "b", "]", "]", "\n", "match_num", "[", "idx", "]", "+=", "torch", ".", "sum", "(", "matches", ")", ".", "to", "(", "match_num", ".", "dtype", ")", "\n", "total_num", "[", "idx", "]", "+=", "ns", "[", "b", "]", ".", "to", "(", "total_num", ".", "dtype", ")", "\n", "\n", "", "", "return", "match_num", "/", "total_num", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_recall": [[58, 91], ["pmat_gt.to.to", "torch.all", "torch.all", "torch.zeros", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.sum", "torch.sum", "torch.isnan", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "matching_recall", "(", "pmat_pred", ":", "Tensor", ",", "pmat_gt", ":", "Tensor", ",", "ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Matching Recall between predicted permutation matrix and ground truth permutation matrix.\n\n    .. math::\n        \\text{matching recall} = \\frac{tr(\\mathbf{X}\\cdot {\\mathbf{X}^{gt}}^\\top)}{\\sum \\mathbf{X}^{gt}}\n\n    :param pmat_pred: :math:`(b\\times n_1 \\times n_2)` predicted permutation matrix :math:`(\\mathbf{X})`\n    :param pmat_gt: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n    :param ns: :math:`(b)` number of exact pairs. We support batched instances with different number of nodes, and\n     ``ns`` is required to specify the exact number of nodes of each instance in the batch.\n    :return: :math:`(b)` matching recall\n\n    .. note::\n        This function is equivalent to \"matching accuracy\" if the matching problem has no outliers.\n    \"\"\"", "\n", "device", "=", "pmat_pred", ".", "device", "\n", "batch_num", "=", "pmat_pred", ".", "shape", "[", "0", "]", "\n", "\n", "pmat_gt", "=", "pmat_gt", ".", "to", "(", "device", ")", "\n", "\n", "assert", "torch", ".", "all", "(", "(", "pmat_pred", "==", "0", ")", "+", "(", "pmat_pred", "==", "1", ")", ")", ",", "'pmat_pred can only contain 0/1 elements.'", "\n", "assert", "torch", ".", "all", "(", "(", "pmat_gt", "==", "0", ")", "+", "(", "pmat_gt", "==", "1", ")", ")", ",", "'pmat_gt should only contain 0/1 elements.'", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_pred", ",", "dim", "=", "-", "1", ")", "<=", "1", ")", "and", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_pred", ",", "dim", "=", "-", "2", ")", "<=", "1", ")", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_gt", ",", "dim", "=", "-", "1", ")", "<=", "1", ")", "and", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_gt", ",", "dim", "=", "-", "2", ")", "<=", "1", ")", "\n", "\n", "acc", "=", "torch", ".", "zeros", "(", "batch_num", ",", "device", "=", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "acc", "[", "b", "]", "=", "torch", ".", "sum", "(", "pmat_pred", "[", "b", ",", ":", "ns", "[", "b", "]", "]", "*", "pmat_gt", "[", "b", ",", ":", "ns", "[", "b", "]", "]", ")", "/", "torch", ".", "sum", "(", "pmat_gt", "[", "b", ",", ":", "ns", "[", "b", "]", "]", ")", "\n", "\n", "", "acc", "[", "torch", ".", "isnan", "(", "acc", ")", "]", "=", "1", "\n", "\n", "return", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_precision": [[93, 126], ["pmat_gt.to.to", "torch.all", "torch.all", "torch.zeros", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.sum", "torch.sum", "torch.isnan", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "matching_precision", "(", "pmat_pred", ":", "Tensor", ",", "pmat_gt", ":", "Tensor", ",", "ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Matching Precision between predicted permutation matrix and ground truth permutation matrix.\n\n    .. math::\n        \\text{matching precision} = \\frac{tr(\\mathbf{X}\\cdot {\\mathbf{X}^{gt}}^\\top)}{\\sum \\mathbf{X}}\n\n    :param pmat_pred: :math:`(b\\times n_1 \\times n_2)` predicted permutation matrix :math:`(\\mathbf{X})`\n    :param pmat_gt: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n    :param ns: :math:`(b)` number of exact pairs. We support batched instances with different number of nodes, and\n     ``ns`` is required to specify the exact number of nodes of each instance in the batch.\n    :return: :math:`(b)` matching precision\n\n    .. note::\n        This function is equivalent to \"matching accuracy\" if the matching problem has no outliers.\n    \"\"\"", "\n", "device", "=", "pmat_pred", ".", "device", "\n", "batch_num", "=", "pmat_pred", ".", "shape", "[", "0", "]", "\n", "\n", "pmat_gt", "=", "pmat_gt", ".", "to", "(", "device", ")", "\n", "\n", "assert", "torch", ".", "all", "(", "(", "pmat_pred", "==", "0", ")", "+", "(", "pmat_pred", "==", "1", ")", ")", ",", "'pmat_pred can only contain 0/1 elements.'", "\n", "assert", "torch", ".", "all", "(", "(", "pmat_gt", "==", "0", ")", "+", "(", "pmat_gt", "==", "1", ")", ")", ",", "'pmat_gt should only contain 0/1 elements.'", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_pred", ",", "dim", "=", "-", "1", ")", "<=", "1", ")", "and", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_pred", ",", "dim", "=", "-", "2", ")", "<=", "1", ")", "\n", "assert", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_gt", ",", "dim", "=", "-", "1", ")", "<=", "1", ")", "and", "torch", ".", "all", "(", "torch", ".", "sum", "(", "pmat_gt", ",", "dim", "=", "-", "2", ")", "<=", "1", ")", "\n", "\n", "precision", "=", "torch", ".", "zeros", "(", "batch_num", ",", "device", "=", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "precision", "[", "b", "]", "=", "torch", ".", "sum", "(", "pmat_pred", "[", "b", ",", ":", "ns", "[", "b", "]", "]", "*", "pmat_gt", "[", "b", ",", ":", "ns", "[", "b", "]", "]", ")", "/", "torch", ".", "sum", "(", "pmat_pred", "[", "b", ",", ":", "ns", "[", "b", "]", "]", ")", "\n", "\n", "", "precision", "[", "torch", ".", "isnan", "(", "precision", ")", "]", "=", "1", "\n", "\n", "return", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_accuracy": [[128, 148], ["evaluation_metric.matching_recall"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.matching_recall"], ["", "def", "matching_accuracy", "(", "pmat_pred", ":", "Tensor", ",", "pmat_gt", ":", "Tensor", ",", "ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Matching Accuracy between predicted permutation matrix and ground truth permutation matrix.\n\n    .. math::\n        \\text{matching recall} = \\frac{tr(\\mathbf{X}\\cdot {\\mathbf{X}^{gt}}^\\top)}{\\sum \\mathbf{X}^{gt}}\n\n    This function is a wrapper of ``matching_recall``.\n\n    :param pmat_pred: :math:`(b\\times n_1 \\times n_2)` predicted permutation matrix :math:`(\\mathbf{X})`\n    :param pmat_gt: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n    :param ns: :math:`(b)` number of exact pairs. We support batched instances with different number of nodes, and\n     ``ns`` is required to specify the exact number of nodes of each instance in the batch.\n    :return: :math:`(b)` matching accuracy\n\n    .. note::\n        If the graph matching problem has no outliers, it is proper to use this metric and papers call it \"matching\n        accuracy\". If there are outliers, it is better to use ``matching_precision`` and ``matching_recall``.\n    \"\"\"", "\n", "return", "matching_recall", "(", "pmat_pred", ",", "pmat_gt", ",", "ns", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_accuracy_metric": [[150, 166], ["torch.mean", "torch.std", "torch.mean", "torch.std", "torch.mean", "torch.std"], "function", ["None"], ["", "def", "format_accuracy_metric", "(", "ps", ":", "Tensor", ",", "rs", ":", "Tensor", ",", "f1s", ":", "Tensor", ")", "->", "str", ":", "\n", "    ", "r\"\"\"\n    Helper function for formatting precision, recall and f1 score metric\n\n    :param ps: tensor containing precisions\n    :param rs: tensor containing recalls\n    :param f1s: tensor containing f1 scores\n    :return: a formatted string with mean and variance of precision, recall and f1 score\n\n    Example output:\n    ::\n\n        p = 0.7837\u00b10.2799, r = 0.7837\u00b10.2799, f1 = 0.7837\u00b10.2799\n    \"\"\"", "\n", "return", "'p = {:.4f}\u00b1{:.4f}, r = {:.4f}\u00b1{:.4f}, f1 = {:.4f}\u00b1{:.4f}'", ".", "format", "(", "torch", ".", "mean", "(", "ps", ")", ",", "torch", ".", "std", "(", "ps", ")", ",", "torch", ".", "mean", "(", "rs", ")", ",", "torch", ".", "std", "(", "rs", ")", ",", "torch", ".", "mean", "(", "f1s", ")", ",", "torch", ".", "std", "(", "f1s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.format_metric": [[167, 175], ["torch.mean", "torch.std"], "function", ["None"], ["", "def", "format_metric", "(", "ms", ":", "Tensor", ")", "->", "str", ":", "\n", "    ", "r\"\"\"\n    Helping function for formatting single metric.\n\n    :param ms: tensor containing metric\n    :return: a formatted string containing mean and variance\n    \"\"\"", "\n", "return", "'{:.4f}\u00b1{:.4f}'", ".", "format", "(", "torch", ".", "mean", "(", "ms", ")", ",", "torch", ".", "std", "(", "ms", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score": [[177, 201], ["pmat_pred.transpose().contiguous().view", "torch.matmul().view", "pmat_pred.transpose().contiguous", "torch.matmul", "torch.matmul", "pmat_pred.transpose", "pmat_pred.transpose().contiguous().view.transpose"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "objective_score", "(", "pmat_pred", ":", "Tensor", ",", "affmtx", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Objective score given predicted permutation matrix and affinity matrix from the problem.\n\n    .. math::\n        \\text{objective score} = \\mathrm{vec}(\\mathbf{X})^\\top \\mathbf{K} \\mathrm{vec}(\\mathbf{X})\n\n    where :math:`\\mathrm{vec}(\\cdot)` means column-wise vectorization.\n\n    :param pmat_pred: predicted permutation matrix :math:`(\\mathbf{X})`\n    :param affmtx: affinity matrix of the quadratic assignment problem :math:`(\\mathbf{K})`\n    :return: objective scores\n\n    .. note::\n        The most general mathematical form of graph matching is known as Quadratic Assignment Problem (QAP), which is an\n        NP-hard combinatorial optimization problem. Objective score reflects the power of the graph matching/QAP solver\n        concerning the objective score of the QAP.\n    \"\"\"", "\n", "batch_num", "=", "pmat_pred", ".", "shape", "[", "0", "]", "\n", "\n", "p_vec", "=", "pmat_pred", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "batch_num", ",", "-", "1", ",", "1", ")", "\n", "obj_score", "=", "torch", ".", "matmul", "(", "torch", ".", "matmul", "(", "p_vec", ".", "transpose", "(", "1", ",", "2", ")", ",", "affmtx", ")", ",", "p_vec", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "return", "obj_score", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.clustering_accuracy": [[202, 262], ["range", "torch.tensor().to", "torch.zeros", "range", "list", "gt_classes_t.append", "range", "range", "range", "torch.max", "set", "len", "len", "gt_classes_t[].append", "torch.tensor", "itertools.combinations", "itertools.combinations", "list.index", "range", "range", "num_clusters[].to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "clustering_accuracy", "(", "pred_clusters", ":", "Tensor", ",", "gt_classes", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Clustering accuracy for clusters.\n\n    :math:`\\mathcal{A}, \\mathcal{B}, ...` are ground truth classes and :math:`\\mathcal{A}^\\prime, \\mathcal{B}^\\prime,\n    ...` are predicted classes and :math:`k` is the number of classes:\n\n    .. math::\n        \\text{clustering accuracy} = 1 - \\frac{1}{k} \\left(\\sum_{\\mathcal{A}} \\sum_{\\mathcal{A}^\\prime \\neq \\mathcal{B}^\\prime}\n         \\frac{|\\mathcal{A}^\\prime \\cap \\mathcal{A}| |\\mathcal{B}^\\prime \\cap \\mathcal{A}|}{|\\mathcal{A}| |\\mathcal{A}|} +\n         \\sum_{\\mathcal{A}^\\prime} \\sum_{\\mathcal{A} \\neq \\mathcal{B}}\n         \\frac{|\\mathcal{A}^\\prime \\cap \\mathcal{A}| |\\mathcal{A}^\\prime \\cap \\mathcal{B}|}{|\\mathcal{A}| |\\mathcal{B}|} \\right)\n\n    This metric is proposed by `\"Wang et al. Clustering-aware Multiple Graph Matching via Decayed Pairwise Matching\n    Composition. AAAI 2020.\" <https://ojs.aaai.org/index.php/AAAI/article/view/5528/5384>`_\n\n    :param pred_clusters: :math:`(b\\times n)` predicted clusters. :math:`n`: number of instances.\n        ::\n\n            e.g. [[0,0,1,2,1,2]\n                  [0,1,2,2,1,0]]\n    :param gt_classes: :math:`(b\\times n)` ground truth classes\n        ::\n\n            e.g. [['car','car','bike','bike','person','person'],\n                  ['bus','bus','cat', 'sofa',  'cat',  'sofa' ]]\n    :return: :math:`(b)` clustering accuracy\n    \"\"\"", "\n", "num_clusters", "=", "torch", ".", "max", "(", "pred_clusters", ",", "dim", "=", "-", "1", ")", ".", "values", "+", "1", "\n", "batch_num", "=", "pred_clusters", ".", "shape", "[", "0", "]", "\n", "\n", "gt_classes_t", "=", "[", "]", "\n", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "gt_classes_b_set", "=", "list", "(", "set", "(", "gt_classes", "[", "b", "]", ")", ")", "\n", "gt_classes_t", ".", "append", "(", "[", "]", ")", "\n", "assert", "len", "(", "gt_classes_b_set", ")", "==", "num_clusters", "[", "b", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_classes", "[", "b", "]", ")", ")", ":", "\n", "            ", "gt_classes_t", "[", "b", "]", ".", "append", "(", "gt_classes_b_set", ".", "index", "(", "gt_classes", "[", "b", "]", "[", "i", "]", ")", ")", "\n", "", "", "gt_clusters", "=", "torch", ".", "tensor", "(", "gt_classes_t", ")", ".", "to", "(", "dtype", "=", "pred_clusters", ".", "dtype", ",", "device", "=", "pred_clusters", ".", "device", ")", "\n", "\n", "cluster_acc", "=", "torch", ".", "zeros", "(", "batch_num", ",", "device", "=", "pred_clusters", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "sum", "=", "0", "\n", "for", "i", "in", "range", "(", "num_clusters", "[", "b", "]", ")", ":", "\n", "            ", "for", "j", ",", "k", "in", "combinations", "(", "range", "(", "num_clusters", "[", "b", "]", ")", ",", "2", ")", ":", "\n", "                ", "pred_i", "=", "(", "pred_clusters", "[", "b", "]", "==", "i", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "gt_j", "=", "(", "gt_clusters", "[", "b", "]", "==", "j", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "gt_k", "=", "(", "gt_clusters", "[", "b", "]", "==", "k", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "sum", "+=", "(", "torch", ".", "sum", "(", "pred_i", "*", "gt_j", ")", "*", "torch", ".", "sum", "(", "pred_i", "*", "gt_k", ")", ")", "/", "torch", ".", "sum", "(", "pred_i", ")", "**", "2", "\n", "", "", "for", "i", "in", "range", "(", "num_clusters", "[", "b", "]", ")", ":", "\n", "            ", "for", "j", ",", "k", "in", "combinations", "(", "range", "(", "num_clusters", "[", "b", "]", ")", ",", "2", ")", ":", "\n", "                ", "gt_i", "=", "(", "gt_clusters", "[", "b", "]", "==", "i", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "pred_j", "=", "(", "pred_clusters", "[", "b", "]", "==", "j", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "pred_k", "=", "(", "pred_clusters", "[", "b", "]", "==", "k", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "sum", "+=", "(", "torch", ".", "sum", "(", "gt_i", "*", "pred_j", ")", "*", "torch", ".", "sum", "(", "gt_i", "*", "pred_k", ")", ")", "/", "(", "torch", ".", "sum", "(", "pred_j", ")", "*", "torch", ".", "sum", "(", "pred_k", ")", ")", "\n", "\n", "", "", "cluster_acc", "[", "b", "]", "=", "1", "-", "sum", "/", "num_clusters", "[", "b", "]", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "", "return", "cluster_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.clustering_purity": [[263, 304], ["range", "torch.tensor().to", "torch.zeros", "range", "list", "gt_classes_t.append", "range", "range", "torch.max", "set", "len", "len", "gt_classes_t[].append", "torch.tensor", "torch.max().to", "list.index", "torch.max", "torch.unique"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "clustering_purity", "(", "pred_clusters", ":", "Tensor", ",", "gt_classes", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Clustering purity for clusters.\n\n    :math:`n` is the number of instances,\n    :math:`\\mathcal{C}_i` represent the predicted class :math:`i` and :math:`\\mathcal{C}^{gt}_j` is ground truth class :math:`j`:\n\n    .. math::\n        \\text{clustering purity} = \\frac{1}{n} \\sum_{i=1}^{k} \\max_{j\\in\\{1,...,k\\}} |\\mathcal{C}_i \\cap \\mathcal{C}^{gt}_{j}|\n\n    :param pred_clusters: :math:`(b\\times n)` predicted clusters. :math:`n`: number of instances.\n        ::\n\n            e.g. [[0,0,1,2,1,2]\n                  [0,1,2,2,1,0]]\n    :param gt_classes: :math:`(b\\times n)` ground truth classes\n        ::\n\n            e.g. [['car','car','bike','bike','person','person'],\n                  ['bus','bus','cat', 'sofa',  'cat',  'sofa' ]]\n    :return: :math:`(b)` clustering purity\n    \"\"\"", "\n", "num_clusters", "=", "torch", ".", "max", "(", "pred_clusters", ",", "dim", "=", "-", "1", ")", ".", "values", "+", "1", "\n", "num_instances", "=", "pred_clusters", ".", "shape", "[", "1", "]", "\n", "batch_num", "=", "pred_clusters", ".", "shape", "[", "0", "]", "\n", "gt_classes_t", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "gt_classes_b_set", "=", "list", "(", "set", "(", "gt_classes", "[", "b", "]", ")", ")", "\n", "gt_classes_t", ".", "append", "(", "[", "]", ")", "\n", "assert", "len", "(", "gt_classes_b_set", ")", "==", "num_clusters", "[", "b", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_classes", "[", "b", "]", ")", ")", ":", "\n", "            ", "gt_classes_t", "[", "b", "]", ".", "append", "(", "gt_classes_b_set", ".", "index", "(", "gt_classes", "[", "b", "]", "[", "i", "]", ")", ")", "\n", "", "", "gt_clusters", "=", "torch", ".", "tensor", "(", "gt_classes_t", ")", ".", "to", "(", "dtype", "=", "pred_clusters", ".", "dtype", ",", "device", "=", "pred_clusters", ".", "device", ")", "\n", "\n", "cluster_purity", "=", "torch", ".", "zeros", "(", "batch_num", ",", "device", "=", "pred_clusters", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_clusters", "[", "b", "]", ")", ":", "\n", "            ", "max_counts", "=", "torch", ".", "max", "(", "torch", ".", "unique", "(", "gt_clusters", "[", "b", "]", "[", "pred_clusters", "[", "b", "]", "==", "i", "]", ",", "return_counts", "=", "True", ")", "[", "-", "1", "]", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "cluster_purity", "[", "b", "]", "+=", "max_counts", "/", "num_instances", "\n", "\n", "", "", "return", "cluster_purity", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.rand_index": [[306, 345], ["range", "torch.tensor().to", "torch.logical_xor().to", "list", "gt_classes_t.append", "range", "pred_clusters.unsqueeze", "pred_clusters.unsqueeze", "torch.tensor().to.unsqueeze", "torch.tensor().to.unsqueeze", "torch.max", "set", "len", "len", "gt_classes_t[].append", "torch.tensor", "torch.logical_xor", "torch.sum", "list.index"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "rand_index", "(", "pred_clusters", ":", "Tensor", ",", "gt_classes", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Rand index measurement for clusters.\n\n    Rand index is computed by the number of instances predicted in the same class with the same label :math:`n_{11}` and\n    the number of instances predicted in separate classes and with different labels :math:`n_{00}`, normalized by the total\n    number of instances pairs :math:`n(n-1)`:\n\n    .. math::\n        \\text{rand index} = \\frac{n_{11} + n_{00}}{n(n-1)}\n\n    :param pred_clusters: :math:`(b\\times n)` predicted clusters. :math:`n`: number of instances.\n        ::\n\n            e.g. [[0,0,1,2,1,2]\n                  [0,1,2,2,1,0]]\n    :param gt_classes: :math:`(b\\times n)` ground truth classes\n        ::\n\n            e.g. [['car','car','bike','bike','person','person'],\n                  ['bus','bus','cat', 'sofa',  'cat',  'sofa' ]]\n    :return: :math:`(b)` clustering purity\n    \"\"\"", "\n", "num_clusters", "=", "torch", ".", "max", "(", "pred_clusters", ",", "dim", "=", "-", "1", ")", ".", "values", "+", "1", "\n", "num_instances", "=", "pred_clusters", ".", "shape", "[", "1", "]", "\n", "batch_num", "=", "pred_clusters", ".", "shape", "[", "0", "]", "\n", "gt_classes_t", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "gt_classes_b_set", "=", "list", "(", "set", "(", "gt_classes", "[", "b", "]", ")", ")", "\n", "gt_classes_t", ".", "append", "(", "[", "]", ")", "\n", "assert", "len", "(", "gt_classes_b_set", ")", "==", "num_clusters", "[", "b", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_classes", "[", "b", "]", ")", ")", ":", "\n", "            ", "gt_classes_t", "[", "b", "]", ".", "append", "(", "gt_classes_b_set", ".", "index", "(", "gt_classes", "[", "b", "]", "[", "i", "]", ")", ")", "\n", "", "", "gt_clusters", "=", "torch", ".", "tensor", "(", "gt_classes_t", ")", ".", "to", "(", "dtype", "=", "pred_clusters", ".", "dtype", ",", "device", "=", "pred_clusters", ".", "device", ")", "\n", "pred_pairs", "=", "pred_clusters", ".", "unsqueeze", "(", "-", "1", ")", "==", "pred_clusters", ".", "unsqueeze", "(", "-", "2", ")", "\n", "gt_pairs", "=", "gt_clusters", ".", "unsqueeze", "(", "-", "1", ")", "==", "gt_clusters", ".", "unsqueeze", "(", "-", "2", ")", "\n", "unmatched_pairs", "=", "torch", ".", "logical_xor", "(", "pred_pairs", ",", "gt_pairs", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", "\n", "rand_index", "=", "1", "-", "torch", ".", "sum", "(", "unmatched_pairs", ",", "dim", "=", "(", "-", "1", ",", "-", "2", ")", ")", "/", "(", "num_instances", "*", "(", "num_instances", "-", "1", ")", ")", "\n", "return", "rand_index", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align": [[5, 38], ["torch.tensor", "torch.zeros", "enumerate", "torch.as_tensor", "feature_align.interp_2d"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.interp_2d"], ["def", "feature_align", "(", "raw_feature", ":", "Tensor", ",", "P", ":", "Tensor", ",", "ns_t", ":", "Tensor", ",", "ori_size", ":", "tuple", ",", "device", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Perform feature align on the image feature map.\n\n    Feature align performs bi-linear interpolation on the image feature map. This operation is inspired by \"ROIAlign\"\n    in `Mask R-CNN <https://arxiv.org/abs/1703.06870>`_.\n\n    :param raw_feature: :math:`(b\\times c \\times w \\times h)` raw feature map. :math:`b`: batch size, :math:`c`: number\n     of feature channels, :math:`w`: feature map width, :math:`h`: feature map height\n    :param P: :math:`(b\\times n \\times 2)` point set containing point coordinates. The coordinates are at the scale of\n     the original image size. :math:`n`: number of points\n    :param ns_t: :math:`(b)` number of exact points. We support batched instances with different number of nodes, and\n     ``ns_t`` is required to specify the exact number of nodes of each instance in the batch.\n    :param ori_size: size of the original image. Since the point coordinates are in the scale of the original image\n     size, this parameter is required.\n    :param device: output device. If not specified, it will be the same as the input\n    :return: :math:`(b\\times c \\times n)` extracted feature vectors\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "raw_feature", ".", "device", "\n", "\n", "", "batch_num", "=", "raw_feature", ".", "shape", "[", "0", "]", "\n", "channel_num", "=", "raw_feature", ".", "shape", "[", "1", "]", "\n", "n_max", "=", "P", ".", "shape", "[", "1", "]", "\n", "\n", "ori_size", "=", "torch", ".", "tensor", "(", "ori_size", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "F", "=", "torch", ".", "zeros", "(", "batch_num", ",", "channel_num", ",", "n_max", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "for", "idx", ",", "feature", "in", "enumerate", "(", "raw_feature", ")", ":", "\n", "        ", "n", "=", "ns_t", "[", "idx", "]", "\n", "feat_size", "=", "torch", ".", "as_tensor", "(", "feature", ".", "shape", "[", "1", ":", "3", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "_P", "=", "P", "[", "idx", ",", "0", ":", "n", "]", "\n", "interp_2d", "(", "feature", ",", "_P", ",", "ori_size", ",", "feat_size", ",", "out", "=", "F", "[", "idx", ",", ":", ",", "0", ":", "n", "]", ")", "\n", "", "return", "F", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.interp_2d": [[40, 65], ["enumerate", "torch.zeros", "feature_align.bilinear_interpolate"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.bilinear_interpolate"], ["", "def", "interp_2d", "(", "z", ":", "Tensor", ",", "P", ":", "Tensor", ",", "ori_size", ":", "Tensor", ",", "feat_size", ":", "Tensor", ",", "out", "=", "None", ",", "device", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Interpolate in 2d grid space. z can be 3-dimensional where the first dimension is feature dimension.\n\n    :param z: :math:`(c\\times w\\times h)` feature map. :math:`c`: number of feature channels, :math:`w`: feature map\n     width, :math:`h`: feature map height\n    :param P: :math:`(n\\times 2)` point set containing point coordinates. The coordinates are at the scale of\n     the original image size. :math:`n`: number of points\n    :param ori_size: :math:`(2)` size of the original image\n    :param feat_size: :math:`(2)` size of the feature map\n    :param out: optional output tensor\n    :param device: output device. If not specified, it will be the same as the input\n    :return: :math:`(c \\times n)` extracted feature vectors\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "z", ".", "device", "\n", "\n", "", "step", "=", "ori_size", "/", "feat_size", "\n", "if", "out", "is", "None", ":", "\n", "        ", "out", "=", "torch", ".", "zeros", "(", "z", ".", "shape", "[", "0", "]", ",", "P", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "", "for", "i", ",", "p", "in", "enumerate", "(", "P", ")", ":", "\n", "        ", "p", "=", "(", "p", "-", "step", "/", "2", ")", "/", "ori_size", "*", "feat_size", "\n", "out", "[", ":", ",", "i", "]", "=", "bilinear_interpolate", "(", "z", ",", "p", "[", "0", "]", ",", "p", "[", "1", "]", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.bilinear_interpolate": [[67, 127], ["x.to().to.to().to", "y.to().to.to().to", "torch.floor", "torch.floor", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "x0.to().to.to().to", "x1.to().to.to().to", "y0.to().to.to().to", "y1.to().to.to().to", "x0.to().to.to().to", "x1.to().to.to().to", "y0.to().to.to().to", "y1.to().to.to().to", "x.to().to.to", "y.to().to.to", "x0.to().to.to", "x1.to().to.to", "y0.to().to.to", "y1.to().to.to", "x0.to().to.to", "x1.to().to.to", "y0.to().to.to", "y1.to().to.to"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "bilinear_interpolate", "(", "im", ":", "Tensor", ",", "x", ":", "Tensor", ",", "y", ":", "Tensor", ",", "device", "=", "None", ")", ":", "\n", "    ", "r\"\"\"\n    Bi-linear interpolate 3d feature map to 2d coordinate (x, y).\n    The coordinates are at the same scale of :math:`w\\times h`.\n\n    :param im: :math:`(c\\times w\\times h)` feature map\n    :param x: :math:`(1)` x coordinate\n    :param y: :math:`(1)` y coordinate\n    :param device: output device. If not specified, it will be the same as the input\n    :return: :math:`(c)` interpolated feature vector\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "im", ".", "device", "\n", "", "x", "=", "x", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "y", "=", "y", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "\n", "x0", "=", "torch", ".", "floor", "(", "x", ")", "\n", "x1", "=", "x0", "+", "1", "\n", "y0", "=", "torch", ".", "floor", "(", "y", ")", "\n", "y1", "=", "y0", "+", "1", "\n", "\n", "x0", "=", "torch", ".", "clamp", "(", "x0", ",", "0", ",", "im", ".", "shape", "[", "2", "]", "-", "1", ")", "\n", "x1", "=", "torch", ".", "clamp", "(", "x1", ",", "0", ",", "im", ".", "shape", "[", "2", "]", "-", "1", ")", "\n", "y0", "=", "torch", ".", "clamp", "(", "y0", ",", "0", ",", "im", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "y1", "=", "torch", ".", "clamp", "(", "y1", ",", "0", ",", "im", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "\n", "x0", "=", "x0", ".", "to", "(", "torch", ".", "int32", ")", ".", "to", "(", "device", ")", "\n", "x1", "=", "x1", ".", "to", "(", "torch", ".", "int32", ")", ".", "to", "(", "device", ")", "\n", "y0", "=", "y0", ".", "to", "(", "torch", ".", "int32", ")", ".", "to", "(", "device", ")", "\n", "y1", "=", "y1", ".", "to", "(", "torch", ".", "int32", ")", ".", "to", "(", "device", ")", "\n", "\n", "Ia", "=", "im", "[", ":", ",", "y0", ",", "x0", "]", "\n", "Ib", "=", "im", "[", ":", ",", "y1", ",", "x0", "]", "\n", "Ic", "=", "im", "[", ":", ",", "y0", ",", "x1", "]", "\n", "Id", "=", "im", "[", ":", ",", "y1", ",", "x1", "]", "\n", "\n", "# to perform nearest neighbor interpolation if out of bounds", "\n", "if", "x0", "==", "x1", ":", "\n", "        ", "if", "x0", "==", "0", ":", "\n", "            ", "x0", "-=", "1", "\n", "", "else", ":", "\n", "            ", "x1", "+=", "1", "\n", "", "", "if", "y0", "==", "y1", ":", "\n", "        ", "if", "y0", "==", "0", ":", "\n", "            ", "y0", "-=", "1", "\n", "", "else", ":", "\n", "            ", "y1", "+=", "1", "\n", "\n", "", "", "x0", "=", "x0", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "x1", "=", "x1", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "y0", "=", "y0", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "y1", "=", "y1", ".", "to", "(", "torch", ".", "float32", ")", ".", "to", "(", "device", ")", "\n", "\n", "wa", "=", "(", "x1", "-", "x", ")", "*", "(", "y1", "-", "y", ")", "\n", "wb", "=", "(", "x1", "-", "x", ")", "*", "(", "y", "-", "y0", ")", "\n", "wc", "=", "(", "x", "-", "x0", ")", "*", "(", "y1", "-", "y", ")", "\n", "wd", "=", "(", "x", "-", "x0", ")", "*", "(", "y", "-", "y0", ")", "\n", "\n", "out", "=", "Ia", "*", "wa", "+", "Ib", "*", "wb", "+", "Ic", "*", "wc", "+", "Id", "*", "wd", "\n", "return", "out", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.build_graphs": [[12, 75], ["int", "numpy.zeros", "numpy.zeros", "range", "build_graphs.delaunay_triangulate", "numpy.sum", "build_graphs.fully_connect", "build_graphs.fully_connect", "range", "range"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.delaunay_triangulate", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.fully_connect", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.fully_connect"], ["def", "build_graphs", "(", "P_np", ":", "np", ".", "ndarray", ",", "n", ":", "int", ",", "n_pad", ":", "int", "=", "None", ",", "edge_pad", ":", "int", "=", "None", ",", "stg", ":", "str", "=", "'fc'", ",", "sym", ":", "bool", "=", "True", ",", "\n", "thre", ":", "int", "=", "0", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "int", "]", ":", "\n", "    ", "r\"\"\"\n    Build graph matrix :math:`\\mathbf G, \\mathbf H` from point set :math:`\\mathbf P`.\n    This function supports only cpu operations in numpy.\n    :math:`\\mathbf G, \\mathbf H` are constructed from adjacency matrix :math:`\\mathbf A`:\n    :math:`\\mathbf A = \\mathbf G \\cdot \\mathbf H^\\top`\n\n    :param P_np: :math:`(n\\times 2)` point set containing point coordinates\n    :param n: number of exact points in the point set\n    :param n_pad: padded node length\n    :param edge_pad: padded edge length\n    :param stg: strategy to build graphs. Options: ``fc``, ``near``, ``tri``\n    :param sym: True for a symmetric adjacency, False for half adjacency (A contains only the upper half)\n    :param thre: The threshold value of 'near' strategy\n    :return: :math:`A`, :math:`G`, :math:`H`, edge_num\n\n    The possible options for ``stg``:\n    ::\n\n        'fc'(default): construct a fully-connected graph\n        'near': construct a fully-connected graph, but edges longer than ``thre`` are removed\n        'tri': apply Delaunay triangulation\n\n    An illustration of :math:`\\mathbf G, \\mathbf H` with their connections to the graph, the adjacency matrix,\n    the incident matrix is\n\n    .. image:: ../../images/build_graphs_GH.png\n    \"\"\"", "\n", "\n", "assert", "stg", "in", "(", "'fc'", ",", "'tri'", ",", "'near'", ")", ",", "'No strategy named {} found.'", ".", "format", "(", "stg", ")", "\n", "\n", "if", "stg", "==", "'tri'", ":", "\n", "        ", "A", "=", "delaunay_triangulate", "(", "P_np", "[", "0", ":", "n", ",", ":", "]", ")", "\n", "", "elif", "stg", "==", "'near'", ":", "\n", "        ", "A", "=", "fully_connect", "(", "P_np", "[", "0", ":", "n", ",", ":", "]", ",", "thre", "=", "thre", ")", "\n", "", "else", ":", "\n", "        ", "A", "=", "fully_connect", "(", "P_np", "[", "0", ":", "n", ",", ":", "]", ")", "\n", "", "edge_num", "=", "int", "(", "np", ".", "sum", "(", "A", ",", "axis", "=", "(", "0", ",", "1", ")", ")", ")", "\n", "assert", "n", ">", "0", "and", "edge_num", ">", "0", ",", "'Error in n = {} and edge_num = {}'", ".", "format", "(", "n", ",", "edge_num", ")", "\n", "\n", "if", "n_pad", "is", "None", ":", "\n", "        ", "n_pad", "=", "n", "\n", "", "if", "edge_pad", "is", "None", ":", "\n", "        ", "edge_pad", "=", "edge_num", "\n", "", "assert", "n_pad", ">=", "n", "\n", "assert", "edge_pad", ">=", "edge_num", "\n", "\n", "G", "=", "np", ".", "zeros", "(", "(", "n_pad", ",", "edge_pad", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "H", "=", "np", ".", "zeros", "(", "(", "n_pad", ",", "edge_pad", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "edge_idx", "=", "0", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "sym", ":", "\n", "            ", "range_j", "=", "range", "(", "n", ")", "\n", "", "else", ":", "\n", "            ", "range_j", "=", "range", "(", "i", ",", "n", ")", "\n", "", "for", "j", "in", "range_j", ":", "\n", "            ", "if", "A", "[", "i", ",", "j", "]", "==", "1", ":", "\n", "                ", "G", "[", "i", ",", "edge_idx", "]", "=", "1", "\n", "H", "[", "j", ",", "edge_idx", "]", "=", "1", "\n", "edge_idx", "+=", "1", "\n", "\n", "", "", "", "return", "A", ",", "G", ",", "H", ",", "edge_num", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.delaunay_triangulate": [[77, 101], ["build_graphs.fully_connect", "scipy.spatial.Delaunay", "numpy.zeros", "itertools.permutations", "print", "print", "print", "build_graphs.fully_connect"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.fully_connect", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.fully_connect"], ["", "def", "delaunay_triangulate", "(", "P", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "r\"\"\"\n    Perform delaunay triangulation on point set P.\n\n    :param P: :math:`(n\\times 2)` point set\n    :return: adjacency matrix :math:`A`\n    \"\"\"", "\n", "n", "=", "P", ".", "shape", "[", "0", "]", "\n", "if", "n", "<", "3", ":", "\n", "        ", "A", "=", "fully_connect", "(", "P", ")", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "d", "=", "Delaunay", "(", "P", ")", "\n", "#assert d.coplanar.size == 0, 'Delaunay triangulation omits points.'", "\n", "A", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "\n", "for", "simplex", "in", "d", ".", "simplices", ":", "\n", "                ", "for", "pair", "in", "itertools", ".", "permutations", "(", "simplex", ",", "2", ")", ":", "\n", "                    ", "A", "[", "pair", "]", "=", "1", "\n", "", "", "", "except", "QhullError", "as", "err", ":", "\n", "            ", "print", "(", "'Delaunay triangulation error detected. Return fully-connected graph.'", ")", "\n", "print", "(", "'Traceback:'", ")", "\n", "print", "(", "err", ")", "\n", "A", "=", "fully_connect", "(", "P", ")", "\n", "", "", "return", "A", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.fully_connect": [[103, 120], ["numpy.ones", "numpy.eye", "range", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "fully_connect", "(", "P", ":", "np", ".", "ndarray", ",", "thre", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "r\"\"\"\n    Return the adjacency matrix of a fully-connected graph.\n\n    :param P: :math:`(n\\times 2)` point set\n    :param thre: edges that are longer than this threshold will be removed\n    :return: adjacency matrix :math:`A`\n    \"\"\"", "\n", "n", "=", "P", ".", "shape", "[", "0", "]", "\n", "A", "=", "np", ".", "ones", "(", "(", "n", ",", "n", ")", ")", "-", "np", ".", "eye", "(", "n", ")", "\n", "if", "thre", "is", "not", "None", ":", "\n", "        ", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "                ", "if", "np", ".", "linalg", ".", "norm", "(", "P", "[", "i", "]", "-", "P", "[", "j", "]", ")", ">", "thre", ":", "\n", "                    ", "A", "[", "i", ",", "j", "]", "=", "0", "\n", "A", "[", "j", ",", "i", "]", "=", "0", "\n", "", "", "", "", "return", "A", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.make_grids": [[122, 142], ["numpy.prod", "numpy.zeros", "enumerate", "len", "len", "len", "zip", "numpy.linspace", "numpy.reshape", "len", "numpy.repeat"], "function", ["None"], ["", "def", "make_grids", "(", "start", ",", "stop", ",", "num", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "r\"\"\"\n    Make grids.\n\n    This function supports only cpu operations in numpy.\n\n    :param start: start index in all dimensions\n    :param stop: stop index in all dimensions\n    :param num: number of grids in each dimension\n    :return: point set P\n    \"\"\"", "\n", "length", "=", "np", ".", "prod", "(", "num", ")", "\n", "P", "=", "np", ".", "zeros", "(", "(", "length", ",", "len", "(", "num", ")", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "assert", "len", "(", "start", ")", "==", "len", "(", "stop", ")", "==", "len", "(", "num", ")", "\n", "for", "i", ",", "(", "begin", ",", "end", ",", "n", ")", "in", "enumerate", "(", "zip", "(", "start", ",", "stop", ",", "num", ")", ")", ":", "\n", "        ", "g", "=", "np", ".", "linspace", "(", "begin", ",", "end", ",", "n", "+", "1", ")", "\n", "g", "-=", "(", "g", "[", "1", "]", "-", "g", "[", "0", "]", ")", "/", "2", "\n", "g", "=", "g", "[", "1", ":", "]", "\n", "P", "[", ":", ",", "i", "]", "=", "np", ".", "reshape", "(", "np", ".", "repeat", "(", "[", "g", "]", ",", "length", "/", "n", ",", "axis", "=", "i", ")", ",", "length", ")", "\n", "", "return", "P", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature": [[144, 172], ["torch.zeros", "torch.matmul", "torch.matmul"], "function", ["None"], ["", "def", "reshape_edge_feature", "(", "F", ":", "Tensor", ",", "G", ":", "Tensor", ",", "H", ":", "Tensor", ",", "device", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Given point-level features extracted from images, reshape it into edge feature matrix :math:`X`,\n    where features are arranged by the order of :math:`G`, :math:`H`.\n\n    .. math::\n        \\mathbf{X}_{e_{ij}} = concat(\\mathbf{F}_i, \\mathbf{F}_j)\n\n    where :math:`e_{ij}` means an edge connecting nodes :math:`i, j`\n\n    :param F: :math:`(b\\times d \\times n)` extracted point-level feature matrix.\n     :math:`b`: batch size. :math:`d`: feature dimension. :math:`n`: number of nodes.\n    :param G: :math:`(b\\times n \\times e)` factorized adjacency matrix, where :math:`\\mathbf A = \\mathbf G \\cdot \\mathbf H^\\top`. :math:`e`: number of edges.\n    :param H: :math:`(b\\times n \\times e)` factorized adjacency matrix, where :math:`\\mathbf A = \\mathbf G \\cdot \\mathbf H^\\top`\n    :param device: device. If not specified, it will be the same as the input\n    :return: edge feature matrix X :math:`(b \\times 2d \\times e)`\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "F", ".", "device", "\n", "\n", "", "batch_num", "=", "F", ".", "shape", "[", "0", "]", "\n", "feat_dim", "=", "F", ".", "shape", "[", "1", "]", "\n", "point_num", ",", "edge_num", "=", "G", ".", "shape", "[", "1", ":", "3", "]", "\n", "X", "=", "torch", ".", "zeros", "(", "batch_num", ",", "2", "*", "feat_dim", ",", "edge_num", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", ")", "\n", "X", "[", ":", ",", "0", ":", "feat_dim", ",", ":", "]", "=", "torch", ".", "matmul", "(", "F", ",", "G", ")", "\n", "X", "[", ":", ",", "feat_dim", ":", "2", "*", "feat_dim", ",", ":", "]", "=", "torch", ".", "matmul", "(", "F", ",", "H", ")", "\n", "\n", "return", "X", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.PermutationLoss.__init__": [[23, 25], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "PermutationLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.PermutationLoss.forward": [[26, 60], ["pred_dsmat.to.to.to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "src_ns[].to().to", "print", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "slice", "slice", "src_ns[].to"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "forward", "(", "self", ",", "pred_dsmat", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ",", "src_ns", ":", "Tensor", ",", "tgt_ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_dsmat: :math:`(b\\times n_1 \\times n_2)` predicted doubly-stochastic matrix :math:`(\\mathbf{S})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :param src_ns: :math:`(b)` number of exact pairs in the first graph (also known as source graph).\n        :param tgt_ns: :math:`(b)` number of exact pairs in the second graph (also known as target graph).\n        :return: :math:`(1)` averaged permutation loss\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``src_ns`` and ``tgt_ns`` are\n            required to specify the exact number of nodes of each instance in the batch.\n        \"\"\"", "\n", "batch_num", "=", "pred_dsmat", ".", "shape", "[", "0", "]", "\n", "\n", "pred_dsmat", "=", "pred_dsmat", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "torch", ".", "all", "(", "(", "pred_dsmat", ">=", "0", ")", "*", "(", "pred_dsmat", "<=", "1", ")", ")", "\n", "assert", "torch", ".", "all", "(", "(", "gt_perm", ">=", "0", ")", "*", "(", "gt_perm", "<=", "1", ")", ")", "\n", "", "except", "AssertionError", "as", "err", ":", "\n", "            ", "print", "(", "pred_dsmat", ")", "\n", "raise", "err", "\n", "\n", "", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "n_sum", "=", "torch", ".", "zeros_like", "(", "loss", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "batch_slice", "=", "[", "b", ",", "slice", "(", "src_ns", "[", "b", "]", ")", ",", "slice", "(", "tgt_ns", "[", "b", "]", ")", "]", "\n", "loss", "+=", "F", ".", "binary_cross_entropy", "(", "\n", "pred_dsmat", "[", "batch_slice", "]", ",", "\n", "gt_perm", "[", "batch_slice", "]", ",", "\n", "reduction", "=", "'sum'", ")", "\n", "n_sum", "+=", "src_ns", "[", "b", "]", ".", "to", "(", "n_sum", ".", "dtype", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "\n", "", "return", "loss", "/", "n_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.CrossEntropyLoss.__init__": [[74, 76], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "CrossEntropyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.CrossEntropyLoss.forward": [[77, 112], ["pred_dsmat.to.to.to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss", "src_ns[].to().to", "print", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "slice", "slice", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "src_ns[].to"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "forward", "(", "self", ",", "pred_dsmat", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ",", "src_ns", ":", "Tensor", ",", "tgt_ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_dsmat: :math:`(b\\times n_1 \\times n_2)` predicted doubly-stochastic matrix :math:`(\\mathbf{S})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :param src_ns: :math:`(b)` number of exact pairs in the first graph (also known as source graph).\n        :param tgt_ns: :math:`(b)` number of exact pairs in the second graph (also known as target graph).\n        :return: :math:`(1)` averaged cross-entropy loss\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``src_ns`` and ``tgt_ns`` are\n            required to specify the exact number of nodes of each instance in the batch.\n        \"\"\"", "\n", "batch_num", "=", "pred_dsmat", ".", "shape", "[", "0", "]", "\n", "\n", "pred_dsmat", "=", "pred_dsmat", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "torch", ".", "all", "(", "(", "pred_dsmat", ">=", "0", ")", "*", "(", "pred_dsmat", "<=", "1", ")", ")", "\n", "assert", "torch", ".", "all", "(", "(", "gt_perm", ">=", "0", ")", "*", "(", "gt_perm", "<=", "1", ")", ")", "\n", "", "except", "AssertionError", "as", "err", ":", "\n", "            ", "print", "(", "pred_dsmat", ")", "\n", "raise", "err", "\n", "\n", "", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "n_sum", "=", "torch", ".", "zeros_like", "(", "loss", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "batch_slice", "=", "[", "b", ",", "slice", "(", "src_ns", "[", "b", "]", ")", ",", "slice", "(", "tgt_ns", "[", "b", "]", ")", "]", "\n", "gt_index", "=", "torch", ".", "max", "(", "gt_perm", "[", "batch_slice", "]", ",", "dim", "=", "-", "1", ")", ".", "indices", "\n", "loss", "+=", "F", ".", "nll_loss", "(", "\n", "torch", ".", "log", "(", "pred_dsmat", "[", "batch_slice", "]", ")", ",", "\n", "gt_index", ",", "\n", "reduction", "=", "'sum'", ")", "\n", "n_sum", "+=", "src_ns", "[", "b", "]", ".", "to", "(", "n_sum", ".", "dtype", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "\n", "", "return", "loss", "/", "n_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.PermutationLossHung.__init__": [[138, 140], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "PermutationLossHung", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.PermutationLossHung.forward": [[141, 172], ["torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "src.lap_solvers.hungarian.hungarian", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "src_ns[].to().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "src_ns[].to"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "forward", "(", "self", ",", "pred_dsmat", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ",", "src_ns", ":", "Tensor", ",", "tgt_ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_dsmat: :math:`(b\\times n_1 \\times n_2)` predicted doubly-stochastic matrix :math:`(\\mathbf{S})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :param src_ns: :math:`(b)` number of exact pairs in the first graph (also known as source graph).\n        :param tgt_ns: :math:`(b)` number of exact pairs in the second graph (also known as target graph).\n        :return: :math:`(1)` averaged permutation loss\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``src_ns`` and ``tgt_ns`` are\n            required to specify the exact number of nodes of each instance in the batch.\n        \"\"\"", "\n", "batch_num", "=", "pred_dsmat", ".", "shape", "[", "0", "]", "\n", "\n", "assert", "torch", ".", "all", "(", "(", "pred_dsmat", ">=", "0", ")", "*", "(", "pred_dsmat", "<=", "1", ")", ")", "\n", "assert", "torch", ".", "all", "(", "(", "gt_perm", ">=", "0", ")", "*", "(", "gt_perm", "<=", "1", ")", ")", "\n", "\n", "dis_pred", "=", "hungarian", "(", "pred_dsmat", ",", "src_ns", ",", "tgt_ns", ")", "\n", "ali_perm", "=", "dis_pred", "+", "gt_perm", "\n", "ali_perm", "[", "ali_perm", ">", "1.0", "]", "=", "1.0", "# Hung", "\n", "pred_dsmat", "=", "torch", ".", "mul", "(", "ali_perm", ",", "pred_dsmat", ")", "\n", "gt_perm", "=", "torch", ".", "mul", "(", "ali_perm", ",", "gt_perm", ")", "\n", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "n_sum", "=", "torch", ".", "zeros_like", "(", "loss", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "loss", "+=", "F", ".", "binary_cross_entropy", "(", "\n", "pred_dsmat", "[", "b", ",", ":", "src_ns", "[", "b", "]", ",", ":", "tgt_ns", "[", "b", "]", "]", ",", "\n", "gt_perm", "[", "b", ",", ":", "src_ns", "[", "b", "]", ",", ":", "tgt_ns", "[", "b", "]", "]", ",", "\n", "reduction", "=", "'sum'", ")", "\n", "n_sum", "+=", "src_ns", "[", "b", "]", ".", "to", "(", "n_sum", ".", "dtype", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "", "return", "loss", "/", "n_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.OffsetLoss.__init__": [[189, 193], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "epsilon", ":", "float", "=", "1e-5", ",", "norm", "=", "None", ")", ":", "\n", "        ", "super", "(", "OffsetLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "norm", "=", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.OffsetLoss.forward": [[194, 214], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "d1", ":", "Tensor", ",", "d2", ":", "Tensor", ",", "mask", ":", "float", "=", "None", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        :param d1: predicted displacement matrix\n        :param d2: ground truth displacement matrix\n        :param mask: (optional) dummy node mask\n        :return: computed offset loss\n        \"\"\"", "\n", "# Loss = Sum(Phi(d_i - d_i^gt))", "\n", "# Phi(x) = sqrt(x^T * x + epsilon)", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "ones_like", "(", "mask", ")", "\n", "", "x", "=", "d1", "-", "d2", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", "/", "self", ".", "norm", "\n", "\n", "", "xtx", "=", "torch", ".", "sum", "(", "x", "*", "x", "*", "mask", ",", "dim", "=", "-", "1", ")", "\n", "phi", "=", "torch", ".", "sqrt", "(", "xtx", "+", "self", ".", "epsilon", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "phi", ")", "/", "d1", ".", "shape", "[", "0", "]", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.FocalLoss.__init__": [[234, 238], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "gamma", "=", "0.", ",", "eps", "=", "1e-15", ")", ":", "\n", "        ", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.FocalLoss.forward": [[239, 270], ["pred_dsmat.to.to.to", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "src_ns[].to().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "src_ns[].to", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "forward", "(", "self", ",", "pred_dsmat", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ",", "src_ns", ":", "Tensor", ",", "tgt_ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_dsmat: :math:`(b\\times n_1 \\times n_2)` predicted doubly-stochastic matrix :math:`(\\mathbf{S})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :param src_ns: :math:`(b)` number of exact pairs in the first graph (also known as source graph).\n        :param tgt_ns: :math:`(b)` number of exact pairs in the second graph (also known as target graph).\n        :return: :math:`(1)` averaged focal loss\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``src_ns`` and ``tgt_ns`` are\n            required to specify the exact number of nodes of each instance in the batch.\n        \"\"\"", "\n", "batch_num", "=", "pred_dsmat", ".", "shape", "[", "0", "]", "\n", "\n", "pred_dsmat", "=", "pred_dsmat", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "assert", "torch", ".", "all", "(", "(", "pred_dsmat", ">=", "0", ")", "*", "(", "pred_dsmat", "<=", "1", ")", ")", "\n", "assert", "torch", ".", "all", "(", "(", "gt_perm", ">=", "0", ")", "*", "(", "gt_perm", "<=", "1", ")", ")", "\n", "\n", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "n_sum", "=", "torch", ".", "zeros_like", "(", "loss", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "x", "=", "pred_dsmat", "[", "b", ",", ":", "src_ns", "[", "b", "]", ",", ":", "tgt_ns", "[", "b", "]", "]", "\n", "y", "=", "gt_perm", "[", "b", ",", ":", "src_ns", "[", "b", "]", ",", ":", "tgt_ns", "[", "b", "]", "]", "\n", "loss", "+=", "torch", ".", "sum", "(", "\n", "-", "(", "1", "-", "x", ")", "**", "self", ".", "gamma", "*", "y", "*", "torch", ".", "log", "(", "x", "+", "self", ".", "eps", ")", "\n", "-", "x", "**", "self", ".", "gamma", "*", "(", "1", "-", "y", ")", "*", "torch", ".", "log", "(", "1", "-", "x", "+", "self", ".", "eps", ")", "\n", ")", "\n", "n_sum", "+=", "src_ns", "[", "b", "]", ".", "to", "(", "n_sum", ".", "dtype", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "\n", "", "return", "loss", "/", "n_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.InnerProductLoss.__init__": [[284, 286], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "InnerProductLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.InnerProductLoss.forward": [[287, 316], ["pred_dsmat.to.to.to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "src_ns[].to().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "slice", "slice", "src_ns[].to"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "forward", "(", "self", ",", "pred_dsmat", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ",", "src_ns", ":", "Tensor", ",", "tgt_ns", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_dsmat: :math:`(b\\times n_1 \\times n_2)` predicted doubly-stochastic matrix :math:`(\\mathbf{S})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :param src_ns: :math:`(b)` number of exact pairs in the first graph (also known as source graph).\n        :param tgt_ns: :math:`(b)` number of exact pairs in the second graph (also known as target graph).\n        :return: :math:`(1)` averaged inner product loss\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``src_ns`` and ``tgt_ns`` are\n            required to specify the exact number of nodes of each instance in the batch.\n        \"\"\"", "\n", "batch_num", "=", "pred_dsmat", ".", "shape", "[", "0", "]", "\n", "\n", "pred_dsmat", "=", "pred_dsmat", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "try", ":", "\n", "            ", "assert", "torch", ".", "all", "(", "(", "gt_perm", ">=", "0", ")", "*", "(", "gt_perm", "<=", "1", ")", ")", "\n", "", "except", "AssertionError", "as", "err", ":", "\n", "            ", "raise", "err", "\n", "\n", "", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "n_sum", "=", "torch", ".", "zeros_like", "(", "loss", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "batch_slice", "=", "[", "b", ",", "slice", "(", "src_ns", "[", "b", "]", ")", ",", "slice", "(", "tgt_ns", "[", "b", "]", ")", "]", "\n", "loss", "-=", "torch", ".", "sum", "(", "pred_dsmat", "[", "batch_slice", "]", "*", "gt_perm", "[", "batch_slice", "]", ")", "\n", "n_sum", "+=", "src_ns", "[", "b", "]", ".", "to", "(", "n_sum", ".", "dtype", ")", ".", "to", "(", "pred_dsmat", ".", "device", ")", "\n", "\n", "", "return", "loss", "/", "n_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.HammingLoss.__init__": [[335, 337], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "HammingLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.loss_func.HammingLoss.forward": [[338, 346], ["errors.mean().sum", "errors.mean"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred_perm", ":", "Tensor", ",", "gt_perm", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param pred_perm: :math:`(b\\times n_1 \\times n_2)` predicted permutation matrix :math:`(\\mathbf{X})`\n        :param gt_perm: :math:`(b\\times n_1 \\times n_2)` ground truth permutation matrix :math:`(\\mathbf{X}^{gt})`\n        :return:\n        \"\"\"", "\n", "errors", "=", "pred_perm", "*", "(", "1.0", "-", "gt_perm", ")", "+", "(", "1.0", "-", "pred_perm", ")", "*", "gt_perm", "\n", "return", "errors", ".", "mean", "(", "dim", "=", "0", ")", ".", "sum", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.__init__": [[11, 16], ["torch.Module.__init__", "backbone.VGG16_base.get_backbone", "list", "backbone.VGG16_base.parameters"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.get_backbone"], ["def", "__init__", "(", "self", ",", "batch_norm", "=", "True", ",", "final_layers", "=", "False", ")", ":", "\n", "        ", "super", "(", "VGG16_base", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_layers", ",", "self", ".", "edge_layers", ",", "self", ".", "final_layers", "=", "self", ".", "get_backbone", "(", "batch_norm", ")", "\n", "if", "not", "final_layers", ":", "self", ".", "final_layers", "=", "None", "\n", "self", ".", "backbone_params", "=", "list", "(", "self", ".", "parameters", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.forward": [[17, 19], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "input", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.device": [[20, 23], ["next", "backbone.VGG16_base.parameters"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.get_backbone": [[24, 67], ["torch.Sequential", "torch.Sequential", "enumerate", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torchvision.models.vgg16_bn", "torchvision.models.vgg16", "isinstance", "isinstance", "torch.AdaptiveMaxPool2d", "torch.AdaptiveMaxPool2d", "list", "isinstance", "len", "len", "torchvision.models.vgg16.features.children", "isinstance"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_backbone", "(", "batch_norm", ")", ":", "\n", "        ", "\"\"\"\n        Get pretrained VGG16 models for feature extraction.\n\n        :return: feature sequence\n        \"\"\"", "\n", "if", "batch_norm", ":", "\n", "            ", "model", "=", "models", ".", "vgg16_bn", "(", "pretrained", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "models", ".", "vgg16", "(", "pretrained", "=", "True", ")", "\n", "\n", "", "conv_layers", "=", "nn", ".", "Sequential", "(", "*", "list", "(", "model", ".", "features", ".", "children", "(", ")", ")", ")", "\n", "\n", "conv_list", "=", "node_list", "=", "edge_list", "=", "[", "]", "\n", "\n", "# get the output of relu4_2(node features) and relu5_1(edge features)", "\n", "cnt_m", ",", "cnt_r", "=", "1", ",", "0", "\n", "for", "layer", ",", "module", "in", "enumerate", "(", "conv_layers", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "cnt_r", "+=", "1", "\n", "", "if", "isinstance", "(", "module", ",", "nn", ".", "MaxPool2d", ")", ":", "\n", "                ", "cnt_r", "=", "0", "\n", "cnt_m", "+=", "1", "\n", "", "conv_list", "+=", "[", "module", "]", "\n", "\n", "#if cnt_m == 4 and cnt_r == 2 and isinstance(module, nn.ReLU):", "\n", "if", "cnt_m", "==", "4", "and", "cnt_r", "==", "3", "and", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "node_list", "=", "conv_list", "\n", "conv_list", "=", "[", "]", "\n", "#elif cnt_m == 5 and cnt_r == 1 and isinstance(module, nn.ReLU):", "\n", "", "elif", "cnt_m", "==", "5", "and", "cnt_r", "==", "2", "and", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "edge_list", "=", "conv_list", "\n", "conv_list", "=", "[", "]", "\n", "\n", "", "", "assert", "len", "(", "node_list", ")", ">", "0", "and", "len", "(", "edge_list", ")", ">", "0", "\n", "\n", "# Set the layers as a nn.Sequential module", "\n", "node_layers", "=", "nn", ".", "Sequential", "(", "*", "node_list", ")", "\n", "edge_layers", "=", "nn", ".", "Sequential", "(", "*", "edge_list", ")", "\n", "final_layers", "=", "nn", ".", "Sequential", "(", "*", "conv_list", ",", "nn", ".", "AdaptiveMaxPool2d", "(", "(", "1", ",", "1", ")", ",", "return_indices", "=", "False", ")", ")", "# this final layer follows Rolink et al. ECCV20", "\n", "\n", "return", "node_layers", ",", "edge_layers", ",", "final_layers", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_bn_final.__init__": [[73, 75], ["backbone.VGG16_base.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "VGG16_bn_final", ",", "self", ")", ".", "__init__", "(", "True", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_bn.__init__": [[81, 83], ["backbone.VGG16_base.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "VGG16_bn", ",", "self", ")", ".", "__init__", "(", "True", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_final.__init__": [[89, 91], ["backbone.VGG16_base.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "VGG16_final", ",", "self", ")", ".", "__init__", "(", "False", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16.__init__": [[97, 99], ["backbone.VGG16_base.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "VGG16", ",", "self", ")", ".", "__init__", "(", "False", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.NoBackbone.__init__": [[105, 108], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "NoBackbone", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_layers", ",", "self", ".", "edge_layers", "=", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.NoBackbone.forward": [[109, 111], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "input", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.NoBackbone.device": [[112, 115], ["next", "backbone.NoBackbone.parameters"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "device", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.data_parallel.DataParallel.__init__": [[9, 11], ["torch.DataParallel.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DataParallel", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.data_parallel.DataParallel.scatter": [[12, 14], ["scatter_gather.scatter_kwargs"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter_kwargs"], ["", "def", "scatter", "(", "self", ",", "inputs", ",", "kwargs", ",", "device_ids", ")", ":", "\n", "        ", "return", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "device_ids", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.data_parallel.DataParallel.gather": [[15, 17], ["scatter_gather.gather"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.gather"], ["", "def", "gather", "(", "self", ",", "outputs", ",", "output_device", ")", ":", "\n", "        ", "return", "gather", "(", "outputs", ",", "output_device", ",", "dim", "=", "self", ".", "dim", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter": [[6, 37], ["isinstance", "scatter_gather.scatter.scatter_map"], "function", ["None"], ["def", "scatter", "(", "inputs", ",", "target_gpus", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Slices tensors into approximately equal chunks and\n    distributes them across given GPUs. Duplicates\n    references to objects that are not tensors.\n    \"\"\"", "\n", "def", "scatter_map", "(", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "torch_", ".", "Scatter", ".", "apply", "(", "target_gpus", ",", "None", ",", "dim", ",", "obj", ")", "\n", "", "if", "isinstance", "(", "obj", ",", "tuple", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "return", "list", "(", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ")", ")", ")", "\n", "", "if", "isinstance", "(", "obj", ",", "list", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "return", "list", "(", "map", "(", "list", ",", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ")", ")", ")", ")", "\n", "", "if", "isinstance", "(", "obj", ",", "dict", ")", "and", "len", "(", "obj", ")", ">", "0", ":", "\n", "            ", "return", "list", "(", "map", "(", "type", "(", "obj", ")", ",", "zip", "(", "*", "map", "(", "scatter_map", ",", "obj", ".", "items", "(", ")", ")", ")", ")", ")", "\n", "\n", "# modified here", "\n", "", "if", "isinstance", "(", "obj", ",", "CSRMatrix3d", ")", "or", "isinstance", "(", "obj", ",", "CSCMatrix3d", ")", ":", "\n", "            ", "return", "scatter_sparse_matrix", "(", "target_gpus", ",", "obj", ")", "\n", "\n", "", "return", "[", "obj", "for", "targets", "in", "target_gpus", "]", "\n", "\n", "# After scatter_map is called, a scatter_map cell will exist. This cell", "\n", "# has a reference to the actual function scatter_map, which has references", "\n", "# to a closure that has a reference to the scatter_map cell (because the", "\n", "# fn is recursive). To avoid this reference cycle, we set the function to", "\n", "# None, clearing the cell", "\n", "", "try", ":", "\n", "        ", "return", "scatter_map", "(", "inputs", ")", "\n", "", "finally", ":", "\n", "        ", "scatter_map", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter_kwargs": [[39, 50], ["tuple", "tuple", "scatter_gather.scatter", "scatter_gather.scatter", "len", "len", "tuple.extend", "len", "len", "tuple.extend", "range", "range", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter"], ["", "", "def", "scatter_kwargs", "(", "inputs", ",", "kwargs", ",", "target_gpus", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"Scatter with support for kwargs dictionary\"\"\"", "\n", "inputs", "=", "scatter", "(", "inputs", ",", "target_gpus", ",", "dim", ")", "if", "inputs", "else", "[", "]", "\n", "kwargs", "=", "scatter", "(", "kwargs", ",", "target_gpus", ",", "dim", ")", "if", "kwargs", "else", "[", "]", "\n", "if", "len", "(", "inputs", ")", "<", "len", "(", "kwargs", ")", ":", "\n", "        ", "inputs", ".", "extend", "(", "[", "(", ")", "for", "_", "in", "range", "(", "len", "(", "kwargs", ")", "-", "len", "(", "inputs", ")", ")", "]", ")", "\n", "", "elif", "len", "(", "kwargs", ")", "<", "len", "(", "inputs", ")", ":", "\n", "        ", "kwargs", ".", "extend", "(", "[", "{", "}", "for", "_", "in", "range", "(", "len", "(", "inputs", ")", "-", "len", "(", "kwargs", ")", ")", "]", ")", "\n", "", "inputs", "=", "tuple", "(", "inputs", ")", "\n", "kwargs", "=", "tuple", "(", "kwargs", ")", "\n", "return", "inputs", ",", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.scatter_sparse_matrix": [[52, 58], ["tuple", "len", "len", "torch.device", "torch.device", "torch.device", "torch.device", "obj[].to", "scatter_gather.scatter_sparse_matrix.get_device"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "scatter_sparse_matrix", "(", "target_gpus", ",", "obj", ")", ":", "\n", "    ", "\"\"\"Scatter for customized sparse matrix\"\"\"", "\n", "def", "get_device", "(", "i", ")", ":", "\n", "        ", "return", "torch", ".", "device", "(", "'cuda:{}'", ".", "format", "(", "i", ")", ")", "if", "i", "!=", "-", "1", "else", "torch", ".", "device", "(", "'cpu'", ")", "\n", "", "step", "=", "len", "(", "obj", ")", "//", "len", "(", "target_gpus", ")", "\n", "return", "tuple", "(", "[", "obj", "[", "i", ":", "i", "+", "step", "]", ".", "to", "(", "get_device", "(", "i", "//", "step", ")", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "obj", ")", ",", "step", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.parallel.scatter_gather.gather": [[60, 92], ["isinstance", "isinstance", "isinstance", "scatter_gather.gather.gather_map"], "function", ["None"], ["", "def", "gather", "(", "outputs", ",", "target_device", ",", "dim", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Gathers tensors from different GPUs on a specified device (-1 means the CPU).\n    \"\"\"", "\n", "def", "gather_map", "(", "outputs", ")", ":", "\n", "        ", "out", "=", "outputs", "[", "0", "]", "\n", "if", "isinstance", "(", "out", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "torch_", ".", "Gather", ".", "apply", "(", "target_device", ",", "dim", ",", "*", "outputs", ")", "\n", "\n", "# modified here", "\n", "", "if", "isinstance", "(", "out", ",", "CSRMatrix3d", ")", "or", "isinstance", "(", "out", ",", "CSCMatrix3d", ")", ":", "\n", "            ", "return", "concatenate", "(", "*", "outputs", ",", "device", "=", "target_device", ")", "\n", "\n", "", "if", "out", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "isinstance", "(", "out", ",", "dict", ")", ":", "\n", "            ", "if", "not", "all", "(", "(", "len", "(", "out", ")", "==", "len", "(", "d", ")", "for", "d", "in", "outputs", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'All dicts must have the same number of keys'", ")", "\n", "", "return", "type", "(", "out", ")", "(", "(", "(", "k", ",", "gather_map", "(", "[", "d", "[", "k", "]", "for", "d", "in", "outputs", "]", ")", ")", "\n", "for", "k", "in", "out", ")", ")", "\n", "", "if", "isinstance", "(", "out", ",", "int", ")", ":", "\n", "            ", "assert", "all", "(", "[", "out", "==", "_", "for", "_", "in", "outputs", "]", ")", "\n", "return", "out", "\n", "\n", "", "return", "type", "(", "out", ")", "(", "map", "(", "gather_map", ",", "zip", "(", "*", "outputs", ")", ")", ")", "\n", "\n", "# Recursive function calls like this create reference cycles.", "\n", "# Setting the function to None clears the refcycle.", "\n", "", "try", ":", "\n", "        ", "return", "gather_map", "(", "outputs", ")", "\n", "", "finally", ":", "\n", "        ", "gather_map", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.pad_tensor.pad_tensor": [[5, 32], ["iter", "next", "list", "numpy.array", "type", "numpy.zeros", "tuple", "padded_ts.append", "next", "range", "numpy.array", "tuple.tolist", "torch.pad", "len", "int", "len", "max"], "function", ["None"], ["def", "pad_tensor", "(", "inp", ")", ":", "\n", "    ", "\"\"\"\n    Pad a list of input tensors into a list of tensors with same dimension\n    :param inp: input tensor list\n    :return: output tensor list\n    \"\"\"", "\n", "assert", "type", "(", "inp", "[", "0", "]", ")", "==", "torch", ".", "Tensor", "\n", "it", "=", "iter", "(", "inp", ")", "\n", "t", "=", "next", "(", "it", ")", "\n", "max_shape", "=", "list", "(", "t", ".", "shape", ")", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "            ", "t", "=", "next", "(", "it", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "max_shape", ")", ")", ":", "\n", "                ", "max_shape", "[", "i", "]", "=", "int", "(", "max", "(", "max_shape", "[", "i", "]", ",", "t", ".", "shape", "[", "i", "]", ")", ")", "\n", "", "", "except", "StopIteration", ":", "\n", "            ", "break", "\n", "", "", "max_shape", "=", "np", ".", "array", "(", "max_shape", ")", "\n", "\n", "padded_ts", "=", "[", "]", "\n", "for", "t", "in", "inp", ":", "\n", "        ", "pad_pattern", "=", "np", ".", "zeros", "(", "2", "*", "len", "(", "max_shape", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "pad_pattern", "[", ":", ":", "-", "2", "]", "=", "max_shape", "-", "np", ".", "array", "(", "t", ".", "shape", ")", "\n", "pad_pattern", "=", "tuple", "(", "pad_pattern", ".", "tolist", "(", ")", ")", "\n", "padded_ts", ".", "append", "(", "functional", ".", "pad", "(", "t", ",", "pad_pattern", ",", "'constant'", ",", "0", ")", ")", "\n", "\n", "", "return", "padded_ts", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.lcm": [[192, 203], ["max"], "function", ["None"], ["def", "lcm", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"\n    Compute the least common multiple of x and y. This function is used for running statistics.\n    \"\"\"", "\n", "greater", "=", "max", "(", "x", ",", "y", ")", "\n", "while", "True", ":", "\n", "        ", "if", "(", "greater", "%", "x", "==", "0", ")", "and", "(", "greater", "%", "y", "==", "0", ")", ":", "\n", "            ", "lcm", "=", "greater", "\n", "break", "\n", "", "greater", "+=", "1", "\n", "", "return", "lcm", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.get_output_dir": [[205, 214], ["os.path.join"], "function", ["None"], ["", "def", "get_output_dir", "(", "model", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"\n    Return the directory where experimental artifacts are placed.\n    :param model: model name\n    :param dataset: dataset name\n    :return: output path (checkpoint and log)\n    \"\"\"", "\n", "outp_path", "=", "os", ".", "path", ".", "join", "(", "'output'", ",", "'{}_{}'", ".", "format", "(", "model", ",", "dataset", ")", ")", "\n", "return", "outp_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config._merge_a_into_b": [[216, 245], ["a.items", "type", "KeyError", "type", "type", "type", "float", "config._merge_a_into_b", "type", "type", "ValueError", "print", "type", "type"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config._merge_a_into_b"], ["", "def", "_merge_a_into_b", "(", "a", ",", "b", ")", ":", "\n", "    ", "\"\"\"Merge config dictionary a into config dictionary b, clobbering the\n    options in b whenever they are also specified in a.\n    \"\"\"", "\n", "if", "type", "(", "a", ")", "is", "not", "edict", ":", "\n", "        ", "return", "\n", "\n", "", "for", "k", ",", "v", "in", "a", ".", "items", "(", ")", ":", "\n", "# a must specify keys that are in b", "\n", "        ", "if", "k", "not", "in", "b", ":", "\n", "            ", "raise", "KeyError", "(", "'{} is not a valid config key'", ".", "format", "(", "k", ")", ")", "\n", "\n", "# the types must match, too", "\n", "", "if", "type", "(", "b", "[", "k", "]", ")", "is", "not", "type", "(", "v", ")", ":", "\n", "            ", "if", "type", "(", "b", "[", "k", "]", ")", "is", "float", "and", "type", "(", "v", ")", "is", "int", ":", "\n", "                ", "v", "=", "float", "(", "v", ")", "\n", "", "else", ":", "\n", "                ", "if", "not", "k", "in", "[", "'CLASS'", "]", ":", "\n", "                    ", "raise", "ValueError", "(", "'Type mismatch ({} vs. {}) for config key: {}'", ".", "format", "(", "type", "(", "b", "[", "k", "]", ")", ",", "type", "(", "v", ")", ",", "k", ")", ")", "\n", "\n", "# recursively merge dicts", "\n", "", "", "", "if", "type", "(", "v", ")", "is", "edict", ":", "\n", "            ", "try", ":", "\n", "                ", "_merge_a_into_b", "(", "a", "[", "k", "]", ",", "b", "[", "k", "]", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "'Error under config key: {}'", ".", "format", "(", "k", ")", ")", "\n", "raise", "\n", "", "", "else", ":", "\n", "            ", "b", "[", "k", "]", "=", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_file": [[247, 264], ["config._merge_a_into_b", "open", "easydict.EasyDict", "importlib.import_module", "__C.update", "__C[].update", "yaml.full_load", "easydict.EasyDict.MODULE.split"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config._merge_a_into_b"], ["", "", "", "def", "cfg_from_file", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Load a config file and merge it into the default options.\"\"\"", "\n", "import", "yaml", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "yaml_cfg", "=", "edict", "(", "yaml", ".", "full_load", "(", "f", ")", ")", "\n", "\n", "", "if", "'MODULE'", "in", "yaml_cfg", "and", "yaml_cfg", ".", "MODULE", "not", "in", "__C", ":", "\n", "        ", "model_cfg_module", "=", "'.'", ".", "join", "(", "yaml_cfg", ".", "MODULE", ".", "split", "(", "'.'", ")", "[", ":", "-", "1", "]", "+", "[", "'model_config'", "]", ")", "\n", "mod", "=", "importlib", ".", "import_module", "(", "model_cfg_module", ")", "\n", "__C", ".", "update", "(", "mod", ".", "model_cfg", ")", "\n", "\n", "", "if", "'DATASET_FULL_NAME'", "in", "yaml_cfg", "and", "yaml_cfg", ".", "DATASET_FULL_NAME", "in", "yaml_cfg", "and", "yaml_cfg", ".", "DATASET_FULL_NAME", "not", "in", "__C", ":", "\n", "        ", "__C", "[", "yaml_cfg", ".", "DATASET_FULL_NAME", "]", "=", "src", ".", "dataset", ".", "dataset_cfg", "[", "yaml_cfg", ".", "DATASET_FULL_NAME", "]", "\n", "__C", "[", "yaml_cfg", ".", "DATASET_FULL_NAME", "]", ".", "update", "(", "yaml_cfg", "[", "yaml_cfg", ".", "DATASET_FULL_NAME", "]", ")", "\n", "\n", "", "_merge_a_into_b", "(", "yaml_cfg", ",", "__C", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_list": [[266, 287], ["zip", "k.split", "len", "d.keys", "literal_eval", "type", "type", "type", "type", "d.keys"], "function", ["None"], ["", "def", "cfg_from_list", "(", "cfg_list", ")", ":", "\n", "    ", "\"\"\"Set config keys via list (e.g., from command line).\"\"\"", "\n", "from", "ast", "import", "literal_eval", "\n", "assert", "len", "(", "cfg_list", ")", "%", "2", "==", "0", "\n", "for", "k", ",", "v", "in", "zip", "(", "cfg_list", "[", "0", ":", ":", "2", "]", ",", "cfg_list", "[", "1", ":", ":", "2", "]", ")", ":", "\n", "        ", "key_list", "=", "k", ".", "split", "(", "'.'", ")", "\n", "d", "=", "__C", "\n", "for", "subkey", "in", "key_list", "[", ":", "-", "1", "]", ":", "\n", "            ", "assert", "subkey", "in", "d", ".", "keys", "(", ")", "\n", "d", "=", "d", "[", "subkey", "]", "\n", "", "subkey", "=", "key_list", "[", "-", "1", "]", "\n", "assert", "subkey", "in", "d", ".", "keys", "(", ")", "\n", "try", ":", "\n", "            ", "value", "=", "literal_eval", "(", "v", ")", "\n", "", "except", ":", "\n", "# handle the case when v is a string literal", "\n", "            ", "value", "=", "v", "\n", "", "assert", "type", "(", "value", ")", "==", "type", "(", "d", "[", "subkey", "]", ")", ",", "'type {} does not match original type {}'", ".", "format", "(", "\n", "type", "(", "value", ")", ",", "type", "(", "d", "[", "subkey", "]", ")", ")", "\n", "d", "[", "subkey", "]", "=", "value", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.static_vars": [[3, 9], ["setattr"], "function", ["None"], ["def", "static_vars", "(", "**", "kwargs", ")", ":", "\n", "    ", "def", "decorate", "(", "func", ")", ":", "\n", "        ", "for", "k", "in", "kwargs", ":", "\n", "            ", "setattr", "(", "func", ",", "k", ",", "kwargs", "[", "k", "]", ")", "\n", "", "return", "func", "\n", "", "return", "decorate", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.print_easydict": [[10, 21], ["print_easydict.static_vars", "inp_dict.items", "print", "print_easydict.print_easydict", "print", "type", "type"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.static_vars", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.print_easydict"], ["", "@", "static_vars", "(", "indent_cnt", "=", "0", ")", "\n", "def", "print_easydict", "(", "inp_dict", ":", "edict", ")", ":", "\n", "    ", "for", "key", ",", "value", "in", "inp_dict", ".", "items", "(", ")", ":", "\n", "        ", "if", "type", "(", "value", ")", "is", "edict", "or", "type", "(", "value", ")", "is", "dict", ":", "\n", "            ", "print", "(", "'{}{}:'", ".", "format", "(", "' '", "*", "2", "*", "print_easydict", ".", "indent_cnt", ",", "key", ")", ")", "\n", "print_easydict", ".", "indent_cnt", "+=", "1", "\n", "print_easydict", "(", "value", ")", "\n", "print_easydict", ".", "indent_cnt", "-=", "1", "\n", "\n", "", "else", ":", "\n", "            ", "print", "(", "'{}{}: {}'", ".", "format", "(", "' '", "*", "2", "*", "print_easydict", ".", "indent_cnt", ",", "key", ",", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.print_easydict_str": [[22, 36], ["print_easydict.static_vars", "inp_dict.items", "print_easydict.print_easydict_str", "type", "type"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.static_vars", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.print_easydict.print_easydict_str"], ["", "", "", "@", "static_vars", "(", "indent_cnt", "=", "0", ")", "\n", "def", "print_easydict_str", "(", "inp_dict", ":", "edict", ")", ":", "\n", "    ", "ret_str", "=", "''", "\n", "for", "key", ",", "value", "in", "inp_dict", ".", "items", "(", ")", ":", "\n", "        ", "if", "type", "(", "value", ")", "is", "edict", "or", "type", "(", "value", ")", "is", "dict", ":", "\n", "            ", "ret_str", "+=", "'{}{}:\\n'", ".", "format", "(", "' '", "*", "2", "*", "print_easydict_str", ".", "indent_cnt", ",", "key", ")", "\n", "print_easydict_str", ".", "indent_cnt", "+=", "1", "\n", "ret_str", "+=", "print_easydict_str", "(", "value", ")", "\n", "print_easydict_str", ".", "indent_cnt", "-=", "1", "\n", "\n", "", "else", ":", "\n", "            ", "ret_str", "+=", "'{}{}: {}\\n'", ".", "format", "(", "' '", "*", "2", "*", "print_easydict_str", ".", "indent_cnt", ",", "key", ",", "value", ")", "\n", "\n", "", "", "return", "ret_str", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.parse_args.parse_args": [[6, 38], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "src.utils.config.cfg_from_list", "src.utils.config.cfg_from_list", "len", "len", "src.utils.config.get_output_dir", "src.utils.config.cfg_from_list", "len", "pathlib.Path().exists", "pathlib.Path().mkdir", "src.utils.config.cfg_from_file", "len", "len", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.parse_args.parse_args", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.get_output_dir", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.config.cfg_from_file"], ["def", "parse_args", "(", "description", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "description", ")", "\n", "parser", ".", "add_argument", "(", "'--cfg'", ",", "'--config'", ",", "dest", "=", "'cfg_file'", ",", "action", "=", "'append'", ",", "\n", "help", "=", "'an optional config file'", ",", "default", "=", "None", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'--batch'", ",", "dest", "=", "'batch_size'", ",", "\n", "help", "=", "'batch size'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--epoch'", ",", "dest", "=", "'epoch'", ",", "\n", "help", "=", "'epoch number'", ",", "default", "=", "None", ",", "type", "=", "int", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# load cfg from file", "\n", "if", "args", ".", "cfg_file", "is", "not", "None", ":", "\n", "        ", "for", "f", "in", "args", ".", "cfg_file", ":", "\n", "            ", "cfg_from_file", "(", "f", ")", "\n", "\n", "# load cfg from arguments", "\n", "", "", "if", "args", ".", "batch_size", "is", "not", "None", ":", "\n", "        ", "cfg_from_list", "(", "[", "'BATCH_SIZE'", ",", "args", ".", "batch_size", "]", ")", "\n", "", "if", "args", ".", "epoch", "is", "not", "None", ":", "\n", "        ", "cfg_from_list", "(", "[", "'TRAIN.START_EPOCH'", ",", "args", ".", "epoch", ",", "'EVAL.EPOCH'", ",", "args", ".", "epoch", "]", ")", "\n", "\n", "", "assert", "len", "(", "cfg", ".", "MODULE", ")", "!=", "0", ",", "'Please specify a module name in your yaml file (e.g. MODULE: models.PCA.model).'", "\n", "assert", "len", "(", "cfg", ".", "DATASET_FULL_NAME", ")", "!=", "0", ",", "'Please specify the full name of dataset in your yaml file (e.g. DATASET_FULL_NAME: PascalVOC).'", "\n", "\n", "if", "len", "(", "cfg", ".", "MODEL_NAME", ")", "!=", "0", "and", "len", "(", "cfg", ".", "DATASET_NAME", ")", "!=", "0", ":", "\n", "        ", "outp_path", "=", "get_output_dir", "(", "cfg", ".", "MODEL_NAME", ",", "cfg", ".", "DATASET_NAME", ")", "\n", "cfg_from_list", "(", "[", "'OUTPUT_PATH'", ",", "outp_path", "]", ")", "\n", "", "assert", "len", "(", "cfg", ".", "OUTPUT_PATH", ")", "!=", "0", ",", "'Invalid OUTPUT_PATH! Make sure model name and dataset name are specified.'", "\n", "if", "not", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", ".", "exists", "(", ")", ":", "\n", "        ", "Path", "(", "cfg", ".", "OUTPUT_PATH", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "", "return", "args", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.timer.Timer.__init__": [[5, 8], ["time.time.time"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "t", "=", "time", "(", ")", "\n", "self", ".", "tk", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.timer.Timer.tick": [[9, 12], ["time.time.time"], "methods", ["None"], ["", "def", "tick", "(", "self", ")", ":", "\n", "        ", "self", ".", "t", "=", "time", "(", ")", "\n", "self", ".", "tk", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.timer.Timer.toc": [[13, 23], ["time.time.time", "RuntimeError"], "methods", ["None"], ["", "def", "toc", "(", "self", ",", "tick_again", "=", "False", ")", ":", "\n", "        ", "if", "not", "self", ".", "tk", ":", "\n", "            ", "raise", "RuntimeError", "(", "'not ticked yet!'", ")", "\n", "", "self", ".", "tk", "=", "False", "\n", "before_t", "=", "self", ".", "t", "\n", "cur_t", "=", "time", "(", ")", "\n", "if", "tick_again", ":", "\n", "            ", "self", ".", "t", "=", "cur_t", "\n", "self", ".", "tk", "=", "True", "\n", "", "return", "cur_t", "-", "before_t", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.forward": [[85, 99], ["ctx.save_for_backward", "sparse.sdd_bmm_torch", "sdd_bmm_torch().transpose", "sparse.sdd_bmm_torch", "t2.transpose", "t1.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "t1", ",", "t2", ")", ":", "\n", "        ", "\"\"\"\n        :param t1: tensor 1\n        :param t2: tensor 2\n        :return: bmm result in dense\n        \"\"\"", "\n", "ctx", ".", "save_for_backward", "(", "t1", ",", "t2", ")", "\n", "assert", "t1", ".", "is_sparse", "!=", "t2", ".", "is_sparse", ",", "'t1, t2 must be one sparse and one dense!'", "\n", "if", "t1", ".", "is_sparse", ":", "\n", "            ", "result", "=", "sdd_bmm_torch", "(", "t1", ",", "t2", ")", "\n", "", "else", ":", "\n", "            ", "result", "=", "sdd_bmm_torch", "(", "t2", ".", "transpose", "(", "1", ",", "2", ")", ",", "t1", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.SparseDenseDenseBMM.backward": [[100, 110], ["torch.bmm", "sparse.dense_to_sparse", "sparse.sdd_bmm_torch", "d_t2.transpose", "s_t1.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.dense_to_sparse", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "dm", ")", ":", "\n", "        ", "s_t1", ",", "d_t2", "=", "ctx", ".", "saved_tensors", "\n", "dt1", "=", "dt2", "=", "None", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", ":", "\n", "            ", "dt1", "=", "torch", ".", "bmm", "(", "dm", ",", "d_t2", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "dt1", "=", "dense_to_sparse", "(", "dt1", ")", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "            ", "dt2", "=", "sdd_bmm_torch", "(", "s_t1", ".", "transpose", "(", "1", ",", "2", ")", ",", "dm", ")", "\n", "", "return", "dt1", ",", "dt2", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.to_sparse": [[19, 30], ["getattr", "indices.t.t", "getattr.", "torch.typename().split", "torch.nonzero", "len", "getattr.", "tuple", "torch.typename", "len", "range"], "function", ["None"], ["", "def", "to_sparse", "(", "x", ",", "dense_dim", "=", "1", ")", ":", "\n", "    ", "\"\"\" converts dense tensor x to sparse format \"\"\"", "\n", "x_typename", "=", "torch", ".", "typename", "(", "x", ")", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "sparse_tensortype", "=", "getattr", "(", "torch", ".", "sparse", ",", "x_typename", ")", "\n", "\n", "indices", "=", "torch", ".", "nonzero", "(", "x", ",", "as_tuple", "=", "False", ")", "[", ":", ",", ":", "len", "(", "x", ".", "shape", ")", "-", "dense_dim", "+", "1", "]", "\n", "if", "len", "(", "indices", ".", "shape", ")", "==", "0", ":", "# if all elements are zeros", "\n", "        ", "return", "sparse_tensortype", "(", "*", "x", ".", "shape", ")", "\n", "", "indices", "=", "indices", ".", "t", "(", ")", "\n", "values", "=", "x", "[", "tuple", "(", "indices", "[", "i", "]", "for", "i", "in", "range", "(", "indices", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "return", "sparse_tensortype", "(", "indices", ",", "values", ",", "x", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sbmm": [[32, 37], ["SparseDenseDenseBMM.apply"], "function", ["None"], ["", "def", "sbmm", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "\"\"\"\n    Perform bmm (Batch Matrix Matrix) for sparse x dense -> dense.\n    \"\"\"", "\n", "return", "SparseDenseDenseBMM", ".", "apply", "(", "t1", ",", "t2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sbmm_diag": [[39, 46], ["sparse.sdd_bmm_diag_torch"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_diag_torch"], ["", "def", "sbmm_diag", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "\"\"\"\n    Perform bmm and diagonal for sparse x dense -> dense. The diagonalized result is returned in vector tensor.\n    This is a wrapper function and does not support gradient.\n    \"\"\"", "\n", "assert", "t1", ".", "is_sparse", "!=", "t2", ".", "is_sparse", ",", "'t1, t2 must be one sparse and one dense!'", "\n", "return", "sdd_bmm_diag_torch", "(", "t1", ",", "t2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdsbmm": [[48, 60], ["sparse.sds_bmm_torch", "sds_bmm_torch().transpose", "type", "type", "type", "sparse.sds_bmm_torch", "t2.transpose", "t1.transpose"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sds_bmm_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sds_bmm_torch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "sdsbmm", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "\"\"\"\n    Perform bmm for sparse x dense -> sparse.\n    This is a wrapper function and does not support gradient.\n    \"\"\"", "\n", "assert", "(", "type", "(", "t1", ")", "==", "list", ")", "!=", "(", "type", "(", "t2", ")", "==", "list", ")", "or", "t1", ".", "is_sparse", "!=", "t2", ".", "is_sparse", ",", "'t1, t2 must be one sparse and one dense!'", "\n", "if", "type", "(", "t1", ")", "==", "list", "or", "t1", ".", "is_sparse", ":", "\n", "        ", "result", "=", "sds_bmm_torch", "(", "t1", ",", "t2", ")", "\n", "", "else", ":", "\n", "        ", "result", "=", "sds_bmm_torch", "(", "t2", ".", "transpose", "(", "1", ",", "2", ")", ",", "t1", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sssbmm_diag": [[62, 72], ["sparse.sss_bmm_diag_spp", "sparse.torch2ssp", "sparse.torch2ssp", "type", "type", "type", "type", "type", "type"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sss_bmm_diag_spp", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.torch2ssp", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.torch2ssp"], ["", "def", "sssbmm_diag", "(", "m1", ",", "m2", ")", ":", "\n", "    ", "\"\"\"\n    Perform bmm and diagonal for sparse x sparse -> sparse.\n    This is a wrapper function and does not support gradient.\n    \"\"\"", "\n", "if", "(", "type", "(", "m1", ")", "==", "list", "and", "type", "(", "m1", "[", "0", "]", ")", "==", "torch", ".", "Tensor", ")", "or", "type", "(", "m1", ")", "==", "torch", ".", "Tensor", ":", "\n", "        ", "m1", "=", "torch2ssp", "(", "m1", ")", "\n", "", "if", "(", "type", "(", "m2", ")", "==", "list", "and", "type", "(", "m2", "[", "0", "]", ")", "==", "torch", ".", "Tensor", ")", "or", "type", "(", "m2", ")", "==", "torch", ".", "Tensor", ":", "\n", "        ", "m2", "=", "torch2ssp", "(", "m2", ")", "\n", "", "return", "sss_bmm_diag_spp", "(", "m1", ",", "m2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_torch": [[112, 132], ["torch.empty", "range", "sparse.get_batches", "torch.mm"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.get_batches"], ["", "", "def", "sdd_bmm_torch", "(", "s_t1", ",", "d_t2", ")", ":", "\n", "    ", "\"\"\"\n    bmm (Batch Matrix Matrix) for sparse x dense -> dense. This function itself doesn't support gradient.\n    with s_t1.shape = (b, x, s), d_t2.shape = (b, s, y), the output shape is (b, x, y)\n    This is a work around utilizing torch.mm for sparse x dense -> dense\n    :param s_t1: sparse tensor 1\n    :param d_t2: dense tensor 2\n    :return: bmm result in dense\n    \"\"\"", "\n", "device", "=", "s_t1", ".", "device", "\n", "batch_num", "=", "s_t1", ".", "shape", "[", "0", "]", "\n", "x", "=", "s_t1", ".", "shape", "[", "1", "]", "\n", "y", "=", "d_t2", ".", "shape", "[", "2", "]", "\n", "assert", "s_t1", ".", "shape", "[", "0", "]", "==", "d_t2", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch.'", "\n", "assert", "s_t1", ".", "shape", "[", "2", "]", "==", "d_t2", ".", "shape", "[", "1", "]", ",", "'Matrix shape mismatch.'", "\n", "outp", "=", "torch", ".", "empty", "(", "batch_num", ",", "x", ",", "y", ",", "dtype", "=", "s_t1", ".", "dtype", ",", "device", "=", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "        ", "_s_t1", "=", "get_batches", "(", "s_t1", ",", "b", ")", "\n", "torch", ".", "mm", "(", "_s_t1", ",", "d_t2", "[", "b", ",", ":", ",", ":", "]", ",", "out", "=", "outp", "[", "b", ",", ":", ",", ":", "]", ")", "\n", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sdd_bmm_diag_torch": [[134, 152], ["t1.transpose().to_dense", "torch.sum", "t2.transpose().to_dense", "torch.sum", "t1.transpose().to_dense.mul_", "t2.transpose().to_dense.mul_", "t1.transpose", "t2.transpose"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "sdd_bmm_diag_torch", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "\"\"\"\n    Perform bmm and diagonal for sparse x dense -> dense. The diagonalized result is returned in vector tensor.\n    With s_t1.shape = (b, x, s), d_t2.shape = (b, s, x), the output shape is (b, x).\n    This method avoids a temporal (b, x, x) for memory efficiency.\n    :param t1: tensor 1\n    :param t2: tensor 2\n    :return: bmm_diag result in dense\n    \"\"\"", "\n", "assert", "t1", ".", "shape", "[", "0", "]", "==", "t2", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch.'", "\n", "assert", "t1", ".", "shape", "[", "2", "]", "==", "t2", ".", "shape", "[", "1", "]", "and", "t1", ".", "shape", "[", "1", "]", "==", "t2", ".", "shape", "[", "2", "]", ",", "'Matrix shape mismatch.'", "\n", "if", "t1", ".", "is_sparse", ":", "\n", "        ", "d_t1", "=", "t1", ".", "transpose", "(", "1", ",", "2", ")", ".", "to_dense", "(", ")", "\n", "outp", "=", "torch", ".", "sum", "(", "d_t1", ".", "mul_", "(", "t2", ")", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "d_t2", "=", "t2", ".", "transpose", "(", "1", ",", "2", ")", ".", "to_dense", "(", ")", "\n", "outp", "=", "torch", ".", "sum", "(", "d_t2", ".", "mul_", "(", "t1", ")", ",", "dim", "=", "2", ")", "\n", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sds_bmm_torch": [[154, 180], ["len", "range", "type", "s_t1[].cpu", "d_t2[].cpu", "torch.smm", "outp.append"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["", "def", "sds_bmm_torch", "(", "s_t1", ",", "d_t2", ")", ":", "\n", "    ", "\"\"\"\n    bmm (Batch Matrix Matrix) for sparse x dense -> sparse. This function doesn't support gradient.\n    And sparse tensors cannot accept gradient due to the limitation of torch implementation.\n    with s_t1.shape = (b, x, s), d_t2.shape = (b, s, y), the output shape is (b, x, y)\n    This is a work around utilizing torch.smm for sparse x dense -> sparse\n    :param s_t1: sparse tensor 1 (in list, representing batches)\n    :param d_t2: dense tensor 2\n    :return: bmm result in sparse (in list, representing batches)\n    \"\"\"", "\n", "device", "=", "d_t2", ".", "device", "\n", "assert", "type", "(", "s_t1", ")", "==", "list", "\n", "batch_num", "=", "len", "(", "s_t1", ")", "\n", "\n", "assert", "batch_num", "==", "d_t2", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch.'", "\n", "\n", "outp", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "# force cpu", "\n", "        ", "_s_t1", "=", "s_t1", "[", "b", "]", ".", "cpu", "(", ")", "\n", "_d_t2", "=", "d_t2", "[", "b", "]", ".", "cpu", "(", ")", "\n", "assert", "_s_t1", ".", "shape", "[", "1", "]", "==", "_d_t2", ".", "shape", "[", "0", "]", ",", "'Matrix shape mismatch.'", "\n", "_outp", "=", "torch", ".", "smm", "(", "_s_t1", ",", "_d_t2", ")", "# CUDA version of smm is not implemented", "\n", "outp", ".", "append", "(", "_outp", ")", "\n", "\n", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.bilinear_diag_torch": [[182, 236], ["bilinear_diag.bilinear_diag", "bilinear_diag.bilinear_diag.to", "s_t1.as_list", "s_t3.as_list"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list"], ["", "def", "bilinear_diag_torch", "(", "s_t1", ":", "CSRMatrix3d", ",", "d_t2", ":", "torch", ".", "Tensor", ",", "s_t3", ":", "CSCMatrix3d", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Bilinear and diagonal in sequence, for diagonal(sparse x dense x sparse) -> dense vector.\n    with s_t1.shape = (b, x, y), d_t2.shape = (b, y, y), d_t3.shape = (b, y, x), the output shape is (b, x).\n    In this function, two sparse tensors (s1 and s3) are represented in CSR and CSC format to guarantee efficient\n    computation.\n    The main operation is implemented in a custom C++ extension, and will be ~1000x faster if CUDA is available.\n    :param s_t1: CSR matrix 1\n    :param d_t2: dense tensor 2\n    :param s_t3: CSC matrix 3\n    :param device: device. If not specified, it will be the same as input.\n    :return: returned dense vector\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "d_t2", ".", "device", "\n", "#dtype = d_t2.dtype", "\n", "\n", "", "batch_num", "=", "s_t1", ".", "shape", "[", "0", "]", "\n", "xlen", "=", "s_t1", ".", "shape", "[", "1", "]", "\n", "assert", "s_t1", ".", "shape", "[", "0", "]", "==", "d_t2", ".", "shape", "[", "0", "]", "==", "s_t3", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch.'", "\n", "assert", "s_t1", ".", "shape", "[", "1", "]", "==", "s_t3", ".", "shape", "[", "2", "]", ",", "'Sparse matrix 1 & 3 shape mismatch.'", "\n", "assert", "s_t1", ".", "shape", "[", "2", "]", "==", "d_t2", ".", "shape", "[", "1", "]", "==", "d_t2", ".", "shape", "[", "2", "]", "==", "s_t3", ".", "shape", "[", "1", "]", ",", "'Matrix size mismatch.'", "\n", "'''\n    s_t1_input = [[], [], []]\n    s_t3_input = [[], [], []]\n    t1_indptr_offset = 0\n    t3_indptr_offset = 0\n    for b in range(batch_num):\n        _s_t1 = s_t1[b].tocsc()\n        s_t1_input[0].append(_s_t1.indices)\n        s_t1_input[1].append(_s_t1.indptr[:-1] + t1_indptr_offset)\n        s_t1_input[2].append(_s_t1.data)\n        t1_indptr_offset += _s_t1.indptr[-1]\n\n        _s_t3 = s_t3[b].tocsc()\n        s_t3_input[0].append(_s_t3.indices)\n        s_t3_input[1].append(_s_t3.indptr[:-1] + t3_indptr_offset)\n        s_t3_input[2].append(_s_t3.data)\n        t3_indptr_offset += _s_t3.indptr[-1]\n\n    s_t1_input[1].append(np.array([t1_indptr_offset]))\n    s_t3_input[1].append(np.array([t3_indptr_offset]))\n\n    for input in (s_t1_input, s_t3_input):\n        for idx in range(len(input)):\n            if idx == 2:  # data\n                _dtype = dtype\n            else:  # indices & indptr\n                _dtype = torch.int64\n            input[idx] = torch.tensor(np.concatenate(input[idx]), dtype=_dtype, device=device)\n    '''", "\n", "outp", "=", "bilinear_diag", ".", "bilinear_diag", "(", "*", "s_t1", ".", "as_list", "(", ")", ",", "d_t2", ",", "*", "s_t3", ".", "as_list", "(", ")", ",", "batch_num", ",", "xlen", ")", "\n", "\n", "return", "outp", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.dense_to_sparse": [[238, 254], ["torch.nonzero", "indices.t.t", "torch.sparse_coo_tensor", "len", "torch.sparse_coo_tensor", "d_t.size", "tuple", "range"], "function", ["None"], ["", "def", "dense_to_sparse", "(", "d_t", ")", ":", "\n", "    ", "\"\"\"\n    Convert a dense tensor to a sparse one.\n    :param d_t: dense tensor\n    :return: sparse tensor\n    \"\"\"", "\n", "dtype", "=", "d_t", ".", "dtype", "\n", "device", "=", "d_t", ".", "device", "\n", "req_grad", "=", "d_t", ".", "requires_grad", "\n", "\n", "indices", "=", "torch", ".", "nonzero", "(", "d_t", ")", "\n", "if", "len", "(", "indices", ".", "shape", ")", "==", "0", ":", "# if all elements are zeros", "\n", "        ", "return", "torch", ".", "sparse_coo_tensor", "(", "[", "]", ",", "[", "]", ",", "d_t", ".", "shape", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "req_grad", ")", "\n", "", "indices", "=", "indices", ".", "t", "(", ")", "\n", "values", "=", "d_t", "[", "tuple", "(", "indices", "[", "i", "]", "for", "i", "in", "range", "(", "indices", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "return", "torch", ".", "sparse_coo_tensor", "(", "indices", ",", "values", ",", "d_t", ".", "size", "(", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ",", "requires_grad", "=", "req_grad", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.get_batches": [[256, 283], ["s_t._indices", "s_t._values", "coo[].view", "data[].view", "torch.sparse_coo_tensor", "range", "coo[].view", "data[].view", "torch.sparse_coo_tensor.append", "torch.sparse_coo_tensor"], "function", ["None"], ["", "def", "get_batches", "(", "s_t", ",", "b", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Get batches from a 3d sparse tensor.\n    :param s_t: sparse tensor\n    :param b: if None, return all batches in a list; else, return a specific batch\n    :param device: device. If None, it will be the same as input\n    :return: sparse tensor or list of sparse tensors\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "s_t", ".", "device", "\n", "\n", "", "coo", "=", "s_t", ".", "_indices", "(", ")", "\n", "data", "=", "s_t", ".", "_values", "(", ")", "\n", "if", "b", "is", "not", "None", ":", "\n", "        ", "idx", "=", "(", "coo", "[", "0", ",", ":", "]", "==", "b", ")", ".", "nonzero", "(", ")", "\n", "_coo", "=", "coo", "[", "1", ":", "3", ",", "idx", "]", ".", "view", "(", "2", ",", "-", "1", ")", "\n", "_data", "=", "data", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "outp", "=", "torch", ".", "sparse_coo_tensor", "(", "_coo", ",", "_data", ",", "s_t", ".", "shape", "[", "1", ":", "3", "]", ",", "dtype", "=", "_data", ".", "dtype", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "batch_num", "=", "s_t", ".", "shape", "[", "0", "]", "\n", "outp", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "idx", "=", "(", "coo", "[", "0", ",", ":", "]", "==", "b", ")", ".", "nonzero", "(", ")", "\n", "_coo", "=", "coo", "[", "1", ":", "3", ",", "idx", "]", ".", "view", "(", "2", ",", "-", "1", ")", "\n", "_data", "=", "data", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "outp", ".", "append", "(", "torch", ".", "sparse_coo_tensor", "(", "_coo", ",", "_data", ",", "s_t", ".", "shape", "[", "1", ":", "3", "]", ",", "dtype", "=", "_data", ".", "dtype", ",", "device", "=", "device", ")", ")", "\n", "", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.slicing_torch": [[285, 326], ["s_t._indices", "s_t._values", "torch.ones", "range", "torch.ones.nonzero().view", "torch.sparse_coo_tensor", "len", "torch.ones.mul_", "torch.tensor.mul_", "torch.Size", "torch.ones.nonzero", "dim_flag.numel", "torch.tensor", "torch.Size", "torch.Size", "torch.tensor", "torch.tensor", "torch.ones", "len"], "function", ["None"], ["", "def", "slicing_torch", "(", "s_t", ",", "slice", ",", "preserve_dim", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    A slicing function for torch sparse tensors.\n    :param s_t: input sparse tensor\n    :param slice: tensor containing indices, -1 stands for all.\n                  For example, (1, -1) returns the second row of a 2d tensor.\n    :param preserve_dim: If True, the dimension of the original tensor will be preserved,\n                         i.e. 1 will be padded for those removed dimensions.\n    :return: sliced sparse tensor\n    \"\"\"", "\n", "device", "=", "s_t", ".", "device", "\n", "dim", "=", "slice", ".", "shape", "[", "0", "]", "\n", "assert", "len", "(", "s_t", ".", "shape", ")", "==", "dim", "\n", "coo", "=", "s_t", ".", "_indices", "(", ")", "\n", "data", "=", "s_t", ".", "_values", "(", ")", "\n", "idx_flag", "=", "torch", ".", "ones", "(", "coo", ".", "shape", "[", "1", "]", ",", "dtype", "=", "torch", ".", "uint8", ",", "device", "=", "device", ")", "\n", "for", "i", "in", "range", "(", "dim", ")", ":", "\n", "        ", "s", "=", "slice", "[", "i", "]", "\n", "if", "s", "==", "-", "1", ":", "\n", "            ", "continue", "\n", "", "_idx_flag", "=", "(", "coo", "[", "i", ",", ":", "]", "==", "s", ")", ".", "view", "(", "-", "1", ")", "\n", "idx_flag", ".", "mul_", "(", "_idx_flag", ")", "\n", "", "idx", "=", "idx_flag", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "not", "preserve_dim", ":", "\n", "        ", "dim_flag", "=", "(", "slice", "==", "-", "1", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "dim_flag", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "coo", "=", "torch", ".", "tensor", "(", "[", "[", "0", "]", "]", ",", "dtype", "=", "coo", ".", "dtype", ",", "device", "=", "device", ")", "\n", "shape", "=", "torch", ".", "Size", "(", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "coo", "=", "coo", "[", ":", ",", "idx", "]", "\n", "coo", "=", "coo", "[", "dim_flag", ",", ":", "]", "\n", "shape", "=", "torch", ".", "Size", "(", "torch", ".", "tensor", "(", "s_t", ".", "shape", ")", "[", "dim_flag", "]", ")", "\n", "", "", "else", ":", "\n", "        ", "coo", "=", "coo", "[", ":", ",", "idx", "]", "\n", "coo", ".", "mul_", "(", "(", "slice", "==", "-", "1", ")", ".", "type", "(", "coo", ".", "dtype", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "_dtype", "=", "torch", ".", "int32", "\n", "shape", "=", "torch", ".", "Size", "(", "torch", ".", "tensor", "(", "s_t", ".", "shape", ",", "dtype", "=", "_dtype", ",", "device", "=", "device", ")", "*", "(", "slice", "==", "-", "1", ")", ".", "type", "(", "_dtype", ")", "\n", "+", "torch", ".", "ones", "(", "len", "(", "s_t", ".", "shape", ")", ",", "dtype", "=", "_dtype", ",", "device", "=", "device", ")", "*", "(", "slice", "!=", "-", "1", ")", ".", "type", "(", "_dtype", ")", ")", "\n", "", "data", "=", "data", "[", "idx", "]", "\n", "\n", "return", "torch", ".", "sparse_coo_tensor", "(", "coo", ",", "data", ",", "shape", ",", "dtype", "=", "s_t", ".", "dtype", ",", "device", "=", "s_t", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sss_bmm_diag_spp": [[333, 354], ["zip", "type", "type", "len", "len", "outp.append", "_m1.dot().diagonal().tocoo", "_m1.dot().diagonal", "_m1.dot"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot"], ["def", "sss_bmm_diag_spp", "(", "s_m1", ",", "s_m2", ")", ":", "\n", "    ", "\"\"\"\n    bmm (Batch Matrix Matrix) for sparse x sparse -> sparse. The diagonalized result is returned in vector tensor.\n    with s_m1.shape = (b, x, s), s_m2.shape = (b, s, x), the output shape is (b, x)\n    This function doesn't support gradient.\n    :param s_m1: sparse matrix 1\n    :param s_m2: sparse matrix 2\n    :return: result in sparse vector\n    \"\"\"", "\n", "if", "type", "(", "s_m1", ")", "!=", "list", ":", "\n", "        ", "s_m1", "=", "[", "s_m1", "]", "\n", "", "if", "type", "(", "s_m2", ")", "!=", "list", ":", "\n", "        ", "s_m2", "=", "[", "s_m2", "]", "\n", "", "assert", "len", "(", "s_m1", ")", "==", "len", "(", "s_m2", ")", ",", "'Batch size mismatch.'", "\n", "\n", "outp", "=", "[", "]", "\n", "for", "_m1", ",", "_m2", "in", "zip", "(", "s_m1", ",", "s_m2", ")", ":", "\n", "        ", "assert", "_m1", ".", "shape", "[", "1", "]", "==", "_m2", ".", "shape", "[", "0", "]", "and", "_m1", ".", "shape", "[", "0", "]", "==", "_m2", ".", "shape", "[", "1", "]", ",", "'Matrix shape mismatch.'", "\n", "outp", ".", "append", "(", "_m1", ".", "dot", "(", "_m2", ")", ".", "diagonal", "(", ")", ".", "tocoo", "(", ")", ")", "\n", "\n", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.ssp2torch": [[361, 401], ["len", "type", "range", "range", "numpy.array", "torch.sparse_coo_tensor", "_M.tocoo.tocoo", "numpy.array", "torch.sparse_coo_tensor.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "_M.tocoo.tocoo", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "torch.Size", "torch.sparse_coo_tensor", "numpy.ones", "list"], "function", ["None"], ["def", "ssp2torch", "(", "M", ",", "batch", "=", "'dim'", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Convert scipy.sparse matrix to torch sparse matrix. Since scipy.sparse has a dimension limit of 2, list of matrices\n    is supported for batches.\n    :param M: input scipy.sparse matrix\n    :param batch: the type that represent batches in the output.\n                  If batch='list', tensors are 2d and stored in list.\n                  If batch='dim', tensors are 3d ane the first dimension represents batch size.\n    :param dtype: output data type\n    :param device: device\n    :return: output torch sparse matrix\n    \"\"\"", "\n", "assert", "batch", "in", "(", "'list'", ",", "'dim'", ")", "\n", "\n", "if", "type", "(", "M", ")", "!=", "list", ":", "\n", "        ", "M", "=", "[", "M", "]", "\n", "", "batch_num", "=", "len", "(", "M", ")", "\n", "\n", "if", "batch", "==", "'list'", ":", "\n", "        ", "outp", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "_M", "=", "M", "[", "i", "]", "\n", "_M", "=", "_M", ".", "tocoo", "(", ")", "\n", "coo", "=", "np", ".", "array", "(", "[", "_M", ".", "row", ",", "_M", ".", "col", "]", ")", "\n", "data", "=", "_M", ".", "data", "\n", "outp", ".", "append", "(", "torch", ".", "sparse_coo_tensor", "(", "coo", ",", "data", ",", "_M", ".", "shape", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "batch", ",", "row", ",", "col", ",", "data", "=", "np", ".", "array", "(", "[", "]", ")", ",", "np", ".", "array", "(", "[", "]", ")", ",", "np", ".", "array", "(", "[", "]", ")", ",", "np", ".", "array", "(", "[", "]", ")", "\n", "for", "i", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "_M", "=", "M", "[", "i", "]", "\n", "_M", "=", "_M", ".", "tocoo", "(", ")", "\n", "batch", "=", "np", ".", "append", "(", "batch", ",", "np", ".", "ones", "(", "_M", ".", "nnz", ")", "*", "i", ")", "\n", "row", "=", "np", ".", "append", "(", "row", ",", "_M", ".", "row", ")", "\n", "col", "=", "np", ".", "append", "(", "col", ",", "_M", ".", "col", ")", "\n", "data", "=", "np", ".", "append", "(", "data", ",", "_M", ".", "data", ")", "\n", "\n", "", "coo", "=", "np", ".", "array", "(", "[", "batch", ",", "row", ",", "col", "]", ")", "\n", "outp", "=", "torch", ".", "sparse_coo_tensor", "(", "coo", ",", "data", ",", "torch", ".", "Size", "(", "[", "batch_num", "]", "+", "list", "(", "_M", ".", "shape", ")", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "\n", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.torch2ssp": [[403, 434], ["type", "len", "range", "M._indices", "M._values", "_M._indices", "_M._values", "ssp.coo_matrix.append", "len", "scipy.coo_matrix", "range", "scipy.coo_matrix", "len", "coo[].view", "data[].view", "ssp.coo_matrix.append", "scipy.coo_matrix"], "function", ["None"], ["", "def", "torch2ssp", "(", "M", ")", ":", "\n", "    ", "\"\"\"\n    Convert torch sparse matrix to scipy.sparse matrix. Since scipy.sparse has a dimension limit of 2, batches are\n    represented in list in the output.\n    :param M: input torch sparse matrix\n    :return: output scipy.sparse matrix\n    \"\"\"", "\n", "if", "type", "(", "M", ")", "==", "list", ":", "\n", "        ", "batch_num", "=", "len", "(", "M", ")", "\n", "outp", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "_M", "=", "M", "[", "b", "]", "\n", "_coo", "=", "_M", ".", "_indices", "(", ")", "\n", "_data", "=", "_M", ".", "_values", "(", ")", "\n", "outp", ".", "append", "(", "ssp", ".", "coo_matrix", "(", "(", "_data", ",", "_coo", ")", ",", "_M", ".", "shape", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "coo", "=", "M", ".", "_indices", "(", ")", "\n", "data", "=", "M", ".", "_values", "(", ")", "\n", "batch_num", "=", "M", ".", "shape", "[", "0", "]", "\n", "\n", "if", "len", "(", "M", ".", "shape", ")", "==", "2", ":", "\n", "            ", "outp", "=", "ssp", ".", "coo_matrix", "(", "(", "data", ",", "coo", ")", ",", "M", ".", "shape", ")", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "M", ".", "shape", ")", "==", "3", "\n", "outp", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "                ", "idx", "=", "(", "coo", "[", "0", ",", ":", "]", "==", "b", ")", ".", "nonzero", "(", ")", "\n", "_coo", "=", "coo", "[", "1", ":", "3", ",", "idx", "]", ".", "view", "(", "2", ",", "-", "1", ")", "\n", "_data", "=", "data", "[", "idx", "]", ".", "view", "(", "-", "1", ")", "\n", "outp", ".", "append", "(", "ssp", ".", "coo_matrix", "(", "(", "_data", ",", "_coo", ")", ",", "M", ".", "shape", "[", "1", ":", "3", "]", ")", ")", "\n", "", "", "", "return", "outp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.recover_ssp": [[436, 459], ["numpy.zeros", "range", "range", "t_dict[].numpy", "[].astype", "max", "max", "scipy.coo_matrix", "ss.append"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy"], ["", "def", "recover_ssp", "(", "t_dict", ")", ":", "\n", "    ", "\"\"\"\n    Recover scipy.sparse coo_matrix from a dictionary containing row, col and data tensors.\n    :param t_dict: containing keys\n                   'row', 'col', 'data', each corresponds to a bxn tensor\n                   'shape', containing the MxN shape of each tensor\n    :return: list of scipy.sparse matrix. list indices represent batches.\n    \"\"\"", "\n", "batch_size", "=", "t_dict", "[", "'row'", "]", ".", "shape", "[", "0", "]", "\n", "np_dict", "=", "{", "key", ":", "t_dict", "[", "key", "]", ".", "numpy", "(", ")", "for", "key", "in", "t_dict", "}", "\n", "ss", "=", "[", "]", "\n", "max_shape", "=", "np", ".", "zeros", "(", "(", "2", ",", ")", ",", "dtype", "=", "np", ".", "int", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "shape", "=", "np_dict", "[", "'shape'", "]", "[", "b", "]", ".", "astype", "(", "np", ".", "int", ")", "\n", "max_shape", "[", "0", "]", "=", "max", "(", "shape", "[", "0", "]", ",", "max_shape", "[", "0", "]", ")", "\n", "max_shape", "[", "1", "]", "=", "max", "(", "shape", "[", "1", "]", ",", "max_shape", "[", "1", "]", ")", "\n", "", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "        ", "data", "=", "np_dict", "[", "'data'", "]", "[", "b", "]", "\n", "row", "=", "np_dict", "[", "'row'", "]", "[", "b", "]", "\n", "col", "=", "np_dict", "[", "'col'", "]", "[", "b", "]", "\n", "_ss", "=", "ssp", ".", "coo_matrix", "(", "(", "data", ",", "(", "row", ",", "col", ")", ")", ",", "shape", "=", "max_shape", ")", "\n", "ss", ".", "append", "(", "_ss", ")", "\n", "", "return", "ss", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.save_model": [[5, 10], ["isinstance", "torch.save", "model.state_dict"], "function", ["None"], ["def", "save_model", "(", "model", ",", "path", ")", ":", "\n", "    ", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "\n", "", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.model_sl.load_model": [[12, 24], ["isinstance", "module.load_state_dict", "torch.load", "len", "print", "len", "print"], "function", ["None"], ["", "def", "load_model", "(", "model", ",", "path", ",", "strict", "=", "True", ")", ":", "\n", "    ", "if", "isinstance", "(", "model", ",", "DataParallel", ")", ":", "\n", "        ", "module", "=", "model", ".", "module", "\n", "", "else", ":", "\n", "        ", "module", "=", "model", "\n", "", "missing_keys", ",", "unexpected_keys", "=", "module", ".", "load_state_dict", "(", "torch", ".", "load", "(", "path", ")", ",", "strict", "=", "strict", ")", "\n", "if", "len", "(", "unexpected_keys", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Warning: Unexpected key(s) in state_dict: {}. '", ".", "format", "(", "\n", "', '", ".", "join", "(", "'\"{}\"'", ".", "format", "(", "k", ")", "for", "k", "in", "unexpected_keys", ")", ")", ")", "\n", "", "if", "len", "(", "missing_keys", ")", ">", "0", ":", "\n", "        ", "print", "(", "'Warning: Missing key(s) in state_dict: {}. '", ".", "format", "(", "\n", "', '", ".", "join", "(", "'\"{}\"'", ".", "format", "(", "k", ")", "for", "k", "in", "missing_keys", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.__init__": [[5, 10], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "stdout", ",", "path", ",", "mode", ")", ":", "\n", "        ", "self", ".", "path", "=", "path", "\n", "self", ".", "_content", "=", "''", "\n", "self", ".", "_stdout", "=", "stdout", "\n", "self", ".", "_file", "=", "open", "(", "path", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write": [[11, 20], ["msg.find", "dup_stdout_manager.DupStdoutFileWriter.flush", "len", "dup_stdout_manager.DupStdoutFileWriter.flush"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.flush", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.flush"], ["", "def", "write", "(", "self", ",", "msg", ")", ":", "\n", "        ", "while", "'\\n'", "in", "msg", ":", "\n", "            ", "pos", "=", "msg", ".", "find", "(", "'\\n'", ")", "\n", "self", ".", "_content", "+=", "msg", "[", ":", "pos", "+", "1", "]", "\n", "self", ".", "flush", "(", ")", "\n", "msg", "=", "msg", "[", "pos", "+", "1", ":", "]", "\n", "", "self", ".", "_content", "+=", "msg", "\n", "if", "len", "(", "self", ".", "_content", ")", ">", "1000", ":", "\n", "            ", "self", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.flush": [[21, 27], ["dup_stdout_manager.DupStdoutFileWriter._stdout.write", "dup_stdout_manager.DupStdoutFileWriter._stdout.flush", "dup_stdout_manager.DupStdoutFileWriter._file.write", "dup_stdout_manager.DupStdoutFileWriter._file.flush"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.flush", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.flush"], ["", "", "def", "flush", "(", "self", ")", ":", "\n", "        ", "self", ".", "_stdout", ".", "write", "(", "self", ".", "_content", ")", "\n", "self", ".", "_stdout", ".", "flush", "(", ")", "\n", "self", ".", "_file", ".", "write", "(", "self", ".", "_content", ")", "\n", "self", ".", "_file", ".", "flush", "(", ")", "\n", "self", ".", "_content", "=", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.__del__": [[28, 30], ["dup_stdout_manager.DupStdoutFileWriter._file.close"], "methods", ["None"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileManager.__init__": [[33, 36], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "path", ",", "mode", "=", "'w+'", ")", ":", "\n", "        ", "self", ".", "path", "=", "path", "\n", "self", ".", "mode", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileManager.__enter__": [[37, 41], ["dup_stdout_manager.DupStdoutFileWriter"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_stdout", "=", "sys", ".", "stdout", "\n", "self", ".", "_file", "=", "DupStdoutFileWriter", "(", "self", ".", "_stdout", ",", "self", ".", "path", ",", "self", ".", "mode", ")", "\n", "sys", ".", "stdout", "=", "self", ".", "_file", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileManager.__exit__": [[42, 44], ["None"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_value", ",", "traceback", ")", ":", "\n", "        ", "sys", ".", "stdout", "=", "self", ".", "_stdout", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.gpu_memory.gpu_free_memory": [[5, 17], ["torch.cuda.empty_cache", "nvmlDeviceGetMemoryInfo", "nvmlDeviceGetHandleByIndex"], "function", ["None"], ["def", "gpu_free_memory", "(", "device_id", ")", ":", "\n", "    ", "\"\"\"\n    Return total amount of available memory in Bytes\n    :param device_id: GPU device id (int)\n    :return: total amount of available memory in Bytes\n    \"\"\"", "\n", "#ree = nvmlDeviceGetMemoryInfo(nvmlDeviceGetHandleByIndex(device_id)).free", "\n", "#rsvd = torch.cuda.memory_reserved(device_id)", "\n", "#used = torch.cuda.memory_allocated(device_id)", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "free", "=", "nvmlDeviceGetMemoryInfo", "(", "nvmlDeviceGetHandleByIndex", "(", "device_id", ")", ")", ".", "free", "\n", "return", "free", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda": [[5, 35], ["type", "enumerate", "data_to_cuda.data_to_cuda", "type", "list", "enumerate", "data_to_cuda.data_to_cuda", "type", "data_to_cuda.data_to_cuda", "type", "type", "inputs.to.cuda", "type", "inputs.to.to", "TypeError", "type"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.data_to_cuda.data_to_cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["def", "data_to_cuda", "(", "inputs", ")", ":", "\n", "    ", "\"\"\"\n    Call cuda() on all tensor elements in inputs\n    :param inputs: input list/dictionary\n    :return: identical to inputs while all its elements are on cuda\n    \"\"\"", "\n", "if", "type", "(", "inputs", ")", "is", "list", ":", "\n", "        ", "for", "i", ",", "x", "in", "enumerate", "(", "inputs", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "data_to_cuda", "(", "x", ")", "\n", "", "", "elif", "type", "(", "inputs", ")", "is", "tuple", ":", "\n", "        ", "inputs", "=", "list", "(", "inputs", ")", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "inputs", ")", ":", "\n", "            ", "inputs", "[", "i", "]", "=", "data_to_cuda", "(", "x", ")", "\n", "", "", "elif", "type", "(", "inputs", ")", "is", "dict", ":", "\n", "        ", "for", "key", "in", "inputs", ":", "\n", "            ", "inputs", "[", "key", "]", "=", "data_to_cuda", "(", "inputs", "[", "key", "]", ")", "\n", "", "", "elif", "type", "(", "inputs", ")", "in", "[", "str", ",", "int", ",", "float", "]", ":", "\n", "        ", "inputs", "=", "inputs", "\n", "", "elif", "type", "(", "inputs", ")", "in", "[", "torch", ".", "Tensor", ",", "CSRMatrix3d", ",", "CSCMatrix3d", "]", ":", "\n", "        ", "inputs", "=", "inputs", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "pyg_datatypes", "=", "[", "pyg", ".", "data", ".", "Data", ",", "pyg", ".", "data", ".", "Batch", ",", "pyg", ".", "data", ".", "batch", ".", "DataBatch", "]", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pyg_datatypes", "=", "[", "pyg", ".", "data", ".", "Data", ",", "pyg", ".", "data", ".", "Batch", "]", "\n", "", "if", "type", "(", "inputs", ")", "in", "pyg_datatypes", ":", "\n", "            ", "inputs", "=", "inputs", ".", "to", "(", "'cuda'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'Unknown type of inputs: {}'", ".", "format", "(", "type", "(", "inputs", ")", ")", ")", "\n", "", "", "return", "inputs", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.count_model_params.count_parameters": [[3, 5], ["numpy.sum", "numpy.prod", "v.size", "model.named_parameters"], "function", ["None"], ["def", "count_parameters", "(", "model", ")", ":", "\n", "  ", "return", "np", ".", "sum", "(", "np", ".", "prod", "(", "v", ".", "size", "(", ")", ")", "for", "name", ",", "v", "in", "model", ".", "named_parameters", "(", ")", "if", "\"auxiliary\"", "not", "in", "name", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.__init__": [[45, 55], ["torch.Module.__init__", "print"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", ":", "int", "=", "10", ",", "tau", ":", "float", "=", "1.", ",", "epsilon", ":", "float", "=", "1e-4", ",", "\n", "log_forward", ":", "bool", "=", "True", ",", "batched_operation", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", "Sinkhorn", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "tau", "=", "tau", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "log_forward", "=", "log_forward", "\n", "if", "not", "log_forward", ":", "\n", "            ", "print", "(", "'Warning: Sinkhorn algorithm without log forward is deprecated because log_forward is more stable.'", ")", "\n", "", "self", ".", "batched_operation", "=", "batched_operation", "# batched operation may cause instability in backward computation,", "\n", "# but will boost computation.", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.forward": [[57, 83], ["sinkhorn.Sinkhorn.forward_log", "sinkhorn.Sinkhorn.forward_ori"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.forward_log", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.forward_ori"], ["", "def", "forward", "(", "self", ",", "s", ":", "Tensor", ",", "nrows", ":", "Tensor", "=", "None", ",", "ncols", ":", "Tensor", "=", "None", ",", "dummy_row", ":", "bool", "=", "False", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param s: :math:`(b\\times n_1 \\times n_2)` input 3d tensor. :math:`b`: batch size\n        :param nrows: :math:`(b)` number of objects in dim1\n        :param ncols: :math:`(b)` number of objects in dim2\n        :param dummy_row: whether to add dummy rows (rows whose elements are all 0) to pad the matrix to square matrix.\n         default: ``False``\n        :return: :math:`(b\\times n_1 \\times n_2)` the computed doubly-stochastic matrix\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``nrows`` and ``ncols`` are\n            required to specify the exact number of objects of each dimension in the batch. If not specified, we assume\n            the batched matrices are not padded.\n\n        .. note::\n            The original Sinkhorn algorithm only works for square matrices. To handle cases where the graphs to be\n            matched have different number of nodes, it is a common practice to add dummy rows to construct a square\n            matrix. After the row and column normalizations, the padded rows are discarded.\n\n        .. note::\n            We assume row number <= column number. If not, the input matrix will be transposed.\n        \"\"\"", "\n", "if", "self", ".", "log_forward", ":", "\n", "            ", "return", "self", ".", "forward_log", "(", "s", ",", "nrows", ",", "ncols", ",", "dummy_row", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "forward_ori", "(", "s", ",", "nrows", ",", "ncols", ",", "dummy_row", ")", "# deprecated", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.forward_log": [[84, 177], ["len", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.cat.transpose", "torch.cat.transpose", "list", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "range", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.full", "torch.full", "torch.full", "torch.full", "range", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "len", "ValueError", "range", "log_s.squeeze_", "slice", "slice", "range", "range", "ret_log_s.transpose.transpose.transpose", "ret_log_s.transpose.transpose.squeeze_", "range", "range", "torch.full().to", "torch.full().to", "torch.full().to", "torch.full().to", "float", "float", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "float", "float", "float", "float", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "float", "torch.full", "torch.full", "torch.full", "torch.full", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "float"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "", "def", "forward_log", "(", "self", ",", "s", ",", "nrows", "=", "None", ",", "ncols", "=", "None", ",", "dummy_row", "=", "False", ")", ":", "\n", "        ", "\"\"\"Compute sinkhorn with row/column normalization in the log space.\"\"\"", "\n", "if", "len", "(", "s", ".", "shape", ")", "==", "2", ":", "\n", "            ", "s", "=", "s", ".", "unsqueeze", "(", "0", ")", "\n", "matrix_input", "=", "True", "\n", "", "elif", "len", "(", "s", ".", "shape", ")", "==", "3", ":", "\n", "            ", "matrix_input", "=", "False", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'input data shape not understood.'", ")", "\n", "\n", "", "batch_size", "=", "s", ".", "shape", "[", "0", "]", "\n", "\n", "if", "s", ".", "shape", "[", "2", "]", ">=", "s", ".", "shape", "[", "1", "]", ":", "\n", "            ", "transposed", "=", "False", "\n", "", "else", ":", "\n", "            ", "s", "=", "s", ".", "transpose", "(", "1", ",", "2", ")", "\n", "nrows", ",", "ncols", "=", "ncols", ",", "nrows", "\n", "transposed", "=", "True", "\n", "\n", "", "if", "nrows", "is", "None", ":", "\n", "            ", "nrows", "=", "[", "s", ".", "shape", "[", "1", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "", "if", "ncols", "is", "None", ":", "\n", "            ", "ncols", "=", "[", "s", ".", "shape", "[", "2", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "\n", "# operations are performed on log_s", "\n", "", "s", "=", "s", "/", "self", ".", "tau", "\n", "\n", "if", "dummy_row", ":", "\n", "            ", "assert", "s", ".", "shape", "[", "2", "]", ">=", "s", ".", "shape", "[", "1", "]", "\n", "dummy_shape", "=", "list", "(", "s", ".", "shape", ")", "\n", "dummy_shape", "[", "1", "]", "=", "s", ".", "shape", "[", "2", "]", "-", "s", ".", "shape", "[", "1", "]", "\n", "ori_nrows", "=", "nrows", "\n", "nrows", "=", "ncols", "\n", "s", "=", "torch", ".", "cat", "(", "(", "s", ",", "torch", ".", "full", "(", "dummy_shape", ",", "-", "float", "(", "'inf'", ")", ")", ".", "to", "(", "s", ".", "device", ")", ")", ",", "dim", "=", "1", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "s", "[", "b", ",", "ori_nrows", "[", "b", "]", ":", "nrows", "[", "b", "]", ",", ":", "ncols", "[", "b", "]", "]", "=", "-", "100", "\n", "s", "[", "b", ",", "nrows", "[", "b", "]", ":", ",", ":", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "s", "[", "b", ",", ":", ",", "ncols", "[", "b", "]", ":", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "\n", "", "", "if", "self", ".", "batched_operation", ":", "\n", "            ", "log_s", "=", "s", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "                ", "if", "i", "%", "2", "==", "0", ":", "\n", "                    ", "log_sum", "=", "torch", ".", "logsumexp", "(", "log_s", ",", "2", ",", "keepdim", "=", "True", ")", "\n", "log_s", "=", "log_s", "-", "log_sum", "\n", "log_s", "[", "torch", ".", "isnan", "(", "log_s", ")", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "", "else", ":", "\n", "                    ", "log_sum", "=", "torch", ".", "logsumexp", "(", "log_s", ",", "1", ",", "keepdim", "=", "True", ")", "\n", "log_s", "=", "log_s", "-", "log_sum", "\n", "log_s", "[", "torch", ".", "isnan", "(", "log_s", ")", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "\n", "# ret_log_s[b, row_slice, col_slice] = log_s", "\n", "\n", "", "", "if", "dummy_row", "and", "dummy_shape", "[", "1", "]", ">", "0", ":", "\n", "                ", "log_s", "=", "log_s", "[", ":", ",", ":", "-", "dummy_shape", "[", "1", "]", "]", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "log_s", "[", "b", ",", "ori_nrows", "[", "b", "]", ":", "nrows", "[", "b", "]", ",", ":", "ncols", "[", "b", "]", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "\n", "", "", "if", "matrix_input", ":", "\n", "                ", "log_s", ".", "squeeze_", "(", "0", ")", "\n", "\n", "", "return", "torch", ".", "exp", "(", "log_s", ")", "\n", "", "else", ":", "\n", "            ", "ret_log_s", "=", "torch", ".", "full", "(", "(", "batch_size", ",", "s", ".", "shape", "[", "1", "]", ",", "s", ".", "shape", "[", "2", "]", ")", ",", "-", "float", "(", "'inf'", ")", ",", "device", "=", "s", ".", "device", ",", "dtype", "=", "s", ".", "dtype", ")", "\n", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "row_slice", "=", "slice", "(", "0", ",", "nrows", "[", "b", "]", ")", "\n", "col_slice", "=", "slice", "(", "0", ",", "ncols", "[", "b", "]", ")", "\n", "log_s", "=", "s", "[", "b", ",", "row_slice", ",", "col_slice", "]", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "                    ", "if", "i", "%", "2", "==", "0", ":", "\n", "                        ", "log_sum", "=", "torch", ".", "logsumexp", "(", "log_s", ",", "1", ",", "keepdim", "=", "True", ")", "\n", "log_s", "=", "log_s", "-", "log_sum", "\n", "", "else", ":", "\n", "                        ", "log_sum", "=", "torch", ".", "logsumexp", "(", "log_s", ",", "0", ",", "keepdim", "=", "True", ")", "\n", "log_s", "=", "log_s", "-", "log_sum", "\n", "\n", "", "", "ret_log_s", "[", "b", ",", "row_slice", ",", "col_slice", "]", "=", "log_s", "\n", "\n", "", "if", "dummy_row", ":", "\n", "                ", "if", "dummy_shape", "[", "1", "]", ">", "0", ":", "\n", "                    ", "ret_log_s", "=", "ret_log_s", "[", ":", ",", ":", "-", "dummy_shape", "[", "1", "]", "]", "\n", "", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "ret_log_s", "[", "b", ",", "ori_nrows", "[", "b", "]", ":", "nrows", "[", "b", "]", ",", ":", "ncols", "[", "b", "]", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "\n", "", "", "if", "transposed", ":", "\n", "                ", "ret_log_s", "=", "ret_log_s", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "if", "matrix_input", ":", "\n", "                ", "ret_log_s", ".", "squeeze_", "(", "0", ")", "\n", "\n", "", "return", "torch", ".", "exp", "(", "ret_log_s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.Sinkhorn.forward_ori": [[185, 266], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "range", "len", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.functional.softmax", "torch.functional.softmax", "list", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "slice", "slice", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "range", "torch.cat.squeeze_", "torch.cat.squeeze_", "len", "ValueError", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "slice", "slice", "range", "range", "torch.full().to", "torch.full().to", "torch.full().to", "torch.full().to", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.zeros.unsqueeze", "torch.zeros.unsqueeze", "torch.zeros.unsqueeze", "torch.zeros.unsqueeze", "torch.cat.unsqueeze", "torch.cat.unsqueeze", "torch.full", "torch.full", "torch.full", "torch.full"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "", "def", "forward_ori", "(", "self", ",", "s", ",", "nrows", "=", "None", ",", "ncols", "=", "None", ",", "dummy_row", "=", "False", ")", ":", "\n", "        ", "r\"\"\"\n        Computing sinkhorn with row/column normalization.\n\n        .. warning::\n            This function is deprecated because :meth:`~src.lap_solvers.sinkhorn.Sinkhorn.forward_log` is more\n            numerically stable.\n        \"\"\"", "\n", "if", "len", "(", "s", ".", "shape", ")", "==", "2", ":", "\n", "            ", "s", "=", "s", ".", "unsqueeze", "(", "0", ")", "\n", "matrix_input", "=", "True", "\n", "", "elif", "len", "(", "s", ".", "shape", ")", "==", "3", ":", "\n", "            ", "matrix_input", "=", "False", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'input data shape not understood.'", ")", "\n", "\n", "", "batch_size", "=", "s", ".", "shape", "[", "0", "]", "\n", "\n", "#s = s.to(dtype=dtype)", "\n", "\n", "if", "nrows", "is", "None", ":", "\n", "            ", "nrows", "=", "[", "s", ".", "shape", "[", "1", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "", "if", "ncols", "is", "None", ":", "\n", "            ", "ncols", "=", "[", "s", ".", "shape", "[", "2", "]", "for", "_", "in", "range", "(", "batch_size", ")", "]", "\n", "\n", "# tau scaling", "\n", "", "ret_s", "=", "torch", ".", "zeros_like", "(", "s", ")", "\n", "for", "b", ",", "n", "in", "enumerate", "(", "nrows", ")", ":", "\n", "            ", "ret_s", "[", "b", ",", "0", ":", "n", ",", "0", ":", "ncols", "[", "b", "]", "]", "=", "nn", ".", "functional", ".", "softmax", "(", "s", "[", "b", ",", "0", ":", "n", ",", "0", ":", "ncols", "[", "b", "]", "]", "/", "self", ".", "tau", ",", "dim", "=", "-", "1", ")", "\n", "", "s", "=", "ret_s", "\n", "\n", "# add dummy elements", "\n", "if", "dummy_row", ":", "\n", "            ", "dummy_shape", "=", "list", "(", "s", ".", "shape", ")", "\n", "dummy_shape", "[", "1", "]", "=", "s", ".", "shape", "[", "2", "]", "-", "s", ".", "shape", "[", "1", "]", "\n", "#s = torch.cat((s, torch.full(dummy_shape, self.epsilon * 10).to(s.device)), dim=1)", "\n", "#nrows = nrows + dummy_shape[1] # non in-place", "\n", "s", "=", "torch", ".", "cat", "(", "(", "s", ",", "torch", ".", "full", "(", "dummy_shape", ",", "0.", ")", ".", "to", "(", "s", ".", "device", ")", ")", ",", "dim", "=", "1", ")", "\n", "ori_nrows", "=", "nrows", "\n", "nrows", "=", "ncols", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "s", "[", "b", ",", "ori_nrows", "[", "b", "]", ":", "nrows", "[", "b", "]", ",", ":", "ncols", "[", "b", "]", "]", "=", "self", ".", "epsilon", "\n", "\n", "", "", "row_norm_ones", "=", "torch", ".", "zeros", "(", "batch_size", ",", "s", ".", "shape", "[", "1", "]", ",", "s", ".", "shape", "[", "1", "]", ",", "device", "=", "s", ".", "device", ",", "dtype", "=", "s", ".", "dtype", ")", "# size: row x row", "\n", "col_norm_ones", "=", "torch", ".", "zeros", "(", "batch_size", ",", "s", ".", "shape", "[", "2", "]", ",", "s", ".", "shape", "[", "2", "]", ",", "device", "=", "s", ".", "device", ",", "dtype", "=", "s", ".", "dtype", ")", "# size: col x col", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "row_slice", "=", "slice", "(", "0", ",", "nrows", "[", "b", "]", ")", "\n", "col_slice", "=", "slice", "(", "0", ",", "ncols", "[", "b", "]", ")", "\n", "row_norm_ones", "[", "b", ",", "row_slice", ",", "row_slice", "]", "=", "1", "\n", "col_norm_ones", "[", "b", ",", "col_slice", ",", "col_slice", "]", "=", "1", "\n", "\n", "", "s", "+=", "self", ".", "epsilon", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "if", "i", "%", "2", "==", "0", ":", "\n", "# column norm", "\n", "#ones = torch.ones(batch_size, s.shape[1], s.shape[1], device=s.device)", "\n", "                ", "sum", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "s", ".", "unsqueeze", "(", "3", ")", ",", "col_norm_ones", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "# row norm", "\n", "# ones = torch.ones(batch_size, s.shape[2], s.shape[2], device=s.device)", "\n", "                ", "sum", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "row_norm_ones", ".", "unsqueeze", "(", "3", ")", ",", "s", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "2", ")", "\n", "\n", "", "tmp", "=", "torch", ".", "zeros_like", "(", "s", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "row_slice", "=", "slice", "(", "0", ",", "nrows", "[", "b", "]", "if", "nrows", "is", "not", "None", "else", "s", ".", "shape", "[", "2", "]", ")", "\n", "col_slice", "=", "slice", "(", "0", ",", "ncols", "[", "b", "]", "if", "ncols", "is", "not", "None", "else", "s", ".", "shape", "[", "1", "]", ")", "\n", "tmp", "[", "b", ",", "row_slice", ",", "col_slice", "]", "=", "1", "/", "sum", "[", "b", ",", "row_slice", ",", "col_slice", "]", "\n", "", "s", "=", "s", "*", "tmp", "\n", "\n", "", "if", "dummy_row", ":", "\n", "            ", "if", "dummy_shape", "[", "1", "]", ">", "0", ":", "\n", "                ", "s", "=", "s", "[", ":", ",", ":", "-", "dummy_shape", "[", "1", "]", "]", "\n", "", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "s", "[", "b", ",", "ori_nrows", "[", "b", "]", ":", "nrows", "[", "b", "]", ",", ":", "ncols", "[", "b", "]", "]", "=", "0", "\n", "\n", "", "", "if", "matrix_input", ":", "\n", "            ", "s", ".", "squeeze_", "(", "0", ")", "\n", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.GumbelSinkhorn.__init__": [[283, 286], ["torch.Module.__init__", "sinkhorn.Sinkhorn"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", "=", "10", ",", "tau", "=", "1.", ",", "epsilon", "=", "1e-4", ",", "batched_operation", "=", "False", ")", ":", "\n", "        ", "super", "(", "GumbelSinkhorn", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", ",", "tau", ",", "epsilon", ",", "batched_operation", "=", "batched_operation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.sinkhorn.GumbelSinkhorn.forward": [[287, 332], ["torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "sinkhorn.GumbelSinkhorn.sinkhorn", "torch.empty_like().uniform_", "torch.empty_like().uniform_", "torch.empty_like().uniform_", "torch.empty_like().uniform_", "sinkhorn.GumbelSinkhorn.forward.sample_gumbel"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "s", ":", "Tensor", ",", "nrows", ":", "Tensor", "=", "None", ",", "ncols", ":", "Tensor", "=", "None", ",", "\n", "sample_num", "=", "5", ",", "dummy_row", "=", "False", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        :param s: :math:`(b\\times n_1 \\times n_2)` input 3d tensor. :math:`b`: batch size\n        :param nrows: :math:`(b)` number of objects in dim1\n        :param ncols: :math:`(b)` number of objects in dim2\n        :param sample_num: number of samples\n        :param dummy_row: whether to add dummy rows (rows whose elements are all 0) to pad the matrix to square matrix.\n         default: ``False``\n        :return: :math:`(b m\\times n_1 \\times n_2)` the computed doubly-stochastic matrix. :math:`m`: number of samples\n         (``sample_num``)\n\n        The samples are stacked at the fist dimension of the output tensor. You may reshape the output tensor ``s`` as:\n\n        ::\n\n            s = torch.reshape(s, (-1, sample_num, s.shape[1], s.shape[2]))\n\n        .. note::\n            We support batched instances with different number of nodes, therefore ``nrows`` and ``ncols`` are\n            required to specify the exact number of objects of each dimension in the batch. If not specified, we assume\n            the batched matrices are not padded.\n\n        .. note::\n            The original Sinkhorn algorithm only works for square matrices. To handle cases where the graphs to be\n            matched have different number of nodes, it is a common practice to add dummy rows to construct a square\n            matrix. After the row and column normalizations, the padded rows are discarded.\n\n        .. note::\n            We assume row number <= column number. If not, the input matrix will be transposed.\n        \"\"\"", "\n", "def", "sample_gumbel", "(", "t_like", ",", "eps", "=", "1e-20", ")", ":", "\n", "            ", "\"\"\"\n            randomly sample standard gumbel variables\n            \"\"\"", "\n", "u", "=", "torch", ".", "empty_like", "(", "t_like", ")", ".", "uniform_", "(", ")", "\n", "return", "-", "torch", ".", "log", "(", "-", "torch", ".", "log", "(", "u", "+", "eps", ")", "+", "eps", ")", "\n", "\n", "", "s_rep", "=", "torch", ".", "repeat_interleave", "(", "s", ",", "sample_num", ",", "dim", "=", "0", ")", "\n", "s_rep", "=", "s_rep", "+", "sample_gumbel", "(", "s_rep", ")", "\n", "nrows_rep", "=", "torch", ".", "repeat_interleave", "(", "nrows", ",", "sample_num", ",", "dim", "=", "0", ")", "\n", "ncols_rep", "=", "torch", ".", "repeat_interleave", "(", "ncols", ",", "sample_num", ",", "dim", "=", "0", ")", "\n", "s_rep", "=", "self", ".", "sinkhorn", "(", "s_rep", ",", "nrows_rep", ",", "ncols_rep", ",", "dummy_row", ")", "\n", "#s_rep = torch.reshape(s_rep, (-1, sample_num, s_rep.shape[1], s_rep.shape[2]))", "\n", "return", "s_rep", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian": [[8, 57], ["torch.from_numpy().to", "len", "s.unsqueeze.unsqueeze", "s.unsqueeze.cpu().detach().numpy", "n1.cpu().numpy.cpu().numpy", "n2.cpu().numpy.cpu().numpy", "numpy.stack", "np.stack.squeeze_", "len", "ValueError", "multiprocessing.Pool", "pool.starmap_async", "numpy.stack", "torch.from_numpy", "s.unsqueeze.cpu().detach", "n1.cpu().numpy.cpu", "n2.cpu().numpy.cpu", "zip", "pool.starmap_async.get", "hungarian._hung_kernel", "range", "s.unsqueeze.cpu"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian._hung_kernel", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["def", "hungarian", "(", "s", ":", "Tensor", ",", "n1", ":", "Tensor", "=", "None", ",", "n2", ":", "Tensor", "=", "None", ",", "nproc", ":", "int", "=", "1", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Solve optimal LAP permutation by hungarian algorithm. The time cost is :math:`O(n^3)`.\n\n    :param s: :math:`(b\\times n_1 \\times n_2)` input 3d tensor. :math:`b`: batch size\n    :param n1: :math:`(b)` number of objects in dim1\n    :param n2: :math:`(b)` number of objects in dim2\n    :param nproc: number of parallel processes (default: ``nproc=1`` for no parallel)\n    :return: :math:`(b\\times n_1 \\times n_2)` optimal permutation matrix\n\n    .. note::\n        We support batched instances with different number of nodes, therefore ``n1`` and ``n2`` are\n        required to specify the exact number of objects of each dimension in the batch. If not specified, we assume\n        the batched matrices are not padded.\n    \"\"\"", "\n", "if", "len", "(", "s", ".", "shape", ")", "==", "2", ":", "\n", "        ", "s", "=", "s", ".", "unsqueeze", "(", "0", ")", "\n", "matrix_input", "=", "True", "\n", "", "elif", "len", "(", "s", ".", "shape", ")", "==", "3", ":", "\n", "        ", "matrix_input", "=", "False", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'input data shape not understood: {}'", ".", "format", "(", "s", ".", "shape", ")", ")", "\n", "\n", "", "device", "=", "s", ".", "device", "\n", "batch_num", "=", "s", ".", "shape", "[", "0", "]", "\n", "\n", "perm_mat", "=", "s", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "*", "-", "1", "\n", "if", "n1", "is", "not", "None", ":", "\n", "        ", "n1", "=", "n1", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "n1", "=", "[", "None", "]", "*", "batch_num", "\n", "", "if", "n2", "is", "not", "None", ":", "\n", "        ", "n2", "=", "n2", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "n2", "=", "[", "None", "]", "*", "batch_num", "\n", "\n", "", "if", "nproc", ">", "1", ":", "\n", "        ", "with", "Pool", "(", "processes", "=", "nproc", ")", "as", "pool", ":", "\n", "            ", "mapresult", "=", "pool", ".", "starmap_async", "(", "_hung_kernel", ",", "zip", "(", "perm_mat", ",", "n1", ",", "n2", ")", ")", "\n", "perm_mat", "=", "np", ".", "stack", "(", "mapresult", ".", "get", "(", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "perm_mat", "=", "np", ".", "stack", "(", "[", "_hung_kernel", "(", "perm_mat", "[", "b", "]", ",", "n1", "[", "b", "]", ",", "n2", "[", "b", "]", ")", "for", "b", "in", "range", "(", "batch_num", ")", "]", ")", "\n", "\n", "", "perm_mat", "=", "torch", ".", "from_numpy", "(", "perm_mat", ")", ".", "to", "(", "device", ")", "\n", "\n", "if", "matrix_input", ":", "\n", "        ", "perm_mat", ".", "squeeze_", "(", "0", ")", "\n", "\n", "", "return", "perm_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian._hung_kernel": [[58, 67], ["scipy.linear_sum_assignment", "numpy.zeros_like"], "function", ["None"], ["", "def", "_hung_kernel", "(", "s", ":", "torch", ".", "Tensor", ",", "n1", "=", "None", ",", "n2", "=", "None", ")", ":", "\n", "    ", "if", "n1", "is", "None", ":", "\n", "        ", "n1", "=", "s", ".", "shape", "[", "0", "]", "\n", "", "if", "n2", "is", "None", ":", "\n", "        ", "n2", "=", "s", ".", "shape", "[", "1", "]", "\n", "", "row", ",", "col", "=", "opt", ".", "linear_sum_assignment", "(", "s", "[", ":", "n1", ",", ":", "n2", "]", ")", "\n", "perm_mat", "=", "np", ".", "zeros_like", "(", "s", ")", "\n", "perm_mat", "[", "row", ",", "col", "]", "=", "1", "\n", "return", "perm_mat", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.__init__": [[19, 49], ["data_loader.GMDataset.bm.compute_img_num", "data_loader.GMDataset.bm.compute_img_num", "data_loader.GMDataset.bm.get_id_combination", "list", "data_loader.GMDataset.bm.compute_length", "data_loader.GMDataset.length_list.append", "itertools.combinations"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "bm", ",", "length", ",", "using_all_graphs", "=", "False", ",", "cls", "=", "None", ",", "problem", "=", "'2GM'", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "bm", "=", "bm", "\n", "self", ".", "using_all_graphs", "=", "using_all_graphs", "\n", "self", ".", "obj_size", "=", "self", ".", "bm", ".", "obj_resize", "\n", "self", ".", "test", "=", "True", "if", "self", ".", "bm", ".", "sets", "==", "'test'", "else", "False", "\n", "self", ".", "cls", "=", "None", "if", "cls", "in", "[", "'none'", ",", "'all'", "]", "else", "cls", "\n", "\n", "if", "self", ".", "cls", "is", "None", ":", "\n", "            ", "if", "problem", "==", "'MGM3'", ":", "\n", "                ", "self", ".", "classes", "=", "list", "(", "combinations", "(", "self", ".", "bm", ".", "classes", ",", "cfg", ".", "PROBLEM", ".", "NUM_CLUSTERS", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "classes", "=", "self", ".", "bm", ".", "classes", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "classes", "=", "[", "self", ".", "cls", "]", "\n", "\n", "", "self", ".", "problem_type", "=", "problem", "\n", "if", "problem", "!=", "'MGM3'", ":", "\n", "            ", "self", ".", "img_num_list", "=", "self", ".", "bm", ".", "compute_img_num", "(", "self", ".", "classes", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "img_num_list", "=", "self", ".", "bm", ".", "compute_img_num", "(", "self", ".", "classes", "[", "0", "]", ")", "\n", "\n", "", "if", "self", ".", "problem_type", "==", "'2GM'", ":", "\n", "            ", "self", ".", "id_combination", ",", "self", ".", "length", "=", "self", ".", "bm", ".", "get_id_combination", "(", "self", ".", "cls", ")", "\n", "self", ".", "length_list", "=", "[", "]", "\n", "for", "cls", "in", "self", ".", "classes", ":", "\n", "                ", "cls_length", "=", "self", ".", "bm", ".", "compute_length", "(", "cls", ")", "\n", "self", ".", "length_list", ".", "append", "(", "cls_length", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "length", "=", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.__len__": [[50, 52], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.__getitem__": [[53, 62], ["data_loader.GMDataset.get_pair", "data_loader.GMDataset.get_multi", "data_loader.GMDataset.get_multi_cluster", "NameError"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.base_dataset.BaseDataset.get_pair", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_multi", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_multi_cluster"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "problem_type", "==", "'2GM'", ":", "\n", "            ", "return", "self", ".", "get_pair", "(", "idx", ",", "self", ".", "cls", ")", "\n", "", "elif", "self", ".", "problem_type", "==", "'MGM'", ":", "\n", "            ", "return", "self", ".", "get_multi", "(", "idx", ",", "self", ".", "cls", ")", "\n", "", "elif", "self", ".", "problem_type", "==", "'MGM3'", ":", "\n", "            ", "return", "self", ".", "get_multi_cluster", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NameError", "(", "\"Unknown problem type: {}\"", ".", "format", "(", "self", ".", "problem_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.to_pyg_graph": [[63, 84], ["max", "numpy.nonzero", "numpy.clip", "numpy.nonzero", "torch_geometric.data.Data", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.array", "numpy.array", "numpy.expand_dims", "numpy.expand_dims", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "", "@", "staticmethod", "\n", "def", "to_pyg_graph", "(", "A", ",", "P", ")", ":", "\n", "        ", "rescale", "=", "max", "(", "cfg", ".", "PROBLEM", ".", "RESCALE", ")", "\n", "\n", "edge_feat", "=", "0.5", "*", "(", "np", ".", "expand_dims", "(", "P", ",", "axis", "=", "1", ")", "-", "np", ".", "expand_dims", "(", "P", ",", "axis", "=", "0", ")", ")", "/", "rescale", "+", "0.5", "# from Rolink's paper", "\n", "edge_index", "=", "np", ".", "nonzero", "(", "A", ")", "\n", "edge_attr", "=", "edge_feat", "[", "edge_index", "]", "\n", "\n", "edge_attr", "=", "np", ".", "clip", "(", "edge_attr", ",", "0", ",", "1", ")", "\n", "assert", "(", "edge_attr", ">", "-", "1e-5", ")", ".", "all", "(", ")", ",", "P", "\n", "\n", "o3_A", "=", "np", ".", "expand_dims", "(", "A", ",", "axis", "=", "0", ")", "*", "np", ".", "expand_dims", "(", "A", ",", "axis", "=", "1", ")", "*", "np", ".", "expand_dims", "(", "A", ",", "axis", "=", "2", ")", "\n", "hyperedge_index", "=", "np", ".", "nonzero", "(", "o3_A", ")", "\n", "\n", "pyg_graph", "=", "pyg", ".", "data", ".", "Data", "(", "\n", "x", "=", "torch", ".", "tensor", "(", "P", "/", "rescale", ")", ".", "to", "(", "torch", ".", "float32", ")", ",", "\n", "edge_index", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "edge_index", ")", ",", "dtype", "=", "torch", ".", "long", ")", ",", "\n", "edge_attr", "=", "torch", ".", "tensor", "(", "edge_attr", ")", ".", "to", "(", "torch", ".", "float32", ")", ",", "\n", "hyperedge_index", "=", "torch", ".", "tensor", "(", "np", ".", "array", "(", "hyperedge_index", ")", ",", "dtype", "=", "torch", ".", "long", ")", ",", "\n", ")", "\n", "return", "pyg_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_pair": [[85, 145], ["random.randrange", "list", "data_loader.GMDataset.bm.get_data", "perm_mat_[].toarray", "numpy.array", "numpy.array", "src.build_graphs.build_graphs", "data_loader.GMDataset.to_pyg_graph", "data_loader.GMDataset.to_pyg_graph", "len", "data_loader.GMDataset.bm.rand_get_data", "perm_mat_[].toarray", "len", "len", "perm_mat_[].toarray.transpose().dot", "perm_mat_[].toarray.transpose().dot", "perm_mat_[].toarray.transpose().dot.dot", "src.build_graphs.build_graphs", "torchvision.transforms.Compose", "min", "perm_mat_[].toarray.transpose().dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "str", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torchvision.transforms.Compose.", "numpy.stack", "numpy.stack", "perm_mat_[].toarray.transpose", "perm_mat_[].toarray.transpose", "int", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.build_graphs", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.to_pyg_graph", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.to_pyg_graph", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.build_graphs", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "get_pair", "(", "self", ",", "idx", ",", "cls", ")", ":", "\n", "#anno_pair, perm_mat = self.bm.get_pair(self.cls if self.cls is not None else", "\n", "#                                       (idx % (cfg.BATCH_SIZE * len(self.classes))) // cfg.BATCH_SIZE)", "\n", "        ", "cls_num", "=", "random", ".", "randrange", "(", "0", ",", "len", "(", "self", ".", "classes", ")", ")", "\n", "ids", "=", "list", "(", "self", ".", "id_combination", "[", "cls_num", "]", "[", "idx", "%", "self", ".", "length_list", "[", "cls_num", "]", "]", ")", "\n", "anno_pair", ",", "perm_mat_", ",", "id_list", "=", "self", ".", "bm", ".", "get_data", "(", "ids", ")", "\n", "perm_mat", "=", "perm_mat_", "[", "(", "0", ",", "1", ")", "]", ".", "toarray", "(", ")", "\n", "while", "min", "(", "perm_mat", ".", "shape", "[", "0", "]", ",", "perm_mat", ".", "shape", "[", "1", "]", ")", "<=", "2", "or", "perm_mat", ".", "size", ">=", "cfg", ".", "PROBLEM", ".", "MAX_PROB_SIZE", ">", "0", ":", "\n", "            ", "anno_pair", ",", "perm_mat_", ",", "id_list", "=", "self", ".", "bm", ".", "rand_get_data", "(", "cls", ")", "\n", "perm_mat", "=", "perm_mat_", "[", "(", "0", ",", "1", ")", "]", ".", "toarray", "(", ")", "\n", "\n", "", "cls", "=", "[", "anno", "[", "'cls'", "]", "for", "anno", "in", "anno_pair", "]", "\n", "P1", "=", "[", "(", "kp", "[", "'x'", "]", ",", "kp", "[", "'y'", "]", ")", "for", "kp", "in", "anno_pair", "[", "0", "]", "[", "'kpts'", "]", "]", "\n", "P2", "=", "[", "(", "kp", "[", "'x'", "]", ",", "kp", "[", "'y'", "]", ")", "for", "kp", "in", "anno_pair", "[", "1", "]", "[", "'kpts'", "]", "]", "\n", "\n", "n1", ",", "n2", "=", "len", "(", "P1", ")", ",", "len", "(", "P2", ")", "\n", "univ_size", "=", "[", "anno", "[", "'univ_size'", "]", "for", "anno", "in", "anno_pair", "]", "\n", "\n", "P1", "=", "np", ".", "array", "(", "P1", ")", "\n", "P2", "=", "np", ".", "array", "(", "P2", ")", "\n", "\n", "A1", ",", "G1", ",", "H1", ",", "e1", "=", "build_graphs", "(", "P1", ",", "n1", ",", "stg", "=", "cfg", ".", "GRAPH", ".", "SRC_GRAPH_CONSTRUCT", ",", "sym", "=", "cfg", ".", "GRAPH", ".", "SYM_ADJACENCY", ")", "\n", "if", "cfg", ".", "GRAPH", ".", "TGT_GRAPH_CONSTRUCT", "==", "'same'", ":", "\n", "            ", "G2", "=", "perm_mat", ".", "transpose", "(", ")", ".", "dot", "(", "G1", ")", "\n", "H2", "=", "perm_mat", ".", "transpose", "(", ")", ".", "dot", "(", "H1", ")", "\n", "A2", "=", "G2", ".", "dot", "(", "H2", ".", "transpose", "(", ")", ")", "\n", "e2", "=", "e1", "\n", "", "else", ":", "\n", "            ", "A2", ",", "G2", ",", "H2", ",", "e2", "=", "build_graphs", "(", "P2", ",", "n2", ",", "stg", "=", "cfg", ".", "GRAPH", ".", "TGT_GRAPH_CONSTRUCT", ",", "sym", "=", "cfg", ".", "GRAPH", ".", "SYM_ADJACENCY", ")", "\n", "\n", "", "pyg_graph1", "=", "self", ".", "to_pyg_graph", "(", "A1", ",", "P1", ")", "\n", "pyg_graph2", "=", "self", ".", "to_pyg_graph", "(", "A2", ",", "P2", ")", "\n", "\n", "ret_dict", "=", "{", "'Ps'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "[", "P1", ",", "P2", "]", "]", ",", "\n", "'ns'", ":", "[", "torch", ".", "tensor", "(", "x", ")", "for", "x", "in", "[", "n1", ",", "n2", "]", "]", ",", "\n", "'es'", ":", "[", "torch", ".", "tensor", "(", "x", ")", "for", "x", "in", "[", "e1", ",", "e2", "]", "]", ",", "\n", "'gt_perm_mat'", ":", "perm_mat", ",", "\n", "'Gs'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "[", "G1", ",", "G2", "]", "]", ",", "\n", "'Hs'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "[", "H1", ",", "H2", "]", "]", ",", "\n", "'As'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "[", "A1", ",", "A2", "]", "]", ",", "\n", "'pyg_graphs'", ":", "[", "pyg_graph1", ",", "pyg_graph2", "]", ",", "\n", "'cls'", ":", "[", "str", "(", "x", ")", "for", "x", "in", "cls", "]", ",", "\n", "'id_list'", ":", "id_list", ",", "\n", "'univ_size'", ":", "[", "torch", ".", "tensor", "(", "int", "(", "x", ")", ")", "for", "x", "in", "univ_size", "]", ",", "\n", "}", "\n", "\n", "imgs", "=", "[", "anno", "[", "'img'", "]", "for", "anno", "in", "anno_pair", "]", "\n", "if", "imgs", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "trans", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "cfg", ".", "NORM_MEANS", ",", "cfg", ".", "NORM_STD", ")", "\n", "]", ")", "\n", "imgs", "=", "[", "trans", "(", "img", ")", "for", "img", "in", "imgs", "]", "\n", "ret_dict", "[", "'images'", "]", "=", "imgs", "\n", "", "elif", "'feat'", "in", "anno_pair", "[", "0", "]", "[", "'kpts'", "]", "[", "0", "]", ":", "\n", "            ", "feat1", "=", "np", ".", "stack", "(", "[", "kp", "[", "'feat'", "]", "for", "kp", "in", "anno_pair", "[", "0", "]", "[", "'kpts'", "]", "]", ",", "axis", "=", "-", "1", ")", "\n", "feat2", "=", "np", ".", "stack", "(", "[", "kp", "[", "'feat'", "]", "for", "kp", "in", "anno_pair", "[", "1", "]", "[", "'kpts'", "]", "]", ",", "axis", "=", "-", "1", ")", "\n", "ret_dict", "[", "'features'", "]", "=", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "[", "feat1", ",", "feat2", "]", "]", "\n", "\n", "", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_multi": [[146, 242], ["zip", "data_loader.GMDataset.bm.rand_get_data", "perm_mat_dict.values", "len", "numpy.array", "src.build_graphs.build_graphs", "src.build_graphs.build_graphs", "As.append", "Gs.append", "Hs.append", "As_tgt.append", "Gs_tgt.append", "Hs_tgt.append", "data_loader.GMDataset.to_pyg_graph", "data_loader.GMDataset.to_pyg_graph", "torchvision.transforms.Compose", "random.randrange", "val.toarray", "zip", "zip", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "str", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torchvision.transforms.Compose.", "len", "type", "data_loader.GMDataset.classes.index", "random.randrange", "perm_mat_dict.items", "int", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "numpy.stack", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "type", "data_loader.GMDataset.classes[].index"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.build_graphs", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.build_graphs", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.to_pyg_graph", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.to_pyg_graph"], ["", "def", "get_multi", "(", "self", ",", "idx", ",", "cls", ")", ":", "\n", "        ", "if", "self", ".", "problem_type", "==", "'MGM'", "and", "self", ".", "using_all_graphs", ":", "\n", "            ", "if", "cls", "==", "None", ":", "\n", "                ", "cls", "=", "random", ".", "randrange", "(", "0", ",", "len", "(", "self", ".", "classes", ")", ")", "\n", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls", "]", "\n", "cls", "=", "self", ".", "classes", "[", "cls", "]", "\n", "", "elif", "type", "(", "cls", ")", "==", "str", ":", "\n", "                ", "cls_num", "=", "self", ".", "classes", ".", "index", "(", "cls", ")", "\n", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls_num", "]", "\n", "", "else", ":", "\n", "                ", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls", "]", "\n", "cls", "=", "self", ".", "classes", "[", "cls", "]", "\n", "\n", "", "", "elif", "self", ".", "problem_type", "==", "'MGM3'", "and", "self", ".", "using_all_graphs", ":", "\n", "            ", "if", "cls", "==", "None", ":", "\n", "                ", "cls", "=", "random", ".", "randrange", "(", "0", ",", "len", "(", "self", ".", "classes", "[", "0", "]", ")", ")", "\n", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls", "]", "\n", "cls", "=", "self", ".", "classes", "[", "cls", "]", "\n", "", "elif", "type", "(", "cls", ")", "==", "str", ":", "\n", "                ", "cls_num", "=", "self", ".", "classes", "[", "0", "]", ".", "index", "(", "cls", ")", "\n", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls_num", "]", "\n", "", "else", ":", "\n", "                ", "num_graphs", "=", "self", ".", "img_num_list", "[", "cls", "]", "\n", "cls", "=", "self", ".", "classes", "[", "cls", "]", "\n", "", "", "else", ":", "\n", "            ", "num_graphs", "=", "cfg", ".", "PROBLEM", ".", "NUM_GRAPHS", "\n", "\n", "", "refetch", "=", "True", "\n", "while", "refetch", ":", "\n", "            ", "refetch", "=", "False", "\n", "anno_list", ",", "perm_mat_dict", ",", "id_list", "=", "self", ".", "bm", ".", "rand_get_data", "(", "cls", ",", "num", "=", "num_graphs", ")", "\n", "perm_mat_dict", "=", "{", "key", ":", "val", ".", "toarray", "(", ")", "for", "key", ",", "val", "in", "perm_mat_dict", ".", "items", "(", ")", "}", "\n", "for", "pm", "in", "perm_mat_dict", ".", "values", "(", ")", ":", "\n", "                ", "if", "pm", ".", "shape", "[", "0", "]", "<=", "2", "or", "pm", ".", "shape", "[", "1", "]", "<=", "2", "or", "pm", ".", "size", ">=", "cfg", ".", "PROBLEM", ".", "MAX_PROB_SIZE", ">", "0", ":", "\n", "                    ", "refetch", "=", "True", "\n", "break", "\n", "\n", "", "", "", "cls", "=", "[", "anno", "[", "'cls'", "]", "for", "anno", "in", "anno_list", "]", "\n", "Ps", "=", "[", "[", "(", "kp", "[", "'x'", "]", ",", "kp", "[", "'y'", "]", ")", "for", "kp", "in", "anno_dict", "[", "'kpts'", "]", "]", "for", "anno_dict", "in", "anno_list", "]", "\n", "\n", "ns", "=", "[", "len", "(", "P", ")", "for", "P", "in", "Ps", "]", "\n", "univ_size", "=", "[", "anno", "[", "'univ_size'", "]", "for", "anno", "in", "anno_list", "]", "\n", "\n", "Ps", "=", "[", "np", ".", "array", "(", "P", ")", "for", "P", "in", "Ps", "]", "\n", "\n", "As", "=", "[", "]", "\n", "Gs", "=", "[", "]", "\n", "Hs", "=", "[", "]", "\n", "As_tgt", "=", "[", "]", "\n", "Gs_tgt", "=", "[", "]", "\n", "Hs_tgt", "=", "[", "]", "\n", "for", "P", ",", "n", "in", "zip", "(", "Ps", ",", "ns", ")", ":", "\n", "# In multi-graph matching (MGM), when a graph is regarded as target graph, its topology may be different", "\n", "# from when it is regarded as source graph. These are represented by suffix \"tgt\".", "\n", "            ", "A", ",", "G", ",", "H", ",", "_", "=", "build_graphs", "(", "P", ",", "n", ",", "stg", "=", "cfg", ".", "GRAPH", ".", "SRC_GRAPH_CONSTRUCT", ")", "\n", "A_tgt", ",", "G_tgt", ",", "H_tgt", ",", "_", "=", "build_graphs", "(", "P", ",", "n", ",", "stg", "=", "cfg", ".", "GRAPH", ".", "TGT_GRAPH_CONSTRUCT", ")", "\n", "As", ".", "append", "(", "A", ")", "\n", "Gs", ".", "append", "(", "G", ")", "\n", "Hs", ".", "append", "(", "H", ")", "\n", "As_tgt", ".", "append", "(", "A_tgt", ")", "\n", "Gs_tgt", ".", "append", "(", "G_tgt", ")", "\n", "Hs_tgt", ".", "append", "(", "H_tgt", ")", "\n", "\n", "", "pyg_graphs", "=", "[", "self", ".", "to_pyg_graph", "(", "A", ",", "P", ")", "for", "A", ",", "P", "in", "zip", "(", "As", ",", "Ps", ")", "]", "\n", "pyg_graphs_tgt", "=", "[", "self", ".", "to_pyg_graph", "(", "A", ",", "P", ")", "for", "A", ",", "P", "in", "zip", "(", "As_tgt", ",", "Ps", ")", "]", "\n", "\n", "ret_dict", "=", "{", "\n", "'Ps'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "Ps", "]", ",", "\n", "'ns'", ":", "[", "torch", ".", "tensor", "(", "x", ")", "for", "x", "in", "ns", "]", ",", "\n", "'gt_perm_mat'", ":", "perm_mat_dict", ",", "\n", "'Gs'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "Gs", "]", ",", "\n", "'Hs'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "Hs", "]", ",", "\n", "'As'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "As", "]", ",", "\n", "'Gs_tgt'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "Gs_tgt", "]", ",", "\n", "'Hs_tgt'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "Hs_tgt", "]", ",", "\n", "'As_tgt'", ":", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "As_tgt", "]", ",", "\n", "'pyg_graphs'", ":", "pyg_graphs", ",", "\n", "'pyg_graphs_tgt'", ":", "pyg_graphs_tgt", ",", "\n", "'cls'", ":", "[", "str", "(", "x", ")", "for", "x", "in", "cls", "]", ",", "\n", "'id_list'", ":", "id_list", ",", "\n", "'univ_size'", ":", "[", "torch", ".", "tensor", "(", "int", "(", "x", ")", ")", "for", "x", "in", "univ_size", "]", ",", "\n", "}", "\n", "\n", "imgs", "=", "[", "anno", "[", "'img'", "]", "for", "anno", "in", "anno_list", "]", "\n", "if", "imgs", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "trans", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "cfg", ".", "NORM_MEANS", ",", "cfg", ".", "NORM_STD", ")", "\n", "]", ")", "\n", "imgs", "=", "[", "trans", "(", "img", ")", "for", "img", "in", "imgs", "]", "\n", "ret_dict", "[", "'images'", "]", "=", "imgs", "\n", "", "elif", "'feat'", "in", "anno_list", "[", "0", "]", "[", "'kpts'", "]", "[", "0", "]", ":", "\n", "            ", "feats", "=", "[", "np", ".", "stack", "(", "[", "kp", "[", "'feat'", "]", "for", "kp", "in", "anno_dict", "[", "'kpts'", "]", "]", ",", "axis", "=", "-", "1", ")", "for", "anno_dict", "in", "anno_list", "]", "\n", "ret_dict", "[", "'features'", "]", "=", "[", "torch", ".", "Tensor", "(", "x", ")", "for", "x", "in", "feats", "]", "\n", "\n", "", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_multi_cluster": [[243, 257], ["random.choice", "dicts.append", "data_loader.GMDataset.get_multi"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.GMDataset.get_multi"], ["", "def", "get_multi_cluster", "(", "self", ",", "idx", ")", ":", "\n", "        ", "dicts", "=", "[", "]", "\n", "if", "self", ".", "cls", "is", "None", "or", "self", ".", "cls", "==", "'none'", ":", "\n", "            ", "cls_iterator", "=", "random", ".", "choice", "(", "self", ".", "classes", ")", "\n", "", "else", ":", "\n", "            ", "cls_iterator", "=", "self", ".", "cls", "\n", "", "for", "cls", "in", "cls_iterator", ":", "\n", "            ", "dicts", ".", "append", "(", "self", ".", "get_multi", "(", "idx", ",", "cls", ")", ")", "\n", "", "ret_dict", "=", "{", "}", "\n", "for", "key", "in", "dicts", "[", "0", "]", ":", "\n", "            ", "ret_dict", "[", "key", "]", "=", "[", "]", "\n", "for", "dic", "in", "dicts", ":", "\n", "                ", "ret_dict", "[", "key", "]", "+=", "dic", "[", "key", "]", "\n", "", "", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.QAPDataset.__init__": [[260, 266], ["eval"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "length", ",", "cls", "=", "None", ",", "**", "args", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "ds", "=", "eval", "(", "self", ".", "name", ")", "(", "**", "args", ",", "cls", "=", "cls", ")", "\n", "self", ".", "classes", "=", "self", ".", "ds", ".", "classes", "\n", "self", ".", "cls", "=", "None", "if", "cls", "==", "'none'", "else", "cls", "\n", "self", ".", "length", "=", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.QAPDataset.__len__": [[267, 270], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "#return len(self.ds.data_list)", "\n", "        ", "return", "self", ".", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.QAPDataset.__getitem__": [[271, 290], ["data_loader.QAPDataset.ds.get_pair", "data_loader.QAPDataset.__getitem__", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "random.randint", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.base_dataset.BaseDataset.get_pair", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.__getitem__"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "Fi", ",", "Fj", ",", "perm_mat", ",", "sol", ",", "name", "=", "self", ".", "ds", ".", "get_pair", "(", "idx", "%", "len", "(", "self", ".", "ds", ".", "data_list", ")", ")", "\n", "if", "perm_mat", ".", "size", "<=", "2", "*", "2", "or", "perm_mat", ".", "size", ">=", "cfg", ".", "PROBLEM", ".", "MAX_PROB_SIZE", ">", "0", ":", "\n", "            ", "return", "self", ".", "__getitem__", "(", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ")", "-", "1", ")", ")", "\n", "\n", "#if np.max(ori_aff_mat) > 0:", "\n", "#    norm_aff_mat = ori_aff_mat / np.mean(ori_aff_mat)", "\n", "#else:", "\n", "#    norm_aff_mat = ori_aff_mat", "\n", "\n", "", "ret_dict", "=", "{", "'Fi'", ":", "Fi", ",", "\n", "'Fj'", ":", "Fj", ",", "\n", "'gt_perm_mat'", ":", "perm_mat", ",", "\n", "'ns'", ":", "[", "torch", ".", "tensor", "(", "x", ")", "for", "x", "in", "perm_mat", ".", "shape", "]", ",", "\n", "'solution'", ":", "torch", ".", "tensor", "(", "sol", ")", ",", "\n", "'name'", ":", "name", ",", "\n", "'univ_size'", ":", "[", "torch", ".", "tensor", "(", "x", ")", "for", "x", "in", "perm_mat", ".", "shape", "]", ",", "}", "\n", "\n", "return", "ret_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.collate_fn": [[292, 403], ["data_loader.collate_fn.stack"], "function", ["None"], ["", "", "def", "collate_fn", "(", "data", ":", "list", ")", ":", "\n", "    ", "\"\"\"\n    Create mini-batch data for training.\n    :param data: data dict\n    :return: mini-batch\n    \"\"\"", "\n", "def", "pad_tensor", "(", "inp", ")", ":", "\n", "        ", "assert", "type", "(", "inp", "[", "0", "]", ")", "==", "torch", ".", "Tensor", "\n", "it", "=", "iter", "(", "inp", ")", "\n", "t", "=", "next", "(", "it", ")", "\n", "max_shape", "=", "list", "(", "t", ".", "shape", ")", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "t", "=", "next", "(", "it", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "max_shape", ")", ")", ":", "\n", "                    ", "max_shape", "[", "i", "]", "=", "int", "(", "max", "(", "max_shape", "[", "i", "]", ",", "t", ".", "shape", "[", "i", "]", ")", ")", "\n", "", "", "except", "StopIteration", ":", "\n", "                ", "break", "\n", "", "", "max_shape", "=", "np", ".", "array", "(", "max_shape", ")", "\n", "\n", "padded_ts", "=", "[", "]", "\n", "for", "t", "in", "inp", ":", "\n", "            ", "pad_pattern", "=", "np", ".", "zeros", "(", "2", "*", "len", "(", "max_shape", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "pad_pattern", "[", ":", ":", "-", "2", "]", "=", "max_shape", "-", "np", ".", "array", "(", "t", ".", "shape", ")", "\n", "#pad_pattern = torch.from_numpy(np.asfortranarray(pad_pattern))", "\n", "pad_pattern", "=", "tuple", "(", "pad_pattern", ".", "tolist", "(", ")", ")", "\n", "padded_ts", ".", "append", "(", "F", ".", "pad", "(", "t", ",", "pad_pattern", ",", "'constant'", ",", "0", ")", ")", "\n", "\n", "", "return", "padded_ts", "\n", "\n", "", "def", "stack", "(", "inp", ")", ":", "\n", "        ", "if", "type", "(", "inp", "[", "0", "]", ")", "==", "list", ":", "\n", "            ", "ret", "=", "[", "]", "\n", "for", "vs", "in", "zip", "(", "*", "inp", ")", ":", "\n", "                ", "ret", ".", "append", "(", "stack", "(", "vs", ")", ")", "\n", "", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "dict", ":", "\n", "            ", "ret", "=", "{", "}", "\n", "for", "kvs", "in", "zip", "(", "*", "[", "x", ".", "items", "(", ")", "for", "x", "in", "inp", "]", ")", ":", "\n", "                ", "ks", ",", "vs", "=", "zip", "(", "*", "kvs", ")", "\n", "for", "k", "in", "ks", ":", "\n", "                    ", "assert", "k", "==", "ks", "[", "0", "]", ",", "\"Keys mismatch.\"", "\n", "", "ret", "[", "k", "]", "=", "stack", "(", "vs", ")", "\n", "", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "torch", ".", "Tensor", ":", "\n", "            ", "new_t", "=", "pad_tensor", "(", "inp", ")", "\n", "ret", "=", "torch", ".", "stack", "(", "new_t", ",", "0", ")", "\n", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "new_t", "=", "pad_tensor", "(", "[", "torch", ".", "from_numpy", "(", "x", ")", "for", "x", "in", "inp", "]", ")", "\n", "ret", "=", "torch", ".", "stack", "(", "new_t", ",", "0", ")", "\n", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "pyg", ".", "data", ".", "Data", ":", "\n", "            ", "ret", "=", "pyg", ".", "data", ".", "Batch", ".", "from_data_list", "(", "inp", ")", "\n", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "str", ":", "\n", "            ", "ret", "=", "inp", "\n", "", "elif", "type", "(", "inp", "[", "0", "]", ")", "==", "tuple", ":", "\n", "            ", "ret", "=", "inp", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Cannot handle type {}'", ".", "format", "(", "type", "(", "inp", "[", "0", "]", ")", ")", ")", "\n", "", "return", "ret", "\n", "\n", "", "ret", "=", "stack", "(", "data", ")", "\n", "\n", "# compute CPU-intensive Kronecker product here to leverage multi-processing nature of dataloader", "\n", "if", "'Gs'", "in", "ret", "and", "'Hs'", "in", "ret", ":", "\n", "        ", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", "and", "len", "(", "ret", "[", "'Gs'", "]", ")", "==", "2", "and", "len", "(", "ret", "[", "'Hs'", "]", ")", "==", "2", ":", "\n", "            ", "G1", ",", "G2", "=", "ret", "[", "'Gs'", "]", "\n", "H1", ",", "H2", "=", "ret", "[", "'Hs'", "]", "\n", "if", "cfg", ".", "FP16", ":", "\n", "                ", "sparse_dtype", "=", "np", ".", "float16", "\n", "", "else", ":", "\n", "                ", "sparse_dtype", "=", "np", ".", "float32", "\n", "", "K1G", "=", "[", "kronecker_sparse", "(", "x", ",", "y", ")", ".", "astype", "(", "sparse_dtype", ")", "for", "x", ",", "y", "in", "zip", "(", "G2", ",", "G1", ")", "]", "# 1 as source graph, 2 as target graph", "\n", "K1H", "=", "[", "kronecker_sparse", "(", "x", ",", "y", ")", ".", "astype", "(", "sparse_dtype", ")", "for", "x", ",", "y", "in", "zip", "(", "H2", ",", "H1", ")", "]", "\n", "K1G", "=", "CSRMatrix3d", "(", "K1G", ")", "\n", "K1H", "=", "CSRMatrix3d", "(", "K1H", ")", ".", "transpose", "(", ")", "\n", "\n", "ret", "[", "'KGHs'", "]", "=", "K1G", ",", "K1H", "\n", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "in", "[", "'MGM'", ",", "'MGM3'", "]", "and", "'Gs_tgt'", "in", "ret", "and", "'Hs_tgt'", "in", "ret", ":", "\n", "            ", "ret", "[", "'KGHs'", "]", "=", "dict", "(", ")", "\n", "for", "idx_1", ",", "idx_2", "in", "product", "(", "range", "(", "len", "(", "ret", "[", "'Gs'", "]", ")", ")", ",", "repeat", "=", "2", ")", ":", "\n", "# 1 as source graph, 2 as target graph", "\n", "                ", "G1", "=", "ret", "[", "'Gs'", "]", "[", "idx_1", "]", "\n", "H1", "=", "ret", "[", "'Hs'", "]", "[", "idx_1", "]", "\n", "G2", "=", "ret", "[", "'Gs_tgt'", "]", "[", "idx_2", "]", "\n", "H2", "=", "ret", "[", "'Hs_tgt'", "]", "[", "idx_2", "]", "\n", "if", "cfg", ".", "FP16", ":", "\n", "                    ", "sparse_dtype", "=", "np", ".", "float16", "\n", "", "else", ":", "\n", "                    ", "sparse_dtype", "=", "np", ".", "float32", "\n", "", "KG", "=", "[", "kronecker_sparse", "(", "x", ",", "y", ")", ".", "astype", "(", "sparse_dtype", ")", "for", "x", ",", "y", "in", "zip", "(", "G2", ",", "G1", ")", "]", "\n", "KH", "=", "[", "kronecker_sparse", "(", "x", ",", "y", ")", ".", "astype", "(", "sparse_dtype", ")", "for", "x", ",", "y", "in", "zip", "(", "H2", ",", "H1", ")", "]", "\n", "KG", "=", "CSRMatrix3d", "(", "KG", ")", "\n", "KH", "=", "CSRMatrix3d", "(", "KH", ")", ".", "transpose", "(", ")", "\n", "ret", "[", "'KGHs'", "]", "[", "'{},{}'", ".", "format", "(", "idx_1", ",", "idx_2", ")", "]", "=", "KG", ",", "KH", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data type not understood.'", ")", "\n", "\n", "", "", "if", "'Fi'", "in", "ret", "and", "'Fj'", "in", "ret", ":", "\n", "        ", "Fi", "=", "ret", "[", "'Fi'", "]", "\n", "Fj", "=", "ret", "[", "'Fj'", "]", "\n", "aff_mat", "=", "kronecker_torch", "(", "Fj", ",", "Fi", ")", "\n", "ret", "[", "'aff_mat'", "]", "=", "aff_mat", "\n", "\n", "", "ret", "[", "'batch_size'", "]", "=", "len", "(", "data", ")", "\n", "ret", "[", "'univ_size'", "]", "=", "torch", ".", "tensor", "(", "[", "max", "(", "*", "[", "item", "[", "b", "]", "for", "item", "in", "ret", "[", "'univ_size'", "]", "]", ")", "for", "b", "in", "range", "(", "ret", "[", "'batch_size'", "]", ")", "]", ")", "\n", "\n", "for", "v", "in", "ret", ".", "values", "(", ")", ":", "\n", "        ", "if", "type", "(", "v", ")", "is", "list", ":", "\n", "            ", "ret", "[", "'num_graphs'", "]", "=", "len", "(", "v", ")", "\n", "break", "\n", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.worker_init_fix": [[405, 411], ["random.seed", "numpy.random.seed"], "function", ["None"], ["", "def", "worker_init_fix", "(", "worker_id", ")", ":", "\n", "    ", "\"\"\"\n    Init dataloader workers with fixed seed.\n    \"\"\"", "\n", "random", ".", "seed", "(", "cfg", ".", "RANDOM_SEED", "+", "worker_id", ")", "\n", "np", ".", "random", ".", "seed", "(", "cfg", ".", "RANDOM_SEED", "+", "worker_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.worker_init_rand": [[413, 420], ["random.seed", "numpy.random.seed", "torch.initial_seed", "torch.initial_seed", "torch.initial_seed", "torch.initial_seed"], "function", ["None"], ["", "def", "worker_init_rand", "(", "worker_id", ")", ":", "\n", "    ", "\"\"\"\n    Init dataloader workers with torch.initial_seed().\n    torch.initial_seed() returns different seeds when called from different dataloader threads.\n    \"\"\"", "\n", "random", ".", "seed", "(", "torch", ".", "initial_seed", "(", ")", ")", "\n", "np", ".", "random", ".", "seed", "(", "torch", ".", "initial_seed", "(", ")", "%", "2", "**", "32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.data_loader.get_dataloader": [[422, 426], ["torch.utils.data.DataLoader", "torch.utils.data.DataLoader"], "function", ["None"], ["", "def", "get_dataloader", "(", "dataset", ",", "fix_seed", "=", "True", ",", "shuffle", "=", "False", ")", ":", "\n", "    ", "return", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "batch_size", "=", "cfg", ".", "BATCH_SIZE", ",", "shuffle", "=", "shuffle", ",", "num_workers", "=", "cfg", ".", "DATALOADER_NUM", ",", "collate_fn", "=", "collate_fn", ",", "\n", "pin_memory", "=", "False", ",", "worker_init_fn", "=", "worker_init_fix", "if", "fix_seed", "else", "worker_init_rand", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.qaplib.QAPLIB.__init__": [[12, 83], ["src.dataset.base_dataset.BaseDataset.__init__", "pathlib.Path", "qaplib.QAPLIB.data_list.sort", "cls_list.index", "qaplib.QAPLIB.qap_path.glob", "qaplib.QAPLIB.data_list.remove", "re.findall", "re.findall", "zip", "qaplib.QAPLIB.__fetch_online", "fetched_flag.touch", "int", "qaplib.QAPLIB.data_list.append", "len", "len", "qaplib.QAPLIB.__init__.cmp_to_key"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.qaplib.QAPLIB.__fetch_online"], ["    ", "def", "__init__", "(", "self", ",", "sets", ",", "cls", ",", "fetch_online", "=", "False", ")", ":", "\n", "        ", "super", "(", "QAPLIB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "classes", "=", "[", "'qaplib'", "]", "\n", "self", ".", "sets", "=", "sets", "\n", "\n", "if", "cls", "is", "not", "None", "and", "cls", "!=", "'none'", ":", "\n", "            ", "idx", "=", "cls_list", ".", "index", "(", "cls", ")", "\n", "self", ".", "cls_list", "=", "[", "cls_list", "[", "idx", "]", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "cls_list", "=", "cls_list", "\n", "\n", "", "self", ".", "data_list", "=", "[", "]", "\n", "self", ".", "qap_path", "=", "Path", "(", "cfg", ".", "QAPLIB", ".", "DIR", ")", "\n", "for", "inst", "in", "self", ".", "cls_list", ":", "\n", "            ", "for", "dat_path", "in", "self", ".", "qap_path", ".", "glob", "(", "inst", "+", "'*.dat'", ")", ":", "\n", "                ", "name", "=", "dat_path", ".", "name", "[", ":", "-", "4", "]", "\n", "prob_size", "=", "int", "(", "re", ".", "findall", "(", "r\"\\d+\"", ",", "name", ")", "[", "0", "]", ")", "\n", "if", "(", "self", ".", "sets", "==", "'test'", "and", "prob_size", ">", "cfg", ".", "QAPLIB", ".", "MAX_TEST_SIZE", ")", "or", "(", "self", ".", "sets", "==", "'train'", "and", "prob_size", ">", "cfg", ".", "QAPLIB", ".", "MAX_TRAIN_SIZE", ")", ":", "\n", "                    ", "continue", "\n", "", "self", ".", "data_list", ".", "append", "(", "name", ")", "\n", "\n", "# remove trivial instance esc16f", "\n", "", "", "if", "'esc16f'", "in", "self", ".", "data_list", ":", "\n", "            ", "self", ".", "data_list", ".", "remove", "(", "'esc16f'", ")", "\n", "\n", "# define compare function", "\n", "", "def", "name_cmp", "(", "a", ",", "b", ")", ":", "\n", "            ", "a", "=", "re", ".", "findall", "(", "r'[0-9]+|[a-z]+'", ",", "a", ")", "\n", "b", "=", "re", ".", "findall", "(", "r'[0-9]+|[a-z]+'", ",", "b", ")", "\n", "for", "_a", ",", "_b", "in", "zip", "(", "a", ",", "b", ")", ":", "\n", "                ", "if", "_a", ".", "isdigit", "(", ")", "and", "_b", ".", "isdigit", "(", ")", ":", "\n", "                    ", "_a", "=", "int", "(", "_a", ")", "\n", "_b", "=", "int", "(", "_b", ")", "\n", "", "cmp", "=", "(", "_a", ">", "_b", ")", "-", "(", "_a", "<", "_b", ")", "\n", "if", "cmp", "!=", "0", ":", "\n", "                    ", "return", "cmp", "\n", "", "", "if", "len", "(", "a", ")", ">", "len", "(", "b", ")", ":", "\n", "                ", "return", "-", "1", "\n", "", "elif", "len", "(", "a", ")", "<", "len", "(", "b", ")", ":", "\n", "                ", "return", "1", "\n", "", "else", ":", "\n", "                ", "return", "0", "\n", "\n", "", "", "def", "cmp_to_key", "(", "mycmp", ")", ":", "\n", "            ", "'Convert a cmp= function into a key= function'", "\n", "class", "K", ":", "\n", "                ", "def", "__init__", "(", "self", ",", "obj", ",", "*", "args", ")", ":", "\n", "                    ", "self", ".", "obj", "=", "obj", "\n", "", "def", "__lt__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", "<", "0", "\n", "", "def", "__gt__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", ">", "0", "\n", "", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", "==", "0", "\n", "", "def", "__le__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", "<=", "0", "\n", "", "def", "__ge__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", ">=", "0", "\n", "", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "                    ", "return", "mycmp", "(", "self", ".", "obj", ",", "other", ".", "obj", ")", "!=", "0", "\n", "", "", "return", "K", "\n", "\n", "# sort data list according to the names", "\n", "", "self", ".", "data_list", ".", "sort", "(", "key", "=", "cmp_to_key", "(", "name_cmp", ")", ")", "\n", "\n", "fetched_flag", "=", "self", ".", "qap_path", "/", "'fetched_online'", "\n", "\n", "if", "fetch_online", "or", "not", "fetched_flag", ".", "exists", "(", ")", ":", "\n", "            ", "self", ".", "__fetch_online", "(", ")", "\n", "fetched_flag", ".", "touch", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.qaplib.QAPLIB.get_pair": [[84, 145], ["dat_path.open", "sln_path.open", "numpy.array", "numpy.array", "numpy.zeros", "enumerate", "re.split", "len", "len", "x.rstrip", "qaplib.QAPLIB.get_pair.split_line"], "methods", ["None"], ["", "", "def", "get_pair", "(", "self", ",", "idx", ",", "shuffle", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Get QAP data by index\n        :param idx: dataset index\n        :param shuffle: no use here\n        :return: (pair of data, groundtruth permutation matrix)\n        \"\"\"", "\n", "name", "=", "self", ".", "data_list", "[", "idx", "]", "\n", "\n", "dat_path", "=", "self", ".", "qap_path", "/", "(", "name", "+", "'.dat'", ")", "\n", "sln_path", "=", "self", ".", "qap_path", "/", "(", "name", "+", "'.sln'", ")", "\n", "dat_file", "=", "dat_path", ".", "open", "(", ")", "\n", "sln_file", "=", "sln_path", ".", "open", "(", ")", "\n", "\n", "def", "split_line", "(", "x", ")", ":", "\n", "            ", "for", "_", "in", "re", ".", "split", "(", "r'[,\\s]'", ",", "x", ".", "rstrip", "(", "'\\n'", ")", ")", ":", "\n", "                ", "if", "_", "==", "\"\"", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "yield", "int", "(", "_", ")", "\n", "\n", "", "", "", "dat_list", "=", "[", "[", "_", "for", "_", "in", "split_line", "(", "line", ")", "]", "for", "line", "in", "dat_file", "]", "\n", "sln_list", "=", "[", "[", "_", "for", "_", "in", "split_line", "(", "line", ")", "]", "for", "line", "in", "sln_file", "]", "\n", "\n", "prob_size", "=", "dat_list", "[", "0", "]", "[", "0", "]", "\n", "\n", "# read data", "\n", "r", "=", "0", "\n", "c", "=", "0", "\n", "Fi", "=", "[", "[", "]", "]", "\n", "Fj", "=", "[", "[", "]", "]", "\n", "F", "=", "Fi", "\n", "for", "l", "in", "dat_list", "[", "1", ":", "]", ":", "\n", "            ", "F", "[", "r", "]", "+=", "l", "\n", "c", "+=", "len", "(", "l", ")", "\n", "assert", "c", "<=", "prob_size", "\n", "if", "c", "==", "prob_size", ":", "\n", "                ", "r", "+=", "1", "\n", "if", "r", "<", "prob_size", ":", "\n", "                    ", "F", ".", "append", "(", "[", "]", ")", "\n", "c", "=", "0", "\n", "", "else", ":", "\n", "                    ", "F", "=", "Fj", "\n", "r", "=", "0", "\n", "c", "=", "0", "\n", "", "", "", "Fi", "=", "np", ".", "array", "(", "Fi", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "Fj", "=", "np", ".", "array", "(", "Fj", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "assert", "Fi", ".", "shape", "==", "Fj", ".", "shape", "==", "(", "prob_size", ",", "prob_size", ")", "\n", "#K = np.kron(Fj, Fi)", "\n", "\n", "# read solution", "\n", "sol", "=", "sln_list", "[", "0", "]", "[", "1", "]", "\n", "perm_list", "=", "[", "]", "\n", "for", "_", "in", "sln_list", "[", "1", ":", "]", ":", "\n", "            ", "perm_list", "+=", "_", "\n", "", "assert", "len", "(", "perm_list", ")", "==", "prob_size", "\n", "perm_mat", "=", "np", ".", "zeros", "(", "(", "prob_size", ",", "prob_size", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "r", ",", "c", "in", "enumerate", "(", "perm_list", ")", ":", "\n", "            ", "perm_mat", "[", "r", ",", "c", "-", "1", "]", "=", "1", "\n", "\n", "", "return", "Fi", ",", "Fj", ",", "perm_mat", ",", "sol", ",", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.qaplib.QAPLIB.__fetch_online": [[146, 158], ["urllib.request.urlopen().read", "urllib.request.urlopen().read", "dat_file.write", "sln_file.write", "urllib.request.urlopen", "urllib.request.urlopen"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.dup_stdout_manager.DupStdoutFileWriter.write"], ["", "def", "__fetch_online", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Fetch from online QAPLIB data\n        \"\"\"", "\n", "for", "name", "in", "self", ".", "data_list", ":", "\n", "            ", "dat_content", "=", "urllib", ".", "request", ".", "urlopen", "(", "cfg", ".", "QAPLIB", ".", "ONLINE_REPO", "+", "'data.d/{}.dat'", ".", "format", "(", "name", ")", ")", ".", "read", "(", ")", "\n", "sln_content", "=", "urllib", ".", "request", ".", "urlopen", "(", "cfg", ".", "QAPLIB", ".", "ONLINE_REPO", "+", "'soln.d/{}.sln'", ".", "format", "(", "name", ")", ")", ".", "read", "(", ")", "\n", "\n", "dat_file", "=", "(", "self", ".", "qap_path", "/", "(", "name", "+", "'.dat'", ")", ")", ".", "open", "(", "'wb'", ")", "\n", "dat_file", ".", "write", "(", "dat_content", ")", "\n", "sln_file", "=", "(", "self", ".", "qap_path", "/", "(", "name", "+", "'.sln'", ")", ")", ".", "open", "(", "'wb'", ")", "\n", "sln_file", ".", "write", "(", "sln_content", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.base_dataset.BaseDataset.__init__": [[2, 4], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.dataset.base_dataset.BaseDataset.get_pair": [[5, 7], ["None"], "methods", ["None"], ["", "def", "get_pair", "(", "self", ",", "cls", ",", "shuffle", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.spectral_matching.SpectralMatching.__init__": [[17, 21], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", "=", "50", ",", "stop_thresh", "=", "2e-7", ")", ":", "\n", "        ", "super", "(", "SpectralMatching", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "stop_thresh", "=", "stop_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.spectral_matching.SpectralMatching.forward": [[22, 41], ["range", "torch.bmm.view", "torch.bmm.view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "src.utils.sparse.sbmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.bmm.view", "torch.bmm.view"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.sbmm"], ["", "def", "forward", "(", "self", ",", "M", ",", "v0", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "batch_num", "=", "M", ".", "shape", "[", "0", "]", "\n", "mn", "=", "M", ".", "shape", "[", "1", "]", "\n", "if", "v0", "is", "None", ":", "\n", "            ", "v0", "=", "torch", ".", "ones", "(", "batch_num", ",", "mn", ",", "1", ",", "dtype", "=", "M", ".", "dtype", ",", "device", "=", "M", ".", "device", ")", "\n", "\n", "", "v", "=", "vlast", "=", "v0", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "if", "M", ".", "is_sparse", ":", "\n", "                ", "v", "=", "sbmm", "(", "M", ",", "v", ")", "\n", "", "else", ":", "\n", "                ", "v", "=", "torch", ".", "bmm", "(", "M", ",", "v", ")", "\n", "", "n", "=", "torch", ".", "norm", "(", "v", ",", "p", "=", "2", ",", "dim", "=", "1", ")", "\n", "v", "=", "torch", ".", "matmul", "(", "v", ",", "(", "1", "/", "n", ")", ".", "view", "(", "batch_num", ",", "1", ",", "1", ")", ")", "\n", "if", "torch", ".", "norm", "(", "v", "-", "vlast", ")", "<", "self", ".", "stop_thresh", ":", "\n", "                ", "return", "v", ".", "view", "(", "batch_num", ",", "-", "1", ")", "\n", "", "vlast", "=", "v", "\n", "\n", "", "return", "v", ".", "view", "(", "batch_num", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.rrwhm.RRWHM.__init__": [[18, 24], ["torch.Module.__init__", "src.lap_solvers.sinkhorn.Sinkhorn"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", "=", "50", ",", "sk_iter", "=", "20", ",", "alpha", "=", "0.2", ",", "beta", "=", "30", ")", ":", "\n", "        ", "super", "(", "RRWHM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "sk", "=", "Sinkhorn", "(", "max_iter", "=", "sk_iter", ",", "log_forward", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.rrwhm.RRWHM.forward": [[25, 62], ["H.sum", "range", "torch.matmul.view", "torch.matmul.view", "len", "H.sum.max", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "v0.transpose().reshape.transpose().reshape.transpose().reshape", "H.unsqueeze", "range", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.matmul.view().transpose", "torch.matmul.view().transpose", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "range", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "v0.transpose().reshape.transpose().reshape.transpose", "list", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.matmul.view", "torch.matmul.view", "rrwhm.RRWHM.sk().transpose().reshape", "torch.matmul.view", "torch.matmul.view", "torch.exp.max().values.max", "torch.exp.max().values.max", "rrwhm.RRWHM.sk().transpose", "torch.exp.max", "torch.exp.max", "rrwhm.RRWHM.sk"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "H", ",", "num_src", ",", "ns_src", ",", "ns_tgt", ",", "v0", "=", "None", ")", ":", "\n", "        ", "order", "=", "len", "(", "H", ".", "shape", ")", "-", "1", "\n", "sum_dims", "=", "[", "i", "+", "2", "for", "i", "in", "range", "(", "order", "-", "1", ")", "]", "\n", "d", "=", "H", ".", "sum", "(", "dim", "=", "sum_dims", ",", "keepdim", "=", "True", ")", "\n", "dmax", "=", "d", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "values", "\n", "H", "=", "H", "/", "dmax", "\n", "\n", "batch_num", "=", "H", ".", "shape", "[", "0", "]", "\n", "mn", "=", "H", ".", "shape", "[", "1", "]", "\n", "if", "v0", "is", "None", ":", "\n", "            ", "v0", "=", "torch", ".", "zeros", "(", "batch_num", ",", "num_src", ",", "mn", "//", "num_src", ",", "dtype", "=", "H", ".", "dtype", ",", "device", "=", "H", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "                ", "v0", "[", "b", ",", "0", ":", "ns_src", "[", "b", "]", ",", "0", ":", "ns_tgt", "[", "b", "]", "]", "=", "torch", ".", "tensor", "(", "1.", ")", "/", "(", "ns_src", "[", "b", "]", "*", "ns_tgt", "[", "b", "]", ")", "\n", "\n", "", "v0", "=", "v0", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "batch_num", ",", "mn", ",", "1", ")", "\n", "\n", "", "v", "=", "v0", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "H_red", "=", "H", ".", "unsqueeze", "(", "-", "1", ")", "\n", "for", "o", "in", "range", "(", "order", "-", "1", ")", ":", "\n", "                ", "v_shape", "=", "[", "v", ".", "shape", "[", "0", "]", "]", "+", "[", "1", "]", "*", "(", "order", "-", "1", "-", "o", ")", "+", "list", "(", "v", ".", "shape", "[", "1", ":", "]", ")", "\n", "H_red", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "H_red", ",", "v", ".", "view", "(", "*", "v_shape", ")", ")", ",", "dim", "=", "-", "2", ")", "\n", "", "v", "=", "H_red", "\n", "last_v", "=", "v", "\n", "n", "=", "torch", ".", "norm", "(", "v", ",", "p", "=", "1", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "v", "=", "v", "/", "n", "\n", "s", "=", "v", ".", "view", "(", "batch_num", ",", "-", "1", ",", "num_src", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "s", "=", "torch", ".", "exp", "(", "self", ".", "beta", "*", "s", "/", "s", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "values", ".", "max", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", ".", "values", ")", "\n", "\n", "v", "=", "self", ".", "alpha", "*", "self", ".", "sk", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "batch_num", ",", "mn", ",", "1", ")", "+", "(", "1", "-", "self", ".", "alpha", ")", "*", "v", "\n", "n", "=", "torch", ".", "norm", "(", "v", ",", "p", "=", "1", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "v", "=", "torch", ".", "matmul", "(", "v", ",", "1", "/", "n", ")", "\n", "\n", "if", "torch", ".", "norm", "(", "v", "-", "last_v", ")", "<", "1e-5", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "v", ".", "view", "(", "batch_num", ",", "-", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.rrwm.RRWM.__init__": [[18, 24], ["torch.Module.__init__", "src.lap_solvers.sinkhorn.Sinkhorn"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", "=", "50", ",", "sk_iter", "=", "20", ",", "alpha", "=", "0.2", ",", "beta", "=", "30", ")", ":", "\n", "        ", "super", "(", "RRWM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "sk", "=", "Sinkhorn", "(", "max_iter", "=", "sk_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.qap_solvers.rrwm.RRWM.forward": [[25, 56], ["M.sum", "range", "torch.matmul.view", "torch.matmul.view", "M.sum.max", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "v0.transpose().reshape.transpose().reshape.transpose().reshape", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.matmul.view().transpose", "torch.matmul.view().transpose", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "M.sum.min", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "v0.transpose().reshape.transpose().reshape.transpose", "torch.matmul.view", "torch.matmul.view", "rrwm.RRWM.sk().transpose().reshape", "torch.exp.max().values.max", "torch.exp.max().values.max", "rrwm.RRWM.sk().transpose", "torch.exp.max", "torch.exp.max", "rrwm.RRWM.sk", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "M", ",", "num_src", ",", "ns_src", ",", "ns_tgt", ",", "v0", "=", "None", ")", ":", "\n", "        ", "d", "=", "M", ".", "sum", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "dmax", "=", "d", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "values", "\n", "M", "=", "M", "/", "(", "dmax", "+", "d", ".", "min", "(", ")", "*", "1e-5", ")", "\n", "\n", "batch_num", "=", "M", ".", "shape", "[", "0", "]", "\n", "mn", "=", "M", ".", "shape", "[", "1", "]", "\n", "if", "v0", "is", "None", ":", "\n", "            ", "v0", "=", "torch", ".", "zeros", "(", "batch_num", ",", "num_src", ",", "mn", "//", "num_src", ",", "dtype", "=", "M", ".", "dtype", ",", "device", "=", "M", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "                ", "v0", "[", "b", ",", "0", ":", "ns_src", "[", "b", "]", ",", "0", ":", "ns_tgt", "[", "b", "]", "]", "=", "torch", ".", "tensor", "(", "1.", ")", "/", "(", "ns_src", "[", "b", "]", "*", "ns_tgt", "[", "b", "]", ")", "\n", "\n", "", "v0", "=", "v0", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "batch_num", ",", "mn", ",", "1", ")", "\n", "\n", "", "v", "=", "v0", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "v", "=", "torch", ".", "bmm", "(", "M", ",", "v", ")", "\n", "last_v", "=", "v", "\n", "n", "=", "torch", ".", "norm", "(", "v", ",", "p", "=", "1", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "v", "=", "v", "/", "n", "\n", "s", "=", "v", ".", "view", "(", "batch_num", ",", "-", "1", ",", "num_src", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "s", "=", "torch", ".", "exp", "(", "self", ".", "beta", "*", "s", "/", "s", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ".", "values", ".", "max", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", ".", "values", ")", "\n", "\n", "v", "=", "self", ".", "alpha", "*", "self", ".", "sk", "(", "torch", ".", "log", "(", "s", ")", ",", "ns_src", ",", "ns_tgt", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "batch_num", ",", "mn", ",", "1", ")", "+", "(", "1", "-", "self", ".", "alpha", ")", "*", "v", "\n", "n", "=", "torch", ".", "norm", "(", "v", ",", "p", "=", "1", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "v", "=", "torch", ".", "matmul", "(", "v", ",", "1", "/", "n", ")", "\n", "\n", "if", "torch", ".", "norm", "(", "v", "-", "last_v", ")", "<", "1e-5", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "v", ".", "view", "(", "batch_num", ",", "-", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.__init__": [[20, 93], ["range", "indptr.append", "csx_matrix.CSXMatrix3d.__init__.from_tensors"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "inp", ",", "shape", ",", "device", "=", "None", ")", ":", "\n", "        ", "def", "from_ssp", "(", "inp_s", ":", "list", ",", "shape", ",", "device", "=", "None", ",", "sptype", "=", "self", ".", "sptype", ")", ":", "\n", "            ", "\"\"\"\n            Load data from list of scipy.sparse matrix\n            :param inp_s: list of input scipy.sparse matrix\n            :param shape: output matrix shape.\n            :param device: device. If not specified, it will be the same as input.\n            :param sptype: sparse matrix type. Should be 'csr' or 'csc'\n            \"\"\"", "\n", "assert", "len", "(", "shape", ")", "==", "3", ",", "'Only 3-dimensional tensor (bxhxw) is supported'", "\n", "batch_num", "=", "shape", "[", "0", "]", "\n", "\n", "indices", "=", "[", "]", "\n", "indptr", "=", "[", "]", "\n", "data", "=", "[", "]", "\n", "indptr_offset", "=", "0", "\n", "\n", "for", "b", "in", "range", "(", "batch_num", ")", ":", "\n", "                ", "if", "sptype", "==", "'csc'", ":", "\n", "                    ", "inp_s", "[", "b", "]", ".", "eliminate_zeros", "(", ")", "\n", "sp", "=", "inp_s", "[", "b", "]", ".", "tocsc", "(", ")", ".", "astype", "(", "dtype", "=", "inp_s", "[", "b", "]", ".", "dtype", ")", "\n", "", "elif", "sptype", "==", "'csr'", ":", "\n", "                    ", "inp_s", "[", "b", "]", ".", "eliminate_zeros", "(", ")", "\n", "sp", "=", "inp_s", "[", "b", "]", ".", "tocsr", "(", ")", ".", "astype", "(", "dtype", "=", "inp_s", "[", "b", "]", ".", "dtype", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'Sparse type not understood {}'", ".", "format", "(", "sptype", ")", ")", "\n", "\n", "", "indices", ".", "append", "(", "sp", ".", "indices", ")", "\n", "indptr", ".", "append", "(", "sp", ".", "indptr", "[", ":", "-", "1", "]", "+", "indptr_offset", ")", "\n", "data", ".", "append", "(", "sp", ".", "data", ")", "\n", "indptr_offset", "+=", "sp", ".", "indptr", "[", "-", "1", "]", "\n", "", "indptr", ".", "append", "(", "np", ".", "array", "(", "[", "indptr_offset", "]", ")", ")", "\n", "\n", "return", "from_tensors", "(", "*", "[", "np", ".", "concatenate", "(", "x", ")", "for", "x", "in", "(", "indices", ",", "indptr", ",", "data", ")", "]", ",", "shape", "=", "shape", ",", "\n", "device", "=", "device", ")", "\n", "\n", "", "def", "from_tensors", "(", "ind", ":", "torch", ".", "Tensor", "or", "np", ".", "ndarray", ",", "indp", ":", "torch", ".", "Tensor", "or", "np", ".", "ndarray", ",", "\n", "data", ":", "torch", ".", "Tensor", "or", "np", ".", "ndarray", ",", "shape", ",", "device", "=", "None", ")", ":", "\n", "            ", "\"\"\"\n            Load data from raw input tensors/arrays.\n            :param ind: indices array/tensor\n            :param indp: indptr array/tensor\n            :param data: data array/tensor\n            :param shape: output matrix shape.\n            :param device: device. Optional\n            :return: indices(Tensor), indptr(Tensor), data(Tensor), shape(tuple)\n            \"\"\"", "\n", "if", "type", "(", "ind", ")", "==", "torch", ".", "Tensor", "and", "device", "is", "None", ":", "\n", "                ", "device", "=", "ind", ".", "device", "\n", "\n", "", "if", "type", "(", "ind", ")", "is", "torch", ".", "Tensor", ":", "\n", "                ", "indices_t", "=", "ind", ".", "to", "(", "torch", ".", "int64", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "                ", "indices_t", "=", "torch", ".", "tensor", "(", "ind", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "", "if", "type", "(", "indp", ")", "is", "torch", ".", "Tensor", ":", "\n", "                ", "indptr_t", "=", "indp", ".", "to", "(", "torch", ".", "int64", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "                ", "indptr_t", "=", "torch", ".", "tensor", "(", "indp", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "device", ")", "\n", "", "if", "type", "(", "data", ")", "is", "torch", ".", "Tensor", ":", "\n", "                ", "data_t", "=", "data", ".", "to", "(", "dtype", "=", "data", ".", "dtype", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "                ", "data_t", "=", "torch", ".", "tensor", "(", "data", ",", "device", "=", "device", ")", "\n", "\n", "", "return", "indices_t", ",", "indptr_t", ",", "data_t", ",", "tuple", "(", "shape", ")", "\n", "\n", "", "if", "type", "(", "inp", ")", "==", "list", "and", "isinstance", "(", "inp", "[", "0", "]", ",", "ssp", ".", "spmatrix", ")", ":", "\n", "            ", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", ",", "self", ".", "shape", "=", "from_ssp", "(", "inp", ",", "shape", ",", "device", ")", "\n", "\n", "", "elif", "type", "(", "inp", ")", "==", "list", ":", "\n", "            ", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", ",", "self", ".", "shape", "=", "from_tensors", "(", "*", "inp", ",", "shape", ",", "device", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data type {} not understood.'", ".", "format", "(", "type", "(", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.__getitem__": [[94, 124], ["isinstance", "csx_matrix.CSXMatrix3d.get_batch", "csx_matrix.CSXMatrix3d.__class__", "isinstance", "int", "range", "isinstance", "torch.cat.append", "torch.cat", "torch.cat", "torch.cat", "csx_matrix.CSXMatrix3d.__class__", "ValueError", "csx_matrix.CSXMatrix3d.get_batch", "torch.cat.append", "torch.cat.append", "torch.cat.append", "int.view", "list", "type", "list", "len"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.get_batch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.get_batch"], ["", "", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Get item through slicing. The slicing is only supported on the batch dimention\n        :param item: index or slice\n        :return: new sparse matrix\n        \"\"\"", "\n", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "            ", "indices", ",", "indptr", ",", "data", "=", "self", ".", "get_batch", "(", "item", ")", "\n", "return", "self", ".", "__class__", "(", "[", "indices", ",", "indptr", ",", "data", "]", ",", "shape", "=", "[", "1", "]", "+", "list", "(", "self", ".", "shape", "[", "1", ":", "3", "]", ")", ")", "\n", "", "elif", "isinstance", "(", "item", ",", "slice", ")", ":", "\n", "            ", "indices", "=", "[", "]", "\n", "indptr", "=", "[", "]", "\n", "data", "=", "[", "]", "\n", "indptr_offset", "=", "int", "(", "0", ")", "\n", "batch_iter", "=", "range", "(", "item", ".", "start", ",", "item", ".", "stop", ",", "item", ".", "step", "if", "item", ".", "step", "is", "not", "None", "else", "1", ")", "\n", "for", "b", "in", "batch_iter", ":", "\n", "                ", "_indices", ",", "_indptr", ",", "_data", "=", "self", ".", "get_batch", "(", "b", ")", "\n", "indices", ".", "append", "(", "_indices", ")", "\n", "indptr", ".", "append", "(", "_indptr", "[", ":", "-", "1", "]", "+", "indptr_offset", ")", "\n", "data", ".", "append", "(", "_data", ")", "\n", "indptr_offset", "=", "indptr_offset", "+", "_indptr", "[", "-", "1", "]", "\n", "", "assert", "isinstance", "(", "indptr_offset", ",", "torch", ".", "Tensor", ")", "\n", "indptr", ".", "append", "(", "indptr_offset", ".", "view", "(", "1", ")", ")", "\n", "\n", "indices", "=", "torch", ".", "cat", "(", "indices", ")", "\n", "indptr", "=", "torch", ".", "cat", "(", "indptr", ")", "\n", "data", "=", "torch", ".", "cat", "(", "data", ")", "\n", "return", "self", ".", "__class__", "(", "[", "indices", ",", "indptr", ",", "data", "]", ",", "shape", "=", "[", "len", "(", "batch_iter", ")", "]", "+", "list", "(", "self", ".", "shape", "[", "1", ":", "3", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Index type {} not supported.'", ".", "format", "(", "type", "(", "item", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.__len__": [[125, 127], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device": [[128, 131], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "device", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "indices", ".", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.sptype": [[132, 135], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sptype", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.transpose": [[136, 138], ["None"], "methods", ["None"], ["", "def", "transpose", "(", "self", ",", "keep_type", "=", "False", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to": [[139, 151], ["isinstance", "csx_matrix.CSXMatrix3d.__class__", "isinstance", "csx_matrix.CSXMatrix3d.__class__", "ValueError", "x.to", "csx_matrix.CSXMatrix3d.data.to"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "to", "(", "self", ",", "tgt", ")", ":", "\n", "        ", "\"\"\"\n        Compatible to torch.Tensor.to()\n        :param tgt: target, can be torch.device or torch.dtype\n        :return: a new instance\n        \"\"\"", "\n", "if", "isinstance", "(", "tgt", ",", "torch", ".", "device", ")", ":", "\n", "            ", "return", "self", ".", "__class__", "(", "[", "x", ".", "to", "(", "tgt", ")", "for", "x", "in", "[", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", "]", "]", ",", "self", ".", "shape", ")", "\n", "", "elif", "isinstance", "(", "tgt", ",", "torch", ".", "dtype", ")", ":", "\n", "            ", "return", "self", ".", "__class__", "(", "[", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", ".", "to", "(", "tgt", ")", "]", ",", "self", ".", "shape", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data type not understood.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda": [[152, 158], ["csx_matrix.CSXMatrix3d.__class__", "x.cuda"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda"], ["", "", "def", "cuda", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compatible to torch.Tensor.cuda()\n        :return: a new instance on CUDA\n        \"\"\"", "\n", "return", "self", ".", "__class__", "(", "[", "x", ".", "cuda", "(", ")", "for", "x", "in", "[", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", "]", "]", ",", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu": [[159, 165], ["csx_matrix.CSXMatrix3d.__class__", "x.cpu"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["", "def", "cpu", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compatible to torch.Tensor.cpu()\n        :return: a new instance on CPU\n        \"\"\"", "\n", "return", "self", ".", "__class__", "(", "[", "x", ".", "cpu", "(", ")", "for", "x", "in", "[", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", "]", "]", ",", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy": [[166, 174], ["numpy.stack", "x.toarray", "csx_matrix.CSXMatrix3d.as_ssp"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_ssp"], ["", "def", "numpy", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return dense numpy array.\n        :return: dense numpy array.\n        \"\"\"", "\n", "ret", "=", "[", "x", ".", "toarray", "(", ")", "for", "x", "in", "self", ".", "as_ssp", "(", ")", "]", "\n", "ret", "=", "np", ".", "stack", "(", "ret", ",", "axis", "=", "0", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list": [[175, 191], ["zip", "ret.append"], "methods", ["None"], ["", "def", "as_list", "(", "self", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Return [indices, indptr, data] in a list.\n        :param mask: Optional. It should be an iterable containing 3 items, each indicating its corresponding attribute\n                     shall be masked out or not.\n        :return: [indices, indptr, data] * mask\n        \"\"\"", "\n", "attrs", "=", "[", "self", ".", "indices", ",", "self", ".", "indptr", ",", "self", ".", "data", "]", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "ret", "=", "[", "]", "\n", "for", "m", ",", "a", "in", "zip", "(", "mask", ",", "attrs", ")", ":", "\n", "                ", "if", "m", ":", "\n", "                    ", "ret", ".", "append", "(", "a", ")", "\n", "", "", "", "else", ":", "\n", "            ", "ret", "=", "attrs", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_ssp": [[192, 210], ["range", "csx_matrix.CSXMatrix3d.get_batch", "ret.append", "construct_func", "data.cpu().to().numpy", "indice.cpu().numpy", "indptr.cpu().numpy", "data.cpu().to", "indice.cpu", "indptr.cpu", "data.cpu"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.get_batch", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["", "def", "as_ssp", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return scipy.sparse matrix.\n        :return: list of scipy.sparse matrix\n        \"\"\"", "\n", "ret", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "self", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "indice", ",", "indptr", ",", "data", "=", "self", ".", "get_batch", "(", "b", ")", "\n", "construct_func", "=", "ssp", ".", "csr_matrix", "if", "self", ".", "sptype", "==", "'csr'", "else", "ssp", ".", "csc_matrix", "\n", "ret", ".", "append", "(", "\n", "construct_func", "(", "\n", "(", "data", ".", "cpu", "(", ")", ".", "to", "(", "dtype", "=", "data", ".", "dtype", ")", ".", "numpy", "(", ")", ",", "\n", "indice", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "indptr", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "shape", "=", "self", ".", "shape", "[", "1", ":", "3", "]", "\n", ")", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_sparse_torch": [[211, 237], ["torch.zeros", "range", "torch.sparse.FloatTensor", "range", "ValueError"], "methods", ["None"], ["", "def", "as_sparse_torch", "(", "self", ")", ":", "\n", "        ", "coo", "=", "torch", ".", "zeros", "(", "3", ",", "self", ".", "data", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "self", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "self", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "self", ".", "sptype", "==", "'csr'", ":", "\n", "                ", "start_ptr", "=", "b", "*", "self", ".", "shape", "[", "1", "]", "\n", "end_ptr", "=", "(", "b", "+", "1", ")", "*", "self", ".", "shape", "[", "1", "]", "+", "1", "\n", "compressed_len", "=", "self", ".", "shape", "[", "1", "]", "\n", "compressed_idx", "=", "1", "\n", "", "elif", "self", ".", "sptype", "==", "'csc'", ":", "\n", "                ", "start_ptr", "=", "b", "*", "self", ".", "shape", "[", "2", "]", "\n", "end_ptr", "=", "(", "b", "+", "1", ")", "*", "self", ".", "shape", "[", "2", "]", "+", "1", "\n", "compressed_len", "=", "self", ".", "shape", "[", "2", "]", "\n", "compressed_idx", "=", "2", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Data type not understood.'", ")", "\n", "", "indptr", "=", "self", ".", "indptr", "[", "start_ptr", ":", "end_ptr", "]", "\n", "coo", "[", "0", ",", "indptr", "[", "0", "]", ":", "indptr", "[", "-", "1", "]", "]", "=", "b", "\n", "for", "i", "in", "range", "(", "compressed_len", ")", ":", "\n", "                ", "coo", "[", "compressed_idx", ",", "indptr", "[", "i", "]", ":", "indptr", "[", "i", "+", "1", "]", "]", "=", "i", "\n", "\n", "", "", "if", "self", ".", "sptype", "==", "'csr'", ":", "\n", "            ", "coo", "[", "2", ",", ":", "]", "=", "self", ".", "indices", "\n", "", "else", ":", "\n", "            ", "coo", "[", "1", ",", ":", "]", "=", "self", ".", "indices", "\n", "\n", "", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "coo", ",", "self", ".", "data", ",", "self", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.get_batch": [[238, 260], ["csx_matrix.CSXMatrix3d.indptr[].clone", "csx_matrix.CSXMatrix3d.indices[].clone", "csx_matrix.CSXMatrix3d.data[].clone", "type", "IndexError", "ValueError"], "methods", ["None"], ["", "def", "get_batch", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"\n        Get a certain batch in tuple (indices, indptr, data)\n        :param item: batch index\n        :return: (indices, indptr, data)\n        \"\"\"", "\n", "if", "type", "(", "item", ")", "!=", "int", ":", "\n", "            ", "raise", "IndexError", "(", "'Only int indices is currently supported.'", ")", "\n", "\n", "", "if", "self", ".", "sptype", "==", "'csr'", ":", "\n", "            ", "start_idx", "=", "item", "*", "self", ".", "shape", "[", "1", "]", "\n", "end_idx", "=", "(", "item", "+", "1", ")", "*", "self", ".", "shape", "[", "1", "]", "+", "1", "\n", "", "elif", "self", ".", "sptype", "==", "'csc'", ":", "\n", "            ", "start_idx", "=", "item", "*", "self", ".", "shape", "[", "2", "]", "\n", "end_idx", "=", "(", "item", "+", "1", ")", "*", "self", ".", "shape", "[", "2", "]", "+", "1", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Data type not understood.'", ")", "\n", "", "indptr", "=", "self", ".", "indptr", "[", "start_idx", ":", "end_idx", "]", ".", "clone", "(", ")", "\n", "indice", "=", "self", ".", "indices", "[", "indptr", "[", "0", "]", ":", "indptr", "[", "-", "1", "]", "]", ".", "clone", "(", ")", "\n", "data", "=", "self", ".", "data", "[", "indptr", "[", "0", "]", ":", "indptr", "[", "-", "1", "]", "]", ".", "clone", "(", ")", "\n", "indptr", "=", "indptr", "-", "indptr", "[", "0", "]", "\n", "return", "indice", ",", "indptr", ",", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.shape_eq": [[261, 268], ["zip"], "methods", ["None"], ["", "def", "shape_eq", "(", "self", ",", "other", ")", ":", "\n", "        ", "ret", "=", "True", "\n", "for", "s_shape", ",", "o_shape", "in", "zip", "(", "self", ".", "shape", ",", "other", ".", "shape", ")", ":", "\n", "            ", "if", "s_shape", "!=", "o_shape", ":", "\n", "                ", "ret", "=", "False", "\n", "break", "\n", "", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSCMatrix3d.__init__": [[271, 293], ["csx_matrix.CSXMatrix3d.__init__", "isinstance", "type", "max", "max", "tuple", "type", "csx_matrix._max", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix._max"], ["    ", "def", "__init__", "(", "self", ",", "inp", ",", "shape", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "        ", "if", "type", "(", "inp", ")", "==", "list", "and", "isinstance", "(", "inp", "[", "0", "]", ",", "ssp", ".", "spmatrix", ")", ":", "\n", "            ", "max_shape", "=", "[", "0", ",", "0", "]", "\n", "for", "s", "in", "inp", ":", "\n", "                ", "max_shape", "[", "0", "]", "=", "max", "(", "max_shape", "[", "0", "]", ",", "s", ".", "shape", "[", "0", "]", ")", "\n", "max_shape", "[", "1", "]", "=", "max", "(", "max_shape", "[", "1", "]", ",", "s", ".", "shape", "[", "1", "]", ")", "\n", "", "if", "shape", "is", "None", ":", "\n", "                ", "shape", "=", "tuple", "(", "[", "len", "(", "inp", ")", "]", "+", "max_shape", ")", "\n", "", "else", ":", "\n", "                ", "assert", "shape", "[", "0", "]", "==", "len", "(", "inp", ")", "\n", "assert", "shape", "[", "1", "]", "<=", "max_shape", "[", "0", "]", "\n", "assert", "shape", "[", "2", "]", "<=", "max_shape", "[", "1", "]", "\n", "\n", "", "", "elif", "type", "(", "inp", ")", "==", "list", ":", "\n", "            ", "assert", "shape", "is", "not", "None", "\n", "batch", "=", "shape", "[", "0", "]", "\n", "row", "=", "_max", "(", "inp", "[", "0", "]", ")", "\n", "col", "=", "(", "len", "(", "inp", "[", "1", "]", ")", "-", "1", ")", "//", "batch", "\n", "assert", "shape", "[", "1", "]", ">=", "row", "\n", "assert", "shape", "[", "2", "]", "==", "col", "\n", "\n", "", "super", "(", "CSCMatrix3d", ",", "self", ")", ".", "__init__", "(", "inp", ",", "shape", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSCMatrix3d.sptype": [[294, 297], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sptype", "(", "self", ")", ":", "\n", "        ", "return", "'csc'", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSCMatrix3d.transpose": [[298, 310], ["list", "csx_matrix.CSRMatrix3d", "csx_matrix.CSCMatrix3d.as_ssp", "csx_matrix.CSCMatrix3d", "csx_matrix.CSCMatrix3d.as_list", "coo.append", "sp.transpose().tocoo().astype", "sp.transpose().tocoo", "sp.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_ssp", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "transpose", "(", "self", ",", "keep_type", "=", "False", ")", ":", "\n", "        ", "if", "not", "keep_type", ":", "\n", "            ", "shape_t", "=", "list", "(", "self", ".", "shape", ")", "\n", "tmp", "=", "shape_t", "[", "1", "]", "\n", "shape_t", "[", "1", "]", "=", "shape_t", "[", "2", "]", "\n", "shape_t", "[", "2", "]", "=", "tmp", "\n", "return", "CSRMatrix3d", "(", "self", ".", "as_list", "(", ")", ",", "shape", "=", "shape_t", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "coo", "=", "[", "]", "\n", "for", "sp", "in", "self", ".", "as_ssp", "(", ")", ":", "\n", "                ", "coo", ".", "append", "(", "sp", ".", "transpose", "(", ")", ".", "tocoo", "(", ")", ".", "astype", "(", "sp", ".", "dtype", ")", ")", "\n", "", "return", "CSCMatrix3d", "(", "coo", ",", "device", "=", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSCMatrix3d.Tdot": [[311, 320], ["csx_matrix.CSCMatrix3d.transpose", "csx_matrix.dot"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot"], ["", "", "def", "Tdot", "(", "self", ",", "other", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        The dot result of a TRANSPOSED CSC matrix and another CSC matrix.\n        This is equivalent to CSR dot CSC.\n        :param other: second CSC matrix\n        :return: dot product in a new CSR matrix\n        \"\"\"", "\n", "t_csr", "=", "self", ".", "transpose", "(", ")", "\n", "return", "dot", "(", "t_csr", ",", "other", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.__init__": [[323, 345], ["csx_matrix.CSXMatrix3d.__init__", "isinstance", "type", "max", "max", "tuple", "type", "csx_matrix._max", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix._max"], ["    ", "def", "__init__", "(", "self", ",", "inp", ",", "shape", "=", "None", ",", "device", "=", "None", ")", ":", "\n", "        ", "if", "type", "(", "inp", ")", "==", "list", "and", "isinstance", "(", "inp", "[", "0", "]", ",", "ssp", ".", "spmatrix", ")", ":", "\n", "            ", "max_shape", "=", "[", "0", ",", "0", "]", "\n", "for", "s", "in", "inp", ":", "\n", "                ", "max_shape", "[", "0", "]", "=", "max", "(", "max_shape", "[", "0", "]", ",", "s", ".", "shape", "[", "0", "]", ")", "\n", "max_shape", "[", "1", "]", "=", "max", "(", "max_shape", "[", "1", "]", ",", "s", ".", "shape", "[", "1", "]", ")", "\n", "", "if", "shape", "is", "None", ":", "\n", "                ", "shape", "=", "tuple", "(", "[", "len", "(", "inp", ")", "]", "+", "max_shape", ")", "\n", "", "else", ":", "\n", "                ", "assert", "shape", "[", "0", "]", "==", "len", "(", "inp", ")", "\n", "assert", "shape", "[", "1", "]", "<=", "max_shape", "[", "0", "]", "\n", "assert", "shape", "[", "2", "]", "<=", "max_shape", "[", "1", "]", "\n", "\n", "", "", "elif", "type", "(", "inp", ")", "==", "list", ":", "\n", "            ", "assert", "shape", "is", "not", "None", "\n", "batch", "=", "shape", "[", "0", "]", "\n", "row", "=", "(", "len", "(", "inp", "[", "1", "]", ")", "-", "1", ")", "//", "batch", "\n", "col", "=", "_max", "(", "inp", "[", "0", "]", ")", "\n", "assert", "shape", "[", "1", "]", "==", "row", "\n", "assert", "shape", "[", "2", "]", ">=", "col", "\n", "\n", "", "super", "(", "CSRMatrix3d", ",", "self", ")", ".", "__init__", "(", "inp", ",", "shape", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.sptype": [[346, 349], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sptype", "(", "self", ")", ":", "\n", "        ", "return", "'csr'", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose": [[350, 362], ["list", "csx_matrix.CSCMatrix3d", "csx_matrix.CSRMatrix3d.as_ssp", "csx_matrix.CSRMatrix3d", "csx_matrix.CSRMatrix3d.as_list", "coo.append", "sp.transpose().tocoo().astype", "sp.transpose().tocoo", "sp.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_ssp", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "transpose", "(", "self", ",", "keep_type", "=", "False", ")", ":", "\n", "        ", "if", "not", "keep_type", ":", "\n", "            ", "shape_t", "=", "list", "(", "self", ".", "shape", ")", "\n", "tmp", "=", "shape_t", "[", "1", "]", "\n", "shape_t", "[", "1", "]", "=", "shape_t", "[", "2", "]", "\n", "shape_t", "[", "2", "]", "=", "tmp", "\n", "return", "CSCMatrix3d", "(", "self", ".", "as_list", "(", ")", ",", "shape", "=", "shape_t", ",", "device", "=", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "coo", "=", "[", "]", "\n", "for", "sp", "in", "self", ".", "as_ssp", "(", ")", ":", "\n", "                ", "coo", ".", "append", "(", "sp", ".", "transpose", "(", ")", ".", "tocoo", "(", ")", ".", "astype", "(", "sp", ".", "dtype", ")", ")", "\n", "", "return", "CSRMatrix3d", "(", "coo", ",", "device", "=", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.dot": [[363, 370], ["csx_matrix.CSRMatrix3d.dot"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot"], ["", "", "def", "dot", "(", "self", ",", "other", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Dot product of this CSR matrix and a CSC matrix.\n        :param other: CSC matrix.\n        :return: dot product in CSR matrix\n        \"\"\"", "\n", "return", "dot", "(", "self", ",", "other", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.dotdiag": [[371, 403], ["sparse_dot.csr_dot_diag", "csx_matrix.CSRMatrix3d", "csx_matrix.CSRMatrix3d.as_list"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list"], ["", "def", "dotdiag", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"\n        Dot product of this CSR matrix and a diagonal matrix from a vector.\n        :param other: input vector.\n        :return: dot product in CSR matrix\n        \"\"\"", "\n", "assert", "self", ".", "shape", "[", "0", "]", "==", "other", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch'", "\n", "assert", "self", ".", "shape", "[", "2", "]", "==", "other", ".", "shape", "[", "1", "]", ",", "'Matrix shape mismatch'", "\n", "batch_size", "=", "self", ".", "shape", "[", "0", "]", "\n", "out_h", "=", "self", ".", "shape", "[", "1", "]", "\n", "out_w", "=", "self", ".", "shape", "[", "2", "]", "\n", "\n", "result", "=", "sparse_dot", ".", "csr_dot_diag", "(", "*", "self", ".", "as_list", "(", ")", ",", "other", ",", "batch_size", ",", "out_h", ",", "out_w", ")", "\n", "ret", "=", "CSRMatrix3d", "(", "result", ",", "shape", "=", "self", ".", "shape", ")", "\n", "'''\n        indptr = self.indptr.clone()\n        indice = self.indices.clone()\n        data = self.data.clone()\n\n        for b in range(batch_size):\n            start_idx = b * self.shape[1]\n            end_idx = (b + 1) * self.shape[1] + 1\n            indp_b = indptr[start_idx: end_idx]\n            indx_b = indice[indp_b[0]: indp_b[-1]]\n            data_b = data[indp_b[0]: indp_b[-1]]\n\n            for j in range(self.shape[2]):\n                data_b[indx_b == j] *= other[b, j]\n\n        ret = CSRMatrix3d([indice, indptr, data], self.shape)\n        '''", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.dot": [[405, 434], ["type", "type", "torch.device", "sparse_dot.csr_dot_csc", "csx_matrix.CSRMatrix3d", "sparse_dot.csr_dot_csc_dense_cuda", "ret.numpy.numpy", "RuntimeWarning", "csr.as_list", "csc.as_list", "csr.as_list", "csc.as_list"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.device", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.as_list"], ["", "", "def", "dot", "(", "csr", ":", "CSRMatrix3d", ",", "csc", ":", "CSCMatrix3d", ",", "dense", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Compute the dot product of one CSR matrix and one CSC matrix. The result will be returned in a new CSR or dense\n    matrix. Note that CUDA implementations do not work when dense=False.\n    :param csr: fist input CSR matrix\n    :param csc: second input CSC matrix\n    :param dense: output matrix in dense format\n    :return: dot result in new csr matrix (dense=False) or\n             dot result in dense matrix (dense=True)\n    \"\"\"", "\n", "assert", "type", "(", "csr", ")", "==", "CSRMatrix3d", "\n", "assert", "type", "(", "csc", ")", "==", "CSCMatrix3d", "\n", "assert", "csr", ".", "shape", "[", "0", "]", "==", "csc", ".", "shape", "[", "0", "]", ",", "'Batch size mismatch'", "\n", "batch_num", "=", "csr", ".", "shape", "[", "0", "]", "\n", "assert", "csr", ".", "shape", "[", "2", "]", "==", "csc", ".", "shape", "[", "1", "]", ",", "'Matrix size mismatch'", "\n", "out_h", "=", "csr", ".", "shape", "[", "1", "]", "\n", "out_w", "=", "csc", ".", "shape", "[", "2", "]", "\n", "\n", "if", "csr", ".", "indptr", ".", "device", "==", "torch", ".", "device", "(", "'cpu'", ")", ":", "\n", "        ", "new_indices", ",", "new_indptr", ",", "new_data", "=", "sparse_dot", ".", "csr_dot_csc", "(", "*", "csr", ".", "as_list", "(", ")", ",", "*", "csc", ".", "as_list", "(", ")", ",", "batch_num", ",", "out_h", ",", "out_w", ")", "\n", "ret", "=", "CSRMatrix3d", "(", "[", "new_indices", ",", "new_indptr", ",", "new_data", "]", ",", "shape", "=", "(", "batch_num", ",", "out_h", ",", "out_w", ")", ")", "\n", "if", "dense", ":", "\n", "            ", "ret", "=", "ret", ".", "numpy", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "not", "dense", ":", "\n", "            ", "raise", "RuntimeWarning", "(", "'Sparse dot product result in CUDA is not implemented.'", ")", "\n", "", "ret", "=", "sparse_dot", ".", "csr_dot_csc_dense_cuda", "(", "*", "csr", ".", "as_list", "(", ")", ",", "*", "csc", ".", "as_list", "(", ")", ",", "batch_num", ",", "out_h", ",", "out_w", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.concatenate": [[436, 471], ["type", "torch.cat.append", "torch.cat", "torch.cat", "torch.cat", "type.", "torch.cat.append", "torch.cat.append", "torch.cat.append", "mat.indptr[].to", "indptr_offset.to.to", "indptr_offset.to.view", "type", "mat.indices.clone().to", "mat.data.clone().to", "mat.indptr[].clone().to", "mat.indices.clone", "mat.data.clone", "mat.indptr[].clone"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["", "def", "concatenate", "(", "*", "mats", ":", "CSXMatrix3d", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Concatenate multiple sparse matrix in first (batch) dimension.\n    :param mats: sequence of input matrix\n    :return: concatenated matrix\n    \"\"\"", "\n", "device", "=", "mats", "[", "0", "]", ".", "device", "if", "device", "is", "None", "else", "device", "\n", "\n", "mat_type", "=", "type", "(", "mats", "[", "0", "]", ")", "\n", "mat_h", "=", "mats", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "mat_w", "=", "mats", "[", "0", "]", ".", "shape", "[", "2", "]", "\n", "batch_size", "=", "0", "\n", "\n", "indptr_offset", "=", "0", "\n", "indices", "=", "[", "]", "\n", "indptr", "=", "[", "]", "\n", "data", "=", "[", "]", "\n", "for", "mat", "in", "mats", ":", "\n", "        ", "assert", "type", "(", "mat", ")", "==", "mat_type", ",", "'Matrix type inconsistent'", "\n", "assert", "mat", ".", "shape", "[", "1", "]", "==", "mat_h", ",", "'Matrix shape inconsistent in dimension 1'", "\n", "assert", "mat", ".", "shape", "[", "2", "]", "==", "mat_w", ",", "'Matrix shape inconsistent in dimension 2'", "\n", "indices", ".", "append", "(", "mat", ".", "indices", ".", "clone", "(", ")", ".", "to", "(", "device", ")", ")", "\n", "indptr", ".", "append", "(", "mat", ".", "indptr", "[", ":", "-", "1", "]", ".", "clone", "(", ")", ".", "to", "(", "device", ")", "+", "indptr_offset", ")", "\n", "data", ".", "append", "(", "mat", ".", "data", ".", "clone", "(", ")", ".", "to", "(", "device", ")", ")", "\n", "indptr_offset", "+=", "mat", ".", "indptr", "[", "-", "1", "]", ".", "to", "(", "device", ")", "\n", "indptr_offset", "=", "indptr_offset", ".", "to", "(", "device", ")", "\n", "batch_size", "+=", "mat", ".", "shape", "[", "0", "]", "\n", "\n", "", "indptr", ".", "append", "(", "indptr_offset", ".", "view", "(", "1", ")", ")", "\n", "\n", "indices", "=", "torch", ".", "cat", "(", "indices", ")", "\n", "indptr", "=", "torch", ".", "cat", "(", "indptr", ")", "\n", "data", "=", "torch", ".", "cat", "(", "data", ")", "\n", "\n", "return", "mat_type", "(", "[", "indices", ",", "indptr", ",", "data", "]", ",", "shape", "=", "(", "batch_size", ",", "mat_h", ",", "mat_w", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix._max": [[473, 480], ["type", "numpy.max", "type", "torch.max", "ValueError", "type"], "function", ["None"], ["", "def", "_max", "(", "inp", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "type", "(", "inp", ")", "==", "np", ".", "ndarray", ":", "\n", "        ", "return", "np", ".", "max", "(", "inp", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "type", "(", "inp", ")", "==", "torch", ".", "Tensor", ":", "\n", "        ", "return", "torch", ".", "max", "(", "inp", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Data type {} not understood.'", ".", "format", "(", "type", "(", "inp", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.affinity_layer.InnerpAffinity.__init__": [[22, 29], ["torch.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.ReLU", "torch.ReLU", "affinity_layer.InnerpAffinity.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "super", "(", "InnerpAffinity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "d", "=", "d", "\n", "self", ".", "lambda1", "=", "Parameter", "(", "Tensor", "(", "self", ".", "d", ",", "self", ".", "d", ")", ")", "\n", "self", ".", "lambda2", "=", "Parameter", "(", "Tensor", "(", "self", ".", "d", ",", "self", ".", "d", ")", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "# problem: if weight<0, then always grad=0. So this parameter is never updated!", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.affinity_layer.InnerpAffinity.reset_parameters": [[30, 36], ["affinity_layer.InnerpAffinity.lambda1.data.uniform_", "affinity_layer.InnerpAffinity.lambda2.data.uniform_", "math.sqrt", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "affinity_layer.InnerpAffinity.lambda1.size"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "lambda1", ".", "size", "(", "1", ")", "*", "2", ")", "\n", "self", ".", "lambda1", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "lambda2", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "lambda1", ".", "data", "+=", "torch", ".", "eye", "(", "self", ".", "d", ")", "/", "2", "\n", "self", ".", "lambda2", ".", "data", "+=", "torch", ".", "eye", "(", "self", ".", "d", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.affinity_layer.InnerpAffinity.forward": [[37, 48], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "affinity_layer.InnerpAffinity.relu", "affinity_layer.InnerpAffinity.relu", "X.transpose", "Ux.transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "affinity_layer.InnerpAffinity.lambda1.transpose", "affinity_layer.InnerpAffinity.lambda2.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "X", ",", "Y", ",", "Ux", ",", "Uy", ",", "w1", "=", "1", ",", "w2", "=", "1", ")", ":", "\n", "        ", "assert", "X", ".", "shape", "[", "1", "]", "==", "Y", ".", "shape", "[", "1", "]", "==", "2", "*", "self", ".", "d", "\n", "lambda1", "=", "self", ".", "relu", "(", "self", ".", "lambda1", "+", "self", ".", "lambda1", ".", "transpose", "(", "0", ",", "1", ")", ")", "*", "w1", "\n", "lambda2", "=", "self", ".", "relu", "(", "self", ".", "lambda2", "+", "self", ".", "lambda2", ".", "transpose", "(", "0", ",", "1", ")", ")", "*", "w2", "\n", "weight", "=", "torch", ".", "cat", "(", "(", "torch", ".", "cat", "(", "(", "lambda1", ",", "lambda2", ")", ")", ",", "\n", "torch", ".", "cat", "(", "(", "lambda2", ",", "lambda1", ")", ")", ")", ",", "1", ")", "\n", "Me", "=", "torch", ".", "matmul", "(", "X", ".", "transpose", "(", "1", ",", "2", ")", ",", "weight", ")", "\n", "Me", "=", "torch", ".", "matmul", "(", "Me", ",", "Y", ")", "\n", "Mp", "=", "torch", ".", "matmul", "(", "Ux", ".", "transpose", "(", "1", ",", "2", ")", ",", "Uy", ")", "\n", "\n", "return", "Me", ",", "Mp", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.affinity_layer.GaussianAffinity.__init__": [[62, 66], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "d", ",", "sigma", ")", ":", "\n", "        ", "super", "(", "GaussianAffinity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "d", "=", "d", "\n", "self", ".", "sigma", "=", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.affinity_layer.GaussianAffinity.forward": [[67, 82], ["X.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "Y.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "float", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "X.unsqueeze().expand.unsqueeze().expand.unsqueeze", "Y.unsqueeze().expand.unsqueeze().expand.unsqueeze", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "Ux.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "X", ",", "Y", ",", "Ux", "=", "None", ",", "Uy", "=", "None", ",", "ae", "=", "1.", ",", "ap", "=", "1.", ")", ":", "\n", "        ", "assert", "X", ".", "shape", "[", "1", "]", "==", "Y", ".", "shape", "[", "1", "]", "==", "self", ".", "d", "\n", "\n", "X", "=", "X", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "*", "X", ".", "shape", ",", "Y", ".", "shape", "[", "2", "]", ")", "\n", "Y", "=", "Y", ".", "unsqueeze", "(", "-", "2", ")", ".", "expand", "(", "*", "Y", ".", "shape", "[", ":", "2", "]", ",", "X", ".", "shape", "[", "2", "]", ",", "Y", ".", "shape", "[", "2", "]", ")", "\n", "# dist = torch.sum(torch.pow(torch.mul(X - Y, self.w.unsqueeze(0).unsqueeze(-1).unsqueeze(-1)), 2), dim=1)", "\n", "dist", "=", "torch", ".", "sum", "(", "torch", ".", "pow", "(", "X", "-", "Y", ",", "2", ")", ",", "dim", "=", "1", ")", "\n", "dist", "[", "torch", ".", "isnan", "(", "dist", ")", "]", "=", "float", "(", "\"Inf\"", ")", "\n", "Me", "=", "torch", ".", "exp", "(", "-", "dist", "/", "self", ".", "sigma", ")", "*", "ae", "\n", "\n", "if", "Ux", "is", "None", "or", "Uy", "is", "None", ":", "\n", "            ", "return", "Me", "\n", "", "else", ":", "\n", "            ", "Mp", "=", "torch", ".", "matmul", "(", "Ux", ".", "transpose", "(", "1", ",", "2", ")", ",", "Uy", ")", "*", "ap", "\n", "return", "Me", ",", "Mp", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.model.Net.__init__": [[19, 29], ["CNN.__init__", "models.GMN.affinity_layer.InnerpAffinity", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.LocalResponseNorm", "src.qap_solvers.spectral_matching.SpectralMatching", "src.qap_solvers.rrwm.RRWM"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "affinity_layer", "=", "Affinity", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", ")", "\n", "if", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'SM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "SpectralMatching", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "PI_ITER_NUM", ",", "stop_thresh", "=", "cfg", ".", "GMN", ".", "PI_STOP_THRESH", ")", "\n", "", "elif", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'RRWM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "RRWM", "(", ")", "\n", "", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.model.Net.forward": [[30, 92], ["src.build_graphs.reshape_edge_feature", "src.build_graphs.reshape_edge_feature", "model.Net.affinity_layer", "src.factorize_graph_matching.construct_aff_mat", "model.Net.gm_solver", "model.Net.view().transpose", "model.Net.sinkhorn", "data_dict.update", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "ValueError", "model.Net.view", "src.lap_solvers.hungarian.hungarian"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian"], ["", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n", "src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.voting_layer.Voting.__init__": [[17, 22], ["torch.Module.__init__", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "200", ",", "pixel_thresh", "=", "None", ")", ":", "\n", "        ", "super", "(", "Voting", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "# Voting among columns", "\n", "self", ".", "pixel_thresh", "=", "pixel_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GMN.voting_layer.Voting.forward": [[23, 36], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "voting_layer.Voting.softmax", "voting_layer.Voting.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "s", ",", "nrow_gt", ",", "ncol_gt", "=", "None", ")", ":", "\n", "# TODO discard dummy nodes & far away nodes", "\n", "        ", "ret_s", "=", "torch", ".", "zeros_like", "(", "s", ")", "\n", "# filter dummy nodes", "\n", "for", "b", ",", "n", "in", "enumerate", "(", "nrow_gt", ")", ":", "\n", "            ", "if", "ncol_gt", "is", "None", ":", "\n", "                ", "ret_s", "[", "b", ",", "0", ":", "n", ",", ":", "]", "=", "self", ".", "softmax", "(", "self", ".", "alpha", "*", "s", "[", "b", ",", "0", ":", "n", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "                ", "ret_s", "[", "b", ",", "0", ":", "n", ",", "0", ":", "ncol_gt", "[", "b", "]", "]", "=", "self", ".", "softmax", "(", "self", ".", "alpha", "*", "s", "[", "b", ",", "0", ":", "n", ",", "0", ":", "ncol_gt", "[", "b", "]", "]", ")", "\n", "\n", "", "", "return", "ret_s", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.affinity_layer.InnerProductWithWeightsAffinity.__init__": [[6, 10], ["torch.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["\n", "\n", "class", "InnerpAffinity", "(", "nn", ".", "Module", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.affinity_layer.InnerProductWithWeightsAffinity._forward": [[11, 17], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "affinity_layer.InnerProductWithWeightsAffinity.A", "Y.transpose", "torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.nn.functional.softplus", "torch.nn.functional.softplus"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.affinity_layer.InnerProductWithWeightsAffinity.forward": [[18, 20], ["affinity_layer.InnerProductWithWeightsAffinity._forward", "zip"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.affinity_layer.InnerProductWithWeightsAffinity._forward"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SConv.__init__": [[8, 23], ["super().__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "sconv_archs.SConv.reset_parameters", "torch_geometric.nn.SplineConv", "sconv_archs.SConv.convs.append"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "input_features", ",", "output_features", ")", ":", "\n", "        ", "super", "(", "SConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "in_channels", "=", "input_features", "\n", "self", ".", "num_layers", "=", "2", "\n", "self", ".", "convs", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "conv", "=", "SplineConv", "(", "input_features", ",", "output_features", ",", "dim", "=", "2", ",", "kernel_size", "=", "5", ",", "aggr", "=", "\"max\"", ")", "\n", "self", ".", "convs", ".", "append", "(", "conv", ")", "\n", "input_features", "=", "output_features", "\n", "\n", "", "input_features", "=", "output_features", "\n", "self", ".", "out_channels", "=", "input_features", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SConv.reset_parameters": [[24, 27], ["conv.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "for", "conv", "in", "self", ".", "convs", ":", "\n", "            ", "conv", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SConv.forward": [[28, 37], ["torch.relu", "torch.relu", "torch.relu", "conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", ",", "edge_index", ",", "edge_attr", "=", "data", ".", "x", ",", "data", ".", "edge_index", ",", "data", ".", "edge_attr", "\n", "xs", "=", "[", "x", "]", "\n", "\n", "for", "conv", "in", "self", ".", "convs", "[", ":", "-", "1", "]", ":", "\n", "            ", "xs", "+=", "[", "F", ".", "relu", "(", "conv", "(", "xs", "[", "-", "1", "]", ",", "edge_index", ",", "edge_attr", ")", ")", "]", "\n", "\n", "", "xs", "+=", "[", "self", ".", "convs", "[", "-", "1", "]", "(", "xs", "[", "-", "1", "]", ",", "edge_index", ",", "edge_attr", ")", "]", "\n", "return", "xs", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseSConvOnNodes.__init__": [[40, 44], ["super().__init__", "sconv_archs.SConv"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_node_dim", ")", ":", "\n", "        ", "super", "(", "SiameseSConvOnNodes", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_node_features", "=", "input_node_dim", "\n", "self", ".", "mp_network", "=", "SConv", "(", "input_features", "=", "self", ".", "num_node_features", ",", "output_features", "=", "self", ".", "num_node_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseSConvOnNodes.forward": [[45, 50], ["sconv_archs.SiameseSConvOnNodes.mp_network"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "graph", ")", ":", "\n", "        ", "old_features", "=", "graph", ".", "x", "\n", "result", "=", "self", ".", "mp_network", "(", "graph", ")", "\n", "graph", ".", "x", "=", "old_features", "+", "0.1", "*", "result", "\n", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.__init__": [[53, 56], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "total_num_nodes", ")", ":", "\n", "        ", "super", "(", "SiameseNodeFeaturesToEdgeFeatures", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_edge_features", "=", "total_num_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.forward": [[57, 63], ["graph.to_data_list", "sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_edge_attr", "sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_hyperedge_attr"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_edge_attr", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_hyperedge_attr"], ["", "def", "forward", "(", "self", ",", "graph", ",", "hyperedge", "=", "False", ")", ":", "\n", "        ", "orig_graphs", "=", "graph", ".", "to_data_list", "(", ")", "\n", "orig_graphs", "=", "[", "self", ".", "vertex_attr_to_edge_attr", "(", "graph", ")", "for", "graph", "in", "orig_graphs", "]", "\n", "if", "hyperedge", ":", "\n", "            ", "orig_graphs", "=", "[", "self", ".", "vertex_attr_to_hyperedge_attr", "(", "graph", ")", "for", "graph", "in", "orig_graphs", "]", "\n", "", "return", "orig_graphs", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_edge_attr": [[64, 74], ["graph.edge_index.transpose().reshape", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select.reshape().transpose", "torch.index_select.reshape().transpose", "torch.index_select.reshape().transpose", "graph.edge_index.transpose", "torch.index_select.reshape", "torch.index_select.reshape", "torch.index_select.reshape"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "vertex_attr_to_edge_attr", "(", "self", ",", "graph", ")", ":", "\n", "        ", "\"\"\"Assigns the difference of node features to each edge\"\"\"", "\n", "flat_edges", "=", "graph", ".", "edge_index", ".", "transpose", "(", "0", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "vertex_attrs", "=", "torch", ".", "index_select", "(", "graph", ".", "x", ",", "dim", "=", "0", ",", "index", "=", "flat_edges", ")", "\n", "\n", "new_shape", "=", "(", "graph", ".", "edge_index", ".", "shape", "[", "1", "]", ",", "2", ",", "vertex_attrs", ".", "shape", "[", "1", "]", ")", "\n", "vertex_attrs_reshaped", "=", "vertex_attrs", ".", "reshape", "(", "new_shape", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "new_edge_attrs", "=", "vertex_attrs_reshaped", "[", "0", "]", "-", "vertex_attrs_reshaped", "[", "1", "]", "\n", "graph", ".", "edge_attr", "=", "new_edge_attrs", "\n", "return", "graph", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures.vertex_attr_to_hyperedge_attr": [[75, 97], ["graph.hyperedge_index.transpose().reshape", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select.reshape().transpose", "torch.index_select.reshape().transpose", "torch.index_select.reshape().transpose", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "graph.hyperedge_index.transpose", "torch.index_select.reshape", "torch.index_select.reshape", "torch.index_select.reshape"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "vertex_attr_to_hyperedge_attr", "(", "self", ",", "graph", ")", ":", "\n", "        ", "\"\"\"Assigns the angle of node features to each hyperedge.\n           graph.hyperedge_index is the incidence matrix.\"\"\"", "\n", "flat_edges", "=", "graph", ".", "hyperedge_index", ".", "transpose", "(", "0", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "vertex_attrs", "=", "torch", ".", "index_select", "(", "graph", ".", "x", ",", "dim", "=", "0", ",", "index", "=", "flat_edges", ")", "\n", "\n", "new_shape", "=", "(", "graph", ".", "hyperedge_index", ".", "shape", "[", "1", "]", ",", "3", ",", "vertex_attrs", ".", "shape", "[", "1", "]", ")", "\n", "\n", "vertex_attrs_reshaped", "=", "vertex_attrs", ".", "reshape", "(", "new_shape", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "v01", "=", "vertex_attrs_reshaped", "[", "0", "]", "-", "vertex_attrs_reshaped", "[", "1", "]", "\n", "v02", "=", "vertex_attrs_reshaped", "[", "0", "]", "-", "vertex_attrs_reshaped", "[", "2", "]", "\n", "v12", "=", "vertex_attrs_reshaped", "[", "1", "]", "-", "vertex_attrs_reshaped", "[", "2", "]", "\n", "nv01", "=", "torch", ".", "norm", "(", "v01", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "nv02", "=", "torch", ".", "norm", "(", "v02", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "nv12", "=", "torch", ".", "norm", "(", "v12", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "\n", "cos1", "=", "torch", ".", "sum", "(", "v01", "*", "v02", ",", "dim", "=", "-", "1", ")", "/", "(", "nv01", "*", "nv02", ")", "\n", "cos2", "=", "torch", ".", "sum", "(", "-", "v01", "*", "v12", ",", "dim", "=", "-", "1", ")", "/", "(", "nv01", "*", "nv12", ")", "\n", "cos3", "=", "torch", ".", "sum", "(", "-", "v12", "*", "-", "v02", ",", "dim", "=", "-", "1", ")", "/", "(", "nv12", "*", "nv02", ")", "\n", "\n", "graph", ".", "hyperedge_attr", "=", "torch", ".", "stack", "(", "(", "cos1", ",", "cos2", ",", "cos3", ")", ",", "dim", "=", "-", "1", ")", "\n", "return", "graph", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.model.Net.__init__": [[30, 43], ["CNN.__init__", "models.BBGM.sconv_archs.SiameseSConvOnNodes", "models.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n", "src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.model.Net.forward": [[44, 154], ["len", "zip", "model.Net.node_layers", "model.Net.edge_layers", "global_list.append", "model.normalize_over_channels", "model.normalize_over_channels", "model.concat_features", "model.concat_features", "torch.cat", "model.Net.message_pass_node_features", "model.Net.build_edge_features_from_node_features", "orig_graph_list.append", "torch.cat", "model.normalize_over_channels", "model.Net.vertex_affinity", "model.Net.edge_affinity", "data_dict.update", "data_dict[].values", "ValueError", "model.Net.final_layers().reshape", "src.feature_align.feature_align", "src.feature_align.feature_align", "model.lexico_iter", "zip", "zip", "lpmp_py.GraphMatchingModule", "lpmp_py.MultiGraphMatchingModule.", "lpmp_py.MultiGraphMatchingModule", "lpmp_py.MultiGraphMatchingModule.", "ValueError", "list", "data_dict.update", "model.lexico_iter", "zip", "model.lexico_iter", "zip", "zip", "model.lexico_iter", "model.Net.final_layers", "zip", "model.lexico_iter", "model.lexico_iter", "model.lexico_iter", "range"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter"], ["tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.model.lexico_iter": [[16, 18], ["itertools.combinations"], "function", ["None"], ["\n", "\n", "class", "Net", "(", "CNN", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.model.normalize_over_channels": [[19, 22], ["torch.norm"], "function", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "affinity_layer", "=", "Affinity", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", ")", "\n", "if", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'SM'", ":", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.BBGM.model.concat_features": [[24, 27], ["torch.cat", "torch.cat.transpose", "zip"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "elif", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'RRWM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "RRWM", "(", ")", "\n", "", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.Affinity.__init__": [[16, 21], ["torch.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "affinity_layer.Affinity.reset_parameters", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.Affinity.reset_parameters": [[22, 26], ["affinity_layer.Affinity.A.data.uniform_", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "math.sqrt"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "super", "(", "InnerpAffinity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "d", "=", "d", "\n", "self", ".", "lambda1", "=", "Parameter", "(", "Tensor", "(", "self", ".", "d", ",", "self", ".", "d", ")", ")", "\n", "self", ".", "lambda2", "=", "Parameter", "(", "Tensor", "(", "self", ".", "d", ",", "self", ".", "d", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.Affinity.forward": [[27, 33], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "Y.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "# problem: if weight<0, then always grad=0. So this parameter is never updated!", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n", "", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "lambda1", ".", "size", "(", "1", ")", "*", "2", ")", "\n", "self", ".", "lambda1", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "lambda2", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityInp.__init__": [[42, 45], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["torch", ".", "cat", "(", "(", "lambda2", ",", "lambda1", ")", ")", ")", ",", "1", ")", "\n", "Me", "=", "torch", ".", "matmul", "(", "X", ".", "transpose", "(", "1", ",", "2", ")", ",", "weight", ")", "\n", "Me", "=", "torch", ".", "matmul", "(", "Me", ",", "Y", ")", "\n", "Mp", "=", "torch", ".", "matmul", "(", "Ux", ".", "transpose", "(", "1", ",", "2", ")", ",", "Uy", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityInp.forward": [[46, 50], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "Y.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["\n", "return", "Me", ",", "Mp", "\n", "\n", "\n", "", "", "class", "GaussianAffinity", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityLR.__init__": [[54, 61], ["torch.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.ReLU", "torch.ReLU", "affinity_layer.AffinityLR.reset_parameters", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityLR.reset_parameters": [[62, 65], ["affinity_layer.AffinityLR.A.data.uniform_", "math.sqrt"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "d", ",", "sigma", ")", ":", "\n", "        ", "super", "(", "GaussianAffinity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "d", "=", "d", "\n", "self", ".", "sigma", "=", "sigma", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityLR.forward": [[66, 73], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "affinity_layer.AffinityLR.relu", "affinity_layer.AffinityLR.A.transpose", "Y.transpose", "torch.matmul.squeeze", "torch.matmul.squeeze"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["\n", "", "def", "forward", "(", "self", ",", "X", ",", "Y", ",", "Ux", "=", "None", ",", "Uy", "=", "None", ",", "ae", "=", "1.", ",", "ap", "=", "1.", ")", ":", "\n", "        ", "assert", "X", ".", "shape", "[", "1", "]", "==", "Y", ".", "shape", "[", "1", "]", "==", "self", ".", "d", "\n", "\n", "X", "=", "X", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "*", "X", ".", "shape", ",", "Y", ".", "shape", "[", "2", "]", ")", "\n", "Y", "=", "Y", ".", "unsqueeze", "(", "-", "2", ")", ".", "expand", "(", "*", "Y", ".", "shape", "[", ":", "2", "]", ",", "X", ".", "shape", "[", "2", "]", ",", "Y", ".", "shape", "[", "2", "]", ")", "\n", "# dist = torch.sum(torch.pow(torch.mul(X - Y, self.w.unsqueeze(0).unsqueeze(-1).unsqueeze(-1)), 2), dim=1)", "\n", "dist", "=", "torch", ".", "sum", "(", "torch", ".", "pow", "(", "X", "-", "Y", ",", "2", ")", ",", "dim", "=", "1", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityMah.__init__": [[75, 82], ["torch.Module.__init__", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.ReLU", "torch.ReLU", "affinity_layer.AffinityMah.reset_parameters", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], ["Me", "=", "torch", ".", "exp", "(", "-", "dist", "/", "self", ".", "sigma", ")", "*", "ae", "\n", "\n", "if", "Ux", "is", "None", "or", "Uy", "is", "None", ":", "\n", "            ", "return", "Me", "\n", "", "else", ":", "\n", "            ", "Mp", "=", "torch", ".", "matmul", "(", "Ux", ".", "transpose", "(", "1", ",", "2", ")", ",", "Uy", ")", "*", "ap", "\n", "return", "Me", ",", "Mp", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityMah.reset_parameters": [[83, 86], ["affinity_layer.AffinityMah.A.data.uniform_", "math.sqrt"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityMah.forward": [[87, 97], ["X.unsqueeze.unsqueeze.unsqueeze", "Y.unsqueeze.unsqueeze.unsqueeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "affinity_layer.AffinityMah.relu", "affinity_layer.AffinityMah.A.transpose", "dxy.unsqueeze", "dxy.unsqueeze", "torch.matmul.squeeze", "torch.matmul.squeeze"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityFC.__init__": [[107, 123], ["torch.Module.__init__", "affinity_layer.AffinityFC.hds.append", "torch.Sequential", "torch.Sequential", "fc_lst.append", "fc_lst.append", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityFC.forward": [[124, 130], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "affinity_layer.AffinityFC.fc().squeeze", "X.unsqueeze().expand", "Y.unsqueeze().expand", "affinity_layer.AffinityFC.fc", "X.unsqueeze", "Y.unsqueeze"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.__init__": [[140, 158], ["torch.Module.__init__", "affinity_layer.AffinityBiFC.hds.append", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "affinity_layer.AffinityBiFC.reset_parameters", "torch.Sequential", "torch.Sequential", "torch.Tensor", "torch.Tensor", "fc_lst.append", "fc_lst.append", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.reset_parameters": [[159, 162], ["affinity_layer.AffinityBiFC.A.data.uniform_", "math.sqrt"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.affinity_layer.AffinityBiFC.forward": [[163, 174], ["torch.empty", "torch.empty", "torch.empty", "torch.empty", "range", "affinity_layer.AffinityBiFC.fc", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "len", "Y.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.model.Net.__init__": [[18, 36], ["CNN.__init__", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "range", "model.Net.add_module", "model.Net.add_module", "src.gconv.Siamese_Gconv", "src.gconv.Siamese_Gconv", "models.PCA.affinity_layer.Affinity", "model.Net.add_module", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["class", "Net", "(", "CNN", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "affinity_layer", "=", "Affinity", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", ")", "\n", "if", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'SM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "SpectralMatching", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "PI_ITER_NUM", ",", "stop_thresh", "=", "cfg", ".", "GMN", ".", "PI_STOP_THRESH", ")", "\n", "", "elif", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'RRWM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "RRWM", "(", ")", "\n", "", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n", "", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.model.Net.reload_backbone": [[37, 39], ["model.Net.get_backbone"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.backbone.VGG16_base.get_backbone"], ["H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.PCA.model.Net.forward": [[41, 127], ["data_dict.update", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "range", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "ValueError", "getattr", "getattr.", "getattr", "getattr.", "model.Net.sinkhorn", "ss.append", "getattr", "getattr.", "getattr", "getattr.", "getattr.", "getattr", "getattr.", "getattr", "getattr.", "model.Net.sinkhorn", "ss.append", "src.lap_solvers.hungarian.hungarian", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "getattr", "getattr.", "getattr.", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "model.Net.transpose", "model.Net.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.__init__": [[23, 40], ["CNN.__init__", "models.PCA.affinity_layer.AffinityInp", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "models.GANN.graduated_assignment.GA_GM"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["            ", "self", ".", "gm_solver", "=", "SpectralMatching", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "PI_ITER_NUM", ",", "stop_thresh", "=", "cfg", ".", "GMN", ".", "PI_STOP_THRESH", ")", "\n", "", "elif", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'RRWM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "RRWM", "(", ")", "\n", "", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n", "", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.forward": [[41, 101], ["model.Net.real_forward", "model.Net.collect_intra_class_matching_wrapper", "cluster_v.cpu().numpy().tolist", "range", "len", "cluster_v.cpu().numpy().tolist.append", "range", "data_dict.update", "data_dict.update", "data_dict.update", "data_dict.update", "cluster_v.cpu().numpy", "len", "cls_indicator[].append", "cluster_v.cpu"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.real_forward", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.collect_intra_class_matching_wrapper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.numpy", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu"], ["src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.real_forward": [[103, 212], ["zip", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "itertools.product", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.Net.node_layers", "model.Net.edge_layers", "src.feature_align.feature_align", "src.feature_align.feature_align", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.Net.l2norm", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "ValueError", "feat_list.append", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "median_lens.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "model.Net.affinity_layer", "range", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "model.Net.ga_mgmc", "torch.stack.append", "torch.stack.append", "torch.stack.append", "range", "src.utils.pad_tensor.pad_tensor", "m.item", "m.item", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "m.item", "m.item", "src_feat.transpose", "tgt_feat.transpose", "range", "max", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "U[].append", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "median_lens.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze", "model.Net.sinkhorn", "model.Net.sinkhorn().t", "model.Net.t", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "max.to", "model.Net.sinkhorn", "P.unsqueeze", "P.unsqueeze", "W_ijb.t"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.model.Net.collect_intra_class_matching_wrapper": [[213, 253], ["set", "itertools.chain", "itertools.chain.append", "pairwise_pred_s.append", "src.lap_solvers.hungarian.hungarian", "pairwise_pred_x.append", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "mgm_pred_x.append", "indices.append", "numpy.where", "itertools.combinations", "Wds[].t", "Wds[].t.unsqueeze", "src.lap_solvers.hungarian.hungarian.unsqueeze", "U[].t", "torch.mm.unsqueeze", "torch.mm.unsqueeze", "torch.mm.unsqueeze", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian"], []], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.Timer.__init__": [[12, 14], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "start_time", "=", "0", "\n", "", "def", "tic", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.Timer.tic": [[14, 16], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "        ", "self", ".", "start_time", "=", "time", ".", "time", "(", ")", "\n", "", "def", "toc", "(", "self", ",", "str", "=", "\"\"", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.Timer.toc": [[16, 18], ["graduated_assignment.print_helper", "time.time"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper"], ["", "def", "toc", "(", "self", ",", "str", "=", "\"\"", ")", ":", "\n", "        ", "print_helper", "(", "'{:.5f}sec {}'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", ",", "str", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.GA_GM.__init__": [[46, 57], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "mgm_iter", "=", "(", "200", ",", ")", ",", "cluster_iter", "=", "10", ",", "sk_iter", "=", "20", ",", "sk_tau0", "=", "(", "0.5", ",", ")", ",", "sk_gamma", "=", "0.5", ",", "cluster_beta", "=", "(", "1.", ",", "0.", ")", ",", "converge_tol", "=", "1e-5", ",", "min_tau", "=", "(", "1e-2", ",", ")", ",", "projector0", "=", "(", "'sinkhorn'", ",", ")", ")", ":", "\n", "        ", "super", "(", "GA_GM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mgm_iter", "=", "mgm_iter", "\n", "self", ".", "cluster_iter", "=", "cluster_iter", "\n", "self", ".", "sk_iter", "=", "sk_iter", "\n", "self", ".", "sk_tau0", "=", "sk_tau0", "\n", "self", ".", "sk_gamma", "=", "sk_gamma", "\n", "self", ".", "cluster_beta", "=", "cluster_beta", "\n", "self", ".", "converge_tol", "=", "converge_tol", "\n", "self", ".", "min_tau", "=", "min_tau", "\n", "self", ".", "projector0", "=", "projector0", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.GA_GM.forward": [[58, 134], ["W.detach.detach.detach", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "graduated_assignment.GA_GM.gagm", "Us.append", "zip", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "graduated_assignment.GA_GM.forward.get_alpha"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.GA_GM.gagm"], ["", "def", "forward", "(", "self", ",", "A", ",", "W", ",", "U0", ",", "ms", ",", "n_univ", ",", "quad_weight", "=", "1.", ",", "cluster_quad_weight", "=", "1.", ",", "num_clusters", "=", "2", ")", ":", "\n", "# gradient is not required for MGM module", "\n", "        ", "W", "=", "W", ".", "detach", "(", ")", "\n", "\n", "num_graphs", "=", "ms", ".", "shape", "[", "0", "]", "\n", "U", "=", "U0", "\n", "m_indices", "=", "torch", ".", "cumsum", "(", "ms", ",", "dim", "=", "0", ")", "\n", "\n", "Us", "=", "[", "]", "\n", "clusters", "=", "[", "]", "\n", "\n", "# initialize U with no clusters", "\n", "cluster_M", "=", "torch", ".", "ones", "(", "num_graphs", ",", "num_graphs", ",", "device", "=", "A", ".", "device", ")", "\n", "cluster_M01", "=", "cluster_M", "\n", "\n", "U", "=", "self", ".", "gagm", "(", "A", ",", "W", ",", "U", ",", "ms", ",", "n_univ", ",", "cluster_M", ",", "self", ".", "sk_tau0", "[", "0", "]", ",", "self", ".", "min_tau", "[", "0", "]", ",", "self", ".", "mgm_iter", "[", "0", "]", ",", "self", ".", "projector0", "[", "0", "]", ",", "\n", "quad_weight", "=", "quad_weight", ",", "hung_iter", "=", "(", "num_clusters", "==", "1", ")", ")", "\n", "Us", ".", "append", "(", "U", ")", "\n", "\n", "# MGM problem", "\n", "if", "num_clusters", "==", "1", ":", "\n", "            ", "return", "U", ",", "torch", ".", "zeros", "(", "num_graphs", ",", "dtype", "=", "torch", ".", "int", ")", "\n", "\n", "", "for", "beta", ",", "sk_tau0", ",", "min_tau", ",", "max_iter", ",", "projector0", "in", "zip", "(", "self", ".", "cluster_beta", ",", "self", ".", "sk_tau0", ",", "self", ".", "min_tau", ",", "self", ".", "mgm_iter", ",", "self", ".", "projector0", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "cluster_iter", ")", ":", "\n", "                ", "lastU", "=", "U", "\n", "\n", "# clustering step", "\n", "def", "get_alpha", "(", "scale", "=", "1.", ",", "qw", "=", "1.", ")", ":", "\n", "                    ", "Alpha", "=", "torch", ".", "zeros", "(", "num_graphs", ",", "num_graphs", ",", "device", "=", "A", ".", "device", ")", "\n", "for", "idx1", ",", "idx2", "in", "product", "(", "range", "(", "num_graphs", ")", ",", "repeat", "=", "2", ")", ":", "\n", "                        ", "if", "idx1", "==", "idx2", ":", "\n", "                            ", "continue", "\n", "", "start_x", "=", "m_indices", "[", "idx1", "-", "1", "]", "if", "idx1", "!=", "0", "else", "0", "\n", "end_x", "=", "m_indices", "[", "idx1", "]", "\n", "start_y", "=", "m_indices", "[", "idx2", "-", "1", "]", "if", "idx2", "!=", "0", "else", "0", "\n", "end_y", "=", "m_indices", "[", "idx2", "]", "\n", "A_i", "=", "A", "[", "start_x", ":", "end_x", ",", "start_x", ":", "end_x", "]", "\n", "A_j", "=", "A", "[", "start_y", ":", "end_y", ",", "start_y", ":", "end_y", "]", "\n", "W_ij", "=", "W", "[", "start_x", ":", "end_x", ",", "start_y", ":", "end_y", "]", "\n", "U_i", "=", "U", "[", "start_x", ":", "end_x", ",", ":", "]", "\n", "U_j", "=", "U", "[", "start_y", ":", "end_y", ",", ":", "]", "\n", "X_ij", "=", "torch", ".", "mm", "(", "U_i", ",", "U_j", ".", "t", "(", ")", ")", "\n", "Alpha_ij", "=", "torch", ".", "sum", "(", "W_ij", "*", "X_ij", ")", "+", "torch", ".", "exp", "(", "-", "torch", ".", "norm", "(", "torch", ".", "chain_matmul", "(", "X_ij", ".", "t", "(", ")", ",", "A_i", ",", "X_ij", ")", "-", "A_j", ")", "/", "scale", ")", "*", "qw", "\n", "Alpha", "[", "idx1", ",", "idx2", "]", "=", "Alpha_ij", "\n", "", "return", "Alpha", "\n", "", "Alpha", "=", "get_alpha", "(", "qw", "=", "cluster_quad_weight", ")", "\n", "\n", "last_cluster_M01", "=", "cluster_M01", "\n", "cluster_v", "=", "spectral_clustering", "(", "Alpha", ",", "num_clusters", ",", "normalized", "=", "True", ")", "\n", "cluster_M01", "=", "(", "cluster_v", ".", "unsqueeze", "(", "0", ")", "==", "cluster_v", ".", "unsqueeze", "(", "1", ")", ")", ".", "to", "(", "dtype", "=", "Alpha", ".", "dtype", ")", "\n", "cluster_M", "=", "(", "1", "-", "beta", ")", "*", "cluster_M01", "+", "beta", "\n", "\n", "if", "beta", "==", "self", ".", "cluster_beta", "[", "0", "]", "and", "i", "==", "0", ":", "\n", "                    ", "clusters", ".", "append", "(", "cluster_v", ")", "\n", "\n", "# matching step", "\n", "", "U", "=", "self", ".", "gagm", "(", "A", ",", "W", ",", "U", ",", "ms", ",", "n_univ", ",", "cluster_M", ",", "sk_tau0", ",", "min_tau", ",", "max_iter", ",", "\n", "projector", "=", "'hungarian'", "if", "i", "!=", "0", "else", "projector0", ",", "quad_weight", "=", "quad_weight", ",", "\n", "hung_iter", "=", "(", "beta", "==", "self", ".", "cluster_beta", "[", "-", "1", "]", ")", ")", "\n", "\n", "print_helper", "(", "'beta = {:.2f}, delta U = {:.4f}, delta M = {:.4f}'", ".", "format", "(", "beta", ",", "torch", ".", "norm", "(", "lastU", "-", "U", ")", ",", "torch", ".", "norm", "(", "last_cluster_M01", "-", "cluster_M01", ")", ")", ")", "\n", "\n", "Us", ".", "append", "(", "U", ")", "\n", "clusters", ".", "append", "(", "cluster_v", ")", "\n", "\n", "if", "beta", "==", "1", ":", "\n", "                    ", "break", "\n", "\n", "", "if", "torch", ".", "norm", "(", "lastU", "-", "U", ")", "<", "self", ".", "converge_tol", "and", "torch", ".", "norm", "(", "last_cluster_M01", "-", "cluster_M01", ")", "<", "self", ".", "converge_tol", ":", "\n", "                    ", "break", "\n", "\n", "#return Us, clusters", "\n", "", "", "", "return", "U", ",", "cluster_v", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.GA_GM.gagm": [[135, 225], ["torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "graduated_assignment.print_helper", "torch.cat.t", "torch.cat.t", "ms.to", "ms.to", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "graduated_assignment.print_helper", "graduated_assignment.print_helper", "graduated_assignment.print_helper", "U_list.append", "torch.all", "torch.all", "torch.all", "torch.all", "NameError", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "src.lap_solvers.hungarian.hungarian", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.chain_matmul", "torch.chain_matmul", "torch.chain_matmul", "torch.chain_matmul", "src.lap_solvers.hungarian.hungarian", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "enumerate", "src.lap_solvers.hungarian.hungarian", "U_list.append", "U_list.append", "V_list.append", "torch.tensor.append", "torch.tensor.append", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "U_list.append", "src.utils.pad_tensor.pad_tensor", "src.lap_solvers.sinkhorn.Sinkhorn", "V.reshape", "src.lap_solvers.sinkhorn.Sinkhorn", "V.reshape().transpose", "V.reshape"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "gagm", "(", "self", ",", "A", ",", "W", ",", "U0", ",", "ms", ",", "n_univ", ",", "cluster_M", ",", "init_tau", ",", "min_tau", ",", "max_iter", ",", "projector", "=", "'sinkhorn'", ",", "hung_iter", "=", "True", ",", "quad_weight", "=", "1.", ")", ":", "\n", "        ", "num_graphs", "=", "ms", ".", "shape", "[", "0", "]", "\n", "U", "=", "U0", "\n", "m_indices", "=", "torch", ".", "cumsum", "(", "ms", ",", "dim", "=", "0", ")", "\n", "\n", "lastU", "=", "torch", ".", "zeros_like", "(", "U", ")", "\n", "\n", "sinkhorn_tau", "=", "init_tau", "\n", "#beta = 0.9", "\n", "iter_flag", "=", "True", "\n", "\n", "while", "iter_flag", ":", "\n", "            ", "for", "i", "in", "range", "(", "max_iter", ")", ":", "\n", "                ", "lastU2", "=", "lastU", "\n", "lastU", "=", "U", "\n", "\n", "# compact matrix form update of V", "\n", "UUt", "=", "torch", ".", "mm", "(", "U", ",", "U", ".", "t", "(", ")", ")", "\n", "cluster_weight", "=", "torch", ".", "repeat_interleave", "(", "cluster_M", ",", "ms", ".", "to", "(", "dtype", "=", "torch", ".", "long", ")", ",", "dim", "=", "0", ")", "\n", "cluster_weight", "=", "torch", ".", "repeat_interleave", "(", "cluster_weight", ",", "ms", ".", "to", "(", "dtype", "=", "torch", ".", "long", ")", ",", "dim", "=", "1", ")", "\n", "V", "=", "torch", ".", "chain_matmul", "(", "A", ",", "UUt", "*", "cluster_weight", ",", "A", ",", "U", ")", "*", "quad_weight", "*", "2", "+", "torch", ".", "mm", "(", "W", "*", "cluster_weight", ",", "U", ")", "\n", "V", "/=", "num_graphs", "\n", "\n", "U_list", "=", "[", "]", "\n", "if", "projector", "==", "'hungarian'", ":", "\n", "                    ", "m_start", "=", "0", "\n", "for", "m_end", "in", "m_indices", ":", "\n", "                        ", "U_list", ".", "append", "(", "hungarian", "(", "V", "[", "m_start", ":", "m_end", ",", ":", "n_univ", "]", ")", ")", "\n", "m_start", "=", "m_end", "\n", "", "", "elif", "projector", "==", "'sinkhorn'", ":", "\n", "                    ", "if", "torch", ".", "all", "(", "ms", "==", "ms", "[", "0", "]", ")", ":", "\n", "                        ", "if", "ms", "[", "0", "]", "<=", "n_univ", ":", "\n", "                            ", "U_list", ".", "append", "(", "\n", "Sinkhorn", "(", "max_iter", "=", "self", ".", "sk_iter", ",", "tau", "=", "sinkhorn_tau", ",", "batched_operation", "=", "True", ")", "(", "V", ".", "reshape", "(", "num_graphs", ",", "-", "1", ",", "n_univ", ")", ",", "dummy_row", "=", "True", ")", ".", "reshape", "(", "-", "1", ",", "n_univ", ")", ")", "\n", "", "else", ":", "\n", "                            ", "U_list", ".", "append", "(", "\n", "Sinkhorn", "(", "max_iter", "=", "self", ".", "sk_iter", ",", "tau", "=", "sinkhorn_tau", ",", "batched_operation", "=", "True", ")", "(", "V", ".", "reshape", "(", "num_graphs", ",", "-", "1", ",", "n_univ", ")", ".", "transpose", "(", "1", ",", "2", ")", ",", "dummy_row", "=", "True", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "-", "1", ",", "n_univ", ")", ")", "\n", "", "", "else", ":", "\n", "                        ", "V_list", "=", "[", "]", "\n", "n1", "=", "[", "]", "\n", "m_start", "=", "0", "\n", "for", "m_end", "in", "m_indices", ":", "\n", "                            ", "V_list", ".", "append", "(", "V", "[", "m_start", ":", "m_end", ",", ":", "n_univ", "]", ")", "\n", "n1", ".", "append", "(", "m_end", "-", "m_start", ")", "\n", "m_start", "=", "m_end", "\n", "", "n1", "=", "torch", ".", "tensor", "(", "n1", ")", "\n", "U", "=", "Sinkhorn", "(", "max_iter", "=", "self", ".", "sk_iter", ",", "tau", "=", "sinkhorn_tau", ",", "batched_operation", "=", "True", ")", "(", "torch", ".", "stack", "(", "pad_tensor", "(", "V_list", ")", ",", "dim", "=", "0", ")", ",", "n1", ",", "dummy_row", "=", "True", ")", "\n", "m_start", "=", "0", "\n", "for", "idx", ",", "m_end", "in", "enumerate", "(", "m_indices", ")", ":", "\n", "                            ", "U_list", ".", "append", "(", "U", "[", "idx", ",", ":", "m_end", "-", "m_start", ",", ":", "]", ")", "\n", "m_start", "=", "m_end", "\n", "", "", "", "else", ":", "\n", "                    ", "raise", "NameError", "(", "'Unknown projecter name: {}'", ".", "format", "(", "projector", ")", ")", "\n", "\n", "", "U", "=", "torch", ".", "cat", "(", "U_list", ",", "dim", "=", "0", ")", "\n", "if", "num_graphs", "==", "2", ":", "\n", "                    ", "U", "[", ":", "ms", "[", "0", "]", ",", ":", "]", "=", "torch", ".", "eye", "(", "ms", "[", "0", "]", ",", "n_univ", ",", "device", "=", "U", ".", "device", ")", "\n", "\n", "", "if", "torch", ".", "norm", "(", "U", "-", "lastU", ")", "<", "self", ".", "converge_tol", "or", "torch", ".", "norm", "(", "U", "-", "lastU2", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "\n", "", "", "if", "i", "==", "max_iter", "-", "1", ":", "# not converged", "\n", "                ", "if", "hung_iter", ":", "\n", "                    ", "pass", "\n", "", "else", ":", "\n", "                    ", "U_list", "=", "[", "hungarian", "(", "_", ")", "for", "_", "in", "U_list", "]", "\n", "U", "=", "torch", ".", "cat", "(", "U_list", ",", "dim", "=", "0", ")", "\n", "print_helper", "(", "i", ",", "'max iter'", ")", "\n", "break", "\n", "\n", "# projection control", "\n", "", "", "if", "projector", "==", "'hungarian'", ":", "\n", "                ", "print_helper", "(", "i", ",", "'hungarian'", ")", "\n", "break", "\n", "", "elif", "sinkhorn_tau", ">", "min_tau", ":", "\n", "                ", "print_helper", "(", "i", ",", "sinkhorn_tau", ")", "\n", "sinkhorn_tau", "*=", "self", ".", "sk_gamma", "\n", "", "else", ":", "\n", "                ", "print_helper", "(", "i", ",", "sinkhorn_tau", ")", "\n", "if", "hung_iter", ":", "\n", "                    ", "projector", "=", "'hungarian'", "\n", "", "else", ":", "\n", "                    ", "U_list", "=", "[", "hungarian", "(", "_", ")", "for", "_", "in", "U_list", "]", "\n", "U", "=", "torch", ".", "cat", "(", "U_list", ",", "dim", "=", "0", ")", "\n", "break", "\n", "\n", "", "", "", "return", "U", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.HiPPI.__init__": [[243, 248], ["torch.Module.__init__", "src.lap_solvers.sinkhorn.Sinkhorn"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "max_iter", "=", "50", ",", "sk_iter", "=", "20", ",", "sk_tau", "=", "1", "/", "200.", ")", ":", "\n", "        ", "super", "(", "HiPPI", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "sk_iter", ",", "tau", "=", "sk_tau", ")", "\n", "self", ".", "hungarian", "=", "hungarian", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.HiPPI.forward": [[249, 285], ["range", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.chain_matmul", "torch.chain_matmul", "torch.chain_matmul", "torch.chain_matmul", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.t", "torch.cat.t", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "graduated_assignment.print_helper", "torch.cat.append", "torch.cat.append", "graduated_assignment.HiPPI.sinkhorn", "torch.cat.append", "torch.cat.append", "NameError", "graduated_assignment.HiPPI.hungarian"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian"], ["", "def", "forward", "(", "self", ",", "W", ",", "U0", ",", "ms", ",", "d", ",", "projector", "=", "'sinkhorn'", ")", ":", "\n", "        ", "num_graphs", "=", "ms", ".", "shape", "[", "0", "]", "\n", "\n", "U", "=", "U0", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "lastU", "=", "U", "\n", "WU", "=", "torch", ".", "mm", "(", "W", ",", "U", ")", "#/ num_graphs", "\n", "V", "=", "torch", ".", "chain_matmul", "(", "WU", ",", "U", ".", "t", "(", ")", ",", "WU", ")", "#/ num_graphs ** 2", "\n", "\n", "#V_median = torch.median(torch.flatten(V, start_dim=-2), dim=-1).values", "\n", "#V_var, V_mean = torch.var_mean(torch.flatten(V, start_dim=-2), dim=-1)", "\n", "#V = V - V_mean", "\n", "#V = V / torch.sqrt(V_var)", "\n", "\n", "#V = V / V_median", "\n", "\n", "U", "=", "[", "]", "\n", "m_start", "=", "0", "\n", "m_indices", "=", "torch", ".", "cumsum", "(", "ms", ",", "dim", "=", "0", ")", "\n", "for", "m_end", "in", "m_indices", ":", "\n", "                ", "if", "projector", "==", "'sinkhorn'", ":", "\n", "                    ", "U", ".", "append", "(", "self", ".", "sinkhorn", "(", "V", "[", "m_start", ":", "m_end", ",", ":", "d", "]", ",", "dummy_row", "=", "True", ")", ")", "\n", "", "elif", "projector", "==", "'hungarian'", ":", "\n", "                    ", "U", ".", "append", "(", "self", ".", "hungarian", "(", "V", "[", "m_start", ":", "m_end", ",", ":", "d", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "NameError", "(", "'Unknown projector {}.'", ".", "format", "(", "projector", ")", ")", "\n", "", "m_start", "=", "m_end", "\n", "", "U", "=", "torch", ".", "cat", "(", "U", ",", "dim", "=", "0", ")", "\n", "\n", "#print_helper('iter={}, diff={}, var={}, vmean={}, vvar={}'.format(i, torch.norm(U-lastU), torch.var(torch.sum(U, dim=0)), V_mean, V_var))", "\n", "\n", "if", "torch", ".", "norm", "(", "U", "-", "lastU", ")", "<", "1e-5", ":", "\n", "                ", "print_helper", "(", "i", ")", "\n", "break", "\n", "\n", "", "", "return", "U", "", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.GANN.graduated_assignment.print_helper": [[21, 24], ["print"], "function", ["None"], ["def", "print_helper", "(", "*", "args", ")", ":", "\n", "    ", "if", "DEBUG", ":", "\n", "        ", "print", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.CIE.model.Net.__init__": [[17, 33], ["CNN.__init__", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "range", "model.Net.add_module", "model.Net.add_module", "src.gconv.Siamese_ChannelIndependentConv", "src.gconv.Siamese_ChannelIndependentConv", "models.PCA.affinity_layer.Affinity", "model.Net.add_module", "model.Net.add_module", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["\n", "class", "Net", "(", "CNN", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "affinity_layer", "=", "Affinity", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", ")", "\n", "if", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'SM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "SpectralMatching", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "PI_ITER_NUM", ",", "stop_thresh", "=", "cfg", ".", "GMN", ".", "PI_STOP_THRESH", ")", "\n", "", "elif", "cfg", ".", "GMN", ".", "GM_SOLVER", "==", "'RRWM'", ":", "\n", "            ", "self", ".", "gm_solver", "=", "RRWM", "(", ")", "\n", "", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n", "", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.CIE.model.Net.forward": [[34, 128], ["torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.norm().detach", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp.unsqueeze", "torch.exp.unsqueeze", "torch.exp.unsqueeze", "torch.exp.unsqueeze", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "range", "data_dict.update", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "P_src.unsqueeze", "P_src.unsqueeze", "P_tgt.unsqueeze", "P_tgt.unsqueeze", "H_src.transpose", "H_tgt.transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "getattr", "getattr.", "getattr", "getattr.", "model.Net.sinkhorn", "ss.append", "ValueError", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "getattr", "getattr.", "getattr.", "src.lap_solvers.hungarian.hungarian", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "model.Net.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n", "src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.Net.__init__": [[47, 74], ["CNN.__init__", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "range", "torch.Linear", "torch.Linear", "torch.Linear", "src.lap_solvers.sinkhorn.Sinkhorn", "models.GMN.affinity_layer.InnerpAffinity", "mgmmodel.Net.add_module", "models.GMN.affinity_layer.GaussianAffinity", "ValueError", "models.NGM.gnn.GNNLayer", "models.NGM.gnn.GNNLayer"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pretrained", "=", "True", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'cat'", ":", "\n", "            ", "self", ".", "affinity_layer", "=", "InnerpAffinity", "(", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", ")", "\n", "", "elif", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'geo'", ":", "\n", "            ", "self", ".", "affinity_layer", "=", "GaussianAffinity", "(", "1", ",", "cfg", ".", "NGM", ".", "GAUSSIAN_SIGMA", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown edge feature type {}'", ".", "format", "(", "cfg", ".", "NGM", ".", "EDGE_FEATURE", ")", ")", "\n", "", "self", ".", "tau", "=", "cfg", ".", "NGM", ".", "SK_TAU", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "tau", "=", "self", ".", "tau", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "\n", "self", ".", "gnn_layer", "=", "cfg", ".", "NGM", ".", "GNN_LAYER", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "gnn_layer", "=", "GNNLayer", "(", "1", ",", "1", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", ",", "edge_emb", "=", "cfg", ".", "NGM", ".", "EDGE_EMB", ")", "\n", "", "else", ":", "\n", "                ", "gnn_layer", "=", "GNNLayer", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", ",", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", ",", "edge_emb", "=", "cfg", ".", "NGM", ".", "EDGE_EMB", ")", "\n", "", "self", ".", "add_module", "(", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ",", "gnn_layer", ")", "\n", "\n", "", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "-", "1", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "1", ")", "\n", "\n", "self", ".", "sinkhorn2", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ",", "tau", "=", "cfg", ".", "NGM", ".", "MGM_SK_TAU", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.Net.forward": [[75, 182], ["zip", "enumerate", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "torch.diagonal", "itertools.combinations", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "itertools.combinations", "data_dict.update", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mgmmodel.Net.node_layers", "mgmmodel.Net.edge_layers", "src.feature_align.feature_align", "src.feature_align.feature_align", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mgmmodel.Net.l2norm", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "feat_list.append", "joint_indices.append", "mgmmodel.Net.__ngm_forward", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "range", "mgmmodel.Net.sinkhorn2", "pred_s.append", "pred_x.append", "indices.append", "mgmmodel.pad_tensor", "ValueError", "mgmmodel.Net.transpose", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.argsort", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "len", "src.lap_solvers.hungarian.hungarian", "data_dict[].items", "data_dict[].items", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "data_dict[].items", "data_dict[].items", "len", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "v[].transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.Net.__ngm_forward", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "# extract graph feature", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# extract data", "\n", "            ", "data", "=", "data_dict", "[", "'images'", "]", "\n", "Ps", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns", "=", "data_dict", "[", "'ns'", "]", "\n", "Gs", "=", "data_dict", "[", "'Gs'", "]", "\n", "Hs", "=", "data_dict", "[", "'Hs'", "]", "\n", "Gs_tgt", "=", "data_dict", "[", "'Gs_tgt'", "]", "\n", "Hs_tgt", "=", "data_dict", "[", "'Hs_tgt'", "]", "\n", "KGs", "=", "{", "k", ":", "v", "[", "0", "]", "for", "k", ",", "v", "in", "data_dict", "[", "'KGHs'", "]", ".", "items", "(", ")", "}", "\n", "KHs", "=", "{", "k", ":", "v", "[", "1", "]", "for", "k", ",", "v", "in", "data_dict", "[", "'KGHs'", "]", ".", "items", "(", ")", "}", "\n", "\n", "batch_size", "=", "data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "device", "=", "data", "[", "0", "]", ".", "device", "\n", "\n", "data_cat", "=", "torch", ".", "cat", "(", "data", ",", "dim", "=", "0", ")", "\n", "P_cat", "=", "torch", ".", "cat", "(", "pad_tensor", "(", "Ps", ")", ",", "dim", "=", "0", ")", "\n", "n_cat", "=", "torch", ".", "cat", "(", "ns", ",", "dim", "=", "0", ")", "\n", "node", "=", "self", ".", "node_layers", "(", "data_cat", ")", "\n", "edge", "=", "self", ".", "edge_layers", "(", "node", ")", "\n", "U", "=", "feature_align", "(", "node", ",", "P_cat", ",", "n_cat", ",", "self", ".", "rescale", ")", "\n", "F", "=", "feature_align", "(", "edge", ",", "P_cat", ",", "n_cat", ",", "self", ".", "rescale", ")", "\n", "feats", "=", "torch", ".", "cat", "(", "(", "U", ",", "F", ")", ",", "dim", "=", "1", ")", "\n", "feats", "=", "self", ".", "l2norm", "(", "feats", ")", "\n", "feats", "=", "torch", ".", "split", "(", "feats", ",", "batch_size", ",", "dim", "=", "0", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# extract data", "\n", "            ", "data", "=", "data_dict", "[", "'features'", "]", "\n", "Ps", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns", "=", "data_dict", "[", "'ns'", "]", "\n", "Gs", "=", "data_dict", "[", "'Gs'", "]", "\n", "Hs", "=", "data_dict", "[", "'Hs'", "]", "\n", "Gs_tgt", "=", "data_dict", "[", "'Gs_tgt'", "]", "\n", "Hs_tgt", "=", "data_dict", "[", "'Hs_tgt'", "]", "\n", "KGs", "=", "{", "k", ":", "v", "[", "0", "]", "for", "k", ",", "v", "in", "data_dict", "[", "'KGHs'", "]", ".", "items", "(", ")", "}", "\n", "KHs", "=", "{", "k", ":", "v", "[", "1", "]", "for", "k", ",", "v", "in", "data_dict", "[", "'KGHs'", "]", ".", "items", "(", ")", "}", "\n", "\n", "batch_size", "=", "data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "device", "=", "data", "[", "0", "]", ".", "device", "\n", "\n", "feats", "=", "data", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "# extract reference graph feature", "\n", "", "feat_list", "=", "[", "]", "\n", "joint_indices", "=", "[", "0", "]", "\n", "iterator", "=", "zip", "(", "feats", ",", "Ps", ",", "Gs", ",", "Hs", ",", "Gs_tgt", ",", "Hs_tgt", ",", "ns", ")", "\n", "for", "idx", ",", "(", "feat", ",", "P", ",", "G", ",", "H", ",", "G_tgt", ",", "H_tgt", ",", "n", ")", "in", "enumerate", "(", "iterator", ")", ":", "\n", "            ", "feat_list", ".", "append", "(", "\n", "(", "\n", "idx", ",", "\n", "feat", ",", "\n", "P", ",", "G", ",", "H", ",", "G_tgt", ",", "H_tgt", ",", "n", "\n", ")", "\n", ")", "\n", "joint_indices", ".", "append", "(", "joint_indices", "[", "-", "1", "]", "+", "P", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "joint_S", "=", "torch", ".", "zeros", "(", "batch_size", ",", "joint_indices", "[", "-", "1", "]", ",", "joint_indices", "[", "-", "1", "]", ",", "device", "=", "device", ")", "\n", "joint_S_diag", "=", "torch", ".", "diagonal", "(", "joint_S", ",", "dim1", "=", "1", ",", "dim2", "=", "2", ")", "\n", "joint_S_diag", "+=", "1", "\n", "\n", "pred_s", "=", "[", "]", "\n", "pred_x", "=", "[", "]", "\n", "indices", "=", "[", "]", "\n", "\n", "for", "src", ",", "tgt", "in", "combinations", "(", "feat_list", ",", "2", ")", ":", "\n", "# pca forward", "\n", "            ", "src_idx", ",", "src_feat", ",", "P_src", ",", "G_src", ",", "H_src", ",", "_", ",", "__", ",", "n_src", "=", "src", "\n", "tgt_idx", ",", "tgt_feat", ",", "P_tgt", ",", "_", ",", "__", ",", "G_tgt", ",", "H_tgt", ",", "n_tgt", "=", "tgt", "\n", "K_G", "=", "KGs", "[", "'{},{}'", ".", "format", "(", "src_idx", ",", "tgt_idx", ")", "]", "\n", "K_H", "=", "KHs", "[", "'{},{}'", ".", "format", "(", "src_idx", ",", "tgt_idx", ")", "]", "\n", "s", "=", "self", ".", "__ngm_forward", "(", "src_feat", ",", "tgt_feat", ",", "P_src", ",", "P_tgt", ",", "G_src", ",", "G_tgt", ",", "H_src", ",", "H_tgt", ",", "K_G", ",", "K_H", ",", "n_src", ",", "n_tgt", ")", "\n", "\n", "if", "src_idx", ">", "tgt_idx", ":", "\n", "                ", "joint_S", "[", ":", ",", "joint_indices", "[", "tgt_idx", "]", ":", "joint_indices", "[", "tgt_idx", "+", "1", "]", ",", "joint_indices", "[", "src_idx", "]", ":", "joint_indices", "[", "src_idx", "+", "1", "]", "]", "+=", "s", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "                ", "joint_S", "[", ":", ",", "joint_indices", "[", "src_idx", "]", ":", "joint_indices", "[", "src_idx", "+", "1", "]", ",", "joint_indices", "[", "tgt_idx", "]", ":", "joint_indices", "[", "tgt_idx", "+", "1", "]", "]", "+=", "s", "\n", "\n", "", "", "matching_s", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "e", ",", "v", "=", "torch", ".", "symeig", "(", "joint_S", "[", "b", "]", ",", "eigenvectors", "=", "True", ")", "\n", "topargs", "=", "torch", ".", "argsort", "(", "torch", ".", "abs", "(", "e", ")", ",", "descending", "=", "True", ")", "[", ":", "joint_indices", "[", "1", "]", "]", "\n", "diff", "=", "e", "[", "topargs", "[", ":", "-", "1", "]", "]", "-", "e", "[", "topargs", "[", "1", ":", "]", "]", "\n", "if", "torch", ".", "min", "(", "torch", ".", "abs", "(", "diff", ")", ")", ">", "1e-4", ":", "\n", "                ", "matching_s", ".", "append", "(", "len", "(", "data", ")", "*", "torch", ".", "mm", "(", "v", "[", ":", ",", "topargs", "]", ",", "v", "[", ":", ",", "topargs", "]", ".", "transpose", "(", "0", ",", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "matching_s", ".", "append", "(", "joint_S", "[", "b", "]", ")", "\n", "\n", "", "", "matching_s", "=", "torch", ".", "stack", "(", "matching_s", ",", "dim", "=", "0", ")", "\n", "\n", "for", "idx1", ",", "idx2", "in", "combinations", "(", "range", "(", "len", "(", "data", ")", ")", ",", "2", ")", ":", "\n", "            ", "s", "=", "matching_s", "[", ":", ",", "joint_indices", "[", "idx1", "]", ":", "joint_indices", "[", "idx1", "+", "1", "]", ",", "joint_indices", "[", "idx2", "]", ":", "joint_indices", "[", "idx2", "+", "1", "]", "]", "\n", "s", "=", "self", ".", "sinkhorn2", "(", "s", ")", "\n", "\n", "pred_s", ".", "append", "(", "s", ")", "\n", "pred_x", ".", "append", "(", "hungarian", "(", "s", ")", ")", "\n", "indices", ".", "append", "(", "(", "idx1", ",", "idx2", ")", ")", "\n", "\n", "", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat_list'", ":", "pred_s", ",", "\n", "'perm_mat_list'", ":", "pred_x", ",", "\n", "'graph_indices'", ":", "indices", ",", "\n", "}", ")", "\n", "return", "data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.Net.__ngm_forward": [[183, 227], ["mgmmodel.Net.affinity_layer", "src.factorize_graph_matching.construct_aff_mat", "src.factorize_graph_matching.construct_aff_mat.unsqueeze", "range", "mgmmodel.Net.classifier", "mgmmodel.Net.view().transpose", "mgmmodel.Net.sinkhorn", "src.build_graphs.reshape_edge_feature", "src.build_graphs.reshape_edge_feature", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "Kp.transpose().contiguous().view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "getattr", "getattr.", "ValueError", "mgmmodel.Net.view", "models.NGM.geo_edge_feature.geo_edge_feature", "models.NGM.geo_edge_feature.geo_edge_feature", "Kp.transpose().contiguous", "Kp.transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "__ngm_forward", "(", "self", ",", "src", ",", "tgt", ",", "P_src", ",", "P_tgt", ",", "G_src", ",", "G_tgt", ",", "H_src", ",", "H_tgt", ",", "K_G", ",", "K_H", ",", "ns_src", ",", "ns_tgt", ")", ":", "\n", "        ", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "\n", "if", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'cat'", ":", "\n", "            ", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "", "elif", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'geo'", ":", "\n", "            ", "X", "=", "geo_edge_feature", "(", "P_src", ",", "G_src", ",", "H_src", ")", "[", ":", ",", ":", "1", ",", ":", "]", "\n", "Y", "=", "geo_edge_feature", "(", "P_tgt", ",", "G_tgt", ",", "H_tgt", ")", "[", ":", ",", ":", "1", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown edge feature type {}'", ".", "format", "(", "cfg", ".", "NGM", ".", "EDGE_FEATURE", ")", ")", "\n", "\n", "#K_G = [kronecker_sparse(x, y).astype(np.float32) for x, y in zip(G_tgt.cpu().numpy(), G_src.cpu().numpy())]", "\n", "#K_H = [kronecker_sparse(x, y).astype(np.float32) for x, y in zip(H_tgt.cpu().numpy(), H_src.cpu().numpy())]", "\n", "#K_G = CSRMatrix3d(K_G).to(src.device)", "\n", "#K_H = CSRMatrix3d(K_H).transpose().to(src.device)", "\n", "\n", "# affinity layer", "\n", "", "Ke", ",", "Kp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "K", "=", "construct_aff_mat", "(", "Ke", ",", "torch", ".", "zeros_like", "(", "Kp", ")", ",", "K_G", ",", "K_H", ")", "\n", "\n", "A", "=", "(", "K", ">", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", "\n", "\n", "if", "cfg", ".", "NGM", ".", "FIRST_ORDER", ":", "\n", "            ", "emb", "=", "Kp", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "Kp", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "emb", "=", "torch", ".", "ones", "(", "K", ".", "shape", "[", "0", "]", ",", "K", ".", "shape", "[", "1", "]", ",", "1", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "emb_K", "=", "K", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "gnn_layer", "=", "getattr", "(", "self", ",", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ")", "\n", "emb_K", ",", "emb", "=", "gnn_layer", "(", "A", ",", "emb_K", ",", "emb", ",", "ns_src", ",", "ns_tgt", ")", "#, norm=False)", "\n", "\n", "", "v", "=", "self", ".", "classifier", "(", "emb", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "U_tgt", ".", "shape", "[", "2", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "ss", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ",", "dummy_row", "=", "True", ")", "\n", "\n", "return", "ss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor": [[22, 44], ["iter", "next", "list", "numpy.array", "type", "numpy.zeros", "tuple", "padded_ts.append", "next", "range", "numpy.array", "tuple.tolist", "torch.pad", "len", "int", "len", "max"], "function", ["None"], ["def", "pad_tensor", "(", "inp", ")", ":", "\n", "    ", "assert", "type", "(", "inp", "[", "0", "]", ")", "==", "torch", ".", "Tensor", "\n", "it", "=", "iter", "(", "inp", ")", "\n", "t", "=", "next", "(", "it", ")", "\n", "max_shape", "=", "list", "(", "t", ".", "shape", ")", "\n", "while", "True", ":", "\n", "        ", "try", ":", "\n", "            ", "t", "=", "next", "(", "it", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "max_shape", ")", ")", ":", "\n", "                ", "max_shape", "[", "i", "]", "=", "int", "(", "max", "(", "max_shape", "[", "i", "]", ",", "t", ".", "shape", "[", "i", "]", ")", ")", "\n", "", "", "except", "StopIteration", ":", "\n", "            ", "break", "\n", "", "", "max_shape", "=", "np", ".", "array", "(", "max_shape", ")", "\n", "\n", "padded_ts", "=", "[", "]", "\n", "for", "t", "in", "inp", ":", "\n", "        ", "pad_pattern", "=", "np", ".", "zeros", "(", "2", "*", "len", "(", "max_shape", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "pad_pattern", "[", ":", ":", "-", "2", "]", "=", "max_shape", "-", "np", ".", "array", "(", "t", ".", "shape", ")", "\n", "pad_pattern", "=", "tuple", "(", "pad_pattern", ".", "tolist", "(", ")", ")", "\n", "padded_ts", ".", "append", "(", "functional", ".", "pad", "(", "t", ",", "pad_pattern", ",", "'constant'", ",", "0", ")", ")", "\n", "\n", "", "return", "padded_ts", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature": [[5, 29], ["torch.sum", "torch.sum", "torch.norm", "torch.stack().to", "torch.mul", "torch.mul", "P.unsqueeze", "G.unsqueeze", "P.unsqueeze", "H.unsqueeze", "torch.stack", "torch.sum"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.to"], ["def", "geo_edge_feature", "(", "P", ":", "Tensor", ",", "G", ":", "Tensor", ",", "H", ":", "Tensor", ",", "norm_d", "=", "256", ",", "device", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Compute geometric edge features [d, cos(theta), sin(theta)]\n    Adjacency matrix is formed by A = G * H^T\n    :param P: point set (b x num_nodes x 2)\n    :param G: factorized graph partition G (b x num_nodes x num_edges)\n    :param H: factorized graph partition H (b x num_nodes x num_edges)\n    :param norm_d: normalize Euclidean distance by norm_d\n    :param device: device\n    :return: feature tensor (b x 3 x num_edges)\n    \"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "P", ".", "device", "\n", "\n", "", "p1", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "P", ".", "unsqueeze", "(", "-", "2", ")", ",", "G", ".", "unsqueeze", "(", "-", "1", ")", ")", ",", "dim", "=", "1", ")", "# (b x num_edges x dim)", "\n", "p2", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "P", ".", "unsqueeze", "(", "-", "2", ")", ",", "H", ".", "unsqueeze", "(", "-", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "\n", "d", "=", "torch", ".", "norm", "(", "(", "p1", "-", "p2", ")", "/", "(", "norm_d", "*", "torch", ".", "sum", "(", "G", ",", "dim", "=", "1", ")", ")", ".", "unsqueeze", "(", "-", "1", ")", ",", "dim", "=", "-", "1", ")", "# (b x num_edges)", "\n", "# non-existing elements are nan", "\n", "\n", "cos_theta", "=", "(", "p1", "[", ":", ",", ":", ",", "0", "]", "-", "p2", "[", ":", ",", ":", ",", "0", "]", ")", "/", "(", "d", "*", "norm_d", ")", "# non-existing elements are nan", "\n", "sin_theta", "=", "(", "p1", "[", ":", ",", ":", ",", "1", "]", "-", "p2", "[", ":", ",", ":", ",", "1", "]", ")", "/", "(", "d", "*", "norm_d", ")", "\n", "\n", "return", "torch", ".", "stack", "(", "(", "d", ",", "cos_theta", ",", "sin_theta", ")", ",", "dim", "=", "1", ")", ".", "to", "(", "device", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model.Net.__init__": [[26, 60], ["CNN.__init__", "src.lap_solvers.sinkhorn.Sinkhorn", "src.lap_solvers.sinkhorn.GumbelSinkhorn", "torch.LocalResponseNorm", "torch.LocalResponseNorm", "range", "torch.Linear", "torch.Linear", "models.GMN.affinity_layer.InnerpAffinity", "model.Net.add_module", "models.GMN.affinity_layer.GaussianAffinity", "ValueError", "models.NGM.gnn.GNNLayer", "models.NGM.gnn.GNNLayer"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "GMN", ".", "BS_ITER_NUM", ",", "tau", "=", "1", "/", "cfg", ".", "GMN", ".", "VOTING_ALPHA", ",", "epsilon", "=", "cfg", ".", "GMN", ".", "BS_EPSILON", ",", "log_forward", "=", "False", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "GMN", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n", "", "def", "forward", "(", "self", ",", "data_dict", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n", "src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model.Net.forward": [[61, 196], ["src.factorize_graph_matching.construct_aff_mat.unsqueeze", "range", "model.Net.classifier", "model.Net.view().transpose", "data_dict.update", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.node_layers", "model.Net.edge_layers", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "model.Net.l2norm", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "model.Net.affinity_layer", "src.factorize_graph_matching.construct_aff_mat", "int", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "getattr", "getattr.", "model.Net.sinkhorn", "src.lap_solvers.hungarian.hungarian", "model.Net.gumbel_sinkhorn", "src.lap_solvers.hungarian.hungarian.reshape", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.min", "torch.cat.min", "src.lap_solvers.hungarian.hungarian", "src.build_graphs.reshape_edge_feature", "src.build_graphs.reshape_edge_feature", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "Kp.transpose().contiguous().view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "math.sqrt", "model.Net.view", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "src.lap_solvers.hungarian.hungarian", "torch.cat.append", "torch.cat.append", "repeat", "repeat", "ValueError", "ValueError", "torch.max", "torch.max", "torch.max", "torch.max", "repeat", "repeat", "src.utils.gpu_memory.gpu_free_memory", "src.factorize_graph_matching.construct_aff_mat.element_size", "src.factorize_graph_matching.construct_aff_mat.nelement", "print", "src.evaluation_metric.objective_score().reshape", "models.NGM.geo_edge_feature.geo_edge_feature", "models.NGM.geo_edge_feature.geo_edge_feature", "Kp.transpose().contiguous", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.cat.min.indices.cpu", "src.evaluation_metric.objective_score", "Kp.transpose", "ss_gumbel[].reshape", "repeat"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.gpu_memory.gpu_free_memory", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.evaluation_metric.objective_score", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown data type for this model.'", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "\n", "# affinity layer", "\n", "Me", ",", "Mp", "=", "self", ".", "affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "\n", "M", "=", "construct_aff_mat", "(", "Me", ",", "Mp", ",", "K_G", ",", "K_H", ")", "\n", "\n", "v", "=", "self", ".", "gm_solver", "(", "M", ",", "num_src", "=", "P_src", ".", "shape", "[", "1", "]", ",", "ns_src", "=", "ns_src", ",", "ns_tgt", "=", "ns_tgt", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "s", "=", "self", ".", "sinkhorn", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s", ",", "\n", "'perm_mat'", ":", "hungarian", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", ",", "\n", "'aff_mat'", ":", "M", "\n", "}", ")", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.Net.__init__": [[56, 91], ["CNN.__init__", "models.BBGM.sconv_archs.SiameseSConvOnNodes", "models.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity", "src.lap_solvers.sinkhorn.Sinkhorn", "src.lap_solvers.sinkhorn.Sinkhorn", "range", "nn.Linear", "hypermodel_v2.Net.add_module", "models.NGM.gnn.HyperGNNLayer", "models.NGM.gnn.HyperGNNLayer"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "message_pass_node_features", "=", "SiameseSConvOnNodes", "(", "input_node_dim", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ")", "\n", "self", ".", "build_edge_features_from_node_features", "=", "SiameseNodeFeaturesToEdgeFeatures", "(", "\n", "total_num_nodes", "=", "self", ".", "message_pass_node_features", ".", "num_node_features", "\n", ")", "\n", "self", ".", "global_state_dim", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", "\n", "self", ".", "vertex_affinity", "=", "InnerProductWithWeightsAffinity", "(", "\n", "self", ".", "global_state_dim", ",", "self", ".", "message_pass_node_features", ".", "num_node_features", ")", "\n", "self", ".", "edge_affinity", "=", "InnerProductWithWeightsAffinity", "(", "\n", "self", ".", "global_state_dim", ",", "self", ".", "build_edge_features_from_node_features", ".", "num_edge_features", ")", "\n", "#self.hyperedge_affinity = InnerProductWithWeightsAffinity(", "\n", "#    self.global_state_dim, self.build_edge_features_from_node_features.num_edge_features)", "\n", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "self", ".", "tau", "=", "cfg", ".", "NGM", ".", "SK_TAU", "\n", "self", ".", "univ_size", "=", "cfg", ".", "NGM", ".", "UNIV_SIZE", "\n", "\n", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "tau", "=", "self", ".", "tau", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ")", "\n", "self", ".", "sinkhorn_mgm", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ",", "tau", "=", "1.", ")", "\n", "self", ".", "gnn_layer", "=", "cfg", ".", "NGM", ".", "GNN_LAYER", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "gnn_layer", "=", "HyperGNNLayer", "(", "\n", "1", ",", "1", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", "\n", ")", "\n", "", "else", ":", "\n", "                ", "gnn_layer", "=", "HyperGNNLayer", "(", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", ",", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", "\n", ")", "\n", "", "self", ".", "add_module", "(", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ",", "gnn_layer", ")", "\n", "", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "-", "1", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.Net.forward": [[92, 248], ["len", "zip", "zip", "hypermodel_v2.Net.node_layers", "hypermodel_v2.Net.edge_layers", "global_list.append", "hypermodel_v2.normalize_over_channels", "hypermodel_v2.normalize_over_channels", "hypermodel_v2.concat_features", "hypermodel_v2.concat_features", "torch.cat", "hypermodel_v2.Net.message_pass_node_features", "hypermodel_v2.Net.build_edge_features_from_node_features", "orig_graph_list.append", "torch.cat", "hypermodel_v2.normalize_over_channels", "hypermodel_v2.Net.vertex_affinity", "hypermodel_v2.Net.edge_affinity", "hypermodel_v2.hyperedge_affinity", "hypermodel_v2.lexico_iter", "hypermodel_v2.lexico_iter", "torch.stack", "torch.stack", "torch.stack", "src.factorize_graph_matching.construct_aff_mat", "hypermodel_v2.construct_hyperE", "hypermodel_v2.construct_hyperE", "torch.bmm().reshape().permute().reshape", "range", "hypermodel_v2.Net.classifier", "hypermodel_v2.Net.view().transpose", "hypermodel_v2.Net.sinkhorn", "src.lap_solvers.hungarian.hungarian", "s_list.append", "x_list.append", "indices.append", "torch.cat", "torch.zeros", "range", "zip", "range", "torch.stack", "data_dict.update", "ValueError", "hypermodel_v2.Net.final_layers().reshape", "src.feature_align.feature_align", "src.feature_align.feature_align", "hypermodel_v2.lexico_iter", "zip", "zip", "zip", "range", "src.utils.pad_tensor.pad_tensor", "src.utils.pad_tensor.pad_tensor", "src.utils.pad_tensor.pad_tensor", "torch.stack.transpose().contiguous().view", "torch.ones", "src.factorize_graph_matching.construct_aff_mat.unsqueeze", "src.utils.sparse.to_sparse", "getattr", "getattr.", "torch.max", "torch.max", "range", "torch.symeig", "hypermodel_v2.Net.sinkhorn_mgm", "src.lap_solvers.hungarian.hungarian", "mgm_s_list.append", "mgm_x_list.append", "data_dict.update", "torch.bmm", "hypermodel_v2.lexico_iter", "hypermodel_v2.lexico_iter", "hypermodel_v2.lexico_iter", "torch.bmm().reshape().permute", "torch.bmm().reshape().permute().reshape.unsqueeze", "hypermodel_v2.Net.view", "torch.cumsum", "torch.zeros", "torch.eye", "hypermodel_v2.Net.transpose", "torch.stack.append", "torch.stack.append", "torch.log", "pm_tgt.transpose", "hypermodel_v2.lexico_iter", "hypermodel_v2.Net.final_layers", "torch.stack.transpose().contiguous", "torch.stack", "torch.min", "torch.relu", "torch.bmm().reshape", "torch.abs", "torch.mm", "torch.stack.transpose", "torch.max", "v[].transpose", "torch.bmm", "torch.bmm", "hyperE2.reshape().transpose", "hyperE1.reshape", "hyperE2.reshape"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.hyperedge_affinity", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.construct_hyperE", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.construct_hyperE", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.to_sparse", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "data_dict", ",", "\n", ")", ":", "\n", "        ", "images", "=", "data_dict", "[", "'images'", "]", "\n", "points", "=", "data_dict", "[", "'Ps'", "]", "\n", "n_points", "=", "data_dict", "[", "'ns'", "]", "\n", "graphs", "=", "data_dict", "[", "'pyg_graphs'", "]", "\n", "batch_size", "=", "data_dict", "[", "'batch_size'", "]", "\n", "num_graphs", "=", "len", "(", "images", ")", "\n", "\n", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", "and", "'gt_perm_mat'", "in", "data_dict", ":", "\n", "            ", "gt_perm_mats", "=", "[", "data_dict", "[", "'gt_perm_mat'", "]", "]", "\n", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM'", "and", "'gt_perm_mat'", "in", "data_dict", ":", "\n", "            ", "perm_mat_list", "=", "data_dict", "[", "'gt_perm_mat'", "]", "\n", "gt_perm_mats", "=", "[", "torch", ".", "bmm", "(", "pm_src", ",", "pm_tgt", ".", "transpose", "(", "1", ",", "2", ")", ")", "for", "pm_src", ",", "pm_tgt", "in", "lexico_iter", "(", "perm_mat_list", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Ground truth information is required during training.'", ")", "\n", "\n", "", "global_list", "=", "[", "]", "\n", "orig_graph_list", "=", "[", "]", "\n", "for", "image", ",", "p", ",", "n_p", ",", "graph", "in", "zip", "(", "images", ",", "points", ",", "n_points", ",", "graphs", ")", ":", "\n", "# extract feature", "\n", "            ", "nodes", "=", "self", ".", "node_layers", "(", "image", ")", "\n", "edges", "=", "self", ".", "edge_layers", "(", "nodes", ")", "\n", "\n", "global_list", ".", "append", "(", "self", ".", "final_layers", "(", "edges", ")", ".", "reshape", "(", "(", "nodes", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", ")", "\n", "nodes", "=", "normalize_over_channels", "(", "nodes", ")", "\n", "edges", "=", "normalize_over_channels", "(", "edges", ")", "\n", "\n", "# arrange features", "\n", "U", "=", "concat_features", "(", "feature_align", "(", "nodes", ",", "p", ",", "n_p", ",", "self", ".", "rescale", ")", ",", "n_p", ")", "\n", "F", "=", "concat_features", "(", "feature_align", "(", "edges", ",", "p", ",", "n_p", ",", "self", ".", "rescale", ")", ",", "n_p", ")", "\n", "node_features", "=", "torch", ".", "cat", "(", "(", "U", ",", "F", ")", ",", "dim", "=", "1", ")", "\n", "graph", ".", "x", "=", "node_features", "\n", "\n", "graph", "=", "self", ".", "message_pass_node_features", "(", "graph", ")", "\n", "orig_graph", "=", "self", ".", "build_edge_features_from_node_features", "(", "graph", ",", "hyperedge", "=", "True", ")", "\n", "orig_graph_list", ".", "append", "(", "orig_graph", ")", "\n", "\n", "", "global_weights_list", "=", "[", "\n", "torch", ".", "cat", "(", "[", "global_src", ",", "global_tgt", "]", ",", "axis", "=", "-", "1", ")", "for", "global_src", ",", "global_tgt", "in", "lexico_iter", "(", "global_list", ")", "\n", "]", "\n", "\n", "global_weights_list", "=", "[", "normalize_over_channels", "(", "g", ")", "for", "g", "in", "global_weights_list", "]", "\n", "\n", "unary_affs_list", "=", "[", "\n", "self", ".", "vertex_affinity", "(", "[", "item", ".", "x", "for", "item", "in", "g_1", "]", ",", "[", "item", ".", "x", "for", "item", "in", "g_2", "]", ",", "global_weights", ")", "\n", "for", "(", "g_1", ",", "g_2", ")", ",", "global_weights", "in", "zip", "(", "lexico_iter", "(", "orig_graph_list", ")", ",", "global_weights_list", ")", "\n", "]", "\n", "\n", "quadratic_affs_list", "=", "[", "\n", "self", ".", "edge_affinity", "(", "[", "item", ".", "edge_attr", "for", "item", "in", "g_1", "]", ",", "[", "item", ".", "edge_attr", "for", "item", "in", "g_2", "]", ",", "global_weights", ")", "\n", "for", "(", "g_1", ",", "g_2", ")", ",", "global_weights", "in", "zip", "(", "lexico_iter", "(", "orig_graph_list", ")", ",", "global_weights_list", ")", "\n", "]", "\n", "\n", "quadratic_affs_list", "=", "[", "[", "0.5", "*", "x", "for", "x", "in", "quadratic_affs", "]", "for", "quadratic_affs", "in", "quadratic_affs_list", "]", "\n", "\n", "order3_affs_list", "=", "[", "\n", "hyperedge_affinity", "(", "[", "item", ".", "hyperedge_attr", "for", "item", "in", "g_1", "]", ",", "[", "item", ".", "hyperedge_attr", "for", "item", "in", "g_2", "]", ")", "\n", "for", "(", "g_1", ",", "g_2", ")", ",", "global_weights", "in", "zip", "(", "lexico_iter", "(", "orig_graph_list", ")", ",", "global_weights_list", ")", "\n", "]", "\n", "\n", "s_list", ",", "mgm_s_list", ",", "x_list", ",", "mgm_x_list", ",", "indices", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "unary_affs", ",", "quadratic_affs", ",", "order3_affs", ",", "(", "g1", ",", "g2", ")", ",", "(", "idx1", ",", "idx2", ")", "in", "zip", "(", "unary_affs_list", ",", "quadratic_affs_list", ",", "order3_affs_list", ",", "lexico_iter", "(", "orig_graph_list", ")", ",", "lexico_iter", "(", "range", "(", "num_graphs", ")", ")", ")", ":", "\n", "            ", "kro_G", ",", "kro_H", "=", "data_dict", "[", "'KGHs'", "]", "if", "num_graphs", "==", "2", "else", "data_dict", "[", "'KGHs'", "]", "[", "'{},{}'", ".", "format", "(", "idx1", ",", "idx2", ")", "]", "\n", "Kp", "=", "torch", ".", "stack", "(", "pad_tensor", "(", "unary_affs", ")", ",", "dim", "=", "0", ")", "\n", "Ke", "=", "torch", ".", "stack", "(", "pad_tensor", "(", "quadratic_affs", ")", ",", "dim", "=", "0", ")", "\n", "He", "=", "torch", ".", "stack", "(", "pad_tensor", "(", "order3_affs", ")", ")", "\n", "K", "=", "construct_aff_mat", "(", "Ke", ",", "Kp", ",", "kro_G", ",", "kro_H", ")", "\n", "\n", "# build hyper graph tensor H", "\n", "hyperE1", ",", "nmax1", ",", "emax1", "=", "construct_hyperE", "(", "g1", ",", "batch_size", ",", "He", ".", "device", ")", "\n", "hyperE2", ",", "nmax2", ",", "emax2", "=", "construct_hyperE", "(", "g2", ",", "batch_size", ",", "He", ".", "device", ")", "\n", "H", "=", "torch", ".", "bmm", "(", "torch", ".", "bmm", "(", "\n", "hyperE1", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "emax1", ")", ",", "He", ")", ",", "hyperE2", ".", "reshape", "(", "batch_size", ",", "-", "1", ",", "emax2", ")", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "reshape", "(", "batch_size", ",", "nmax1", ",", "nmax1", ",", "nmax1", ",", "nmax2", ",", "nmax2", ",", "nmax2", ")", ".", "permute", "(", "0", ",", "4", ",", "1", ",", "5", ",", "2", ",", "6", ",", "3", ")", ".", "reshape", "(", "batch_size", ",", "nmax1", "*", "nmax2", ",", "nmax1", "*", "nmax2", ",", "nmax1", "*", "nmax2", ")", "\n", "\n", "if", "num_graphs", "==", "2", ":", "data_dict", "[", "'aff_mat'", "]", "=", "K", "\n", "\n", "if", "cfg", ".", "NGM", ".", "FIRST_ORDER", ":", "\n", "                ", "emb", "=", "Kp", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "Kp", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "emb", "=", "torch", ".", "ones", "(", "K", ".", "shape", "[", "0", "]", ",", "K", ".", "shape", "[", "1", "]", ",", "1", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "if", "cfg", ".", "NGM", ".", "POSITIVE_EDGES", ":", "\n", "                ", "adjs", "=", "[", "(", "K", ">", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", ",", "(", "H", ">", "0", ")", ".", "to", "(", "H", ".", "dtype", ")", "]", "\n", "", "else", ":", "\n", "                ", "adjs", "=", "[", "(", "K", "!=", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", ",", "(", "H", "!=", "0", ")", ".", "to", "(", "H", ".", "dtype", ")", "]", "\n", "\n", "", "emb_edges", "=", "[", "K", ".", "unsqueeze", "(", "-", "1", ")", ",", "to_sparse", "(", "H", ".", "unsqueeze", "(", "-", "1", ")", ",", "dense_dim", "=", "2", ")", "]", "\n", "\n", "# NGM qap solver", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "                ", "gnn_layer", "=", "getattr", "(", "self", ",", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ")", "\n", "emb_edges", ",", "emb", "=", "gnn_layer", "(", "adjs", ",", "emb_edges", ",", "emb", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "#, weight=[1, 0.1])", "\n", "\n", "", "v", "=", "self", ".", "classifier", "(", "emb", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "points", "[", "idx2", "]", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "ss", "=", "self", ".", "sinkhorn", "(", "s", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ",", "dummy_row", "=", "True", ")", "\n", "x", "=", "hungarian", "(", "ss", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "\n", "s_list", ".", "append", "(", "ss", ")", "\n", "x_list", ".", "append", "(", "x", ")", "\n", "indices", ".", "append", "(", "(", "idx1", ",", "idx2", ")", ")", "\n", "\n", "", "if", "num_graphs", ">", "2", ":", "\n", "            ", "joint_indices", "=", "torch", ".", "cat", "(", "(", "torch", ".", "cumsum", "(", "torch", ".", "stack", "(", "[", "torch", ".", "max", "(", "np", ")", "for", "np", "in", "n_points", "]", ")", ",", "dim", "=", "0", ")", ",", "torch", ".", "zeros", "(", "(", "1", ",", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "K", ".", "device", ")", ")", ")", "\n", "joint_S", "=", "torch", ".", "zeros", "(", "batch_size", ",", "torch", ".", "max", "(", "joint_indices", ")", ",", "torch", ".", "max", "(", "joint_indices", ")", ",", "device", "=", "K", ".", "device", ")", "\n", "for", "idx", "in", "range", "(", "num_graphs", ")", ":", "\n", "                ", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "start", "=", "joint_indices", "[", "idx", "-", "1", "]", "\n", "joint_S", "[", "b", ",", "start", ":", "start", "+", "n_points", "[", "idx", "]", "[", "b", "]", ",", "start", ":", "start", "+", "n_points", "[", "idx", "]", "[", "b", "]", "]", "+=", "torch", ".", "eye", "(", "n_points", "[", "idx", "]", "[", "b", "]", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "", "for", "(", "idx1", ",", "idx2", ")", ",", "s", "in", "zip", "(", "indices", ",", "s_list", ")", ":", "\n", "                ", "if", "idx1", ">", "idx2", ":", "\n", "                    ", "joint_S", "[", ":", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", "]", "+=", "s", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "                    ", "joint_S", "[", ":", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", "]", "+=", "s", "\n", "\n", "", "", "matching_s", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "e", ",", "v", "=", "torch", ".", "symeig", "(", "joint_S", "[", "b", "]", ",", "eigenvectors", "=", "True", ")", "\n", "diff", "=", "e", "[", "-", "self", ".", "univ_size", ":", "-", "1", "]", "-", "e", "[", "-", "self", ".", "univ_size", "+", "1", ":", "]", "\n", "if", "self", ".", "training", "and", "torch", ".", "min", "(", "torch", ".", "abs", "(", "diff", ")", ")", "<=", "1e-4", ":", "\n", "                    ", "matching_s", ".", "append", "(", "joint_S", "[", "b", "]", ")", "\n", "", "else", ":", "\n", "                    ", "matching_s", ".", "append", "(", "num_graphs", "*", "torch", ".", "mm", "(", "v", "[", ":", ",", "-", "self", ".", "univ_size", ":", "]", ",", "v", "[", ":", ",", "-", "self", ".", "univ_size", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ")", ")", "\n", "\n", "", "", "matching_s", "=", "torch", ".", "stack", "(", "matching_s", ",", "dim", "=", "0", ")", "\n", "\n", "for", "idx1", ",", "idx2", "in", "indices", ":", "\n", "                ", "s", "=", "matching_s", "[", ":", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", "]", "\n", "s", "=", "self", ".", "sinkhorn_mgm", "(", "torch", ".", "log", "(", "torch", ".", "relu", "(", "s", ")", ")", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "# only perform row/col norm, do not perform exp", "\n", "x", "=", "hungarian", "(", "s", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "\n", "\n", "mgm_s_list", ".", "append", "(", "s", ")", "\n", "mgm_x_list", ".", "append", "(", "x", ")", "\n", "\n", "", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", ":", "\n", "            ", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s_list", "[", "0", "]", ",", "\n", "'perm_mat'", ":", "x_list", "[", "0", "]", "\n", "}", ")", "\n", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM'", ":", "\n", "            ", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat_list'", ":", "mgm_s_list", ",", "\n", "'perm_mat_list'", ":", "mgm_x_list", ",", "\n", "'graph_indices'", ":", "indices", ",", "\n", "'gt_perm_mat_list'", ":", "gt_perm_mats", "\n", "}", ")", "\n", "\n", "", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.lexico_iter": [[20, 22], ["itertools.combinations"], "function", ["None"], ["def", "lexico_iter", "(", "lex", ")", ":", "\n", "    ", "return", "itertools", ".", "combinations", "(", "lex", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.normalize_over_channels": [[24, 27], ["torch.norm"], "function", ["None"], ["", "def", "normalize_over_channels", "(", "x", ")", ":", "\n", "    ", "channel_norms", "=", "torch", ".", "norm", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "x", "/", "channel_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.concat_features": [[29, 32], ["torch.cat", "torch.cat.transpose", "zip"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "concat_features", "(", "embeddings", ",", "num_vertices", ")", ":", "\n", "    ", "res", "=", "torch", ".", "cat", "(", "[", "embedding", "[", ":", ",", ":", "num_v", "]", "for", "embedding", ",", "num_v", "in", "zip", "(", "embeddings", ",", "num_vertices", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "return", "res", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.construct_hyperE": [[34, 42], ["max", "max", "torch.zeros", "enumerate", "torch.arange"], "function", ["None"], ["", "def", "construct_hyperE", "(", "ori_graphs", ",", "batch_size", ",", "device", ")", ":", "\n", "    ", "nmax", "=", "max", "(", "[", "g", ".", "num_nodes", "for", "g", "in", "ori_graphs", "]", ")", "\n", "emax", "=", "max", "(", "[", "g", ".", "hyperedge_index", ".", "shape", "[", "1", "]", "for", "g", "in", "ori_graphs", "]", ")", "\n", "hyperE", "=", "torch", ".", "zeros", "(", "batch_size", ",", "nmax", ",", "nmax", ",", "nmax", ",", "emax", ",", "device", "=", "device", ")", "\n", "for", "b", ",", "g", "in", "enumerate", "(", "ori_graphs", ")", ":", "\n", "        ", "hyperE", "[", "b", "]", "[", "g", ".", "hyperedge_index", "[", "0", "]", ",", "g", ".", "hyperedge_index", "[", "1", "]", ",", "g", ".", "hyperedge_index", "[", "2", "]", ",", "torch", ".", "arange", "(", "\n", "g", ".", "hyperedge_index", ".", "shape", "[", "1", "]", ")", "]", "=", "1", "\n", "", "return", "hyperE", ",", "nmax", ",", "emax", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel_v2.hyperedge_affinity": [[44, 53], ["zip", "attr1.unsqueeze().expand", "attr2.unsqueeze().expand", "torch.sum", "float", "ret_list.append", "torch.pow", "torch.exp", "attr1.unsqueeze", "attr2.unsqueeze", "torch.isnan"], "function", ["None"], ["", "def", "hyperedge_affinity", "(", "attrs1", ",", "attrs2", ")", ":", "\n", "    ", "ret_list", "=", "[", "]", "\n", "for", "attr1", ",", "attr2", "in", "zip", "(", "attrs1", ",", "attrs2", ")", ":", "\n", "        ", "X", "=", "attr1", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "attr1", ".", "shape", "[", "0", "]", ",", "attr2", ".", "shape", "[", "0", "]", ",", "attr1", ".", "shape", "[", "1", "]", ")", "\n", "Y", "=", "attr2", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "attr1", ".", "shape", "[", "0", "]", ",", "attr2", ".", "shape", "[", "0", "]", ",", "attr2", ".", "shape", "[", "1", "]", ")", "\n", "dist", "=", "torch", ".", "sum", "(", "torch", ".", "pow", "(", "X", "-", "Y", ",", "2", ")", ",", "dim", "=", "-", "1", ")", "\n", "dist", "[", "torch", ".", "isnan", "(", "dist", ")", "]", "=", "float", "(", "\"inf\"", ")", "\n", "ret_list", ".", "append", "(", "torch", ".", "exp", "(", "-", "dist", "/", "cfg", ".", "NGM", ".", "SIGMA3", ")", ")", "\n", "", "return", "ret_list", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.Net.__init__": [[34, 67], ["CNN.__init__", "models.BBGM.sconv_archs.SiameseSConvOnNodes", "models.BBGM.sconv_archs.SiameseNodeFeaturesToEdgeFeatures", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity", "models.BBGM.affinity_layer.InnerProductWithWeightsAffinity", "src.lap_solvers.sinkhorn.Sinkhorn", "src.lap_solvers.sinkhorn.Sinkhorn", "range", "nn.Linear", "model_v2.Net.add_module", "models.NGM.gnn.GNNLayer", "models.NGM.gnn.GNNLayer"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "message_pass_node_features", "=", "SiameseSConvOnNodes", "(", "input_node_dim", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ")", "\n", "self", ".", "build_edge_features_from_node_features", "=", "SiameseNodeFeaturesToEdgeFeatures", "(", "\n", "total_num_nodes", "=", "self", ".", "message_pass_node_features", ".", "num_node_features", "\n", ")", "\n", "self", ".", "global_state_dim", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", "\n", "self", ".", "vertex_affinity", "=", "InnerProductWithWeightsAffinity", "(", "\n", "self", ".", "global_state_dim", ",", "self", ".", "message_pass_node_features", ".", "num_node_features", ")", "\n", "self", ".", "edge_affinity", "=", "InnerProductWithWeightsAffinity", "(", "\n", "self", ".", "global_state_dim", ",", "\n", "self", ".", "build_edge_features_from_node_features", ".", "num_edge_features", ")", "\n", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "self", ".", "tau", "=", "cfg", ".", "NGM", ".", "SK_TAU", "\n", "self", ".", "mgm_tau", "=", "cfg", ".", "NGM", ".", "MGM_SK_TAU", "\n", "self", ".", "univ_size", "=", "cfg", ".", "NGM", ".", "UNIV_SIZE", "\n", "\n", "self", ".", "sinkhorn", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "tau", "=", "self", ".", "tau", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ")", "\n", "self", ".", "sinkhorn_mgm", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ",", "tau", "=", "self", ".", "mgm_tau", ")", "\n", "self", ".", "gnn_layer", "=", "cfg", ".", "NGM", ".", "GNN_LAYER", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "tau", "=", "cfg", ".", "NGM", ".", "SK_TAU", "\n", "if", "i", "==", "0", ":", "\n", "                ", "gnn_layer", "=", "GNNLayer", "(", "1", ",", "1", ",", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "tau", ",", "edge_emb", "=", "cfg", ".", "NGM", ".", "EDGE_EMB", ")", "\n", "", "else", ":", "\n", "                ", "gnn_layer", "=", "GNNLayer", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", ",", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "tau", ",", "edge_emb", "=", "cfg", ".", "NGM", ".", "EDGE_EMB", ")", "\n", "", "self", ".", "add_module", "(", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ",", "gnn_layer", ")", "\n", "", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "-", "1", "]", "+", "cfg", ".", "NGM", ".", "SK_EMB", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.Net.forward": [[68, 199], ["len", "zip", "zip", "model_v2.Net.node_layers", "model_v2.Net.edge_layers", "global_list.append", "model_v2.normalize_over_channels", "model_v2.normalize_over_channels", "model_v2.concat_features", "model_v2.concat_features", "torch.cat", "model_v2.Net.message_pass_node_features", "model_v2.Net.build_edge_features_from_node_features", "orig_graph_list.append", "torch.cat", "model_v2.normalize_over_channels", "model_v2.Net.vertex_affinity", "model_v2.Net.edge_affinity", "model_v2.lexico_iter", "torch.stack", "torch.stack", "src.factorize_graph_matching.construct_aff_mat", "src.factorize_graph_matching.construct_aff_mat.unsqueeze", "range", "model_v2.Net.classifier", "model_v2.Net.view().transpose", "model_v2.Net.sinkhorn", "src.lap_solvers.hungarian.hungarian", "s_list.append", "x_list.append", "indices.append", "torch.cat", "torch.zeros", "range", "zip", "range", "torch.stack", "data_dict.update", "model_v2.Net.final_layers().reshape", "src.feature_align.feature_align", "src.feature_align.feature_align", "model_v2.lexico_iter", "zip", "zip", "range", "src.utils.pad_tensor.pad_tensor", "src.utils.pad_tensor.pad_tensor", "torch.stack.transpose().contiguous().view", "torch.ones", "getattr", "getattr.", "torch.max", "torch.max", "range", "torch.symeig", "model_v2.Net.sinkhorn_mgm", "src.lap_solvers.hungarian.hungarian", "mgm_s_list.append", "mgm_x_list.append", "data_dict.update", "model_v2.lexico_iter", "model_v2.lexico_iter", "model_v2.Net.view", "torch.cumsum", "torch.zeros", "torch.eye", "model_v2.Net.transpose", "torch.stack.append", "torch.stack.append", "torch.log", "model_v2.Net.final_layers", "torch.stack.transpose().contiguous", "torch.stack", "torch.min", "torch.relu", "torch.abs", "torch.mm", "torch.stack.transpose", "torch.max", "v[].transpose"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.mgmmodel.pad_tensor", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "data_dict", ",", "\n", ")", ":", "\n", "        ", "images", "=", "data_dict", "[", "'images'", "]", "\n", "points", "=", "data_dict", "[", "'Ps'", "]", "\n", "n_points", "=", "data_dict", "[", "'ns'", "]", "\n", "graphs", "=", "data_dict", "[", "'pyg_graphs'", "]", "\n", "batch_size", "=", "data_dict", "[", "'batch_size'", "]", "\n", "num_graphs", "=", "len", "(", "images", ")", "\n", "\n", "global_list", "=", "[", "]", "\n", "orig_graph_list", "=", "[", "]", "\n", "for", "image", ",", "p", ",", "n_p", ",", "graph", "in", "zip", "(", "images", ",", "points", ",", "n_points", ",", "graphs", ")", ":", "\n", "# extract feature", "\n", "            ", "nodes", "=", "self", ".", "node_layers", "(", "image", ")", "\n", "edges", "=", "self", ".", "edge_layers", "(", "nodes", ")", "\n", "\n", "global_list", ".", "append", "(", "self", ".", "final_layers", "(", "edges", ")", ".", "reshape", "(", "(", "nodes", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", ")", "\n", "nodes", "=", "normalize_over_channels", "(", "nodes", ")", "\n", "edges", "=", "normalize_over_channels", "(", "edges", ")", "\n", "\n", "# arrange features", "\n", "U", "=", "concat_features", "(", "feature_align", "(", "nodes", ",", "p", ",", "n_p", ",", "self", ".", "rescale", ")", ",", "n_p", ")", "\n", "F", "=", "concat_features", "(", "feature_align", "(", "edges", ",", "p", ",", "n_p", ",", "self", ".", "rescale", ")", ",", "n_p", ")", "\n", "node_features", "=", "torch", ".", "cat", "(", "(", "U", ",", "F", ")", ",", "dim", "=", "1", ")", "\n", "graph", ".", "x", "=", "node_features", "\n", "\n", "graph", "=", "self", ".", "message_pass_node_features", "(", "graph", ")", "\n", "orig_graph", "=", "self", ".", "build_edge_features_from_node_features", "(", "graph", ")", "\n", "orig_graph_list", ".", "append", "(", "orig_graph", ")", "\n", "\n", "", "global_weights_list", "=", "[", "\n", "torch", ".", "cat", "(", "[", "global_src", ",", "global_tgt", "]", ",", "axis", "=", "-", "1", ")", "for", "global_src", ",", "global_tgt", "in", "lexico_iter", "(", "global_list", ")", "\n", "]", "\n", "\n", "global_weights_list", "=", "[", "normalize_over_channels", "(", "g", ")", "for", "g", "in", "global_weights_list", "]", "\n", "\n", "unary_affs_list", "=", "[", "\n", "self", ".", "vertex_affinity", "(", "[", "item", ".", "x", "for", "item", "in", "g_1", "]", ",", "[", "item", ".", "x", "for", "item", "in", "g_2", "]", ",", "global_weights", ")", "\n", "for", "(", "g_1", ",", "g_2", ")", ",", "global_weights", "in", "zip", "(", "lexico_iter", "(", "orig_graph_list", ")", ",", "global_weights_list", ")", "\n", "]", "\n", "\n", "quadratic_affs_list", "=", "[", "\n", "self", ".", "edge_affinity", "(", "[", "item", ".", "edge_attr", "for", "item", "in", "g_1", "]", ",", "[", "item", ".", "edge_attr", "for", "item", "in", "g_2", "]", ",", "global_weights", ")", "\n", "for", "(", "g_1", ",", "g_2", ")", ",", "global_weights", "in", "zip", "(", "lexico_iter", "(", "orig_graph_list", ")", ",", "global_weights_list", ")", "\n", "]", "\n", "\n", "quadratic_affs_list", "=", "[", "[", "0.5", "*", "x", "for", "x", "in", "quadratic_affs", "]", "for", "quadratic_affs", "in", "quadratic_affs_list", "]", "\n", "\n", "s_list", ",", "mgm_s_list", ",", "x_list", ",", "mgm_x_list", ",", "indices", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "unary_affs", ",", "quadratic_affs", ",", "(", "idx1", ",", "idx2", ")", "in", "zip", "(", "unary_affs_list", ",", "quadratic_affs_list", ",", "lexico_iter", "(", "range", "(", "num_graphs", ")", ")", ")", ":", "\n", "            ", "kro_G", ",", "kro_H", "=", "data_dict", "[", "'KGHs'", "]", "if", "num_graphs", "==", "2", "else", "data_dict", "[", "'KGHs'", "]", "[", "'{},{}'", ".", "format", "(", "idx1", ",", "idx2", ")", "]", "\n", "Kp", "=", "torch", ".", "stack", "(", "pad_tensor", "(", "unary_affs", ")", ",", "dim", "=", "0", ")", "\n", "Ke", "=", "torch", ".", "stack", "(", "pad_tensor", "(", "quadratic_affs", ")", ",", "dim", "=", "0", ")", "\n", "K", "=", "construct_aff_mat", "(", "Ke", ",", "Kp", ",", "kro_G", ",", "kro_H", ")", "\n", "if", "num_graphs", "==", "2", ":", "data_dict", "[", "'aff_mat'", "]", "=", "K", "\n", "\n", "if", "cfg", ".", "NGM", ".", "FIRST_ORDER", ":", "\n", "                ", "emb", "=", "Kp", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "Kp", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "emb", "=", "torch", ".", "ones", "(", "K", ".", "shape", "[", "0", "]", ",", "K", ".", "shape", "[", "1", "]", ",", "1", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "if", "cfg", ".", "NGM", ".", "POSITIVE_EDGES", ":", "\n", "                ", "A", "=", "(", "K", ">", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", "\n", "", "else", ":", "\n", "                ", "A", "=", "(", "K", "!=", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", "\n", "\n", "", "emb_K", "=", "K", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "# NGM qap solver", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "                ", "gnn_layer", "=", "getattr", "(", "self", ",", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ")", "\n", "emb_K", ",", "emb", "=", "gnn_layer", "(", "A", ",", "emb_K", ",", "emb", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "\n", "\n", "", "v", "=", "self", ".", "classifier", "(", "emb", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "points", "[", "idx2", "]", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "ss", "=", "self", ".", "sinkhorn", "(", "s", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ",", "dummy_row", "=", "True", ")", "\n", "x", "=", "hungarian", "(", "ss", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "\n", "s_list", ".", "append", "(", "ss", ")", "\n", "x_list", ".", "append", "(", "x", ")", "\n", "indices", ".", "append", "(", "(", "idx1", ",", "idx2", ")", ")", "\n", "\n", "", "if", "num_graphs", ">", "2", ":", "\n", "            ", "joint_indices", "=", "torch", ".", "cat", "(", "(", "torch", ".", "cumsum", "(", "torch", ".", "stack", "(", "[", "torch", ".", "max", "(", "np", ")", "for", "np", "in", "n_points", "]", ")", ",", "dim", "=", "0", ")", ",", "torch", ".", "zeros", "(", "(", "1", ",", ")", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "K", ".", "device", ")", ")", ")", "\n", "joint_S", "=", "torch", ".", "zeros", "(", "batch_size", ",", "torch", ".", "max", "(", "joint_indices", ")", ",", "torch", ".", "max", "(", "joint_indices", ")", ",", "device", "=", "K", ".", "device", ")", "\n", "for", "idx", "in", "range", "(", "num_graphs", ")", ":", "\n", "                ", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "start", "=", "joint_indices", "[", "idx", "-", "1", "]", "\n", "joint_S", "[", "b", ",", "start", ":", "start", "+", "n_points", "[", "idx", "]", "[", "b", "]", ",", "start", ":", "start", "+", "n_points", "[", "idx", "]", "[", "b", "]", "]", "+=", "torch", ".", "eye", "(", "n_points", "[", "idx", "]", "[", "b", "]", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "", "for", "(", "idx1", ",", "idx2", ")", ",", "s", "in", "zip", "(", "indices", ",", "s_list", ")", ":", "\n", "                ", "if", "idx1", ">", "idx2", ":", "\n", "                    ", "joint_S", "[", ":", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", "]", "+=", "s", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "\n", "                    ", "joint_S", "[", ":", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", "]", "+=", "s", "\n", "\n", "", "", "matching_s", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "e", ",", "v", "=", "torch", ".", "symeig", "(", "joint_S", "[", "b", "]", ",", "eigenvectors", "=", "True", ")", "\n", "diff", "=", "e", "[", "-", "self", ".", "univ_size", ":", "-", "1", "]", "-", "e", "[", "-", "self", ".", "univ_size", "+", "1", ":", "]", "\n", "if", "self", ".", "training", "and", "torch", ".", "min", "(", "torch", ".", "abs", "(", "diff", ")", ")", "<=", "1e-4", ":", "\n", "                    ", "matching_s", ".", "append", "(", "joint_S", "[", "b", "]", ")", "\n", "", "else", ":", "\n", "                    ", "matching_s", ".", "append", "(", "num_graphs", "*", "torch", ".", "mm", "(", "v", "[", ":", ",", "-", "self", ".", "univ_size", ":", "]", ",", "v", "[", ":", ",", "-", "self", ".", "univ_size", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ")", ")", "\n", "\n", "", "", "matching_s", "=", "torch", ".", "stack", "(", "matching_s", ",", "dim", "=", "0", ")", "\n", "\n", "for", "idx1", ",", "idx2", "in", "indices", ":", "\n", "                ", "s", "=", "matching_s", "[", ":", ",", "joint_indices", "[", "idx1", "-", "1", "]", ":", "joint_indices", "[", "idx1", "]", ",", "joint_indices", "[", "idx2", "-", "1", "]", ":", "joint_indices", "[", "idx2", "]", "]", "\n", "s", "=", "self", ".", "sinkhorn_mgm", "(", "torch", ".", "log", "(", "torch", ".", "relu", "(", "s", ")", ")", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "# only perform row/col norm, do not perform exp", "\n", "x", "=", "hungarian", "(", "s", ",", "n_points", "[", "idx1", "]", ",", "n_points", "[", "idx2", "]", ")", "\n", "\n", "mgm_s_list", ".", "append", "(", "s", ")", "\n", "mgm_x_list", ".", "append", "(", "x", ")", "\n", "\n", "", "", "if", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'2GM'", ":", "\n", "            ", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "s_list", "[", "0", "]", ",", "\n", "'perm_mat'", ":", "x_list", "[", "0", "]", "\n", "}", ")", "\n", "", "elif", "cfg", ".", "PROBLEM", ".", "TYPE", "==", "'MGM'", ":", "\n", "            ", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat_list'", ":", "mgm_s_list", ",", "\n", "'perm_mat_list'", ":", "mgm_x_list", ",", "\n", "'graph_indices'", ":", "indices", ",", "\n", "}", ")", "\n", "\n", "", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.lexico_iter": [[19, 21], ["itertools.combinations"], "function", ["None"], ["def", "lexico_iter", "(", "lex", ")", ":", "\n", "    ", "return", "itertools", ".", "combinations", "(", "lex", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.normalize_over_channels": [[23, 26], ["torch.norm"], "function", ["None"], ["", "def", "normalize_over_channels", "(", "x", ")", ":", "\n", "    ", "channel_norms", "=", "torch", ".", "norm", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "x", "/", "channel_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.model_v2.concat_features": [[28, 31], ["torch.cat", "torch.cat.transpose", "zip"], "function", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "concat_features", "(", "embeddings", ",", "num_vertices", ")", ":", "\n", "    ", "res", "=", "torch", ".", "cat", "(", "[", "embedding", "[", ":", ",", ":", "num_v", "]", "for", "embedding", ",", "num_v", "in", "zip", "(", "embeddings", ",", "num_vertices", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "return", "res", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel.Net.__init__": [[19, 48], ["CNN.__init__", "models.GMN.affinity_layer.GaussianAffinity", "models.GMN.affinity_layer.InnerpAffinity", "models.GMN.affinity_layer.InnerpAffinity", "src.lap_solvers.sinkhorn.Sinkhorn", "nn.LocalResponseNorm", "range", "nn.Linear", "hypermodel.Net.add_module", "models.NGM.gnn.HyperGNNLayer", "models.NGM.gnn.HyperGNNLayer"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "geo_affinity_layer", "=", "GaussianAffinity", "(", "1", ",", "cfg", ".", "NGM", ".", "GAUSSIAN_SIGMA", ")", "\n", "self", ".", "feat_affinity_layer", "=", "InnerpAffinity", "(", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", ")", "\n", "self", ".", "feat_affinity_layer3", "=", "InnerpAffinity", "(", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", ")", "\n", "self", ".", "tau", "=", "cfg", ".", "NGM", ".", "SK_TAU", "\n", "self", ".", "bi_stochastic", "=", "Sinkhorn", "(", "max_iter", "=", "cfg", ".", "NGM", ".", "SK_ITER_NUM", ",", "tau", "=", "self", ".", "tau", ",", "epsilon", "=", "cfg", ".", "NGM", ".", "SK_EPSILON", ")", "\n", "self", ".", "l2norm", "=", "nn", ".", "LocalResponseNorm", "(", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ",", "alpha", "=", "cfg", ".", "NGM", ".", "FEATURE_CHANNEL", "*", "2", ",", "beta", "=", "0.5", ",", "k", "=", "0", ")", "\n", "\n", "self", ".", "gnn_layer", "=", "cfg", ".", "NGM", ".", "GNN_LAYER", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "gnn_layer", "=", "HyperGNNLayer", "(", "\n", "1", ",", "1", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", "\n", ")", "\n", "", "else", ":", "\n", "                ", "gnn_layer", "=", "HyperGNNLayer", "(", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "-", "1", "]", ",", "\n", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "i", "]", ",", "\n", "sk_channel", "=", "cfg", ".", "NGM", ".", "SK_EMB", ",", "sk_tau", "=", "self", ".", "tau", "\n", ")", "\n", "", "self", ".", "add_module", "(", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ",", "gnn_layer", ")", "\n", "\n", "", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "cfg", ".", "NGM", ".", "GNN_FEAT", "[", "-", "1", "]", "+", "(", "1", "if", "cfg", ".", "NGM", ".", "SK_EMB", "else", "0", ")", ",", "1", ")", "\n", "\n", "self", ".", "weight2", "=", "cfg", ".", "NGM", ".", "WEIGHT2", "\n", "self", ".", "weight3", "=", "cfg", ".", "NGM", ".", "WEIGHT3", "\n", "self", ".", "rescale", "=", "cfg", ".", "PROBLEM", ".", "RESCALE", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.hypermodel.Net.forward": [[49, 181], ["src.build_graphs.reshape_edge_feature", "src.build_graphs.reshape_edge_feature", "src.factorize_graph_matching.construct_aff_mat", "hyper_adj.to_sparse().coalesce().cuda.to_sparse().coalesce().cuda.cpu", "hyper_adj.to_sparse().coalesce().cuda.to_sparse().coalesce().cuda.to_sparse().coalesce().cuda", "torch.zeros_like.sparse_mask", "range", "hypermodel.Net.classifier", "hypermodel.Net.view().transpose", "hypermodel.Net.bi_stochastic", "src.lap_solvers.hungarian.hungarian", "data_dict.update", "hypermodel.Net.node_layers", "hypermodel.Net.edge_layers", "hypermodel.Net.node_layers", "hypermodel.Net.edge_layers", "hypermodel.Net.l2norm", "hypermodel.Net.l2norm", "hypermodel.Net.l2norm", "hypermodel.Net.l2norm", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "src.feature_align.feature_align", "models.NGM.geo_edge_feature.geo_edge_feature", "models.NGM.geo_edge_feature.geo_edge_feature", "hypermodel.Net.feat_affinity_layer", "torch.zeros_like", "list", "adj.unsqueeze().expand", "hypermodel.Net.feat_affinity_layer3", "src.factorize_graph_matching.construct_aff_mat", "torch.sum", "torch.zeros_like._indices", "torch.zeros_like._values().unsqueeze", "Kp.transpose().contiguous().view", "torch.ones", "torch.sum", "src.factorize_graph_matching.construct_aff_mat.unsqueeze", "getattr", "getattr.", "ValueError", "hypermodel.Net.geo_affinity_layer", "ValueError", "adj.unsqueeze().expand", "adj.unsqueeze().expand", "torch.zeros", "torch.zeros", "torch.zeros_like", "torch.relu", "hypermodel.Net.geo_affinity_layer", "src.factorize_graph_matching.construct_aff_mat().cpu", "src.factorize_graph_matching.construct_aff_mat().cpu", "order3A.cuda.cuda.cpu", "torch.zeros_like", "range", "torch.zeros_like.cuda", "order3A.cuda.cuda.cuda", "hyper_adj.to_sparse().coalesce().cuda.to_sparse().coalesce().cuda.to_sparse().coalesce", "hypermodel.Net.view", "adj.unsqueeze", "src.factorize_graph_matching.construct_aff_mat.unsqueeze().expand", "torch.zeros", "torch.zeros", "hypermodel.Net.forward.calc_sin"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.build_graphs.reshape_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.lap_solvers.hungarian.hungarian", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.feature_align.feature_align", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.geo_edge_feature.geo_edge_feature", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.src.factorize_graph_matching.construct_aff_mat", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cpu", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSXMatrix3d.cuda"], ["", "def", "forward", "(", "self", ",", "data_dict", ")", ":", "\n", "        ", "if", "'images'", "in", "data_dict", ":", "\n", "# real image data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'images'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "# extract feature", "\n", "src_node", "=", "self", ".", "node_layers", "(", "src", ")", "\n", "src_edge", "=", "self", ".", "edge_layers", "(", "src_node", ")", "\n", "tgt_node", "=", "self", ".", "node_layers", "(", "tgt", ")", "\n", "tgt_edge", "=", "self", ".", "edge_layers", "(", "tgt_node", ")", "\n", "\n", "# feature normalization", "\n", "src_node", "=", "self", ".", "l2norm", "(", "src_node", ")", "\n", "src_edge", "=", "self", ".", "l2norm", "(", "src_edge", ")", "\n", "tgt_node", "=", "self", ".", "l2norm", "(", "tgt_node", ")", "\n", "tgt_edge", "=", "self", ".", "l2norm", "(", "tgt_edge", ")", "\n", "\n", "# arrange features", "\n", "U_src", "=", "feature_align", "(", "src_node", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "F_src", "=", "feature_align", "(", "src_edge", ",", "P_src", ",", "ns_src", ",", "self", ".", "rescale", ")", "\n", "U_tgt", "=", "feature_align", "(", "tgt_node", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "F_tgt", "=", "feature_align", "(", "tgt_edge", ",", "P_tgt", ",", "ns_tgt", ",", "self", ".", "rescale", ")", "\n", "", "elif", "'features'", "in", "data_dict", ":", "\n", "# synthetic data", "\n", "            ", "src", ",", "tgt", "=", "data_dict", "[", "'features'", "]", "\n", "P_src", ",", "P_tgt", "=", "data_dict", "[", "'Ps'", "]", "\n", "ns_src", ",", "ns_tgt", "=", "data_dict", "[", "'ns'", "]", "\n", "G_src", ",", "G_tgt", "=", "data_dict", "[", "'Gs'", "]", "\n", "H_src", ",", "H_tgt", "=", "data_dict", "[", "'Hs'", "]", "\n", "K_G", ",", "K_H", "=", "data_dict", "[", "'KGHs'", "]", "\n", "\n", "U_src", "=", "src", "[", ":", ",", ":", "src", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_src", "=", "src", "[", ":", ",", "src", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "U_tgt", "=", "tgt", "[", ":", ",", ":", "tgt", ".", "shape", "[", "1", "]", "//", "2", ",", ":", "]", "\n", "F_tgt", "=", "tgt", "[", ":", ",", "tgt", ".", "shape", "[", "1", "]", "//", "2", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'unknown type string {}'", ".", "format", "(", "type", ")", ")", "\n", "\n", "", "X", "=", "reshape_edge_feature", "(", "F_src", ",", "G_src", ",", "H_src", ")", "\n", "Y", "=", "reshape_edge_feature", "(", "F_tgt", ",", "G_tgt", ",", "H_tgt", ")", "\n", "dx", "=", "geo_edge_feature", "(", "P_src", ",", "G_src", ",", "H_src", ")", "[", ":", ",", ":", "1", ",", ":", "]", "\n", "dy", "=", "geo_edge_feature", "(", "P_tgt", ",", "G_tgt", ",", "H_tgt", ")", "[", ":", ",", ":", "1", ",", ":", "]", "\n", "\n", "# affinity layer for 2-order affinity matrix", "\n", "if", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'cat'", ":", "\n", "            ", "Ke", ",", "Kp", "=", "self", ".", "feat_affinity_layer", "(", "X", ",", "Y", ",", "U_src", ",", "U_tgt", ")", "\n", "", "elif", "cfg", ".", "NGM", ".", "EDGE_FEATURE", "==", "'geo'", ":", "\n", "             ", "Ke", ",", "Kp", "=", "self", ".", "geo_affinity_layer", "(", "dx", ",", "dy", ",", "U_src", ",", "U_tgt", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown edge feature type {}'", ".", "format", "(", "cfg", ".", "NGM", ".", "EDGE_FEATURE", ")", ")", "\n", "\n", "", "K", "=", "construct_aff_mat", "(", "Ke", ",", "torch", ".", "zeros_like", "(", "Kp", ")", ",", "K_G", ",", "K_H", ")", "\n", "adj", "=", "(", "K", ">", "0", ")", ".", "to", "(", "K", ".", "dtype", ")", "\n", "\n", "# build 3-order affinity tensor", "\n", "hshape", "=", "list", "(", "adj", ".", "shape", ")", "+", "[", "adj", ".", "shape", "[", "-", "1", "]", "]", "\n", "order3A", "=", "adj", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "hshape", ")", "*", "adj", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "hshape", ")", "*", "adj", ".", "unsqueeze", "(", "3", ")", ".", "expand", "(", "hshape", ")", "\n", "hyper_adj", "=", "order3A", "\n", "\n", "if", "cfg", ".", "NGM", ".", "ORDER3_FEATURE", "==", "'cat'", ":", "\n", "            ", "Ke_3", ",", "_", "=", "self", ".", "feat_affinity_layer3", "(", "X", ",", "Y", ",", "torch", ".", "zeros", "(", "1", ",", "1", ",", "1", ")", ",", "torch", ".", "zeros", "(", "1", ",", "1", ",", "1", ")", ",", "w1", "=", "0.5", ",", "w2", "=", "1", ")", "\n", "K_3", "=", "construct_aff_mat", "(", "Ke_3", ",", "torch", ".", "zeros_like", "(", "Kp", ")", ",", "K_G", ",", "K_H", ")", "\n", "H", "=", "(", "K_3", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "hshape", ")", "+", "K_3", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "hshape", ")", "+", "K_3", ".", "unsqueeze", "(", "3", ")", ".", "expand", "(", "hshape", ")", ")", "*", "F", ".", "relu", "(", "self", ".", "weight3", ")", "\n", "", "elif", "cfg", ".", "NGM", ".", "ORDER3_FEATURE", "==", "'geo'", ":", "\n", "            ", "Ke_d", ",", "_", "=", "self", ".", "geo_affinity_layer", "(", "dx", ",", "dy", ",", "torch", ".", "zeros", "(", "1", ",", "1", ",", "1", ")", ",", "torch", ".", "zeros", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "m_d_src", "=", "construct_aff_mat", "(", "dx", ".", "squeeze", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand_as", "(", "Ke_d", ")", ",", "torch", ".", "zeros_like", "(", "Kp", ")", ",", "K_G", ",", "K_H", ")", ".", "cpu", "(", ")", "\n", "m_d_tgt", "=", "construct_aff_mat", "(", "dy", ".", "squeeze", "(", ")", ".", "unsqueeze", "(", "-", "2", ")", ".", "expand_as", "(", "Ke_d", ")", ",", "torch", ".", "zeros_like", "(", "Kp", ")", ",", "K_G", ",", "K_H", ")", ".", "cpu", "(", ")", "\n", "order3A", "=", "order3A", ".", "cpu", "(", ")", "\n", "\n", "cum_sin", "=", "torch", ".", "zeros_like", "(", "order3A", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                ", "def", "calc_sin", "(", "t", ")", ":", "\n", "                    ", "a", "=", "t", ".", "unsqueeze", "(", "i", "%", "3", "+", "1", ")", ".", "expand", "(", "hshape", ")", "\n", "b", "=", "t", ".", "unsqueeze", "(", "(", "i", "+", "1", ")", "%", "3", "+", "1", ")", ".", "expand", "(", "hshape", ")", "\n", "c", "=", "t", ".", "unsqueeze", "(", "(", "i", "+", "2", ")", "%", "3", "+", "1", ")", ".", "expand", "(", "hshape", ")", "\n", "cos", "=", "torch", ".", "clamp", "(", "(", "a", ".", "pow", "(", "2", ")", "+", "b", ".", "pow", "(", "2", ")", "-", "c", ".", "pow", "(", "2", ")", ")", "/", "(", "2", "*", "a", "*", "b", "+", "1e-15", ")", ",", "-", "1", ",", "1", ")", "\n", "cos", "*=", "order3A", "\n", "sin", "=", "torch", ".", "sqrt", "(", "1", "-", "cos", ".", "pow", "(", "2", ")", ")", "*", "order3A", "\n", "assert", "torch", ".", "sum", "(", "torch", ".", "isnan", "(", "sin", ")", ")", "==", "0", "\n", "return", "sin", "\n", "", "sin_src", "=", "calc_sin", "(", "m_d_src", ")", "\n", "sin_tgt", "=", "calc_sin", "(", "m_d_tgt", ")", "\n", "cum_sin", "+=", "torch", ".", "abs", "(", "sin_src", "-", "sin_tgt", ")", "\n", "\n", "", "H", "=", "torch", ".", "exp", "(", "-", "1", "/", "cfg", ".", "NGM", ".", "SIGMA3", "*", "cum_sin", ")", "*", "order3A", "\n", "H", "=", "H", ".", "cuda", "(", ")", "\n", "order3A", "=", "order3A", ".", "cuda", "(", ")", "\n", "", "elif", "cfg", ".", "NGM", ".", "ORDER3_FEATURE", "==", "'none'", ":", "\n", "            ", "H", "=", "torch", ".", "zeros_like", "(", "hyper_adj", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown edge feature type {}'", ".", "format", "(", "cfg", ".", "NGM", ".", "ORDER3_FEATURE", ")", ")", "\n", "\n", "", "hyper_adj", "=", "hyper_adj", ".", "cpu", "(", ")", "\n", "hyper_adj_sum", "=", "torch", ".", "sum", "(", "hyper_adj", ",", "dim", "=", "tuple", "(", "range", "(", "2", ",", "3", "+", "1", ")", ")", ",", "keepdim", "=", "True", ")", "+", "1e-10", "\n", "hyper_adj", "=", "hyper_adj", "/", "hyper_adj_sum", "\n", "hyper_adj", "=", "hyper_adj", ".", "to_sparse", "(", ")", ".", "coalesce", "(", ")", ".", "cuda", "(", ")", "\n", "\n", "H", "=", "H", ".", "sparse_mask", "(", "hyper_adj", ")", "\n", "H", "=", "(", "H", ".", "_indices", "(", ")", ",", "H", ".", "_values", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", "\n", "\n", "if", "cfg", ".", "NGM", ".", "FIRST_ORDER", ":", "\n", "            ", "emb", "=", "Kp", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "Kp", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "emb", "=", "torch", ".", "ones", "(", "K", ".", "shape", "[", "0", "]", ",", "K", ".", "shape", "[", "1", "]", ",", "1", ",", "device", "=", "K", ".", "device", ")", "\n", "\n", "", "adj_sum", "=", "torch", ".", "sum", "(", "adj", ",", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "+", "1e-10", "\n", "adj", "=", "adj", "/", "adj_sum", "\n", "pack_M", "=", "[", "K", ".", "unsqueeze", "(", "-", "1", ")", ",", "H", "]", "\n", "pack_A", "=", "[", "adj", ",", "hyper_adj", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "gnn_layer", ")", ":", "\n", "            ", "gnn_layer", "=", "getattr", "(", "self", ",", "'gnn_layer_{}'", ".", "format", "(", "i", ")", ")", "\n", "pack_M", ",", "emb", "=", "gnn_layer", "(", "pack_A", ",", "pack_M", ",", "emb", ",", "ns_src", ",", "ns_tgt", ",", "norm", "=", "False", ")", "\n", "\n", "", "v", "=", "self", ".", "classifier", "(", "emb", ")", "\n", "s", "=", "v", ".", "view", "(", "v", ".", "shape", "[", "0", "]", ",", "P_tgt", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "ss", "=", "self", ".", "bi_stochastic", "(", "s", ",", "ns_src", ",", "ns_tgt", ")", "\n", "x", "=", "hungarian", "(", "ss", ",", "ns_src", ",", "ns_tgt", ")", "\n", "\n", "data_dict", ".", "update", "(", "{", "\n", "'ds_mat'", ":", "ss", ",", "\n", "'perm_mat'", ":", "x", ",", "\n", "'aff_mat'", ":", "K", "\n", "}", ")", "\n", "\n", "return", "data_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.GNNLayer.__init__": [[10, 50], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_node_features", ",", "in_edge_features", ",", "out_node_features", ",", "out_edge_features", ",", "\n", "sk_channel", "=", "0", ",", "sk_iter", "=", "20", ",", "sk_tau", "=", "0.05", ",", "edge_emb", "=", "False", ")", ":", "\n", "        ", "super", "(", "GNNLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_nfeat", "=", "in_node_features", "\n", "self", ".", "in_efeat", "=", "in_edge_features", "\n", "self", ".", "out_efeat", "=", "out_edge_features", "\n", "self", ".", "sk_channel", "=", "sk_channel", "\n", "assert", "out_node_features", "==", "out_edge_features", "+", "self", ".", "sk_channel", "\n", "if", "self", ".", "sk_channel", ">", "0", ":", "\n", "            ", "self", ".", "out_nfeat", "=", "out_node_features", "-", "self", ".", "sk_channel", "\n", "self", ".", "sk", "=", "Sinkhorn", "(", "sk_iter", ",", "sk_tau", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "sk_channel", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "out_nfeat", "=", "out_node_features", "\n", "self", ".", "sk", "=", "self", ".", "classifier", "=", "None", "\n", "\n", "", "if", "edge_emb", ":", "\n", "            ", "self", ".", "e_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_efeat", "+", "self", ".", "in_nfeat", ",", "self", ".", "out_efeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_efeat", ",", "self", ".", "out_efeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "e_func", "=", "None", "\n", "\n", "", "self", ".", "n_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "#nn.Linear(self.in_nfeat, self.out_nfeat // self.out_efeat),", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "#nn.Linear(self.out_nfeat // self.out_efeat, self.out_nfeat // self.out_efeat),", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "\n", "self", ".", "n_self_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.GNNLayer.forward": [[52, 86], ["gnn.GNNLayer.n_func", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "torch.matmul().squeeze().transpose", "gnn.GNNLayer.n_self_func", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "gnn.GNNLayer.e_func", "torch.normalize", "torch.normalize", "torch.normalize", "gnn.GNNLayer.classifier", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "gnn.GNNLayer.permute().reshape().transpose", "gnn.GNNLayer.sk().transpose().contiguous", "gnn.GNNLayer.reshape().permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.normalize.unsqueeze", "x.unsqueeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "n1.max", "n2.max", "gnn.GNNLayer.permute().reshape", "gnn.GNNLayer.sk().transpose", "gnn.GNNLayer.reshape", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "n2.max", "n1.max", "gnn.GNNLayer.unsqueeze().permute", "gnn.GNNLayer.permute", "gnn.GNNLayer.sk", "n1.max", "n2.max", "gnn.GNNLayer.unsqueeze", "torch.normalize.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "A", ",", "W", ",", "x", ",", "n1", "=", "None", ",", "n2", "=", "None", ",", "norm", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        :param A: adjacent matrix in 0/1 (b x n x n)\n        :param W: edge feature tensor (b x n x n x feat_dim)\n        :param x: node feature tensor (b x n x feat_dim)\n        \"\"\"", "\n", "if", "self", ".", "e_func", "is", "not", "None", ":", "\n", "            ", "W1", "=", "torch", ".", "mul", "(", "A", ".", "unsqueeze", "(", "-", "1", ")", ",", "x", ".", "unsqueeze", "(", "1", ")", ")", "\n", "W2", "=", "torch", ".", "cat", "(", "(", "W", ",", "W1", ")", ",", "dim", "=", "-", "1", ")", "\n", "W_new", "=", "self", ".", "e_func", "(", "W2", ")", "\n", "", "else", ":", "\n", "            ", "W_new", "=", "W", "\n", "\n", "", "if", "norm", "is", "True", ":", "\n", "            ", "A", "=", "F", ".", "normalize", "(", "A", ",", "p", "=", "1", ",", "dim", "=", "2", ")", "\n", "\n", "", "x1", "=", "self", ".", "n_func", "(", "x", ")", "\n", "x2", "=", "torch", ".", "matmul", "(", "(", "A", ".", "unsqueeze", "(", "-", "1", ")", "*", "W_new", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "x1", ".", "unsqueeze", "(", "2", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", ".", "squeeze", "(", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "x2", "+=", "self", ".", "n_self_func", "(", "x", ")", "\n", "\n", "if", "self", ".", "classifier", "is", "not", "None", ":", "\n", "            ", "assert", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", "==", "x", ".", "shape", "[", "1", "]", "\n", "x3", "=", "self", ".", "classifier", "(", "x2", ")", "\n", "n1_rep", "=", "torch", ".", "repeat_interleave", "(", "n1", ",", "self", ".", "sk_channel", ",", "dim", "=", "0", ")", "\n", "n2_rep", "=", "torch", ".", "repeat_interleave", "(", "n2", ",", "self", ".", "sk_channel", ",", "dim", "=", "0", ")", "\n", "x4", "=", "x3", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", "*", "self", ".", "sk_channel", ",", "n2", ".", "max", "(", ")", ",", "n1", ".", "max", "(", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "x5", "=", "self", ".", "sk", "(", "x4", ",", "n1_rep", ",", "n2_rep", ",", "dummy_row", "=", "True", ")", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "x6", "=", "x5", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "sk_channel", ",", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "x_new", "=", "torch", ".", "cat", "(", "(", "x2", ",", "x6", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x_new", "=", "x2", "\n", "\n", "", "return", "W_new", ",", "x_new", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.__init__": [[89, 129], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Sequential", "torch.Sequential", "torch.Sequential", "gnn.HyperGNNLayer.add_module", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_node_features", ",", "in_edge_features", ",", "out_node_features", ",", "out_edge_features", ",", "orders", "=", "3", ",", "eps", "=", "1e-10", ",", "\n", "sk_channel", "=", "False", ",", "sk_iter", "=", "20", ",", "sk_tau", "=", "0.05", ")", ":", "\n", "        ", "super", "(", "HyperGNNLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_nfeat", "=", "in_node_features", "\n", "self", ".", "in_efeat", "=", "in_edge_features", "\n", "self", ".", "out_efeat", "=", "out_edge_features", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "sk_channel", "=", "sk_channel", "\n", "assert", "out_node_features", "==", "out_edge_features", "+", "self", ".", "sk_channel", "\n", "if", "self", ".", "sk_channel", ">", "0", ":", "\n", "            ", "self", ".", "out_nfeat", "=", "out_node_features", "-", "self", ".", "sk_channel", "\n", "self", ".", "sk", "=", "Sinkhorn", "(", "sk_iter", ",", "sk_tau", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "sk_channel", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "out_nfeat", "=", "out_node_features", "\n", "self", ".", "sk", "=", "self", ".", "classifier", "=", "None", "\n", "\n", "# used by forward_dense", "\n", "", "self", ".", "n_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "\n", "# used by forward_sparse", "\n", "for", "i", "in", "range", "(", "2", ",", "orders", "+", "1", ")", ":", "\n", "            ", "n_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "self", ".", "add_module", "(", "'n_func_{}'", ".", "format", "(", "i", ")", ",", "n_func", ")", "\n", "\n", "", "self", ".", "n_self_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "out_nfeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.forward": [[131, 167], ["enumerate", "gnn.HyperGNNLayer.n_self_func", "isinstance", "len", "len", "zip", "W_new.append", "gnn.HyperGNNLayer.classifier", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "gnn.HyperGNNLayer.permute().reshape().transpose", "gnn.HyperGNNLayer.sk().transpose().contiguous", "gnn.HyperGNNLayer.reshape().permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "gnn.HyperGNNLayer.forward_sparse", "gnn.HyperGNNLayer.forward_dense", "type", "n1.max", "n2.max", "gnn.HyperGNNLayer.permute().reshape", "gnn.HyperGNNLayer.sk().transpose", "gnn.HyperGNNLayer.reshape", "type", "n2.max", "n1.max", "gnn.HyperGNNLayer.permute", "gnn.HyperGNNLayer.sk", "n1.max", "n2.max"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.forward_sparse", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.forward_dense", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "A", ",", "W", ",", "x", ",", "n1", "=", "None", ",", "n2", "=", "None", ",", "weight", "=", "None", ",", "norm", "=", "True", ")", ":", "\n", "        ", "\"\"\"wrapper function of forward (support dense/sparse)\"\"\"", "\n", "if", "not", "isinstance", "(", "A", ",", "Iterable", ")", ":", "\n", "            ", "A", "=", "[", "A", "]", "\n", "W", "=", "[", "W", "]", "\n", "\n", "", "W_new", "=", "[", "]", "\n", "if", "weight", "is", "None", ":", "\n", "            ", "weight", "=", "[", "1.", "]", "*", "len", "(", "A", ")", "\n", "", "assert", "len", "(", "weight", ")", "==", "len", "(", "A", ")", "\n", "for", "i", ",", "(", "_A", ",", "_W", ",", "w", ")", "in", "enumerate", "(", "zip", "(", "A", ",", "W", ",", "weight", ")", ")", ":", "\n", "            ", "if", "type", "(", "_W", ")", "is", "tuple", "or", "(", "type", "(", "_W", ")", "is", "torch", ".", "Tensor", "and", "_W", ".", "is_sparse", ")", ":", "\n", "                ", "_W_new", ",", "_x", "=", "self", ".", "forward_sparse", "(", "_A", ",", "_W", ",", "x", ",", "norm", ")", "\n", "", "else", ":", "\n", "                ", "_W_new", ",", "_x", "=", "self", ".", "forward_dense", "(", "_A", ",", "_W", ",", "x", ",", "norm", ")", "\n", "", "if", "i", "==", "0", ":", "\n", "                ", "x2", "=", "_x", "*", "w", "\n", "", "else", ":", "\n", "                ", "x2", "+=", "_x", "*", "w", "\n", "", "W_new", ".", "append", "(", "_W_new", ")", "\n", "\n", "", "x2", "+=", "self", ".", "n_self_func", "(", "x", ")", "\n", "\n", "if", "self", ".", "classifier", "is", "not", "None", ":", "\n", "            ", "assert", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", "==", "x", ".", "shape", "[", "1", "]", "\n", "x3", "=", "self", ".", "classifier", "(", "x2", ")", "\n", "n1_rep", "=", "torch", ".", "repeat_interleave", "(", "n1", ",", "self", ".", "sk_channel", ",", "dim", "=", "0", ")", "\n", "n2_rep", "=", "torch", ".", "repeat_interleave", "(", "n2", ",", "self", ".", "sk_channel", ",", "dim", "=", "0", ")", "\n", "x4", "=", "x3", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", "*", "self", ".", "sk_channel", ",", "n2", ".", "max", "(", ")", ",", "n1", ".", "max", "(", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "x5", "=", "self", ".", "sk", "(", "x4", ",", "n1_rep", ",", "n2_rep", ",", "dummy_row", "=", "True", ")", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "x6", "=", "x5", ".", "reshape", "(", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "sk_channel", ",", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "x_new", "=", "torch", ".", "cat", "(", "(", "x2", ",", "x6", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "x_new", "=", "x2", "\n", "\n", "", "return", "W_new", ",", "x_new", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.forward_sparse": [[168, 210], ["getattr", "getattr.", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "range", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.index_put_", "torch.zeros_like.index_put_", "torch.zeros_like.index_put_", "len", "type", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "A.to_sparse.to_sparse.to_sparse", "len", "A.to_sparse.to_sparse._values().unsqueeze", "W._indices", "W._values", "ValueError", "torch.sum.expand_as", "torch.sum.expand_as", "torch.sum.expand_as", "A.to_sparse.to_sparse._indices", "type", "tuple", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "A.to_sparse.to_sparse._values", "A.to_sparse.to_sparse._values", "type", "range"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.utils.sparse.to_sparse"], ["", "def", "forward_sparse", "(", "self", ",", "A", ",", "W", ",", "x", ",", "norm", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        :param A: adjacent tensor in 0/1 (b x {n x ... x n})\n        :param W: edge feature tensor (b x {n x ... x n} x feat_dim)\n        :param x: node feature tensor (b x n x feat_dim)\n        \"\"\"", "\n", "order", "=", "len", "(", "A", ".", "shape", ")", "-", "1", "\n", "\n", "if", "type", "(", "W", ")", "is", "tuple", ":", "\n", "            ", "W_ind", ",", "W_val", "=", "W", "\n", "", "elif", "type", "(", "W", ")", "is", "torch", ".", "Tensor", "and", "W", ".", "is_sparse", ":", "\n", "            ", "W_ind", "=", "W", ".", "_indices", "(", ")", "\n", "W_val", "=", "W", ".", "_values", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown datatype {}'", ".", "format", "(", "type", "(", "W", ")", ")", ")", "\n", "\n", "", "W_new_val", "=", "W_val", "\n", "if", "norm", "is", "True", ":", "\n", "            ", "assert", "not", "A", ".", "is_sparse", ",", "'sparse normalization is currently not supported'", "\n", "A_sum", "=", "torch", ".", "sum", "(", "A", ",", "dim", "=", "tuple", "(", "range", "(", "2", ",", "order", "+", "1", ")", ")", ",", "keepdim", "=", "True", ")", "\n", "A", "=", "A", "/", "A_sum", ".", "expand_as", "(", "A", ")", "\n", "A", "[", "torch", ".", "isnan", "(", "A", ")", "]", "=", "0", "\n", "\n", "", "if", "not", "A", ".", "is_sparse", ":", "\n", "            ", "A", "=", "A", ".", "to_sparse", "(", ")", "\n", "\n", "", "assert", "A", ".", "_values", "(", ")", ".", "shape", "[", "0", "]", "==", "W_new_val", ".", "shape", "[", "0", "]", "\n", "assert", "len", "(", "W_new_val", ".", "shape", ")", "==", "2", "\n", "\n", "n_func", "=", "getattr", "(", "self", ",", "'n_func_{}'", ".", "format", "(", "order", ")", ")", "\n", "x1", "=", "n_func", "(", "x", ")", "\n", "\n", "tp_val", "=", "torch", ".", "mul", "(", "A", ".", "_values", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", ",", "W_new_val", ")", "\n", "for", "i", "in", "range", "(", "order", "-", "1", ")", ":", "\n", "            ", "tp_val", "=", "x1", "[", "W_ind", "[", "0", ",", ":", "]", ",", "W_ind", "[", "-", "1", "-", "i", ",", ":", "]", ",", ":", "]", "*", "tp_val", "\n", "\n", "", "assert", "torch", ".", "all", "(", "W_ind", "==", "A", ".", "_indices", "(", ")", ")", "\n", "\n", "x_new", "=", "torch", ".", "zeros_like", "(", "x1", ")", "\n", "x_new", ".", "index_put_", "(", "(", "W_ind", "[", "0", ",", ":", "]", ",", "W_ind", "[", "1", ",", ":", "]", ")", ",", "tp_val", ",", "True", ")", "\n", "\n", "return", "(", "W_ind", ",", "W_new_val", ")", ",", "x_new", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperGNNLayer.forward_dense": [[212, 234], ["gnn.HyperGNNLayer.n_func", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "range", "len", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "A.unsqueeze", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum.expand_as", "torch.sum.expand_as", "torch.sum.expand_as", "list", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "tuple", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "gnn.HyperGNNLayer.view", "range"], "methods", ["None"], ["", "def", "forward_dense", "(", "self", ",", "A", ",", "W", ",", "x", ",", "norm", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        :param A: adjacent tensor in 0/1 (b x {n x ... x n})\n        :param W: edge feature tensor (b x {n x ... x n} x feat_dim)\n        :param x: node feature tensor (b x n x feat_dim)\n        \"\"\"", "\n", "order", "=", "len", "(", "A", ".", "shape", ")", "-", "1", "\n", "W_new", "=", "W", "\n", "\n", "if", "norm", "is", "True", ":", "\n", "            ", "A_sum", "=", "torch", ".", "sum", "(", "A", ",", "dim", "=", "tuple", "(", "range", "(", "2", ",", "order", "+", "1", ")", ")", ",", "keepdim", "=", "True", ")", "\n", "A", "=", "A", "/", "A_sum", ".", "expand_as", "(", "A", ")", "\n", "A", "[", "torch", ".", "isnan", "(", "A", ")", "]", "=", "0", "\n", "\n", "", "x1", "=", "self", ".", "n_func", "(", "x", ")", "\n", "\n", "x_new", "=", "torch", ".", "mul", "(", "A", ".", "unsqueeze", "(", "-", "1", ")", ",", "W_new", ")", "\n", "for", "i", "in", "range", "(", "order", "-", "1", ")", ":", "\n", "            ", "x1_shape", "=", "[", "x1", ".", "shape", "[", "0", "]", "]", "+", "[", "1", "]", "*", "(", "order", "-", "1", "-", "i", ")", "+", "list", "(", "x1", ".", "shape", "[", "1", ":", "]", ")", "\n", "x_new", "=", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "x_new", ",", "x1", ".", "view", "(", "*", "x1_shape", ")", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "", "return", "W_new", ",", "x_new", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperConvLayer.__init__": [[240, 269], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "src.lap_solvers.sinkhorn.Sinkhorn", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "in_node_features", ",", "in_edge_features", ",", "out_node_features", ",", "out_edge_features", ",", "eps", "=", "0.0001", ",", "\n", "sk_channel", "=", "False", ",", "sk_iter", "=", "20", ",", "voting_alpha", "=", "20", ")", ":", "\n", "        ", "super", "(", "HyperConvLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_nfeat", "=", "in_node_features", "\n", "self", ".", "in_efeat", "=", "in_edge_features", "\n", "self", ".", "out_efeat", "=", "out_edge_features", "\n", "self", ".", "eps", "=", "eps", "\n", "if", "sk_channel", ":", "\n", "            ", "assert", "out_node_features", "==", "out_edge_features", "+", "1", "\n", "self", ".", "out_nfeat", "=", "out_node_features", "-", "1", "\n", "self", ".", "sk", "=", "Sinkhorn", "(", "sk_iter", ",", "1", "/", "voting_alpha", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "out_efeat", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "assert", "out_node_features", "==", "out_edge_features", "\n", "self", ".", "out_nfeat", "=", "out_node_features", "\n", "self", ".", "sk", "=", "self", ".", "classifier", "=", "None", "\n", "\n", "", "self", ".", "ne_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", ",", "self", ".", "out_efeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "self", ".", "e_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "out_efeat", "+", "self", ".", "in_efeat", ",", "self", ".", "out_efeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "self", ".", "n_func", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "self", ".", "in_nfeat", "+", "self", ".", "out_efeat", ",", "self", ".", "out_nfeat", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.HyperConvLayer.forward": [[271, 301], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "gnn.HyperConvLayer.e_func", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "gnn.HyperConvLayer.n_func", "H_node_norm.transpose", "gnn.HyperConvLayer.ne_func", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "gnn.HyperConvLayer.classifier", "gnn.HyperConvLayer.sk().transpose().contiguous", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "n1.max", "n2.max", "gnn.HyperConvLayer.sk().transpose", "gnn.HyperConvLayer.view", "gnn.HyperConvLayer.sk", "n1.max", "n2.max", "gnn.HyperConvLayer.view().transpose", "gnn.HyperConvLayer.view", "n2.max", "n1.max"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose", "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.sparse_torch.csx_matrix.CSRMatrix3d.transpose"], ["", "def", "forward", "(", "self", ",", "H", ",", "E", ",", "x", ",", "n1", "=", "None", ",", "n2", "=", "None", ",", "norm", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param H: connectivity (b x n x e)\n        :param E: (hyper)edge feature (b x e x f)\n        :param x: node feature (b x n x f)\n        :param n1: number of nodes in graph1\n        :param n2: number of nodes in graph2\n        :param norm: do normalization (only supports dense tensor)\n        :return: new edge feature, new node feature\n        \"\"\"", "\n", "H_node_sum", "=", "torch", ".", "sum", "(", "H", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "H_node_norm", "=", "H", "/", "H_node_sum", "\n", "H_node_norm", "[", "torch", ".", "isnan", "(", "H_node_norm", ")", "]", "=", "0", "\n", "H_edge_sum", "=", "torch", ".", "sum", "(", "H", ",", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "H_edge_norm", "=", "H", "/", "H_edge_sum", "\n", "H_edge_norm", "[", "torch", ".", "isnan", "(", "H_edge_norm", ")", "]", "=", "0", "\n", "\n", "x_to_E", "=", "torch", ".", "bmm", "(", "H_node_norm", ".", "transpose", "(", "1", ",", "2", ")", ",", "self", ".", "ne_func", "(", "x", ")", ")", "\n", "new_E", "=", "self", ".", "e_func", "(", "torch", ".", "cat", "(", "(", "x_to_E", ",", "E", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "E_to_x", "=", "torch", ".", "bmm", "(", "H_edge_norm", ",", "new_E", ")", "\n", "new_x", "=", "self", ".", "n_func", "(", "torch", ".", "cat", "(", "(", "E_to_x", ",", "x", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n", "if", "self", ".", "classifier", "is", "not", "None", ":", "\n", "            ", "assert", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", "==", "x", ".", "shape", "[", "1", "]", "\n", "x3", "=", "self", ".", "classifier", "(", "new_x", ")", "\n", "x5", "=", "self", ".", "sk", "(", "x3", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "n2", ".", "max", "(", ")", ",", "n1", ".", "max", "(", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", ",", "n1", ",", "n2", ",", "dummy_row", "=", "True", ")", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "new_x", "=", "torch", ".", "cat", "(", "(", "new_x", ",", "x5", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "n1", ".", "max", "(", ")", "*", "n2", ".", "max", "(", ")", ",", "-", "1", ")", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "new_E", ",", "new_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__": [[307, 315], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty().uniform_", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty"], "methods", ["home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.__init__"], ["def", "__init__", "(", "self", ",", "feat1", ",", "feat2", ",", "hid_feat", ")", ":", "\n", "        ", "super", "(", "Attention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_feat1", "=", "feat1", "\n", "self", ".", "in_feat2", "=", "feat2", "\n", "self", ".", "hid_feat", "=", "hid_feat", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "self", ".", "in_feat1", ",", "self", ".", "hid_feat", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "self", ".", "in_feat2", ",", "self", ".", "hid_feat", ")", "\n", "self", ".", "v", "=", "nn", ".", "Parameter", "(", "torch", ".", "empty", "(", "self", ".", "hid_feat", ")", ".", "uniform_", "(", "-", "1", "/", "self", ".", "hid_feat", ",", "1", "/", "self", ".", "hid_feat", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Thinklab-SJTU_ThinkMatch.NGM.gnn.Attention.forward": [[316, 337], ["H._indices", "H._values", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "torch.sparse_coo_tensor().coalesce", "gnn.Attention.v.view", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "range", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "range", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.sparse_coo_tensor", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "H._values.unsqueeze().expand", "gnn.Attention.linear1().unsqueeze", "gnn.Attention.linear2().unsqueeze", "x._values", "H._values.unsqueeze", "gnn.Attention.linear1", "gnn.Attention.linear2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "t1", ",", "t2", ",", "H", ")", ":", "\n", "        ", "\"\"\"\n        :param t1: tensor1 (b x n1 x f)\n        :param t2: tensor2 (b x n2 x f)\n        :param H: indicator tensor (sparse b x n1 x n2)\n        \"\"\"", "\n", "H_idx", "=", "H", ".", "_indices", "(", ")", "\n", "H_data", "=", "H", ".", "_values", "(", ")", "\n", "sparse_mask", "=", "torch", ".", "sparse_coo_tensor", "(", "H_idx", ",", "H_data", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "-", "1", ",", "self", ".", "hid_feat", ")", ",", "H", ".", "shape", "+", "(", "self", ".", "hid_feat", ",", ")", ")", ".", "coalesce", "(", ")", "\n", "x", "=", "(", "self", ".", "linear1", "(", "t1", ")", ".", "unsqueeze", "(", "2", ")", "+", "self", ".", "linear2", "(", "t2", ")", ".", "unsqueeze", "(", "1", ")", ")", ".", "sparse_mask", "(", "sparse_mask", ")", "#+ t2W2.sparse_mask(sparse_mask)", "\n", "v", "=", "self", ".", "v", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "w_data", "=", "torch", ".", "matmul", "(", "x", ".", "_values", "(", ")", ",", "v", ")", ".", "squeeze", "(", ")", "\n", "w_softmax_data", "=", "torch", ".", "empty_like", "(", "w_data", ")", "\n", "for", "b", "in", "range", "(", "x", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "mask_b", "=", "(", "H_idx", "[", "0", "]", "==", "b", ")", "\n", "for", "r", "in", "range", "(", "x", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "mask_r", "=", "(", "H_idx", "[", "1", "]", "==", "r", ")", "\n", "mask", "=", "mask_b", "*", "mask_r", "\n", "w_softmax_data", "[", "mask", "]", "=", "nn", ".", "functional", ".", "softmax", "(", "w_data", "[", "mask", "]", ",", "dim", "=", "0", ")", "\n", "", "", "w_softmax", "=", "torch", ".", "sparse_coo_tensor", "(", "H_idx", ",", "w_softmax_data", ",", "H", ".", "shape", ")", "\n", "return", "w_softmax", "\n", "", "", ""]]}