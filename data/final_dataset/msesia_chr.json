{"home.repos.pwc.inspect_result.msesia_chr.experiments.dataset.GetDataset": [[5, 366], ["X.astype.astype", "y.astype.astype", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv", "pd.concat.dropna", "numpy.concatenate", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv", "numpy.loadtxt", "pandas.read_csv", "pandas.get_dummies", "pandas.concat", "pandas.get_dummies", "pandas.concat", "pd.concat.drop", "pd.concat.head", "df[].map", "pd.concat.drop", "pd.concat.drop", "pandas.read_csv", "pandas.read_csv", "data.dropna.drop", "data.dropna.replace", "SimpleImputer", "imputer.fit.fit", "imputer.fit.transform", "data.dropna.dropna", "open", "pd.concat.columns.to_series().groupby", "pd.concat.drop", "pandas.DatetimeIndex", "pandas.DatetimeIndex", "pandas.DatetimeIndex", "pandas.DatetimeIndex", "pd.concat.columns.to_series"], "function", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit"], ["def", "GetDataset", "(", "name", ",", "base_path", ")", ":", "\n", "    ", "\"\"\" Load a dataset\n    \n    Parameters\n    ----------\n    name : string, dataset name\n    base_path : string, e.g. \"path/to/datasets/directory/\"\n    \n    Returns\n    -------\n    X : features (nXp)\n    y : labels (n)\n    \n\t\"\"\"", "\n", "if", "name", "==", "\"meps_19\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'meps_19_reg_fix.csv'", ")", "\n", "column_names", "=", "df", ".", "columns", "\n", "response_name", "=", "\"UTILIZATION_reg\"", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "response_name", "]", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "\"Unnamed: 0\"", "]", "\n", "\n", "col_names", "=", "[", "'AGE'", ",", "'PCS42'", ",", "'MCS42'", ",", "'K6SUM42'", ",", "'PERWT15F'", ",", "'REGION=1'", ",", "\n", "'REGION=2'", ",", "'REGION=3'", ",", "'REGION=4'", ",", "'SEX=1'", ",", "'SEX=2'", ",", "'MARRY=1'", ",", "\n", "'MARRY=2'", ",", "'MARRY=3'", ",", "'MARRY=4'", ",", "'MARRY=5'", ",", "'MARRY=6'", ",", "'MARRY=7'", ",", "\n", "'MARRY=8'", ",", "'MARRY=9'", ",", "'MARRY=10'", ",", "'FTSTU=-1'", ",", "'FTSTU=1'", ",", "'FTSTU=2'", ",", "\n", "'FTSTU=3'", ",", "'ACTDTY=1'", ",", "'ACTDTY=2'", ",", "'ACTDTY=3'", ",", "'ACTDTY=4'", ",", "\n", "'HONRDC=1'", ",", "'HONRDC=2'", ",", "'HONRDC=3'", ",", "'HONRDC=4'", ",", "'RTHLTH=-1'", ",", "\n", "'RTHLTH=1'", ",", "'RTHLTH=2'", ",", "'RTHLTH=3'", ",", "'RTHLTH=4'", ",", "'RTHLTH=5'", ",", "\n", "'MNHLTH=-1'", ",", "'MNHLTH=1'", ",", "'MNHLTH=2'", ",", "'MNHLTH=3'", ",", "'MNHLTH=4'", ",", "\n", "'MNHLTH=5'", ",", "'HIBPDX=-1'", ",", "'HIBPDX=1'", ",", "'HIBPDX=2'", ",", "'CHDDX=-1'", ",", "\n", "'CHDDX=1'", ",", "'CHDDX=2'", ",", "'ANGIDX=-1'", ",", "'ANGIDX=1'", ",", "'ANGIDX=2'", ",", "\n", "'MIDX=-1'", ",", "'MIDX=1'", ",", "'MIDX=2'", ",", "'OHRTDX=-1'", ",", "'OHRTDX=1'", ",", "'OHRTDX=2'", ",", "\n", "'STRKDX=-1'", ",", "'STRKDX=1'", ",", "'STRKDX=2'", ",", "'EMPHDX=-1'", ",", "'EMPHDX=1'", ",", "\n", "'EMPHDX=2'", ",", "'CHBRON=-1'", ",", "'CHBRON=1'", ",", "'CHBRON=2'", ",", "'CHOLDX=-1'", ",", "\n", "'CHOLDX=1'", ",", "'CHOLDX=2'", ",", "'CANCERDX=-1'", ",", "'CANCERDX=1'", ",", "'CANCERDX=2'", ",", "\n", "'DIABDX=-1'", ",", "'DIABDX=1'", ",", "'DIABDX=2'", ",", "'JTPAIN=-1'", ",", "'JTPAIN=1'", ",", "\n", "'JTPAIN=2'", ",", "'ARTHDX=-1'", ",", "'ARTHDX=1'", ",", "'ARTHDX=2'", ",", "'ARTHTYPE=-1'", ",", "\n", "'ARTHTYPE=1'", ",", "'ARTHTYPE=2'", ",", "'ARTHTYPE=3'", ",", "'ASTHDX=1'", ",", "'ASTHDX=2'", ",", "\n", "'ADHDADDX=-1'", ",", "'ADHDADDX=1'", ",", "'ADHDADDX=2'", ",", "'PREGNT=-1'", ",", "'PREGNT=1'", ",", "\n", "'PREGNT=2'", ",", "'WLKLIM=-1'", ",", "'WLKLIM=1'", ",", "'WLKLIM=2'", ",", "'ACTLIM=-1'", ",", "\n", "'ACTLIM=1'", ",", "'ACTLIM=2'", ",", "'SOCLIM=-1'", ",", "'SOCLIM=1'", ",", "'SOCLIM=2'", ",", "\n", "'COGLIM=-1'", ",", "'COGLIM=1'", ",", "'COGLIM=2'", ",", "'DFHEAR42=-1'", ",", "'DFHEAR42=1'", ",", "\n", "'DFHEAR42=2'", ",", "'DFSEE42=-1'", ",", "'DFSEE42=1'", ",", "'DFSEE42=2'", ",", "\n", "'ADSMOK42=-1'", ",", "'ADSMOK42=1'", ",", "'ADSMOK42=2'", ",", "'PHQ242=-1'", ",", "'PHQ242=0'", ",", "\n", "'PHQ242=1'", ",", "'PHQ242=2'", ",", "'PHQ242=3'", ",", "'PHQ242=4'", ",", "'PHQ242=5'", ",", "\n", "'PHQ242=6'", ",", "'EMPST=-1'", ",", "'EMPST=1'", ",", "'EMPST=2'", ",", "'EMPST=3'", ",", "'EMPST=4'", ",", "\n", "'POVCAT=1'", ",", "'POVCAT=2'", ",", "'POVCAT=3'", ",", "'POVCAT=4'", ",", "'POVCAT=5'", ",", "\n", "'INSCOV=1'", ",", "'INSCOV=2'", ",", "'INSCOV=3'", ",", "'RACE'", "]", "\n", "\n", "y", "=", "df", "[", "response_name", "]", ".", "values", "\n", "#        y = np.log(1 + y - min(y))", "\n", "X", "=", "df", "[", "col_names", "]", ".", "values", "\n", "\n", "\n", "", "if", "name", "==", "\"meps_20\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'meps_20_reg_fix.csv'", ")", "\n", "column_names", "=", "df", ".", "columns", "\n", "response_name", "=", "\"UTILIZATION_reg\"", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "response_name", "]", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "\"Unnamed: 0\"", "]", "\n", "\n", "col_names", "=", "[", "'AGE'", ",", "'PCS42'", ",", "'MCS42'", ",", "'K6SUM42'", ",", "'PERWT15F'", ",", "'REGION=1'", ",", "\n", "'REGION=2'", ",", "'REGION=3'", ",", "'REGION=4'", ",", "'SEX=1'", ",", "'SEX=2'", ",", "'MARRY=1'", ",", "\n", "'MARRY=2'", ",", "'MARRY=3'", ",", "'MARRY=4'", ",", "'MARRY=5'", ",", "'MARRY=6'", ",", "'MARRY=7'", ",", "\n", "'MARRY=8'", ",", "'MARRY=9'", ",", "'MARRY=10'", ",", "'FTSTU=-1'", ",", "'FTSTU=1'", ",", "'FTSTU=2'", ",", "\n", "'FTSTU=3'", ",", "'ACTDTY=1'", ",", "'ACTDTY=2'", ",", "'ACTDTY=3'", ",", "'ACTDTY=4'", ",", "\n", "'HONRDC=1'", ",", "'HONRDC=2'", ",", "'HONRDC=3'", ",", "'HONRDC=4'", ",", "'RTHLTH=-1'", ",", "\n", "'RTHLTH=1'", ",", "'RTHLTH=2'", ",", "'RTHLTH=3'", ",", "'RTHLTH=4'", ",", "'RTHLTH=5'", ",", "\n", "'MNHLTH=-1'", ",", "'MNHLTH=1'", ",", "'MNHLTH=2'", ",", "'MNHLTH=3'", ",", "'MNHLTH=4'", ",", "\n", "'MNHLTH=5'", ",", "'HIBPDX=-1'", ",", "'HIBPDX=1'", ",", "'HIBPDX=2'", ",", "'CHDDX=-1'", ",", "\n", "'CHDDX=1'", ",", "'CHDDX=2'", ",", "'ANGIDX=-1'", ",", "'ANGIDX=1'", ",", "'ANGIDX=2'", ",", "\n", "'MIDX=-1'", ",", "'MIDX=1'", ",", "'MIDX=2'", ",", "'OHRTDX=-1'", ",", "'OHRTDX=1'", ",", "'OHRTDX=2'", ",", "\n", "'STRKDX=-1'", ",", "'STRKDX=1'", ",", "'STRKDX=2'", ",", "'EMPHDX=-1'", ",", "'EMPHDX=1'", ",", "\n", "'EMPHDX=2'", ",", "'CHBRON=-1'", ",", "'CHBRON=1'", ",", "'CHBRON=2'", ",", "'CHOLDX=-1'", ",", "\n", "'CHOLDX=1'", ",", "'CHOLDX=2'", ",", "'CANCERDX=-1'", ",", "'CANCERDX=1'", ",", "'CANCERDX=2'", ",", "\n", "'DIABDX=-1'", ",", "'DIABDX=1'", ",", "'DIABDX=2'", ",", "'JTPAIN=-1'", ",", "'JTPAIN=1'", ",", "\n", "'JTPAIN=2'", ",", "'ARTHDX=-1'", ",", "'ARTHDX=1'", ",", "'ARTHDX=2'", ",", "'ARTHTYPE=-1'", ",", "\n", "'ARTHTYPE=1'", ",", "'ARTHTYPE=2'", ",", "'ARTHTYPE=3'", ",", "'ASTHDX=1'", ",", "'ASTHDX=2'", ",", "\n", "'ADHDADDX=-1'", ",", "'ADHDADDX=1'", ",", "'ADHDADDX=2'", ",", "'PREGNT=-1'", ",", "'PREGNT=1'", ",", "\n", "'PREGNT=2'", ",", "'WLKLIM=-1'", ",", "'WLKLIM=1'", ",", "'WLKLIM=2'", ",", "'ACTLIM=-1'", ",", "\n", "'ACTLIM=1'", ",", "'ACTLIM=2'", ",", "'SOCLIM=-1'", ",", "'SOCLIM=1'", ",", "'SOCLIM=2'", ",", "\n", "'COGLIM=-1'", ",", "'COGLIM=1'", ",", "'COGLIM=2'", ",", "'DFHEAR42=-1'", ",", "'DFHEAR42=1'", ",", "\n", "'DFHEAR42=2'", ",", "'DFSEE42=-1'", ",", "'DFSEE42=1'", ",", "'DFSEE42=2'", ",", "\n", "'ADSMOK42=-1'", ",", "'ADSMOK42=1'", ",", "'ADSMOK42=2'", ",", "'PHQ242=-1'", ",", "'PHQ242=0'", ",", "\n", "'PHQ242=1'", ",", "'PHQ242=2'", ",", "'PHQ242=3'", ",", "'PHQ242=4'", ",", "'PHQ242=5'", ",", "\n", "'PHQ242=6'", ",", "'EMPST=-1'", ",", "'EMPST=1'", ",", "'EMPST=2'", ",", "'EMPST=3'", ",", "'EMPST=4'", ",", "\n", "'POVCAT=1'", ",", "'POVCAT=2'", ",", "'POVCAT=3'", ",", "'POVCAT=4'", ",", "'POVCAT=5'", ",", "\n", "'INSCOV=1'", ",", "'INSCOV=2'", ",", "'INSCOV=3'", ",", "'RACE'", "]", "\n", "\n", "y", "=", "df", "[", "response_name", "]", ".", "values", "\n", "#        y = np.log(1 + y - min(y))", "\n", "X", "=", "df", "[", "col_names", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "\"meps_21\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'meps_21_reg_fix.csv'", ")", "\n", "column_names", "=", "df", ".", "columns", "\n", "response_name", "=", "\"UTILIZATION_reg\"", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "response_name", "]", "\n", "column_names", "=", "column_names", "[", "column_names", "!=", "\"Unnamed: 0\"", "]", "\n", "\n", "col_names", "=", "[", "'AGE'", ",", "'PCS42'", ",", "'MCS42'", ",", "'K6SUM42'", ",", "'PERWT16F'", ",", "'REGION=1'", ",", "\n", "'REGION=2'", ",", "'REGION=3'", ",", "'REGION=4'", ",", "'SEX=1'", ",", "'SEX=2'", ",", "'MARRY=1'", ",", "\n", "'MARRY=2'", ",", "'MARRY=3'", ",", "'MARRY=4'", ",", "'MARRY=5'", ",", "'MARRY=6'", ",", "'MARRY=7'", ",", "\n", "'MARRY=8'", ",", "'MARRY=9'", ",", "'MARRY=10'", ",", "'FTSTU=-1'", ",", "'FTSTU=1'", ",", "'FTSTU=2'", ",", "\n", "'FTSTU=3'", ",", "'ACTDTY=1'", ",", "'ACTDTY=2'", ",", "'ACTDTY=3'", ",", "'ACTDTY=4'", ",", "\n", "'HONRDC=1'", ",", "'HONRDC=2'", ",", "'HONRDC=3'", ",", "'HONRDC=4'", ",", "'RTHLTH=-1'", ",", "\n", "'RTHLTH=1'", ",", "'RTHLTH=2'", ",", "'RTHLTH=3'", ",", "'RTHLTH=4'", ",", "'RTHLTH=5'", ",", "\n", "'MNHLTH=-1'", ",", "'MNHLTH=1'", ",", "'MNHLTH=2'", ",", "'MNHLTH=3'", ",", "'MNHLTH=4'", ",", "\n", "'MNHLTH=5'", ",", "'HIBPDX=-1'", ",", "'HIBPDX=1'", ",", "'HIBPDX=2'", ",", "'CHDDX=-1'", ",", "\n", "'CHDDX=1'", ",", "'CHDDX=2'", ",", "'ANGIDX=-1'", ",", "'ANGIDX=1'", ",", "'ANGIDX=2'", ",", "\n", "'MIDX=-1'", ",", "'MIDX=1'", ",", "'MIDX=2'", ",", "'OHRTDX=-1'", ",", "'OHRTDX=1'", ",", "'OHRTDX=2'", ",", "\n", "'STRKDX=-1'", ",", "'STRKDX=1'", ",", "'STRKDX=2'", ",", "'EMPHDX=-1'", ",", "'EMPHDX=1'", ",", "\n", "'EMPHDX=2'", ",", "'CHBRON=-1'", ",", "'CHBRON=1'", ",", "'CHBRON=2'", ",", "'CHOLDX=-1'", ",", "\n", "'CHOLDX=1'", ",", "'CHOLDX=2'", ",", "'CANCERDX=-1'", ",", "'CANCERDX=1'", ",", "'CANCERDX=2'", ",", "\n", "'DIABDX=-1'", ",", "'DIABDX=1'", ",", "'DIABDX=2'", ",", "'JTPAIN=-1'", ",", "'JTPAIN=1'", ",", "\n", "'JTPAIN=2'", ",", "'ARTHDX=-1'", ",", "'ARTHDX=1'", ",", "'ARTHDX=2'", ",", "'ARTHTYPE=-1'", ",", "\n", "'ARTHTYPE=1'", ",", "'ARTHTYPE=2'", ",", "'ARTHTYPE=3'", ",", "'ASTHDX=1'", ",", "'ASTHDX=2'", ",", "\n", "'ADHDADDX=-1'", ",", "'ADHDADDX=1'", ",", "'ADHDADDX=2'", ",", "'PREGNT=-1'", ",", "'PREGNT=1'", ",", "\n", "'PREGNT=2'", ",", "'WLKLIM=-1'", ",", "'WLKLIM=1'", ",", "'WLKLIM=2'", ",", "'ACTLIM=-1'", ",", "\n", "'ACTLIM=1'", ",", "'ACTLIM=2'", ",", "'SOCLIM=-1'", ",", "'SOCLIM=1'", ",", "'SOCLIM=2'", ",", "\n", "'COGLIM=-1'", ",", "'COGLIM=1'", ",", "'COGLIM=2'", ",", "'DFHEAR42=-1'", ",", "'DFHEAR42=1'", ",", "\n", "'DFHEAR42=2'", ",", "'DFSEE42=-1'", ",", "'DFSEE42=1'", ",", "'DFSEE42=2'", ",", "\n", "'ADSMOK42=-1'", ",", "'ADSMOK42=1'", ",", "'ADSMOK42=2'", ",", "'PHQ242=-1'", ",", "'PHQ242=0'", ",", "\n", "'PHQ242=1'", ",", "'PHQ242=2'", ",", "'PHQ242=3'", ",", "'PHQ242=4'", ",", "'PHQ242=5'", ",", "\n", "'PHQ242=6'", ",", "'EMPST=-1'", ",", "'EMPST=1'", ",", "'EMPST=2'", ",", "'EMPST=3'", ",", "'EMPST=4'", ",", "\n", "'POVCAT=1'", ",", "'POVCAT=2'", ",", "'POVCAT=3'", ",", "'POVCAT=4'", ",", "'POVCAT=5'", ",", "\n", "'INSCOV=1'", ",", "'INSCOV=2'", ",", "'INSCOV=3'", ",", "'RACE'", "]", "\n", "\n", "y", "=", "df", "[", "response_name", "]", ".", "values", "\n", "#        y = np.log(1 + y - min(y))", "\n", "X", "=", "df", "[", "col_names", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "\"star\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'STAR.csv'", ")", "\n", "df", ".", "loc", "[", "df", "[", "'gender'", "]", "==", "'female'", ",", "'gender'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'gender'", "]", "==", "'male'", ",", "'gender'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'cauc'", ",", "'ethnicity'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'afam'", ",", "'ethnicity'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'asian'", ",", "'ethnicity'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'hispanic'", ",", "'ethnicity'", "]", "=", "3", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'amindian'", ",", "'ethnicity'", "]", "=", "4", "\n", "df", ".", "loc", "[", "df", "[", "'ethnicity'", "]", "==", "'other'", ",", "'ethnicity'", "]", "=", "5", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'stark'", "]", "==", "'regular'", ",", "'stark'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'stark'", "]", "==", "'small'", ",", "'stark'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'stark'", "]", "==", "'regular+aide'", ",", "'stark'", "]", "=", "2", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'star1'", "]", "==", "'regular'", ",", "'star1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'star1'", "]", "==", "'small'", ",", "'star1'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'star1'", "]", "==", "'regular+aide'", ",", "'star1'", "]", "=", "2", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'star2'", "]", "==", "'regular'", ",", "'star2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'star2'", "]", "==", "'small'", ",", "'star2'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'star2'", "]", "==", "'regular+aide'", ",", "'star2'", "]", "=", "2", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'star3'", "]", "==", "'regular'", ",", "'star3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'star3'", "]", "==", "'small'", ",", "'star3'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'star3'", "]", "==", "'regular+aide'", ",", "'star3'", "]", "=", "2", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'lunchk'", "]", "==", "'free'", ",", "'lunchk'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'lunchk'", "]", "==", "'non-free'", ",", "'lunchk'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'lunch1'", "]", "==", "'free'", ",", "'lunch1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'lunch1'", "]", "==", "'non-free'", ",", "'lunch1'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'lunch2'", "]", "==", "'free'", ",", "'lunch2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'lunch2'", "]", "==", "'non-free'", ",", "'lunch2'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'lunch3'", "]", "==", "'free'", ",", "'lunch3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'lunch3'", "]", "==", "'non-free'", ",", "'lunch3'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'schoolk'", "]", "==", "'inner-city'", ",", "'schoolk'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'schoolk'", "]", "==", "'suburban'", ",", "'schoolk'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'schoolk'", "]", "==", "'rural'", ",", "'schoolk'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'schoolk'", "]", "==", "'urban'", ",", "'schoolk'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'school1'", "]", "==", "'inner-city'", ",", "'school1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'school1'", "]", "==", "'suburban'", ",", "'school1'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'school1'", "]", "==", "'rural'", ",", "'school1'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'school1'", "]", "==", "'urban'", ",", "'school1'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'school2'", "]", "==", "'inner-city'", ",", "'school2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'school2'", "]", "==", "'suburban'", ",", "'school2'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'school2'", "]", "==", "'rural'", ",", "'school2'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'school2'", "]", "==", "'urban'", ",", "'school2'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'school3'", "]", "==", "'inner-city'", ",", "'school3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'school3'", "]", "==", "'suburban'", ",", "'school3'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'school3'", "]", "==", "'rural'", ",", "'school3'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'school3'", "]", "==", "'urban'", ",", "'school3'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'degreek'", "]", "==", "'bachelor'", ",", "'degreek'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'degreek'", "]", "==", "'master'", ",", "'degreek'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'degreek'", "]", "==", "'specialist'", ",", "'degreek'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'degreek'", "]", "==", "'master+'", ",", "'degreek'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'degree1'", "]", "==", "'bachelor'", ",", "'degree1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'degree1'", "]", "==", "'master'", ",", "'degree1'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'degree1'", "]", "==", "'specialist'", ",", "'degree1'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'degree1'", "]", "==", "'phd'", ",", "'degree1'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'degree2'", "]", "==", "'bachelor'", ",", "'degree2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'degree2'", "]", "==", "'master'", ",", "'degree2'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'degree2'", "]", "==", "'specialist'", ",", "'degree2'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'degree2'", "]", "==", "'phd'", ",", "'degree2'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'degree3'", "]", "==", "'bachelor'", ",", "'degree3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'degree3'", "]", "==", "'master'", ",", "'degree3'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'degree3'", "]", "==", "'specialist'", ",", "'degree3'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'degree3'", "]", "==", "'phd'", ",", "'degree3'", "]", "=", "3", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'level1'", ",", "'ladderk'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'level2'", ",", "'ladderk'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'level3'", ",", "'ladderk'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'apprentice'", ",", "'ladderk'", "]", "=", "3", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'probation'", ",", "'ladderk'", "]", "=", "4", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'pending'", ",", "'ladderk'", "]", "=", "5", "\n", "df", ".", "loc", "[", "df", "[", "'ladderk'", "]", "==", "'notladder'", ",", "'ladderk'", "]", "=", "6", "\n", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'level1'", ",", "'ladder1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'level2'", ",", "'ladder1'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'level3'", ",", "'ladder1'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'apprentice'", ",", "'ladder1'", "]", "=", "3", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'probation'", ",", "'ladder1'", "]", "=", "4", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'noladder'", ",", "'ladder1'", "]", "=", "5", "\n", "df", ".", "loc", "[", "df", "[", "'ladder1'", "]", "==", "'notladder'", ",", "'ladder1'", "]", "=", "6", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'level1'", ",", "'ladder2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'level2'", ",", "'ladder2'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'level3'", ",", "'ladder2'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'apprentice'", ",", "'ladder2'", "]", "=", "3", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'probation'", ",", "'ladder2'", "]", "=", "4", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'noladder'", ",", "'ladder2'", "]", "=", "5", "\n", "df", ".", "loc", "[", "df", "[", "'ladder2'", "]", "==", "'notladder'", ",", "'ladder2'", "]", "=", "6", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'level1'", ",", "'ladder3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'level2'", ",", "'ladder3'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'level3'", ",", "'ladder3'", "]", "=", "2", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'apprentice'", ",", "'ladder3'", "]", "=", "3", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'probation'", ",", "'ladder3'", "]", "=", "4", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'noladder'", ",", "'ladder3'", "]", "=", "5", "\n", "df", ".", "loc", "[", "df", "[", "'ladder3'", "]", "==", "'notladder'", ",", "'ladder3'", "]", "=", "6", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicityk'", "]", "==", "'cauc'", ",", "'tethnicityk'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicityk'", "]", "==", "'afam'", ",", "'tethnicityk'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity1'", "]", "==", "'cauc'", ",", "'tethnicity1'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity1'", "]", "==", "'afam'", ",", "'tethnicity1'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity2'", "]", "==", "'cauc'", ",", "'tethnicity2'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity2'", "]", "==", "'afam'", ",", "'tethnicity2'", "]", "=", "1", "\n", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity3'", "]", "==", "'cauc'", ",", "'tethnicity3'", "]", "=", "0", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity3'", "]", "==", "'afam'", ",", "'tethnicity3'", "]", "=", "1", "\n", "df", ".", "loc", "[", "df", "[", "'tethnicity3'", "]", "==", "'asian'", ",", "'tethnicity3'", "]", "=", "2", "\n", "\n", "df", "=", "df", ".", "dropna", "(", ")", "\n", "\n", "grade", "=", "df", "[", "\"readk\"", "]", "+", "df", "[", "\"read1\"", "]", "+", "df", "[", "\"read2\"", "]", "+", "df", "[", "\"read3\"", "]", "\n", "grade", "+=", "df", "[", "\"mathk\"", "]", "+", "df", "[", "\"math1\"", "]", "+", "df", "[", "\"math2\"", "]", "+", "df", "[", "\"math3\"", "]", "\n", "\n", "\n", "names", "=", "df", ".", "columns", "\n", "target_names", "=", "names", "[", "8", ":", "16", "]", "\n", "data_names", "=", "np", ".", "concatenate", "(", "(", "names", "[", "0", ":", "8", "]", ",", "names", "[", "17", ":", "]", ")", ")", "\n", "X", "=", "df", ".", "loc", "[", ":", ",", "data_names", "]", ".", "values", "\n", "y", "=", "grade", ".", "values", "\n", "\n", "\n", "", "if", "name", "==", "\"facebook_1\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'facebook/Features_Variant_1.csv'", ")", "\n", "y", "=", "df", ".", "iloc", "[", ":", ",", "53", "]", ".", "values", "\n", "#        y = np.log(1 + y - min(y))", "\n", "X", "=", "df", ".", "iloc", "[", ":", ",", "0", ":", "53", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "\"facebook_2\"", ":", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'facebook/Features_Variant_2.csv'", ")", "\n", "y", "=", "df", ".", "iloc", "[", ":", ",", "53", "]", ".", "values", "\n", "#        y = np.log(1 + y - min(y))", "\n", "\n", "X", "=", "df", ".", "iloc", "[", ":", ",", "0", ":", "53", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "\"bio\"", ":", "\n", "#https://github.com/joefavergel/TertiaryPhysicochemicalProperties/blob/master/RMSD-ProteinTertiaryStructures.ipynb", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'CASP.csv'", ")", "\n", "y", "=", "df", ".", "iloc", "[", ":", ",", "0", "]", ".", "values", "\n", "X", "=", "df", ".", "iloc", "[", ":", ",", "1", ":", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "'blog_data'", ":", "\n", "# https://github.com/xinbinhuang/feature-selection_blogfeedback", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'blogData_train.csv'", ",", "header", "=", "None", ")", "\n", "X", "=", "df", ".", "iloc", "[", ":", ",", "0", ":", "280", "]", ".", "values", "\n", "y", "=", "df", ".", "iloc", "[", ":", ",", "-", "1", "]", ".", "values", "\n", "\n", "", "if", "name", "==", "\"concrete\"", ":", "\n", "        ", "dataset", "=", "np", ".", "loadtxt", "(", "open", "(", "base_path", "+", "'Concrete_Data.csv'", ",", "\"rb\"", ")", ",", "delimiter", "=", "\",\"", ",", "skiprows", "=", "1", ")", "\n", "X", "=", "dataset", "[", ":", ",", ":", "-", "1", "]", "\n", "y", "=", "dataset", "[", ":", ",", "-", "1", ":", "]", "\n", "#        y = np.log(1 + y - min(y))", "\n", "\n", "\n", "\n", "", "if", "name", "==", "\"bike\"", ":", "\n", "# https://www.kaggle.com/rajmehra03/bike-sharing-demand-rmsle-0-3194", "\n", "        ", "df", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'bike_train.csv'", ")", "\n", "\n", "# # seperating season as per values. this is bcoz this will enhance features.", "\n", "season", "=", "pd", ".", "get_dummies", "(", "df", "[", "'season'", "]", ",", "prefix", "=", "'season'", ")", "\n", "df", "=", "pd", ".", "concat", "(", "[", "df", ",", "season", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# # # same for weather. this is bcoz this will enhance features.", "\n", "weather", "=", "pd", ".", "get_dummies", "(", "df", "[", "'weather'", "]", ",", "prefix", "=", "'weather'", ")", "\n", "df", "=", "pd", ".", "concat", "(", "[", "df", ",", "weather", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# # # now can drop weather and season.", "\n", "df", ".", "drop", "(", "[", "'season'", ",", "'weather'", "]", ",", "inplace", "=", "True", ",", "axis", "=", "1", ")", "\n", "df", ".", "head", "(", ")", "\n", "\n", "df", "[", "\"hour\"", "]", "=", "[", "t", ".", "hour", "for", "t", "in", "pd", ".", "DatetimeIndex", "(", "df", ".", "datetime", ")", "]", "\n", "df", "[", "\"day\"", "]", "=", "[", "t", ".", "dayofweek", "for", "t", "in", "pd", ".", "DatetimeIndex", "(", "df", ".", "datetime", ")", "]", "\n", "df", "[", "\"month\"", "]", "=", "[", "t", ".", "month", "for", "t", "in", "pd", ".", "DatetimeIndex", "(", "df", ".", "datetime", ")", "]", "\n", "df", "[", "'year'", "]", "=", "[", "t", ".", "year", "for", "t", "in", "pd", ".", "DatetimeIndex", "(", "df", ".", "datetime", ")", "]", "\n", "df", "[", "'year'", "]", "=", "df", "[", "'year'", "]", ".", "map", "(", "{", "2011", ":", "0", ",", "2012", ":", "1", "}", ")", "\n", "\n", "df", ".", "drop", "(", "'datetime'", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df", ".", "drop", "(", "[", "'casual'", ",", "'registered'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df", ".", "columns", ".", "to_series", "(", ")", ".", "groupby", "(", "df", ".", "dtypes", ")", ".", "groups", "\n", "X", "=", "df", ".", "drop", "(", "'count'", ",", "axis", "=", "1", ")", ".", "values", "\n", "y", "=", "df", "[", "'count'", "]", ".", "values", "\n", "\n", "\n", "", "if", "name", "==", "\"community\"", ":", "\n", "# https://github.com/vbordalo/Communities-Crime/blob/master/Crime_v1.ipynb", "\n", "        ", "attrib", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'communities_attributes.csv'", ",", "delim_whitespace", "=", "True", ")", "\n", "data", "=", "pd", ".", "read_csv", "(", "base_path", "+", "'communities.data'", ",", "names", "=", "attrib", "[", "'attributes'", "]", ")", "\n", "data", "=", "data", ".", "drop", "(", "columns", "=", "[", "'state'", ",", "'county'", ",", "\n", "'community'", ",", "'communityname'", ",", "\n", "'fold'", "]", ",", "axis", "=", "1", ")", "\n", "\n", "data", "=", "data", ".", "replace", "(", "'?'", ",", "np", ".", "nan", ")", "\n", "\n", "# Impute mean values for samples with missing values        ", "\n", "#        from sklearn.preprocessing import Imputer", "\n", "from", "sklearn", ".", "impute", "import", "SimpleImputer", "\n", "\n", "imputer", "=", "SimpleImputer", "(", "missing_values", "=", "'NaN'", ",", "strategy", "=", "'mean'", ")", "\n", "\n", "imputer", "=", "imputer", ".", "fit", "(", "data", "[", "[", "'OtherPerCap'", "]", "]", ")", "\n", "data", "[", "[", "'OtherPerCap'", "]", "]", "=", "imputer", ".", "transform", "(", "data", "[", "[", "'OtherPerCap'", "]", "]", ")", "\n", "data", "=", "data", ".", "dropna", "(", "axis", "=", "1", ")", "\n", "X", "=", "data", ".", "iloc", "[", ":", ",", "0", ":", "100", "]", ".", "values", "\n", "y", "=", "data", ".", "iloc", "[", ":", ",", "100", "]", ".", "values", "\n", "\n", "\n", "", "X", "=", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y", "=", "y", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "\n", "return", "X", ",", "y", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.experiments.experiment_real_func.run_experiment": [[26, 164], ["numpy.random.seed", "dataset.GetDataset", "min", "max", "print", "random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.is_available", "sklearn.model_selection.train_test_split", "sklearn.model_selection.train_test_split", "sklearn.preprocessing.StandardScaler", "sklearn.preprocessing.StandardScaler.fit", "sklearn.preprocessing.StandardScaler.transform", "sklearn.preprocessing.StandardScaler.transform", "sklearn.preprocessing.StandardScaler.transform", "pandas.DataFrame", "pandas.DataFrame", "chr.black_boxes.QRF.fit", "numpy.random.normal", "torch.cuda.manual_seed_all", "len", "numpy.arange", "chr.black_boxes.QNet", "chr.methods.CHR", "chr.others.DistSplit", "chr.others.DCP", "chr.others.CQR", "chr.others.CQR2", "method.calibrate", "method.predict", "chr.utils.evaluate_predictions", "results.append.append", "results.append.to_csv", "print", "sys.stdout.flush", "numpy.arange", "chr.black_boxes.QRF", "os.path.exists", "os.mkdir"], "function", ["home.repos.pwc.inspect_result.msesia_chr.experiments.dataset.GetDataset", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.utils.evaluate_predictions"], ["def", "run_experiment", "(", "base_dataset_path", ",", "\n", "dataset_name", ",", "\n", "test_size", ",", "\n", "n_cal", ",", "\n", "alpha", "=", "0.1", ",", "\n", "experiment", "=", "0", ",", "\n", "bbox_method", "=", "'NNet'", ",", "\n", "out_dir", "=", "'./results'", ",", "\n", "random_state", "=", "2020", ",", "\n", "n_jobs", "=", "1", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "\n", "# Set random seed", "\n", "    ", "np", ".", "random", ".", "seed", "(", "random_state", ")", "\n", "# Random state for this experiment", "\n", "random_state", "=", "2020", "+", "experiment", "\n", "\n", "X", ",", "Y", "=", "GetDataset", "(", "dataset_name", ",", "base_dataset_path", ")", "\n", "\n", "# Add noise to response", "\n", "Y", "+=", "1e-6", "*", "np", ".", "random", ".", "normal", "(", "size", "=", "Y", ".", "shape", ")", "\n", "\n", "# if transform_y:", "\n", "# Y = np.log(1 + Y - min(Y))", "\n", "\n", "y_min", "=", "min", "(", "Y", ")", "\n", "y_max", "=", "max", "(", "Y", ")", "\n", "\n", "if", "X", ".", "shape", "[", "0", "]", "<=", "2", "*", "n_cal", "+", "test_size", ":", "\n", "        ", "return", "\n", "\n", "# Determine output file", "\n", "", "out_file", "=", "out_dir", "+", "\"/summary.csv\"", "\n", "print", "(", "out_file", ")", "\n", "\n", "# Set random seed", "\n", "random", ".", "seed", "(", "random_state", ")", "\n", "np", ".", "random", ".", "seed", "(", "random_state", ")", "\n", "torch", ".", "manual_seed", "(", "random_state", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed_all", "(", "random_state", ")", "\n", "\n", "\n", "# Split the data", "\n", "", "X_train", ",", "X_test", ",", "Y_train", ",", "Y_test", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "test_size", ",", "\n", "random_state", "=", "random_state", ")", "\n", "\n", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X_train", ",", "Y_train", ",", "test_size", "=", "n_cal", ",", "\n", "random_state", "=", "random_state", ")", "\n", "\n", "\n", "scaler", "=", "StandardScaler", "(", ")", "\n", "scaler", ".", "fit", "(", "X_train", ")", "\n", "X_train", "=", "scaler", ".", "transform", "(", "X_train", ")", "\n", "X_calib", "=", "scaler", ".", "transform", "(", "X_calib", ")", "\n", "X_test", "=", "scaler", ".", "transform", "(", "X_test", ")", "\n", "\n", "\n", "n_train", "=", "X_train", ".", "shape", "[", "0", "]", "\n", "assert", "(", "n_cal", "==", "X_calib", ".", "shape", "[", "0", "]", ")", "\n", "n_test", "=", "X_test", ".", "shape", "[", "0", "]", "\n", "\n", "results", "=", "pd", ".", "DataFrame", "(", ")", "\n", "results_full", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "if", "len", "(", "X", ".", "shape", ")", "==", "1", ":", "\n", "        ", "n_features", "=", "1", "\n", "", "else", ":", "\n", "        ", "n_features", "=", "X", ".", "shape", "[", "1", "]", "\n", "\n", "", "y_step", "=", "1000", "# maybe larger than 1000", "\n", "\n", "# Initialize the black-box and the conformalizer", "\n", "if", "bbox_method", "==", "'NNet'", ":", "\n", "\n", "        ", "epochs", "=", "2000", "\n", "lr", "=", "0.0005", "\n", "batch_size", "=", "n_train", "\n", "dropout", "=", "0.1", "\n", "\n", "grid_quantiles", "=", "np", ".", "arange", "(", "0.01", ",", "1.0", ",", "0.01", ")", "\n", "bbox", "=", "QNet", "(", "grid_quantiles", ",", "n_features", ",", "no_crossing", "=", "True", ",", "batch_size", "=", "batch_size", ",", "\n", "dropout", "=", "dropout", ",", "num_epochs", "=", "epochs", ",", "learning_rate", "=", "lr", ",", "calibrate", "=", "1", ",", "\n", "verbose", "=", "verbose", ")", "\n", "", "elif", "bbox_method", "==", "'RF'", ":", "\n", "        ", "n_estimators", "=", "100", "\n", "min_samples_leaf", "=", "50", "\n", "#        min_samples_leaf = 20", "\n", "#max_features = x_train.shape[1]", "\n", "grid_quantiles", "=", "np", ".", "arange", "(", "0.01", ",", "1.0", ",", "0.01", ")", "\n", "bbox", "=", "QRF", "(", "grid_quantiles", ",", "n_estimators", "=", "n_estimators", ",", "\n", "min_samples_leaf", "=", "min_samples_leaf", ",", "random_state", "=", "2020", ",", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "verbose", ")", "\n", "\n", "\n", "# Train the black-box model", "\n", "", "bbox", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "# Define list of methods to use in experiments", "\n", "methods", "=", "{", "\n", "'CHR'", ":", "CHR", "(", "bbox", ",", "ymin", "=", "y_min", ",", "ymax", "=", "y_max", ",", "y_steps", "=", "1000", ",", "randomize", "=", "True", ")", ",", "\n", "'DistSplit'", ":", "DistSplit", "(", "bbox", ",", "ymin", "=", "y_min", ",", "ymax", "=", "y_max", ")", ",", "\n", "'DCP'", ":", "DCP", "(", "bbox", ",", "ymin", "=", "y_min", ",", "ymax", "=", "y_max", ")", ",", "\n", "'CQR'", ":", "CQR", "(", "bbox", ")", ",", "\n", "'CQR2'", ":", "CQR2", "(", "bbox", ")", "\n", "}", "\n", "\n", "for", "method_name", "in", "methods", ":", "\n", "# Apply the conformalization method", "\n", "        ", "method", "=", "methods", "[", "method_name", "]", "\n", "method", ".", "calibrate", "(", "X_calib", ",", "Y_calib", ",", "alpha", ")", "\n", "# Compute prediction on test data", "\n", "pred", "=", "method", ".", "predict", "(", "X_test", ")", "\n", "\n", "# Evaluate results", "\n", "res", "=", "evaluate_predictions", "(", "pred", ",", "Y_test", ",", "X", "=", "X_test", ")", "\n", "# Add information about this experiment", "\n", "res", "[", "'Box'", "]", "=", "bbox_method", "\n", "res", "[", "'Dataset'", "]", "=", "dataset_name", "\n", "res", "[", "'Method'", "]", "=", "method_name", "\n", "res", "[", "'Experiment'", "]", "=", "experiment", "\n", "res", "[", "'Nominal'", "]", "=", "1", "-", "alpha", "\n", "res", "[", "'n_train'", "]", "=", "n_train", "\n", "res", "[", "'n_cal'", "]", "=", "n_cal", "\n", "res", "[", "'n_test'", "]", "=", "n_test", "\n", "\n", "\n", "# Add results to the list", "\n", "results", "=", "results", ".", "append", "(", "res", ")", "\n", "\n", "# Write results on output files", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "out_dir", ")", "\n", "\n", "", "results", ".", "to_csv", "(", "out_file", ",", "index", "=", "False", ",", "float_format", "=", "\"%.4f\"", ")", "\n", "print", "(", "\"Updated summary of results on\\n {}\"", ".", "format", "(", "out_file", ")", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex1.__init__": [[11, 14], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "a", "=", "1.0", ",", "symmetry", "=", "0", ")", ":", "\n", "        ", "self", ".", "a", "=", "a", "\n", "self", ".", "symmetry", "=", "symmetry", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex1.sample_X": [[15, 19], ["numpy.random.uniform", "X.reshape.reshape.reshape", "X.reshape.reshape.astype"], "methods", ["None"], ["", "def", "sample_X", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "a", ",", "size", "=", "n", ")", "\n", "X", "=", "X", ".", "reshape", "(", "(", "n", ",", "1", ")", ")", "\n", "return", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex1._sample_Y": [[20, 27], ["numpy.random.poisson", "numpy.random.uniform", "numpy.random.randn", "numpy.random.uniform", "numpy.random.randn", "numpy.sin"], "methods", ["None"], ["", "def", "_sample_Y", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "np", ".", "random", ".", "poisson", "(", "np", ".", "sin", "(", "x", "*", "2", "*", "np", ".", "pi", ")", "**", "2", "+", "0.1", ")", "+", "0.2", "*", "x", "*", "np", ".", "random", ".", "randn", "(", "1", ")", "\n", "y", "+=", "(", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "1", ")", "<", "0.09", ")", "*", "(", "5", "+", "2", "*", "np", ".", "random", ".", "randn", "(", "1", ")", ")", "\n", "# Toss a coin and decide whether to flip y", "\n", "if", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "1", ")", "<", "self", ".", "symmetry", ":", "\n", "            ", "y", "=", "-", "y", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex1.sample_Y": [[28, 33], ["range", "Y.astype().flatten", "len", "models.Model_Ex1._sample_Y", "Y.astype"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2._sample_Y"], ["", "def", "sample_Y", "(", "self", ",", "X", ")", ":", "\n", "        ", "Y", "=", "0", "*", "X", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "            ", "Y", "[", "i", "]", "=", "self", ".", "_sample_Y", "(", "X", "[", "i", "]", ")", "\n", "", "return", "Y", ".", "astype", "(", "np", ".", "float32", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex1.sample": [[34, 38], ["models.Model_Ex1.sample_X", "models.Model_Ex1.sample_Y"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_X", "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y"], ["", "def", "sample", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "self", ".", "sample_X", "(", "n", ")", "\n", "Y", "=", "self", ".", "sample_Y", "(", "X", ")", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2.__init__": [[40, 43], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "a", "=", "1.0", ",", "symmetry", "=", "0", ")", ":", "\n", "        ", "self", ".", "a", "=", "a", "\n", "self", ".", "symmetry", "=", "symmetry", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2.sample_X": [[44, 48], ["numpy.random.uniform", "X.reshape.reshape.reshape", "X.reshape.reshape.astype"], "methods", ["None"], ["", "def", "sample_X", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "a", ",", "size", "=", "n", ")", "\n", "X", "=", "X", ".", "reshape", "(", "(", "n", ",", "1", ")", ")", "\n", "return", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2._sample_Y": [[49, 56], ["numpy.random.poisson", "numpy.random.uniform", "numpy.random.randn", "numpy.random.uniform", "numpy.random.randn", "numpy.sin"], "methods", ["None"], ["", "def", "_sample_Y", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "np", ".", "random", ".", "poisson", "(", "np", ".", "sin", "(", "x", "*", "2", "*", "np", ".", "pi", ")", "**", "2", "+", "0.1", ")", "+", "1", "*", "x", "*", "np", ".", "random", ".", "randn", "(", "1", ")", "\n", "y", "+=", "(", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "1", ")", "<", "0.09", ")", "*", "(", "5", "+", "2", "*", "np", ".", "random", ".", "randn", "(", "1", ")", ")", "\n", "# Toss a coin and decide whether to flip y", "\n", "if", "np", ".", "random", ".", "uniform", "(", "0", ",", "1", ",", "1", ")", "<", "self", ".", "symmetry", ":", "\n", "            ", "y", "=", "-", "y", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2.sample_Y": [[57, 62], ["range", "Y.astype().flatten", "len", "models.Model_Ex2._sample_Y", "Y.astype"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2._sample_Y"], ["", "def", "sample_Y", "(", "self", ",", "X", ")", ":", "\n", "        ", "Y", "=", "0", "*", "X", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "            ", "Y", "[", "i", "]", "=", "self", ".", "_sample_Y", "(", "X", "[", "i", "]", ")", "\n", "", "return", "Y", ".", "astype", "(", "np", ".", "float32", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex2.sample": [[63, 67], ["models.Model_Ex2.sample_X", "models.Model_Ex2.sample_Y"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_X", "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y"], ["", "def", "sample", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "self", ".", "sample_X", "(", "n", ")", "\n", "Y", "=", "self", ".", "sample_Y", "(", "X", ")", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex3.__init__": [[70, 74], ["numpy.zeros"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "p", "=", "1", ")", ":", "\n", "        ", "self", ".", "p", "=", "p", "\n", "self", ".", "beta", "=", "np", ".", "zeros", "(", "(", "self", ".", "p", ",", ")", ")", "\n", "self", ".", "beta", "[", "0", ":", "5", "]", "=", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex3.sample_X": [[75, 78], ["numpy.random.uniform", "numpy.random.uniform.astype"], "methods", ["None"], ["", "def", "sample_X", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "n", ",", "self", ".", "p", ")", ")", "\n", "return", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex3.sample_Y": [[79, 89], ["numpy.dot", "numpy.random.normal", "Y.astype().flatten", "models.Model_Ex3.sample_Y.f"], "methods", ["None"], ["", "def", "sample_Y", "(", "self", ",", "X", ")", ":", "\n", "        ", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "def", "f", "(", "Z", ")", ":", "\n", "            ", "return", "(", "2.0", "*", "np", ".", "sin", "(", "np", ".", "pi", "*", "Z", ")", "+", "np", ".", "pi", "*", "Z", ")", "\n", "\n", "", "Z", "=", "np", ".", "dot", "(", "X", ",", "self", ".", "beta", ")", "\n", "E", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "n", ",", ")", ")", "\n", "Y", "=", "f", "(", "Z", ")", "+", "np", ".", "sqrt", "(", "1.0", "+", "Z", "**", "2", ")", "*", "E", "\n", "\n", "return", "Y", ".", "astype", "(", "np", ".", "float32", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex3.sample": [[90, 94], ["models.Model_Ex3.sample_X", "models.Model_Ex3.sample_Y"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_X", "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y"], ["", "def", "sample", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "self", ".", "sample_X", "(", "n", ")", "\n", "Y", "=", "self", ".", "sample_Y", "(", "X", ")", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.__init__": [[96, 98], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "a", "=", "0.9", ")", ":", "\n", "        ", "self", ".", "a", "=", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_X": [[99, 103], ["numpy.random.uniform", "X.reshape.reshape.reshape", "X.reshape.reshape.astype"], "methods", ["None"], ["", "def", "sample_X", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "np", ".", "random", ".", "uniform", "(", "0.1", ",", "self", ".", "a", ",", "size", "=", "n", ")", "\n", "X", "=", "X", ".", "reshape", "(", "(", "n", ",", "1", ")", ")", "\n", "return", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y": [[104, 110], ["range", "Y.astype().flatten", "len", "numpy.sin", "Y.astype", "numpy.random.randn"], "methods", ["None"], ["", "def", "sample_Y", "(", "self", ",", "X", ")", ":", "\n", "        ", "Y", "=", "0", "*", "X", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "            ", "Y", "[", "i", "]", "=", "np", ".", "sin", "(", "X", "[", "i", "]", "*", "np", ".", "pi", ")", "+", "X", "[", "i", "]", "*", "np", ".", "random", ".", "randn", "(", "1", ")", "\n", "\n", "", "return", "Y", ".", "astype", "(", "np", ".", "float32", ")", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample": [[111, 115], ["models.Model_Ex4.sample_X", "models.Model_Ex4.sample_Y"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_X", "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y"], ["", "def", "sample", "(", "self", ",", "n", ")", ":", "\n", "        ", "X", "=", "self", ".", "sample_X", "(", "n", ")", "\n", "Y", "=", "self", ".", "sample_Y", "(", "X", ")", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_GaussianAR1.__init__": [[137, 148], ["models.covariance_AR1", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.models.covariance_AR1"], ["def", "__init__", "(", "self", ",", "p", "=", "10", ",", "rho", "=", "0.7", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n        :param p      : Number of variables\n        :param rho    : A coupling parameter\n        :return:\n        \"\"\"", "\n", "self", ".", "p", "=", "p", "\n", "self", ".", "rho", "=", "rho", "\n", "self", ".", "Sigma", "=", "covariance_AR1", "(", "self", ".", "p", ",", "[", "self", ".", "rho", "]", "*", "(", "self", ".", "p", "-", "1", ")", ")", "\n", "self", ".", "mu", "=", "np", ".", "zeros", "(", "(", "self", ".", "p", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_GaussianAR1.sample": [[149, 156], ["numpy.random.multivariate_normal().astype", "numpy.random.multivariate_normal"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "n", "=", "1", ",", "**", "args", ")", ":", "\n", "        ", "\"\"\"\n        Sample the observations from their marginal distribution\n        :param n: The number of observations to be sampled (default 1)\n        :return: numpy matrix (n x p)\n        \"\"\"", "\n", "return", "np", ".", "random", ".", "multivariate_normal", "(", "self", ".", "mu", ",", "self", ".", "Sigma", ",", "n", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_GaussianAR1.extract_y": [[157, 161], ["numpy.delete", "numpy.delete.astype", "Y.astype"], "methods", ["None"], ["", "def", "extract_y", "(", "self", ",", "X", ",", "feature_y", "=", "0", ")", ":", "\n", "        ", "Y", "=", "X", "[", ":", ",", "feature_y", "]", "\n", "X", "=", "np", ".", "delete", "(", "X", ",", "feature_y", ",", "1", ")", "\n", "return", "X", ".", "astype", "(", "np", ".", "float", ")", ",", "Y", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_GaussianAR1.flip_signs": [[162, 167], ["numpy.random.binomial", "new_X.astype"], "methods", ["None"], ["", "def", "flip_signs", "(", "self", ",", "X", ",", "percent_flip", "=", "0.001", ")", ":", "\n", "        ", "is_outlier", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "percent_flip", ",", "X", ".", "shape", ")", "\n", "new_X", "=", "(", "1", "-", "2", "*", "is_outlier", ")", "*", "X", "\n", "\n", "return", "new_X", ".", "astype", "(", "np", ".", "float", ")", ",", "is_outlier", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_GaussianAR1.p_not_outlier": [[168, 176], ["scipy.stats.multivariate_normal", "X.copy", "scipy.stats.multivariate_normal.pdf", "scipy.stats.multivariate_normal.pdf"], "methods", ["None"], ["", "def", "p_not_outlier", "(", "self", ",", "X", ",", "feature_y", ",", "percent_flip", "=", "0.001", ")", ":", "\n", "        ", "dist", "=", "multivariate_normal", "(", "mean", "=", "self", ".", "mu", ",", "cov", "=", "self", ".", "Sigma", ")", "\n", "X_tilde", "=", "X", ".", "copy", "(", ")", "\n", "X_tilde", "[", ":", ",", "feature_y", "]", "=", "-", "X_tilde", "[", ":", ",", "feature_y", "]", "\n", "fx", "=", "dist", ".", "pdf", "(", "X", ")", "\n", "fx_tilde", "=", "dist", ".", "pdf", "(", "X_tilde", ")", "\n", "ret_val", "=", "1.0", "-", "fx_tilde", "*", "percent_flip", "/", "(", "fx_tilde", "*", "percent_flip", "+", "fx", "*", "(", "1", "-", "percent_flip", ")", ")", "\n", "return", "ret_val", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.models.covariance_AR1": [[117, 132], ["numpy.zeros", "range", "len", "max", "min", "range", "numpy.diag", "functools.reduce", "numpy.triu", "numpy.diag", "numpy.triu", "range"], "function", ["None"], ["", "", "def", "covariance_AR1", "(", "p", ",", "rho", ")", ":", "\n", "    ", "\"\"\"\n    Construct the covariance matrix of a Gaussian AR(1) process\n    \"\"\"", "\n", "assert", "len", "(", "rho", ")", ">", "0", ",", "\"The list of coupling parameters must have non-zero length\"", "\n", "assert", "0", "<=", "max", "(", "rho", ")", "<=", "1", ",", "\"The coupling parameters must be between 0 and 1\"", "\n", "assert", "0", "<=", "min", "(", "rho", ")", "<=", "1", ",", "\"The coupling parameters must be between 0 and 1\"", "\n", "\n", "# Construct the covariance matrix", "\n", "Sigma", "=", "np", ".", "zeros", "(", "shape", "=", "(", "p", ",", "p", ")", ")", "\n", "for", "i", "in", "range", "(", "p", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", ",", "p", ")", ":", "\n", "            ", "Sigma", "[", "i", "]", "[", "j", "]", "=", "reduce", "(", "mul", ",", "[", "rho", "[", "l", "]", "for", "l", "in", "range", "(", "i", ",", "j", ")", "]", ",", "1", ")", "\n", "", "", "Sigma", "=", "np", ".", "triu", "(", "Sigma", ")", "+", "np", ".", "triu", "(", "Sigma", ")", ".", "T", "-", "np", ".", "diag", "(", "np", ".", "diag", "(", "Sigma", ")", ")", "\n", "return", "Sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.__init__": [[19, 38], ["numpy.linspace", "methods.CHR.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["def", "__init__", "(", "self", ",", "bbox", "=", "None", ",", "ymin", "=", "-", "1", ",", "ymax", "=", "1", ",", "y_steps", "=", "1000", ",", "delta_alpha", "=", "0.001", ",", "intervals", "=", "True", ",", "randomize", "=", "False", ")", ":", "\n", "\n", "# Define discrete grid of y values for histogram estimator", "\n", "        ", "self", ".", "grid_histogram", "=", "np", ".", "linspace", "(", "ymin", ",", "ymax", ",", "num", "=", "y_steps", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "ymin", "=", "ymin", "\n", "self", ".", "ymax", "=", "ymax", "\n", "\n", "# Should we predict intervals or sets?", "\n", "self", ".", "intervals", "=", "intervals", "\n", "\n", "# Store the black-box", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Store desired nominal level", "\n", "", "self", ".", "alpha", "=", "None", "\n", "self", ".", "delta_alpha", "=", "delta_alpha", "\n", "\n", "self", ".", "randomize", "=", "randomize", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.init_bbox": [[40, 48], ["methods.CHR.bbox.get_quantiles", "chr.histogram.Histogram", "numpy.diff"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles"], ["", "def", "init_bbox", "(", "self", ",", "bbox", ")", ":", "\n", "# Store the black-box", "\n", "        ", "self", ".", "bbox", "=", "bbox", "\n", "grid_quantiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "# Make sure the quantiles are sorted", "\n", "assert", "(", "(", "np", ".", "diff", "(", "grid_quantiles", ")", ">=", "0", ")", ".", "all", "(", ")", ")", "\n", "# Initialize conditional histogram estimator", "\n", "self", ".", "hist", "=", "Histogram", "(", "grid_quantiles", ",", "self", ".", "grid_histogram", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.fit": [[49, 56], ["methods.CHR.bbox.fit", "methods.CHR.init_bbox", "X.astype", "Y.astype"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "bbox", "=", "None", ")", ":", "\n", "# Store the black-box", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Fit black-box model", "\n", "", "self", ".", "bbox", ".", "fit", "(", "X", ".", "astype", "(", "np", ".", "float32", ")", ",", "Y", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.calibrate": [[57, 95], ["methods.CHR.bbox.predict", "methods.CHR.hist.compute_histogram", "chr.grey_boxes.HistogramAccumulator", "numpy.round", "print", "methods.CHR.init_bbox", "X.astype", "numpy.random.uniform", "chr.grey_boxes.HistogramAccumulator.calibrate_intervals", "Y.astype", "float", "scipy.stats.mstats.mquantiles"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram.Histogram.compute_histogram", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox", "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.calibrate_intervals"], ["", "def", "calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "return_scores", "=", "False", ")", ":", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Store desired nominal level", "\n", "", "self", ".", "alpha", "=", "alpha", "\n", "\n", "# Compute predictions on calibration data", "\n", "q_calib", "=", "self", ".", "bbox", ".", "predict", "(", "X", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Estimate conditional histogram for calibration points", "\n", "d_calib", "=", "self", ".", "hist", ".", "compute_histogram", "(", "q_calib", ",", "self", ".", "ymin", ",", "self", ".", "ymax", ",", "alpha", ")", "\n", "\n", "# Initialize histogram accumulator (grey-box)", "\n", "accumulator", "=", "HistogramAccumulator", "(", "d_calib", ",", "self", ".", "grid_histogram", ",", "self", ".", "alpha", ",", "delta_alpha", "=", "self", ".", "delta_alpha", ")", "\n", "\n", "# Generate noise for randomization", "\n", "n2", "=", "X", ".", "shape", "[", "0", "]", "\n", "if", "self", ".", "randomize", ":", "\n", "            ", "epsilon", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ",", "size", "=", "n2", ")", "\n", "", "else", ":", "\n", "            ", "epsilon", "=", "None", "\n", "\n", "# Compute conformity scores", "\n", "", "if", "self", ".", "intervals", ":", "\n", "            ", "scores", "=", "accumulator", ".", "calibrate_intervals", "(", "Y", ".", "astype", "(", "np", ".", "float32", ")", ",", "epsilon", "=", "epsilon", ")", "\n", "", "else", ":", "\n", "# TODO: implement this", "\n", "            ", "assert", "(", "1", "==", "2", ")", "\n", "\n", "# Compute upper quantile of scores", "\n", "", "level_adjusted", "=", "(", "1.0", "-", "alpha", ")", "*", "(", "1.0", "+", "1.0", "/", "float", "(", "n2", ")", ")", "\n", "self", ".", "calibrated_alpha", "=", "np", ".", "round", "(", "1.0", "-", "mquantiles", "(", "scores", ",", "prob", "=", "level_adjusted", ")", "[", "0", "]", ",", "4", ")", "\n", "\n", "# Print message", "\n", "print", "(", "\"Calibrated alpha (nominal level: {}): {:.3f}.\"", ".", "format", "(", "alpha", ",", "self", ".", "calibrated_alpha", ")", ")", "\n", "\n", "return", "self", ".", "calibrated_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.fit_calibrate": [[97, 116], ["sklearn.model_selection.train_test_split", "methods.CHR.fit", "methods.CHR.calibrate", "methods.CHR.init_bbox", "X_train.astype", "Y_train.astype", "X_calib.astype", "Y_calib.astype"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "random_state", "=", "2020", ",", "bbox", "=", "None", ",", "\n", "verbose", "=", "False", ",", "return_scores", "=", "False", ")", ":", "\n", "# Store the black-box", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Split data into training/calibration sets", "\n", "", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", ")", "\n", "n2", "=", "X_calib", ".", "shape", "[", "0", "]", "\n", "\n", "# Fit black-box model", "\n", "self", ".", "fit", "(", "X_train", ".", "astype", "(", "np", ".", "float32", ")", ",", "Y_train", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Calibrate", "\n", "scores", "=", "self", ".", "calibrate", "(", "X_calib", ".", "astype", "(", "np", ".", "float32", ")", ",", "Y_calib", ".", "astype", "(", "np", ".", "float32", ")", ",", "alpha", ")", "\n", "\n", "# Return conformity scores", "\n", "if", "return_scores", ":", "\n", "            ", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.methods.CHR.predict": [[117, 143], ["methods.CHR.bbox.predict", "methods.CHR.hist.compute_histogram", "chr.grey_boxes.HistogramAccumulator", "chr.grey_boxes.HistogramAccumulator.predict_intervals", "X.astype", "numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram.Histogram.compute_histogram", "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals"], ["", "", "def", "predict", "(", "self", ",", "X", ",", "alpha", "=", "None", ")", ":", "\n", "        ", "assert", "(", "self", ".", "alpha", "is", "not", "None", ")", "\n", "\n", "# Compute predictions on new data", "\n", "q_new", "=", "self", ".", "bbox", ".", "predict", "(", "X", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Estimate conditional histogram for new data points", "\n", "d_new", "=", "self", ".", "hist", ".", "compute_histogram", "(", "q_new", ",", "self", ".", "ymin", ",", "self", ".", "ymax", ",", "self", ".", "alpha", ")", "\n", "\n", "# Initialize histogram accumulator (grey-box)", "\n", "accumulator", "=", "HistogramAccumulator", "(", "d_new", ",", "self", ".", "grid_histogram", ",", "self", ".", "alpha", ",", "delta_alpha", "=", "self", ".", "delta_alpha", ")", "\n", "\n", "# Generate noise for randomization", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "if", "self", ".", "randomize", ":", "\n", "            ", "epsilon", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ",", "size", "=", "n", ")", "\n", "", "else", ":", "\n", "            ", "epsilon", "=", "None", "\n", "\n", "# Compute prediction bands", "\n", "", "if", "alpha", "is", "None", ":", "\n", "            ", "alpha", "=", "self", ".", "calibrated_alpha", "\n", "\n", "", "_", ",", "bands", "=", "accumulator", ".", "predict_intervals", "(", "alpha", ",", "epsilon", "=", "epsilon", ")", "\n", "\n", "return", "bands", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QRF.__init__": [[13, 32], ["black_boxes_r.QRF.r.library"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "quantiles", ",", "n_estimators", "=", "100", ",", "min_samples_leaf", "=", "5", ",", "\n", "n_jobs", "=", "1", ",", "random_state", "=", "0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialization\n        Parameters\n        ----------\n        quantiles : numpy array of quantile levels (q), each in the range (0,1)\n        n_jobs: number of parallel jobs (default: 1)\n        random_state : integer, seed used in CV when splitting to train-test\n        \"\"\"", "\n", "\n", "self", ".", "quantiles", "=", "quantiles", "\n", "self", ".", "n_estimators", "=", "n_estimators", "\n", "self", ".", "min_samples_leaf", "=", "min_samples_leaf", "\n", "self", ".", "nthreads", "=", "n_jobs", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "r", "=", "ro", ".", "r", "\n", "self", ".", "r", ".", "library", "(", "'quantregForest'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QRF.fit": [[33, 38], ["black_boxes_r.QRF.r"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "return_loss", "=", "None", ")", ":", "\n", "        ", "self", ".", "r", "(", "'set.seed'", ")", "(", "self", ".", "random_state", ")", "\n", "\n", "self", ".", "forest", "=", "self", ".", "r", "[", "'quantregForest'", "]", "(", "X", ",", "Y", ",", "ntree", "=", "self", ".", "n_estimators", ",", "nodesize", "=", "self", ".", "min_samples_leaf", ",", "\n", "nthreads", "=", "self", ".", "nthreads", ",", "**", "{", "'do.trace'", ":", "self", ".", "verbose", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QRF.predict": [[40, 54], ["numpy.array"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Estimate the label given the features\n        Parameters\n        ----------\n        x : numpy array of training features (nXp)\n        Returns\n        -------\n        ret_val : numpy array of predicted labels (n)\n        \"\"\"", "\n", "\n", "# Sample from posterior distribution learnt by BART", "\n", "pred", "=", "np", ".", "array", "(", "self", ".", "r", "[", "'predict'", "]", "(", "self", ".", "forest", ",", "X", ",", "what", "=", "self", ".", "quantiles", ")", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QRF.get_quantiles": [[55, 57], ["None"], "methods", ["None"], ["", "def", "get_quantiles", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "quantiles", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QBART.__init__": [[61, 73], ["black_boxes_r.QBART.r.library"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "quantiles", ",", "random_state", "=", "0", ")", ":", "\n", "        ", "\"\"\" Initialization\n        Parameters\n        ----------\n        quantiles : numpy array of quantile levels (q), each in the range (0,1)\n        random_state : integer, seed used in CV when splitting to train-test\n        \"\"\"", "\n", "\n", "self", ".", "quantiles", "=", "quantiles", "\n", "\n", "self", ".", "r", "=", "ro", ".", "r", "\n", "self", ".", "r", ".", "library", "(", "'BART'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QBART.fit": [[74, 76], ["None"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "return_loss", "=", "None", ")", ":", "\n", "        ", "self", ".", "posterior", "=", "self", ".", "r", "[", "'gbart'", "]", "(", "X", ",", "Y", ",", "nskip", "=", "200", ",", "ndpost", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QBART.predict": [[78, 93], ["numpy.array", "scipy.stats.mstats.mquantiles"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Estimate the label given the features\n        Parameters\n        ----------\n        x : numpy array of training features (nXp)\n        Returns\n        -------\n        ret_val : numpy array of predicted labels (n)\n        \"\"\"", "\n", "\n", "# Sample from posterior distribution learnt by BART", "\n", "post_samples", "=", "np", ".", "array", "(", "self", ".", "r", "[", "'predict'", "]", "(", "self", ".", "posterior", ",", "X", ")", ")", "\n", "pred", "=", "mquantiles", "(", "post_samples", ",", "prob", "=", "self", ".", "quantiles", ",", "axis", "=", "0", ")", ".", "T", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes_r.QBART.get_quantiles": [[94, 96], ["None"], "methods", ["None"], ["", "def", "get_quantiles", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "quantiles", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.__init__": [[24, 26], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "super", "(", "QR_errfun", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply": [[27, 34], ["numpy.maximum"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "prediction", ",", "y", ")", ":", "\n", "    ", "y_lower", "=", "prediction", "[", ":", ",", "0", "]", "\n", "y_upper", "=", "prediction", "[", ":", ",", "-", "1", "]", "\n", "error_low", "=", "y_lower", "-", "y", "\n", "error_high", "=", "y", "-", "y_upper", "\n", "err", "=", "np", ".", "maximum", "(", "error_high", ",", "error_low", ")", "\n", "return", "err", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply_inverse": [[35, 38], ["numpy.quantile", "numpy.vstack", "numpy.minimum"], "methods", ["None"], ["", "def", "apply_inverse", "(", "self", ",", "nc", ",", "alpha", ")", ":", "\n", "    ", "q", "=", "np", ".", "quantile", "(", "nc", ",", "np", ".", "minimum", "(", "1.0", ",", "(", "1.0", "-", "alpha", ")", "*", "(", "nc", ".", "shape", "[", "0", "]", "+", "1.0", ")", "/", "nc", ".", "shape", "[", "0", "]", ")", ")", "\n", "return", "np", ".", "vstack", "(", "[", "q", ",", "q", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.Oracle.__init__": [[44, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "alpha", ",", "nreps", "=", "1000", ",", "ymin", "=", "None", ",", "ymax", "=", "None", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "nreps", "=", "nreps", "\n", "self", ".", "ymin", "=", "ymin", "\n", "self", ".", "ymax", "=", "ymax", "\n", "self", ".", "skeweness", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.Oracle.predict": [[52, 81], ["numpy.arange", "numpy.linspace", "chr.histogram.Histogram", "numpy.zeros", "numpy.zeros", "range", "chr.histogram.Histogram.compute_histogram", "chr.grey_boxes.HistogramAccumulator", "numpy.random.uniform", "chr.grey_boxes.HistogramAccumulator.predict_intervals", "numpy.mean", "numpy.array", "scipy.stats.mstats.mquantiles", "scipy.stats.skew", "len", "others.Oracle.model.sample_Y", "range"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.histogram.Histogram.compute_histogram", "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals", "home.repos.pwc.inspect_result.msesia_chr.chr.models.Model_Ex4.sample_Y"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "# Initialize conditional histogram estimator", "\n", "grid_quantiles", "=", "np", ".", "arange", "(", "0.01", ",", "0.99", ",", "0.005", ")", "\n", "grid_histogram", "=", "np", ".", "linspace", "(", "self", ".", "ymin", ",", "self", ".", "ymax", ",", "num", "=", "2000", ",", "endpoint", "=", "True", ")", "\n", "hist", "=", "Histogram", "(", "grid_quantiles", ",", "grid_histogram", ")", "\n", "\n", "quantiles", "=", "np", ".", "zeros", "(", "(", "n", ",", "len", "(", "grid_quantiles", ")", ")", ")", "\n", "skeweness", "=", "np", ".", "zeros", "(", "(", "n", ",", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "y_values", "=", "np", ".", "array", "(", "[", "self", ".", "model", ".", "sample_Y", "(", "X", "[", "i", "]", ")", "[", "0", "]", "for", "b", "in", "range", "(", "self", ".", "nreps", ")", "]", ")", "\n", "quantiles", "[", "i", "]", "=", "mquantiles", "(", "y_values", ",", "prob", "=", "grid_quantiles", ")", "\n", "skeweness", "[", "i", "]", "=", "skew", "(", "y_values", ")", "\n", "\n", "# Estimate conditional histogram for calibration points", "\n", "", "density", "=", "hist", ".", "compute_histogram", "(", "quantiles", ",", "self", ".", "ymin", ",", "self", ".", "ymax", ",", "self", ".", "alpha", ",", "smooth_tails", "=", "True", ")", "\n", "\n", "# Initialize histogram accumulator (grey-box)", "\n", "accumulator", "=", "HistogramAccumulator", "(", "density", ",", "grid_histogram", ",", "self", ".", "alpha", ")", "\n", "\n", "# Compute randomized prediction bands", "\n", "epsilon", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1.0", ",", "size", "=", "n", ")", "\n", "_", ",", "bands", "=", "accumulator", ".", "predict_intervals", "(", "self", ".", "alpha", ",", "epsilon", "=", "epsilon", ")", "\n", "\n", "# Estimate expected skeweness", "\n", "self", ".", "skeweness", "=", "np", ".", "mean", "(", "skeweness", ")", "\n", "\n", "return", "bands", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.__init__": [[87, 92], ["others.DistSplit.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["def", "__init__", "(", "self", ",", "bbox", "=", "None", ",", "ymin", "=", "-", "1", ",", "ymax", "=", "1", ")", ":", "\n", "    ", "if", "bbox", "is", "not", "None", ":", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "", "self", ".", "ymin", "=", "ymin", "\n", "self", ".", "ymax", "=", "ymax", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.init_bbox": [[93, 95], ["None"], "methods", ["None"], ["", "def", "init_bbox", "(", "self", ",", "bbox", ")", ":", "\n", "    ", "self", ".", "bbox", "=", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.fit": [[96, 99], ["others.DistSplit.bbox.fit"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "# Fit black-box model", "\n", "    ", "self", ".", "bbox", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.calibrate": [[100, 122], ["others.DistSplit.bbox.predict", "others.DistSplit.bbox.get_quantiles", "numpy.array", "range", "others.DistSplit.init_bbox", "chr.histogram._estim_dist", "cdf", "scipy.stats.mstats.mquantiles", "scipy.stats.mstats.mquantiles", "float"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist"], ["", "def", "calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "return_scores", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Compute predictions on calibration data", "\n", "", "n2", "=", "X", ".", "shape", "[", "0", "]", "\n", "quantiles", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "percentiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "\n", "# Compute conformity scores", "\n", "scores", "=", "np", ".", "array", "(", "[", "0.0", "]", "*", "n2", ")", "\n", "for", "i", "in", "range", "(", "n2", ")", ":", "\n", "        ", "cdf", ",", "inv_cdf", "=", "_estim_dist", "(", "quantiles", "[", "i", "]", ",", "percentiles", ",", "y_min", "=", "self", ".", "ymin", ",", "y_max", "=", "self", ".", "ymax", ",", "smooth_tails", "=", "True", ",", "tau", "=", "0.01", ")", "\n", "scores", "[", "i", "]", "=", "cdf", "(", "Y", "[", "i", "]", ")", "\n", "\n", "# Compute upper and lower quantiles of conformity scores", "\n", "", "alpha_adjusted", "=", "1", "-", "(", "1", "-", "alpha", ")", "*", "(", "1.0", "+", "1.0", "/", "float", "(", "n2", ")", ")", "\n", "self", ".", "t_lo", "=", "mquantiles", "(", "scores", ",", "prob", "=", "alpha_adjusted", "/", "2", ")", "[", "0", "]", "\n", "self", ".", "t_up", "=", "mquantiles", "(", "scores", ",", "prob", "=", "1.0", "-", "alpha_adjusted", "/", "2", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.fit_calibrate": [[136, 150], ["sklearn.model_selection.train_test_split", "others.DistSplit.fit", "others.DistSplit.calibrate", "others.DistSplit.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "random_state", "=", "2020", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Split data into training/calibration sets", "\n", "", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", ")", "\n", "\n", "# Fit black-box model", "\n", "self", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "# Calibrate", "\n", "self", ".", "calibrate", "(", "X_calib", ",", "Y_calib", ",", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DistSplit.predict": [[151, 164], ["others.DistSplit.bbox.predict", "others.DistSplit.bbox.get_quantiles", "numpy.zeros", "range", "chr.histogram._estim_dist", "inv_cdf", "inv_cdf"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "\n", "    ", "quantiles", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "percentiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "pred", "=", "np", ".", "zeros", "(", "(", "n", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "cdf", ",", "inv_cdf", "=", "_estim_dist", "(", "quantiles", "[", "i", "]", ",", "percentiles", ",", "y_min", "=", "self", ".", "ymin", ",", "y_max", "=", "self", ".", "ymax", ",", "smooth_tails", "=", "True", ",", "tau", "=", "0.01", ")", "\n", "pred", "[", "i", ",", "0", "]", "=", "inv_cdf", "(", "self", ".", "t_lo", ")", "\n", "pred", "[", "i", ",", "1", "]", "=", "inv_cdf", "(", "self", ".", "t_up", ")", "\n", "\n", "", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.__init__": [[170, 175], ["others.DCP.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["def", "__init__", "(", "self", ",", "bbox", "=", "None", ",", "ymin", "=", "-", "1", ",", "ymax", "=", "1", ")", ":", "\n", "    ", "if", "bbox", "is", "not", "None", ":", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "", "self", ".", "ymin", "=", "ymin", "\n", "self", ".", "ymax", "=", "ymax", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.init_bbox": [[176, 178], ["None"], "methods", ["None"], ["", "def", "init_bbox", "(", "self", ",", "bbox", ")", ":", "\n", "    ", "self", ".", "bbox", "=", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.fit": [[179, 182], ["others.DCP.bbox.fit"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "# Fit black-box model", "\n", "    ", "self", ".", "bbox", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.calibrate": [[183, 207], ["others.DCP.bbox.predict", "others.DCP.bbox.get_quantiles", "numpy.array", "range", "numpy.abs", "others.DCP.init_bbox", "chr.histogram._estim_dist", "cdf", "numpy.clip", "scipy.stats.mstats.mquantiles", "float"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist"], ["", "def", "calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "return_scores", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Compute predictions on calibration data", "\n", "", "n2", "=", "X", ".", "shape", "[", "0", "]", "\n", "quantiles", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "percentiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "\n", "# Compute conformity scores", "\n", "cdf_values", "=", "np", ".", "array", "(", "[", "0.0", "]", "*", "n2", ")", "\n", "for", "i", "in", "range", "(", "n2", ")", ":", "\n", "        ", "cdf", ",", "inv_cdf", "=", "_estim_dist", "(", "quantiles", "[", "i", "]", ",", "percentiles", ",", "y_min", "=", "self", ".", "ymin", ",", "y_max", "=", "self", ".", "ymax", ",", "smooth_tails", "=", "True", ",", "tau", "=", "0.01", ")", "\n", "cdf_values", "[", "i", "]", "=", "cdf", "(", "Y", "[", "i", "]", ")", "\n", "\n", "", "scores", "=", "np", ".", "abs", "(", "np", ".", "clip", "(", "cdf_values", ",", "0", ",", "1", ")", "-", "1", "/", "2", ")", "\n", "#noise = np.random.uniform(low=-1e-6, high=1e-6, size=n2)", "\n", "#scores = np.abs(np.clip(scores+noise, 0, 1)-1/2)", "\n", "\n", "level_adjusted", "=", "(", "1.0", "-", "alpha", ")", "*", "(", "1.0", "+", "1.0", "/", "float", "(", "n2", ")", ")", "\n", "self", ".", "alpha_calibrated", "=", "0.5", "-", "mquantiles", "(", "scores", ",", "prob", "=", "level_adjusted", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.fit_calibrate": [[208, 222], ["sklearn.model_selection.train_test_split", "others.DCP.fit", "others.DCP.calibrate", "others.DCP.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "random_state", "=", "2020", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Split data into training/calibration sets", "\n", "", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", ")", "\n", "\n", "# Fit black-box model", "\n", "self", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "# Calibrate", "\n", "self", ".", "calibrate", "(", "X_calib", ",", "Y_calib", ",", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.DCP.predict": [[223, 236], ["others.DCP.bbox.predict", "others.DCP.bbox.get_quantiles", "numpy.zeros", "range", "chr.histogram._estim_dist", "inv_cdf", "inv_cdf"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "\n", "    ", "quantiles", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "percentiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "pred", "=", "np", ".", "zeros", "(", "(", "n", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "cdf", ",", "inv_cdf", "=", "_estim_dist", "(", "quantiles", "[", "i", "]", ",", "percentiles", ",", "y_min", "=", "self", ".", "ymin", ",", "y_max", "=", "self", ".", "ymax", ",", "smooth_tails", "=", "True", ",", "tau", "=", "0.01", ")", "\n", "pred", "[", "i", ",", "0", "]", "=", "inv_cdf", "(", "self", ".", "alpha_calibrated", ")", "\n", "pred", "[", "i", ",", "1", "]", "=", "inv_cdf", "(", "1", "-", "self", ".", "alpha_calibrated", ")", "\n", "\n", "", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.__init__": [[242, 245], ["others.CQR.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["def", "__init__", "(", "self", ",", "bbox", "=", "None", ")", ":", "\n", "    ", "if", "bbox", "is", "not", "None", ":", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.init_bbox": [[246, 248], ["None"], "methods", ["None"], ["", "", "def", "init_bbox", "(", "self", ",", "bbox", ")", ":", "\n", "    ", "self", ".", "bbox", "=", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.fit": [[249, 252], ["others.CQR.bbox.fit"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "# Fit black-box model", "\n", "    ", "self", ".", "bbox", ".", "fit", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.calibrate": [[253, 280], ["others.CQR.bbox.predict", "others.CQR.bbox.get_quantiles", "others.find_nearest", "others.find_nearest", "others.QR_errfun", "others.QR_errfun.apply", "others.QR_errfun.apply_inverse", "print", "others.CQR.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.others.find_nearest", "home.repos.pwc.inspect_result.msesia_chr.chr.others.find_nearest", "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply", "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply_inverse", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "return_scores", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Compute predictions on calibration data", "\n", "", "n2", "=", "X", ".", "shape", "[", "0", "]", "\n", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "\n", "# Predict using (alpha/2, 1-alpha/2) quantiles", "\n", "quantiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "idx_lower", "=", "find_nearest", "(", "quantiles", ",", "self", ".", "alpha", "/", "2.0", ")", "\n", "idx_upper", "=", "find_nearest", "(", "quantiles", ",", "1.0", "-", "self", ".", "alpha", "/", "2.0", ")", "\n", "pred", "=", "pred", "[", ":", ",", "[", "idx_lower", ",", "idx_upper", "]", "]", "\n", "\n", "# Choose conformity score", "\n", "scorer", "=", "QR_errfun", "(", ")", "\n", "scores", "=", "scorer", ".", "apply", "(", "pred", ",", "Y", ")", "\n", "\n", "# Compute correction factor based on scores", "\n", "self", ".", "score_correction", "=", "scorer", ".", "apply_inverse", "(", "scores", ",", "alpha", ")", "\n", "\n", "# Print message", "\n", "print", "(", "\"Calibrated score corrections: {:.3f}, {:.3f}\"", ".", "format", "(", "-", "self", ".", "score_correction", "[", "0", ",", "0", "]", ",", "self", ".", "score_correction", "[", "1", ",", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.fit_calibrate": [[281, 295], ["sklearn.model_selection.train_test_split", "others.CQR.fit", "others.CQR.calibrate", "others.CQR.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "random_state", "=", "2020", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "self", ".", "alpha", "=", "alpha", "\n", "if", "bbox", "is", "not", "None", ":", "\n", "# Store the pre-trained black-box", "\n", "      ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Split data into training/calibration sets", "\n", "", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", ")", "\n", "\n", "# Fit black-box model", "\n", "self", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "# Calibrate", "\n", "self", ".", "calibrate", "(", "X_calib", ",", "Y_calib", ",", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.predict": [[296, 308], ["others.CQR.bbox.get_quantiles", "others.find_nearest", "others.find_nearest", "others.CQR.bbox.predict"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.others.find_nearest", "home.repos.pwc.inspect_result.msesia_chr.chr.others.find_nearest", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "# Predict using (alpha/2, 1-alpha/2) quantiles", "\n", "    ", "quantiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "idx_lower", "=", "find_nearest", "(", "quantiles", ",", "self", ".", "alpha", "/", "2.0", ")", "\n", "idx_upper", "=", "find_nearest", "(", "quantiles", ",", "1.0", "-", "self", ".", "alpha", "/", "2.0", ")", "\n", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "pred", "=", "pred", "[", ":", ",", "[", "idx_lower", ",", "idx_upper", "]", "]", "\n", "\n", "# Apply correction", "\n", "pred", "[", ":", ",", "0", "]", "-=", "self", ".", "score_correction", "[", "0", ",", "0", "]", "\n", "pred", "[", ":", ",", "1", "]", "+=", "self", ".", "score_correction", "[", "1", ",", "0", "]", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR.predict_all": [[309, 312], ["others.CQR.bbox.predict"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict"], ["", "def", "predict_all", "(", "self", ",", "X", ")", ":", "\n", "    ", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.__init__": [[317, 321], ["others.CQR2.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["def", "__init__", "(", "self", ",", "bbox", "=", "None", ")", ":", "\n", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox": [[322, 341], ["len", "int", "numpy.arange", "numpy.floor", "numpy.sort", "len", "numpy.diff", "len"], "methods", ["None"], ["", "", "def", "init_bbox", "(", "self", ",", "bbox", ")", ":", "\n", "\n", "        ", "self", ".", "bbox", "=", "bbox", "\n", "\n", "# Define sequence of prediction intervals for the black-box", "\n", "# e.g.", "\n", "# [0.05,0.1,0.5,0.9,0.95] -> [[0.05,0.95], [0.1,0.9]]", "\n", "# This assumes that the input quantiles are sorted", "\n", "quantiles", "=", "bbox", ".", "quantiles", "\n", "assert", "(", "(", "np", ".", "diff", "(", "quantiles", ")", ">=", "0", ")", ".", "all", "(", ")", ")", "\n", "# Number of prediction intervals = 1/2 number of black-box quantiles", "\n", "num_quantiles", "=", "len", "(", "quantiles", ")", "\n", "num_alpha", "=", "int", "(", "np", ".", "floor", "(", "num_quantiles", "/", "2", ")", ")", "\n", "assert", "(", "num_alpha", ">", "1", ")", "\n", "# Make list of lower and upper ends", "\n", "quantiles_idx", "=", "np", ".", "arange", "(", "num_quantiles", ")", "\n", "qidx_low", "=", "quantiles_idx", "[", "0", ":", "num_alpha", "]", "\n", "self", ".", "qidx_low", "=", "-", "np", ".", "sort", "(", "-", "qidx_low", ")", "\n", "self", ".", "qidx_high", "=", "quantiles_idx", "[", "(", "len", "(", "quantiles", ")", "-", "num_alpha", ")", ":", "len", "(", "quantiles", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.fit": [[342, 349], ["others.CQR2.bbox.fit", "others.CQR2.init_bbox", "X.astype", "Y.astype"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "bbox", "=", "None", ")", ":", "\n", "# Store the black-box", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Fit black-box model", "\n", "", "self", ".", "bbox", ".", "fit", "(", "X", ".", "astype", "(", "np", ".", "float32", ")", ",", "Y", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate": [[350, 410], ["others.CQR2.bbox.predict", "others.CQR2.bbox.get_quantiles", "len", "Y_calib.reshape", "numpy.pad", "numpy.argmax", "int", "numpy.zeros", "others.QR_errfun", "others.QR_errfun.apply", "QR_errfun.apply_inverse().flatten", "print", "others.CQR2.init_bbox", "len", "len", "len", "numpy.where", "scipy.stats.mstats.mquantiles", "len", "others.QR_errfun.apply_inverse", "float", "len"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles", "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox", "home.repos.pwc.inspect_result.msesia_chr.chr.others.QR_errfun.apply_inverse"], ["", "def", "calibrate", "(", "self", ",", "X_calib", ",", "Y_calib", ",", "alpha", ",", "bbox", "=", "None", ",", "return_scores", "=", "False", ")", ":", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Compute predictions on calibration data", "\n", "", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X_calib", ")", "\n", "\n", "# Extract black-box quantiles", "\n", "quantiles", "=", "self", ".", "bbox", ".", "get_quantiles", "(", ")", "\n", "num_quantiles", "=", "len", "(", "quantiles", ")", "\n", "\n", "# Check coverage for all intervals on calibration data", "\n", "pred_low", "=", "pred", "[", ":", ",", "self", ".", "qidx_low", "]", "\n", "pred_high", "=", "pred", "[", ":", ",", "self", ".", "qidx_high", "]", "\n", "Y_c_mat", "=", "Y_calib", ".", "reshape", "(", "(", "len", "(", "Y_calib", ")", ",", "1", ")", ")", "\n", "covered", "=", "(", "Y_c_mat", ">=", "pred_low", ")", "*", "(", "Y_c_mat", "<=", "pred_high", ")", "\n", "# Add padding to make sure coverage is always possible", "\n", "covered", "=", "np", ".", "pad", "(", "covered", ",", "(", "(", "0", ",", "0", ")", ",", "(", "1", ",", "1", ")", ")", ",", "'constant'", ",", "constant_values", "=", "(", "False", ",", "True", ")", ")", "\n", "# Compute conformity scores on calibration data", "\n", "scores", "=", "np", ".", "argmax", "(", "covered", "==", "True", ",", "axis", "=", "1", ")", "\n", "# Remove padding", "\n", "scores", "=", "scores", "-", "1", "\n", "scores", "[", "np", ".", "where", "(", "scores", "<", "0", ")", "]", "=", "0", "\n", "\n", "# Compute upper quantile of scores", "\n", "n2", "=", "X_calib", ".", "shape", "[", "0", "]", "\n", "level_adjusted", "=", "(", "1.0", "-", "alpha", ")", "*", "(", "1.0", "+", "1.0", "/", "float", "(", "n2", ")", ")", "\n", "calibrated_idx", "=", "int", "(", "mquantiles", "(", "scores", ",", "prob", "=", "level_adjusted", ")", "[", "0", "]", ")", "\n", "\n", "# Use the most conservative bands if everything else failed", "\n", "if", "calibrated_idx", ">=", "len", "(", "self", ".", "qidx_low", ")", ":", "\n", "            ", "calibrated_idx", "=", "len", "(", "self", ".", "qidx_low", ")", "-", "1", "\n", "\n", "# Apply CQR on top of the selected bands", "\n", "", "self", ".", "calibrated_qidx_low", "=", "self", ".", "qidx_low", "[", "calibrated_idx", "]", "\n", "self", ".", "calibrated_qidx_high", "=", "self", ".", "qidx_high", "[", "calibrated_idx", "]", "\n", "pred_cqr", "=", "np", ".", "zeros", "(", "(", "n2", ",", "2", ")", ")", "\n", "pred_cqr", "[", ":", ",", "0", "]", "=", "pred", "[", ":", ",", "self", ".", "calibrated_qidx_low", "]", "\n", "pred_cqr", "[", ":", ",", "1", "]", "=", "pred", "[", ":", ",", "self", ".", "calibrated_qidx_high", "]", "\n", "\n", "# Choose conformity score for CQR correction", "\n", "scorer_cqr", "=", "QR_errfun", "(", ")", "\n", "scores_cqr", "=", "scorer_cqr", ".", "apply", "(", "pred_cqr", ",", "Y_calib", ")", "\n", "\n", "# Compute correction factor based on scores", "\n", "self", ".", "cqr_correction", "=", "scorer_cqr", ".", "apply_inverse", "(", "scores_cqr", ",", "alpha", ")", ".", "flatten", "(", ")", "\n", "\n", "# Print message", "\n", "q_star_low", "=", "quantiles", "[", "self", ".", "calibrated_qidx_low", "]", "\n", "q_star_high", "=", "quantiles", "[", "self", ".", "calibrated_qidx_high", "]", "\n", "print", "(", "\"Calibrated quantiles (nominal level: {}): {:.3f},{:.3f}; CQR correction: {:.3f}\"", ".", "format", "(", "alpha", ",", "q_star_low", ",", "q_star_high", ",", "self", ".", "cqr_correction", "[", "0", "]", ")", ")", "\n", "\n", "# Return p-value scores", "\n", "scores_out", "=", "scores", "\n", "scores_out", "[", "scores_out", "==", "len", "(", "self", ".", "qidx_low", ")", "]", "=", "len", "(", "self", ".", "qidx_low", ")", "-", "1", "\n", "scores_out", "=", "1.0", "-", "2", "*", "quantiles", "[", "self", ".", "qidx_low", "[", "scores_out", "]", "]", "\n", "\n", "# Return conformity scores", "\n", "if", "return_scores", ":", "\n", "            ", "return", "scores_out", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.fit_calibrate": [[411, 429], ["sklearn.model_selection.train_test_split", "others.CQR2.fit", "others.CQR2.calibrate", "others.CQR2.init_bbox"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.calibrate", "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.init_bbox"], ["", "", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "random_state", "=", "2020", ",", "bbox", "=", "None", ",", "\n", "verbose", "=", "False", ",", "return_scores", "=", "False", ")", ":", "\n", "# Store the black-box", "\n", "        ", "if", "bbox", "is", "not", "None", ":", "\n", "            ", "self", ".", "init_bbox", "(", "bbox", ")", "\n", "\n", "# Split data into training/calibration sets", "\n", "", "X_train", ",", "X_calib", ",", "Y_train", ",", "Y_calib", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", ")", "\n", "\n", "# Fit black-box model", "\n", "self", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "# Calibrate", "\n", "scores", "=", "self", ".", "calibrate", "(", "X_calib", ",", "Y_calib", ",", "alpha", ")", "\n", "\n", "# Return conformity scores", "\n", "if", "return_scores", ":", "\n", "            ", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.predict": [[430, 436], ["others.CQR2.bbox.predict", "numpy.concatenate().squeeze", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict"], ["", "", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "pred_low", "=", "pred", "[", ":", ",", "self", ".", "calibrated_qidx_low", "]", "-", "self", ".", "cqr_correction", "[", "0", "]", "\n", "pred_high", "=", "pred", "[", ":", ",", "self", ".", "calibrated_qidx_high", "]", "+", "self", ".", "cqr_correction", "[", "1", "]", "\n", "\n", "return", "np", ".", "concatenate", "(", "(", "pred_low", "[", ":", ",", "np", ".", "newaxis", "]", ",", "pred_high", "[", ":", ",", "np", ".", "newaxis", "]", ")", ",", "axis", "=", "1", ")", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.CQR2.predict_all": [[437, 440], ["others.CQR2.bbox.predict"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict"], ["", "def", "predict_all", "(", "self", ",", "X", ")", ":", "\n", "        ", "pred", "=", "self", ".", "bbox", ".", "predict", "(", "X", ")", "\n", "return", "pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.others.find_nearest": [[12, 16], ["numpy.abs().argmin", "numpy.abs"], "function", ["None"], ["def", "find_nearest", "(", "a", ",", "a0", ")", ":", "\n", "    ", "\"Index of element in nd array `a` closest to the scalar value `a0`\"", "\n", "idx", "=", "np", ".", "abs", "(", "a", "-", "a0", ")", ".", "argmin", "(", ")", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.__init__": [[48, 67], ["numpy.round", "numpy.unique", "numpy.argsort", "numpy.empty_like", "range", "numpy.round", "numpy.arange", "numpy.sort", "numpy.arange", "numpy.sort", "grey_boxes.HistogramAccumulator.pi_sort.cumsum", "numpy.concatenate", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pi", ",", "breaks", ",", "alpha", ",", "delta_alpha", "=", "0.001", ")", ":", "\n", "        ", "self", ".", "n", ",", "self", ".", "K", "=", "pi", ".", "shape", "\n", "self", ".", "breaks", "=", "breaks", "\n", "self", ".", "pi", "=", "pi", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n", "# Define grid of alpha values", "\n", "self", ".", "alpha_grid", "=", "np", ".", "round", "(", "np", ".", "arange", "(", "delta_alpha", ",", "1.0", ",", "delta_alpha", ")", ",", "4", ")", "\n", "\n", "# Make sure the target value is included", "\n", "self", ".", "alpha_grid", "=", "np", ".", "unique", "(", "np", ".", "sort", "(", "np", ".", "concatenate", "(", "(", "self", ".", "alpha_grid", ",", "[", "alpha", "]", ")", ")", ")", ")", "\n", "\n", "# This is only used to predict sets rather than intervals", "\n", "self", ".", "order", "=", "np", ".", "argsort", "(", "-", "pi", ",", "axis", "=", "1", ")", "\n", "self", ".", "ranks", "=", "np", ".", "empty_like", "(", "self", ".", "order", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n", ")", ":", "\n", "            ", "self", ".", "ranks", "[", "i", ",", "self", ".", "order", "[", "i", "]", "]", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "order", "[", "i", "]", ")", ")", "\n", "", "self", ".", "pi_sort", "=", "-", "np", ".", "sort", "(", "-", "pi", ",", "axis", "=", "1", ")", "\n", "self", ".", "Z", "=", "np", ".", "round", "(", "self", ".", "pi_sort", ".", "cumsum", "(", "axis", "=", "1", ")", ",", "9", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.compute_interval_sequence": [[68, 96], ["len", "grey_boxes.HistogramAccumulator.predict_intervals_single", "range", "numpy.ones().astype", "numpy.ones().astype", "grey_boxes.HistogramAccumulator.predict_intervals_single", "range", "grey_boxes.HistogramAccumulator.predict_intervals_single", "numpy.where", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals_single", "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals_single", "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals_single"], ["", "def", "compute_interval_sequence", "(", "self", ",", "epsilon", "=", "None", ")", ":", "\n", "        ", "alpha_grid", "=", "self", ".", "alpha_grid", "\n", "n_grid", "=", "len", "(", "alpha_grid", ")", "\n", "k_star", "=", "np", ".", "where", "(", "alpha_grid", "==", "self", ".", "alpha", ")", "[", "0", "]", "[", "0", "]", "\n", "S_grid", "=", "-", "np", ".", "ones", "(", "(", "n_grid", ",", "self", ".", "n", ",", "2", ")", ")", ".", "astype", "(", "int", ")", "\n", "S_grid_random", "=", "-", "np", ".", "ones", "(", "(", "n_grid", ",", "self", ".", "n", ",", "2", ")", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# First compute optimal set for target alpha", "\n", "S", ",", "S_random", "=", "self", ".", "predict_intervals_single", "(", "alpha_grid", "[", "k_star", "]", ",", "epsilon", "=", "epsilon", ")", "\n", "S_grid", "[", "k_star", "]", "=", "S", "\n", "S_grid_random", "[", "k_star", "]", "=", "S_random", "\n", "\n", "# Compute smaller sets", "\n", "for", "k", "in", "range", "(", "k_star", "+", "1", ",", "n_grid", ")", ":", "\n", "            ", "a", "=", "S_grid", "[", "k", "-", "1", ",", ":", ",", "0", "]", "\n", "b", "=", "S_grid", "[", "k", "-", "1", ",", ":", ",", "1", "]", "\n", "S", ",", "S_random", "=", "self", ".", "predict_intervals_single", "(", "alpha_grid", "[", "k", "]", ",", "epsilon", "=", "epsilon", ",", "a", "=", "a", ",", "b", "=", "b", ")", "\n", "S_grid", "[", "k", "]", "=", "S", "\n", "S_grid_random", "[", "k", "]", "=", "S_random", "\n", "\n", "# Compute larger sets", "\n", "", "for", "k", "in", "range", "(", "0", ",", "k_star", ")", "[", ":", ":", "-", "1", "]", ":", "\n", "            ", "alpha", "=", "alpha_grid", "[", "k", "]", "\n", "S", ",", "S_random", "=", "self", ".", "predict_intervals_single", "(", "alpha", ",", "epsilon", "=", "epsilon", ",", "include", "=", "S_grid_random", "[", "k", "+", "1", "]", ")", "\n", "S_grid", "[", "k", "]", "=", "S", "\n", "S_grid_random", "[", "k", "]", "=", "S_random", "\n", "\n", "", "return", "S_grid_random", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals_single": [[97, 141], ["range", "numpy.concatenate", "copy.deepcopy", "numpy.zeros().astype", "numpy.ones().astype", "numpy.ones().astype", "grey_boxes.smallestSubWithSum", "range", "numpy.sum", "print", "quit", "start.reshape", "end.reshape", "numpy.sum", "numpy.zeros", "numpy.ones", "numpy.ones", "numpy.ones", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.smallestSubWithSum"], ["", "def", "predict_intervals_single", "(", "self", ",", "alpha", ",", "a", "=", "None", ",", "b", "=", "None", ",", "include", "=", "None", ",", "epsilon", "=", "None", ")", ":", "\n", "\n", "        ", "if", "a", "is", "None", ":", "\n", "            ", "a", "=", "np", ".", "zeros", "(", "self", ".", "n", ")", ".", "astype", "(", "int", ")", "\n", "", "if", "b", "is", "None", ":", "\n", "            ", "b", "=", "(", "np", ".", "ones", "(", "self", ".", "n", ")", "*", "len", "(", "self", ".", "pi", "[", "0", "]", ")", ")", ".", "astype", "(", "int", ")", "\n", "\n", "", "if", "include", "is", "None", ":", "\n", "            ", "include", "=", "[", "None", "]", "*", "self", ".", "n", "\n", "\n", "", "start", "=", "-", "np", ".", "ones", "(", "self", ".", "n", ")", ".", "astype", "(", "int", ")", "\n", "end", "=", "-", "np", ".", "ones", "(", "self", ".", "n", ")", ".", "astype", "(", "int", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n", ")", ":", "\n", "            ", "start_offset", "=", "a", "[", "i", "]", "\n", "end_offset", "=", "b", "[", "i", "]", "+", "1", "\n", "if", "np", ".", "sum", "(", "self", ".", "pi", "[", "i", "]", "[", "start_offset", ":", "end_offset", "]", ")", "<", "1.0", "-", "alpha", ":", "\n", "                ", "print", "(", "\"Error: incorrect probability normalization. This may be a bug.\"", ")", "\n", "quit", "(", ")", "\n", "", "start", "[", "i", "]", ",", "end", "[", "i", "]", "=", "smallestSubWithSum", "(", "self", ".", "pi", "[", "i", "]", "[", "start_offset", ":", "end_offset", "]", ",", "1.0", "-", "alpha", ",", "include", "=", "include", "[", "i", "]", ")", "\n", "start", "[", "i", "]", "+=", "start_offset", "\n", "end", "[", "i", "]", "+=", "start_offset", "\n", "", "S", "=", "np", ".", "concatenate", "(", "(", "start", ".", "reshape", "(", "(", "len", "(", "start", ")", ",", "1", ")", ")", ",", "end", ".", "reshape", "(", "(", "len", "(", "start", ")", ",", "1", ")", ")", ")", ",", "1", ")", "\n", "S_random", "=", "copy", ".", "deepcopy", "(", "S", ")", "\n", "\n", "# Randomly remove one bin (either first or last) to seek exact coverage", "\n", "if", "(", "epsilon", "is", "not", "None", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "n", ")", ":", "\n", "                ", "if", "(", "(", "S", "[", "i", ",", "-", "1", "]", "-", "S", "[", "i", ",", "0", "]", ")", "<=", "1", ")", ":", "\n", "                    ", "continue", "\n", "", "tot_weight", "=", "np", ".", "sum", "(", "self", ".", "pi", "[", "i", "]", "[", "S", "[", "i", ",", "0", "]", ":", "(", "S", "[", "i", ",", "-", "1", "]", "+", "1", ")", "]", ")", "\n", "excess_weight", "=", "tot_weight", "-", "(", "1.0", "-", "alpha", ")", "\n", "weight_left", "=", "self", ".", "pi", "[", "i", "]", "[", "S", "[", "i", ",", "0", "]", "]", "\n", "weight_right", "=", "self", ".", "pi", "[", "i", "]", "[", "S", "[", "i", ",", "-", "1", "]", "]", "\n", "# Remove the endpoint with the least weight (more likely to be removed)", "\n", "if", "weight_left", "<", "weight_right", ":", "\n", "                    ", "pi_remove", "=", "excess_weight", "/", "(", "weight_left", "+", "1e-5", ")", "\n", "if", "epsilon", "[", "i", "]", "<=", "pi_remove", ":", "\n", "                        ", "S_random", "[", "i", ",", "0", "]", "+=", "1", "\n", "", "", "else", ":", "\n", "                    ", "pi_remove", "=", "excess_weight", "/", "(", "weight_right", "+", "1e-5", ")", "\n", "if", "epsilon", "[", "i", "]", "<=", "pi_remove", ":", "\n", "                        ", "S_random", "[", "i", ",", "-", "1", "]", "-=", "1", "\n", "\n", "", "", "", "", "return", "S", ",", "S_random", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_intervals": [[142, 157], ["numpy.zeros", "grey_boxes.HistogramAccumulator.compute_interval_sequence", "numpy.where", "len", "numpy.tile", "numpy.max", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.compute_interval_sequence"], ["", "def", "predict_intervals", "(", "self", ",", "alpha", ",", "epsilon", "=", "None", ")", ":", "\n", "# Pre-compute list of predictive intervals", "\n", "        ", "bands", "=", "np", ".", "zeros", "(", "(", "self", ".", "n", ",", "2", ")", ")", "\n", "S_grid", "=", "self", ".", "compute_interval_sequence", "(", "epsilon", "=", "epsilon", ")", "\n", "j_star_idx", "=", "np", ".", "where", "(", "self", ".", "alpha_grid", "<=", "alpha", ")", "[", "0", "]", "\n", "if", "len", "(", "j_star_idx", ")", "==", "0", ":", "\n", "            ", "S", "=", "np", ".", "tile", "(", "np", ".", "arange", "(", "self", ".", "K", ")", ",", "(", "self", ".", "n", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "j_star", "=", "np", ".", "max", "(", "j_star_idx", ")", "\n", "S", "=", "S_grid", "[", "j_star", "]", "\n", "\n", "", "bands", "[", ":", ",", "0", "]", "=", "self", ".", "breaks", "[", "S", "[", ":", ",", "0", "]", "-", "1", "]", "\n", "bands", "[", ":", ",", "1", "]", "=", "self", ".", "breaks", "[", "S", "[", ":", ",", "-", "1", "]", "]", "\n", "\n", "return", "S", ",", "bands", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.calibrate_intervals": [[158, 175], ["numpy.atleast_1d", "len", "numpy.zeros", "grey_boxes.HistogramAccumulator.compute_interval_sequence", "tqdm.autonotebook.tqdm.autonotebook.tqdm", "print", "range", "len", "numpy.where", "len"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.compute_interval_sequence"], ["", "def", "calibrate_intervals", "(", "self", ",", "Y", ",", "epsilon", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "Y", "=", "np", ".", "atleast_1d", "(", "Y", ")", "\n", "n2", "=", "len", "(", "Y", ")", "\n", "alpha_max", "=", "np", ".", "zeros", "(", "n2", ",", ")", "\n", "S_grid", "=", "self", ".", "compute_interval_sequence", "(", "epsilon", "=", "epsilon", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Computing conformity scores.\"", ")", "\n", "", "for", "j", "in", "tqdm", "(", "range", "(", "len", "(", "self", ".", "alpha_grid", ")", ")", ",", "disable", "=", "(", "not", "verbose", ")", ")", ":", "\n", "            ", "alpha", "=", "self", ".", "alpha_grid", "[", "j", "]", "\n", "S", "=", "S_grid", "[", "j", "]", "\n", "band_left", "=", "self", ".", "breaks", "[", "S", "[", ":", ",", "0", "]", "-", "1", "]", "\n", "band_right", "=", "self", ".", "breaks", "[", "S", "[", ":", ",", "-", "1", "]", "]", "\n", "idx_inside", "=", "np", ".", "where", "(", "(", "Y", ">=", "band_left", ")", "*", "(", "Y", "<=", "band_right", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx_inside", ")", ">", "0", ":", "\n", "                ", "alpha_max", "[", "idx_inside", "]", "=", "alpha", "\n", "\n", "", "", "return", "1.0", "-", "alpha_max", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.predict_sets": [[176, 188], ["numpy.argmax().flatten", "numpy.sort", "numpy.argmax", "numpy.array", "numpy.array", "numpy.where", "range", "numpy.arange", "range", "range"], "methods", ["None"], ["", "def", "predict_sets", "(", "self", ",", "alpha", ",", "epsilon", "=", "None", ")", ":", "\n", "        ", "L", "=", "np", ".", "argmax", "(", "self", ".", "Z", ">=", "1.0", "-", "alpha", ",", "axis", "=", "1", ")", ".", "flatten", "(", ")", "\n", "if", "epsilon", "is", "not", "None", ":", "\n", "            ", "Z_excess", "=", "np", ".", "array", "(", "[", "self", ".", "Z", "[", "i", ",", "L", "[", "i", "]", "]", "for", "i", "in", "range", "(", "self", ".", "n", ")", "]", ")", "-", "(", "1.0", "-", "alpha", ")", "\n", "p_remove", "=", "Z_excess", "/", "np", ".", "array", "(", "[", "self", ".", "pi_sort", "[", "i", ",", "L", "[", "i", "]", "]", "for", "i", "in", "range", "(", "self", ".", "n", ")", "]", ")", "\n", "remove", "=", "epsilon", "<=", "p_remove", "\n", "for", "i", "in", "np", ".", "where", "(", "remove", ")", "[", "0", "]", ":", "\n", "                ", "L", "[", "i", "]", "=", "L", "[", "i", "]", "-", "1", "\n", "# Return prediction set", "\n", "", "", "S", "=", "[", "self", ".", "order", "[", "i", ",", "np", ".", "arange", "(", "0", ",", "L", "[", "i", "]", "+", "1", ")", "]", "for", "i", "in", "range", "(", "self", ".", "n", ")", "]", "\n", "S", "=", "[", "np", ".", "sort", "(", "s", ")", "for", "s", "in", "S", "]", "\n", "return", "(", "S", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.HistogramAccumulator.calibrate_sets": [[189, 202], ["numpy.atleast_1d", "len", "numpy.array", "numpy.array", "numpy.array", "numpy.multiply", "numpy.minimum", "range", "range", "range"], "methods", ["None"], ["", "def", "calibrate_sets", "(", "self", ",", "Y", ",", "epsilon", "=", "None", ")", ":", "\n", "        ", "Y", "=", "np", ".", "atleast_1d", "(", "Y", ")", "\n", "n2", "=", "len", "(", "Y", ")", "\n", "ranks", "=", "np", ".", "array", "(", "[", "self", ".", "ranks", "[", "i", ",", "Y", "[", "i", "]", "]", "for", "i", "in", "range", "(", "n2", ")", "]", ")", "\n", "pi_cum", "=", "np", ".", "array", "(", "[", "self", ".", "Z", "[", "i", ",", "ranks", "[", "i", "]", "]", "for", "i", "in", "range", "(", "n2", ")", "]", ")", "\n", "pi", "=", "np", ".", "array", "(", "[", "self", ".", "pi_sort", "[", "i", ",", "ranks", "[", "i", "]", "]", "for", "i", "in", "range", "(", "n2", ")", "]", ")", "\n", "alpha_max", "=", "1.0", "-", "pi_cum", "\n", "if", "epsilon", "is", "not", "None", ":", "\n", "            ", "alpha_max", "+=", "np", ".", "multiply", "(", "pi", ",", "epsilon", ")", "\n", "", "else", ":", "\n", "            ", "alpha_max", "+=", "pi", "\n", "alpha_max", "=", "np", ".", "minimum", "(", "alpha_max", ",", "1", ")", "\n", "", "return", "alpha_max", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.grey_boxes.smallestSubWithSum": [[5, 46], ["len", "numpy.sum", "range", "print", "quit"], "function", ["None"], ["def", "smallestSubWithSum", "(", "arr", ",", "x", ",", "include", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Credit: https://www.geeksforgeeks.org/minimum-length-subarray-sum-greater-given-value/\n    \"\"\"", "\n", "n", "=", "len", "(", "arr", ")", "\n", "\n", "# Initialize weights if not provided", "\n", "if", "include", "is", "None", ":", "\n", "        ", "end_init", "=", "0", "\n", "start_max", "=", "n", "\n", "", "else", ":", "\n", "        ", "end_init", "=", "include", "[", "1", "]", "\n", "start_max", "=", "include", "[", "0", "]", "\n", "\n", "# Initialize optimal solution", "\n", "", "start_best", "=", "0", "\n", "end_best", "=", "n", "\n", "min_len", "=", "n", "+", "1", "\n", "\n", "# Initialize starting index", "\n", "start", "=", "0", "\n", "\n", "# Initialize current sum", "\n", "curr_sum", "=", "np", ".", "sum", "(", "arr", "[", "start", ":", "end_init", "]", ")", "\n", "\n", "for", "end", "in", "range", "(", "end_init", ",", "n", ")", ":", "\n", "        ", "curr_sum", "+=", "arr", "[", "end", "]", "\n", "while", "(", "curr_sum", ">=", "x", ")", "and", "(", "start", "<=", "end", ")", "and", "(", "start", "<=", "start_max", ")", ":", "\n", "            ", "if", "(", "end", "-", "start", "+", "1", "<", "min_len", ")", ":", "\n", "                ", "min_len", "=", "end", "-", "start", "+", "1", "\n", "start_best", "=", "start", "\n", "end_best", "=", "end", "\n", "\n", "", "curr_sum", "-=", "arr", "[", "start", "]", "\n", "start", "+=", "1", "\n", "\n", "", "", "if", "end_best", "==", "n", ":", "\n", "        ", "print", "(", "\"Error in smallestSubWithSum(): no solution! This may be a bug.\"", ")", "\n", "quit", "(", ")", "\n", "\n", "", "return", "start_best", ",", "end_best", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.histogram.Histogram.__init__": [[82, 85], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "percentiles", ",", "breaks", ")", ":", "\n", "        ", "self", ".", "percentiles", "=", "percentiles", "\n", "self", ".", "breaks", "=", "breaks", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.histogram.Histogram.compute_histogram": [[86, 108], ["numpy.zeros", "numpy.concatenate", "numpy.pad", "range", "len", "scipy.interpolate.interp1d", "histogram._estim_dist", "cdf", "numpy.concatenate", "numpy.sum", "numpy.diff"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist"], ["", "def", "compute_histogram", "(", "self", ",", "quantiles", ",", "ymin", ",", "ymax", ",", "alpha", ",", "smooth_tails", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Compute pi_hat[j]: the mass between break[j-1] and break[j]\n        \"\"\"", "\n", "n", "=", "quantiles", ".", "shape", "[", "0", "]", "\n", "B", "=", "len", "(", "self", ".", "breaks", ")", "-", "1", "\n", "\n", "pi_hat", "=", "np", ".", "zeros", "(", "(", "n", ",", "B", "+", "1", ")", ")", "\n", "percentiles", "=", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "self", ".", "percentiles", ",", "[", "1", "]", ")", ")", "\n", "quantiles", "=", "np", ".", "pad", "(", "quantiles", ",", "(", "(", "0", ",", "0", ")", ",", "(", "1", ",", "1", ")", ")", ",", "'constant'", ",", "constant_values", "=", "(", "ymin", ",", "ymax", ")", ")", "\n", "\n", "def", "interp1d", "(", "x", ",", "y", ",", "a", ",", "b", ")", ":", "\n", "            ", "return", "interpolate", ".", "interp1d", "(", "x", ",", "y", ",", "bounds_error", "=", "False", ",", "fill_value", "=", "(", "a", ",", "b", ")", ",", "assume_sorted", "=", "True", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "cdf", ",", "inv_cdf", "=", "_estim_dist", "(", "quantiles", "[", "i", "]", ",", "percentiles", ",", "y_min", "=", "ymin", ",", "y_max", "=", "ymax", ",", "\n", "smooth_tails", "=", "smooth_tails", ",", "tau", "=", "0.01", ")", "\n", "cdf_hat", "=", "cdf", "(", "self", ".", "breaks", ")", "\n", "pi_hat", "[", "i", "]", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "np", ".", "diff", "(", "cdf_hat", ")", "]", ")", "\n", "pi_hat", "[", "i", "]", "=", "(", "pi_hat", "[", "i", "]", "+", "1e-6", ")", "/", "(", "np", ".", "sum", "(", "pi_hat", "[", "i", "]", "+", "1e-6", ")", ")", "\n", "\n", "", "return", "pi_hat", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist_old": [[5, 37], ["numpy.random.uniform", "numpy.sort", "histogram._estim_dist_old.interp1d"], "function", ["None"], ["def", "_estim_dist_old", "(", "quantiles", ",", "percentiles", ",", "y_min", ",", "y_max", ",", "smooth_tails", ",", "tau", ")", ":", "\n", "    ", "\"\"\" Estimate CDF from list of quantiles, with smoothing \"\"\"", "\n", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1e-8", ",", "size", "=", "(", "(", "len", "(", "quantiles", ")", ",", ")", ")", ")", "\n", "noise_monotone", "=", "np", ".", "sort", "(", "noise", ")", "\n", "quantiles", "=", "quantiles", "+", "noise_monotone", "\n", "\n", "# Smooth tails", "\n", "def", "interp1d", "(", "x", ",", "y", ",", "a", ",", "b", ")", ":", "\n", "        ", "return", "interpolate", ".", "interp1d", "(", "x", ",", "y", ",", "bounds_error", "=", "False", ",", "fill_value", "=", "(", "a", ",", "b", ")", ",", "assume_sorted", "=", "True", ")", "\n", "\n", "", "cdf", "=", "interp1d", "(", "quantiles", ",", "percentiles", ",", "0.0", ",", "1.0", ")", "\n", "inv_cdf", "=", "interp1d", "(", "percentiles", ",", "quantiles", ",", "y_min", ",", "y_max", ")", "\n", "\n", "if", "smooth_tails", ":", "\n", "# Uniform smoothing of tails", "\n", "        ", "quantiles_smooth", "=", "quantiles", "\n", "tau_lo", "=", "tau", "\n", "tau_hi", "=", "1", "-", "tau", "\n", "q_lo", "=", "inv_cdf", "(", "tau_lo", ")", "\n", "q_hi", "=", "inv_cdf", "(", "tau_hi", ")", "\n", "idx_lo", "=", "np", ".", "where", "(", "percentiles", "<", "tau_lo", ")", "[", "0", "]", "\n", "idx_hi", "=", "np", ".", "where", "(", "percentiles", ">", "tau_hi", ")", "[", "0", "]", "\n", "if", "len", "(", "idx_lo", ")", ">", "0", ":", "\n", "            ", "quantiles_smooth", "[", "idx_lo", "]", "=", "np", ".", "linspace", "(", "quantiles", "[", "0", "]", ",", "q_lo", ",", "num", "=", "len", "(", "idx_lo", ")", ")", "\n", "", "if", "len", "(", "idx_hi", ")", ">", "0", ":", "\n", "            ", "quantiles_smooth", "[", "idx_hi", "]", "=", "np", ".", "linspace", "(", "q_hi", ",", "quantiles", "[", "-", "1", "]", ",", "num", "=", "len", "(", "idx_hi", ")", ")", "\n", "\n", "", "cdf", "=", "interp1d", "(", "quantiles_smooth", ",", "percentiles", ",", "0.0", ",", "1.0", ")", "\n", "inv_cdf", "=", "interp1d", "(", "percentiles", ",", "quantiles_smooth", ",", "y_min", ",", "y_max", ")", "\n", "\n", "", "return", "cdf", ",", "inv_cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.histogram._estim_dist": [[38, 79], ["numpy.random.uniform", "numpy.sort", "histogram._estim_dist_old.interp1d"], "function", ["None"], ["", "def", "_estim_dist", "(", "quantiles", ",", "percentiles", ",", "y_min", ",", "y_max", ",", "smooth_tails", ",", "tau", ")", ":", "\n", "    ", "\"\"\" Estimate CDF from list of quantiles, with smoothing \"\"\"", "\n", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "high", "=", "1e-5", ",", "size", "=", "(", "(", "len", "(", "quantiles", ")", ",", ")", ")", ")", "\n", "noise_monotone", "=", "np", ".", "sort", "(", "noise", ")", "\n", "quantiles", "=", "quantiles", "+", "noise_monotone", "\n", "\n", "# Smooth tails", "\n", "def", "interp1d", "(", "x", ",", "y", ",", "a", ",", "b", ")", ":", "\n", "        ", "return", "interpolate", ".", "interp1d", "(", "x", ",", "y", ",", "bounds_error", "=", "False", ",", "fill_value", "=", "(", "a", ",", "b", ")", ",", "assume_sorted", "=", "True", ")", "\n", "\n", "", "cdf", "=", "interp1d", "(", "quantiles", ",", "percentiles", ",", "0.0", ",", "1.0", ")", "\n", "inv_cdf", "=", "interp1d", "(", "percentiles", ",", "quantiles", ",", "y_min", ",", "y_max", ")", "\n", "\n", "if", "smooth_tails", ":", "\n", "# Uniform smoothing of tails", "\n", "        ", "quantiles_smooth", "=", "quantiles", "\n", "tau_lo", "=", "tau", "\n", "tau_hi", "=", "1", "-", "tau", "\n", "q_lo", "=", "inv_cdf", "(", "tau_lo", ")", "\n", "q_hi", "=", "inv_cdf", "(", "tau_hi", ")", "\n", "idx_lo", "=", "np", ".", "where", "(", "percentiles", "<", "tau_lo", ")", "[", "0", "]", "\n", "idx_hi", "=", "np", ".", "where", "(", "percentiles", ">", "tau_hi", ")", "[", "0", "]", "\n", "if", "len", "(", "idx_lo", ")", ">", "0", ":", "\n", "            ", "quantiles_smooth", "[", "idx_lo", "]", "=", "np", ".", "linspace", "(", "quantiles", "[", "0", "]", ",", "q_lo", ",", "num", "=", "len", "(", "idx_lo", ")", ")", "\n", "", "if", "len", "(", "idx_hi", ")", ">", "0", ":", "\n", "            ", "quantiles_smooth", "[", "idx_hi", "]", "=", "np", ".", "linspace", "(", "q_hi", ",", "quantiles", "[", "-", "1", "]", ",", "num", "=", "len", "(", "idx_hi", ")", ")", "\n", "\n", "", "cdf", "=", "interp1d", "(", "quantiles_smooth", ",", "percentiles", ",", "0.0", ",", "1.0", ")", "\n", "inv_cdf", "=", "interp1d", "(", "percentiles", ",", "quantiles_smooth", ",", "y_min", ",", "y_max", ")", "\n", "\n", "# Standardize", "\n", "", "breaks", "=", "np", ".", "linspace", "(", "y_min", ",", "y_max", ",", "num", "=", "1000", ",", "endpoint", "=", "True", ")", "\n", "cdf_hat", "=", "cdf", "(", "breaks", ")", "\n", "f_hat", "=", "np", ".", "diff", "(", "cdf_hat", ")", "\n", "f_hat", "=", "(", "f_hat", "+", "1e-6", ")", "/", "(", "np", ".", "sum", "(", "f_hat", "+", "1e-6", ")", ")", "\n", "cdf_hat", "=", "np", ".", "concatenate", "(", "[", "[", "0", "]", ",", "np", ".", "cumsum", "(", "f_hat", ")", "]", ")", "\n", "cdf", "=", "interp1d", "(", "breaks", ",", "cdf_hat", ",", "0.0", ",", "1.0", ")", "\n", "inv_cdf", "=", "interp1d", "(", "cdf_hat", ",", "breaks", ",", "y_min", ",", "y_max", ")", "\n", "\n", "return", "cdf", ",", "inv_cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others_r.DistSplit.__init__": [[25, 29], ["others_r.DistSplit.r.library", "others_r.DistSplit.r.library"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "r", "=", "ro", ".", "r", "\n", "self", ".", "r", ".", "library", "(", "'FlexCoDE'", ")", "\n", "self", ".", "r", ".", "library", "(", "'predictionBands'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others_r.DistSplit.fit_calibrate": [[30, 33], ["None"], "methods", ["None"], ["", "def", "fit_calibrate", "(", "self", ",", "X", ",", "Y", ",", "alpha", ",", "bbox", "=", "None", ",", "random_state", "=", "2020", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "fit", "=", "self", ".", "r", "[", "'fit_predictionBands'", "]", "(", "X", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.others_r.DistSplit.predict": [[34, 45], ["numpy.array", "numpy.zeros", "range", "[].replace().replace().replace().split", "float", "float", "[].replace().replace().replace", "[].replace().replace", "[].replace"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "pred_r", "=", "np", ".", "array", "(", "self", ".", "r", "[", "'predict'", "]", "(", "self", ".", "fit", ",", "X", ",", "type", "=", "\"dist\"", ",", "**", "{", "'alpha'", ":", "self", ".", "alpha", "}", ")", ")", "\n", "pred", "=", "np", ".", "zeros", "(", "(", "n", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "pred_str", "=", "pred_r", "[", "4", "]", "[", "i", "]", "[", "0", "]", ".", "replace", "(", "','", ",", "' '", ")", ".", "replace", "(", "'('", ",", "''", ")", ".", "replace", "(", "')'", ",", "''", ")", ".", "split", "(", ")", "\n", "pred", "[", "i", ",", "0", "]", "=", "float", "(", "pred_str", "[", "0", "]", ")", "\n", "pred", "[", "i", ",", "1", "]", "=", "float", "(", "pred_str", "[", "1", "]", ")", "\n", "\n", "", "return", "pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.coverage.wsc": [[5, 56], ["numpy.min", "numpy.max", "coverage.wsc.sample_sphere"], "function", ["None"], ["def", "wsc", "(", "X", ",", "y", ",", "pred", ",", "delta", "=", "0.1", ",", "M", "=", "1000", ",", "verbose", "=", "False", ")", ":", "\n", "# Extract lower and upper prediction bands", "\n", "    ", "pred_l", "=", "np", ".", "min", "(", "pred", ",", "1", ")", "\n", "pred_h", "=", "np", ".", "max", "(", "pred", ",", "1", ")", "\n", "\n", "def", "wsc_v", "(", "X", ",", "y", ",", "pred_l", ",", "pred_h", ",", "delta", ",", "v", ")", ":", "\n", "        ", "n", "=", "len", "(", "y", ")", "\n", "cover", "=", "(", "y", ">=", "pred_l", ")", "*", "(", "y", "<=", "pred_h", ")", "\n", "z", "=", "np", ".", "dot", "(", "X", ",", "v", ")", "\n", "# Compute mass", "\n", "z_order", "=", "np", ".", "argsort", "(", "z", ")", "\n", "z_sorted", "=", "z", "[", "z_order", "]", "\n", "cover_ordered", "=", "cover", "[", "z_order", "]", "\n", "ai_max", "=", "int", "(", "np", ".", "round", "(", "(", "1.0", "-", "delta", ")", "*", "n", ")", ")", "\n", "ai_best", "=", "0", "\n", "bi_best", "=", "n", "-", "1", "\n", "cover_min", "=", "np", ".", "mean", "(", "(", "y", ">=", "pred_l", ")", "*", "(", "y", "<=", "pred_h", ")", ")", "\n", "for", "ai", "in", "np", ".", "arange", "(", "0", ",", "ai_max", ")", ":", "\n", "            ", "bi_min", "=", "np", ".", "minimum", "(", "ai", "+", "int", "(", "np", ".", "round", "(", "delta", "*", "n", ")", ")", ",", "n", ")", "\n", "coverage", "=", "np", ".", "cumsum", "(", "cover_ordered", "[", "ai", ":", "n", "]", ")", "/", "np", ".", "arange", "(", "1", ",", "n", "-", "ai", "+", "1", ")", "\n", "coverage", "[", "np", ".", "arange", "(", "0", ",", "bi_min", "-", "ai", ")", "]", "=", "1", "\n", "bi_star", "=", "ai", "+", "np", ".", "argmin", "(", "coverage", ")", "\n", "cover_star", "=", "coverage", "[", "bi_star", "-", "ai", "]", "\n", "if", "cover_star", "<", "cover_min", ":", "\n", "                ", "ai_best", "=", "ai", "\n", "bi_best", "=", "bi_star", "\n", "cover_min", "=", "cover_star", "\n", "", "", "return", "cover_min", ",", "z_sorted", "[", "ai_best", "]", ",", "z_sorted", "[", "bi_best", "]", "\n", "\n", "", "def", "sample_sphere", "(", "n", ",", "p", ")", ":", "\n", "        ", "v", "=", "np", ".", "random", ".", "randn", "(", "p", ",", "n", ")", "\n", "v", "/=", "np", ".", "linalg", ".", "norm", "(", "v", ",", "axis", "=", "0", ")", "\n", "return", "v", ".", "T", "\n", "\n", "", "V", "=", "sample_sphere", "(", "M", ",", "p", "=", "X", ".", "shape", "[", "1", "]", ")", "\n", "wsc_list", "=", "[", "[", "]", "]", "*", "M", "\n", "a_list", "=", "[", "[", "]", "]", "*", "M", "\n", "b_list", "=", "[", "[", "]", "]", "*", "M", "\n", "if", "verbose", ":", "\n", "        ", "for", "m", "in", "tqdm", "(", "range", "(", "M", ")", ")", ":", "\n", "            ", "wsc_list", "[", "m", "]", ",", "a_list", "[", "m", "]", ",", "b_list", "[", "m", "]", "=", "wsc_v", "(", "X", ",", "y", ",", "pred_l", ",", "pred_h", ",", "delta", ",", "V", "[", "m", "]", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "m", "in", "range", "(", "M", ")", ":", "\n", "            ", "wsc_list", "[", "m", "]", ",", "a_list", "[", "m", "]", ",", "b_list", "[", "m", "]", "=", "wsc_v", "(", "X", ",", "y", ",", "pred_l", ",", "pred_h", ",", "delta", ",", "V", "[", "m", "]", ")", "\n", "\n", "", "", "idx_star", "=", "np", ".", "argmin", "(", "np", ".", "array", "(", "wsc_list", ")", ")", "\n", "a_star", "=", "a_list", "[", "idx_star", "]", "\n", "b_star", "=", "b_list", "[", "idx_star", "]", "\n", "v_star", "=", "V", "[", "idx_star", "]", "\n", "wsc_star", "=", "wsc_list", "[", "idx_star", "]", "\n", "return", "wsc_star", ",", "v_star", ",", "a_star", ",", "b_star", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.coverage.wsc_unbiased": [[57, 76], ["sklearn.model_selection.train_test_split", "coverage.wsc", "coverage.wsc_unbiased.wsc_vab"], "function", ["home.repos.pwc.inspect_result.msesia_chr.chr.coverage.wsc"], ["", "def", "wsc_unbiased", "(", "X", ",", "y", ",", "pred", ",", "delta", "=", "0.1", ",", "M", "=", "1000", ",", "test_size", "=", "0.75", ",", "random_state", "=", "2020", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "def", "wsc_vab", "(", "X", ",", "y", ",", "pred", ",", "v", ",", "a", ",", "b", ")", ":", "\n", "# Extract lower and upper prediction bands", "\n", "        ", "pred_l", "=", "np", ".", "min", "(", "pred", ",", "1", ")", "\n", "pred_h", "=", "np", ".", "max", "(", "pred", ",", "1", ")", "\n", "n", "=", "len", "(", "y", ")", "\n", "cover", "=", "(", "y", ">=", "pred_l", ")", "*", "(", "y", "<=", "pred_h", ")", "\n", "z", "=", "np", ".", "dot", "(", "X", ",", "v", ")", "\n", "idx", "=", "np", ".", "where", "(", "(", "z", ">=", "a", ")", "*", "(", "z", "<=", "b", ")", ")", "\n", "coverage", "=", "np", ".", "mean", "(", "cover", "[", "idx", "]", ")", "\n", "return", "coverage", "\n", "\n", "", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", ",", "pred_train", ",", "pred_test", "=", "train_test_split", "(", "X", ",", "y", ",", "pred", ",", "test_size", "=", "test_size", ",", "\n", "random_state", "=", "random_state", ")", "\n", "# Find adversarial parameters", "\n", "wsc_star", ",", "v_star", ",", "a_star", ",", "b_star", "=", "wsc", "(", "X_train", ",", "y_train", ",", "pred_train", ",", "delta", "=", "delta", ",", "M", "=", "M", ",", "verbose", "=", "verbose", ")", "\n", "# Estimate coverage", "\n", "coverage", "=", "wsc_vab", "(", "X_test", ",", "y_test", ",", "pred_test", ",", "v_star", ",", "a_star", ",", "b_star", ")", "\n", "return", "coverage", "", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.utils.RegressionDataset.__init__": [[14, 17], ["torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "X_data", ",", "y_data", ")", ":", "\n", "        ", "self", ".", "X_data", "=", "torch", ".", "from_numpy", "(", "X_data", ")", ".", "float", "(", ")", "\n", "self", ".", "y_data", "=", "torch", ".", "from_numpy", "(", "y_data", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.utils.RegressionDataset.__getitem__": [[18, 20], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "X_data", "[", "index", "]", ",", "self", ".", "y_data", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.utils.RegressionDataset.__len__": [[21, 23], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "X_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.utils.evaluate_predictions": [[24, 48], ["numpy.min", "numpy.max", "numpy.mean", "numpy.mean", "numpy.mean", "pandas.DataFrame", "chr.coverage.wsc_unbiased", "numpy.where"], "function", ["home.repos.pwc.inspect_result.msesia_chr.chr.coverage.wsc_unbiased"], ["", "", "def", "evaluate_predictions", "(", "pred", ",", "Y", ",", "X", "=", "None", ")", ":", "\n", "# Extract lower and upper prediction bands", "\n", "    ", "pred_l", "=", "np", ".", "min", "(", "pred", ",", "1", ")", "\n", "pred_h", "=", "np", ".", "max", "(", "pred", ",", "1", ")", "\n", "# Marginal coverage", "\n", "cover", "=", "(", "Y", ">=", "pred_l", ")", "*", "(", "Y", "<=", "pred_h", ")", "\n", "marg_coverage", "=", "np", ".", "mean", "(", "cover", ")", "\n", "if", "X", "is", "None", ":", "\n", "        ", "wsc_coverage", "=", "None", "\n", "", "else", ":", "\n", "# Estimated conditional coverage (worse-case slab)", "\n", "        ", "wsc_coverage", "=", "coverage", ".", "wsc_unbiased", "(", "X", ",", "Y", ",", "pred", ",", "M", "=", "100", ")", "\n", "\n", "# Marginal length", "\n", "", "lengths", "=", "pred_h", "-", "pred_l", "\n", "length", "=", "np", ".", "mean", "(", "lengths", ")", "\n", "# Length conditional on coverage", "\n", "idx_cover", "=", "np", ".", "where", "(", "cover", ")", "[", "0", "]", "\n", "length_cover", "=", "np", ".", "mean", "(", "[", "lengths", "for", "i", "in", "idx_cover", "]", ")", "\n", "\n", "# Combine results", "\n", "out", "=", "pd", ".", "DataFrame", "(", "{", "'Coverage'", ":", "[", "marg_coverage", "]", ",", "'Conditional coverage'", ":", "[", "wsc_coverage", "]", ",", "\n", "'Length'", ":", "[", "length", "]", ",", "'Length cover'", ":", "[", "length_cover", "]", "}", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.utils.plot_histogram": [[49, 81], ["matplotlib.step", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.show", "matplotlib.figure", "numpy.zeros", "matplotlib.fill_between", "range", "matplotlib.xlim", "plt.figure.set_size_inches", "matplotlib.savefig", "len", "len", "matplotlib.axvline", "len", "len"], "function", ["None"], ["", "def", "plot_histogram", "(", "breaks", ",", "weights", ",", "S", "=", "None", ",", "fig", "=", "None", ",", "limits", "=", "None", ",", "i", "=", "0", ",", "colors", "=", "None", ",", "linestyles", "=", "None", ",", "xlim", "=", "None", ",", "filename", "=", "None", ")", ":", "\n", "    ", "if", "colors", "is", "None", ":", "\n", "        ", "if", "limits", "is", "not", "None", ":", "\n", "            ", "colors", "=", "[", "'tab:blue'", "]", "*", "len", "(", "limits", ")", "\n", "", "", "if", "linestyles", "is", "None", ":", "\n", "        ", "if", "limits", "is", "not", "None", ":", "\n", "            ", "linestyles", "=", "[", "'-'", "]", "*", "len", "(", "limits", ")", "\n", "\n", "", "", "if", "fig", "is", "None", ":", "\n", "        ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "", "plt", ".", "step", "(", "breaks", ",", "weights", "[", "i", "]", ",", "where", "=", "'pre'", ",", "color", "=", "'black'", ")", "\n", "if", "S", "is", "not", "None", ":", "\n", "        ", "idx", "=", "S", "[", "i", "]", "\n", "z", "=", "np", ".", "zeros", "(", "len", "(", "breaks", ")", ",", ")", "\n", "z", "[", "idx", "]", "=", "weights", "[", "i", ",", "idx", "]", "\n", "plt", ".", "fill_between", "(", "breaks", ",", "z", ",", "step", "=", "\"pre\"", ",", "alpha", "=", "0.4", ",", "color", "=", "'gray'", ")", "\n", "", "if", "limits", "is", "not", "None", ":", "\n", "        ", "for", "q_idx", "in", "range", "(", "len", "(", "limits", "[", "i", "]", ")", ")", ":", "\n", "            ", "q", "=", "limits", "[", "i", "]", "[", "q_idx", "]", "\n", "plt", ".", "axvline", "(", "q", ",", "0", ",", "1", ",", "linestyle", "=", "linestyles", "[", "q_idx", "]", ",", "color", "=", "colors", "[", "q_idx", "]", ")", "\n", "\n", "", "", "plt", ".", "xlabel", "(", "'$Y$'", ")", "\n", "plt", ".", "ylabel", "(", "'Density'", ")", "\n", "\n", "if", "xlim", "is", "not", "None", ":", "\n", "        ", "plt", ".", "xlim", "(", "xlim", ")", "\n", "\n", "", "if", "filename", "is", "not", "None", ":", "\n", "        ", "fig", ".", "set_size_inches", "(", "4.5", ",", "3", ")", "\n", "plt", ".", "savefig", "(", "filename", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "300", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.NNet.__init__": [[26, 53], ["torch.Module.__init__", "len", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "black_boxes.NNet.init_weights", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.__init__", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.NNet.init_weights"], ["def", "__init__", "(", "self", ",", "quantiles", ",", "num_features", ",", "num_hidden", "=", "64", ",", "dropout", "=", "0.1", ",", "no_crossing", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialization\n        Parameters\n        ----------\n        quantiles : numpy array of quantile levels (q), each in the range (0,1)\n        num_features : integer, input signal dimension (p)\n        num_hidden : integer, hidden layer dimension\n        dropout : float, dropout rate\n        no_crossing: boolean, whether to explicitly prevent quantile crossovers\n        \"\"\"", "\n", "super", "(", "NNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "no_crossing", "=", "no_crossing", "\n", "\n", "self", ".", "num_quantiles", "=", "len", "(", "quantiles", ")", "\n", "\n", "# Construct base network", "\n", "self", ".", "base_model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "num_features", ",", "num_hidden", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "dropout", ")", ",", "\n", "nn", ".", "Linear", "(", "num_hidden", ",", "num_hidden", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Dropout", "(", "dropout", ")", ",", "\n", "nn", ".", "Linear", "(", "num_hidden", ",", "self", ".", "num_quantiles", ")", ",", "\n", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.NNet.init_weights": [[54, 61], ["isinstance", "torch.init.orthogonal_", "torch.init.orthogonal_", "torch.init.orthogonal_", "torch.init.orthogonal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\" Initialize the network parameters\n        \"\"\"", "\n", "for", "m", "in", "self", ".", "base_model", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "orthogonal_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.NNet.forward": [[62, 71], ["black_boxes.NNet.base_model", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Run forward pass\n        \"\"\"", "\n", "x", "=", "self", ".", "base_model", "(", "x", ")", "\n", "if", "self", ".", "no_crossing", ":", "\n", "            ", "y", ",", "_", "=", "torch", ".", "sort", "(", "x", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "x", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.AllQuantileLoss.__init__": [[76, 84], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.__init__"], ["def", "__init__", "(", "self", ",", "quantiles", ")", ":", "\n", "        ", "\"\"\" Initialize\n        Parameters\n        ----------\n        quantiles : pytorch vector of quantile levels, each in the range (0,1)\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "quantiles", "=", "quantiles", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.AllQuantileLoss.forward": [[85, 103], ["black_boxes.AllQuantileLoss.quantiles.unsqueeze", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "torch.max().mean", "target.unsqueeze", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "preds", ",", "target", ")", ":", "\n", "        ", "\"\"\" Compute the pinball loss\n        Parameters\n        ----------\n        preds : pytorch tensor of estimated labels (n)\n        target : pytorch tensor of true labels (n)\n        Returns\n        -------\n        loss : cost function value\n        \"\"\"", "\n", "#assert not target.requires_grad", "\n", "#assert preds.size(0) == target.size(0)", "\n", "\n", "errors", "=", "target", ".", "unsqueeze", "(", "1", ")", "-", "preds", "\n", "Q", "=", "self", ".", "quantiles", ".", "unsqueeze", "(", "0", ")", "\n", "loss", "=", "torch", ".", "max", "(", "(", "Q", "-", "1.0", ")", "*", "errors", ",", "Q", "*", "errors", ")", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet.__init__": [[108, 152], ["torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "torch.device", "numpy.sort", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "black_boxes.NNet", "black_boxes.QNet.model.to", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "black_boxes.AllQuantileLoss", "int", "black_boxes.QNet.model.parameters", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "quantiles", ",", "num_features", ",", "no_crossing", "=", "False", ",", "dropout", "=", "0.2", ",", "learning_rate", "=", "0.001", ",", "\n", "num_epochs", "=", "100", ",", "batch_size", "=", "16", ",", "num_hidden", "=", "64", ",", "random_state", "=", "0", ",", "calibrate", "=", "0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialization\n        Parameters\n        ----------\n        quantiles : numpy array of quantile levels (q), each in the range (0,1)\n        num_features : integer, input signal dimension (p)\n        learning_rate : learning rate\n        random_state : integer, seed used in CV when splitting to train-test\n        \"\"\"", "\n", "\n", "# Detect whether CUDA is available", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "\n", "# Store input (sort the quantiles)", "\n", "quantiles", "=", "np", ".", "sort", "(", "quantiles", ")", "\n", "self", ".", "quantiles", "=", "torch", ".", "from_numpy", "(", "quantiles", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "\n", "# Define NNet model", "\n", "self", ".", "model", "=", "NNet", "(", "self", ".", "quantiles", ",", "self", ".", "num_features", ",", "num_hidden", "=", "num_hidden", ",", "dropout", "=", "dropout", ",", "no_crossing", "=", "no_crossing", ")", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# Initialize optimizer", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "learning_rate", ")", "\n", "\n", "# Initialize loss function", "\n", "self", ".", "loss_func", "=", "AllQuantileLoss", "(", "self", ".", "quantiles", ")", "\n", "\n", "# Store variables", "\n", "self", ".", "num_epochs", "=", "num_epochs", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "calibrate", "=", "int", "(", "calibrate", ")", "\n", "\n", "# Initialize training logs", "\n", "self", ".", "loss_history", "=", "[", "]", "\n", "self", ".", "test_loss_history", "=", "[", "]", "\n", "self", ".", "full_loss_history", "=", "[", "]", "\n", "\n", "# Validation", "\n", "self", ".", "val_period", "=", "10", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet.fit": [[153, 186], ["Y.flatten().astype.flatten().astype.flatten().astype", "X.astype.astype.astype", "chr.utils.RegressionDataset", "black_boxes.QNet._fit", "int", "range", "numpy.median().flatten", "Y.flatten().astype.flatten().astype.flatten", "numpy.round", "sklearn.model_selection.train_test_split", "chr.utils.RegressionDataset", "chr.utils.RegressionDataset", "black_boxes.QNet._fit", "numpy.median().flatten.append", "black_boxes.QNet.model.init_weights", "numpy.matrix", "numpy.concatenate", "numpy.median", "numpy.argmin"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet._fit", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet._fit", "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.NNet.init_weights"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "return_loss", "=", "False", ")", ":", "\n", "        ", "Y", "=", "Y", ".", "flatten", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "X", "=", "X", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "dataset", "=", "RegressionDataset", "(", "X", ",", "Y", ")", "\n", "num_epochs", "=", "self", ".", "num_epochs", "\n", "if", "self", ".", "calibrate", ">", "0", ":", "\n", "# Train with 80% of samples", "\n", "            ", "n_valid", "=", "int", "(", "np", ".", "round", "(", "0.2", "*", "X", ".", "shape", "[", "0", "]", ")", ")", "\n", "loss_stats", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "self", ".", "calibrate", ")", ":", "\n", "                ", "X_train", ",", "X_valid", ",", "Y_train", ",", "Y_valid", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "n_valid", ",", "random_state", "=", "self", ".", "random_state", "+", "b", ")", "\n", "train_dataset", "=", "RegressionDataset", "(", "X_train", ",", "Y_train", ")", "\n", "val_dataset", "=", "RegressionDataset", "(", "X_valid", ",", "Y_valid", ")", "\n", "loss_stats_tmp", "=", "self", ".", "_fit", "(", "train_dataset", ",", "num_epochs", ",", "val_dataset", "=", "val_dataset", ")", "\n", "loss_stats", ".", "append", "(", "[", "loss_stats_tmp", "[", "'val'", "]", "]", ")", "\n", "# Reset model", "\n", "self", ".", "model", ".", "init_weights", "(", ")", "\n", "\n", "", "loss_stats", "=", "np", ".", "matrix", "(", "np", ".", "concatenate", "(", "loss_stats", ",", "0", ")", ")", ".", "T", "\n", "\n", "loss_stats", "=", "np", ".", "median", "(", "loss_stats", ",", "1", ")", ".", "flatten", "(", ")", "\n", "# Find optimal number of epochs", "\n", "num_epochs", "=", "self", ".", "val_period", "*", "(", "np", ".", "argmin", "(", "loss_stats", ")", "+", "1", ")", "\n", "loss_stats_cal", "=", "loss_stats", "\n", "\n", "# Train with all samples", "\n", "", "loss_stats", "=", "self", ".", "_fit", "(", "dataset", ",", "num_epochs", ")", "\n", "if", "self", ".", "calibrate", ":", "\n", "            ", "loss_stats", "=", "loss_stats_cal", "\n", "\n", "", "if", "return_loss", ":", "\n", "          ", "return", "loss_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet._fit": [[187, 266], ["torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "train_dataset.X_data.to", "train_dataset.y_data.to", "tqdm.autonotebook.tqdm.autonotebook.tqdm", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "range", "black_boxes.QNet.model.train", "black_boxes.QNet.optimizer.zero_grad", "black_boxes.QNet.model().to", "black_boxes.QNet.loss_func", "black_boxes.QNet.backward", "black_boxes.QNet.optimizer.step", "black_boxes.QNet.item", "loss_stats[].append", "loss_stats[].append", "black_boxes.QNet.optimizer.zero_grad", "black_boxes.QNet.model().to", "black_boxes.QNet.loss_func", "black_boxes.QNet.backward", "black_boxes.QNet.optimizer.step", "black_boxes.QNet.item", "black_boxes.QNet.model.eval", "loss_stats[].append", "black_boxes.QNet.model.train", "print", "print", "print", "train_dataset.X_data.to.to", "train_dataset.y_data.to.to", "black_boxes.QNet.model", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "len", "black_boxes.QNet.model", "black_boxes.QNet.model().to", "black_boxes.QNet.loss_func", "black_boxes.QNet.item", "len", "X_val_batch.to", "y_val_batch.to", "black_boxes.QNet.model", "len", "len", "len"], "methods", ["None"], ["", "", "def", "_fit", "(", "self", ",", "train_dataset", ",", "num_epochs", ",", "val_dataset", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "self", ".", "batch_size", "\n", "\n", "# Initialize data loaders", "\n", "train_loader", "=", "DataLoader", "(", "dataset", "=", "train_dataset", ",", "batch_size", "=", "batch_size", ")", "\n", "if", "val_dataset", "is", "not", "None", ":", "\n", "            ", "val_loader", "=", "DataLoader", "(", "dataset", "=", "val_dataset", ",", "batch_size", "=", "1", ")", "\n", "\n", "", "num_samples", ",", "num_features", "=", "train_dataset", ".", "X_data", ".", "shape", "\n", "print", "(", "\"Training with {} samples and {} features.\"", ".", "format", "(", "num_samples", ",", "num_features", ")", ")", "\n", "\n", "loss_stats", "=", "{", "'train'", ":", "[", "]", ",", "\"val\"", ":", "[", "]", "}", "\n", "\n", "X_train_batch", "=", "train_dataset", ".", "X_data", ".", "to", "(", "self", ".", "device", ")", "\n", "y_train_batch", "=", "train_dataset", ".", "y_data", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "for", "e", "in", "tqdm", "(", "range", "(", "1", ",", "num_epochs", "+", "1", ")", ")", ":", "\n", "\n", "# TRAINING", "\n", "            ", "train_epoch_loss", "=", "0", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "if", "batch_size", "<", "500", ":", "\n", "\n", "              ", "for", "X_train_batch", ",", "y_train_batch", "in", "train_loader", ":", "\n", "                  ", "X_train_batch", ",", "y_train_batch", "=", "X_train_batch", ".", "to", "(", "self", ".", "device", ")", ",", "y_train_batch", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "y_train_pred", "=", "self", ".", "model", "(", "X_train_batch", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "train_loss", "=", "self", ".", "loss_func", "(", "y_train_pred", ",", "y_train_batch", ")", "\n", "\n", "train_loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "train_epoch_loss", "+=", "train_loss", ".", "item", "(", ")", "\n", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "y_train_pred", "=", "self", ".", "model", "(", "X_train_batch", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "train_loss", "=", "self", ".", "loss_func", "(", "y_train_pred", ",", "y_train_batch", ")", "\n", "\n", "train_loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "train_epoch_loss", "+=", "train_loss", ".", "item", "(", ")", "\n", "\n", "# VALIDATION", "\n", "", "if", "val_dataset", "is", "not", "None", ":", "\n", "                ", "if", "e", "%", "self", ".", "val_period", "==", "0", ":", "\n", "                    ", "self", ".", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "val_epoch_loss", "=", "0", "\n", "for", "X_val_batch", ",", "y_val_batch", "in", "val_loader", ":", "\n", "                            ", "X_val_batch", ",", "y_val_batch", "=", "X_val_batch", ".", "to", "(", "self", ".", "device", ")", ",", "y_val_batch", ".", "to", "(", "self", ".", "device", ")", "\n", "y_val_pred", "=", "self", ".", "model", "(", "X_val_batch", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "val_loss", "=", "self", ".", "loss_func", "(", "y_val_pred", ",", "y_val_batch", ")", "\n", "val_epoch_loss", "+=", "val_loss", ".", "item", "(", ")", "\n", "\n", "", "", "loss_stats", "[", "'val'", "]", ".", "append", "(", "val_epoch_loss", "/", "len", "(", "val_loader", ")", ")", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "", "", "else", ":", "\n", "                ", "loss_stats", "[", "'val'", "]", ".", "append", "(", "0", ")", "\n", "\n", "", "if", "e", "%", "self", ".", "val_period", "==", "0", ":", "\n", "                ", "loss_stats", "[", "'train'", "]", ".", "append", "(", "train_epoch_loss", "/", "len", "(", "train_loader", ")", ")", "\n", "\n", "", "if", "(", "e", "%", "10", "==", "0", ")", "and", "(", "self", ".", "verbose", ")", ":", "\n", "                ", "if", "val_dataset", "is", "not", "None", ":", "\n", "                    ", "print", "(", "f'Epoch {e+0:03}: | Train Loss: {train_epoch_loss/len(train_loader):.5f} | '", ",", "end", "=", "''", ")", "\n", "print", "(", "f'Val Loss: {val_epoch_loss/len(val_loader):.5f} | '", ",", "flush", "=", "True", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "f'Epoch {e+0:03}: | Train Loss: {train_epoch_loss/len(train_loader):.5f} | '", ",", "flush", "=", "True", ")", "\n", "\n", "", "", "", "return", "loss_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet.predict": [[267, 279], ["black_boxes.QNet.model.eval", "black_boxes.QNet.model", "black_boxes.QNet.cpu().detach().numpy", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "torch.from_numpy().to().float().requires_grad_", "black_boxes.QNet.cpu().detach", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "torch.from_numpy().to().float", "black_boxes.QNet.cpu", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\" Estimate the label given the features\n        Parameters\n        ----------\n        x : numpy array of training features (nXp)\n        Returns\n        -------\n        ret_val : numpy array of predicted labels (n)\n        \"\"\"", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "ret_val", "=", "self", ".", "model", "(", "torch", ".", "from_numpy", "(", "X", ")", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", ".", "requires_grad_", "(", "False", ")", ")", "\n", "return", "ret_val", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QNet.get_quantiles": [[280, 282], ["black_boxes.QNet.quantiles.cpu().numpy", "black_boxes.QNet.quantiles.cpu"], "methods", ["None"], ["", "def", "get_quantiles", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "quantiles", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.__init__": [[286, 304], ["torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "skgarden.RandomForestQuantileRegressor", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.sort"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "quantiles", ",", "min_samples_leaf", "=", "5", ",", "n_estimators", "=", "100", ",", "n_jobs", "=", "1", ",", "\n", "random_state", "=", "0", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialization\n        Parameters\n        ----------\n        quantiles : numpy array of quantile levels (q), each in the range (0,1)\n        num_features : integer, input signal dimension (p)\n        random_state : integer, seed used in quantile random forests\n        \"\"\"", "\n", "\n", "self", ".", "device", "=", "'cpu'", "\n", "# Store input (sort the quantiles)", "\n", "self", ".", "quantiles", "=", "torch", ".", "from_numpy", "(", "np", ".", "sort", "(", "quantiles", ")", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# Define RF model", "\n", "self", ".", "model", "=", "RandomForestQuantileRegressor", "(", "random_state", "=", "random_state", ",", "\n", "min_samples_leaf", "=", "min_samples_leaf", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit": [[305, 310], ["warnings.filterwarnings", "black_boxes.QRF.model.fit", "warnings.filterwarnings"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "return_loss", "=", "None", ")", ":", "\n", "        ", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "FutureWarning", ")", "\n", "self", ".", "model", ".", "fit", "(", "X", ",", "Y", ")", "\n", "warnings", ".", "filterwarnings", "(", "\"default\"", ",", "category", "=", "FutureWarning", ")", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict": [[311, 326], ["black_boxes.QRF.quantiles.cpu", "numpy.zeros", "print", "tqdm.autonotebook.tqdm.autonotebook.tqdm", "range", "black_boxes.QRF.model.predict", "len", "len"], "methods", ["home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\" Estimate the label given the features\n        Parameters\n        ----------\n        x : numpy array of training features (nXp)\n        Returns\n        -------\n        ret_val : numpy array of predicted labels (n)\n        \"\"\"", "\n", "quantiles", "=", "self", ".", "quantiles", ".", "cpu", "(", ")", "\n", "ret_val", "=", "np", ".", "zeros", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "len", "(", "quantiles", ")", ")", ")", "\n", "print", "(", "\"Predicting RF quantiles:\"", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "len", "(", "quantiles", ")", ")", ")", ":", "\n", "            ", "ret_val", "[", ":", ",", "i", "]", "=", "self", ".", "model", ".", "predict", "(", "X", ",", "quantile", "=", "100", "*", "quantiles", "[", "i", "]", ")", "\n", "", "return", "ret_val", "\n", "\n"]], "home.repos.pwc.inspect_result.msesia_chr.chr.black_boxes.QRF.get_quantiles": [[327, 329], ["black_boxes.QRF.quantiles.cpu().numpy", "black_boxes.QRF.quantiles.cpu"], "methods", ["None"], ["", "def", "get_quantiles", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "quantiles", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "", ""]]}