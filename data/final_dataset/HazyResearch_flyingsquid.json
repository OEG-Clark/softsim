{"home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator": [[16, 57], ["set", "set", "list", "len", "queue.pop", "_graphs.Mixin._is_separator.neighbors"], "methods", ["None"], ["def", "_is_separator", "(", "self", ",", "srcSet", ",", "dstSet", ",", "separatorSet", ")", ":", "\n", "        ", "'''Check if separatorSet separates srcSet from dstSet.\n        \n        Tries to find a path from some node in srcSet to some node in dstSet that doesn't\n        pass through separatorSet. If successful, return False. Otherwise, return True.\n        '''", "\n", "def", "neighbors", "(", "node", ")", ":", "\n", "            ", "neighbor_set", "=", "set", "(", ")", "\n", "for", "edge", "in", "self", ".", "G", ".", "edges", ":", "\n", "                ", "if", "edge", "[", "0", "]", "==", "node", ":", "\n", "                    ", "neighbor_set", ".", "add", "(", "edge", "[", "1", "]", ")", "\n", "", "if", "edge", "[", "1", "]", "==", "node", ":", "\n", "                    ", "neighbor_set", ".", "add", "(", "edge", "[", "0", "]", ")", "\n", "", "", "return", "list", "(", "neighbor_set", ")", "\n", "\n", "", "visited", "=", "set", "(", ")", "\n", "for", "srcNode", "in", "srcSet", ":", "\n", "            ", "if", "srcNode", "in", "dstSet", ":", "\n", "                ", "return", "False", "\n", "", "queue", "=", "[", "srcNode", "]", "\n", "\n", "curNode", "=", "srcNode", "\n", "\n", "while", "len", "(", "queue", ")", ">", "0", ":", "\n", "                ", "curNode", "=", "queue", ".", "pop", "(", ")", "\n", "if", "curNode", "not", "in", "visited", ":", "\n", "                    ", "visited", ".", "add", "(", "curNode", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "\n", "", "for", "neighbor", "in", "neighbors", "(", "curNode", ")", ":", "\n", "                    ", "if", "neighbor", "==", "srcNode", ":", "\n", "                        ", "continue", "\n", "", "if", "neighbor", "in", "dstSet", ":", "\n", "                        ", "return", "False", "\n", "", "if", "neighbor", "in", "separatorSet", ":", "\n", "                        ", "continue", "\n", "", "if", "neighbor", "not", "in", "visited", ":", "\n", "                        ", "queue", ".", "append", "(", "neighbor", ")", "\n", "\n", "", "", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._check": [[59, 136], ["sorted", "len", "len", "_graphs.Mixin._check.num_Ys"], "methods", ["None"], ["", "def", "_check", "(", "self", ")", ":", "\n", "        ", "'''Check to make sure we can solve this.\n        \n        Checks:\n        * For each node or separator set in the junction tree:\n            There is either only one Y node in the clique, or the clique is made up entirely of Y nodes, since\n            we can only estimate marginals where there is at most one Y, unless the entire marginal is\n            made up of Y's)\n        * For each node or separator set in the junction tree that contains at least one\n          lambda node and exactly one Y node:\n            The Y node separates the lambda's from at least two other lambda nodes, that are themselves\n            separated by Y. To estimate the marginal mu(lambda_i, ..., lambda_j, Y_k), we need to find\n            lambda_a, lambda_b such that lambda_a, lambda_b, and the joint (lambda_i, ..., lambda_j) are\n            independent conditioned on Y_k. This amounts to Y_k separating lambda_a, lambda_b, and\n            (lambda_i, ..., lambda_j). Note that lambda_i, ..., lambda_j do not have to be separated by Y_k.\n        \n        Outputs: True if we can solve this, False otherwise.\n        '''", "\n", "def", "num_Ys", "(", "nodes", ")", ":", "\n", "            ", "return", "len", "(", "[", "\n", "node", "for", "node", "in", "nodes", "if", "'Y'", "in", "node", "\n", "]", ")", "\n", "\n", "", "def", "num_lambdas", "(", "nodes", ")", ":", "\n", "            ", "return", "len", "(", "[", "\n", "node", "for", "node", "in", "nodes", "if", "'lambda'", "in", "node", "\n", "]", ")", "\n", "\n", "", "def", "estimatable_clique", "(", "clique", ")", ":", "\n", "            ", "y_count", "=", "num_Ys", "(", "clique", ")", "\n", "lambda_count", "=", "num_lambdas", "(", "clique", ")", "\n", "\n", "return", "y_count", "<=", "1", "or", "lambda_count", "==", "0", "\n", "\n", "", "for", "clique", "in", "self", ".", "junction_tree", ".", "nodes", ":", "\n", "            ", "if", "not", "estimatable_clique", "(", "clique", ")", ":", "\n", "                ", "return", "False", ",", "\"We can't estimate {}!\"", ".", "format", "(", "clique", ")", "\n", "\n", "", "", "for", "separator_set", "in", "self", ".", "separator_sets", ":", "\n", "            ", "if", "not", "estimatable_clique", "(", "clique", ")", ":", "\n", "                ", "return", "False", ",", "\"We can't estimate {}!\"", ".", "format", "(", "separator_set", ")", "\n", "\n", "# for each marginal we need to estimate, check if there is a valid triplet", "\n", "", "", "marginals", "=", "sorted", "(", "list", "(", "self", ".", "junction_tree", ".", "nodes", ")", "+", "list", "(", "self", ".", "separator_sets", ")", ")", "\n", "for", "marginal", "in", "marginals", ":", "\n", "            ", "y_count", "=", "num_Ys", "(", "marginal", ")", "\n", "lambda_count", "=", "num_lambdas", "(", "marginal", ")", "\n", "\n", "if", "y_count", "!=", "1", ":", "\n", "                ", "continue", "\n", "", "if", "lambda_count", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "separator_y", "=", "[", "node", "for", "node", "in", "marginal", "if", "'Y'", "in", "node", "]", "\n", "lambdas", "=", "[", "node", "for", "node", "in", "marginal", "if", "'lambda'", "in", "node", "]", "\n", "\n", "found", "=", "False", "\n", "for", "first_node", "in", "self", ".", "nodes", ":", "\n", "                ", "if", "'Y'", "in", "first_node", "or", "first_node", "in", "lambdas", ":", "\n", "                    ", "continue", "\n", "", "for", "second_node", "in", "self", ".", "nodes", ":", "\n", "                    ", "if", "'Y'", "in", "second_node", "or", "second_node", "in", "lambdas", ":", "\n", "                        ", "continue", "\n", "\n", "", "if", "(", "self", ".", "_is_separator", "(", "lambdas", ",", "[", "first_node", "]", ",", "separator_y", ")", "and", "\n", "self", ".", "_is_separator", "(", "lambdas", ",", "[", "second_node", "]", ",", "separator_y", ")", "and", "\n", "self", ".", "_is_separator", "(", "[", "first_node", "]", ",", "[", "second_node", "]", ",", "separator_y", ")", ")", ":", "\n", "                        ", "found", "=", "True", "\n", "break", "\n", "", "", "if", "found", ":", "\n", "                    ", "break", "\n", "\n", "", "", "if", "not", "found", ":", "\n", "                ", "print", "(", "'Could not find triplet for {}!'", ".", "format", "(", "marginal", ")", ")", "\n", "return", "False", "\n", "\n", "", "", "return", "True", "", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_e_vector": [[16, 92], ["range", "tuple", "len", "new_e_vec.append", "new_e_vec.append"], "methods", ["None"], ["def", "_generate_e_vector", "(", "self", ",", "clique", ")", ":", "\n", "        ", "'''\n        The e vector is a vector of assignments for a particular marginal.\n        \n        For example, in a marginal with one LF and one Y variable, and no\n        abstentions, the e vector entries are:\n            [\n                (1, 1),\n                (1, -1),\n                (-1, 1),\n                (-1, -1)\n            ]\n        The first entry of each tuple is the value of the LF, the second\n        entry is the value of the Y variagble.\n        \n        In a marginal with two LFs and one Y variable and no abstentions,\n        the entries are:\n            [\n                (1, 1, 1),\n                (1, 1, -1),\n                (1, -1, 1),\n                (1, -1, -1),\n                (-1, 1, 1),\n                (-1, 1, -1),\n                (-1, -1, 1),\n                (-1, -1, -1)\n            ]\n        \n        In a marginal with one Lf, one Y variable, and abstentions:\n            [\n                (1, 1),\n                (0, 1),\n                (-1, 1),\n                (1, -1),\n                (0, -1),\n                (-1, -1)\n            ]\n            \n        Two LFs, one Y variable, and abstentions:\n            [\n                (1, 1, 1),\n                (0, 1, 1),\n                (-1, 1, 1),\n                (1, 0, 1),\n                (0, 0, 1),\n                (-1, 0, 1),\n                (1, -1, 1),\n                (0, -1, 1),\n                (-1, -1, 1),\n                (1, 1, -1),\n                (0, 1, -1),\n                (-1, 1, -1),\n                (1, 0, -1),\n                (0, 0, -1),\n                (-1, 0, -1),\n                (1, -1, -1),\n                (0, -1, -1),\n                (-1, -1, -1)\n            ]\n        '''", "\n", "lambda_values", "=", "[", "1", ",", "0", ",", "-", "1", "]", "if", "self", ".", "allow_abstentions", "else", "[", "1", ",", "-", "1", "]", "\n", "e_vec", "=", "[", "[", "1", "]", ",", "[", "-", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "clique", ")", "-", "1", ")", ":", "\n", "            ", "new_e_vec", "=", "[", "]", "\n", "if", "not", "self", ".", "allow_abstentions", ":", "\n", "                ", "for", "new_val", "in", "lambda_values", ":", "\n", "                    ", "for", "e_val", "in", "e_vec", ":", "\n", "                        ", "new_e_vec", ".", "append", "(", "e_val", "+", "[", "new_val", "]", ")", "\n", "", "", "", "else", ":", "\n", "                ", "for", "e_val", "in", "e_vec", ":", "\n", "                    ", "for", "new_val", "in", "lambda_values", ":", "\n", "                        ", "new_e_vec", ".", "append", "(", "[", "new_val", "]", "+", "e_val", ")", "\n", "", "", "", "e_vec", "=", "new_e_vec", "\n", "", "e_vec", "=", "[", "tuple", "(", "e_val", ")", "for", "e_val", "in", "e_vec", "]", "\n", "\n", "return", "e_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_r_vector": [[93, 161], ["sorted", "_lm_parameters.Mixin._generate_e_vector", "int", "zip", "r_vec_entry_equal_one.append", "tuple", "tuple", "tuple", "tuple", "r_vec.append", "r_vec.append", "node.split", "len", "len", "len", "print", "exit", "r_vec_entry_equal_zero.append", "r_vec_entry_equal_one.append", "r_vec_entry_equal_one.append"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_e_vector"], ["", "def", "_generate_r_vector", "(", "self", ",", "clique", ")", ":", "\n", "        ", "'''\n        The r vector is the vector of probability values that needs to be on the RHS\n        of the B_matrix * e_vector = r_vector to make e_vector have the right values.\n        \n        When there are abstentions, the mapping works as follows:\n        * Each probability is some combination of\n            P(A * B *  ... * C = 1, D = 0, E = 0, ..., F = 0)\n        * The A, B, ..., C can include any LF, and the Y variable.\n        * The D, E, ..., F can include any LF\n        * Let the A, B, ..., C set be called the \"equals one set\"\n        * Let the D, E, ..., F set be called the \"equals zero set\"\n        * Then, for each entry in the e vector:\n          * If there is a -1 in an LF spot, add the LF to the \"equals zero set\"\n          * If there is a 0 in the LF spot, add the LF to the \"equals one set\"\n          * If there is a -1 in the Y variable spot, add it to the \"equals one set\"\n          \n        When there are no abstentions, each probability is just defined by the\n        \"equals one set\" (i.e., P(A * B * ... * C = 1)).\n        * For each entry in the e vector:\n          * If there is a -1 in any spot (LF spot or Y variable), add it to the\n            \"equals one set\"\n        '''", "\n", "indices", "=", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "clique", "]", "\n", "lf_indices", "=", "sorted", "(", "indices", "[", ":", "-", "1", "]", ")", "\n", "Y_idx", "=", "indices", "[", "-", "1", "]", "\n", "Y_val", "=", "'Y_{}'", ".", "format", "(", "Y_idx", ")", "\n", "\n", "e_vec", "=", "self", ".", "_generate_e_vector", "(", "clique", ")", "\n", "\n", "r_vec", "=", "[", "]", "\n", "for", "e_vec_tup", "in", "e_vec", ":", "\n", "# P(a * b * ... * c = 1) for everything in this array", "\n", "            ", "r_vec_entry_equal_one", "=", "[", "]", "\n", "# P(a = 0, b = 0, ..., c = 0) for everything in this array", "\n", "r_vec_entry_equal_zero", "=", "[", "]", "\n", "for", "e_vec_entry", ",", "lf_idx", "in", "zip", "(", "e_vec_tup", ",", "lf_indices", ")", ":", "\n", "# if you have abstentions, -1 means add to equal zero, 0 means add to equal one", "\n", "                ", "if", "self", ".", "allow_abstentions", ":", "\n", "                    ", "if", "e_vec_entry", "==", "-", "1", ":", "\n", "                        ", "r_vec_entry_equal_zero", ".", "append", "(", "'lambda_{}'", ".", "format", "(", "lf_idx", ")", ")", "\n", "", "if", "e_vec_entry", "==", "0", ":", "\n", "                        ", "r_vec_entry_equal_one", ".", "append", "(", "'lambda_{}'", ".", "format", "(", "lf_idx", ")", ")", "\n", "# otherwise, -1 means add to equal one", "\n", "", "", "else", ":", "\n", "                    ", "if", "e_vec_entry", "==", "-", "1", ":", "\n", "                        ", "r_vec_entry_equal_one", ".", "append", "(", "'lambda_{}'", ".", "format", "(", "lf_idx", ")", ")", "\n", "", "", "", "if", "e_vec_tup", "[", "-", "1", "]", "==", "-", "1", ":", "\n", "                ", "r_vec_entry_equal_one", ".", "append", "(", "Y_val", ")", "\n", "\n", "", "entries_equal_one", "=", "(", "\n", "tuple", "(", "[", "'1'", "]", ")", "if", "len", "(", "r_vec_entry_equal_one", ")", "==", "0", "else", "\n", "tuple", "(", "r_vec_entry_equal_one", ")", ")", "\n", "entries_equal_zero", "=", "(", "\n", "tuple", "(", "[", "'0'", "]", ")", "if", "len", "(", "r_vec_entry_equal_zero", ")", "==", "0", "else", "\n", "tuple", "(", "r_vec_entry_equal_zero", ")", ")", "\n", "if", "self", ".", "allow_abstentions", ":", "\n", "                ", "r_vec", ".", "append", "(", "(", "\n", "entries_equal_one", ",", "\n", "entries_equal_zero", "\n", ")", ")", "\n", "", "else", ":", "\n", "                ", "if", "len", "(", "r_vec_entry_equal_zero", ")", ">", "0", ":", "\n", "                    ", "print", "(", "'No abstentions allowed!'", ")", "\n", "exit", "(", "1", ")", "\n", "", "r_vec", ".", "append", "(", "entries_equal_one", ")", "\n", "\n", "", "", "return", "r_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_b_matrix": [[162, 201], ["numpy.array", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "numpy.kron", "len", "len", "numpy.kron", "numpy.kron", "numpy.kron", "numpy.kron"], "methods", ["None"], ["", "def", "_generate_b_matrix", "(", "self", ",", "clique", ")", ":", "\n", "        ", "if", "not", "self", ".", "allow_abstentions", ":", "\n", "            ", "b_matrix_orig", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", "]", "]", ")", "\n", "b_matrix", "=", "b_matrix_orig", "\n", "for", "i", "in", "range", "(", "len", "(", "clique", ")", "-", "1", ")", ":", "\n", "                ", "b_matrix", "=", "np", ".", "kron", "(", "b_matrix", ",", "b_matrix_orig", ")", "\n", "", "b_matrix", "[", "b_matrix", "<", "0", "]", "=", "0", "\n", "\n", "return", "b_matrix", "\n", "", "else", ":", "\n", "            ", "a_zero", "=", "np", ".", "array", "(", "[", "\n", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", "]", "\n", "]", ")", "\n", "b_zero", "=", "np", ".", "array", "(", "[", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", "\n", "]", ")", "\n", "\n", "c_matrix", "=", "np", ".", "array", "(", "[", "\n", "[", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", "\n", "]", ")", "\n", "d_matrix", "=", "np", ".", "array", "(", "[", "\n", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", "]", "\n", "]", ")", "\n", "\n", "a_i", "=", "a_zero", "\n", "b_i", "=", "b_zero", "\n", "for", "i", "in", "range", "(", "len", "(", "clique", ")", "-", "1", ")", ":", "\n", "                ", "a_prev", "=", "a_i", "\n", "b_prev", "=", "b_i", "\n", "a_i", "=", "np", ".", "kron", "(", "a_prev", ",", "c_matrix", ")", "+", "np", ".", "kron", "(", "b_prev", ",", "d_matrix", ")", "\n", "b_i", "=", "np", ".", "kron", "(", "a_prev", ",", "d_matrix", ")", "+", "np", ".", "kron", "(", "b_prev", ",", "c_matrix", ")", "\n", "\n", "", "return", "a_i", "", "", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_single_seed": [[17, 201], ["sorted", "set", "list", "random.shuffle", "set", "tuple", "tuple", "tuple", "tuple", "triplets.append", "tuple", "tuple", "tuple", "sorted", "sorted", "sorted", "tuple", "tuple", "tuple", "sorted", "set.add", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "set.add", "sorted", "sorted", "sorted", "sorted", "sorted", "sorted", "int", "int", "int", "int", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "len", "len", "len", "len", "any", "all", "any", "all", "all", "all", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "node.split", "node.split", "node.split", "node.split", "len", "len", "all", "all", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "len", "len", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator"], ["def", "_triplet_method_single_seed", "(", "self", ",", "expectations_to_estimate", ")", ":", "\n", "# create triplets for what we need, and return which moments we'll need to compute", "\n", "\n", "        ", "exp_to_estimate_list", "=", "sorted", "(", "list", "(", "expectations_to_estimate", ")", ")", "\n", "if", "self", ".", "triplet_seed", "is", "not", "None", ":", "\n", "            ", "random", ".", "shuffle", "(", "exp_to_estimate_list", ")", "\n", "\n", "", "if", "self", ".", "triplets", "is", "None", ":", "\n", "            ", "expectations_in_triplets", "=", "set", "(", ")", "\n", "triplets", "=", "[", "]", "\n", "for", "expectation", "in", "exp_to_estimate_list", ":", "\n", "# if we're already computing it, don't need to add to a new triplet", "\n", "                ", "if", "expectation", "in", "expectations_in_triplets", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "not", "self", ".", "allow_abstentions", ":", "\n", "                    ", "Y_node", "=", "expectation", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "Y_node", "=", "expectation", "[", "0", "]", "[", "-", "1", "]", "\n", "\n", "", "def", "check_triplet", "(", "triplet", ")", ":", "\n", "                    ", "return", "(", "self", ".", "_is_separator", "(", "triplet", "[", "0", "]", "[", ":", "-", "1", "]", ",", "triplet", "[", "1", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "and", "\n", "self", ".", "_is_separator", "(", "triplet", "[", "0", "]", "[", ":", "-", "1", "]", ",", "triplet", "[", "2", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "and", "\n", "self", ".", "_is_separator", "(", "triplet", "[", "1", "]", "[", ":", "-", "1", "]", ",", "triplet", "[", "2", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", "\n", "\n", "", "triplet", "=", "[", "expectation", "]", "\n", "found", "=", "False", "\n", "\n", "# first try looking at the other expectations that we need to estimate", "\n", "for", "first_node", "in", "exp_to_estimate_list", ":", "\n", "                    ", "if", "self", ".", "allow_abstentions", ":", "\n", "# need to check if conditionals are the same", "\n", "                        ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "first_node", "[", "0", "]", "[", "-", "1", "]", "!=", "Y_node", "or", "# skip if the Y values aren't the same", "\n", "first_node", "[", "1", "]", "!=", "expectation", "[", "1", "]", "or", "# skip if conditions are different", "\n", "(", "len", "(", "first_node", "[", "0", "]", ")", ">", "2", "and", "len", "(", "expectation", "[", "0", "]", ")", ">", "2", ")", "or", "# at most one item in the triplet can have length > 2", "\n", "first_node", "in", "expectations_in_triplets", "or", "# we're already computing this", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", "0", "]", "[", ":", "-", "1", "]", ",", "first_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                            ", "continue", "\n", "", "", "else", ":", "\n", "                        ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "first_node", "[", "-", "1", "]", "!=", "Y_node", "or", "# skip if the Y values aren't the same", "\n", "(", "len", "(", "first_node", ")", ">", "2", "and", "len", "(", "expectation", ")", ">", "2", ")", "or", "# at most one item in the triplet can have length > 2", "\n", "first_node", "in", "expectations_in_triplets", "or", "# we're already computing this", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", ":", "-", "1", "]", ",", "first_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                            ", "continue", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", "]", "\n", "# first try looking at the other expectations that we need to estimate", "\n", "for", "second_node", "in", "exp_to_estimate_list", ":", "\n", "                        ", "if", "self", ".", "allow_abstentions", ":", "\n", "                            ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "second_node", "[", "0", "]", "[", "-", "1", "]", "!=", "Y_node", "or", "# skip if the Y values aren't the same", "\n", "second_node", "[", "1", "]", "!=", "expectation", "[", "1", "]", "or", "# skip if conditions are different", "\n", "(", "len", "(", "second_node", "[", "0", "]", ")", ">", "2", "and", "\n", "any", "(", "len", "(", "exp", "[", "0", "]", ")", ">", "2", "for", "exp", "in", "triplet", ")", ")", "or", "# at most one item in the triplet can have length > 2", "\n", "second_node", "in", "expectations_in_triplets", "or", "# we're already computing this", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", "0", "]", "[", ":", "-", "1", "]", ",", "second_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "", "", "else", ":", "\n", "                            ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "second_node", "[", "-", "1", "]", "!=", "Y_node", "or", "# skip if the Y values aren't the same", "\n", "(", "len", "(", "second_node", ")", ">", "2", "and", "\n", "any", "(", "len", "(", "exp", ")", ">", "2", "for", "exp", "in", "triplet", ")", ")", "or", "# at most one item in the triplet can have length > 2", "\n", "second_node", "in", "expectations_in_triplets", "or", "# we're already computing this", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", ":", "-", "1", "]", ",", "second_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "\n", "# we found a triplet!", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", ",", "second_node", "]", "\n", "found", "=", "True", "\n", "break", "\n", "\n", "", "if", "found", ":", "\n", "                        ", "break", "\n", "\n", "# otherwise, try everything", "\n", "", "for", "second_node", "in", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "expectation", "[", "1", "]", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "\n", "]", ":", "\n", "                        ", "if", "self", ".", "allow_abstentions", ":", "\n", "                            ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "second_node", "[", "1", "]", "!=", "expectation", "[", "1", "]", "or", "# skip if conditions are different", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", "0", "]", "[", ":", "-", "1", "]", ",", "second_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "", "", "else", ":", "\n", "                            ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", ":", "-", "1", "]", ",", "second_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "\n", "# we found a triplet!", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", ",", "second_node", "]", "\n", "found", "=", "True", "\n", "break", "\n", "\n", "", "if", "found", ":", "\n", "                        ", "break", "\n", "\n", "", "", "if", "not", "found", ":", "\n", "# try everything", "\n", "                    ", "for", "first_node", "in", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "expectation", "[", "1", "]", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "if", "'Y'", "not", "in", "node", "\n", "]", ":", "\n", "                        ", "if", "self", ".", "allow_abstentions", ":", "\n", "                            ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "first_node", "[", "0", "]", "[", "0", "]", "in", "expectation", "[", "1", "]", "or", "# skip if the node is part of the condition", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", "0", "]", "[", ":", "-", "1", "]", ",", "first_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "", "", "else", ":", "\n", "                            ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", ":", "-", "1", "]", ",", "first_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", "]", "\n", "\n", "if", "found", ":", "\n", "                            ", "break", "\n", "\n", "", "for", "second_node", "in", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "expectation", "[", "1", "]", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "if", "'Y'", "not", "in", "node", "\n", "]", ":", "\n", "                            ", "if", "self", ".", "allow_abstentions", ":", "\n", "                                ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "second_node", "[", "0", "]", "[", "0", "]", "in", "expectation", "[", "1", "]", "or", "# skip if the node is part of the condition", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", "0", "]", "[", ":", "-", "1", "]", ",", "second_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                    ", "continue", "\n", "", "", "else", ":", "\n", "                                ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", ":", "-", "1", "]", ",", "second_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                    ", "continue", "\n", "# we found a triplet!", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", ",", "second_node", "]", "\n", "found", "=", "True", "\n", "break", "\n", "\n", "", "if", "found", ":", "\n", "                            ", "break", "\n", "\n", "", "", "", "if", "found", ":", "\n", "                    ", "triplets", ".", "append", "(", "triplet", ")", "\n", "for", "expectation", "in", "triplet", ":", "\n", "                        ", "expectations_in_triplets", ".", "add", "(", "expectation", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "triplets", "=", "self", ".", "triplets", "\n", "\n", "", "all_moments", "=", "set", "(", ")", "\n", "abstention_probabilities", "=", "{", "}", "\n", "\n", "for", "exp1", ",", "exp2", ",", "exp3", "in", "triplets", ":", "\n", "            ", "if", "self", ".", "allow_abstentions", ":", "\n", "                ", "condition", "=", "exp1", "[", "1", "]", "\n", "\n", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "\n", "indices1", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "indices2", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "indices3", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "\n", "if", "indices1", "not", "in", "abstention_probabilities", ":", "\n", "                    ", "abstention_probabilities", "[", "indices1", "]", "=", "0", "\n", "", "if", "indices2", "not", "in", "abstention_probabilities", ":", "\n", "                    ", "abstention_probabilities", "[", "indices2", "]", "=", "0", "\n", "", "if", "indices3", "not", "in", "abstention_probabilities", ":", "\n", "                    ", "abstention_probabilities", "[", "indices3", "]", "=", "0", "\n", "", "", "else", ":", "\n", "# first, figure out which moments we need to compute", "\n", "                ", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp2", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "", "for", "moment", "in", "moments", ":", "\n", "                ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "moment", "]", ")", ")", "\n", "\n", "if", "indices", "not", "in", "all_moments", ":", "\n", "                    ", "all_moments", ".", "add", "(", "indices", ")", "\n", "\n", "", "", "", "return", "triplets", ",", "all_moments", ",", "abstention_probabilities", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_mean_median": [[202, 318], ["sorted", "set", "list", "list", "set", "range", "tuple", "tuple", "tuple", "tuple", "tuple", "tuple", "tuple", "sorted", "sorted", "sorted", "tuple", "tuple", "tuple", "sorted", "set.add", "triplets.append", "tuple", "sorted", "sorted", "sorted", "sorted", "sorted", "sorted", "tuple", "tuple", "int", "int", "int", "int", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator", "all", "all", "node.split", "node.split", "node.split", "node.split", "_triplets.Mixin._is_separator", "_triplets.Mixin._is_separator"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._is_separator"], ["", "def", "_triplet_method_mean_median", "(", "self", ",", "expectations_to_estimate", ",", "solve_method", ")", ":", "\n", "        ", "exp_to_estimate_list", "=", "sorted", "(", "list", "(", "expectations_to_estimate", ")", ")", "\n", "triplets", "=", "[", "]", "\n", "\n", "if", "self", ".", "triplets", "is", "None", ":", "\n", "            ", "if", "self", ".", "fully_independent_case", ":", "\n", "                ", "Y_node", "=", "'Y'", "\n", "all_nodes", "=", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "'0'", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "if", "'Y'", "not", "in", "node", "\n", "]", "\n", "triplets", "=", "[", "\n", "[", "i", ",", "j", ",", "k", "]", "\n", "for", "i", "in", "all_nodes", "\n", "for", "j", "in", "all_nodes", "if", "i", "!=", "j", "\n", "for", "k", "in", "all_nodes", "if", "i", "!=", "k", "and", "k", "!=", "j", "\n", "]", "+", "[", "\n", "[", "expectation", ",", "-", "1", ",", "-", "1", "]", "for", "expectation", "in", "exp_to_estimate_list", "\n", "]", "\n", "", "else", ":", "\n", "                ", "for", "expectation", "in", "exp_to_estimate_list", ":", "\n", "                    ", "if", "not", "self", ".", "allow_abstentions", ":", "\n", "                        ", "Y_node", "=", "expectation", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                        ", "Y_node", "=", "expectation", "[", "0", "]", "[", "-", "1", "]", "\n", "\n", "", "triplet", "=", "[", "expectation", "]", "\n", "\n", "# try everything", "\n", "for", "first_node", "in", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "expectation", "[", "1", "]", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "if", "'Y'", "not", "in", "node", "\n", "]", ":", "\n", "                        ", "if", "self", ".", "allow_abstentions", ":", "\n", "                            ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "first_node", "[", "0", "]", "[", "0", "]", "in", "expectation", "[", "1", "]", "or", "# skip if the node is part of the condition", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", "0", "]", "[", ":", "-", "1", "]", ",", "first_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "", "", "else", ":", "\n", "                            ", "if", "(", "first_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "not", "self", ".", "_is_separator", "(", "expectation", "[", ":", "-", "1", "]", ",", "first_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", ")", ":", "# not separated", "\n", "                                ", "continue", "\n", "\n", "", "", "triplet", "=", "[", "expectation", ",", "first_node", "]", "\n", "\n", "for", "second_node", "in", "[", "\n", "(", "(", "node", ",", "Y_node", ")", ",", "expectation", "[", "1", "]", ")", "if", "self", ".", "allow_abstentions", "else", "(", "node", ",", "Y_node", ")", "\n", "for", "node", "in", "self", ".", "nodes", "if", "'Y'", "not", "in", "node", "\n", "]", ":", "\n", "                            ", "if", "self", ".", "allow_abstentions", ":", "\n", "                                ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "second_node", "[", "0", "]", "[", "0", "]", "in", "expectation", "[", "1", "]", "or", "# skip if the node is part of the condition", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", "0", "]", "[", ":", "-", "1", "]", ",", "second_node", "[", "0", "]", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                    ", "continue", "\n", "", "", "else", ":", "\n", "                                ", "if", "(", "second_node", "in", "triplet", "or", "# skip if it's already in the triplet", "\n", "not", "all", "(", "self", ".", "_is_separator", "(", "exp", "[", ":", "-", "1", "]", ",", "second_node", "[", ":", "-", "1", "]", ",", "Y_node", ")", "for", "exp", "in", "triplet", ")", ")", ":", "# not separated", "\n", "                                    ", "continue", "\n", "", "", "if", "tuple", "(", "[", "expectation", ",", "second_node", ",", "first_node", "]", ")", "in", "triplets", ":", "\n", "                                ", "continue", "\n", "# we found a triplet!", "\n", "", "triplet", "=", "[", "expectation", ",", "first_node", ",", "second_node", "]", "\n", "triplets", ".", "append", "(", "tuple", "(", "triplet", ")", ")", "\n", "triplet", "=", "[", "expectation", ",", "first_node", "]", "\n", "", "triplet", "=", "[", "expectation", "]", "\n", "", "", "", "", "else", ":", "\n", "            ", "triplets", "=", "self", ".", "triplets", "\n", "\n", "", "all_moments", "=", "set", "(", ")", "\n", "abstention_probabilities", "=", "{", "}", "\n", "\n", "if", "self", ".", "fully_independent_case", ":", "\n", "            ", "all_nodes", "=", "list", "(", "range", "(", "self", ".", "m", ")", ")", "\n", "all_moments", "=", "set", "(", "[", "\n", "(", "i", ",", "j", ")", "\n", "for", "i", "in", "all_nodes", "\n", "for", "j", "in", "all_nodes", "if", "i", "!=", "j", "\n", "]", ")", "\n", "if", "self", ".", "allow_abstentions", ":", "\n", "                ", "for", "node", "in", "all_nodes", ":", "\n", "                    ", "abstention_probabilities", "[", "tuple", "(", "[", "node", "]", ")", "]", "=", "0", "\n", "", "", "", "else", ":", "\n", "            ", "for", "exp1", ",", "exp2", ",", "exp3", "in", "triplets", ":", "\n", "                ", "if", "self", ".", "allow_abstentions", ":", "\n", "                    ", "condition", "=", "exp1", "[", "1", "]", "\n", "\n", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "\n", "indices1", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "indices2", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "indices3", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "\n", "if", "indices1", "not", "in", "abstention_probabilities", ":", "\n", "                        ", "abstention_probabilities", "[", "indices1", "]", "=", "0", "\n", "", "if", "indices2", "not", "in", "abstention_probabilities", ":", "\n", "                        ", "abstention_probabilities", "[", "indices2", "]", "=", "0", "\n", "", "if", "indices3", "not", "in", "abstention_probabilities", ":", "\n", "                        ", "abstention_probabilities", "[", "indices3", "]", "=", "0", "\n", "", "", "else", ":", "\n", "# first, figure out which moments we need to compute", "\n", "                    ", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp2", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "", "for", "moment", "in", "moments", ":", "\n", "                    ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "moment", "]", ")", ")", "\n", "\n", "if", "indices", "not", "in", "all_moments", ":", "\n", "                        ", "all_moments", ".", "add", "(", "indices", ")", "\n", "\n", "", "", "", "", "return", "triplets", ",", "all_moments", ",", "abstention_probabilities", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_preprocess": [[319, 326], ["_triplets.Mixin._triplet_method_single_seed", "_triplets.Mixin._triplet_method_mean_median", "NotImplemented"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_single_seed", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_mean_median"], ["", "def", "_triplet_method_preprocess", "(", "self", ",", "expectations_to_estimate", ",", "solve_method", ")", ":", "\n", "        ", "if", "solve_method", "==", "'triplet'", ":", "\n", "            ", "return", "self", ".", "_triplet_method_single_seed", "(", "expectations_to_estimate", ")", "\n", "", "elif", "solve_method", "in", "[", "'triplet_mean'", ",", "'triplet_median'", "]", ":", "\n", "            ", "return", "self", ".", "_triplet_method_mean_median", "(", "expectations_to_estimate", ",", "solve_method", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplemented", "(", "'Unknown solve method {}'", ".", "format", "(", "solve_method", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_probabilities": [[327, 447], ["numpy.zeros", "print", "sorted", "range", "_triplets.Mixin._triplet_method_probabilities.all_triplet_vals"], "methods", ["None"], ["", "", "def", "_triplet_method_probabilities", "(", "self", ",", "triplets", ",", "lambda_moment_vals", ",", "lambda_zeros", ",", "\n", "abstention_probabilities", ",", "sign_recovery", ",", "solve_method", ")", ":", "\n", "        ", "expectation_values", "=", "{", "}", "\n", "\n", "if", "solve_method", "==", "'triplet'", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "# each triplet is constructed for the first value in the expectation", "\n", "# get all the triplets with the same first value, and take the mean or median", "\n", "            ", "expectation_value_candidates", "=", "{", "}", "\n", "\n", "", "if", "self", ".", "fully_independent_case", "and", "solve_method", "in", "[", "'triplet_mean'", ",", "'triplet_median'", "]", ":", "\n", "            ", "second_moment", "=", "np", ".", "zeros", "(", "(", "self", ".", "m", ",", "self", ".", "m", ")", ")", "\n", "for", "key", "in", "lambda_moment_vals", ":", "\n", "                ", "i", ",", "j", "=", "key", "\n", "second_moment", "[", "i", "]", "[", "j", "]", "=", "lambda_moment_vals", "[", "(", "i", ",", "j", ")", "]", "\n", "\n", "", "def", "all_triplet_vals", "(", "idx", ")", ":", "\n", "                ", "triplet_vals", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "m", ")", ":", "\n", "                    ", "if", "i", "==", "idx", ":", "\n", "                        ", "continue", "\n", "", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "                        ", "if", "j", "==", "idx", ":", "\n", "                            ", "continue", "\n", "", "val", "=", "math", ".", "sqrt", "(", "abs", "(", "\n", "(", "second_moment", "[", "idx", ",", "i", "]", "*", "second_moment", "[", "idx", ",", "j", "]", "/", "second_moment", "[", "i", ",", "j", "]", ")", "\n", "if", "second_moment", "[", "i", ",", "j", "]", "!=", "0", "else", "0", "\n", ")", ")", "\n", "triplet_vals", ".", "append", "(", "val", ")", "\n", "", "", "return", "triplet_vals", "\n", "", "all_vals", "=", "[", "all_triplet_vals", "(", "idx", ")", "for", "idx", "in", "range", "(", "self", ".", "m", ")", "]", "\n", "expectations_to_estimate", "=", "[", "\n", "expectation", "\n", "for", "expectation", ",", "a", ",", "b", "in", "triplets", "if", "a", "==", "-", "1", "and", "b", "==", "-", "1", "\n", "]", "\n", "for", "expectation", "in", "expectations_to_estimate", ":", "\n", "                ", "if", "self", ".", "allow_abstentions", ":", "\n", "                    ", "idx", "=", "int", "(", "expectation", "[", "0", "]", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "idx", "=", "int", "(", "expectation", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "", "expectation_value_candidates", "[", "expectation", "]", "=", "all_vals", "[", "idx", "]", "\n", "", "", "else", ":", "\n", "            ", "for", "exp1", ",", "exp2", ",", "exp3", "in", "triplets", ":", "\n", "                ", "if", "self", ".", "allow_abstentions", ":", "\n", "                    ", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", "0", "]", "[", ":", "-", "1", "]", "+", "exp3", "[", "0", "]", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "", "else", ":", "\n", "# first, figure out which moments we need to compute", "\n", "                    ", "moments", "=", "[", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp2", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp1", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", ",", "\n", "tuple", "(", "sorted", "(", "exp2", "[", ":", "-", "1", "]", "+", "exp3", "[", ":", "-", "1", "]", ")", ")", "\n", "]", "\n", "\n", "", "moment_vals", "=", "[", "\n", "lambda_moment_vals", "[", "\n", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "moment", "]", ")", ")", "\n", "]", "\n", "for", "moment", "in", "moments", "\n", "]", "\n", "\n", "if", "solve_method", "==", "'triplet'", ":", "\n", "                    ", "expectation_values", "[", "exp1", "]", "=", "(", "\n", "math", ".", "sqrt", "(", "abs", "(", "moment_vals", "[", "0", "]", "*", "moment_vals", "[", "1", "]", "/", "moment_vals", "[", "2", "]", ")", ")", "if", "moment_vals", "[", "2", "]", "!=", "0", "else", "0", ")", "\n", "expectation_values", "[", "exp2", "]", "=", "(", "\n", "math", ".", "sqrt", "(", "abs", "(", "moment_vals", "[", "0", "]", "*", "moment_vals", "[", "2", "]", "/", "moment_vals", "[", "1", "]", ")", ")", "if", "moment_vals", "[", "1", "]", "!=", "0", "else", "0", ")", "\n", "expectation_values", "[", "exp3", "]", "=", "(", "\n", "math", ".", "sqrt", "(", "abs", "(", "moment_vals", "[", "1", "]", "*", "moment_vals", "[", "2", "]", "/", "moment_vals", "[", "0", "]", ")", ")", "if", "moment_vals", "[", "0", "]", "!=", "0", "else", "0", ")", "\n", "", "else", ":", "\n", "                    ", "if", "exp1", "not", "in", "expectation_value_candidates", ":", "\n", "                        ", "expectation_value_candidates", "[", "exp1", "]", "=", "[", "]", "\n", "", "exp_value", "=", "(", "\n", "math", ".", "sqrt", "(", "abs", "(", "moment_vals", "[", "0", "]", "*", "moment_vals", "[", "1", "]", "/", "moment_vals", "[", "2", "]", ")", ")", "if", "moment_vals", "[", "2", "]", "!=", "0", "else", "0", ")", "\n", "expectation_value_candidates", "[", "exp1", "]", ".", "append", "(", "exp_value", ")", "\n", "\n", "", "", "", "if", "solve_method", "in", "[", "'triplet_mean'", ",", "'triplet_median'", "]", ":", "\n", "            ", "for", "exp", "in", "expectation_value_candidates", ":", "\n", "                ", "if", "solve_method", "==", "'triplet_mean'", ":", "\n", "                    ", "agg_function", "=", "np", ".", "mean", "\n", "", "if", "solve_method", "==", "'triplet_median'", ":", "\n", "                    ", "agg_function", "=", "np", ".", "median", "\n", "", "expectation_values", "[", "exp", "]", "=", "agg_function", "(", "expectation_value_candidates", "[", "exp", "]", ")", "\n", "\n", "", "self", ".", "expectation_value_candidates", "=", "expectation_value_candidates", "\n", "\n", "", "if", "sign_recovery", "==", "'all_positive'", ":", "\n", "# all signs are already positive", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "print", "(", "'{} sign recovery not implemented'", ".", "format", "(", "sign_recovery", ")", ")", "\n", "return", "\n", "\n", "", "if", "self", ".", "allow_abstentions", ":", "\n", "# probability is 0.5 * (1 + expectation - P(lambda part of factor is zero)) * P(conditional)", "\n", "# P(conditional) is 1 if there is no conditional", "\n", "            ", "probabilities", "=", "{", "}", "\n", "for", "expectation", "in", "sorted", "(", "list", "(", "expectation_values", ".", "keys", "(", ")", ")", ")", ":", "\n", "                ", "exp_value", "=", "expectation_values", "[", "expectation", "]", "\n", "if", "expectation", "[", "1", "]", "[", "0", "]", "==", "'0'", ":", "\n", "                    ", "condition_prob", "=", "1", "\n", "", "else", ":", "\n", "                    ", "zero_condition", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "expectation", "[", "1", "]", "]", ")", ")", "\n", "condition_prob", "=", "lambda_zeros", "[", "zero_condition", "]", "\n", "\n", "", "lambda_factor", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "expectation", "[", "0", "]", "[", ":", "-", "1", "]", "]", ")", ")", "\n", "abstention_prob", "=", "abstention_probabilities", "[", "lambda_factor", "]", "\n", "\n", "probabilities", "[", "expectation", "]", "=", "0.5", "*", "(", "1", "+", "exp_value", "-", "abstention_prob", ")", "*", "condition_prob", "\n", "", "", "else", ":", "\n", "            ", "probabilities", "=", "{", "\n", "expectation", ":", "0.5", "*", "(", "1", "+", "expectation_values", "[", "expectation", "]", ")", "\n", "for", "expectation", "in", "sorted", "(", "list", "(", "expectation_values", ".", "keys", "(", ")", ")", ")", "\n", "}", "\n", "\n", "\n", "", "return", "probabilities", ",", "expectation_values", "\n", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.__init__": [[18, 89], ["pgmpy.models.MarkovModel", "pgmpy.models.MarkovModel.add_nodes_from", "pgmpy.models.MarkovModel.add_nodes_from", "pgmpy.models.MarkovModel.add_edges_from", "pgmpy.models.MarkovModel.add_edges_from", "pgmpy.models.MarkovModel.add_edges_from", "label_model.LabelModel.G.to_junction_tree", "sorted", "set", "NotImplementedError", "list", "random.seed", "random.shuffle", "label_model.LabelModel._check", "NotImplementedError", "tuple", "range", "range", "range", "sorted", "list", "set().intersection", "set", "set"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._graphs.Mixin._check"], ["    ", "def", "__init__", "(", "self", ",", "m", ",", "v", "=", "1", ",", "y_edges", "=", "[", "]", ",", "lambda_y_edges", "=", "[", "]", ",", "lambda_edges", "=", "[", "]", ",", "\n", "allow_abstentions", "=", "True", ",", "triplets", "=", "None", ",", "triplet_seed", "=", "0", ")", ":", "\n", "        ", "'''Initialize the LabelModel with a graph G.\n        \n        m: number of LF's\n        v: number of Y tasks\n        y_edges: edges between the tasks. (i, j) in y_edges means that\n            there is an edge between y_i and y_j.\n        lambda_y_edges: edges between LF's and tasks. (i, j) in lambda_y_edges\n            means that there is an edge between lambda_i and y_j. If this list\n            is empty, assume that all labeling functions are connected to Y_0.\n        lambda_edges: edges between LF's. (i, j) in lambda_edges means that\n            there is an edge between lambda_i and lambda_j.\n        allow_abstentions: if True, allow abstentions in L_train.\n        triplets: if specified, use these triplets\n        triplet_seed: if triplets not specified, randomly shuffle the nodes\n            with this seed when generating triplets\n        '''", "\n", "if", "lambda_y_edges", "==", "[", "]", ":", "\n", "            ", "lambda_y_edges", "=", "[", "(", "i", ",", "0", ")", "for", "i", "in", "range", "(", "m", ")", "]", "\n", "\n", "", "G", "=", "MarkovModel", "(", ")", "\n", "# Add LF nodes", "\n", "G", ".", "add_nodes_from", "(", "[", "\n", "'lambda_{}'", ".", "format", "(", "i", ")", "\n", "for", "i", "in", "range", "(", "m", ")", "\n", "]", ")", "\n", "G", ".", "add_nodes_from", "(", "[", "\n", "'Y_{}'", ".", "format", "(", "i", ")", "\n", "for", "i", "in", "range", "(", "v", ")", "\n", "]", ")", "\n", "\n", "# Add edges", "\n", "G", ".", "add_edges_from", "(", "[", "\n", "(", "'Y_{}'", ".", "format", "(", "start", ")", ",", "'Y_{}'", ".", "format", "(", "end", ")", ")", "\n", "for", "start", ",", "end", "in", "y_edges", "\n", "]", ")", "\n", "G", ".", "add_edges_from", "(", "[", "\n", "(", "'lambda_{}'", ".", "format", "(", "start", ")", ",", "'Y_{}'", ".", "format", "(", "end", ")", ")", "\n", "for", "start", ",", "end", "in", "lambda_y_edges", "\n", "]", ")", "\n", "G", ".", "add_edges_from", "(", "[", "\n", "(", "'lambda_{}'", ".", "format", "(", "start", ")", ",", "'lambda_{}'", ".", "format", "(", "end", ")", ")", "\n", "for", "start", ",", "end", "in", "lambda_edges", "\n", "]", ")", "\n", "\n", "self", ".", "fully_independent_case", "=", "lambda_edges", "==", "[", "]", "\n", "\n", "self", ".", "m", "=", "m", "\n", "if", "m", "<", "3", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Triplet method needs at least three LF's to run.\"", ")", "\n", "", "self", ".", "v", "=", "v", "\n", "self", ".", "G", "=", "G", "\n", "self", ".", "junction_tree", "=", "self", ".", "G", ".", "to_junction_tree", "(", ")", "\n", "\n", "self", ".", "nodes", "=", "sorted", "(", "list", "(", "self", ".", "G", ".", "nodes", ")", ")", "\n", "self", ".", "triplet_seed", "=", "triplet_seed", "\n", "if", "triplet_seed", "is", "not", "None", ":", "\n", "            ", "random", ".", "seed", "(", "triplet_seed", ")", "\n", "random", ".", "shuffle", "(", "self", ".", "nodes", ")", "\n", "\n", "", "self", ".", "separator_sets", "=", "set", "(", "[", "\n", "tuple", "(", "sorted", "(", "list", "(", "(", "set", "(", "clique1", ")", ".", "intersection", "(", "set", "(", "clique2", ")", ")", ")", ")", ")", ")", "\n", "for", "clique1", ",", "clique2", "in", "self", ".", "junction_tree", ".", "edges", "\n", "]", ")", "\n", "\n", "self", ".", "allow_abstentions", "=", "allow_abstentions", "\n", "self", ".", "triplets", "=", "triplets", "\n", "\n", "if", "not", "self", ".", "_check", "(", ")", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Cannot run triplet method for specified graph.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.save": [[91, 93], ["None"], "methods", ["None"], ["", "", "def", "save", "(", "obj", ")", ":", "\n", "        ", "return", "(", "obj", ".", "__class__", ",", "obj", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.load": [[94, 98], ["cls.__new__", "cls.__new__.__dict__.update"], "methods", ["None"], ["", "def", "load", "(", "cls", ",", "attributes", ")", ":", "\n", "        ", "obj", "=", "cls", ".", "__new__", "(", "cls", ")", "\n", "obj", ".", "__dict__", ".", "update", "(", "attributes", ")", "\n", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.enumerate_ys": [[99, 108], ["sorted", "range", "dict_product", "range"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.helpers.dict_product"], ["", "def", "enumerate_ys", "(", "self", ")", ":", "\n", "# order to output probabilities", "\n", "        ", "vals", "=", "{", "Y", ":", "(", "-", "1", ",", "1", ")", "for", "Y", "in", "range", "(", "self", ".", "v", ")", "}", "\n", "Y_vecs", "=", "sorted", "(", "[", "\n", "[", "vec_dict", "[", "Y", "]", "for", "Y", "in", "range", "(", "self", ".", "v", ")", "]", "\n", "for", "vec_dict", "in", "dict_product", "(", "vals", ")", "\n", "]", ")", "\n", "\n", "return", "Y_vecs", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel._lambda_pass": [[109, 319], ["lambda_marginals.update", "lambda_moment_vals.update", "lambda_equals_one.update", "lambda_zeros.update", "abstention_probabilities.update", "numpy.einsum", "numpy.einsum", "pgmpy.factors.discrete.JointProbabilityDistribution", "len", "len", "len", "len", "len", "len", "sorted", "tqdm.tqdm.tqdm", "pgmpy.factors.discrete.JointProbabilityDistribution", "len", "len", "len", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "tuple", "len", "len", "type", "type", "len", "type", "type", "len", "type", "type", "numpy.prod", "numpy.prod", "type", "type", "numpy.count_nonzero", "numpy.prod", "dict_product", "tuple", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.prod", "float", "len", "numpy.prod", "tuple"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.helpers.dict_product"], ["", "def", "_lambda_pass", "(", "self", ",", "L_train", ",", "lambda_marginals", ",", "lambda_moment_vals", ",", "lambda_equals_one", ",", "\n", "lambda_zeros", ",", "abstention_probabilities", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "'''\n        Make the pass over L_train.\n        \n        In this pass, we need to:\n        * Compute all the joint marginal distributions over multiple lambda's (lambda_marginals)\n        * Compute the probabilities that some set of lambda's are all equal to zero (lambda_zeros)\n        * Compute all the lambda moments, including conditional moments (lambda_moment_vals)\n        * Compute the probability that the product of some lambdas is zero (abstention_probabilities)\n        '''", "\n", "\n", "# do the fast cases first", "\n", "easy_marginals", "=", "{", "\n", "marginal", ":", "None", "\n", "for", "marginal", "in", "lambda_marginals", "\n", "if", "len", "(", "marginal", ")", "==", "1", "\n", "}", "\n", "easy_moments", "=", "{", "\n", "moment", ":", "None", "\n", "for", "moment", "in", "lambda_moment_vals", "\n", "if", "type", "(", "moment", "[", "0", "]", ")", "!=", "type", "(", "(", ")", ")", "and", "len", "(", "moment", ")", "<=", "2", "\n", "}", "\n", "easy_equals_one", "=", "{", "\n", "factor", ":", "None", "\n", "for", "factor", "in", "lambda_equals_one", "\n", "if", "type", "(", "factor", "[", "0", "]", ")", "!=", "type", "(", "(", ")", ")", "and", "len", "(", "factor", ")", "==", "1", "\n", "}", "\n", "easy_zeros", "=", "{", "\n", "condition", ":", "None", "\n", "for", "condition", "in", "lambda_zeros", "if", "len", "(", "condition", ")", "==", "1", "\n", "}", "\n", "easy_abstention_probs", "=", "{", "\n", "factor", ":", "None", "\n", "for", "factor", "in", "abstention_probabilities", "if", "len", "(", "factor", ")", "==", "1", "\n", "}", "\n", "\n", "means", "=", "np", ".", "einsum", "(", "'ij->j'", ",", "L_train", ")", "/", "L_train", ".", "shape", "[", "0", "]", "\n", "covariance", "=", "np", ".", "einsum", "(", "'ij,ik->jk'", ",", "L_train", ",", "L_train", ")", "/", "L_train", ".", "shape", "[", "0", "]", "\n", "\n", "lf_cardinality", "=", "3", "if", "self", ".", "allow_abstentions", "else", "2", "\n", "lf_values", "=", "(", "-", "1", ",", "0", ",", "1", ")", "if", "self", ".", "allow_abstentions", "else", "(", "-", "1", ",", "1", ")", "\n", "for", "marginal", "in", "easy_marginals", ":", "\n", "            ", "idx", "=", "marginal", "[", "0", "]", "\n", "counts", "=", "[", "np", ".", "sum", "(", "L_train", "[", ":", ",", "idx", "]", "==", "val", ")", "/", "L_train", ".", "shape", "[", "0", "]", "for", "val", "in", "lf_values", "]", "\n", "easy_marginals", "[", "marginal", "]", "=", "JointProbabilityDistribution", "(", "\n", "[", "'lambda_{}'", ".", "format", "(", "idx", ")", "]", ",", "[", "lf_cardinality", "]", ",", "counts", "\n", ")", "\n", "\n", "if", "marginal", "in", "easy_equals_one", ":", "\n", "                ", "easy_equals_one", "[", "marginal", "]", "=", "counts", "[", "-", "1", "]", "\n", "", "if", "marginal", "in", "easy_zeros", ":", "\n", "                ", "easy_zeros", "[", "marginal", "]", "=", "counts", "[", "1", "]", "\n", "", "if", "marginal", "in", "easy_abstention_probs", ":", "\n", "                ", "easy_abstention_probs", "[", "marginal", "]", "=", "counts", "[", "1", "]", "\n", "", "", "for", "moment", "in", "easy_moments", ":", "\n", "            ", "if", "len", "(", "moment", ")", "==", "1", ":", "\n", "                ", "easy_moments", "[", "moment", "]", "=", "means", "[", "moment", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "                ", "easy_moments", "[", "moment", "]", "=", "covariance", "[", "moment", "[", "0", "]", "]", "[", "moment", "[", "1", "]", "]", "\n", "", "", "for", "factor", "in", "easy_equals_one", ":", "\n", "            ", "if", "easy_equals_one", "[", "factor", "]", "is", "None", ":", "\n", "                ", "easy_equals_one", "[", "factor", "]", "=", "np", ".", "sum", "(", "L_train", "[", ":", ",", "factor", "[", "0", "]", "]", "==", "1", ")", "/", "L_train", ".", "shape", "[", "0", "]", "\n", "", "", "for", "condition", "in", "easy_zeros", ":", "\n", "            ", "if", "easy_zeros", "[", "condition", "]", "is", "None", ":", "\n", "                ", "idx", "=", "condition", "[", "0", "]", "\n", "easy_zeros", "[", "condition", "]", "=", "np", ".", "sum", "(", "L_train", "[", ":", ",", "idx", "]", "==", "0", ")", "/", "L_train", ".", "shape", "[", "0", "]", "\n", "", "", "for", "factor", "in", "easy_abstention_probs", ":", "\n", "            ", "if", "easy_abstention_probs", "[", "factor", "]", "is", "None", ":", "\n", "                ", "idx", "=", "factor", "[", "0", "]", "\n", "easy_abstention_probs", "[", "factor", "]", "=", "np", ".", "sum", "(", "L_train", "[", ":", ",", "idx", "]", "==", "0", ")", "/", "L_train", ".", "shape", "[", "0", "]", "\n", "\n", "# time for the remaining cases", "\n", "", "", "lambda_marginals", "=", "{", "\n", "key", ":", "lambda_marginals", "[", "key", "]", "\n", "for", "key", "in", "lambda_marginals", "\n", "if", "key", "not", "in", "easy_marginals", "\n", "}", "\n", "lambda_moment_vals", "=", "{", "\n", "key", ":", "lambda_moment_vals", "[", "key", "]", "\n", "for", "key", "in", "lambda_moment_vals", "\n", "if", "key", "not", "in", "easy_moments", "\n", "}", "\n", "lambda_equals_one", "=", "{", "\n", "key", ":", "lambda_equals_one", "[", "key", "]", "\n", "for", "key", "in", "lambda_equals_one", "\n", "if", "key", "not", "in", "easy_equals_one", "\n", "}", "\n", "lambda_zeros", "=", "{", "\n", "key", ":", "lambda_zeros", "[", "key", "]", "\n", "for", "key", "in", "lambda_zeros", "\n", "if", "key", "not", "in", "easy_zeros", "\n", "}", "\n", "abstention_probabilities", "=", "{", "\n", "key", ":", "abstention_probabilities", "[", "key", "]", "\n", "for", "key", "in", "abstention_probabilities", "\n", "if", "key", "not", "in", "easy_abstention_probs", "\n", "}", "\n", "\n", "# for the rest, loop through L_train", "\n", "if", "(", "len", "(", "lambda_marginals", ")", ">", "0", "or", "len", "(", "lambda_moment_vals", ")", ">", "0", "or", "\n", "len", "(", "lambda_equals_one", ")", ">", "0", "or", "len", "(", "lambda_zeros", ")", ">", "0", "or", "\n", "len", "(", "abstention_probabilities", ")", ">", "0", ")", ":", "\n", "\n", "# figure out which lambda states we need to keep track of", "\n", "            ", "lambda_marginal_counts", "=", "{", "}", "\n", "lambda_marginal_vecs", "=", "{", "}", "\n", "lf_values", "=", "(", "-", "1", ",", "0", ",", "1", ")", "if", "self", ".", "allow_abstentions", "else", "(", "-", "1", ",", "1", ")", "\n", "for", "lambda_marginal", "in", "lambda_marginals", ":", "\n", "                ", "nodes", "=", "[", "'lambda_{}'", ".", "format", "(", "idx", ")", "for", "idx", "in", "lambda_marginal", "]", "\n", "vals", "=", "{", "lf", ":", "lf_values", "for", "lf", "in", "nodes", "}", "\n", "lf_vecs", "=", "sorted", "(", "[", "\n", "[", "vec_dict", "[", "lf", "]", "for", "lf", "in", "nodes", "]", "\n", "for", "vec_dict", "in", "dict_product", "(", "vals", ")", "\n", "]", ")", "\n", "counts", "=", "{", "\n", "tuple", "(", "lf_vec", ")", ":", "0", "\n", "for", "lf_vec", "in", "lf_vecs", "\n", "}", "\n", "lambda_marginal_vecs", "[", "lambda_marginal", "]", "=", "lf_vecs", "\n", "lambda_marginal_counts", "[", "lambda_marginal", "]", "=", "counts", "\n", "\n", "", "lambda_moment_counts", "=", "{", "moment", ":", "0", "for", "moment", "in", "lambda_moment_vals", "}", "\n", "lambda_moment_basis", "=", "{", "moment", ":", "0", "for", "moment", "in", "lambda_moment_vals", "}", "\n", "lambda_equals_one_counts", "=", "{", "factor", ":", "0", "for", "factor", "in", "lambda_equals_one", "}", "\n", "lambda_equals_one_basis", "=", "{", "factor", ":", "0", "for", "factor", "in", "lambda_equals_one", "}", "\n", "lambda_zero_counts", "=", "{", "condition", ":", "0", "for", "condition", "in", "lambda_zeros", "}", "\n", "abstention_probability_counts", "=", "{", "factor", ":", "0", "for", "factor", "in", "abstention_probabilities", "}", "\n", "\n", "for", "data_point", "in", "tqdm", "(", "L_train", ")", "if", "verbose", "else", "L_train", ":", "\n", "                ", "for", "marginal", "in", "lambda_marginals", ":", "\n", "                    ", "mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "marginal", "]", "\n", "lambda_marginal_counts", "[", "marginal", "]", "[", "tuple", "(", "mask", ")", "]", "+=", "1", "\n", "", "for", "moment", "in", "lambda_moment_vals", ":", "\n", "                    ", "if", "type", "(", "moment", "[", "0", "]", ")", "==", "type", "(", "(", ")", ")", ":", "\n", "                        ", "pos_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "moment", "[", "0", "]", "]", "\n", "zero_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "moment", "[", "1", "]", "]", "\n", "\n", "if", "np", ".", "count_nonzero", "(", "zero_mask", ")", "==", "0", ":", "\n", "                            ", "lambda_moment_basis", "[", "moment", "]", "+=", "1", "\n", "", "lambda_moment_counts", "[", "moment", "]", "+=", "np", ".", "prod", "(", "pos_mask", ")", "\n", "", "else", ":", "\n", "                        ", "mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "moment", "]", "\n", "lambda_moment_counts", "[", "moment", "]", "+=", "np", ".", "prod", "(", "mask", ")", "\n", "lambda_moment_basis", "[", "moment", "]", "+=", "1", "\n", "", "", "for", "factor", "in", "lambda_equals_one", ":", "\n", "                    ", "if", "type", "(", "factor", "[", "0", "]", ")", "==", "type", "(", "(", ")", ")", ":", "\n", "                        ", "pos_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "factor", "[", "0", "]", "]", "\n", "zero_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "factor", "[", "1", "]", "]", "\n", "\n", "if", "np", ".", "count_nonzero", "(", "zero_mask", ")", "==", "0", ":", "\n", "                            ", "lambda_equals_one_basis", "[", "factor", "]", "+=", "1", "\n", "if", "np", ".", "prod", "(", "pos_mask", ")", "==", "1", ":", "\n", "                                ", "lambda_equals_one_counts", "[", "factor", "]", "+=", "1", "\n", "", "", "", "else", ":", "\n", "                        ", "mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "factor", "]", "\n", "if", "np", ".", "prod", "(", "mask", ")", "==", "1", ":", "\n", "                            ", "lambda_equals_one_counts", "[", "factor", "]", "+=", "1", "\n", "", "lambda_equals_one_basis", "[", "factor", "]", "+=", "1", "\n", "", "", "for", "zero_condition", "in", "lambda_zeros", ":", "\n", "                    ", "zero_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "zero_condition", "]", "\n", "if", "np", ".", "count_nonzero", "(", "zero_mask", ")", "==", "0", ":", "\n", "                        ", "lambda_zero_counts", "[", "zero_condition", "]", "+=", "1", "\n", "", "", "for", "factor", "in", "abstention_probability_counts", ":", "\n", "                    ", "zero_mask", "=", "[", "data_point", "[", "idx", "]", "for", "idx", "in", "factor", "]", "\n", "if", "np", ".", "prod", "(", "zero_mask", ")", "==", "0", ":", "\n", "                        ", "abstention_probability_counts", "[", "factor", "]", "+=", "1", "\n", "\n", "", "", "", "lf_cardinality", "=", "3", "if", "self", ".", "allow_abstentions", "else", "2", "\n", "for", "marginal", "in", "lambda_marginals", ":", "\n", "                ", "nodes", "=", "[", "'lambda_{}'", ".", "format", "(", "idx", ")", "for", "idx", "in", "marginal", "]", "\n", "lf_vecs", "=", "lambda_marginal_vecs", "[", "marginal", "]", "\n", "counts", "=", "lambda_marginal_counts", "[", "marginal", "]", "\n", "\n", "lambda_marginals", "[", "marginal", "]", "=", "JointProbabilityDistribution", "(", "\n", "nodes", ",", "[", "lf_cardinality", "for", "node", "in", "nodes", "]", ",", "\n", "[", "\n", "float", "(", "counts", "[", "tuple", "(", "lf_vec", ")", "]", ")", "/", "len", "(", "L_train", ")", "\n", "for", "lf_vec", "in", "lf_vecs", "\n", "]", "\n", ")", "\n", "\n", "", "for", "moment", "in", "lambda_moment_vals", ":", "\n", "                ", "if", "lambda_moment_basis", "[", "moment", "]", "==", "0", ":", "\n", "                    ", "moment_val", "=", "0", "\n", "", "else", ":", "\n", "                    ", "moment_val", "=", "lambda_moment_counts", "[", "moment", "]", "/", "lambda_moment_basis", "[", "moment", "]", "\n", "", "lambda_moment_vals", "[", "moment", "]", "=", "moment_val", "\n", "\n", "", "for", "factor", "in", "lambda_equals_one", ":", "\n", "                ", "if", "lambda_equals_one_basis", "[", "factor", "]", "==", "0", ":", "\n", "                    ", "prob", "=", "0", "\n", "", "else", ":", "\n", "                    ", "prob", "=", "lambda_equals_one_counts", "[", "factor", "]", "/", "lambda_equals_one_basis", "[", "factor", "]", "\n", "", "lambda_equals_one", "[", "factor", "]", "=", "prob", "\n", "\n", "", "for", "zero_condition", "in", "lambda_zeros", ":", "\n", "                ", "lambda_zeros", "[", "zero_condition", "]", "=", "lambda_zero_counts", "[", "zero_condition", "]", "/", "len", "(", "L_train", ")", "\n", "\n", "", "for", "factor", "in", "abstention_probabilities", ":", "\n", "                ", "abstention_probabilities", "[", "factor", "]", "=", "abstention_probability_counts", "[", "factor", "]", "/", "len", "(", "L_train", ")", "\n", "\n", "# update with the easy values", "\n", "", "", "lambda_marginals", ".", "update", "(", "easy_marginals", ")", "\n", "lambda_moment_vals", ".", "update", "(", "easy_moments", ")", "\n", "lambda_equals_one", ".", "update", "(", "easy_equals_one", ")", "\n", "lambda_zeros", ".", "update", "(", "easy_zeros", ")", "\n", "abstention_probabilities", ".", "update", "(", "easy_abstention_probs", ")", "\n", "\n", "return", "lambda_marginals", ",", "lambda_moment_vals", ",", "lambda_equals_one", ",", "lambda_zeros", ",", "abstention_probabilities", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.fit": [[320, 703], ["enumerate", "set", "label_model.LabelModel._compute_class_balance", "label_model.LabelModel._compute_Y_marginals", "label_model.LabelModel._compute_Y_equals_one", "label_model.LabelModel._lambda_pass", "len", "len", "tuple", "print", "list", "label_model.LabelModel._generate_r_vector", "print", "print", "label_model.LabelModel._triplet_method_preprocess", "print", "print", "print", "print", "tuple", "label_model.LabelModel._triplet_method_probabilities", "print", "print", "list", "numpy.array", "label_model.LabelModel._generate_e_vector", "label_model.LabelModel._generate_b_matrix", "numpy.array", "sorted", "pgmpy.factors.discrete.DiscreteFactor().normalize", "numpy.count_nonzero", "print", "observable_cliques.append", "non_observable_cliques.append", "sorted", "reversed", "print", "sorted", "print", "reversed", "numpy.linalg.inv", "sum", "int", "len", "len", "sorted", "sorted", "tuple", "tuple", "tuple", "tuple", "label_model.LabelModel.fit.num_Ys"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_class_balance", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_Y_marginals", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_Y_equals_one", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel._lambda_pass", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_r_vector", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_preprocess", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._triplets.Mixin._triplet_method_probabilities", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_e_vector", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._lm_parameters.Mixin._generate_b_matrix"], ["", "def", "fit", "(", "self", ",", "L_train", ",", "class_balance", "=", "None", ",", "Y_dev", "=", "None", ",", "flip_negative", "=", "True", ",", "clamp", "=", "True", ",", "\n", "solve_method", "=", "'triplet_mean'", ",", "\n", "sign_recovery", "=", "'all_positive'", ",", "\n", "verbose", "=", "False", ")", ":", "\n", "        ", "'''Compute the marginal probabilities of each clique and separator set in the junction tree.\n        \n        L_train: an m x n matrix of LF outputs. L_train[k][i] is the value of \\lambda_i on item k.\n            1 means positive, -1 means negative, 0 means abstain.\n        class_balance: a 2^v vector of the probabilities of each combination of Y values. Sorted in\n          lexicographical order (entry zero is for Y_0 = -1, ..., Y_{v-1} = -1, entry one is for\n          Y_0 = -1, ..., Y_{v-1} = 1, last entry is for Y_0 = 1, ..., Y_{v-1} = 1).\n        Y_dev: a v x |Y_dev| matrix of ground truth examples. If class_balance is not specified, this\n          is used to find out the class balance. Otherwise not used.\n          If this is not specified, and class_balance is not specified, then class balance is uniform.\n          1 means positive, -1 means negative.\n        flip_negative: if True, flip sign of negative probabilities\n        clamp: if True and flip_negative is not True, set negative probabilities to 0\n        solve_method: one of ['triplet_mean', 'triplet_median', 'triplet', 'independencies']\n          If triplet, use the method below and the independencies we write down there.\n          If independencies, use the following facts:\n            * For any lambda_i: lambda_i * Y and Y are independent for any i, so\n              E[lambda_i Y] = E[lambda_i] / E[Y]\n            * For any lambda_i, lambda_j: E[lambda_i * lambda_j * Y] = E[lambda_i * lambda_j] * E[Y]\n            * For an odd number of lambda's, the first property holds; for an even number, the second\n              property holds\n          Only triplet implemented right now.\n        sign_recovery: one of ['all_positive', 'fully_independent']\n          If all_positive, assume that all accuracies that we compute are positive.\n          If fully_independent, assume that the accuracy of lambda_0 on Y_0 is positive, and that for\n            any lambda_i and lambda_{i+1}, sign(lambda_i lambda_{i+1}) = sign(M_{i,i+1}) where M_{i, i+1}\n            is the second moment between lambda_0 and lambda_i.\n          If solve_method is independencies, we don't need to do this.\n          Only all_positive implemented right now.\n        verbose: if True, print out messages to stderr as we make progress\n        \n        How we go about solving these probabilities (for Triplet method):\n          * We assume that we have the joint distribution/class balance of our Y's (or can infer it\n            from the dev set).\n          * We observe agreements and disagreements between LF's, so we can compute values like\n            P(\\lambda_i \\lambda_j = 1).\n          * The only thing we need to estimate now are correlations between LF's and (unseen) Y's -\n            values like P(\\lambda_i Y_j = 1).\n          * Luckily, we have P(\\lambda_i Y_j = 1) = 1/2(1 + E[\\lambda_i Y_j]). We refer to E[\\lambda_i Y_j]\n            as the accuracy of \\lambda_i on Y_j.\n          * And because of the format of our exponential model, we have:\n              E[\\lambda_i Y_j]E[\\lambda_k Y_j] = E[\\lambda_i Y_j \\lambda_k Y_j] = E[\\lambda_i \\lambda_k]\n            For any \\lambda_i, \\lambda_k that are conditionally independent given Y_j. This translates to\n              Y_j being a separator of \\lambda_i and \\lambda_k in our graphical model.\n            And we can observe E[\\lambda_i \\lambda_k] (the second moment) from L_train!\n          * The algorithm proceeds to estimate the marginal probabilities by picking out triplets of\n            conditionally-independent subsets of LF's, and estimating the accuracies of LF's on Y's.\n          * Then, to recover the joint probabilities, we can solve a linear system B e = r (written out in latex):\n          \n              $$\\begin{align*}\n                \\begin{bmatrix}\n                1 & 1 & 1 & 1 \\\\\n                1 & 0 & 1 & 0 \\\\\n                1 & 1 & 0 & 0 \\\\\n                1 & 0 & 0 &1\n                \\end{bmatrix}\n                \\begin{bmatrix}\n                p_{\\lambda_i, Y_j}(+1, +1)\\\\ \n                p_{\\lambda_i, Y_j}(-1, +1)  \\\\ \n                p_{\\lambda_i, Y_j}(+1, -1) \\\\ \n                p_{\\lambda_i, Y_j}(-1, -1) \\end{bmatrix} = \n                \\begin{bmatrix} 1 \\\\ \n                P(\\lambda_{i} = 1) \\\\ \n                P(Y_j = 1)  \\\\ \n                \\rho_{i, j} \\end{bmatrix} .\n                \\end{align*}$$\n            \n              The values on the left of the equality are an invertible matrix, and values like\n              P(\\lambda_i = 1, Y_j = 1), P(\\lambda_i = -1, Y_j = 1), etc for the full marginal probability.\n              The values on the left of the equality are [1, P(\\lambda_i = 1), P(Y_j = 1), P(\\lambda_i = Y_j)]^T.\n              We can observe or solve for all the values on the right, to solve for the values in the marginal\n              probability!\n              This can also be extended to multiple dimensions.\n            \n            Outputs: None.\n        '''", "\n", "# if abstentions not allowed, check for zero's", "\n", "if", "not", "self", ".", "allow_abstentions", ":", "\n", "            ", "if", "np", ".", "count_nonzero", "(", "L_train", ")", "<", "L_train", ".", "shape", "[", "0", "]", "*", "L_train", ".", "shape", "[", "1", "]", ":", "\n", "                ", "print", "(", "'Abstentions not allowed!'", ")", "\n", "return", "\n", "\n", "# Y marginals to compute", "\n", "", "", "Y_marginals", "=", "{", "}", "\n", "\n", "# lambda marginals to compute", "\n", "lambda_marginals", "=", "{", "}", "\n", "\n", "# marginals will eventually be returned here", "\n", "marginals", "=", "[", "\n", "(", "clique", ",", "None", ")", "\n", "for", "clique", "in", "sorted", "(", "list", "(", "self", ".", "junction_tree", ".", "nodes", ")", ")", "+", "sorted", "(", "list", "(", "self", ".", "separator_sets", ")", ")", "\n", "]", "\n", "\n", "def", "num_Ys", "(", "nodes", ")", ":", "\n", "            ", "if", "nodes", "==", "tuple", "(", "[", "1", "]", ")", "or", "nodes", "==", "tuple", "(", "[", "0", "]", ")", ":", "\n", "                ", "return", "0", "\n", "", "return", "len", "(", "[", "\n", "node", "for", "node", "in", "nodes", "if", "'Y'", "in", "node", "\n", "]", ")", "\n", "\n", "", "def", "num_lambdas", "(", "nodes", ")", ":", "\n", "            ", "if", "nodes", "==", "tuple", "(", "[", "1", "]", ")", "or", "nodes", "==", "tuple", "(", "[", "0", "]", ")", ":", "\n", "                ", "return", "0", "\n", "", "return", "len", "(", "[", "\n", "node", "for", "node", "in", "nodes", "if", "'lambda'", "in", "node", "\n", "]", ")", "\n", "\n", "", "observable_cliques", "=", "[", "]", "\n", "non_observable_cliques", "=", "[", "]", "\n", "\n", "for", "i", ",", "(", "clique", ",", "_", ")", "in", "enumerate", "(", "marginals", ")", ":", "\n", "            ", "if", "num_Ys", "(", "clique", ")", "==", "0", "or", "num_lambdas", "(", "clique", ")", "==", "0", ":", "\n", "                ", "observable_cliques", ".", "append", "(", "i", ")", "\n", "", "else", ":", "\n", "                ", "non_observable_cliques", ".", "append", "(", "i", ")", "\n", "\n", "# write down everything we need for the observable cliques", "\n", "", "", "for", "idx", "in", "observable_cliques", ":", "\n", "            ", "clique", "=", "marginals", "[", "idx", "]", "[", "0", "]", "\n", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "clique", "]", ")", ")", "\n", "\n", "if", "'Y'", "in", "clique", "[", "0", "]", ":", "\n", "                ", "if", "indices", "not", "in", "Y_marginals", ":", "\n", "                    ", "Y_marginals", "[", "indices", "]", "=", "None", "\n", "", "", "else", ":", "\n", "                ", "if", "indices", "not", "in", "lambda_marginals", ":", "\n", "                    ", "lambda_marginals", "[", "indices", "]", "=", "None", "\n", "\n", "", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Marginals written down'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# for each marginal we need to estimate, write down the r vector that we need", "\n", "", "r_vecs", "=", "{", "}", "# mapping from clique index to the r vector", "\n", "r_vals", "=", "{", "}", "# mapping from a value name (like Y_1 or tuple(lambda_1, Y_1)) to its value", "\n", "for", "idx", "in", "non_observable_cliques", ":", "\n", "            ", "clique", "=", "list", "(", "reversed", "(", "sorted", "(", "marginals", "[", "idx", "]", "[", "0", "]", ")", ")", ")", "\n", "r_vec", "=", "self", ".", "_generate_r_vector", "(", "clique", ")", "\n", "r_vecs", "[", "idx", "]", "=", "r_vec", "\n", "for", "r_val", "in", "r_vec", ":", "\n", "                ", "if", "r_val", "not", "in", "r_vals", ":", "\n", "                    ", "r_vals", "[", "r_val", "]", "=", "None", "\n", "\n", "", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'R vector written down'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# write down all the sets of zero conditions", "\n", "", "lambda_zeros", "=", "{", "}", "\n", "\n", "# write down the moment values that we need to keep track of when we walk through the L matrix", "\n", "Y_equals_one", "=", "{", "}", "\n", "lambda_equals_one", "=", "{", "}", "\n", "\n", "# write down which expectations we need to solve using the triplet method", "\n", "expectations_to_estimate", "=", "set", "(", ")", "\n", "for", "r_val", "in", "r_vals", ":", "\n", "            ", "if", "not", "self", ".", "allow_abstentions", "or", "r_val", "[", "1", "]", "==", "tuple", "(", "[", "'0'", "]", ")", ":", "\n", "                ", "equals_one_tup", "=", "r_val", "if", "not", "self", ".", "allow_abstentions", "else", "r_val", "[", "0", "]", "\n", "\n", "if", "equals_one_tup", "[", "0", "]", "==", "'1'", ":", "\n", "# If the value is 1, the probability is just 1", "\n", "                    ", "r_vals", "[", "r_val", "]", "=", "1", "\n", "", "elif", "num_Ys", "(", "equals_one_tup", ")", "!=", "0", "and", "num_lambdas", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "# If this contains lambdas and Y's, we can't observe it", "\n", "                    ", "expectations_to_estimate", ".", "add", "(", "r_val", ")", "\n", "", "elif", "num_Ys", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "# We need to cache this moment", "\n", "                    ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "if", "indices", "not", "in", "Y_equals_one", ":", "\n", "                        ", "Y_equals_one", "[", "indices", "]", "=", "None", "\n", "", "", "elif", "num_lambdas", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "# If it contains just lambdas, go through L_train", "\n", "                    ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "if", "indices", "not", "in", "lambda_equals_one", ":", "\n", "                        ", "lambda_equals_one", "[", "indices", "]", "=", "None", "\n", "", "", "", "else", ":", "\n", "# we allow abstentions, and there are clauses that are equal to zero", "\n", "                ", "equals_one_tup", "=", "r_val", "[", "0", "]", "\n", "equals_zero_tup", "=", "r_val", "[", "1", "]", "\n", "if", "num_lambdas", "(", "equals_one_tup", ")", ">", "0", "and", "num_Ys", "(", "equals_one_tup", ")", ">", "0", ":", "\n", "# we can't observe this", "\n", "                    ", "expectations_to_estimate", ".", "add", "(", "r_val", ")", "\n", "", "elif", "num_lambdas", "(", "equals_one_tup", ")", ">", "0", ":", "\n", "# compute probability some lambda's multiply to one, subject to some zeros", "\n", "                    ", "pos_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "zero_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_zero_tup", "]", ")", ")", "\n", "\n", "tup", "=", "(", "pos_indices", ",", "zero_indices", ")", "\n", "if", "tup", "not", "in", "lambda_equals_one", ":", "\n", "                        ", "lambda_equals_one", "[", "tup", "]", "=", "None", "\n", "", "if", "zero_indices", "not", "in", "lambda_zeros", ":", "\n", "                        ", "lambda_zeros", "[", "zero_indices", "]", "=", "None", "\n", "", "", "else", ":", "\n", "# compute a Y equals one probability, and multiply it by probability of zeros", "\n", "                    ", "if", "equals_one_tup", "[", "0", "]", "!=", "'1'", ":", "\n", "                        ", "pos_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "if", "pos_indices", "not", "in", "Y_equals_one", ":", "\n", "                            ", "Y_equals_one", "[", "pos_indices", "]", "=", "None", "\n", "", "", "zero_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_zero_tup", "]", ")", ")", "\n", "if", "zero_indices", "not", "in", "lambda_zeros", ":", "\n", "                        ", "lambda_zeros", "[", "zero_indices", "]", "=", "None", "\n", "\n", "", "", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Expectations to estimate written down'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "if", "solve_method", "[", ":", "len", "(", "'triplet'", ")", "]", "==", "'triplet'", ":", "\n", "            ", "triplets", ",", "new_moment_vals", ",", "abstention_probabilities", "=", "self", ".", "_triplet_method_preprocess", "(", "\n", "expectations_to_estimate", ",", "solve_method", ")", "\n", "self", ".", "triplets", "=", "triplets", "\n", "", "elif", "solve_method", "==", "'independencies'", ":", "\n", "            ", "print", "(", "'Independencies not implemented yet!'", ")", "\n", "return", "\n", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'Triplets constructed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "lambda_moment_vals", "=", "{", "}", "\n", "for", "moment", "in", "new_moment_vals", ":", "\n", "            ", "if", "moment", "not", "in", "lambda_moment_vals", ":", "\n", "                ", "lambda_moment_vals", "[", "moment", "]", "=", "None", "\n", "\n", "# now time to compute all the Y marginals", "\n", "", "", "self", ".", "cb", "=", "self", ".", "_compute_class_balance", "(", "class_balance", ",", "Y_dev", ")", "\n", "Y_marginals", "=", "self", ".", "_compute_Y_marginals", "(", "Y_marginals", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Y marginals computed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "Y_equals_one", "=", "self", ".", "_compute_Y_equals_one", "(", "Y_equals_one", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Y equals one computed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "self", ".", "Y_marginals", "=", "Y_marginals", "\n", "self", ".", "Y_equals_one", "=", "Y_equals_one", "\n", "\n", "# now time to compute the lambda moments, marginals, zero conditions, and abstention probs", "\n", "lambda_marginals", ",", "lambda_moment_vals", ",", "lambda_equals_one", ",", "lambda_zeros", ",", "abstention_probabilities", "=", "self", ".", "_lambda_pass", "(", "\n", "L_train", ",", "lambda_marginals", ",", "lambda_moment_vals", ",", "lambda_equals_one", ",", "\n", "lambda_zeros", ",", "abstention_probabilities", ",", "verbose", "=", "verbose", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'lambda marginals, moments, conditions computed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "self", ".", "lambda_marginals", "=", "lambda_marginals", "\n", "self", ".", "lambda_moment_vals", "=", "lambda_moment_vals", "\n", "self", ".", "lambda_equals_one", "=", "lambda_equals_one", "\n", "self", ".", "lambda_zeros", "=", "lambda_zeros", "\n", "self", ".", "abstention_probabilities", "=", "abstention_probabilities", "\n", "\n", "# put observable cliques in the right place", "\n", "for", "idx", "in", "observable_cliques", ":", "\n", "            ", "clique", "=", "marginals", "[", "idx", "]", "[", "0", "]", "\n", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "clique", "]", ")", ")", "\n", "\n", "if", "'Y'", "in", "clique", "[", "0", "]", ":", "\n", "                ", "marginal", "=", "Y_marginals", "[", "indices", "]", "\n", "", "else", ":", "\n", "                ", "marginal", "=", "lambda_marginals", "[", "indices", "]", "\n", "\n", "", "marginals", "[", "idx", "]", "=", "(", "clique", ",", "marginal", ")", "\n", "\n", "# get unobserved probabilities", "\n", "", "if", "solve_method", "[", ":", "len", "(", "'triplet'", ")", "]", "==", "'triplet'", ":", "\n", "            ", "probability_values", ",", "expectation_values", "=", "self", ".", "_triplet_method_probabilities", "(", "\n", "triplets", ",", "lambda_moment_vals", ",", "lambda_zeros", ",", "\n", "abstention_probabilities", ",", "sign_recovery", ",", "solve_method", ")", "\n", "", "elif", "solve_method", "==", "'independencies'", ":", "\n", "            ", "print", "(", "'Independencies not implemented yet!'", ")", "\n", "return", "\n", "\n", "", "self", ".", "probability_values", "=", "probability_values", "\n", "self", ".", "expectation_values", "=", "expectation_values", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'Unobserved probabilities computed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# put values into the R vectors", "\n", "", "for", "r_val", "in", "r_vals", ":", "\n", "            ", "if", "not", "self", ".", "allow_abstentions", "or", "r_val", "[", "1", "]", "==", "tuple", "(", "[", "'0'", "]", ")", ":", "\n", "                ", "equals_one_tup", "=", "r_val", "if", "not", "self", ".", "allow_abstentions", "else", "r_val", "[", "0", "]", "\n", "\n", "if", "equals_one_tup", "[", "0", "]", "==", "'1'", ":", "\n", "# If the value is 1, the probability is just 1", "\n", "                    ", "pass", "\n", "", "elif", "num_Ys", "(", "equals_one_tup", ")", "!=", "0", "and", "num_lambdas", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "# If this contains lambdas and Y's, we can't observe it", "\n", "                    ", "r_vals", "[", "r_val", "]", "=", "probability_values", "[", "r_val", "]", "\n", "", "elif", "num_Ys", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "# We need to cache this moment", "\n", "                    ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "r_vals", "[", "r_val", "]", "=", "Y_equals_one", "[", "indices", "]", "\n", "", "elif", "num_lambdas", "(", "equals_one_tup", ")", "!=", "0", ":", "\n", "                    ", "indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "r_vals", "[", "r_val", "]", "=", "lambda_equals_one", "[", "indices", "]", "\n", "", "", "else", ":", "\n", "# we allow abstentions, and there are clauses that are equal to zero", "\n", "                ", "equals_one_tup", "=", "r_val", "[", "0", "]", "\n", "equals_zero_tup", "=", "r_val", "[", "1", "]", "\n", "if", "num_lambdas", "(", "equals_one_tup", ")", ">", "0", "and", "num_Ys", "(", "equals_one_tup", ")", ">", "0", ":", "\n", "# we can't observe this", "\n", "                    ", "r_vals", "[", "r_val", "]", "=", "probability_values", "[", "r_val", "]", "\n", "", "elif", "num_lambdas", "(", "equals_one_tup", ")", ">", "0", ":", "\n", "# compute lambda moment, subject to some zeros", "\n", "                    ", "pos_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "zero_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_zero_tup", "]", ")", ")", "\n", "\n", "tup", "=", "(", "pos_indices", ",", "zero_indices", ")", "\n", "r_vals", "[", "r_val", "]", "=", "lambda_equals_one", "[", "tup", "]", "\n", "", "else", ":", "\n", "# compute a Y moment, and multiply it by probability of zeros", "\n", "                    ", "if", "equals_one_tup", "[", "0", "]", "!=", "'1'", ":", "\n", "                        ", "pos_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_one_tup", "]", ")", ")", "\n", "\n", "pos_prob", "=", "Y_equals_one", "[", "pos_indices", "]", "\n", "", "else", ":", "\n", "                        ", "pos_prob", "=", "1.", "\n", "", "zero_indices", "=", "tuple", "(", "sorted", "(", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "equals_zero_tup", "]", ")", ")", "\n", "zero_probs", "=", "lambda_zeros", "[", "zero_indices", "]", "\n", "\n", "r_vals", "[", "r_val", "]", "=", "pos_prob", "*", "zero_probs", "\n", "\n", "", "", "", "self", ".", "r_vals", "=", "r_vals", "\n", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'R values computed'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# solve for marginal values", "\n", "", "for", "idx", "in", "non_observable_cliques", ":", "\n", "            ", "clique", "=", "list", "(", "reversed", "(", "sorted", "(", "marginals", "[", "idx", "]", "[", "0", "]", ")", ")", ")", "\n", "r_vec", "=", "r_vecs", "[", "idx", "]", "\n", "\n", "r_vec_vals", "=", "np", ".", "array", "(", "[", "r_vals", "[", "exp", "]", "for", "exp", "in", "r_vec", "]", ")", "\n", "\n", "# e_vec is the vector of marginal values", "\n", "e_vec", "=", "self", ".", "_generate_e_vector", "(", "clique", ")", "\n", "\n", "b_matrix", "=", "self", ".", "_generate_b_matrix", "(", "clique", ")", "\n", "\n", "e_vec_vals", "=", "np", ".", "linalg", ".", "inv", "(", "b_matrix", ")", "@", "r_vec_vals", "\n", "\n", "e_vec_val_index", "=", "{", "tup", ":", "i", "for", "i", ",", "tup", "in", "enumerate", "(", "e_vec", ")", "}", "\n", "marginal_vals", "=", "np", ".", "array", "(", "[", "\n", "e_vec_vals", "[", "e_vec_val_index", "[", "tup", "]", "]", "\n", "for", "tup", "in", "sorted", "(", "e_vec", ")", "\n", "]", ")", "\n", "\n", "if", "flip_negative", ":", "\n", "                ", "marginal_vals", "[", "marginal_vals", "<", "0", "]", "=", "marginal_vals", "[", "marginal_vals", "<", "0", "]", "*", "-", "1", "\n", "marginal_vals", "/=", "sum", "(", "marginal_vals", ")", "\n", "", "elif", "clamp", ":", "\n", "                ", "marginal_vals", "[", "marginal_vals", "<", "0", "]", "=", "1e-8", "\n", "marginal_vals", "/=", "sum", "(", "marginal_vals", ")", "\n", "\n", "", "indices", "=", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "for", "node", "in", "clique", "]", "\n", "lf_indices", "=", "sorted", "(", "indices", "[", ":", "-", "1", "]", ")", "\n", "Y_idx", "=", "indices", "[", "-", "1", "]", "\n", "\n", "variables", "=", "[", "'lambda_{}'", ".", "format", "(", "i", ")", "for", "i", "in", "lf_indices", "]", "+", "[", "'Y_{}'", ".", "format", "(", "Y_idx", ")", "]", "\n", "\n", "# cardinality 3 for lambda variables if you allow abstentions, 2 for Y's", "\n", "cardinalities", "=", "[", "\n", "3", "if", "self", ".", "allow_abstentions", "else", "2", "\n", "for", "i", "in", "range", "(", "len", "(", "lf_indices", ")", ")", "\n", "]", "+", "[", "2", "]", "\n", "\n", "marginal", "=", "DiscreteFactor", "(", "variables", ",", "cardinalities", ",", "marginal_vals", ")", ".", "normalize", "(", "inplace", "=", "False", ")", "\n", "\n", "marginals", "[", "idx", "]", "=", "(", "clique", ",", "marginal", ")", "\n", "\n", "", "self", ".", "clique_marginals", "=", "marginals", "[", ":", "len", "(", "self", ".", "junction_tree", ".", "nodes", ")", "]", "\n", "self", ".", "separator_marginals", "=", "marginals", "[", "len", "(", "self", ".", "junction_tree", ".", "nodes", ")", ":", "]", "\n", "separator_degrees", "=", "{", "\n", "sep", ":", "0", "\n", "for", "sep", "in", "self", ".", "separator_sets", "\n", "}", "\n", "for", "clique1", ",", "clique2", "in", "self", ".", "junction_tree", ".", "edges", ":", "\n", "            ", "separator_degrees", "[", "tuple", "(", "sorted", "(", "list", "(", "(", "set", "(", "clique1", ")", ".", "intersection", "(", "set", "(", "clique2", ")", ")", ")", ")", ")", ")", "]", "+=", "1", "\n", "", "self", ".", "separator_degrees", "=", "separator_degrees", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.reduce_marginal": [[704, 711], ["marginal.reduce", "lf_vals.index", "len", "int", "var.split"], "methods", ["None"], ["", "def", "reduce_marginal", "(", "self", ",", "marginal", ",", "data_point", ")", ":", "\n", "        ", "lf_vals", "=", "[", "-", "1", ",", "0", ",", "1", "]", "if", "self", ".", "allow_abstentions", "else", "[", "-", "1", ",", "1", "]", "\n", "params", "=", "[", "\n", "(", "var", ",", "lf_vals", ".", "index", "(", "data_point", "[", "int", "(", "var", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "]", ")", ")", "\n", "for", "var", "in", "marginal", ".", "variables", "if", "'lambda'", "in", "var", "\n", "]", "\n", "return", "marginal", ".", "reduce", "(", "params", ",", "inplace", "=", "False", ")", "if", "len", "(", "params", ")", ">", "0", "else", "marginal", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict_proba": [[712, 861], ["numpy.array", "label_model.LabelModel.enumerate_ys", "max", "range", "numpy.zeros", "enumerate", "numpy.prod", "len", "sorted", "numpy.zeros", "enumerate", "numpy.array().astype", "numpy.prod", "numerator_vals_by_lambda_count.append", "len", "numpy.zeros", "enumerate", "numpy.prod", "enumerate", "numpy.array", "len", "label_model.LabelModel.fit.num_lambdas"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.enumerate_ys"], ["", "def", "predict_proba", "(", "self", ",", "L_matrix", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "'''Predict the probabilities of the Y's given the outputs of the LF's.\n        \n        L_matrix: a m x |Y| matrix of of LF outputs. L_matrix[k][i] is the value of \\lambda_i on item k.\n            1 means positive, -1 means negative, 0 means abstain.\n        \n        Let C be the set of all cliques in the graphical model, and S the set of all separator sets.\n        Let d(s) for s \\in S be the number of maximal cliques that s separates.\n        \n        Then, we have the following formula for the joint probability:\n        \n          P(\\lambda_1, ..., \\lambda_m, Y_1, ..., Y_v) =\n              \\prod_{c \\in C} \\mu_c(c) / \\prod_{s \\in S} [\\mu_s(s)]^(d(s) - 1)\n        \n        Where \\mu_c and \\mu_s are the marginal probabilities of a clique c or a separator s, respectively.\n        We solved for these marginals during the fit function, so now we use them for inference!\n        \n        Outputs: a 2^v x |Y| matrix of probabilities. The probabilities for the combinations are\n          sorted lexicographically.\n        '''", "\n", "def", "num_lambdas", "(", "nodes", ")", ":", "\n", "            ", "return", "len", "(", "[", "\n", "node", "for", "node", "in", "nodes", "if", "'lambda'", "in", "node", "\n", "]", ")", "\n", "\n", "", "L_matrix", "=", "np", ".", "array", "(", "L_matrix", ")", "\n", "\n", "Y_vecs", "=", "self", ".", "enumerate_ys", "(", ")", "\n", "numerator_vals_by_lambda_count", "=", "[", "]", "\n", "max_lambda_count", "=", "max", "(", "[", "num_lambdas", "(", "clique", ")", "for", "clique", ",", "marginal", "in", "self", ".", "clique_marginals", "]", ")", "\n", "\n", "# Compute all marginals that have lambda_count lambdas", "\n", "for", "lambda_count", "in", "range", "(", "1", ",", "max_lambda_count", "+", "1", ")", ":", "\n", "            ", "correct_lambda_cliques", "=", "[", "\n", "(", "clique", ",", "marginal", ")", "\n", "for", "clique", ",", "marginal", "in", "self", ".", "clique_marginals", "if", "num_lambdas", "(", "clique", ")", "==", "lambda_count", "\n", "]", "\n", "if", "len", "(", "correct_lambda_cliques", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "lambda_options", "=", "(", "-", "1", ",", "0", ",", "1", ")", "if", "self", ".", "allow_abstentions", "else", "(", "-", "1", ",", "1", ")", "\n", "lambda_vals", "=", "{", "\n", "i", ":", "lambda_options", "\n", "for", "i", "in", "range", "(", "lambda_count", ")", "\n", "}", "\n", "lambda_vecs", "=", "sorted", "(", "[", "\n", "[", "vec_dict", "[", "i", "]", "for", "i", "in", "range", "(", "lambda_count", ")", "]", "\n", "for", "vec_dict", "in", "dict_product", "(", "lambda_vals", ")", "\n", "]", ")", "\n", "\n", "# index by Y_vec, clique, and lambda value", "\n", "A_lambda", "=", "np", ".", "zeros", "(", "(", "len", "(", "Y_vecs", ")", ",", "len", "(", "correct_lambda_cliques", ")", ",", "len", "(", "lambda_vecs", ")", ")", ")", "\n", "\n", "for", "i", ",", "Y_vec", "in", "enumerate", "(", "Y_vecs", ")", ":", "\n", "                ", "for", "j", ",", "(", "clique", ",", "marginal", ")", "in", "enumerate", "(", "correct_lambda_cliques", ")", ":", "\n", "                    ", "lambda_marginal", "=", "marginal", ".", "reduce", "(", "\n", "[", "\n", "(", "'Y_{}'", ".", "format", "(", "Y_idx", ")", ",", "y_val", "if", "y_val", "==", "1", "else", "0", ")", "\n", "for", "Y_idx", ",", "y_val", "in", "enumerate", "(", "Y_vec", ")", "\n", "if", "'Y_{}'", ".", "format", "(", "Y_idx", ")", "in", "clique", "\n", "]", ",", "\n", "inplace", "=", "False", "\n", ")", "\n", "for", "k", ",", "lambda_vec", "in", "enumerate", "(", "lambda_vecs", ")", ":", "\n", "                        ", "A_lambda", "[", "i", ",", "j", ",", "k", "]", "=", "lambda_marginal", ".", "reduce", "(", "\n", "[", "\n", "(", "\n", "clique_node", ",", "\n", "lambda_options", ".", "index", "(", "lambda_val", ")", "\n", ")", "\n", "for", "clique_node", ",", "lambda_val", "in", "zip", "(", "clique", ",", "lambda_vec", ")", "\n", "]", ",", "\n", "inplace", "=", "False", ")", ".", "values", "\n", "\n", "", "", "", "indexes", "=", "np", ".", "array", "(", "[", "\n", "[", "\n", "np", ".", "sum", "(", "[", "\n", "(", "(", "lambda_options", ".", "index", "(", "data_point", "[", "int", "(", "node", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "]", ")", ")", "*", "\n", "(", "(", "len", "(", "lambda_options", ")", ")", "**", "(", "lambda_count", "-", "i", "-", "1", ")", ")", ")", "\n", "for", "i", ",", "node", "in", "enumerate", "(", "clique", "[", ":", "-", "1", "]", ")", "\n", "]", ")", "\n", "for", "clique", ",", "marginal", "in", "correct_lambda_cliques", "\n", "]", "\n", "for", "data_point", "in", "L_matrix", "\n", "]", ")", ".", "astype", "(", "'int'", ")", "\n", "\n", "clique_values", "=", "A_lambda", "[", ":", ",", "np", ".", "arange", "(", "indexes", ".", "shape", "[", "1", "]", ")", ",", "indexes", "]", "\n", "\n", "numerator_values", "=", "np", ".", "prod", "(", "clique_values", ",", "axis", "=", "2", ")", "\n", "numerator_vals_by_lambda_count", ".", "append", "(", "numerator_values", ")", "\n", "\n", "# Compute all marginals that have zero lambdas", "\n", "", "zero_lambda_cliques", "=", "[", "\n", "(", "clique", ",", "marginal", ")", "\n", "for", "clique", ",", "marginal", "in", "self", ".", "clique_marginals", "if", "num_lambdas", "(", "clique", ")", "==", "0", "\n", "]", "\n", "if", "len", "(", "zero_lambda_cliques", ")", ">", "0", ":", "\n", "            ", "A_y", "=", "np", ".", "zeros", "(", "(", "len", "(", "Y_vecs", ")", ",", "len", "(", "zero_lambda_cliques", ")", ")", ")", "\n", "for", "i", ",", "Y_vec", "in", "enumerate", "(", "Y_vecs", ")", ":", "\n", "                ", "for", "j", ",", "(", "clique", ",", "marginal", ")", "in", "enumerate", "(", "zero_lambda_cliques", ")", ":", "\n", "                    ", "Y_marginal", "=", "marginal", ".", "reduce", "(", "\n", "[", "\n", "(", "'Y_{}'", ".", "format", "(", "Y_idx", ")", ",", "y_val", "if", "y_val", "==", "1", "else", "0", ")", "\n", "for", "Y_idx", ",", "y_val", "in", "enumerate", "(", "Y_vec", ")", "\n", "if", "'Y_{}'", ".", "format", "(", "Y_idx", ")", "in", "clique", "\n", "]", ",", "\n", "inplace", "=", "False", "\n", ")", "\n", "A_y", "[", "i", ",", "j", "]", "=", "Y_marginal", ".", "values", "\n", "\n", "", "", "y_probs", "=", "np", ".", "prod", "(", "A_y", ",", "axis", "=", "1", ")", "\n", "\n", "numerator_ys", "=", "np", ".", "array", "(", "[", "y_probs", ",", "]", "*", "L_matrix", ".", "shape", "[", "0", "]", ")", ".", "T", "\n", "\n", "# Compute all separator marginals", "\n", "", "zero_lambda_separators", "=", "[", "\n", "(", "clique", ",", "marginal", ")", "\n", "for", "clique", ",", "marginal", "in", "self", ".", "separator_marginals", "if", "num_lambdas", "(", "clique", ")", "==", "0", "\n", "]", "\n", "\n", "A_y_sep", "=", "np", ".", "zeros", "(", "(", "len", "(", "Y_vecs", ")", ",", "len", "(", "zero_lambda_separators", ")", ")", ")", "\n", "for", "i", ",", "Y_vec", "in", "enumerate", "(", "Y_vecs", ")", ":", "\n", "            ", "for", "j", ",", "(", "clique", ",", "marginal", ")", "in", "enumerate", "(", "zero_lambda_separators", ")", ":", "\n", "                ", "Y_marginal", "=", "marginal", ".", "reduce", "(", "\n", "[", "\n", "(", "'Y_{}'", ".", "format", "(", "Y_idx", ")", ",", "y_val", "if", "y_val", "==", "1", "else", "0", ")", "\n", "for", "Y_idx", ",", "y_val", "in", "enumerate", "(", "Y_vec", ")", "\n", "if", "'Y_{}'", ".", "format", "(", "Y_idx", ")", "in", "clique", "\n", "]", ",", "\n", "inplace", "=", "False", "\n", ")", "\n", "A_y_sep", "[", "i", ",", "j", "]", "=", "Y_marginal", ".", "values", "**", "(", "self", ".", "separator_degrees", "[", "clique", "]", "-", "1", ")", "\n", "\n", "", "", "y_probs_sep", "=", "np", ".", "prod", "(", "A_y_sep", ",", "axis", "=", "1", ")", "\n", "\n", "denominator_ys", "=", "np", ".", "array", "(", "[", "y_probs_sep", ",", "]", "*", "L_matrix", ".", "shape", "[", "0", "]", ")", ".", "T", "\n", "\n", "predictions", "=", "numerator_vals_by_lambda_count", "[", "0", "]", "\n", "for", "lambda_numerator", "in", "numerator_vals_by_lambda_count", "[", "1", ":", "]", ":", "\n", "            ", "predictions", "=", "predictions", "*", "lambda_numerator", "\n", "", "if", "len", "(", "zero_lambda_cliques", ")", ">", "0", ":", "\n", "            ", "predictions", "=", "predictions", "*", "numerator_ys", "\n", "", "predictions", "=", "(", "predictions", "/", "denominator_ys", ")", ".", "T", "\n", "\n", "# in the case of zero-sum predictions", "\n", "predictions", "[", "predictions", ".", "sum", "(", "axis", "=", "1", ")", "==", "0", "]", "+=", ".001", "\n", "\n", "normalized_preds", "=", "predictions", "/", "np", ".", "array", "(", "(", "[", "predictions", ".", "sum", "(", "axis", "=", "1", ")", ",", "]", "*", "len", "(", "Y_vecs", ")", ")", ")", ".", "T", "\n", "\n", "return", "normalized_preds", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict": [[862, 888], ["label_model.LabelModel.enumerate_ys", "label_model.LabelModel.predict_proba", "numpy.argmax", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.enumerate_ys", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict_proba"], ["", "def", "predict", "(", "self", ",", "L_matrix", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "'''Predict the value of the Y's that best fits the outputs of the LF's.\n        \n        L_matrix: a m x |Y| matrix of LF outputs. L_matrix[k][i] is the value of \\lambda_i on item k.\n            1 means positive, -1 means negative, 0 means abstain.\n        \n        Let C be the set of all cliques in the graphical model, and S the set of all separator sets.\n        Let d(s) for s \\in S be the number of maximal cliques that s separates.\n        \n        Then, we have the following formula for the joint probability:\n        \n          P(\\lambda_1, ..., \\lambda_m, Y_1, ..., Y_v) =\n              \\prod_{c \\in C} \\mu_c(c) / \\prod_{s \\in S} [\\mu_s(s)]^(d(s) - 1)\n        \n        Where \\mu_c and \\mu_s are the marginal probabilities of a clique c or a separator s, respectively.\n        We solved for these marginals during the fit function, so now we use them for inference!\n        \n        Outputs: a v x |Y| matrix of predicted outputs.\n        '''", "\n", "\n", "Y_vecs", "=", "self", ".", "enumerate_ys", "(", ")", "\n", "combination_probs", "=", "self", ".", "predict_proba", "(", "L_matrix", ",", "verbose", "=", "verbose", ")", "\n", "most_likely", "=", "np", ".", "argmax", "(", "combination_probs", ",", "axis", "=", "1", ")", "\n", "preds", "=", "np", ".", "array", "(", "Y_vecs", ")", "[", "most_likely", "]", "\n", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict_proba_marginalized": [[889, 919], ["label_model.LabelModel.predict_proba", "label_model.LabelModel.enumerate_ys", "numpy.sum().reshape", "range", "numpy.sum", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict_proba", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.enumerate_ys"], ["", "def", "predict_proba_marginalized", "(", "self", ",", "L_matrix", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "'''Predict the probabilities of the Y's given the outputs of the LF's, marginalizing out all the\n        Y values every time (return a separate probability for +1/-1 for each Y).\n        \n        L_matrix: a m x |Y| matrix of of LF outputs. L_matrix[k][i] is the value of \\lambda_i on item k.\n            1 means positive, -1 means negative, 0 means abstain.\n        \n        Let C be the set of all cliques in the graphical model, and S the set of all separator sets.\n        Let d(s) for s \\in S be the number of maximal cliques that s separates.\n        \n        Then, we have the following formula for the joint probability:\n        \n          P(\\lambda_1, ..., \\lambda_m, Y_1, ..., Y_v) =\n              \\prod_{c \\in C} \\mu_c(c) / \\prod_{s \\in S} [\\mu_s(s)]^(d(s) - 1)\n        \n        Where \\mu_c and \\mu_s are the marginal probabilities of a clique c or a separator s, respectively.\n        We solved for these marginals during the fit function, so now we use them for inference!\n        \n        Outputs: a v x |Y| matrix of marginalized probabilities (one probability for each task, for each\n          data point). \n        '''", "\n", "combination_probs", "=", "self", ".", "predict_proba", "(", "L_matrix", ",", "verbose", "=", "verbose", ")", "\n", "# construct indices for each task", "\n", "Y_vecs", "=", "self", ".", "enumerate_ys", "(", ")", "\n", "task_indices", "=", "[", "\n", "[", "idx", "for", "idx", ",", "y_vec", "in", "enumerate", "(", "Y_vecs", ")", "if", "y_vec", "[", "i", "]", "==", "1", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "v", ")", "\n", "]", "\n", "\n", "return", "np", ".", "sum", "(", "combination_probs", "[", ":", ",", "task_indices", "]", ",", "axis", "=", "2", ")", ".", "reshape", "(", "len", "(", "combination_probs", ")", "*", "self", ".", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.estimated_accuracies": [[920, 949], ["range", "print", "accuracies.append"], "methods", ["None"], ["", "def", "estimated_accuracies", "(", "self", ")", ":", "\n", "        ", "'''Get the estimated accuracies of each LF.\n        \n        Assumes that each LF is connected to exactly one Y node.\n        Let Y(i) denote the node that LF i is connected to.\n        This function returns an array of values P(lambda_i = Y(i)), for each LF i.\n        \n        Outputs: a m-sized array of estimated LF accuracies.\n        '''", "\n", "if", "not", "self", ".", "probability_values", ":", "\n", "            ", "print", "(", "'You need to train the label model first!'", ")", "\n", "return", "\n", "\n", "", "accuracies", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "m", ")", ":", "\n", "            ", "lambda_node", "=", "'lambda_{}'", ".", "format", "(", "i", ")", "\n", "Y_node", "=", "[", "\n", "e2", "\n", "for", "e1", ",", "e2", "in", "self", ".", "G", ".", "edges", "\n", "if", "e1", "==", "lambda_node", "and", "'Y'", "in", "e2", "\n", "]", "[", "0", "]", "\n", "if", "self", ".", "allow_abstentions", ":", "\n", "                ", "prob_key", "=", "(", "\n", "(", "lambda_node", ",", "Y_node", ")", ",", "(", "'0'", ",", ")", "\n", ")", "if", "self", ".", "allow_abstentions", "else", "(", "lambda_node", ",", "Y_node", ")", "\n", "\n", "accuracies", ".", "append", "(", "self", ".", "probability_values", "[", "prob_key", "]", ")", "\n", "\n", "", "", "return", "accuracies", "\n", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.pytorch_loss.FSLoss.__init__": [[100, 133], ["torch.Module.__init__", "flyingsquid.label_model.LabelModel", "pytorch_loss.FSLoss.register_buffer", "pytorch_loss.FSLoss.register_buffer", "pytorch_loss.FSLoss.register_buffer", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.ImageFSDataset.__init__"], ["def", "__init__", "(", "self", ",", "m", ",", "v", "=", "1", ",", "task_deps", "=", "[", "]", ",", "lf_task_deps", "=", "[", "]", ",", "lf_deps", "=", "[", "]", ",", "\n", "Y_dev", "=", "None", ",", "cb", "=", "None", ",", "allow_abstentions", "=", "True", ",", "device", "=", "'cpu'", ",", "\n", "buffer_capacity", "=", "100", ",", "update_frequency", "=", "10", ",", "clamp_vals", "=", "False", ",", "\n", "triplets", "=", "None", ",", "pos_weight", "=", "None", ")", ":", "\n", "        ", "super", "(", "WSLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "m", "=", "m", "\n", "self", ".", "v", "=", "v", "\n", "self", ".", "task_deps", "=", "task_deps", "\n", "self", ".", "lf_task_deps", "=", "lf_task_deps", "\n", "if", "self", ".", "lf_task_deps", "==", "[", "]", ":", "\n", "            ", "self", ".", "lf_task_deps", "=", "[", "(", "i", ",", "0", ")", "for", "i", "in", "range", "(", "m", ")", "]", "\n", "", "self", ".", "lf_deps", "=", "lf_deps", "\n", "self", ".", "Y_dev", "=", "Y_dev", "\n", "self", ".", "cb", "=", "cb", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "clamp_vals", "=", "clamp_vals", "\n", "\n", "self", ".", "lm", "=", "LabelModel", "(", "m", ",", "v", "=", "v", ",", "y_edges", "=", "task_deps", ",", "lambda_y_edges", "=", "lf_task_deps", ",", "\n", "lambda_edges", "=", "lf_deps", ",", "allow_abstentions", "=", "allow_abstentions", ",", "\n", "triplets", "=", "triplets", ")", "\n", "\n", "self", ".", "criterion", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "if", "pos_weight", "is", "None", "else", "nn", ".", "BCEWithLogitsLoss", "(", "pos_weight", "=", "pos_weight", ")", "\n", "self", ".", "buffer_capacity", "=", "buffer_capacity", "\n", "self", ".", "update_frequency", "=", "update_frequency", "\n", "\n", "# register buffer for LF outputs", "\n", "self", ".", "register_buffer", "(", "'lf_buffer'", ",", "torch", ".", "zeros", "(", "(", "buffer_capacity", ",", "m", ")", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "\n", "# register buffer to keep track of how many items", "\n", "self", ".", "register_buffer", "(", "'buffer_size'", ",", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "\n", "# reigster buffer to keep track of where you are", "\n", "self", ".", "register_buffer", "(", "'buffer_index'", ",", "torch", ".", "zeros", "(", "1", ",", "dtype", "=", "torch", ".", "long", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.pytorch_loss.FSLoss.forward": [[134, 185], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "enumerate", "zip", "pytorch_loss.FSLoss.lm.predict_proba_marginalized", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "pytorch_loss.FSLoss.lm.fit", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "pytorch_loss.FSLoss.criterion", "pytorch_loss.FSLoss.lf_buffer.cpu().numpy", "label_vector.cpu().numpy", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "pytorch_loss.FSLoss.lf_buffer.cpu", "label_vector.cpu"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.predict_proba_marginalized", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.label_model.LabelModel.fit"], ["", "def", "forward", "(", "self", ",", "predictions", ",", "weak_labels", ",", "update_frequency", "=", "None", ")", ":", "\n", "        ", "'''\n        Generate probabilistic labels from the weak labels, and use `BCEWithLogitsLoss` to\n        get the actual loss value for end model training.\n        Also caches the LF votes, and re-trains the label model if necessary (depending on\n        update_frequency).\n        \n        Args:\n            predictions: A (batch_size, v)-sized tensor of model outputs. For sequences,\n                v is usually the length of the sequence.\n            weak_labels: A (batch_size, m)-sized tensor of weak labels.\n            \n        Returns:\n            Computes BCEWithLogitsLoss on every item in the batch (for each item, computes it\n            between the v model outputs and the v probabilistic labels), and returns the\n            average.\n        '''", "\n", "update_frequency", "=", "update_frequency", "if", "update_frequency", "else", "self", ".", "update_frequency", "\n", "\n", "output", "=", "torch", ".", "tensor", "(", "0.", ",", "requires_grad", "=", "True", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "for", "i", ",", "(", "prediction", ",", "label_vector", ")", "in", "enumerate", "(", "zip", "(", "predictions", ",", "weak_labels", ")", ")", ":", "\n", "            ", "self", ".", "lf_buffer", "[", "self", ".", "buffer_index", "]", "=", "label_vector", "\n", "if", "self", ".", "buffer_size", "<", "self", ".", "buffer_capacity", ":", "\n", "                ", "self", ".", "buffer_size", "+=", "1", "\n", "\n", "", "if", "(", "self", ".", "buffer_index", "%", "update_frequency", ")", "==", "0", ":", "\n", "                ", "L_train", "=", "self", ".", "lf_buffer", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", ":", "self", ".", "buffer_size", "]", "\n", "\n", "self", ".", "lm", ".", "fit", "(", "\n", "L_train", ",", "\n", "Y_dev", "=", "self", ".", "Y_dev", ",", "\n", "class_balance", "=", "self", ".", "cb", "\n", ")", "\n", "\n", "", "self", ".", "buffer_index", "+=", "1", "\n", "if", "self", ".", "buffer_index", "==", "self", ".", "buffer_capacity", ":", "\n", "                ", "self", ".", "buffer_index", "=", "torch", ".", "tensor", "(", "0", ")", "\n", "\n", "", "labels", "=", "self", ".", "lm", ".", "predict_proba_marginalized", "(", "\n", "[", "label_vector", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", ",", "verbose", "=", "False", ")", "\n", "if", "self", ".", "clamp_vals", ":", "\n", "                ", "labels", "[", "0", "]", "=", "[", "1.", "if", "pred", ">=", "0.5", "else", "0.", "for", "pred", "in", "labels", "[", "0", "]", "]", "\n", "\n", "", "label_tensor", "=", "torch", ".", "tensor", "(", "labels", "[", "0", "]", ",", "requires_grad", "=", "True", ",", "device", "=", "self", ".", "device", ")", ".", "view", "(", "prediction", ".", "shape", ")", "\n", "\n", "output", "=", "output", "+", "self", ".", "criterion", "(", "\n", "prediction", ",", "\n", "label_tensor", ")", "\n", "\n", "", "return", "output", "/", "predictions", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.pytorch_loss.MajorityVoteLoss.__init__": [[253, 257], ["torch.Module.__init__", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.ImageFSDataset.__init__"], ["def", "__init__", "(", "self", ",", "device", "=", "'cpu'", ",", "pos_weight", "=", "None", ")", ":", "\n", "        ", "super", "(", "MajorityVoteLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "criterion", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "if", "pos_weight", "is", "None", "else", "nn", ".", "BCEWithLogitsLoss", "(", "pos_weight", "=", "pos_weight", ")", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.pytorch_loss.MajorityVoteLoss.forward": [[258, 287], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "enumerate", "zip", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "pytorch_loss.MajorityVoteLoss.criterion", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "np.sum", "label_vector.cpu().numpy", "label_vector.cpu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "predictions", ",", "weak_labels", ",", "update_frequency", "=", "None", ")", ":", "\n", "        ", "'''\n        Generate probabilistic labels from the weak labels, and use `BCEWithLogitsLoss` to\n        get the actual loss value for end model training.\n        Also caches the LF votes, and re-trains the label model if necessary (depending on\n        update_frequency).\n        \n        Args:\n            predictions: A (batch_size)-sized tensor of model outputs.\n            weak_labels: A (batch_size, m)-sized tensor of weak labels.\n            \n        Returns:\n            Computes BCEWithLogitsLoss on every item in the batch (for each item, computes it\n            between the v model outputs and the v probabilistic labels), and returns the\n            average.\n        '''", "\n", "\n", "output", "=", "torch", ".", "tensor", "(", "0.", ",", "requires_grad", "=", "True", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "for", "i", ",", "(", "prediction", ",", "label_vector", ")", "in", "enumerate", "(", "zip", "(", "predictions", ",", "weak_labels", ")", ")", ":", "\n", "            ", "label", "=", "(", "np", ".", "sum", "(", "label_vector", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ">", "0", ")", ".", "astype", "(", "float", ")", "\n", "\n", "label_tensor", "=", "torch", ".", "tensor", "(", "label", ",", "requires_grad", "=", "True", ",", "device", "=", "self", ".", "device", ")", ".", "view", "(", "prediction", ".", "shape", ")", "\n", "\n", "output", "=", "output", "+", "self", ".", "criterion", "(", "\n", "prediction", ",", "\n", "label_tensor", ")", "\n", "\n", "", "return", "output", "/", "predictions", ".", "shape", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_class_balance": [[16, 52], ["pgmpy.factors.discrete.JointProbabilityDistribution", "range", "range", "sum", "sorted", "pgmpy.factors.discrete.JointProbabilityDistribution", "pgmpy.factors.discrete.JointProbabilityDistribution", "tuple", "range", "dict_product", "tuple", "float", "len", "range", "tuple"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.helpers.dict_product"], ["def", "_compute_class_balance", "(", "self", ",", "class_balance", "=", "None", ",", "Y_dev", "=", "None", ")", ":", "\n", "# generate class balance of Ys", "\n", "        ", "Ys_ordered", "=", "[", "'Y_{}'", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "v", ")", "]", "\n", "cardinalities", "=", "[", "2", "for", "i", "in", "range", "(", "self", ".", "v", ")", "]", "\n", "if", "class_balance", "is", "not", "None", ":", "\n", "            ", "class_balance", "=", "class_balance", "/", "sum", "(", "class_balance", ")", "\n", "cb", "=", "JointProbabilityDistribution", "(", "\n", "Ys_ordered", ",", "cardinalities", ",", "class_balance", "\n", ")", "\n", "", "elif", "Y_dev", "is", "not", "None", ":", "\n", "            ", "Ys_ordered", "=", "[", "'Y_{}'", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "self", ".", "v", ")", "]", "\n", "vals", "=", "{", "Y", ":", "(", "-", "1", ",", "1", ")", "for", "Y", "in", "Ys_ordered", "}", "\n", "Y_vecs", "=", "sorted", "(", "[", "\n", "[", "vec_dict", "[", "Y", "]", "for", "Y", "in", "Ys_ordered", "]", "\n", "for", "vec_dict", "in", "dict_product", "(", "vals", ")", "\n", "]", ")", "\n", "counts", "=", "{", "\n", "tuple", "(", "Y_vec", ")", ":", "0", "\n", "for", "Y_vec", "in", "Y_vecs", "\n", "}", "\n", "for", "data_point", "in", "Y_dev", ":", "\n", "                ", "counts", "[", "tuple", "(", "data_point", ")", "]", "+=", "1", "\n", "", "cb", "=", "JointProbabilityDistribution", "(", "\n", "Ys_ordered", ",", "cardinalities", ",", "\n", "[", "\n", "float", "(", "counts", "[", "tuple", "(", "Y_vec", ")", "]", ")", "/", "len", "(", "Y_dev", ")", "\n", "for", "Y_vec", "in", "Y_vecs", "\n", "]", ")", "\n", "", "else", ":", "\n", "            ", "num_combinations", "=", "2", "**", "self", ".", "v", "\n", "cb", "=", "JointProbabilityDistribution", "(", "\n", "Ys_ordered", ",", "cardinalities", ",", "[", "\n", "1.", "/", "num_combinations", "for", "i", "in", "range", "(", "num_combinations", ")", "\n", "]", ")", "\n", "\n", "", "return", "cb", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_Y_marginals": [[53, 62], ["_observables.Mixin.cb.marginal_distribution"], "methods", ["None"], ["", "def", "_compute_Y_marginals", "(", "self", ",", "Y_marginals", ")", ":", "\n", "        ", "for", "marginal", "in", "Y_marginals", ":", "\n", "            ", "nodes", "=", "[", "'Y_{}'", ".", "format", "(", "idx", ")", "for", "idx", "in", "marginal", "]", "\n", "Y_marginals", "[", "marginal", "]", "=", "self", ".", "cb", ".", "marginal_distribution", "(", "\n", "nodes", ",", "\n", "inplace", "=", "False", "\n", ")", "\n", "\n", "", "return", "Y_marginals", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid._observables.Mixin._compute_Y_equals_one": [[63, 94], ["_observables.Mixin.cb.marginal_distribution", "sorted", "numpy.prod", "dict_product", "_observables.Mixin.reduce", "zip"], "methods", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.helpers.dict_product"], ["", "def", "_compute_Y_equals_one", "(", "self", ",", "Y_equals_one", ")", ":", "\n", "# compute from class balance", "\n", "        ", "for", "factor", "in", "Y_equals_one", ":", "\n", "            ", "nodes", "=", "[", "'Y_{}'", ".", "format", "(", "idx", ")", "for", "idx", "in", "factor", "]", "\n", "\n", "Y_marginal", "=", "self", ".", "cb", ".", "marginal_distribution", "(", "\n", "nodes", ",", "\n", "inplace", "=", "False", "\n", ")", "\n", "vals", "=", "{", "Y", ":", "(", "-", "1", ",", "1", ")", "for", "Y", "in", "nodes", "}", "\n", "Y_vecs", "=", "sorted", "(", "[", "\n", "[", "vec_dict", "[", "Y", "]", "for", "Y", "in", "nodes", "]", "\n", "for", "vec_dict", "in", "dict_product", "(", "vals", ")", "\n", "]", ")", "\n", "\n", "# add up the probabilities of all the vectors whose values multiply to +1", "\n", "total_prob", "=", "0", "\n", "for", "Y_vec", "in", "Y_vecs", ":", "\n", "                ", "if", "np", ".", "prod", "(", "Y_vec", ")", "==", "1", ":", "\n", "                    ", "vector_prob", "=", "Y_marginal", ".", "reduce", "(", "\n", "[", "\n", "(", "Y_i", ",", "Y_val", "if", "Y_val", "==", "1", "else", "0", ")", "\n", "for", "Y_i", ",", "Y_val", "in", "zip", "(", "nodes", ",", "Y_vec", ")", "\n", "]", ",", "\n", "inplace", "=", "False", "\n", ")", ".", "values", "\n", "total_prob", "+=", "vector_prob", "\n", "\n", "", "", "Y_equals_one", "[", "factor", "]", "=", "total_prob", "\n", "\n", "", "return", "Y_equals_one", "", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.flyingsquid.helpers.dict_product": [[3, 7], ["d.keys", "itertools.product", "d.values", "dict", "zip"], "function", ["None"], ["def", "dict_product", "(", "d", ")", ":", "\n", "    ", "keys", "=", "d", ".", "keys", "(", ")", "\n", "for", "element", "in", "product", "(", "*", "d", ".", "values", "(", ")", ")", ":", "\n", "        ", "yield", "dict", "(", "zip", "(", "keys", ",", "element", ")", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.ImageFSDataset.__init__": [[32, 58], ["numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "len", "len", "len", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "paths", ",", "weak_labels", ",", "T", ",", "gt_labels", "=", "None", ",", "\n", "transform", "=", "None", ")", ":", "\n", "        ", "self", ".", "T", "=", "T", "\n", "self", ".", "paths", "=", "self", ".", "paths", "[", ":", "len", "(", "self", ".", "paths", ")", "-", "(", "len", "(", "self", ".", "paths", ")", "%", "T", ")", "]", "\n", "self", ".", "weak_labels", "=", "self", ".", "weak_labels", "[", ":", "self", ".", "weak_labels", ".", "shape", "[", "0", "]", "-", "\n", "(", "self", ".", "weak_labels", ".", "shape", "[", "0", "]", "%", "T", ")", "]", "\n", "m_per_task", "=", "self", ".", "weak_labels", ".", "shape", "[", "1", "]", "\n", "\n", "self", ".", "transform", "=", "transform", "\n", "\n", "n_frames", "=", "self", ".", "weak_labels", ".", "shape", "[", "0", "]", "\n", "n_seqs", "=", "n_frames", "//", "T", "\n", "\n", "v", "=", "T", "\n", "m", "=", "m_per_task", "*", "T", "\n", "\n", "self", ".", "data_temporal", "=", "{", "\n", "'paths'", ":", "np", ".", "reshape", "(", "self", ".", "paths", ",", "(", "n_seqs", ",", "v", ")", ")", ",", "\n", "'weak_labels'", ":", "np", ".", "reshape", "(", "self", ".", "weak_labels", ",", "(", "n_seqs", ",", "m", ")", ")", "\n", "}", "\n", "\n", "self", ".", "gt_labels", "=", "gt_labels", "\n", "if", "gt_labels", "is", "not", "None", ":", "\n", "            ", "self", ".", "gt_labels", "=", "self", ".", "gt_labels", "[", ":", "len", "(", "self", ".", "gt_labels", ")", "-", "\n", "(", "len", "(", "self", ".", "gt_labels", ")", "%", "T", ")", "]", "\n", "self", ".", "data_temporal", "[", "'gt_labels'", "]", "=", "np", ".", "reshape", "(", "self", ".", "gt_labels", ",", "(", "n_seqs", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.ImageFSDataset.__len__": [[59, 61], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_temporal", "[", "'paths'", "]", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.ImageFSDataset.__getitem__": [[62, 80], ["torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "03_pytorch_integration.ImageFSDataset.transform", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "Image.open().convert", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "Image.open"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "paths_seq", "=", "self", ".", "data_temporal", "[", "'paths'", "]", "[", "idx", "]", "\n", "\n", "img_tensors", "=", "[", "\n", "torch", ".", "unsqueeze", "(", "\n", "self", ".", "transform", "(", "Image", ".", "open", "(", "path", ")", ".", "convert", "(", "'RGB'", ")", ")", ",", "\n", "dim", "=", "0", ")", "\n", "for", "path", "in", "paths_seq", "\n", "]", "\n", "\n", "weak_labels", "=", "self", ".", "data_temporal", "[", "'weak_labels'", "]", "[", "idx", "]", "\n", "\n", "if", "self", ".", "gt_labels", "is", "not", "None", ":", "\n", "            ", "return", "(", "torch", ".", "cat", "(", "img_tensors", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "torch", ".", "tensor", "(", "weak_labels", ")", ",", "dim", "=", "0", ")", ",", "\n", "torch", ".", "unsqueeze", "(", "torch", ".", "tensor", "(", "self", ".", "data_temporal", "[", "'gt_labels'", "]", "[", "idx", "]", ")", ",", "dim", "=", "0", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "img_tensors", ")", ",", "torch", ".", "unsqueeze", "(", "torch", ".", "tensor", "(", "weak_labels", ")", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.examples.03_pytorch_integration.train_model_online": [[82, 105], ["model.train", "len", "optimizer.zero_grad", "torch.set_grad_enabled", "torch.set_grad_enabled", "torch.set_grad_enabled", "model", "criterion", "criterion.backward", "optimizer.step", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze"], "function", ["None"], ["", "", "", "def", "train_model_online", "(", "model", ",", "T", ",", "criterion", ",", "optimizer", ",", "dataset", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "dataset_size", "=", "len", "(", "dataset", ")", "*", "T", "\n", "\n", "for", "item", "in", "dataset", ":", "\n", "        ", "image_tensor", "=", "item", "[", "0", "]", "\n", "weak_labels", "=", "item", "[", "1", "]", "\n", "labels", "=", "None", "if", "dataset", ".", "gt_labels", "is", "None", "else", "item", "[", "2", "]", "\n", "\n", "# zero the parameter gradients", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# forward", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "            ", "outputs", "=", "model", "(", "inputs", ")", "\n", "\n", "loss", "=", "criterion", "(", "torch", ".", "unsqueeze", "(", "outputs", ",", "dim", "=", "0", ")", ",", "weak_labels", ")", "\n", "\n", "# backward + optimize", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.exponential_family": [[5, 8], ["numpy.exp", "numpy.dot"], "function", ["None"], ["def", "exponential_family", "(", "lam", ",", "y", ",", "theta", ",", "theta_y", ")", ":", "\n", "# without normalization", "\n", "    ", "return", "np", ".", "exp", "(", "theta_y", "*", "y", "+", "y", "*", "np", ".", "dot", "(", "theta", ",", "lam", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.make_pdf": [[10, 17], ["numpy.zeros", "range", "len", "len", "tutorial_helpers.exponential_family", "sum"], "function", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.exponential_family"], ["", "def", "make_pdf", "(", "m", ",", "v", ",", "theta", ",", "theta_y", ",", "lst", ")", ":", "\n", "    ", "p", "=", "np", ".", "zeros", "(", "len", "(", "lst", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "lst", ")", ")", ":", "\n", "        ", "labels", "=", "lst", "[", "i", "]", "\n", "p", "[", "i", "]", "=", "exponential_family", "(", "labels", "[", "0", ":", "m", "]", ",", "labels", "[", "v", "-", "1", "]", ",", "theta", ",", "theta_y", ")", "\n", "\n", "", "return", "p", "/", "sum", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.make_cdf": [[18, 20], ["numpy.cumsum"], "function", ["None"], ["", "def", "make_cdf", "(", "pdf", ")", ":", "\n", "    ", "return", "np", ".", "cumsum", "(", "pdf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.sample": [[22, 30], ["numpy.random.random_sample", "numpy.where", "len", "smaller.max"], "function", ["None"], ["", "def", "sample", "(", "lst", ",", "cdf", ")", ":", "\n", "    ", "r", "=", "np", ".", "random", ".", "random_sample", "(", ")", "\n", "smaller", "=", "np", ".", "where", "(", "cdf", "<", "r", ")", "[", "0", "]", "\n", "if", "len", "(", "smaller", ")", "==", "0", ":", "\n", "        ", "i", "=", "0", "\n", "", "else", ":", "\n", "        ", "i", "=", "smaller", ".", "max", "(", ")", "+", "1", "\n", "", "return", "lst", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.generate_data": [[31, 43], ["list", "tutorial_helpers.make_pdf", "tutorial_helpers.make_cdf", "numpy.zeros", "range", "map", "tutorial_helpers.sample", "itertools.product"], "function", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.make_pdf", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.make_cdf", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.sample"], ["", "def", "generate_data", "(", "n", ",", "theta", ",", "m", ",", "theta_y", "=", "0", ")", ":", "\n", "    ", "v", "=", "m", "+", "1", "\n", "\n", "lst", "=", "list", "(", "map", "(", "list", ",", "itertools", ".", "product", "(", "[", "-", "1", ",", "1", "]", ",", "repeat", "=", "v", ")", ")", ")", "\n", "pdf", "=", "make_pdf", "(", "m", ",", "v", ",", "theta", ",", "theta_y", ",", "lst", ")", "\n", "cdf", "=", "make_cdf", "(", "pdf", ")", "\n", "\n", "sample_matrix", "=", "np", ".", "zeros", "(", "(", "n", ",", "v", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "sample_matrix", "[", "i", ",", ":", "]", "=", "sample", "(", "lst", ",", "cdf", ")", "\n", "\n", "", "return", "sample_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.synthetic_data_basics": [[44, 68], ["numpy.random.seed", "tutorial_helpers.generate_data", "tutorial_helpers.generate_data", "numpy.random.rand().reshape", "numpy.random.rand().reshape", "numpy.random.rand", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.generate_data", "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.generate_data"], ["", "def", "synthetic_data_basics", "(", ")", ":", "\n", "    ", "seed", "(", "0", ")", "\n", "\n", "n_train", "=", "10000", "\n", "n_dev", "=", "500", "\n", "\n", "m", "=", "5", "\n", "theta", "=", "[", "1.5", ",", ".5", ",", ".2", ",", ".2", ",", ".05", "]", "\n", "abstain_rate", "=", "[", ".8", ",", ".88", ",", ".28", ",", ".38", ",", ".45", "]", "\n", "\n", "train_data", "=", "generate_data", "(", "n_train", ",", "theta", ",", "m", ")", "\n", "dev_data", "=", "generate_data", "(", "n_dev", ",", "theta", ",", "m", ")", "\n", "\n", "L_train", "=", "train_data", "[", ":", ",", ":", "-", "1", "]", "\n", "L_dev", "=", "dev_data", "[", ":", ",", ":", "-", "1", "]", "\n", "Y_dev", "=", "dev_data", "[", ":", ",", "-", "1", "]", "\n", "\n", "train_values", "=", "rand", "(", "n_train", "*", "m", ")", ".", "reshape", "(", "L_train", ".", "shape", ")", "\n", "dev_values", "=", "rand", "(", "n_dev", "*", "m", ")", ".", "reshape", "(", "L_dev", ".", "shape", ")", "\n", "\n", "L_train", "[", "train_values", "<", "(", "abstain_rate", ",", ")", "*", "n_train", "]", "=", "0", "\n", "L_dev", "[", "dev_values", "<", "(", "abstain_rate", ",", ")", "*", "n_dev", "]", "=", "0", "\n", "\n", "return", "L_train", ",", "L_dev", ",", "Y_dev", "\n", "\n"]], "home.repos.pwc.inspect_result.HazyResearch_flyingsquid.tutorials.tutorial_helpers.print_statistics": [[69, 78], ["range", "print", "numpy.sum", "numpy.sum", "numpy.sum", "int", "int"], "function", ["None"], ["", "def", "print_statistics", "(", "L_dev", ",", "Y_dev", ")", ":", "\n", "    ", "m", "=", "L_dev", ".", "shape", "[", "1", "]", "\n", "\n", "for", "i", "in", "range", "(", "m", ")", ":", "\n", "        ", "acc", "=", "np", ".", "sum", "(", "L_dev", "[", ":", ",", "i", "]", "==", "Y_dev", ")", "/", "np", ".", "sum", "(", "L_dev", "[", ":", ",", "i", "]", "!=", "0", ")", "\n", "abstains", "=", "np", ".", "sum", "(", "L_dev", "[", ":", ",", "i", "]", "==", "0", ")", "/", "Y_dev", ".", "shape", "[", "0", "]", "\n", "\n", "print", "(", "'LF {}: Accuracy {}%, Abstain rate {}%'", ".", "format", "(", "\n", "i", ",", "int", "(", "acc", "*", "100", ")", ",", "int", "(", "(", "abstains", ")", "*", "100", ")", ")", ")", "", "", "", ""]]}