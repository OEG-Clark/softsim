{"home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.reproducibility.get_parser": [[14, 25], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-l\"", ",", "\"--log-directory\"", ",", "dest", "=", "\"logdir\"", ",", "required", "=", "True", ",", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"Output path of trained model.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-b\"", ",", "\"--bids-path\"", ",", "dest", "=", "\"bids\"", ",", "\n", "required", "=", "True", ",", "type", "=", "str", ",", "help", "=", "\"Bids path where are located the GT.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--iterations\"", ",", "default", "=", "10", ",", "type", "=", "int", ",", "help", "=", "\"Number of Monte Carlo iterations.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output-path\"", ",", "nargs", "=", "\"+\"", ",", "dest", "=", "\"output_path\"", ",", "required", "=", "True", ",", "\n", "type", "=", "str", ",", "help", "=", "\"Output directory name without extention to save final csv file. There should \"", "\n", "\"be the same number of output files parameters as the number of config files.\"", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.reproducibility.get_results": [[27, 39], ["os.path.join", "os.path.exists", "ivadomed.main.run_command", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_command"], ["", "def", "get_results", "(", "context", ")", ":", "\n", "    ", "context", "[", "\"command\"", "]", "=", "\"test\"", "\n", "pred_mask_path", "=", "os", ".", "path", ".", "join", "(", "context", "[", "\"path_output\"", "]", ",", "\"pred_masks\"", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "pred_mask_path", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "pred_mask_path", ")", "\n", "\n", "# RandomAffine will be applied during testing", "\n", "", "if", "\"dataset_type\"", "in", "context", "[", "\"transformation\"", "]", "[", "\"RandomAffine\"", "]", ":", "\n", "        ", "del", "context", "[", "\"transformation\"", "]", "[", "\"RandomAffine\"", "]", "[", "\"dataset_type\"", "]", "\n", "", "if", "\"scale\"", "in", "context", "[", "\"transformation\"", "]", "[", "\"RandomAffine\"", "]", ":", "\n", "        ", "del", "context", "[", "\"transformation\"", "]", "[", "\"RandomAffine\"", "]", "[", "\"scale\"", "]", "\n", "", "return", "ivado", ".", "run_command", "(", "context", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.reproducibility.compute_csa": [[41, 79], ["list", "df_results.assign.assign", "os.path.join", "os.system", "pandas.read_csv", "float", "os.remove", "os.path.join", "nibabel.load", "nibabel.Nifti1Image", "nibabel.save", "os.system", "pandas.read_csv", "float", "os.remove", "os.system", "abs", "subject.split", "nib.load.get_fdata", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "compute_csa", "(", "config", ",", "df_results", ",", "logdir", ",", "bids", ")", ":", "\n", "    ", "subject_list", "=", "list", "(", "df_results", ".", "index", ")", "\n", "# Create empty columns", "\n", "df_results", "=", "df_results", ".", "assign", "(", "csa_pred", "=", "\"\"", ",", "csa_gt", "=", "\"\"", ",", "absolute_csa_diff", "=", "\"\"", ",", "relative_csa_diff", "=", "\"\"", ")", "\n", "for", "subject", "in", "subject_list", ":", "\n", "# Get GT csa", "\n", "        ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "bids", ",", "\"derivatives\"", ",", "\"labels\"", ",", "subject", ".", "split", "(", "\"_\"", ")", "[", "0", "]", ",", "\n", "\"anat\"", ",", "subject", "+", "config", "[", "\"loader_parameters\"", "]", "[", "\"target_suffix\"", "]", "[", "0", "]", "+", "\".nii.gz\"", ")", "\n", "os", ".", "system", "(", "f\"sct_process_segmentation  -i {gt_path} -perslice 1 -angle-corr 0 -o csa.csv\"", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "\"csa.csv\"", ")", "\n", "# Take only the medial slice", "\n", "csa_gt", "=", "float", "(", "df", "[", "\"MEAN(area)\"", "]", "[", "len", "(", "df", "[", "\"MEAN(area)\"", "]", ")", "//", "2", "]", ")", "\n", "os", ".", "remove", "(", "\"csa.csv\"", ")", "\n", "\n", "# Get prediction csa", "\n", "pred_path", "=", "os", ".", "path", ".", "join", "(", "logdir", ",", "\"pred_masks\"", ",", "subject", "+", "\"_pred.nii.gz\"", ")", "\n", "pred_nii", "=", "nib", ".", "load", "(", "pred_path", ")", "\n", "# Keep only first label to compute csa", "\n", "single_label_pred", "=", "nib", ".", "Nifti1Image", "(", "pred_nii", ".", "get_fdata", "(", ")", "[", "...", ",", "0", "]", ",", "pred_nii", ".", "affine", ")", "\n", "single_label_pred_path", "=", "\"pred_single_label.nii.gz\"", "\n", "nib", ".", "save", "(", "single_label_pred", ",", "single_label_pred_path", ")", "\n", "os", ".", "system", "(", "\n", "f\"sct_process_segmentation -i {single_label_pred_path} -perslice 1 -angle-corr 0 -o csa.csv\"", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "\"csa.csv\"", ")", "\n", "# Take only the medial slice", "\n", "csa_pred", "=", "float", "(", "df", "[", "\"MEAN(area)\"", "]", "[", "len", "(", "df", "[", "\"MEAN(area)\"", "]", ")", "//", "2", "]", ")", "\n", "\n", "# Remove files", "\n", "os", ".", "remove", "(", "\"csa.csv\"", ")", "\n", "os", ".", "system", "(", "f\"rm {single_label_pred_path}\"", ")", "\n", "\n", "# Populate df with csa stats", "\n", "df_results", ".", "at", "[", "subject", ",", "'csa_pred'", "]", "=", "csa_pred", "\n", "df_results", ".", "at", "[", "subject", ",", "'csa_gt'", "]", "=", "csa_gt", "\n", "df_results", ".", "at", "[", "subject", ",", "'absolute_csa_diff'", "]", "=", "abs", "(", "csa_gt", "-", "csa_pred", ")", "/", "csa_gt", "\n", "df_results", ".", "at", "[", "subject", ",", "'relative_csa_diff'", "]", "=", "(", "csa_gt", "-", "csa_pred", ")", "/", "csa_gt", "\n", "\n", "", "return", "df_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.reproducibility.main": [[81, 102], ["reproducibility.get_parser", "get_parser.parse_args", "zip", "os.path.join", "ivadomed.config_manager.ConfigurationManager().get_config", "range", "numpy.average", "numpy.average", "pandas.DataFrame().to_csv", "int", "reproducibility.get_results", "reproducibility.compute_csa", "list", "df_list.append", "numpy.average", "numpy.std", "ivadomed.config_manager.ConfigurationManager", "numpy.array", "numpy.array", "numpy.array", "pandas.DataFrame", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.reproducibility.compute_csa"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "for", "logdir", ",", "output_path", "in", "zip", "(", "args", ".", "logdir", ",", "args", ".", "output_path", ")", ":", "\n", "        ", "config", "=", "os", ".", "path", ".", "join", "(", "logdir", ",", "\"config_file.json\"", ")", "\n", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "config", ")", ".", "get_config", "(", ")", "\n", "\n", "df_list", "=", "[", "]", "\n", "metrics", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "int", "(", "args", ".", "iterations", ")", ")", ":", "\n", "            ", "df", "=", "get_results", "(", "context", ")", "\n", "df", "=", "compute_csa", "(", "context", ",", "df", ",", "logdir", ",", "args", ".", "bids", ")", "\n", "metrics", "=", "list", "(", "df", ".", "columns", ")", "\n", "df_list", ".", "append", "(", "np", ".", "array", "(", "df", ")", ")", "\n", "\n", "# Get average and std for each subject (intra subject), then average on all subjects", "\n", "", "average", "=", "np", ".", "average", "(", "np", ".", "average", "(", "np", ".", "array", "(", "df_list", ")", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "std", "=", "np", ".", "average", "(", "np", ".", "std", "(", "np", ".", "array", "(", "df_list", ",", "dtype", "=", "np", ".", "float", ")", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "pd", ".", "DataFrame", "(", "np", ".", "stack", "(", "[", "average", ",", "std", "]", ",", "axis", "=", "1", ")", ",", "index", "=", "metrics", ",", "columns", "=", "[", "\"mean\"", ",", "\"std\"", "]", ")", ".", "to_csv", "(", "output_path", "+", "\n", "\".csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.metadata_config.run_main": [[15, 46], ["torchvision.transforms.Compose", "tqdm.tqdm", "open", "json.dump", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.NumpyToTensor", "ivadomed.transforms.NormalizeInstance", "ivadomed.loader.bids_dataset.BidsDataset", "list", "set", "ivadomed.loader.slice_filter.SliceFilter"], "function", ["None"], ["def", "run_main", "(", "context", ")", ":", "\n", "    ", "no_transform", "=", "torch_transforms", ".", "Compose", "(", "[", "\n", "imed_transforms", ".", "CenterCrop", "(", "[", "128", ",", "128", "]", ")", ",", "\n", "imed_transforms", ".", "NumpyToTensor", "(", ")", ",", "\n", "imed_transforms", ".", "NormalizeInstance", "(", ")", ",", "\n", "]", ")", "\n", "\n", "out_dir", "=", "context", "[", "\"path_output\"", "]", "\n", "metadata_dct", "=", "{", "}", "\n", "for", "subset", "in", "[", "'train'", ",", "'validation'", ",", "'test'", "]", ":", "\n", "        ", "metadata_dct", "[", "subset", "]", "=", "{", "}", "\n", "for", "bids_ds", "in", "tqdm", "(", "context", "[", "\"path_data_\"", "+", "subset", "]", ",", "desc", "=", "\"Loading \"", "+", "subset", "+", "\" set\"", ")", ":", "\n", "            ", "ds", "=", "BidsDataset", "(", "bids_ds", ",", "\n", "contrast_lst", "=", "context", "[", "\"contrast_train_validation\"", "]", "\n", "if", "subset", "!=", "\"test\"", "else", "context", "[", "\"contrast_test\"", "]", ",", "\n", "transform", "=", "no_transform", ",", "\n", "slice_filter_fn", "=", "SliceFilter", "(", ")", ")", "\n", "\n", "for", "m", "in", "metadata_type", ":", "\n", "                ", "if", "m", "in", "metadata_dct", ":", "\n", "                    ", "metadata_dct", "[", "subset", "]", "[", "m", "]", "=", "[", "v", "for", "m_lst", "in", "[", "metadata_dct", "[", "subset", "]", "[", "m", "]", ",", "ds", ".", "metadata", "[", "m", "]", "]", "for", "v", "in", "m_lst", "]", "\n", "", "else", ":", "\n", "                    ", "metadata_dct", "[", "subset", "]", "[", "m", "]", "=", "ds", ".", "metadata", "[", "m", "]", "\n", "\n", "", "", "", "for", "m", "in", "metadata_type", ":", "\n", "            ", "metadata_dct", "[", "subset", "]", "[", "m", "]", "=", "list", "(", "set", "(", "metadata_dct", "[", "subset", "]", "[", "m", "]", ")", ")", "\n", "\n", "", "", "with", "open", "(", "out_dir", "+", "\"/metadata_config.json\"", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "metadata_dct", ",", "fp", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.target_size.get_parser": [[32, 37], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "help", "=", "\"Config file path.\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.target_size.plot_distrib": [[39, 52], ["matplotlib.figure", "seaborn.distplot", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.ylabel", "plt.figure.savefig", "loguru.logger.info"], "function", ["None"], ["", "def", "plot_distrib", "(", "arr", ",", "label", ",", "xlim", ",", "fname_out", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "\n", "sns", ".", "distplot", "(", "arr", ",", "hist", "=", "False", ",", "kde", "=", "True", ",", "rug", "=", "True", ",", "\n", "color", "=", "'darkblue'", ",", "\n", "kde_kws", "=", "{", "'linewidth'", ":", "2", "}", ",", "\n", "rug_kws", "=", "{", "'color'", ":", "'black'", "}", ")", "\n", "\n", "plt", ".", "xlabel", "(", "label", ")", "\n", "plt", ".", "xlim", "(", "xlim", ")", "\n", "plt", ".", "ylabel", "(", "'Density'", ")", "\n", "fig", ".", "savefig", "(", "fname_out", ")", "\n", "logger", ".", "info", "(", "f\"\\tSave as: {fname_out}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.target_size.run_main": [[54, 95], ["ivadomed.config_manager.ConfigurationManager().get_config", "os.path.join", "scipy.ndimage.generate_binary_structure", "os.listdir", "loguru.logger.debug", "ivadomed.utils.print_stats", "target_size.plot_distrib", "loguru.logger.info", "ivadomed.utils.print_stats", "target_size.plot_distrib", "os.path.join", "os.path.isdir", "ivadomed.config_manager.ConfigurationManager", "os.listdir", "numpy.percentile", "numpy.percentile", "[].split", "f.endswith", "os.path.join", "nibabel.load", "numpy.asanyarray", "numpy.any", "scipy.ndimage.label", "range", "numpy.count_nonzero", "vox_lst.append", "mm3_lst.append", "f.split"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.print_stats", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.target_size.plot_distrib", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.print_stats", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.target_size.plot_distrib"], ["", "def", "run_main", "(", "args", ")", ":", "\n", "    ", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "args", ".", "c", ")", ".", "get_config", "(", ")", "\n", "\n", "path_folder", "=", "os", ".", "path", ".", "join", "(", "context", "[", "'path_data'", "]", ",", "'derivatives'", ",", "'labels'", ")", "\n", "\n", "bin_struct", "=", "generate_binary_structure", "(", "3", ",", "2", ")", "# 18-connectivity", "\n", "\n", "vox_lst", ",", "mm3_lst", "=", "[", "]", ",", "[", "]", "\n", "for", "s", "in", "os", ".", "listdir", "(", "path_folder", ")", ":", "\n", "        ", "s_fold", "=", "os", ".", "path", ".", "join", "(", "path_folder", ",", "s", ",", "'anat'", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "s_fold", ")", ":", "\n", "            ", "for", "f", "in", "os", ".", "listdir", "(", "s_fold", ")", ":", "\n", "                ", "c", "=", "f", ".", "split", "(", "s", "+", "'_'", ")", "[", "-", "1", "]", ".", "split", "(", "context", "[", "\"target_suffix\"", "]", ")", "[", "0", "]", "\n", "if", "f", ".", "endswith", "(", "context", "[", "\"target_suffix\"", "]", "+", "'.nii.gz'", ")", "and", "c", "in", "context", "[", "\"contrast_test\"", "]", ":", "\n", "                    ", "f_path", "=", "os", ".", "path", ".", "join", "(", "s_fold", ",", "f", ")", "\n", "im", "=", "nib", ".", "load", "(", "f_path", ")", "\n", "data", "=", "np", ".", "asanyarray", "(", "im", ".", "dataobj", ")", "\n", "px", ",", "py", ",", "pz", "=", "im", ".", "header", "[", "'pixdim'", "]", "[", "1", ":", "4", "]", "\n", "del", "im", "\n", "\n", "if", "np", ".", "any", "(", "data", ")", ":", "\n", "                        ", "data_label", ",", "n", "=", "label", "(", "data", ",", "\n", "structure", "=", "bin_struct", ")", "\n", "for", "idx", "in", "range", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "                            ", "data_idx", "=", "(", "data_label", "==", "idx", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "n_vox", "=", "np", ".", "count_nonzero", "(", "data_idx", ")", "\n", "vox_lst", ".", "append", "(", "n_vox", ")", "\n", "mm3_lst", ".", "append", "(", "n_vox", "*", "px", "*", "py", "*", "pz", ")", "\n", "\n", "", "", "", "", "", "", "logger", ".", "debug", "(", "\"\\nTarget distribution in vox:\"", ")", "\n", "imed_utils", ".", "print_stats", "(", "vox_lst", ")", "\n", "plot_distrib", "(", "vox_lst", ",", "context", "[", "\"target_suffix\"", "]", "+", "' size in vox'", ",", "\n", "[", "0", ",", "np", ".", "percentile", "(", "vox_lst", ",", "90", ")", "]", ",", "\n", "context", "[", "\"target_suffix\"", "]", "+", "'_vox.png'", ")", "\n", "\n", "logger", ".", "info", "(", "\"\\nTarget distribution in mm3:\"", ")", "\n", "imed_utils", ".", "print_stats", "(", "mm3_lst", ")", "\n", "plot_distrib", "(", "mm3_lst", ",", "context", "[", "\"target_suffix\"", "]", "+", "' size in mm3'", ",", "\n", "[", "0", ",", "np", ".", "percentile", "(", "mm3_lst", ",", "90", ")", "]", ",", "\n", "context", "[", "\"target_suffix\"", "]", "+", "'_mm3.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.data_aug_dilation.save_sample": [[17, 27], ["matplotlib.figure", "matplotlib.subplot", "matplotlib.axis", "matplotlib.imshow", "matplotlib.savefig", "matplotlib.close"], "function", ["None"], ["def", "save_sample", "(", "img", ",", "fname_out", ")", ":", "\n", "    ", "plt", ".", "figure", "(", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "\n", "plt", ".", "imshow", "(", "img", ",", "interpolation", "=", "'nearest'", ",", "aspect", "=", "'auto'", ",", "cmap", "=", "'jet'", ",", "vmin", "=", "0", ",", "vmax", "=", "1", ")", "\n", "\n", "plt", ".", "savefig", "(", "fname_out", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.data_aug_dilation.dilate_mask": [[29, 78], ["numpy.copy", "numpy.where", "random.random", "random.sample", "scipy.ndimage.measurements.label", "range", "scipy.ndimage.morphology.binary_fill_holes", "scipy.ndimage.morphology.binary_closing", "mask.astype", "mask.astype", "scipy.ndimage.morphology.binary_dilation", "numpy.logical_xor().astype", "numpy.logical_xor", "range", "int", "scipy.ndimage.morphology.binary_closing.astype", "range", "round", "numpy.sum", "numpy.logical_xor"], "function", ["None"], ["", "def", "dilate_mask", "(", "mask", ",", "nb_dilation_it", "=", "3", ")", ":", "\n", "# values of the voxels added to the input mask", "\n", "    ", "soft_label_values", "=", "[", "x", "/", "(", "nb_dilation_it", "+", "1", ")", "for", "x", "in", "range", "(", "nb_dilation_it", ",", "0", ",", "-", "1", ")", "]", "\n", "\n", "# dilation", "\n", "mask_bin", ",", "mask_soft", "=", "mask", ".", "astype", "(", "np", ".", "int", ")", ",", "mask", ".", "astype", "(", "np", ".", "float", ")", "\n", "for", "soft_label", "in", "soft_label_values", ":", "\n", "# binary dilation with 1 iteration", "\n", "        ", "mask_dilated", "=", "binary_dilation", "(", "mask_bin", ",", "iterations", "=", "1", ")", "\n", "\n", "# isolate new voxels, i.e. the ones from the dilation", "\n", "new_voxels", "=", "np", ".", "logical_xor", "(", "mask_dilated", ",", "mask_bin", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "# assign a soft value (]0, 1[) to the new voxels", "\n", "soft_new_voxels", "=", "soft_label", "*", "new_voxels", "\n", "\n", "# add the new voxels to the input mask", "\n", "mask_soft", "+=", "soft_new_voxels", "\n", "mask_bin", "=", "(", "mask_soft", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "# save the mask after dilation, used later during post-processing", "\n", "", "mask_after_dilation", "=", "np", ".", "copy", "(", "mask_soft", ")", "\n", "\n", "# coordinates of the new voxels, i.e. the ones from the dilation", "\n", "new_voxels_xx", ",", "new_voxels_yy", "=", "np", ".", "where", "(", "np", ".", "logical_xor", "(", "mask_bin", ",", "mask", ")", ")", "\n", "nb_new_voxels", "=", "new_voxels_xx", ".", "shape", "[", "0", "]", "\n", "\n", "# ratio of voxels added to the input mask from the dilated mask", "\n", "new_voxel_ratio", "=", "random", ".", "random", "(", ")", "\n", "# randomly select new voxel indexes to remove", "\n", "idx_to_remove", "=", "random", ".", "sample", "(", "range", "(", "nb_new_voxels", ")", ",", "\n", "int", "(", "round", "(", "nb_new_voxels", "*", "(", "1", "-", "new_voxel_ratio", ")", ")", ")", ")", "\n", "# set to zero the here-above randomly selected new voxels", "\n", "mask_soft", "[", "new_voxels_xx", "[", "idx_to_remove", "]", ",", "new_voxels_yy", "[", "idx_to_remove", "]", "]", "=", "0", "\n", "mask_bin", "=", "(", "mask_soft", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "# remove new object that are not connected to the input mask", "\n", "mask_labeled", ",", "labels_nb", "=", "label", "(", "mask_bin", ")", "\n", "connected_to_input_mask", "=", "mask_labeled", "*", "mask", "\n", "for", "label_value", "in", "range", "(", "1", ",", "labels_nb", "+", "1", ")", ":", "\n", "        ", "if", "np", ".", "sum", "(", "connected_to_input_mask", "==", "label_value", ")", "==", "0", ":", "\n", "            ", "mask_soft", "[", "mask_labeled", "==", "label_value", "]", "=", "0", "\n", "\n", "# fill binary holes", "\n", "", "", "mask_bin", "=", "binary_fill_holes", "(", "(", "mask_soft", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", ")", "\n", "# binary closing", "\n", "mask_bin", "=", "binary_closing", "(", "mask_bin", ".", "astype", "(", "np", ".", "int", ")", ")", "\n", "# recover the soft-value assigned to the filled-holes", "\n", "mask_out", "=", "mask_bin", "*", "mask_after_dilation", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.data_aug_dilation.run_main": [[81, 88], ["spinalcordtoolbox.image.Image", "range", "data_aug_dilation.dilate_mask", "random.sample", "range"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.data_aug_dilation.dilate_mask"], ["", "def", "run_main", "(", "mask", ")", ":", "\n", "\n", "    ", "mask_im", "=", "Image", "(", "mask", ")", "# assume RPI orientation", "\n", "mask_data", "=", "mask_im", ".", "data", "[", ":", ",", ":", ",", "random", ".", "sample", "(", "range", "(", "mask_im", ".", "dim", "[", "2", "]", ")", ",", "1", ")", "[", "0", "]", "]", "\n", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "        ", "dilate_mask", "(", "(", "mask_data", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", ",", "nb_dilation_it", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.seek_contrast_sctTesting.run_main": [[14, 34], ["loguru.logger.info", "tqdm.tqdm", "list", "loguru.logger.info", "loguru.logger.info", "os.path.isdir", "loguru.logger.warning", "loguru.logger.warning", "os.path.join", "contrast_lst_lst.append", "set", "os.listdir", "os.path.isdir", "os.path.join", "len", "os.listdir", "i.endswith", "len", "[].split", "c.split"], "function", ["None"], ["def", "run_main", "(", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "isdir", "(", "PATH_SCTTESTING", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "f\"\\nThis folder does not exist: {PATH_SCTTESTING}\"", ")", "\n", "logger", ".", "warning", "(", "\"Please change the path at the top of this file\"", ")", "\n", "\n", "", "subj_lst", "=", "[", "os", ".", "path", ".", "join", "(", "PATH_SCTTESTING", ",", "s", ",", "'anat'", ")", "for", "s", "in", "os", ".", "listdir", "(", "PATH_SCTTESTING", ")", "if", "\n", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "join", "(", "PATH_SCTTESTING", ",", "s", ",", "'anat'", ")", ")", "]", "\n", "logger", ".", "info", "(", "f\"\\n{len(subj_lst)} subjects found.\\n\"", ")", "\n", "\n", "contrast_lst_lst", "=", "[", "]", "\n", "for", "subj_fold", "in", "tqdm", "(", "subj_lst", ",", "desc", "=", "\"Scanning dataset\"", ")", ":", "\n", "        ", "img_lst", "=", "[", "i", "for", "i", "in", "os", ".", "listdir", "(", "subj_fold", ")", "if", "i", ".", "endswith", "(", "'.nii.gz'", ")", "]", "\n", "contrast_cur_lst", "=", "[", "'_'", ".", "join", "(", "c", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "1", ":", "]", ")", "for", "c", "in", "img_lst", "]", "\n", "contrast_lst_lst", ".", "append", "(", "contrast_cur_lst", ")", "\n", "\n", "", "contrast_lst", "=", "[", "sublst", "for", "lst", "in", "contrast_lst_lst", "for", "sublst", "in", "lst", "]", "\n", "contrast_lst_noDuplicate", "=", "list", "(", "set", "(", "contrast_lst", ")", ")", "\n", "logger", ".", "info", "(", "f\"\\n{len(contrast_lst_noDuplicate)} contrasts found.\\n\"", ")", "\n", "\n", "logger", ".", "info", "(", "f\"['{', '.join(contrast_lst_noDuplicate)}']\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_cluster_metadata.plot_decision_boundaries": [[26, 51], ["matplotlib.figure", "numpy.meshgrid", "numpy.asarray().reshape", "matplotlib.contourf", "zip", "matplotlib.xlabel", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.yticks", "plt.figure.savefig", "loguru.logger.info", "numpy.arange", "numpy.arange", "model.predict", "matplotlib.scatter", "xx.min", "xx.max", "yy.min", "yy.max", "matplotlib.xscale", "xx.ravel", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.predict"], ["def", "plot_decision_boundaries", "(", "data", ",", "model", ",", "x_range", ",", "metadata_name", ",", "fname_out", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "\n", "x_min", ",", "x_max", "=", "x_range", "[", "0", "]", ",", "x_range", "[", "1", "]", "\n", "y_min", ",", "y_max", "=", "0", ",", "(", "x_max", "-", "x_min", ")", "*", "0.2", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "np", ".", "arange", "(", "x_min", ",", "x_max", ",", "x_range", "[", "2", "]", ")", ",", "\n", "np", ".", "arange", "(", "y_min", ",", "y_max", ",", "x_range", "[", "2", "]", ")", ")", "\n", "\n", "Z", "=", "[", "model", ".", "predict", "(", "v", ")", "for", "v", "in", "xx", ".", "ravel", "(", ")", "]", "\n", "Z", "=", "np", ".", "asarray", "(", "Z", ")", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "\n", "plt", ".", "contourf", "(", "xx", ",", "yy", ",", "Z", ",", "cmap", "=", "plt", ".", "cm", ".", "jet", ",", "alpha", "=", "0.8", ")", "\n", "\n", "for", "s", ",", "y_val", "in", "zip", "(", "[", "'train'", ",", "'valid'", ",", "'test'", "]", ",", "[", "0.25", ",", "0.5", ",", "0.75", "]", ")", ":", "\n", "        ", "plt", ".", "scatter", "(", "data", "[", "s", "]", "[", "metadata_name", "]", ",", "[", "(", "y_max", "-", "y_min", ")", "*", "y_val", "for", "v", "in", "data", "[", "s", "]", "[", "metadata_name", "]", "]", ",", "c", "=", "'k'", ")", "\n", "\n", "", "plt", ".", "xlabel", "(", "metadata_name", ")", "\n", "plt", ".", "xlim", "(", "xx", ".", "min", "(", ")", ",", "xx", ".", "max", "(", ")", ")", "\n", "plt", ".", "ylim", "(", "yy", ".", "min", "(", ")", ",", "yy", ".", "max", "(", ")", ")", "\n", "plt", ".", "yticks", "(", "(", ")", ")", "\n", "if", "metadata_name", "!=", "'FlipAngle'", ":", "\n", "        ", "plt", ".", "xscale", "(", "'log'", ")", "\n", "\n", "", "fig", ".", "savefig", "(", "fname_out", ")", "\n", "logger", ".", "info", "(", "f\"\\tSave as: {fname_out}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_cluster_metadata.run_main": [[53, 88], ["torchvision.transforms.Compose", "sklearn.externals.joblib.load", "sklearn.externals.joblib.load", "os.path.join", "os.path.join", "ivadomed.loader.bids_dataset.BidsDataset", "os.path.join", "os.path.isdir", "os.makedirs", "loguru.logger.info", "plot_cluster_metadata.plot_decision_boundaries", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.NumpyToTensor", "ivadomed.transforms.NormalizeInstance", "os.path.join", "ivadomed.loader.slice_filter.SliceFilter", "min", "max", "numpy.median"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_cluster_metadata.plot_decision_boundaries"], ["", "def", "run_main", "(", "context", ")", ":", "\n", "    ", "no_transform", "=", "torch_transforms", ".", "Compose", "(", "[", "\n", "imed_transforms", ".", "CenterCrop", "(", "[", "128", ",", "128", "]", ")", ",", "\n", "imed_transforms", ".", "NumpyToTensor", "(", ")", ",", "\n", "imed_transforms", ".", "NormalizeInstance", "(", ")", ",", "\n", "]", ")", "\n", "\n", "out_dir", "=", "context", "[", "\"path_output\"", "]", "\n", "split_dct", "=", "joblib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "\"split_datasets.joblib\"", ")", ")", "\n", "metadata_dct", "=", "{", "}", "\n", "for", "subset", "in", "[", "'train'", ",", "'valid'", ",", "'test'", "]", ":", "\n", "        ", "metadata_dct", "[", "subset", "]", "=", "{", "}", "\n", "ds", "=", "BidsDataset", "(", "context", "[", "\"path_data\"", "]", ",", "\n", "subject_lst", "=", "split_dct", "[", "subset", "]", ",", "\n", "contrast_lst", "=", "context", "[", "\"contrast_train_validation\"", "]", "\n", "if", "subset", "!=", "\"test\"", "else", "context", "[", "\"contrast_test\"", "]", ",", "\n", "transform", "=", "no_transform", ",", "\n", "slice_filter_fn", "=", "SliceFilter", "(", ")", ")", "\n", "\n", "for", "m", "in", "metadata_type", ":", "\n", "            ", "if", "m", "in", "metadata_dct", ":", "\n", "                ", "metadata_dct", "[", "subset", "]", "[", "m", "]", "=", "[", "v", "for", "m_lst", "in", "[", "metadata_dct", "[", "subset", "]", "[", "m", "]", ",", "ds", ".", "metadata", "[", "m", "]", "]", "for", "v", "in", "m_lst", "]", "\n", "", "else", ":", "\n", "                ", "metadata_dct", "[", "subset", "]", "[", "m", "]", "=", "ds", ".", "metadata", "[", "m", "]", "\n", "\n", "", "", "", "cluster_dct", "=", "joblib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "\"clustering_models.joblib\"", ")", ")", "\n", "\n", "out_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "\"cluster_metadata\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "for", "m", "in", "metadata_type", ":", "\n", "        ", "values", "=", "[", "v", "for", "s", "in", "[", "'train'", ",", "'valid'", ",", "'test'", "]", "for", "v", "in", "metadata_dct", "[", "s", "]", "[", "m", "]", "]", "\n", "logger", ".", "info", "(", "f\"\\n{m}: Min={min(values)}, Max={max(values)}, Median={np.median(values)}\"", ")", "\n", "plot_decision_boundaries", "(", "metadata_dct", ",", "cluster_dct", "[", "m", "]", ",", "metadata_range", "[", "m", "]", ",", "m", ",", "os", ".", "path", ".", "join", "(", "out_dir", ",", "m", "+", "'.png'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.class_balance.get_parser": [[30, 35], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "help", "=", "\"Config file path.\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.class_balance.run_main": [[37, 86], ["ivadomed.config_manager.ConfigurationManager().get_config", "torchvision.transforms.Compose", "ivadomed.loader.utils.split_dataset", "zip", "loguru.logger.info", "ivadomed.utils.print_stats", "loguru.logger.info", "ivadomed.loader.bids_dataset.BidsDataset", "loguru.logger.info", "torch.utils.data.DataLoader", "enumerate", "loguru.logger.info", "ivadomed.utils.print_stats", "ivadomed.config_manager.ConfigurationManager", "ivadomed.transforms.Resample", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.NumpyToTensor", "ivadomed.transforms.NormalizeInstance", "balance_lst.append", "ivadomed.loader.slice_filter.SliceFilter", "batch[].numpy().astype", "len", "batch[].numpy"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.split_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.print_stats", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.print_stats"], ["", "def", "run_main", "(", "args", ")", ":", "\n", "    ", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "args", ".", "c", ")", ".", "get_config", "(", ")", "\n", "\n", "transform_lst", "=", "torch_transforms", ".", "Compose", "(", "[", "\n", "imed_transforms", ".", "Resample", "(", "wspace", "=", "0.75", ",", "hspace", "=", "0.75", ")", ",", "\n", "imed_transforms", ".", "CenterCrop", "(", "[", "128", ",", "128", "]", ")", ",", "\n", "imed_transforms", ".", "NumpyToTensor", "(", ")", ",", "\n", "imed_transforms", ".", "NormalizeInstance", "(", ")", ",", "\n", "]", ")", "\n", "\n", "train_lst", ",", "valid_lst", ",", "test_lst", "=", "imed_loader_utils", ".", "split_dataset", "(", "context", "[", "\"path_data\"", "]", ",", "\n", "context", "[", "\"center_test\"", "]", ",", "\n", "context", "[", "\"split_method\"", "]", ",", "\n", "context", "[", "\"random_seed\"", "]", ")", "\n", "\n", "balance_dct", "=", "{", "}", "\n", "for", "ds_lst", ",", "ds_name", "in", "zip", "(", "[", "train_lst", ",", "valid_lst", ",", "test_lst", "]", ",", "[", "'train'", ",", "'valid'", ",", "'test'", "]", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"\\nLoading {ds_name} set.\\n\"", ")", "\n", "ds", "=", "BidsDataset", "(", "context", "[", "\"path_data\"", "]", ",", "\n", "subject_lst", "=", "ds_lst", ",", "\n", "target_suffix", "=", "context", "[", "\"target_suffix\"", "]", ",", "\n", "contrast_lst", "=", "context", "[", "\"contrast_test\"", "]", "if", "ds_name", "==", "'test'", "\n", "else", "context", "[", "\"contrast_train_validation\"", "]", ",", "\n", "metadata_choice", "=", "context", "[", "\"metadata\"", "]", ",", "\n", "contrast_balance", "=", "context", "[", "\"contrast_balance\"", "]", ",", "\n", "transform", "=", "transform_lst", ",", "\n", "slice_filter_fn", "=", "SliceFilter", "(", ")", ")", "\n", "\n", "logger", ".", "info", "(", "f\"Loaded {len(ds)} axial slices for the {ds_name} set.\"", ")", "\n", "ds_loader", "=", "DataLoader", "(", "ds", ",", "batch_size", "=", "1", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "1", ")", "\n", "\n", "balance_lst", "=", "[", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "ds_loader", ")", ":", "\n", "            ", "gt_sample", "=", "batch", "[", "\"gt\"", "]", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "int", ")", "[", "0", ",", "0", ",", ":", ",", ":", "]", "\n", "nb_ones", "=", "(", "gt_sample", "==", "1", ")", ".", "sum", "(", ")", "\n", "nb_voxels", "=", "gt_sample", ".", "size", "\n", "balance_lst", ".", "append", "(", "nb_ones", "*", "100.0", "/", "nb_voxels", ")", "\n", "\n", "", "balance_dct", "[", "ds_name", "]", "=", "balance_lst", "\n", "\n", "", "for", "ds_name", "in", "balance_dct", ":", "\n", "        ", "logger", ".", "info", "(", "f\"\\nClass balance in {ds_name} set:\"", ")", "\n", "imed_utils", ".", "print_stats", "(", "balance_dct", "[", "ds_name", "]", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"\\nClass balance in full set:\"", ")", "\n", "imed_utils", ".", "print_stats", "(", "[", "e", "for", "d", "in", "balance_dct", "for", "e", "in", "balance_dct", "[", "d", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.plot_histogram": [[21, 41], ["numpy.linspace", "matplotlib.figure", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "numpy.array().ravel", "matplotlib.hist", "plt.figure.savefig", "numpy.array", "functools.reduce"], "function", ["None"], ["def", "plot_histogram", "(", "data", ",", "layer_no", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"\n    Save the histograms showing the frequency of the values inside gammas or betas tensors for one layer.\n\n    :param data: input data, which are gammas or betas for one layer\n    :param layer_no: number of the layer to consider\n    :param fname_out: directory to save the figure\n    \"\"\"", "\n", "bins", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "100", ")", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "12", ")", ")", "\n", "plt", ".", "title", "(", "f'Histogram: Layer {layer_no}'", ")", "\n", "plt", ".", "xlabel", "(", "'Value'", ")", "\n", "plt", ".", "ylabel", "(", "'Frequency'", ")", "\n", "\n", "# Flatten data", "\n", "data", "=", "np", ".", "array", "(", "functools", ".", "reduce", "(", "operator", ".", "iconcat", ",", "data", ",", "[", "]", ")", ")", ".", "ravel", "(", ")", "\n", "\n", "plt", ".", "hist", "(", "data", ",", "bins", ")", "\n", "fig", ".", "savefig", "(", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_pca": [[43, 77], ["pandas.DataFrame", "sklearn.decomposition.PCA", "numpy.concatenate", "numpy.array().ravel", "sklearn.decomposition.PCA.fit_transform", "pandas.DataFrame", "pandas.concat", "matplotlib.figure", "matplotlib.title", "seaborn.scatterplot", "plt.figure.savefig", "list", "numpy.array", "functools.reduce"], "function", ["None"], ["", "def", "visualize_pca", "(", "data", ",", "metadata_values", ",", "layer_no", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"\n    Save the PCA graphs showing gammas or betas tensors for one layer.\n\n    :param data: input data, which are gammas or betas for one layer\n    :param metadata_values: numpy array with the metadata values of all the images\n    :param layer_no: number of the layer to consider\n    :param fname_out: directory to save the figure\n    \"\"\"", "\n", "pca_df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "pca", "=", "PCA", "(", "n_components", "=", "2", ")", "\n", "\n", "# Dim 0 will be the number of examples", "\n", "data", "=", "np", ".", "concatenate", "(", "list", "(", "data", ")", ",", "axis", "=", "0", ")", "\n", "metadata_values", "=", "np", ".", "array", "(", "functools", ".", "reduce", "(", "operator", ".", "iconcat", ",", "metadata_values", ",", "[", "]", ")", ")", ".", "ravel", "(", ")", "\n", "\n", "pca_result", "=", "pca", ".", "fit_transform", "(", "data", ")", "\n", "pca_df2", "=", "pd", ".", "DataFrame", "(", ")", "\n", "pca_df2", "[", "'pca1'", "]", "=", "pca_result", "[", ":", ",", "0", "]", "\n", "pca_df2", "[", "'pca2'", "]", "=", "pca_result", "[", ":", ",", "1", "]", "\n", "pca_df2", "[", "'contrast'", "]", "=", "metadata_values", "\n", "pca_df", "=", "pd", ".", "concat", "(", "[", "pca_df", ",", "pca_df2", "]", ")", "\n", "\n", "# Create the graph and save it", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "16", ",", "10", ")", ")", "\n", "plt", ".", "title", "(", "f\"PCA: Layer {layer_no}\"", ")", "\n", "sns", ".", "scatterplot", "(", "\n", "x", "=", "\"pca1\"", ",", "y", "=", "\"pca2\"", ",", "\n", "hue", "=", "\"contrast\"", ",", "\n", "data", "=", "pca_df", ",", "\n", "legend", "=", "\"full\"", ",", "\n", "alpha", "=", "1", ")", "\n", "fig", ".", "savefig", "(", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_tsne": [[79, 119], ["pandas.DataFrame", "sklearn.manifold.TSNE", "numpy.concatenate", "numpy.array().ravel", "sklearn.manifold.TSNE.fit_transform", "pandas.DataFrame", "pandas.concat", "loguru.logger.info", "matplotlib.figure", "matplotlib.title", "seaborn.scatterplot", "plt.figure.savefig", "list", "numpy.array", "functools.reduce"], "function", ["None"], ["", "def", "visualize_tsne", "(", "data", ",", "metadata_values", ",", "layer_no", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"\n    Save the t-SNE graphs showing gammas or betas tensors for one layer.\n\n    :param data: input data, which are gammas or betas for one layer\n    :param metadata_values: numpy array with the metadata values of all the images\n    :param layer_no: number of the layer to consider\n    :param fname_out: directory to save the figure\n    \"\"\"", "\n", "tsne_df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "tsne", "=", "TSNE", "(", "n_components", "=", "2", ",", "verbose", "=", "1", ",", "perplexity", "=", "40", ",", "n_iter", "=", "300", ")", "\n", "\n", "# Dim 0 will be the number of examples", "\n", "data", "=", "np", ".", "concatenate", "(", "list", "(", "data", ")", ",", "axis", "=", "0", ")", "\n", "contrast_images", "=", "np", ".", "array", "(", "functools", ".", "reduce", "(", "operator", ".", "iconcat", ",", "metadata_values", ",", "[", "]", ")", ")", ".", "ravel", "(", ")", "\n", "\n", "tsne_results", "=", "tsne", ".", "fit_transform", "(", "data", ")", "\n", "tsne_df2", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "tsne_df2", "[", "'tsne-2d-one'", "]", "=", "tsne_results", "[", ":", ",", "0", "]", "\n", "tsne_df2", "[", "'tsne-2d-two'", "]", "=", "tsne_results", "[", ":", ",", "1", "]", "\n", "tsne_df2", "[", "'contrast'", "]", "=", "contrast_images", "\n", "\n", "tsne_df", "=", "pd", ".", "concat", "(", "[", "tsne_df", ",", "tsne_df2", "]", ")", "\n", "\n", "logger", ".", "info", "(", "\"t-SNE done!\"", ")", "\n", "\n", "# Visualize", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "16", ",", "10", ")", ")", "\n", "plt", ".", "title", "(", "f\"t-SNE: Layer {layer_no}\"", ")", "\n", "sns", ".", "scatterplot", "(", "\n", "x", "=", "\"tsne-2d-one\"", ",", "\n", "y", "=", "\"tsne-2d-two\"", ",", "\n", "hue", "=", "\"contrast\"", ",", "\n", "data", "=", "tsne_df", ",", "\n", "legend", "=", "\"full\"", ",", "\n", "alpha", "=", "1", "\n", ")", "\n", "fig", ".", "savefig", "(", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.run_main": [[121, 165], ["range", "numpy.load", "gammas.keys", "gammas.keys", "gammas.keys", "os.path.isdir", "os.makedirs", "plot_film_parameters.plot_histogram", "plot_film_parameters.plot_histogram", "plot_film_parameters.visualize_tsne", "plot_film_parameters.visualize_tsne", "numpy.load", "numpy.load", "plot_film_parameters.visualize_pca", "plot_film_parameters.visualize_pca", "numpy.load", "numpy.load", "loguru.logger.error", "loguru.logger.error"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.plot_histogram", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.plot_histogram", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_tsne", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_tsne", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_pca", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.plot_film_parameters.visualize_pca"], ["", "def", "run_main", "(", "context", ")", ":", "\n", "    ", "\"\"\"\n    Main command to create and save the graphs to visualize the film parameters.\n\n    :param context: this is a dictionary with all data from the\n                    configuration file from which we only use:\n                        - 'path_output': folder name where log files are saved\n    \"\"\"", "\n", "path_output", "=", "context", "[", "\"path_output\"", "]", "\n", "\n", "gammas", "=", "{", "}", "\n", "betas", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "1", ",", "9", ")", ":", "\n", "        ", "if", "np", ".", "load", "(", "path_output", "+", "f\"/gamma_layer_{i}.npy\"", ",", "allow_pickle", "=", "True", ")", ".", "size", "!=", "0", ":", "\n", "            ", "gammas", "[", "i", "]", "=", "np", ".", "load", "(", "path_output", "+", "f\"/gamma_layer_{i}.npy\"", ",", "allow_pickle", "=", "True", ")", "\n", "", "if", "np", ".", "load", "(", "path_output", "+", "f\"/beta_layer_{i}.npy\"", ",", "allow_pickle", "=", "True", ")", ".", "size", "!=", "0", ":", "\n", "            ", "betas", "[", "i", "]", "=", "np", ".", "load", "(", "path_output", "+", "f\"/beta_layer_{i}.npy\"", ",", "allow_pickle", "=", "True", ")", "\n", "\n", "", "", "metadata_values", "=", "np", ".", "load", "(", "path_output", "+", "\"/metadata_values.npy\"", ",", "allow_pickle", "=", "True", ")", "\n", "\n", "out_dir", "=", "context", "[", "\"path_output\"", "]", "+", "\"/film-parameters-visualization\"", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "# save histograms with gammas and betas values", "\n", "", "for", "layer_no", "in", "gammas", ".", "keys", "(", ")", ":", "\n", "        ", "plot_histogram", "(", "gammas", "[", "layer_no", "]", ",", "layer_no", ",", "out_dir", "+", "f\"/hist_gamma_{layer_no}.png\"", ")", "\n", "plot_histogram", "(", "betas", "[", "layer_no", "]", ",", "layer_no", ",", "out_dir", "+", "f\"/hist_beta_{layer_no}.png\"", ")", "\n", "\n", "# save PCA for betas and gammas except for the last layer due to gammas/betas shapes", "\n", "", "for", "layer_no", "in", "gammas", ".", "keys", "(", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "visualize_pca", "(", "gammas", "[", "layer_no", "]", ",", "metadata_values", ",", "layer_no", ",", "out_dir", "+", "f\"/pca_gamma_{layer_no}.png\"", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "logger", ".", "error", "(", "f\"No PCA for gamma from the film layer {layer_no} because of a too small dimension.\"", ")", "\n", "", "try", ":", "\n", "            ", "visualize_pca", "(", "betas", "[", "layer_no", "]", ",", "metadata_values", ",", "layer_no", ",", "out_dir", "+", "f\"/pca_beta_{layer_no}.png\"", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "logger", ".", "error", "(", "f\"No PCA for beta from the film layer {layer_no} because of a too small dimension.\"", ")", "\n", "\n", "# save tsne for betas and gammas", "\n", "", "", "for", "layer_no", "in", "gammas", ".", "keys", "(", ")", ":", "\n", "        ", "visualize_tsne", "(", "gammas", "[", "layer_no", "]", ",", "metadata_values", ",", "layer_no", ",", "out_dir", "+", "f\"/tsne_gamma_{layer_no}.png\"", ")", "\n", "visualize_tsne", "(", "betas", "[", "layer_no", "]", ",", "metadata_values", ",", "layer_no", ",", "out_dir", "+", "f\"/tsne_beta_{layer_no}.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.get_parser": [[47, 56], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "help", "=", "\"Config file path.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-thrUnc\"", ",", "help", "=", "\"Threshold to apply on uncertainty map.\"", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "\"-thrPred\"", ",", "help", "=", "\"Threshold to apply on prediction.\"", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "\"-suffixUnc\"", ",", "help", "=", "\"Suffix of the uncertainty map to use (e.g. _unc-vox).\"", ",", "default", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "\"-ofolder\"", ",", "help", "=", "\"Output folder.\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.auc_homemade": [[58, 67], ["list", "zip", "zip", "enumerate", "len", "zip"], "function", ["None"], ["", "def", "auc_homemade", "(", "fpr", ",", "tpr", ",", "trapezoid", "=", "False", ")", ":", "\n", "# source: https://stackoverflow.com/a/39687168", "\n", "    ", "inds", "=", "[", "i", "for", "(", "i", ",", "(", "s", ",", "e", ")", ")", "in", "enumerate", "(", "zip", "(", "fpr", "[", ":", "-", "1", "]", ",", "fpr", "[", "1", ":", "]", ")", ")", "if", "s", "!=", "e", "]", "+", "[", "len", "(", "fpr", ")", "-", "1", "]", "\n", "fpr", ",", "tpr", "=", "fpr", "[", "inds", "]", ",", "tpr", "[", "inds", "]", "\n", "area", "=", "0", "\n", "ft", "=", "list", "(", "zip", "(", "fpr", ",", "tpr", ")", ")", "\n", "for", "p0", ",", "p1", "in", "zip", "(", "ft", "[", ":", "-", "1", "]", ",", "ft", "[", "1", ":", "]", ")", ":", "\n", "        ", "area", "+=", "(", "p1", "[", "0", "]", "-", "p0", "[", "0", "]", ")", "*", "(", "(", "p1", "[", "1", "]", "+", "p0", "[", "1", "]", ")", "/", "2", "if", "trapezoid", "else", "p0", "[", "1", "]", ")", "\n", "", "return", "-", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.print_unc_stats": [[69, 86], ["zip", "os.path.join", "nibabel.load", "nib.load.get_data", "list", "len", "loguru.logger.debug", "mins.append", "maxs.append", "p25s.append", "p50s.append", "p75s.append", "numpy.min", "numpy.max", "numpy.percentile", "numpy.percentile", "numpy.percentile", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data"], ["", "def", "print_unc_stats", "(", "unc_name", ",", "pred_folder", ",", "im_lst", ")", ":", "\n", "    ", "mins", ",", "p25s", ",", "p50s", ",", "p75s", ",", "maxs", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "fname_pref", "in", "im_lst", ":", "\n", "        ", "fname_unc", "=", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "fname_pref", "+", "unc_name", "+", "'.nii.gz'", ")", "\n", "im", "=", "nib", ".", "load", "(", "fname_unc", ")", "\n", "data_unc", "=", "im", ".", "get_data", "(", ")", "\n", "del", "im", "\n", "vals", "=", "list", "(", "data_unc", "[", "data_unc", ">", "0", "]", ")", "\n", "if", "len", "(", "vals", ")", ":", "\n", "            ", "mins", ".", "append", "(", "np", ".", "min", "(", "vals", ")", ")", "\n", "maxs", ".", "append", "(", "np", ".", "max", "(", "vals", ")", ")", "\n", "p25s", ".", "append", "(", "np", ".", "percentile", "(", "vals", ",", "25", ")", ")", "\n", "p50s", ".", "append", "(", "np", ".", "percentile", "(", "vals", ",", "50", ")", ")", "\n", "p75s", ".", "append", "(", "np", ".", "percentile", "(", "vals", ",", "75", ")", ")", "\n", "\n", "", "", "for", "n", ",", "l", "in", "zip", "(", "[", "'min'", ",", "'max'", ",", "'p25'", ",", "'p50'", ",", "'p75'", "]", ",", "[", "mins", ",", "maxs", ",", "p25s", ",", "p50s", ",", "p75s", "]", ")", ":", "\n", "        ", "logger", ".", "debug", "(", "f\"\\t{n}: {np.mean(l)}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.count_retained": [[88, 98], ["loguru.logger.debug", "scipy.ndimage.label", "scipy.ndimage.label", "loguru.logger.debug", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "", "def", "count_retained", "(", "data_before", ",", "data_after", ",", "level", ")", ":", "\n", "    ", "if", "level", "==", "'vox'", ":", "\n", "        ", "cmpt_before", ",", "cmpt_after", "=", "np", ".", "count_nonzero", "(", "data_before", ")", ",", "np", ".", "count_nonzero", "(", "data_after", ")", "\n", "", "else", ":", "# level == 'obj'", "\n", "        ", "logger", ".", "debug", "(", "f\"{np.sum(data_before)} {np.sum(data_after)}\"", ")", "\n", "_", ",", "cmpt_before", "=", "label", "(", "data_before", ",", "structure", "=", "BIN_STRUCT", ")", "\n", "_", ",", "cmpt_after", "=", "label", "(", "data_after", ",", "structure", "=", "BIN_STRUCT", ")", "\n", "logger", ".", "debug", "(", "f\"{cmpt_before} {cmpt_after}\"", ")", "\n", "", "percent_rm", "=", "(", "cmpt_before", "-", "cmpt_after", ")", "*", "100.", "/", "cmpt_before", "\n", "return", "100.", "-", "percent_rm", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.run_experiment": [[100, 159], ["copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "os.path.join", "nibabel.load", "nib.load.get_data", "numpy.array", "os.path.join", "os.path.isfile", "range", "range", "nibabel.load", "nib.load.get_data", "loguru.logger.debug", "numpy.mean", "numpy.any", "len", "len", "range", "nibabel.load().get_data", "fname_pref.split", "numpy.sum", "enumerate", "len", "os.listdir", "copy.deepcopy", "filtering_lesion.count_retained", "[].append", "loguru.logger.debug", "enumerate", "nibabel.load", "ivadomed.postprocessing.threshold_predictions().astype", "ivadomed.utils.Evaluation3DMetrics", "loguru.logger.debug", "[].append", "[].append", "os.path.join", "ivadomed.metrics.recall_score", "imed_utils.Evaluation3DMetrics.get_ltpr", "imed_utils.Evaluation3DMetrics.get_lfdr", "ivadomed.postprocessing.threshold_predictions", "ivadomed.metrics.precision_score", "copy.deepcopy", "numpy.count_nonzero", "numpy.count_nonzero", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.count_retained", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.recall_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_ltpr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_lfdr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.precision_score"], ["", "def", "run_experiment", "(", "level", ",", "unc_name", ",", "thr_unc_lst", ",", "thr_pred_lst", ",", "gt_folder", ",", "pred_folder", ",", "im_lst", ",", "target_suf", ",", "param_eval", ")", ":", "\n", "# init results", "\n", "    ", "tmp_lst", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "thr_pred_lst", ")", ")", "]", "\n", "res_init_lst", "=", "[", "deepcopy", "(", "tmp_lst", ")", "for", "_", "in", "range", "(", "len", "(", "thr_unc_lst", ")", ")", "]", "\n", "res_dct", "=", "{", "'tpr'", ":", "deepcopy", "(", "res_init_lst", ")", ",", "\n", "'fdr'", ":", "deepcopy", "(", "res_init_lst", ")", ",", "\n", "'retained_elt'", ":", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "thr_unc_lst", ")", ")", "]", "\n", "}", "\n", "\n", "# loop across images", "\n", "for", "fname_pref", "in", "im_lst", ":", "\n", "# uncertainty map", "\n", "        ", "fname_unc", "=", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "fname_pref", "+", "unc_name", "+", "'.nii.gz'", ")", "\n", "im", "=", "nib", ".", "load", "(", "fname_unc", ")", "\n", "data_unc", "=", "im", ".", "get_data", "(", ")", "\n", "del", "im", "\n", "\n", "# list MC samples", "\n", "data_pred_lst", "=", "np", ".", "array", "(", "[", "nib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "f", ")", ")", ".", "get_data", "(", ")", "\n", "for", "f", "in", "os", ".", "listdir", "(", "pred_folder", ")", "if", "fname_pref", "+", "'_pred_'", "in", "f", "]", ")", "\n", "\n", "# ground-truth fname", "\n", "fname_gt", "=", "os", ".", "path", ".", "join", "(", "gt_folder", ",", "fname_pref", ".", "split", "(", "'_'", ")", "[", "0", "]", ",", "'anat'", ",", "fname_pref", "+", "target_suf", "+", "'.nii.gz'", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "fname_gt", ")", ":", "\n", "            ", "nib_gt", "=", "nib", ".", "load", "(", "fname_gt", ")", "\n", "data_gt", "=", "nib_gt", ".", "get_data", "(", ")", "\n", "logger", ".", "debug", "(", "np", ".", "sum", "(", "data_gt", ")", ")", "\n", "# soft prediction", "\n", "data_soft", "=", "np", ".", "mean", "(", "data_pred_lst", ",", "axis", "=", "0", ")", "\n", "\n", "if", "np", ".", "any", "(", "data_soft", ")", ":", "\n", "                ", "for", "i_unc", ",", "thr_unc", "in", "enumerate", "(", "thr_unc_lst", ")", ":", "\n", "# discard uncertain lesions from data_soft", "\n", "                    ", "data_soft_thrUnc", "=", "deepcopy", "(", "data_soft", ")", "\n", "data_soft_thrUnc", "[", "data_unc", ">", "thr_unc", "]", "=", "0", "\n", "cmpt", "=", "count_retained", "(", "(", "data_soft", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", ",", "(", "data_soft_thrUnc", ">", "0", ")", ".", "astype", "(", "np", ".", "int", ")", ",", "level", ")", "\n", "res_dct", "[", "'retained_elt'", "]", "[", "i_unc", "]", ".", "append", "(", "cmpt", ")", "\n", "logger", ".", "debug", "(", "f\"{thr_unc} {cmpt}\"", ")", "\n", "for", "i_pred", ",", "thr_pred", "in", "enumerate", "(", "thr_pred_lst", ")", ":", "\n", "                        ", "data_hard", "=", "imed_postpro", ".", "threshold_predictions", "(", "deepcopy", "(", "data_soft_thrUnc", ")", ",", "thr", "=", "thr_pred", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "eval", "=", "imed_utils", ".", "Evaluation3DMetrics", "(", "data_pred", "=", "data_hard", ",", "\n", "data_gt", "=", "data_gt", ",", "\n", "dim_lst", "=", "nib_gt", ".", "header", "[", "'pixdim'", "]", "[", "1", ":", "4", "]", ",", "\n", "params", "=", "param_eval", ")", "\n", "\n", "if", "level", "==", "'vox'", ":", "\n", "                            ", "tpr", "=", "imed_metrics", ".", "recall_score", "(", "eval", ".", "data_pred", ",", "eval", ".", "data_gt", ",", "err_value", "=", "np", ".", "nan", ")", "\n", "fdr", "=", "100.", "-", "imed_metrics", ".", "precision_score", "(", "eval", ".", "data_pred", ",", "eval", ".", "data_gt", ",", "err_value", "=", "np", ".", "nan", ")", "\n", "", "else", ":", "\n", "                            ", "tpr", ",", "_", "=", "eval", ".", "get_ltpr", "(", ")", "\n", "fdr", "=", "eval", ".", "get_lfdr", "(", ")", "\n", "", "logger", ".", "debug", "(", "f\"{thr_pred} {np.count_nonzero(deepcopy(data_soft_thrUnc))} \"", "\n", "f\"{np.count_nonzero(data_hard)} {tpr} {fdr}\"", ")", "\n", "res_dct", "[", "'tpr'", "]", "[", "i_unc", "]", "[", "i_pred", "]", ".", "append", "(", "tpr", "/", "100.", ")", "\n", "res_dct", "[", "'fdr'", "]", "[", "i_unc", "]", "[", "i_pred", "]", ".", "append", "(", "fdr", "/", "100.", ")", "\n", "\n", "", "", "", "", "", "return", "res_dct", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.print_retained_elt": [[161, 165], ["loguru.logger.info", "enumerate", "loguru.logger.info", "numpy.mean"], "function", ["None"], ["", "def", "print_retained_elt", "(", "thr_unc_lst", ",", "retained_elt_lst", ")", ":", "\n", "    ", "logger", ".", "info", "(", "'Mean percentage of retained elt:'", ")", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thr_unc_lst", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"\\tUnc threshold: {t} --> {np.mean(retained_elt_lst[i])}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.plot_roc": [[167, 192], ["matplotlib.figure", "enumerate", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.savefig", "matplotlib.close", "loguru.logger.info", "numpy.array", "numpy.array", "filtering_lesion.auc_homemade", "numpy.argmax", "loguru.logger.info", "matplotlib.scatter", "numpy.nanmean", "numpy.nanmean", "range", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.auc_homemade"], ["", "", "def", "plot_roc", "(", "thr_unc_lst", ",", "thr_pred_lst", ",", "res_dct", ",", "metric", ",", "fname_out", ")", ":", "\n", "    ", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "10", ")", ")", "\n", "for", "i_unc", ",", "thr_unc", "in", "enumerate", "(", "thr_unc_lst", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Unc Thr: {thr_unc}\"", ")", "\n", "\n", "tpr_vals", "=", "np", ".", "array", "(", "[", "np", ".", "nanmean", "(", "res_dct", "[", "'tpr'", "]", "[", "i_unc", "]", "[", "i_pred", "]", ")", "for", "i_pred", "in", "range", "(", "len", "(", "thr_pred_lst", ")", ")", "]", ")", "\n", "fdr_vals", "=", "np", ".", "array", "(", "[", "np", ".", "nanmean", "(", "res_dct", "[", "'fdr'", "]", "[", "i_unc", "]", "[", "i_pred", "]", ")", "for", "i_pred", "in", "range", "(", "len", "(", "thr_pred_lst", ")", ")", "]", ")", "\n", "\n", "auc_", "=", "auc_homemade", "(", "fdr_vals", ",", "tpr_vals", ",", "True", ")", "\n", "\n", "optimal_idx", "=", "np", ".", "argmax", "(", "tpr_vals", "-", "fdr_vals", ")", "\n", "optimal_threshold", "=", "thr_pred_lst", "[", "optimal_idx", "]", "\n", "logger", ".", "info", "(", "f\"AUC: {auc_}, Optimal Pred Thr: {optimal_threshold}\"", ")", "\n", "\n", "plt", ".", "scatter", "(", "fdr_vals", ",", "tpr_vals", ",", "label", "=", "'Unc thr={0:0.2f} (area = {1:0.2f})'", ".", "format", "(", "thr_unc", ",", "auc_", ")", ",", "s", "=", "22", ")", "\n", "\n", "", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "'k--'", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Detection Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'ROC - '", "+", "metric", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "plt", ".", "savefig", "(", "fname_out", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.run_inference": [[194, 242], ["pandas.DataFrame", "os.path.join", "nibabel.load", "nib.load.get_data", "numpy.mean", "ivadomed.postprocessing.threshold_predictions().astype", "ivadomed.utils.Evaluation3DMetrics", "imed_utils.Evaluation3DMetrics.run_eval", "df_results.append.append", "any", "loguru.logger.debug", "os.path.join", "nibabel.load", "nib.load.get_data", "numpy.array", "numpy.array", "any", "loguru.logger.debug", "fname_pref.split", "fname_pref.split", "ivadomed.postprocessing.threshold_predictions", "nibabel.load().get_data", "nibabel.load().get_data", "os.listdir", "os.listdir", "nibabel.load", "nibabel.load", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.run_eval", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data"], ["", "def", "run_inference", "(", "pred_folder", ",", "im_lst", ",", "thr_pred", ",", "gt_folder", ",", "target_suf", ",", "param_eval", ",", "unc_name", "=", "None", ",", "thr_unc", "=", "None", ")", ":", "\n", "# init df", "\n", "    ", "df_results", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "# loop across images", "\n", "for", "fname_pref", "in", "im_lst", ":", "\n", "        ", "if", "not", "any", "(", "elem", "is", "None", "for", "elem", "in", "[", "unc_name", ",", "thr_unc", "]", ")", ":", "\n", "            ", "logger", ".", "debug", "(", "thr_unc", ")", "\n", "# uncertainty map", "\n", "fname_unc", "=", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "fname_pref", "+", "unc_name", "+", "'.nii.gz'", ")", "\n", "im", "=", "nib", ".", "load", "(", "fname_unc", ")", "\n", "data_unc", "=", "im", ".", "get_data", "(", ")", "\n", "del", "im", "\n", "\n", "# list MC samples", "\n", "data_pred_lst", "=", "np", ".", "array", "(", "[", "nib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "f", ")", ")", ".", "get_data", "(", ")", "\n", "for", "f", "in", "os", ".", "listdir", "(", "pred_folder", ")", "if", "fname_pref", "+", "'_pred_'", "in", "f", "]", ")", "\n", "", "else", ":", "\n", "            ", "data_pred_lst", "=", "np", ".", "array", "(", "[", "nib", ".", "load", "(", "os", ".", "path", ".", "join", "(", "pred_folder", ",", "f", ")", ")", ".", "get_data", "(", ")", "\n", "for", "f", "in", "os", ".", "listdir", "(", "pred_folder", ")", "if", "fname_pref", "+", "'_pred.'", "in", "f", "]", ")", "\n", "\n", "# ground-truth fname", "\n", "", "fname_gt", "=", "os", ".", "path", ".", "join", "(", "gt_folder", ",", "fname_pref", ".", "split", "(", "'_'", ")", "[", "0", "]", ",", "'anat'", ",", "fname_pref", "+", "target_suf", "+", "'.nii.gz'", ")", "\n", "nib_gt", "=", "nib", ".", "load", "(", "fname_gt", ")", "\n", "data_gt", "=", "nib_gt", ".", "get_data", "(", ")", "\n", "\n", "# soft prediction", "\n", "data_soft", "=", "np", ".", "mean", "(", "data_pred_lst", ",", "axis", "=", "0", ")", "\n", "\n", "if", "not", "any", "(", "elem", "is", "None", "for", "elem", "in", "[", "unc_name", ",", "thr_unc", "]", ")", ":", "\n", "            ", "logger", ".", "debug", "(", "\"thr\"", ")", "\n", "# discard uncertain lesions from data_soft", "\n", "data_soft", "[", "data_unc", ">", "thr_unc", "]", "=", "0", "\n", "\n", "", "data_hard", "=", "imed_postpro", ".", "threshold_predictions", "(", "data_soft", ",", "thr", "=", "thr_pred", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "eval", "=", "imed_utils", ".", "Evaluation3DMetrics", "(", "data_pred", "=", "data_hard", ",", "\n", "data_gt", "=", "data_gt", ",", "\n", "dim_lst", "=", "nib_gt", ".", "header", "[", "'pixdim'", "]", "[", "1", ":", "4", "]", ",", "\n", "params", "=", "param_eval", ")", "\n", "\n", "results_pred", ",", "_", "=", "eval", ".", "run_eval", "(", ")", "\n", "\n", "# save results of this fname_pred", "\n", "results_pred", "[", "'image_id'", "]", "=", "fname_pref", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "df_results", "=", "df_results", ".", "append", "(", "results_pred", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "return", "df_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.run_main": [[244, 307], ["ivadomed.config_manager.ConfigurationManager().get_config", "os.path.join", "list", "os.path.join", "float", "float", "os.path.isdir", "os.makedirs", "os.path.isdir", "ivadomed.main.cmd_test", "set", "exp_dct.keys", "filtering_lesion.run_inference", "loguru.logger.debug", "loguru.logger.info", "run_inference.to_csv", "ivadomed.config_manager.ConfigurationManager", "loguru.logger.debug", "filtering_lesion.print_unc_stats", "os.path.join", "filtering_lesion.print_retained_elt", "filtering_lesion.plot_roc", "run_inference.head", "os.path.join", "os.path.isfile", "filtering_lesion.run_experiment", "joblib.dump", "joblib.load", "f.split", "os.listdir", "os.path.join", "str", "numpy.median", "numpy.percentile", "numpy.percentile", "f.endswith", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.print_unc_stats", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.print_retained_elt", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.plot_roc", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.dev.filtering_lesion.run_experiment"], ["", "def", "run_main", "(", "args", ")", ":", "\n", "    ", "thrPred", "=", "None", "if", "args", ".", "thrPred", "is", "None", "else", "float", "(", "args", ".", "thrPred", ")", "\n", "thrUnc", "=", "None", "if", "args", ".", "thrUnc", "is", "None", "else", "float", "(", "args", ".", "thrUnc", ")", "\n", "sufUnc", "=", "args", ".", "suffixUnc", "\n", "\n", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "args", ".", "c", ")", ".", "get_config", "(", ")", "\n", "\n", "ofolder", "=", "args", ".", "ofolder", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "ofolder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "ofolder", ")", "\n", "\n", "", "pred_folder", "=", "os", ".", "path", ".", "join", "(", "context", "[", "'path_output'", "]", ",", "'pred_masks'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "pred_folder", ")", ":", "\n", "        ", "imed", ".", "cmd_test", "(", "context", ")", "\n", "\n", "", "subj_acq_lst", "=", "list", "(", "set", "(", "[", "f", ".", "split", "(", "'_pred'", ")", "[", "0", "]", "for", "f", "in", "os", ".", "listdir", "(", "pred_folder", ")", "\n", "if", "f", ".", "endswith", "(", "'.nii.gz'", ")", "and", "'_pred'", "in", "f", "]", ")", ")", "\n", "# subj_acq_lst = [subj_acq_lst[0]]", "\n", "gt_folder", "=", "os", ".", "path", ".", "join", "(", "context", "[", "'path_data'", "]", ",", "'derivatives'", ",", "'labels'", ")", "\n", "\n", "if", "thrPred", "is", "None", ":", "\n", "        ", "for", "exp", "in", "exp_dct", ".", "keys", "(", ")", ":", "\n", "            ", "config_dct", "=", "exp_dct", "[", "exp", "]", "\n", "logger", ".", "debug", "(", "config_dct", "[", "'uncertainty_measure'", "]", ")", "\n", "\n", "# print_unc_stats is used to determine 'uncertainty_thr'", "\n", "print_unc_stats", "(", "config_dct", "[", "'uncertainty_measure'", "]", ",", "pred_folder", ",", "subj_acq_lst", ")", "\n", "\n", "res_ofname", "=", "os", ".", "path", ".", "join", "(", "ofolder", ",", "config_dct", "[", "'uncertainty_measure'", "]", "+", "'.joblib'", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "res_ofname", ")", ":", "\n", "                ", "res", "=", "run_experiment", "(", "level", "=", "config_dct", "[", "'level'", "]", ",", "\n", "unc_name", "=", "config_dct", "[", "'uncertainty_measure'", "]", ",", "\n", "thr_unc_lst", "=", "config_dct", "[", "'uncertainty_thr'", "]", ",", "\n", "thr_pred_lst", "=", "config_dct", "[", "'prediction_thr'", "]", ",", "\n", "gt_folder", "=", "gt_folder", ",", "\n", "pred_folder", "=", "pred_folder", ",", "\n", "im_lst", "=", "subj_acq_lst", ",", "\n", "target_suf", "=", "context", "[", "\"target_suffix\"", "]", "[", "0", "]", ",", "\n", "param_eval", "=", "context", "[", "\"eval_params\"", "]", ")", "\n", "joblib", ".", "dump", "(", "res", ",", "res_ofname", ")", "\n", "", "else", ":", "\n", "                ", "res", "=", "joblib", ".", "load", "(", "res_ofname", ")", "\n", "\n", "", "print_retained_elt", "(", "thr_unc_lst", "=", "config_dct", "[", "'uncertainty_thr'", "]", ",", "retained_elt_lst", "=", "res", "[", "'retained_elt'", "]", ")", "\n", "\n", "plot_roc", "(", "thr_unc_lst", "=", "config_dct", "[", "'uncertainty_thr'", "]", ",", "\n", "thr_pred_lst", "=", "config_dct", "[", "'prediction_thr'", "]", ",", "\n", "res_dct", "=", "res", ",", "\n", "metric", "=", "config_dct", "[", "'uncertainty_measure'", "]", ",", "\n", "fname_out", "=", "os", ".", "path", ".", "join", "(", "ofolder", ",", "config_dct", "[", "'uncertainty_measure'", "]", "+", "'.png'", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "df", "=", "run_inference", "(", "pred_folder", "=", "pred_folder", ",", "\n", "im_lst", "=", "subj_acq_lst", ",", "\n", "thr_pred", "=", "thrPred", ",", "\n", "gt_folder", "=", "gt_folder", ",", "\n", "target_suf", "=", "context", "[", "\"target_suffix\"", "]", "[", "0", "]", ",", "\n", "param_eval", "=", "context", "[", "\"eval_params\"", "]", ",", "\n", "unc_name", "=", "sufUnc", ",", "\n", "thr_unc", "=", "thrUnc", ")", "\n", "logger", ".", "debug", "(", "df", ".", "head", "(", ")", ")", "\n", "vals", "=", "[", "v", "for", "v", "in", "df", ".", "dice_class0", "if", "str", "(", "v", ")", "!=", "'nan'", "]", "\n", "logger", ".", "info", "(", "f\"Median (IQR): {np.median(vals)} ({np.percentile(vals, 25)} - {np.percentile(vals, 75)}).\"", ")", "\n", "df", ".", "to_csv", "(", "os", ".", "path", ".", "join", "(", "ofolder", ",", "'_'", ".", "join", "(", "[", "str", "(", "sufUnc", ")", ",", "str", "(", "thrUnc", ")", ",", "str", "(", "thrPred", ")", "]", ")", "+", "'.csv'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.prepare_data.prepdata.remove_slice": [[8, 54], ["nibabel.load", "numpy.asanyarray", "nibabel.load", "numpy.asanyarray", "range", "range", "numpy.dot", "numpy.copy", "nibabel.Nifti1Image", "nibabel.save", "nibabel.Nifti1Image", "nibabel.save", "numpy.mean", "numpy.mean", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["def", "remove_slice", "(", "fname_im", ",", "fname_seg", ")", ":", "\n", "    ", "\"\"\"\n    Look at the average signal within the segmentation, for edge slices, and remove those slices if this average is\n    zero. Assumes last dimension is Z.\n    :param fname_im:\n    :param fname_seg:\n    :return:\n    \"\"\"", "\n", "# Load data", "\n", "nii_im", "=", "nib", ".", "load", "(", "fname_im", ")", "\n", "data_im", "=", "np", ".", "asanyarray", "(", "nii_im", ".", "dataobj", ")", "\n", "affine_im", "=", "nii_im", ".", "affine", "\n", "nii_seg", "=", "nib", ".", "load", "(", "fname_seg", ")", "\n", "data_seg", "=", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", "\n", "_", ",", "_", ",", "nz", "=", "nii_im", ".", "shape", "\n", "# Loop across slices in ascending mode and stop when no more empty", "\n", "z_bottom", "=", "0", "\n", "for", "iz", "in", "range", "(", "nz", ")", ":", "\n", "        ", "if", "np", ".", "mean", "(", "data_im", "[", ":", ",", ":", ",", "iz", "]", "*", "data_seg", "[", ":", ",", ":", ",", "iz", "]", ")", "==", "0.0", ":", "\n", "            ", "z_bottom", "=", "iz", "+", "1", "\n", "", "else", ":", "\n", "            ", "break", "\n", "# Loop across slices in descending mode and stop when no more empty", "\n", "", "", "z_top", "=", "0", "\n", "for", "iz", "in", "range", "(", "nz", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "if", "np", ".", "mean", "(", "data_im", "[", ":", ",", ":", ",", "iz", "]", "*", "data_seg", "[", ":", ",", ":", ",", "iz", "]", ")", "==", "0.0", ":", "\n", "            ", "z_top", "=", "iz", "\n", "", "else", ":", "\n", "            ", "break", "\n", "# If some slices are empty, crop image and segmentation", "\n", "", "", "if", "z_bottom", "or", "z_top", ":", "\n", "# Remove edge slices", "\n", "        ", "data_im_crop", "=", "data_im", "[", "...", ",", "z_bottom", ":", "z_top", "]", "\n", "data_seg_crop", "=", "data_seg", "[", "...", ",", "z_bottom", ":", "z_top", "]", "\n", "# Calculate the translation (in voxel space)", "\n", "translation_vox", "=", "[", "0", ",", "0", ",", "z_bottom", "]", "\n", "# Update affine transformation, accounting for the number of slices removed (voxel coordinate system is shifted)", "\n", "transfo", "=", "affine_im", "[", "0", ":", "3", ",", "0", ":", "3", "]", "\n", "translation", "=", "np", ".", "dot", "(", "transfo", ",", "np", ".", "transpose", "(", "translation_vox", ")", ")", "\n", "affine_im_new", "=", "np", ".", "copy", "(", "affine_im", ")", "\n", "affine_im_new", "[", "0", ":", "3", ",", "3", "]", "=", "affine_im_new", "[", "0", ":", "3", ",", "3", "]", "+", "translation", "\n", "# Overwrite image and segmentation", "\n", "nii_im_new", "=", "nib", ".", "Nifti1Image", "(", "data_im_crop", ",", "affine_im_new", ")", "\n", "nib", ".", "save", "(", "nii_im_new", ",", "fname_im", ")", "\n", "nii_seg_new", "=", "nib", ".", "Nifti1Image", "(", "data_seg_crop", ",", "affine_im_new", ")", "\n", "nib", ".", "save", "(", "nii_seg_new", ",", "fname_seg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.prepare_data.prepdata.run_main": [[56, 75], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "prepdata.remove_slice"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.prepare_data.prepdata.remove_slice"], ["", "", "def", "run_main", "(", ")", ":", "\n", "\n", "# Parse arguments", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Prepare data.'", ")", "\n", "parser", ".", "add_argument", "(", "'action'", ",", "\n", "choices", "=", "[", "'remove-slice'", "]", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "'-i'", ",", "'--image'", ",", "\n", "help", "=", "'image in nifti format'", ",", "\n", "type", "=", "str", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--segmentation'", ",", "\n", "help", "=", "'segmentation in nifti format'", ",", "\n", "type", "=", "str", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "# Select action", "\n", "if", "args", ".", "action", "==", "'remove-slice'", ":", "\n", "        ", "remove_slice", "(", "fname_im", "=", "args", ".", "image", ",", "fname_seg", "=", "args", ".", "segmentation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.download_dataset": [[40, 60], ["path_dataset.exists", "loguru.logger.info", "ivadomed.scripts.download_data.main", "loguru.logger.warning", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["def", "download_dataset", "(", "dataset", ":", "str", "=", "'data_testing'", ")", ":", "\n", "    ", "\"\"\"Download testing data from internet.\n\n    Args:\n        dataset (str): the name of the dataset to download\n    \"\"\"", "\n", "\n", "path_dataset", ":", "Path", "=", "path_repo_root", "/", "dataset", "\n", "\n", "# Early abort if testing data already exist.", "\n", "if", "path_dataset", ".", "exists", "(", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "f\"\\nTesting data files appear to already exist at {path_dataset}, aborting download\"", ")", "\n", "return", "\n", "\n", "", "logger", ".", "info", "(", "f\"\\nDownloading testing data... to {dataset}\"", ")", "\n", "\n", "# Call the ivadomed download CLI", "\n", "ivadomed_download_data", ".", "main", "(", "[", "\n", "'-d'", ",", "dataset", ",", "\n", "'-o'", ",", "str", "(", "path_dataset", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_dataset": [[63, 75], ["pathlib.Path", "loguru.logger.debug", "shutil.rmtree"], "function", ["None"], ["", "def", "remove_dataset", "(", "dataset", ":", "str", "=", "'data_testing'", ")", ":", "\n", "    ", "\"\"\"Recursively remove the data_testing folder.\n\n    Args:\n        dataset (str): the name of the dataset to remove\n    \"\"\"", "\n", "\n", "path_dataset", "=", "Path", "(", "path_temp", ",", "dataset", ")", "\n", "\n", "logger", ".", "debug", "(", "f\"rm -rf {path_dataset}\"", ")", "\n", "\n", "shutil", ".", "rmtree", "(", "path_dataset", ",", "ignore_errors", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir": [[77, 80], ["shutil.rmtree"], "function", ["None"], ["", "def", "remove_tmp_dir", "(", ")", ":", "\n", "    ", "\"\"\"Recursively remove the ``tmp`` directory if it exists.\"\"\"", "\n", "shutil", ".", "rmtree", "(", "path_temp", ",", "ignore_errors", "=", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_compare_models.setup_function": [[10, 12], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_compare_models.test_compare_models": [[14, 21], ["pathlib.Path", "pathlib.Path", "ivadomed.scripts.compare_models.main", "pathlib.Path.exists", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_compare_models", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__output_file__", "=", "Path", "(", "__tmp_dir__", ",", "'comparison_results.csv'", ")", "\n", "path_df", "=", "Path", "(", "__data_testing_dir__", ",", "'temporary_results.csv'", ")", "\n", "compare_models", ".", "main", "(", "args", "=", "[", "'-df'", ",", "str", "(", "path_df", ")", ",", "\n", "'-n'", ",", "'2'", ",", "\n", "'-o'", ",", "str", "(", "__output_file__", ")", "]", ")", "\n", "assert", "__output_file__", ".", "exists", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_compare_models.teardown_function": [[23, 25], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_template.setup_function": [[64, 74], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "\"\"\"Function which is run before each test in this file.\n\n    ``create_tmp_dir`` will do the following:\n    1. Create a directory called ``tmp`` (overwrite if already exists)\n    2. Copy ``data_functional_testing`` -> ``tmp/data_functional_testing``\n\n    Add any other things for setup here.\n    \"\"\"", "\n", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_template.test_template": [[76, 85], ["logger.info", "pathlib.Path().mkdir", "pathlib.Path", "pathlib.Path().iterdir", "pathlib.Path"], "function", ["None"], ["", "def", "test_template", "(", ")", ":", "\n", "# Test Input Files: all test input files should be in tmp/data_functional_testing", "\n", "# aka __data_testing_dir__", "\n", "    ", "logger", ".", "info", "(", "[", "f", ".", "name", "for", "f", "in", "Path", "(", "__data_testing_dir__", ")", ".", "iterdir", "(", ")", "]", ")", "\n", "\n", "# Test Output Files: put your output files in tmp folder", "\n", "Path", "(", "__tmp_dir__", ",", "'my_output_dir'", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "assert", "1", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_template.teardown_function": [[87, 98], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "\"\"\"Function which is run after each test in this file.\n\n    ``remove_tmp_dir`` will do the following:\n    1. Delete the directory called ``tmp`` (if already exists)\n\n    Add any other things for teardown here.\n    Note: this function gets run after each test, so files/data will not be saved\n        in between tests.\n    \"\"\"", "\n", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_prepare_dataset_vertebral_labelling.setup_function": [[9, 11], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_prepare_dataset_vertebral_labelling.test_prepare_dataset_vertebral_labeling": [[13, 23], ["ivadomed.scripts.prepare_dataset_vertebral_labeling.main", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_prepare_dataset_vertebral_labeling", "(", "download_functional_test_files", ")", ":", "\n", "    ", "prepare_dataset_vertebral_labeling", ".", "main", "(", "args", "=", "[", "'--path'", ",", "__data_testing_dir__", ",", "\n", "'--suffix'", ",", "'_T2w'", ",", "\n", "'--aim'", ",", "'3'", "]", ")", "\n", "assert", "Path", "(", "\n", "__data_testing_dir__", ",", "\"derivatives/labels/sub-unf01/anat/sub-unf01_T2w_mid_heatmap3.nii.gz\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "\n", "__data_testing_dir__", ",", "\"derivatives/labels/sub-unf02/anat/sub-unf02_T2w_mid_heatmap3.nii.gz\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "\n", "__data_testing_dir__", ",", "\"derivatives/labels/sub-unf03/anat/sub-unf03_T2w_mid_heatmap3.nii.gz\"", ")", ".", "exists", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_prepare_dataset_vertebral_labelling.teardown_function": [[25, 27], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_visualize_transforms.setup_function": [[10, 12], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_visualize_transforms.test_visualize_transforms_n_1": [[14, 32], ["pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "ivadomed.scripts.visualize_transforms.main", "pathlib.Path.exists", "len", "pathlib.Path.iterdir", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_visualize_transforms_n_1", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__data_testing_dir__", "=", "Path", "(", "__tmp_dir__", ",", "\"data_functional_testing\"", ")", "\n", "__input_file__", "=", "Path", "(", "__data_testing_dir__", ",", "'sub-unf01/anat/sub-unf01_T1w.nii.gz'", ")", "\n", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "\"output_visualize_transforms_n_1\"", ")", "\n", "__config_file__", "=", "Path", "(", "__data_testing_dir__", ",", "\"model_config.json\"", ")", "\n", "__label_file__", "=", "Path", "(", "__data_testing_dir__", ",", "\n", "'derivatives/labels/sub-test001/anat/sub-unf01_T1w_seg-manual.nii.gz'", ")", "\n", "visualize_transforms", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__input_file__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", ",", "\n", "'--config'", ",", "str", "(", "__config_file__", ")", ",", "\n", "'-r'", ",", "str", "(", "__label_file__", ")", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_files", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "len", "(", "output_files", ")", "==", "5", "\n", "for", "output_file", "in", "output_files", ":", "\n", "        ", "assert", "\"Resample\"", "in", "output_file", "\n", "assert", "\"slice\"", "in", "output_file", "\n", "assert", "\".png\"", "in", "output_file", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_visualize_transforms.test_visualize_transforms_n_2": [[34, 53], ["pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "ivadomed.scripts.visualize_transforms.main", "pathlib.Path.exists", "len", "pathlib.Path.iterdir", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "", "def", "test_visualize_transforms_n_2", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__data_testing_dir__", "=", "Path", "(", "__tmp_dir__", ",", "\"data_functional_testing\"", ")", "\n", "__input_file__", "=", "Path", "(", "__data_testing_dir__", ",", "'sub-unf01/anat/sub-unf01_T1w.nii.gz'", ")", "\n", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "\"output_visualize_transforms_n_2\"", ")", "\n", "__config_file__", "=", "Path", "(", "__data_testing_dir__", ",", "\"model_config.json\"", ")", "\n", "__label_file__", "=", "Path", "(", "__data_testing_dir__", ",", "\n", "'derivatives/labels/sub-test001/anat/sub-unf01_T1w_seg-manual.nii.gz'", ")", "\n", "visualize_transforms", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__input_file__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", ",", "\n", "'--config'", ",", "str", "(", "__config_file__", ")", ",", "\n", "'-r'", ",", "str", "(", "__label_file__", ")", ",", "\n", "'-n'", ",", "'2'", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_files", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "len", "(", "output_files", ")", "==", "10", "\n", "for", "output_file", "in", "output_files", ":", "\n", "        ", "assert", "\"Resample\"", "in", "output_file", "\n", "assert", "\"slice\"", "in", "output_file", "\n", "assert", "\".png\"", "in", "output_file", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_visualize_transforms.teardown_function": [[55, 57], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_automate_training.setup_function": [[13, 15], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_automate_training.test_automate_training": [[17, 36], ["pytest.mark.script_launch_mode", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pytest_console_scripts.script_runner.run", "logger.debug", "logger.debug", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "testing.functional_tests.t_utils.check_sha256", "str", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_utils.check_sha256"], ["", "@", "pytest", ".", "mark", ".", "script_launch_mode", "(", "'subprocess'", ")", "\n", "def", "test_automate_training", "(", "download_functional_test_files", ",", "script_runner", ")", ":", "\n", "    ", "file_config", "=", "Path", "(", "__data_testing_dir__", ",", "'automate_training_config.json'", ")", "\n", "file_config_hyper", "=", "Path", "(", "__data_testing_dir__", ",", "'automate_training_hyperparameter_opt.json'", ")", "\n", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'results'", ")", "\n", "\n", "ret", "=", "script_runner", ".", "run", "(", "'ivadomed_automate_training'", ",", "'--config'", ",", "f'{file_config}'", ",", "\n", "'--config-hyper'", ",", "f'{file_config_hyper}'", ",", "\n", "'--path-data'", ",", "f'{__data_testing_dir__}'", ",", "\n", "'--output_dir'", ",", "f'{__output_dir__}'", ")", "\n", "logger", ".", "debug", "(", "f\"{ret.stdout}\"", ")", "\n", "logger", ".", "debug", "(", "f\"{ret.stderr}\"", ")", "\n", "assert", "ret", ".", "success", "\n", "assert", "Path", "(", "__output_dir__", ",", "'detailed_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'temporary_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'average_eval.csv'", ")", ".", "exists", "(", ")", "\n", "\n", "# check sha256 is recorded in config_file.json", "\n", "check_sha256", "(", "str", "(", "file_config", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_automate_training.test_automate_training_run_test_debug": [[38, 68], ["os.path.join", "os.path.join", "os.path.join", "automate_training", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.automate_training"], ["", "def", "test_automate_training_run_test_debug", "(", "download_functional_test_files", ")", ":", "\n", "    ", "\"\"\"A unit test similar to test_automate_training_run_test but allow step through (instead of using script caller/\n    subprocess mode which cannot be stepped. Other than that, nothing else really changed and is exactly the same.\n    Very useful for debugging this high level function to spot problems\n\n    Fixture Required:\n        download_functional_test_files:\n    \"\"\"", "\n", "file_config", "=", "os", ".", "path", ".", "join", "(", "__data_testing_dir__", ",", "'automate_training_config.json'", ")", "\n", "file_config_hyper", "=", "os", ".", "path", ".", "join", "(", "__data_testing_dir__", ",", "\n", "'automate_training_hyperparameter_opt.json'", ")", "\n", "__output_dir__", "=", "os", ".", "path", ".", "join", "(", "__tmp_dir__", ",", "'results'", ")", "\n", "\n", "from", "ivadomed", ".", "scripts", ".", "automate_training", "import", "automate_training", "\n", "\n", "automate_training", "(", "file_config", "=", "file_config", ",", "\n", "file_config_hyper", "=", "file_config_hyper", ",", "\n", "path_data", "=", "__data_testing_dir__", ",", "\n", "run_test", "=", "True", ",", "\n", "output_dir", "=", "__output_dir__", ",", "\n", "fixed_split", "=", "False", ",", "\n", "all_combin", "=", "True", ",", "\n", "n_iterations", "=", "1", ",", "\n", "all_logs", "=", "True", ",", "\n", "multi_params", "=", "True", ",", "\n", ")", "\n", "\n", "assert", "Path", "(", "__output_dir__", ",", "'detailed_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'temporary_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'average_eval.csv'", ")", ".", "exists", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_automate_training.test_automate_training_run_test": [[70, 90], ["pytest.mark.script_launch_mode", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pytest_console_scripts.script_runner.run", "logger.debug", "logger.debug", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "testing.functional_tests.t_utils.check_sha256", "str", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_utils.check_sha256"], ["", "@", "pytest", ".", "mark", ".", "script_launch_mode", "(", "'subprocess'", ")", "\n", "def", "test_automate_training_run_test", "(", "download_functional_test_files", ",", "script_runner", ")", ":", "\n", "    ", "file_config", "=", "Path", "(", "__data_testing_dir__", ",", "'automate_training_config.json'", ")", "\n", "file_config_hyper", "=", "Path", "(", "__data_testing_dir__", ",", "'automate_training_hyperparameter_opt.json'", ")", "\n", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'results'", ")", "\n", "\n", "ret", "=", "script_runner", ".", "run", "(", "'ivadomed_automate_training'", ",", "'--config'", ",", "f'{file_config}'", ",", "\n", "'--config-hyper'", ",", "f'{file_config_hyper}'", ",", "\n", "'--path-data'", ",", "f'{__data_testing_dir__}'", ",", "\n", "'--output_dir'", ",", "f'{__output_dir__}'", ",", "\n", "'--run-test'", ")", "\n", "logger", ".", "debug", "(", "f\"{ret.stdout}\"", ")", "\n", "logger", ".", "debug", "(", "f\"{ret.stderr}\"", ")", "\n", "assert", "ret", ".", "success", "\n", "assert", "Path", "(", "__output_dir__", ",", "'detailed_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'temporary_results.csv'", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "'average_eval.csv'", ")", ".", "exists", "(", ")", "\n", "\n", "# check sha256 is recorded in config_file.json", "\n", "check_sha256", "(", "str", "(", "file_config", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_convert_to_onnx.setup_function": [[14, 16], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_convert_to_onnx.test_convert_to_onnx": [[18, 21], ["ivadomed.scripts.convert_to_onnx.main", "pathlib.Path().exists", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_convert_to_onnx", "(", "download_functional_test_files", ")", ":", "\n", "    ", "convert_to_onnx", ".", "main", "(", "args", "=", "[", "'-m'", ",", "f'{__model_path__}'", ",", "'-d'", ",", "'2'", "]", ")", "\n", "assert", "Path", "(", "__data_testing_dir__", ",", "'spinegeneric_model.onnx'", ")", ".", "exists", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_convert_to_onnx.test_convert_to_onnx_no_model": [[23, 26], ["pytest.raises", "ivadomed.scripts.convert_to_onnx.main"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_convert_to_onnx_no_model", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ArgParseException", ",", "match", "=", "r\"Error parsing args\"", ")", ":", "\n", "        ", "convert_to_onnx", ".", "main", "(", "args", "=", "[", "'-d'", ",", "'2'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_convert_to_onnx.test_convert_to_onnx_no_dimension": [[28, 31], ["pytest.raises", "ivadomed.scripts.convert_to_onnx.main"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "", "def", "test_convert_to_onnx_no_dimension", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ArgParseException", ",", "match", "=", "r\"Error parsing args\"", ")", ":", "\n", "        ", "convert_to_onnx", ".", "main", "(", "args", "=", "[", "'-m'", ",", "f'{__model_path__}'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_convert_to_onnx.teardown_function": [[33, 35], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_utils.download_functional_test_files": [[16, 22], ["pytest.fixture", "testing.common_testing_util.download_dataset"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.download_dataset"], ["@", "pytest", ".", "fixture", "(", "scope", "=", "'session'", ")", "\n", "def", "download_functional_test_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    This fixture will attempt to download test data file if there are not present.\n    \"\"\"", "\n", "download_dataset", "(", "\"data_functional_testing\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_utils.check_sha256": [[24, 38], ["ivadomed.config_manager.ConfigurationManager().get_config", "pathlib.Path().parent.glob", "ivadomed.config_manager.ConfigurationManager().get_config", "ivadomed.config_manager.ConfigurationManager", "path_object.is_file", "result.append", "pathlib.Path", "str", "ivadomed.config_manager.ConfigurationManager"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config"], ["", "def", "check_sha256", "(", "file_config", ")", ":", "\n", "    ", "\"\"\"\n    This function checks if sha256 is generated in according to config file\n    \"\"\"", "\n", "initial_config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "file_config", ")", ".", "get_config", "(", ")", "\n", "result", "=", "[", "]", "\n", "name", "=", "\"config_file.json\"", "\n", "for", "path_object", "in", "Path", "(", "initial_config", "[", "\"path_output\"", "]", ")", ".", "parent", ".", "glob", "(", "\"**/*\"", ")", ":", "\n", "        ", "if", "path_object", ".", "is_file", "(", ")", "and", "name", "in", "path_object", ".", "name", ":", "\n", "            ", "result", ".", "append", "(", "str", "(", "path_object", ")", ")", "\n", "", "", "assert", "result", "!=", "[", "]", "\n", "for", "generated_config", "in", "result", ":", "\n", "        ", "config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "generated_config", ")", ".", "get_config", "(", ")", "\n", "assert", "'training_sha256'", "in", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.t_utils.create_tmp_dir": [[40, 58], ["testing.common_testing_util.remove_tmp_dir", "pathlib.Path().mkdir", "pathlib.Path().exists", "shutil.copytree", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "create_tmp_dir", "(", "copy_data_testing_dir", "=", "True", ")", ":", "\n", "    ", "\"\"\"Create a temporary directory for data_functional and copy test data files.\n\n    1. Remove the ``tmp`` directory if it exists.\n    2. Copy the ``data_functional_testing`` directory to the ``tmp`` directory.\n\n    Any data files created during testing will go into ``tmp`` directory.\n    This is created/removed for each test.\n\n    Args:\n        copy_data_testing_dir (bool): If true, copy the __data_testing_dir_ref__ folder\n            into the ``tmp`` folder.\n    \"\"\"", "\n", "remove_tmp_dir", "(", ")", "\n", "Path", "(", "path_temp", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "if", "Path", "(", "path_data_functional_source", ")", ".", "exists", "(", ")", "and", "copy_data_testing_dir", ":", "\n", "        ", "shutil", ".", "copytree", "(", "path_data_functional_source", ",", "\n", "path_data_functional_tmp", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.setup_function": [[21, 23], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.test_segment_volume_2d_NumpyToTensor_retrocompatibility": [[31, 82], ["ivadomed.models.Unet", "torch.save", "pathlib.Path", "ivadomed.inference.segment_volume", "shutil.rmtree", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "pathlib.Path", "open", "json.dump", "str", "str", "numpy.squeeze", "nibabel.load", "nib_img.dataobj.max", "nib_img.dataobj.min", "str", "nib_img.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume"], ["def", "test_segment_volume_2d_NumpyToTensor_retrocompatibility", "(", "download_functional_test_files", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Unet", "(", "in_channel", "=", "1", ",", "\n", "out_channel", "=", "1", ",", "\n", "depth", "=", "2", ",", "\n", "dropout_rate", "=", "DROPOUT", ",", "\n", "bn_momentum", "=", "BN", ")", "\n", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "torch", ".", "save", "(", "model", ",", "Path", "(", "PATH_MODEL", ",", "\"model_test.pt\"", ")", ")", "\n", "config", "=", "{", "\n", "\"loader_parameters\"", ":", "{", "\n", "\"slice_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"roi_params\"", ":", "{", "\n", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\n", "\"slice_filter_roi\"", ":", "10", "\n", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", ",", "\n", "\"transformation\"", ":", "{", "\n", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"ROICrop\"", ":", "{", "\"size\"", ":", "[", "48", ",", "48", "]", "}", ",", "\n", "\"RandomTranslation\"", ":", "{", "\n", "\"translate\"", ":", "[", "0.03", ",", "0.03", "]", ",", "\n", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", ",", "\n", "\"dataset_type\"", ":", "[", "\"training\"", "]", "\n", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", ",", "\n", "\"postprocessing\"", ":", "{", "}", ",", "\n", "\"training_parameters\"", ":", "{", "\n", "\"batch_size\"", ":", "BATCH_SIZE", "\n", "}", "\n", "}", "\n", "\n", "PATH_CONFIG", "=", "Path", "(", "PATH_MODEL", ",", "'model_test.json'", ")", "\n", "with", "open", "(", "PATH_CONFIG", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "config", ",", "fp", ")", "\n", "\n", "", "nib_lst", ",", "_", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "PATH_MODEL", ")", ",", "[", "str", "(", "PATH_IMAGE", ")", "]", ",", "options", "=", "{", "'fname_prior'", ":", "str", "(", "PATH_ROI", ")", "}", ")", "\n", "nib_img", "=", "nib_lst", "[", "0", "]", "\n", "assert", "np", ".", "squeeze", "(", "nib_img", ".", "get_fdata", "(", ")", ")", ".", "shape", "==", "nib", ".", "load", "(", "PATH_IMAGE", ")", ".", "shape", "\n", "assert", "(", "nib_img", ".", "dataobj", ".", "max", "(", ")", "<=", "1.0", ")", "and", "(", "nib_img", ".", "dataobj", ".", "min", "(", ")", ">=", "0.0", ")", "\n", "assert", "nib_img", ".", "dataobj", ".", "dtype", "==", "'float32'", "\n", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.test_segment_volume_2d": [[84, 134], ["ivadomed.models.Unet", "torch.save", "pathlib.Path", "ivadomed.inference.segment_volume", "shutil.rmtree", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "pathlib.Path", "pathlib.Path.open", "json.dump", "str", "str", "numpy.squeeze", "nibabel.load", "nib_img.dataobj.max", "nib_img.dataobj.min", "str", "nib_img.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume"], ["", "def", "test_segment_volume_2d", "(", "download_functional_test_files", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Unet", "(", "in_channel", "=", "1", ",", "\n", "out_channel", "=", "1", ",", "\n", "depth", "=", "2", ",", "\n", "dropout_rate", "=", "DROPOUT", ",", "\n", "bn_momentum", "=", "BN", ")", "\n", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "torch", ".", "save", "(", "model", ",", "Path", "(", "PATH_MODEL", ",", "\"model_test.pt\"", ")", ")", "\n", "config", "=", "{", "\n", "\"loader_parameters\"", ":", "{", "\n", "\"slice_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"roi_params\"", ":", "{", "\n", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\n", "\"slice_filter_roi\"", ":", "10", "\n", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", ",", "\n", "\"transformation\"", ":", "{", "\n", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"ROICrop\"", ":", "{", "\"size\"", ":", "[", "48", ",", "48", "]", "}", ",", "\n", "\"RandomTranslation\"", ":", "{", "\n", "\"translate\"", ":", "[", "0.03", ",", "0.03", "]", ",", "\n", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", ",", "\n", "\"dataset_type\"", ":", "[", "\"training\"", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", ",", "\n", "\"postprocessing\"", ":", "{", "}", ",", "\n", "\"training_parameters\"", ":", "{", "\n", "\"batch_size\"", ":", "BATCH_SIZE", "\n", "}", "\n", "}", "\n", "\n", "PATH_CONFIG", "=", "Path", "(", "PATH_MODEL", ",", "'model_test.json'", ")", "\n", "with", "PATH_CONFIG", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "config", ",", "fp", ")", "\n", "\n", "", "nib_lst", ",", "_", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "PATH_MODEL", ")", ",", "[", "str", "(", "PATH_IMAGE", ")", "]", ",", "options", "=", "{", "'fname_prior'", ":", "str", "(", "PATH_ROI", ")", "}", ")", "\n", "nib_img", "=", "nib_lst", "[", "0", "]", "\n", "assert", "np", ".", "squeeze", "(", "nib_img", ".", "get_fdata", "(", ")", ")", ".", "shape", "==", "nib", ".", "load", "(", "PATH_IMAGE", ")", ".", "shape", "\n", "assert", "(", "nib_img", ".", "dataobj", ".", "max", "(", ")", "<=", "1.0", ")", "and", "(", "nib_img", ".", "dataobj", ".", "min", "(", ")", ">=", "0.0", ")", "\n", "assert", "nib_img", ".", "dataobj", ".", "dtype", "==", "'float32'", "\n", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.test_segment_volume_2d_no_prepro_transform": [[136, 179], ["ivadomed.models.Unet", "torch.save", "pathlib.Path", "ivadomed.inference.segment_volume", "shutil.rmtree", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "pathlib.Path", "pathlib.Path.open", "json.dump", "str", "str", "numpy.squeeze", "nibabel.load", "nib_img.dataobj.max", "nib_img.dataobj.min", "nib_img.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume"], ["", "def", "test_segment_volume_2d_no_prepro_transform", "(", "download_functional_test_files", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Unet", "(", "in_channel", "=", "1", ",", "\n", "out_channel", "=", "1", ",", "\n", "depth", "=", "2", ",", "\n", "dropout_rate", "=", "DROPOUT", ",", "\n", "bn_momentum", "=", "BN", ")", "\n", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", ")", "\n", "\n", "", "torch", ".", "save", "(", "model", ",", "Path", "(", "PATH_MODEL", ",", "\"model_test.pt\"", ")", ")", "\n", "config", "=", "{", "\n", "\"loader_parameters\"", ":", "{", "\n", "\"slice_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"roi_params\"", ":", "{", "\n", "\"suffix\"", ":", "None", ",", "\n", "\"slice_filter_roi\"", ":", "None", "\n", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", ",", "\n", "\"transformation\"", ":", "{", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", ",", "\n", "\"postprocessing\"", ":", "{", "}", ",", "\n", "\"training_parameters\"", ":", "{", "\n", "\"batch_size\"", ":", "BATCH_SIZE", "\n", "}", "\n", "}", "\n", "\n", "PATH_CONFIG", "=", "Path", "(", "PATH_MODEL", ",", "'model_test.json'", ")", "\n", "with", "PATH_CONFIG", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "config", ",", "fp", ")", "\n", "\n", "", "nib_lst", ",", "_", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "PATH_MODEL", ")", ",", "[", "str", "(", "PATH_IMAGE", ")", "]", ")", "\n", "nib_img", "=", "nib_lst", "[", "0", "]", "\n", "assert", "np", ".", "squeeze", "(", "nib_img", ".", "get_fdata", "(", ")", ")", ".", "shape", "==", "nib", ".", "load", "(", "PATH_IMAGE", ")", ".", "shape", "\n", "assert", "(", "nib_img", ".", "dataobj", ".", "max", "(", ")", "<=", "1.0", ")", "and", "(", "nib_img", ".", "dataobj", ".", "min", "(", ")", ">=", "0.0", ")", "\n", "assert", "nib_img", ".", "dataobj", ".", "dtype", "==", "'float32'", "\n", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.test_segment_volume_2d_with_patches": [[181, 240], ["pytest.mark.parametrize", "ivadomed.models.Unet", "torch.save", "pathlib.Path", "ivadomed.inference.segment_volume", "shutil.rmtree", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "pathlib.Path", "pathlib.Path.open", "json.dump", "str", "str", "numpy.squeeze", "nibabel.load", "nib_img.dataobj.max", "nib_img.dataobj.min", "nib_img.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"center_crop\"", ",", "[", "[", "200", ",", "200", "]", "]", ")", "\n", "def", "test_segment_volume_2d_with_patches", "(", "download_functional_test_files", ",", "center_crop", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Unet", "(", "in_channel", "=", "1", ",", "\n", "out_channel", "=", "1", ",", "\n", "depth", "=", "2", ",", "\n", "dropout_rate", "=", "DROPOUT", ",", "\n", "bn_momentum", "=", "BN", ")", "\n", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "torch", ".", "save", "(", "model", ",", "Path", "(", "PATH_MODEL", ",", "\"model_test.pt\"", ")", ")", "\n", "config", "=", "{", "\n", "\"loader_parameters\"", ":", "{", "\n", "\"slice_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"roi_params\"", ":", "{", "\n", "\"suffix\"", ":", "None", ",", "\n", "\"slice_filter_roi\"", ":", "None", "\n", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", ",", "\n", "\"default_model\"", ":", "{", "\n", "\"length_2D\"", ":", "LENGTH_2D", ",", "\n", "\"stride_2D\"", ":", "LENGTH_2D", "\n", "}", ",", "\n", "\"transformation\"", ":", "{", "\n", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "center_crop", "}", ",", "\n", "\"RandomTranslation\"", ":", "{", "\n", "\"translate\"", ":", "[", "0.03", ",", "0.03", "]", ",", "\n", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", ",", "\n", "\"dataset_type\"", ":", "[", "\"training\"", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", ",", "\n", "\"postprocessing\"", ":", "{", "}", ",", "\n", "\"training_parameters\"", ":", "{", "\n", "\"batch_size\"", ":", "BATCH_SIZE", "\n", "}", "\n", "}", "\n", "\n", "PATH_CONFIG", "=", "Path", "(", "PATH_MODEL", ",", "'model_test.json'", ")", "\n", "with", "PATH_CONFIG", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "config", ",", "fp", ")", "\n", "\n", "", "nib_lst", ",", "_", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "PATH_MODEL", ")", ",", "[", "str", "(", "PATH_IMAGE", ")", "]", ")", "\n", "nib_img", "=", "nib_lst", "[", "0", "]", "\n", "assert", "np", ".", "squeeze", "(", "nib_img", ".", "get_fdata", "(", ")", ")", ".", "shape", "==", "nib", ".", "load", "(", "PATH_IMAGE", ")", ".", "shape", "\n", "assert", "(", "nib_img", ".", "dataobj", ".", "max", "(", ")", "<=", "1.0", ")", "and", "(", "nib_img", ".", "dataobj", ".", "min", "(", ")", ">=", "0.0", ")", "\n", "assert", "nib_img", ".", "dataobj", ".", "dtype", "==", "'float32'", "\n", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.test_segment_volume_3d": [[242, 304], ["pytest.mark.parametrize", "ivadomed.models.Modified3DUNet", "torch.save", "pathlib.Path", "ivadomed.inference.segment_volume", "shutil.rmtree", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "pathlib.Path", "pathlib.Path.open", "json.dump", "str", "str", "numpy.squeeze", "nibabel.load", "nib_img.dataobj.max", "nib_img.dataobj.min", "nib_img.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"center_crop\"", ",", "[", "[", "192", ",", "192", ",", "16", "]", "]", ")", "\n", "def", "test_segment_volume_3d", "(", "download_functional_test_files", ",", "center_crop", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Modified3DUNet", "(", "in_channel", "=", "1", ",", "\n", "out_channel", "=", "1", ",", "\n", "base_n_filter", "=", "1", ")", "\n", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "torch", ".", "save", "(", "model", ",", "Path", "(", "PATH_MODEL", ",", "\"model_test.pt\"", ")", ")", "\n", "config", "=", "{", "\n", "\"Modified3DUNet\"", ":", "{", "\n", "\"applied\"", ":", "True", ",", "\n", "\"length_3D\"", ":", "LENGTH_3D", ",", "\n", "\"stride_3D\"", ":", "LENGTH_3D", ",", "\n", "\"attention\"", ":", "False", "\n", "}", ",", "\n", "\"loader_parameters\"", ":", "{", "\n", "\"slice_filter_params\"", ":", "{", "\n", "\"filter_empty_mask\"", ":", "False", ",", "\n", "\"filter_empty_input\"", ":", "False", "\n", "}", ",", "\n", "\"roi_params\"", ":", "{", "\n", "\"suffix\"", ":", "None", ",", "\n", "\"slice_filter_roi\"", ":", "None", "\n", "}", ",", "\n", "\"slice_axis\"", ":", "\"sagittal\"", "\n", "}", ",", "\n", "\"transformation\"", ":", "{", "\n", "\"Resample\"", ":", "\n", "{", "\n", "\"wspace\"", ":", "1", ",", "\n", "\"hspace\"", ":", "1", ",", "\n", "\"dspace\"", ":", "2", "\n", "}", ",", "\n", "\"CenterCrop\"", ":", "{", "\n", "\"size\"", ":", "center_crop", "\n", "}", ",", "\n", "\"RandomTranslation\"", ":", "{", "\n", "\"translate\"", ":", "[", "0.03", ",", "0.03", "]", ",", "\n", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", ",", "\n", "\"dataset_type\"", ":", "[", "\"training\"", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", ",", "\n", "\"postprocessing\"", ":", "{", "}", ",", "\n", "\"training_parameters\"", ":", "{", "\n", "\"batch_size\"", ":", "BATCH_SIZE", "\n", "}", "\n", "}", "\n", "\n", "PATH_CONFIG", "=", "Path", "(", "PATH_MODEL", ",", "'model_test.json'", ")", "\n", "with", "PATH_CONFIG", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "config", ",", "fp", ")", "\n", "\n", "", "nib_lst", ",", "_", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "PATH_MODEL", ")", ",", "[", "str", "(", "PATH_IMAGE", ")", "]", ")", "\n", "nib_img", "=", "nib_lst", "[", "0", "]", "\n", "assert", "np", ".", "squeeze", "(", "nib_img", ".", "get_fdata", "(", ")", ")", ".", "shape", "==", "nib", ".", "load", "(", "PATH_IMAGE", ")", ".", "shape", "\n", "assert", "(", "nib_img", ".", "dataobj", ".", "max", "(", ")", "<=", "1.0", ")", "and", "(", "nib_img", ".", "dataobj", ".", "min", "(", ")", ">=", "0.0", ")", "\n", "assert", "nib_img", ".", "dataobj", ".", "dtype", "==", "'float32'", "\n", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_segment_volume.teardown_function": [[306, 308], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_download_data.setup_function": [[11, 13], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", "copy_data_testing_dir", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_download_data.test_download_data": [[15, 22], ["pathlib.Path", "ivadomed.scripts.download_data.main", "pathlib.Path.exists", "testing.common_testing_util.remove_dataset", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_dataset"], ["", "def", "test_download_data", "(", ")", ":", "\n", "    ", "for", "dataset", "in", "download_data", ".", "DICT_URL", ":", "\n", "        ", "output_folder", "=", "Path", "(", "__tmp_dir__", ",", "dataset", ")", "\n", "download_data", ".", "main", "(", "args", "=", "[", "'-d'", ",", "dataset", ",", "\n", "'-o'", ",", "str", "(", "output_folder", ")", "]", ")", "\n", "assert", "output_folder", ".", "exists", "(", ")", "\n", "remove_dataset", "(", "dataset", "=", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_download_data.test_download_data_no_dataset_specified": [[24, 27], ["pytest.raises", "ivadomed.scripts.download_data.main"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "", "def", "test_download_data_no_dataset_specified", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ArgParseException", ",", "match", "=", "r\"Error parsing args\"", ")", ":", "\n", "        ", "download_data", ".", "main", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_download_data.teardown_function": [[29, 31], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_training_curve.setup_function": [[9, 11], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_training_curve.test_training_curve": [[13, 30], ["pathlib.Path", "pathlib.Path", "pathlib.Path", "ivadomed.scripts.training_curve.main", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path().exists", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "pathlib.Path", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_training_curve", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__data_testing_dir__", "=", "Path", "(", "__tmp_dir__", ",", "\"data_functional_testing\"", ")", "\n", "__input_dir__", "=", "Path", "(", "__data_testing_dir__", ",", "'tensorboard_events'", ")", "\n", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'output_training_curve'", ")", "\n", "training_curve", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__input_dir__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", "]", ")", "\n", "assert", "Path", "(", "__output_dir__", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"accuracy_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"dice_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"hausdorff_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"intersection_over_union.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"losses.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"multi_class_dice_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"precision_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"recall_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"specificity_score.png\"", ")", ".", "exists", "(", ")", "\n", "assert", "Path", "(", "__output_dir__", ",", "\"tensorboard_events_training_values.csv\"", ")", ".", "exists", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_training_curve.teardown_function": [[32, 34], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.setup_function": [[10, 12], ["testing.functional_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.test_extract_small_dataset_default_n": [[14, 26], ["pathlib.Path", "ivadomed.scripts.extract_small_dataset.main", "pathlib.Path.exists", "pathlib.Path.iterdir", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_extract_small_dataset_default_n", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'output_extract_small_dataset'", ")", "\n", "extract_small_dataset", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__data_testing_dir__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_dir_list", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "'derivatives'", "in", "output_dir_list", "\n", "assert", "'participants.tsv'", "in", "output_dir_list", "\n", "assert", "'dataset_description.json'", "in", "output_dir_list", "\n", "assert", "'sub-unf01'", "in", "output_dir_list", "or", "'sub-unf02'", "in", "output_dir_list", "or", "'sub-unf03'", "in", "output_dir_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.test_extract_small_dataset_n_2": [[28, 44], ["pathlib.Path", "ivadomed.scripts.extract_small_dataset.main", "pathlib.Path.exists", "pathlib.Path.iterdir", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_extract_small_dataset_n_2", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'output_extract_small_dataset_2'", ")", "\n", "extract_small_dataset", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__data_testing_dir__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", ",", "\n", "'-n'", ",", "'2'", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_dir_list", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "'derivatives'", "in", "output_dir_list", "\n", "assert", "'participants.tsv'", "in", "output_dir_list", "\n", "assert", "'dataset_description.json'", "in", "output_dir_list", "\n", "assert", "(", "'sub-unf01'", "in", "output_dir_list", "and", "'sub-unf02'", "in", "output_dir_list", ")", "or", "(", "'sub-unf01'", "in", "output_dir_list", "and", "'sub-unf03'", "in", "output_dir_list", ")", "or", "(", "'sub-unf03'", "in", "output_dir_list", "and", "'sub-unf02'", "in", "output_dir_list", ")", "\n", "assert", "'sub-unf01'", "not", "in", "output_dir_list", "or", "'sub-unf02'", "not", "in", "output_dir_list", "or", "'sub-unf03'", "not", "in", "output_dir_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.test_extract_small_dataset_no_derivatives": [[46, 59], ["pathlib.Path", "ivadomed.scripts.extract_small_dataset.main", "pathlib.Path.exists", "pathlib.Path.iterdir", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_extract_small_dataset_no_derivatives", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'output_extract_small_dataset_3'", ")", "\n", "extract_small_dataset", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__data_testing_dir__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", ",", "\n", "'-d'", ",", "'0'", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_dir_list", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "'derivatives'", "not", "in", "output_dir_list", "\n", "assert", "'participants.tsv'", "in", "output_dir_list", "\n", "assert", "'dataset_description.json'", "in", "output_dir_list", "\n", "assert", "'sub-unf01'", "in", "output_dir_list", "or", "'sub-unf02'", "in", "output_dir_list", "or", "'sub-unf03'", "in", "output_dir_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.test_extract_small_dataset_contrast_list": [[61, 74], ["pathlib.Path", "ivadomed.scripts.extract_small_dataset.main", "pathlib.Path.exists", "pathlib.Path.iterdir", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main"], ["", "def", "test_extract_small_dataset_contrast_list", "(", "download_functional_test_files", ")", ":", "\n", "    ", "__output_dir__", "=", "Path", "(", "__tmp_dir__", ",", "'output_extract_small_dataset_4'", ")", "\n", "extract_small_dataset", ".", "main", "(", "args", "=", "[", "'--input'", ",", "str", "(", "__data_testing_dir__", ")", ",", "\n", "'--output'", ",", "str", "(", "__output_dir__", ")", ",", "\n", "'-c'", ",", "'T1w, T2w'", "]", ")", "\n", "assert", "__output_dir__", ".", "exists", "(", ")", "\n", "output_dir_list", "=", "[", "f", ".", "name", "for", "f", "in", "__output_dir__", ".", "iterdir", "(", ")", "]", "\n", "assert", "'derivatives'", "in", "output_dir_list", "\n", "assert", "'participants.tsv'", "in", "output_dir_list", "\n", "assert", "'dataset_description.json'", "in", "output_dir_list", "\n", "assert", "'sub-unf01'", "in", "output_dir_list", "or", "'sub-unf02'", "in", "output_dir_list", "or", "'sub-unf03'", "in", "output_dir_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.functional_tests.test_extract_small_dataset.teardown_function": [[76, 78], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_template.setup_function": [[64, 74], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "\"\"\"Function which is run before each test in this file.\n\n    ``create_tmp_dir`` will do the following:\n    1. Create a directory called ``tmp`` (overwrite if already exists)\n    2. Copy ``data_functional_testing`` -> ``tmp/data_functional_testing``\n\n    Add any other things for setup here.\n    \"\"\"", "\n", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_template.test_template": [[76, 84], ["logger.info", "pathlib.Path().mkdir", "pathlib.Path", "pathlib.Path().iterdir", "pathlib.Path"], "function", ["None"], ["", "def", "test_template", "(", ")", ":", "\n", "# Test Input Files: all test input files should be in tmp/data_functional_testing", "\n", "# aka __data_testing_dir__", "\n", "    ", "logger", ".", "info", "(", "[", "f", ".", "name", "for", "f", "in", "Path", "(", "__data_testing_dir__", ")", ".", "iterdir", "(", ")", "]", ")", "\n", "\n", "# Test Output Files: put your output files in tmp folder", "\n", "Path", "(", "__tmp_dir__", ",", "'my_output_dir'", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "assert", "1", "==", "1", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_template.teardown_function": [[86, 97], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["\n", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "\"\"\"Function which is run after each test in this file.\n\n    ``remove_tmp_dir`` will do the following:\n    1. Delete the directory called ``tmp`` (if already exists)\n\n    Add any other things for teardown here.\n    Note: this function gets run after each test, so files/data will not be saved\n        in between tests.\n    \"\"\"", "\n", "remove_tmp_dir", "(", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_bounding_box.setup_function": [[21, 23], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_bounding_box.test_bounding_box": [[25, 124], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "numpy.zeros", "ivadomed.object_detection.utils.get_bounding_boxes", "pathlib.Path", "pathlib.Path.cwd", "str", "loader_params.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "range", "shutil.rmtree", "config[].update", "pathlib.Path().exists", "PATH_OUTPUT.mkdir", "train_lst[].split", "pathlib.Path", "open", "json.dump", "len", "pathlib.Path", "str", "str", "path_seg_pair.open", "pickle.load", "path_seg_pair.open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.get_bounding_boxes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'train_lst'", ",", "[", "[", "'sub-unf01_T2w.nii.gz'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_lesion-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'config'", ",", "[", "\n", "{", "\n", "\"object_detection_params\"", ":", "{", "\n", "\"object_detection_path\"", ":", "\"object_detection\"", ",", "\n", "\"safety_factor\"", ":", "[", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "\"path_output\"", ":", "str", "(", "PATH_OUTPUT", ")", "\n", "}", ",", "\n", "\"transforms_params\"", ":", "{", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "}", ",", "{", "\n", "\"object_detection_params\"", ":", "{", "\n", "\"object_detection_path\"", ":", "\"object_detection\"", ",", "\n", "\"safety_factor\"", ":", "[", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "\"path_output\"", ":", "str", "(", "PATH_OUTPUT", ")", "\n", "}", ",", "\n", "\"transforms_params\"", ":", "{", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"Modified3DUNet\"", ":", "{", "\n", "\"applied\"", ":", "True", ",", "\n", "\"length_3D\"", ":", "[", "16", ",", "16", ",", "16", "]", ",", "\n", "\"stride_3D\"", ":", "[", "1", ",", "1", ",", "1", "]", ",", "\n", "\"attention\"", ":", "False", ",", "\n", "\"n_filters\"", ":", "8", "\n", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "}", "]", ")", "\n", "def", "test_bounding_box", "(", "download_data_testing_test_files", ",", "train_lst", ",", "target_lst", ",", "config", ")", ":", "\n", "# Create mask", "\n", "    ", "mask_coord", "=", "[", "20", ",", "40", ",", "20", ",", "90", ",", "0", ",", "25", "]", "\n", "mx1", ",", "mx2", ",", "my1", ",", "my2", ",", "mz1", ",", "mz2", "=", "mask_coord", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "96", ",", "96", ",", "96", ")", ")", "\n", "mask", "[", "mx1", ":", "mx2", "+", "1", ",", "my1", ":", "my2", "+", "1", ",", "mz1", ":", "mz2", "+", "1", "]", "=", "1", "\n", "coord", "=", "imed_obj_detect", ".", "get_bounding_boxes", "(", "mask", ")", "\n", "assert", "coord", "[", "0", "]", "==", "mask_coord", "\n", "\n", "loader_params", "=", "{", "\n", "\"data_list\"", ":", "train_lst", ",", "\n", "\"dataset_type\"", ":", "\"training\"", ",", "\n", "\"requires_undo\"", ":", "False", ",", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", "\n", "\n", "if", "\"Modified3DUNet\"", "in", "config", ":", "\n", "        ", "config", "[", "'model_params'", "]", "[", "\"name\"", "]", "=", "\"Modified3DUNet\"", "\n", "config", "[", "'model_params'", "]", ".", "update", "(", "config", "[", "\"Modified3DUNet\"", "]", ")", "\n", "\n", "", "bounding_box_dict", "=", "{", "}", "\n", "bounding_box_path", "=", "Path", "(", "PATH_OUTPUT", ",", "'bounding_boxes.json'", ")", "\n", "if", "not", "Path", "(", "PATH_OUTPUT", ")", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_OUTPUT", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "current_dir", "=", "Path", ".", "cwd", "(", ")", "\n", "sub", "=", "train_lst", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "contrast", "=", "config", "[", "'contrast_params'", "]", "[", "'contrast_lst'", "]", "[", "0", "]", "\n", "bb_path", "=", "str", "(", "Path", "(", "current_dir", ",", "__data_testing_dir__", ",", "sub", ",", "\"anat\"", ",", "sub", "+", "\"_\"", "+", "contrast", "+", "\".nii.gz\"", ")", ")", "\n", "bounding_box_dict", "[", "bb_path", "]", "=", "coord", "\n", "with", "open", "(", "bounding_box_path", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "bounding_box_dict", ",", "fp", ",", "indent", "=", "4", ")", "\n", "\n", "# Update loader_params with config", "\n", "", "loader_params", ".", "update", "(", "config", ")", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "\n", "handler", "=", "ds", ".", "handlers", "if", "\"Modified3DUNet\"", "in", "config", "else", "ds", ".", "indexes", "\n", "for", "index", "in", "range", "(", "len", "(", "handler", ")", ")", ":", "\n", "\n", "        ", "if", "\"Modified3DUNet\"", "in", "config", ":", "\n", "            ", "if", "ds", ".", "disk_cache", ":", "\n", "                ", "path_seg_pair", ",", "_", "=", "handler", "[", "index", "]", "\n", "with", "path_seg_pair", ".", "open", "(", "'rb'", ")", "as", "f", ":", "\n", "                    ", "seg_pair", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "                ", "seg_pair", ",", "_", "=", "handler", "[", "index", "]", "\n", "", "assert", "seg_pair", "[", "'input'", "]", "[", "0", "]", ".", "shape", "[", "-", "3", ":", "]", "==", "(", "mx2", "-", "mx1", ",", "my2", "-", "my1", ",", "mz2", "-", "mz1", ")", "\n", "", "else", ":", "\n", "            ", "if", "ds", ".", "disk_cache", ":", "\n", "                ", "path_seg_pair", "=", "handler", "[", "index", "]", "\n", "with", "path_seg_pair", ".", "open", "(", "'rb'", ")", "as", "f", ":", "\n", "                    ", "seg_pair", ",", "_", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "                ", "seg_pair", ",", "_", "=", "handler", "[", "index", "]", "\n", "", "assert", "seg_pair", "[", "'input'", "]", "[", "0", "]", ".", "shape", "[", "-", "2", ":", "]", "==", "(", "mx2", "-", "mx1", ",", "my2", "-", "my1", ")", "\n", "\n", "", "", "shutil", ".", "rmtree", "(", "PATH_OUTPUT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_bounding_box.test_adjust_bb_size": [[126, 130], ["ivadomed.object_detection.utils.adjust_bb_size"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_bb_size"], ["", "def", "test_adjust_bb_size", "(", ")", ":", "\n", "    ", "test_coord", "=", "(", "0", ",", "10", ",", "0", ",", "10", ",", "0", ",", "10", ")", "\n", "res", "=", "imed_obj_detect", ".", "adjust_bb_size", "(", "test_coord", ",", "(", "2", ",", "2", ",", "2", ")", ",", "True", ")", "\n", "assert", "(", "res", "==", "[", "0", ",", "20", ",", "0", ",", "20", ",", "0", ",", "20", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_bounding_box.test_compute_bb_statistics": [[132, 136], ["ivadomed.object_detection.utils.compute_bb_statistics", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.compute_bb_statistics"], ["", "def", "test_compute_bb_statistics", "(", "download_data_testing_test_files", ")", ":", "\n", "    ", "\"\"\"Check to make sure compute_bb_statistics runs.\"\"\"", "\n", "imed_obj_detect", ".", "compute_bb_statistics", "(", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\n", "\"bounding_box_dict.json\"", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_bounding_box.teardown_function": [[138, 140], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image": [[25, 90], ["numpy.zeros", "range", "numpy.ceil().astype", "range", "numpy.random.randint", "scipy.ndimage.center_of_mass", "int", "numpy.random.uniform", "ivadomed.maths.rescale_values_array", "list_im.append", "list_seg.append", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.ceil", "numpy.ceil", "np.ceil().astype.astype", "round", "numpy.maximum", "numpy.rint", "numpy.rint", "numpy.rint", "numpy.random.random", "numpy.random.random"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array"], ["", "def", "create_test_image", "(", "width", ",", "height", ",", "depth", "=", "0", ",", "num_contrasts", "=", "1", ",", "noise_max", "=", "10.0", ",", "num_objs", "=", "1", ",", "rad_max", "=", "30", ",", "\n", "num_seg_classes", "=", "1", ",", "random_position", "=", "False", ")", ":", "\n", "    ", "\"\"\"Create test image.\n\n    Create test image and its segmentation with a given number of objects, classes, and maximum radius.\n    Compatible with both 2D (depth=0) and 3D images.\n\n    Args:\n        height (int): height image\n        width (int): width image\n        depth (int): depth image, if 0 then 2D images are returned\n        num_contrasts (int): number of contrasts\n        noise_max (float): noise from the uniform distribution [0,noise_max)\n        num_objs (int): number of objects\n        rad_max (int): maximum radius of objects\n        num_seg_classes (int): number of classes\n        random_position (bool): If false, the object is located at the center of the image. Otherwise, randomly located.\n\n    Return:\n        list, list: image and segmentation, list of num_contrasts elements of shape (height, width, depth).\n\n    Adapted from: https://github.com/Project-MONAI/MONAI/blob/master/monai/data/synthetic.py#L17\n    \"\"\"", "\n", "assert", "num_contrasts", ">=", "1", "\n", "\n", "depth_", "=", "depth", "if", "depth", ">=", "1", "else", "2", "*", "rad_max", "+", "1", "\n", "assert", "(", "height", ">", "2", "*", "rad_max", ")", "and", "(", "width", ">", "2", "*", "rad_max", ")", "and", "(", "depth_", ">", "2", "*", "rad_max", ")", "\n", "\n", "image", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ",", "depth_", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_objs", ")", ":", "\n", "        ", "if", "random_position", ":", "\n", "            ", "x", "=", "np", ".", "random", ".", "randint", "(", "rad_max", ",", "height", "-", "rad_max", ")", "\n", "y", "=", "np", ".", "random", ".", "randint", "(", "rad_max", ",", "width", "-", "rad_max", ")", "\n", "z", "=", "np", ".", "random", ".", "randint", "(", "rad_max", ",", "depth_", "-", "rad_max", ")", "\n", "", "else", ":", "\n", "            ", "x", ",", "y", ",", "z", "=", "np", ".", "rint", "(", "height", "/", "2", ")", ",", "np", ".", "rint", "(", "width", "/", "2", ")", ",", "np", ".", "rint", "(", "depth_", "/", "2", ")", "\n", "", "rad", "=", "np", ".", "random", ".", "randint", "(", "5", ",", "rad_max", ")", "\n", "spy", ",", "spx", ",", "spz", "=", "np", ".", "ogrid", "[", "-", "x", ":", "height", "-", "x", ",", "-", "y", ":", "width", "-", "y", ",", "-", "z", ":", "depth_", "-", "z", "]", "\n", "sphere", "=", "(", "spx", "*", "spx", "+", "spy", "*", "spy", "+", "spz", "*", "spz", ")", "<=", "rad", "*", "rad", "*", "rad", "\n", "\n", "if", "num_seg_classes", ">", "1", ":", "\n", "            ", "image", "[", "sphere", "]", "=", "np", ".", "ceil", "(", "np", ".", "random", ".", "random", "(", ")", "*", "num_seg_classes", ")", "\n", "", "else", ":", "\n", "            ", "image", "[", "sphere", "]", "=", "np", ".", "random", ".", "random", "(", ")", "*", "0.5", "+", "0.5", "\n", "\n", "", "", "seg", "=", "np", ".", "ceil", "(", "image", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "if", "depth", "==", "0", ":", "\n", "        ", "_", ",", "_", ",", "z_slice", "=", "center_of_mass", "(", "seg", ".", "astype", "(", "int", ")", ")", "\n", "z_slice", "=", "int", "(", "round", "(", "z_slice", ")", ")", "\n", "seg", "=", "seg", "[", ":", ",", ":", ",", "z_slice", "]", "\n", "\n", "", "list_im", ",", "list_seg", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "num_contrasts", ")", ":", "\n", "        ", "norm", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "num_seg_classes", "*", "noise_max", ",", "size", "=", "image", ".", "shape", ")", "\n", "noisy_image", "=", "imed_maths", ".", "rescale_values_array", "(", "np", ".", "maximum", "(", "image", ",", "norm", ")", ")", "\n", "\n", "if", "depth", "==", "0", ":", "\n", "            ", "noisy_image", "=", "noisy_image", "[", ":", ",", ":", ",", "z_slice", "]", "\n", "\n", "", "list_im", ".", "append", "(", "noisy_image", ")", "\n", "list_seg", ".", "append", "(", "seg", ")", "\n", "\n", "", "return", "list_im", ",", "list_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_HistogramClipping": [[92, 109], ["pytest.mark.parametrize", "ivadomed.transforms.HistogramClipping", "ivadomed.transforms.HistogramClipping.", "zip", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "len", "len", "math.isclose", "math.isclose", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.loader.sample_meta_data.SampleMetadata", "numpy.min", "numpy.percentile", "numpy.max", "numpy.percentile"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "2", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ")", "]", ")", "\n", "def", "test_HistogramClipping", "(", "im_seg", ")", ":", "\n", "    ", "im", ",", "_", "=", "im_seg", "\n", "# Transform", "\n", "transform", "=", "HistogramClipping", "(", ")", "\n", "# Apply Transform", "\n", "metadata", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "do_im", ",", "_", "=", "transform", "(", "sample", "=", "im", ",", "metadata", "=", "metadata", ")", "\n", "# Check result has the same number of contrasts", "\n", "assert", "len", "(", "do_im", ")", "==", "len", "(", "im", ")", "\n", "# Check clipping", "\n", "min_percentile", "=", "transform", ".", "min_percentile", "\n", "max_percentile", "=", "transform", ".", "max_percentile", "\n", "for", "i", ",", "r", "in", "zip", "(", "im", ",", "do_im", ")", ":", "\n", "        ", "assert", "isclose", "(", "np", ".", "min", "(", "r", ")", ",", "np", ".", "percentile", "(", "i", ",", "min_percentile", ")", ",", "rel_tol", "=", "1e-02", ")", "\n", "assert", "isclose", "(", "np", ".", "max", "(", "r", ")", ",", "np", ".", "percentile", "(", "i", ",", "max_percentile", ")", ",", "rel_tol", "=", "1e-02", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_NumpyToTensor": [[138, 159], ["pytest.mark.parametrize", "ivadomed.transforms.NumpyToTensor", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "ivadomed.transforms.NumpyToTensor.", "enumerate", "ivadomed.transforms.NumpyToTensor.undo_transform", "enumerate", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.loader.sample_meta_data.SampleMetadata", "torch.is_tensor", "isinstance", "numpy.array_equal"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "2", ")", "]", ")", "\n", "def", "test_NumpyToTensor", "(", "im_seg", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform", "\n", "transform", "=", "NumpyToTensor", "(", ")", "\n", "\n", "for", "im_cur", "in", "[", "im", ",", "seg", "]", ":", "\n", "# Numpy to Tensor", "\n", "        ", "do_im", ",", "do_metadata", "=", "transform", "(", "sample", "=", "im_cur", ",", "metadata", "=", "metadata_in", ")", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "do_im", ")", ":", "\n", "            ", "assert", "torch", ".", "is_tensor", "(", "i", ")", "\n", "\n", "# Tensor to Numpy", "\n", "", "undo_im", ",", "undo_metadata", "=", "transform", ".", "undo_transform", "(", "sample", "=", "do_im", ",", "metadata", "=", "do_metadata", ")", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "undo_im", ")", ":", "\n", "            ", "assert", "isinstance", "(", "i", ",", "np", ".", "ndarray", ")", "\n", "assert", "np", ".", "array_equal", "(", "i", ",", "im_cur", "[", "idx", "]", ")", "\n", "assert", "i", ".", "dtype", "==", "im_cur", "[", "idx", "]", ".", "dtype", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Resample": [[161, 200], ["ivadomed.loader.sample_meta_data.SampleMetadata", "resample_transform", "resample_transform.undo_transform", "ivadomed.loader.sample_meta_data.SampleMetadata", "resample_transform", "resample_transform.undo_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "test_transforms._check_dtype", "test_transforms._check_shape", "enumerate", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "plot_transformed_sample", "plot_transformed_sample", "ivadomed.metrics.dice_score", "len", "list", "len", "list"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score"], ["", "", "", "def", "_test_Resample", "(", "im_seg", ",", "resample_transform", ",", "native_resolution", ",", "is_2D", "=", "False", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_", "=", "SampleMetadata", "(", "{", "MetadataKW", ".", "ZOOMS", ":", "native_resolution", ",", "\n", "MetadataKW", ".", "DATA_SHAPE", ":", "im", "[", "0", "]", ".", "shape", "if", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "3", "else", "list", "(", "im", "[", "0", "]", ".", "shape", ")", "+", "[", "1", "]", ",", "\n", "MetadataKW", ".", "DATA_TYPE", ":", "'im'", "\n", "}", ")", "\n", "metadata_in", "=", "[", "metadata_", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Resample input data", "\n", "do_im", ",", "do_metadata", "=", "resample_transform", "(", "sample", "=", "im", ",", "metadata", "=", "metadata_in", ")", "\n", "# Undo Resample on input data", "\n", "undo_im", ",", "_", "=", "resample_transform", ".", "undo_transform", "(", "sample", "=", "do_im", ",", "metadata", "=", "do_metadata", ")", "\n", "\n", "# Resampler for label data", "\n", "resample_transform", ".", "interpolation_order", "=", "0", "\n", "metadata_", "=", "SampleMetadata", "(", "{", "MetadataKW", ".", "ZOOMS", ":", "native_resolution", ",", "\n", "MetadataKW", ".", "DATA_SHAPE", ":", "seg", "[", "0", "]", ".", "shape", "if", "len", "(", "seg", "[", "0", "]", ".", "shape", ")", "==", "3", "else", "list", "(", "seg", "[", "0", "]", ".", "shape", ")", "+", "[", "1", "]", ",", "\n", "MetadataKW", ".", "DATA_TYPE", ":", "'gt'", "\n", "}", ")", "\n", "metadata_in", "=", "[", "metadata_", "for", "_", "in", "seg", "]", "if", "isinstance", "(", "seg", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "# Resample label data", "\n", "do_seg", ",", "do_metadata", "=", "resample_transform", "(", "sample", "=", "seg", ",", "metadata", "=", "metadata_in", ")", "\n", "# Undo Resample on label data", "\n", "undo_seg", ",", "_", "=", "resample_transform", ".", "undo_transform", "(", "sample", "=", "do_seg", ",", "metadata", "=", "do_metadata", ")", "\n", "\n", "# Check data type and shape", "\n", "_check_dtype", "(", "im", ",", "[", "undo_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "undo_im", "]", ")", "\n", "_check_dtype", "(", "seg", ",", "[", "undo_seg", "]", ")", "\n", "_check_shape", "(", "seg", ",", "[", "undo_seg", "]", ")", "\n", "\n", "# Check data content and data shape between input data and undo", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "im", ")", ":", "\n", "# Plot for debugging", "\n", "        ", "if", "DEBUGGING", "and", "is_2D", ":", "\n", "            ", "plot_transformed_sample", "(", "im", "[", "idx", "]", ",", "undo_im", "[", "idx", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "plot_transformed_sample", "(", "seg", "[", "idx", "]", ",", "undo_seg", "[", "idx", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "# Data consistency", "\n", "", "assert", "dice_score", "(", "undo_seg", "[", "idx", "]", ",", "seg", "[", "idx", "]", ")", ">", "0.8", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_Resample_2D": [[202, 209], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "test_transforms._test_Resample", "test_transforms.create_test_image", "ivadomed.transforms.Resample", "ivadomed.transforms.Resample"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Resample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "80", ",", "100", ",", "0", ",", "2", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'resample_transform'", ",", "[", "Resample", "(", "0.8", ",", "1.0", ")", ",", "\n", "Resample", "(", "1.0", ",", "0.8", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'native_resolution'", ",", "[", "(", "0.9", ",", "1.0", ")", ",", "\n", "(", "1.0", ",", "0.9", ")", "]", ")", "\n", "def", "test_Resample_2D", "(", "im_seg", ",", "resample_transform", ",", "native_resolution", ")", ":", "\n", "    ", "_test_Resample", "(", "im_seg", ",", "resample_transform", ",", "native_resolution", ",", "is_2D", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_Resample_3D": [[211, 218], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "test_transforms._test_Resample", "test_transforms.create_test_image", "ivadomed.transforms.Resample", "ivadomed.transforms.Resample"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Resample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "80", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'resample_transform'", ",", "[", "Resample", "(", "0.8", ",", "1.0", ",", "0.5", ")", ",", "\n", "Resample", "(", "1.0", ",", "0.8", ",", "0.7", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'native_resolution'", ",", "[", "(", "0.9", ",", "1.0", ",", "0.8", ")", ",", "\n", "(", "1.0", ",", "0.9", ",", "1.1", ")", "]", ")", "\n", "def", "test_Resample_3D", "(", "im_seg", ",", "resample_transform", ",", "native_resolution", ")", ":", "\n", "    ", "_test_Resample", "(", "im_seg", ",", "resample_transform", ",", "native_resolution", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_NormalizeInstance": [[220, 240], ["pytest.mark.parametrize", "ivadomed.transforms.NormalizeInstance", "ivadomed.transforms.NormalizeInstance.", "ivadomed.transforms.NormalizeInstance.", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "ivadomed.transforms.NumpyToTensor", "abs", "abs", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.loader.sample_meta_data.SampleMetadata", "abs", "abs", "do_tensor.mean", "do_tensor.std", "numpy.mean", "numpy.std"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "2", ")", "]", ")", "\n", "def", "test_NormalizeInstance", "(", "im_seg", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "transform", "=", "NormalizeInstance", "(", ")", "\n", "do_im", ",", "_", "=", "transform", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "# Check normalization", "\n", "for", "i", "in", "do_im", ":", "\n", "        ", "assert", "abs", "(", "np", ".", "mean", "(", "i", ")", "-", "0.0", ")", "<=", "1e-2", "\n", "assert", "abs", "(", "np", ".", "std", "(", "i", ")", "-", "1.0", ")", "<=", "1e-2", "\n", "\n", "# Transform on Tensor", "\n", "", "tensor", ",", "metadata_tensor", "=", "NumpyToTensor", "(", ")", "(", "im", ",", "metadata_in", ")", "\n", "do_tensor", ",", "_", "=", "transform", "(", "tensor", ",", "metadata_tensor", ")", "\n", "# Check normalization", "\n", "assert", "abs", "(", "do_tensor", ".", "mean", "(", ")", "-", "0.0", ")", "<=", "1e-2", "\n", "assert", "abs", "(", "do_tensor", ".", "std", "(", ")", "-", "1.0", ")", "<=", "1e-2", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Crop": [[242, 292], ["ivadomed.loader.sample_meta_data.SampleMetadata", "crop_transform", "crop_transform", "enumerate", "crop_transform.undo_transform", "crop_transform.undo_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "test_transforms._check_dtype", "test_transforms._check_shape", "enumerate", "isinstance", "crop_transform", "list", "list", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "numpy.array_equal", "len", "plot_transformed_sample", "plot_transformed_sample"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample"], ["", "def", "_test_Crop", "(", "im_seg", ",", "crop_transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_", "=", "SampleMetadata", "(", "{", "MetadataKW", ".", "DATA_SHAPE", ":", "im", "[", "0", "]", ".", "shape", ",", "MetadataKW", ".", "CROP_PARAMS", ":", "{", "}", "}", ")", "\n", "metadata_in", "=", "[", "metadata_", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "{", "}", "\n", "if", "crop_transform", ".", "__class__", ".", "__name__", "==", "\"ROICrop\"", ":", "\n", "        ", "_", ",", "metadata_in", "=", "crop_transform", "(", "seg", ",", "metadata_in", ")", "\n", "for", "metadata", "in", "metadata_in", ":", "\n", "            ", "assert", "crop_transform", ".", "__class__", ".", "__name__", "in", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "\n", "\n", "# Apply transform", "\n", "", "", "do_im", ",", "do_metadata", "=", "crop_transform", "(", "im", ",", "metadata_in", ")", "\n", "do_seg", ",", "do_seg_metadata", "=", "crop_transform", "(", "seg", ",", "metadata_in", ")", "\n", "crop_transfrom_size", "=", "crop_transform", ".", "size", "if", "not", "len", "(", "do_im", "[", "0", "]", ".", "shape", ")", "==", "2", "else", "crop_transform", ".", "size", "[", ":", "2", "]", "\n", "\n", "# Loop and check", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "im", ")", ":", "\n", "# Check data shape", "\n", "        ", "assert", "list", "(", "do_im", "[", "idx", "]", ".", "shape", ")", "==", "crop_transfrom_size", "\n", "assert", "list", "(", "do_seg", "[", "idx", "]", ".", "shape", ")", "==", "crop_transfrom_size", "\n", "# Check metadata", "\n", "assert", "do_metadata", "[", "idx", "]", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "crop_transform", ".", "__class__", ".", "__name__", "]", "==", "do_seg_metadata", "[", "idx", "]", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "crop_transform", ".", "__class__", ".", "__name__", "]", "\n", "\n", "# Apply undo transform", "\n", "", "undo_im", ",", "_", "=", "crop_transform", ".", "undo_transform", "(", "do_im", ",", "do_metadata", ")", "\n", "undo_seg", ",", "_", "=", "crop_transform", ".", "undo_transform", "(", "do_seg", ",", "do_seg_metadata", ")", "\n", "\n", "# Check data type and shape", "\n", "_check_dtype", "(", "im", ",", "[", "undo_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "undo_im", "]", ")", "\n", "_check_dtype", "(", "seg", ",", "[", "undo_seg", "]", ")", "\n", "_check_shape", "(", "seg", ",", "[", "undo_seg", "]", ")", "\n", "\n", "# Loop and check", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "im", ")", ":", "\n", "# Check data consistency", "\n", "        ", "fh", ",", "fw", ",", "fd", ",", "_", ",", "_", ",", "_", "=", "do_metadata", "[", "idx", "]", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "crop_transform", ".", "__class__", ".", "__name__", "]", "\n", "th", ",", "tw", ",", "td", "=", "crop_transform", ".", "size", "\n", "if", "not", "td", ":", "\n", "            ", "assert", "np", ".", "array_equal", "(", "i", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", "]", ",", "undo_im", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "seg", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", "]", ",", "undo_seg", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", "]", ")", "\n", "# Plot for debugging", "\n", "if", "DEBUGGING", ":", "\n", "                ", "plot_transformed_sample", "(", "seg", "[", "idx", "]", ",", "undo_seg", "[", "idx", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "plot_transformed_sample", "(", "i", ",", "undo_im", "[", "idx", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "assert", "np", ".", "array_equal", "(", "i", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", "fd", ":", "fd", "+", "td", "]", ",", "\n", "undo_im", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", "fd", ":", "fd", "+", "td", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "seg", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", "fd", ":", "fd", "+", "td", "]", ",", "\n", "undo_seg", "[", "idx", "]", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", "fd", ":", "fd", "+", "td", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_Crop_2D": [[294, 301], ["pytest.mark.parametrize", "pytest.mark.parametrize", "test_transforms._test_Crop", "test_transforms.create_test_image", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.ROICrop", "ivadomed.transforms.ROICrop"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Crop", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "2", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'crop_transform'", ",", "[", "CenterCrop", "(", "[", "80", ",", "60", "]", ")", ",", "\n", "CenterCrop", "(", "[", "60", ",", "80", "]", ")", ",", "\n", "ROICrop", "(", "[", "80", ",", "60", "]", ")", ",", "\n", "ROICrop", "(", "[", "60", ",", "80", "]", ")", "]", ")", "\n", "def", "test_Crop_2D", "(", "im_seg", ",", "crop_transform", ")", ":", "\n", "    ", "_test_Crop", "(", "im_seg", ",", "crop_transform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_Crop_3D": [[303, 310], ["pytest.mark.parametrize", "pytest.mark.parametrize", "test_transforms._test_Crop", "test_transforms.create_test_image", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.CenterCrop", "ivadomed.transforms.ROICrop", "ivadomed.transforms.ROICrop"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._test_Crop", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'crop_transform'", ",", "[", "CenterCrop", "(", "[", "80", ",", "60", ",", "40", "]", ")", ",", "\n", "CenterCrop", "(", "[", "60", ",", "80", ",", "50", "]", ")", ",", "\n", "ROICrop", "(", "[", "80", ",", "60", ",", "40", "]", ")", ",", "\n", "ROICrop", "(", "[", "60", ",", "80", ",", "50", "]", ")", "]", ")", "\n", "def", "test_Crop_3D", "(", "im_seg", ",", "crop_transform", ")", ":", "\n", "    ", "_test_Crop", "(", "im_seg", ",", "crop_transform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_RandomAffine": [[312, 352], ["pytest.mark.parametrize", "pytest.mark.parametrize", "transform", "transform", "transform.undo_transform", "transform.undo_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "test_transforms._check_dtype", "test_transforms._check_shape", "enumerate", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "seg.copy", "plot_transformed_sample", "plot_transformed_sample", "plot_transformed_sample", "plot_transformed_sample", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.transforms.RandomAffine", "ivadomed.transforms.RandomAffine", "ivadomed.transforms.RandomAffine", "ivadomed.transforms.RandomAffine", "ivadomed.transforms.RandomAffine", "ivadomed.loader.sample_meta_data.SampleMetadata", "len", "len", "ivadomed.metrics.dice_score"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transform'", ",", "[", "RandomAffine", "(", "degrees", "=", "180", ")", ",", "\n", "RandomAffine", "(", "degrees", "=", "(", "5", ",", "180", ")", ")", ",", "\n", "RandomAffine", "(", "translate", "=", "[", "0.1", ",", "0.2", ",", "0", "]", ")", ",", "\n", "RandomAffine", "(", "scale", "=", "[", "0.03", ",", "0.07", ",", "0.0", "]", ")", ",", "\n", "RandomAffine", "(", "translate", "=", "[", "0.1", ",", "0.2", ",", "0.05", "]", ",", "\n", "scale", "=", "[", "0.05", ",", "0.05", ",", "0", "]", ",", "\n", "degrees", "=", "5", ")", "]", ")", "\n", "def", "test_RandomAffine", "(", "im_seg", ",", "transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_im", ",", "metadata_do", "=", "transform", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "do_seg", ",", "metadata_do", "=", "transform", "(", "seg", ".", "copy", "(", ")", ",", "metadata_do", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "im", "[", "0", "]", ",", "do_im", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "do_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "\n", "# Transform on Numpy", "\n", "", "undo_im", ",", "_", "=", "transform", ".", "undo_transform", "(", "do_im", ",", "metadata_do", ")", "\n", "undo_seg", ",", "_", "=", "transform", ".", "undo_transform", "(", "do_seg", ",", "metadata_do", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "# TODO: ERROR for image but not for seg.....", "\n", "        ", "plot_transformed_sample", "(", "im", "[", "0", "]", ",", "undo_im", "[", "0", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "undo_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "\n", "# Check data type and shape", "\n", "", "_check_dtype", "(", "im", ",", "[", "do_im", ",", "undo_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "do_im", ",", "undo_im", "]", ")", "\n", "_check_dtype", "(", "seg", ",", "[", "undo_seg", ",", "do_seg", "]", ")", "\n", "_check_shape", "(", "seg", ",", "[", "undo_seg", ",", "do_seg", "]", ")", "\n", "\n", "# Loop and check", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "im", ")", ":", "\n", "# Data consistency", "\n", "        ", "assert", "dice_score", "(", "undo_seg", "[", "idx", "]", ",", "seg", "[", "idx", "]", ")", ">", "0.85", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_ElasticTransform": [[354, 374], ["pytest.mark.parametrize", "pytest.mark.parametrize", "elastic_transform", "elastic_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "test_transforms._check_dtype", "test_transforms._check_shape", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "seg.copy", "plot_transformed_sample", "plot_transformed_sample", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.transforms.ElasticTransform", "ivadomed.loader.sample_meta_data.SampleMetadata", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'elastic_transform'", ",", "[", "ElasticTransform", "(", "alpha_range", "=", "[", "150.0", ",", "250.0", "]", ",", "\n", "sigma_range", "=", "[", "100", "*", "0.06", ",", "100", "*", "0.09", "]", ")", "]", ")", "\n", "def", "test_ElasticTransform", "(", "im_seg", ",", "elastic_transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_im", ",", "metadata_do", "=", "elastic_transform", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "do_seg", ",", "metadata_do", "=", "elastic_transform", "(", "seg", ".", "copy", "(", ")", ",", "metadata_do", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "im", "[", "0", "]", ",", "do_im", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "do_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "\n", "", "_check_dtype", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_dtype", "(", "seg", ",", "[", "do_seg", "]", ")", "\n", "_check_shape", "(", "seg", ",", "[", "do_seg", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_DilateGT": [[376, 398], ["pytest.mark.parametrize", "pytest.mark.parametrize", "dilate_transform", "test_transforms._check_shape", "enumerate", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "seg.copy", "plot_transformed_sample", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.transforms.DilateGT", "ivadomed.loader.sample_meta_data.SampleMetadata", "len", "numpy.sum", "numpy.sum", "scipy.ndimage.label", "scipy.ndimage.label"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'dilate_transform'", ",", "[", "DilateGT", "(", "dilation_factor", "=", "0.3", ")", "]", ")", "\n", "def", "test_DilateGT", "(", "im_seg", ",", "dilate_transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_seg", ",", "metadata_do", "=", "dilate_transform", "(", "seg", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "do_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "\n", "# Check data shape and type", "\n", "", "_check_shape", "(", "ref", "=", "seg", ",", "list_mov", "=", "[", "do_seg", "]", ")", "\n", "\n", "# Check data augmentation", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "seg", ")", ":", "\n", "# data aug", "\n", "        ", "assert", "np", ".", "sum", "(", "(", "do_seg", "[", "idx", "]", ">", "0", ")", ".", "astype", "(", "int", ")", ")", ">=", "np", ".", "sum", "(", "i", ")", "\n", "# same number of objects", "\n", "assert", "label", "(", "(", "do_seg", "[", "idx", "]", ">", "0", ")", ".", "astype", "(", "int", ")", ")", "[", "1", "]", "==", "label", "(", "i", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_RandomReverse": [[400, 423], ["pytest.mark.parametrize", "pytest.mark.parametrize", "reverse_transform", "reverse_transform", "reverse_transform.undo_transform", "reverse_transform.undo_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "test_transforms._check_dtype", "test_transforms._check_shape", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "seg.copy", "plot_transformed_sample", "plot_transformed_sample", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.transforms.RandomReverse", "ivadomed.loader.sample_meta_data.SampleMetadata", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'reverse_transform'", ",", "[", "RandomReverse", "(", ")", "]", ")", "\n", "def", "test_RandomReverse", "(", "im_seg", ",", "reverse_transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_im", ",", "metadata_do", "=", "reverse_transform", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "do_seg", ",", "metadata_do", "=", "reverse_transform", "(", "seg", ".", "copy", "(", ")", ",", "metadata_do", ")", "\n", "\n", "# Transform on Numpy", "\n", "undo_im", ",", "_", "=", "reverse_transform", ".", "undo_transform", "(", "do_im", ",", "metadata_do", ")", "\n", "undo_seg", ",", "_", "=", "reverse_transform", ".", "undo_transform", "(", "do_seg", ",", "metadata_do", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "do_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "plot_transformed_sample", "(", "seg", "[", "0", "]", ",", "undo_seg", "[", "0", "]", ",", "[", "'raw'", ",", "'undo'", "]", ")", "\n", "\n", "", "_check_dtype", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_dtype", "(", "seg", ",", "[", "do_seg", "]", ")", "\n", "_check_shape", "(", "seg", ",", "[", "do_seg", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_AdditiveGaussianNoise": [[425, 440], ["pytest.mark.parametrize", "pytest.mark.parametrize", "noise_transform", "test_transforms._check_dtype", "test_transforms._check_shape", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "plot_transformed_sample", "test_transforms.create_test_image", "test_transforms.create_test_image", "ivadomed.transforms.AdditiveGaussianNoise", "ivadomed.loader.sample_meta_data.SampleMetadata", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", ",", "\n", "create_test_image", "(", "100", ",", "100", ",", "100", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'noise_transform'", ",", "[", "AdditiveGaussianNoise", "(", "mean", "=", "1.", ",", "std", "=", "0.01", ")", "]", ")", "\n", "def", "test_AdditiveGaussianNoise", "(", "im_seg", ",", "noise_transform", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_im", ",", "metadata_do", "=", "noise_transform", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "\n", "_check_dtype", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "do_im", "]", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "im", "[", "0", "]", ",", "do_im", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.test_Clahe": [[442, 456], ["pytest.mark.parametrize", "pytest.mark.parametrize", "clahe", "test_transforms._check_dtype", "test_transforms._check_shape", "isinstance", "ivadomed.loader.sample_meta_data.SampleMetadata", "im.copy", "plot_transformed_sample", "test_transforms.create_test_image", "ivadomed.transforms.Clahe", "ivadomed.loader.sample_meta_data.SampleMetadata", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms.create_test_image"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'im_seg'", ",", "[", "create_test_image", "(", "100", ",", "100", ",", "0", ",", "1", ",", "rad_max", "=", "10", ")", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'clahe'", ",", "[", "Clahe", "(", "kernel_size", "=", "(", "8", ",", "8", ")", ")", "]", ")", "\n", "def", "test_Clahe", "(", "im_seg", ",", "clahe", ")", ":", "\n", "    ", "im", ",", "seg", "=", "im_seg", "\n", "metadata_in", "=", "[", "SampleMetadata", "(", "{", "}", ")", "for", "_", "in", "im", "]", "if", "isinstance", "(", "im", ",", "list", ")", "else", "SampleMetadata", "(", "{", "}", ")", "\n", "\n", "# Transform on Numpy", "\n", "do_im", ",", "metadata_do", "=", "clahe", "(", "im", ".", "copy", "(", ")", ",", "metadata_in", ")", "\n", "\n", "_check_dtype", "(", "im", ",", "[", "do_im", "]", ")", "\n", "_check_shape", "(", "im", ",", "[", "do_im", "]", ")", "\n", "\n", "if", "DEBUGGING", "and", "len", "(", "im", "[", "0", "]", ".", "shape", ")", "==", "2", ":", "\n", "        ", "plot_transformed_sample", "(", "im", "[", "0", "]", ",", "do_im", "[", "0", "]", ",", "[", "'raw'", ",", "'do'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_shape": [[458, 464], ["enumerate"], "function", ["None"], ["", "", "def", "_check_shape", "(", "ref", ",", "list_mov", ")", ":", "\n", "# Loop and check", "\n", "    ", "for", "mov", "in", "list_mov", ":", "\n", "        ", "for", "idx", ",", "i", "in", "enumerate", "(", "ref", ")", ":", "\n", "# Check data shape", "\n", "            ", "assert", "mov", "[", "idx", "]", ".", "shape", "==", "i", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transforms._check_dtype": [[466, 472], ["enumerate"], "function", ["None"], ["", "", "", "def", "_check_dtype", "(", "ref", ",", "list_mov", ")", ":", "\n", "# Loop and check", "\n", "    ", "for", "mov", "in", "list_mov", ":", "\n", "        ", "for", "idx", ",", "i", "in", "enumerate", "(", "ref", ")", ":", "\n", "# Check data type", "\n", "            ", "assert", "mov", "[", "idx", "]", ".", "dtype", "==", "i", ".", "dtype", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_patch_filter.setup_function": [[20, 22], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_patch_filter._cmpt_slice": [[24, 35], ["enumerate", "loguru.logger.debug", "numpy.any", "gt.numpy", "ivadomed.loader.loader"], "function", ["None"], ["", "def", "_cmpt_slice", "(", "ds_loader", ")", ":", "\n", "    ", "cmpt_label", "=", "{", "0", ":", "0", ",", "1", ":", "0", "}", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "ds_loader", ")", ":", "\n", "        ", "for", "gt", "in", "batch", "[", "'gt'", "]", ":", "\n", "# TODO: multi label", "\n", "            ", "if", "np", ".", "any", "(", "gt", ".", "numpy", "(", ")", ")", ":", "\n", "                ", "cmpt_label", "[", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                ", "cmpt_label", "[", "0", "]", "+=", "1", "\n", "", "", "", "logger", ".", "debug", "(", "cmpt_label", ")", "\n", "return", "cmpt_label", "[", "0", "]", ",", "cmpt_label", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_patch_filter.test_patch_filter": [[37, 89], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "loguru.logger.info", "torch.utils.data.DataLoader", "loguru.logger.info", "test_patch_filter._cmpt_slice", "os.path.join", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter._cmpt_slice"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "{", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "128", ",", "128", "]", ",", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", "}", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'train_lst'", ",", "[", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_seg-axon-manual\"", ",", "\"_seg-myelin-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'patch_filter_params'", ",", "[", "\n", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "{", "\"filter_empty_mask\"", ":", "True", ",", "\"filter_empty_input\"", ":", "True", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'dataset_type'", ",", "[", "\"training\"", ",", "\"testing\"", "]", ")", "\n", "def", "test_patch_filter", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "train_lst", ",", "target_lst", ",", "patch_filter_params", ",", "\n", "dataset_type", ")", ":", "\n", "\n", "    ", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "train_lst", ",", "\n", "\"dataset_type\"", ":", "dataset_type", ",", "\n", "\"requires_undo\"", ":", "False", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'SEM'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "os", ".", "path", ".", "join", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", ",", "\"length_2D\"", ":", "[", "32", ",", "32", "]", ",", "\"stride_2D\"", ":", "[", "32", ",", "32", "]", "}", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"patch_filter_params\"", ":", "patch_filter_params", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "# Get Training dataset", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "\n", "logger", ".", "info", "(", "f\"\\tNumber of loaded patches: {len(ds)}\"", ")", "\n", "\n", "loader", "=", "DataLoader", "(", "ds", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "logger", ".", "info", "(", "\"\\tNumber of Neg/Pos patches in GT.\"", ")", "\n", "cmpt_neg", ",", "cmpt_pos", "=", "_cmpt_slice", "(", "loader", ")", "\n", "if", "patch_filter_params", "[", "\"filter_empty_mask\"", "]", ":", "\n", "        ", "if", "dataset_type", "==", "\"testing\"", ":", "\n", "# Filters on patches are not applied at testing time", "\n", "            ", "assert", "cmpt_neg", "+", "cmpt_pos", "==", "len", "(", "ds", ")", "\n", "", "else", ":", "\n", "# Filters on patches are applied at training time", "\n", "            ", "assert", "cmpt_neg", "==", "0", "\n", "assert", "cmpt_pos", "!=", "0", "\n", "", "", "else", ":", "\n", "# We verify if there are still some negative patches (they are removed with our filter)", "\n", "        ", "assert", "cmpt_neg", "!=", "0", "and", "cmpt_pos", "!=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_patch_filter.teardown_function": [[91, 93], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.setup_function": [[17, 19], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.load_dataset": [[21, 33], ["test_split_dataset.create_tsvfile", "test_split_dataset.create_jsonfile", "pandas.read_csv", "ivadomed.loader.utils.get_subdatasets_subject_files_list", "PATH_LOG.is_dir", "PATH_LOG.mkdir", "pathlib.Path", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.create_tsvfile", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.create_jsonfile", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_subdatasets_subject_files_list"], ["", "def", "load_dataset", "(", "split_params", ")", ":", "\n", "    ", "patient_mapping", "=", "create_tsvfile", "(", ")", "\n", "create_jsonfile", "(", ")", "\n", "\n", "# Create log path", "\n", "if", "not", "PATH_LOG", ".", "is_dir", "(", ")", ":", "\n", "        ", "PATH_LOG", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "df", "=", "pd", ".", "read_csv", "(", "Path", "(", "PATH_DATA", ",", "\"participants.tsv\"", ")", ",", "sep", "=", "'\\t'", ")", "\n", "df", "[", "'filename'", "]", "=", "df", "[", "\"participant_id\"", "]", "\n", "train", ",", "val", ",", "test", "=", "imed_loader_utils", ".", "get_subdatasets_subject_files_list", "(", "split_params", ",", "df", ",", "str", "(", "PATH_LOG", ")", ")", "\n", "return", "train", ",", "val", ",", "test", ",", "patient_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_center_testcenter_0": [[35, 52], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "len", "round"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "\"institution_id\"", ",", "\"data_value\"", ":", "[", "0", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.6", ",", "\n", "\"test_fraction\"", ":", "0.2", "\n", "}", "]", ")", "\n", "def", "test_per_center_testcenter_0", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "# Verify split proportion", "\n", "assert", "len", "(", "train", ")", "==", "round", "(", "0.6", "*", "N", ")", "\n", "\n", "# Verify there is only the test center selected", "\n", "for", "sub", "in", "test", ":", "\n", "        ", "assert", "patient_mapping", "[", "sub", "]", "[", "'center'", "]", "==", "'0'", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_center_without_testcenter": [[54, 79], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "set", "set", "set.add", "set.add", "len", "round"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "\"institution_id\"", ",", "\"data_value\"", ":", "[", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.2", ",", "\n", "\"test_fraction\"", ":", "0.4", "\n", "}", "]", ")", "\n", "def", "test_per_center_without_testcenter", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "test_centers", "=", "set", "(", ")", "\n", "for", "sub", "in", "test", ":", "\n", "        ", "test_centers", ".", "add", "(", "patient_mapping", "[", "sub", "]", "[", "'center'", "]", ")", "\n", "\n", "", "training_centers", "=", "set", "(", ")", "\n", "for", "sub", "in", "train", ":", "\n", "        ", "training_centers", ".", "add", "(", "patient_mapping", "[", "sub", "]", "[", "'center'", "]", ")", "\n", "\n", "# Verify the test center proportion", "\n", "", "assert", "len", "(", "test_centers", ")", "==", "round", "(", "N_CENTERS", "*", "0.4", ")", "\n", "\n", "# Verify test and training centers are fully different", "\n", "for", "train_center", "in", "training_centers", ":", "\n", "        ", "assert", "train_center", "not", "in", "test_centers", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_patient": [[81, 94], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "numpy.isclose", "numpy.isclose", "len", "round", "len", "round"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "None", ",", "\"data_value\"", ":", "[", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.45", ",", "\n", "\"test_fraction\"", ":", "0.35", "\n", "}", "]", ")", "\n", "def", "test_per_patient", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "train", ")", ",", "round", "(", "N", "*", "0.45", ")", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "test", ")", ",", "round", "(", "N", "*", "0.35", ")", ",", "atol", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_patient_2": [[96, 110], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "numpy.isclose", "numpy.isclose", "numpy.isclose", "len", "round", "len", "round", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "None", ",", "\"data_value\"", ":", "[", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.6", ",", "\n", "\"test_fraction\"", ":", "0", "\n", "}", "]", ")", "\n", "def", "test_per_patient_2", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "train", ")", ",", "round", "(", "N", "*", "0.6", ")", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "val", ")", ",", "round", "(", "N", "*", "0.4", ")", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "test", ")", ",", "0", ",", "atol", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.check_balance": [[112, 121], ["numpy.isclose", "numpy.isclose", "numpy.isclose"], "function", ["None"], ["", "def", "check_balance", "(", "train", ",", "val", ",", "test", ",", "patient_mapping", ")", ":", "\n", "    ", "for", "dataset", "in", "[", "train", ",", "val", ",", "test", "]", ":", "\n", "        ", "disability_count", "=", "{", "'0'", ":", "0", ",", "'1'", ":", "0", ",", "'2'", ":", "0", "}", "\n", "for", "sub", "in", "dataset", ":", "\n", "            ", "disability_count", "[", "patient_mapping", "[", "sub", "]", "[", "'disability'", "]", "]", "+=", "1", "\n", "\n", "", "assert", "np", ".", "isclose", "(", "disability_count", "[", "'0'", "]", ",", "disability_count", "[", "'1'", "]", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "disability_count", "[", "'1'", "]", ",", "disability_count", "[", "'2'", "]", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "disability_count", "[", "'0'", "]", ",", "disability_count", "[", "'2'", "]", ",", "atol", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_patient_balance": [[123, 139], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "numpy.isclose", "numpy.isclose", "test_split_dataset.check_balance", "len", "round", "len", "round"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.check_balance"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"center_test\"", ":", "[", "]", ",", "\n", "\"balance\"", ":", "\"disability\"", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "None", ",", "\"data_value\"", ":", "[", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.45", ",", "\n", "\"test_fraction\"", ":", "0.35", "\n", "}", "]", ")", "\n", "def", "test_per_patient_balance", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "train", ")", ",", "round", "(", "N", "*", "0.45", ")", ",", "atol", "=", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "test", ")", ",", "round", "(", "N", "*", "0.35", ")", ",", "atol", "=", "1", ")", "\n", "check_balance", "(", "train", ",", "val", ",", "test", ",", "patient_mapping", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.test_per_center_balance": [[141, 161], ["pytest.mark.parametrize", "test_split_dataset.load_dataset", "numpy.isclose", "test_split_dataset.check_balance", "len", "round"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.check_balance"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'split_params'", ",", "[", "{", "\n", "\"fname_split\"", ":", "None", ",", "\n", "\"random_seed\"", ":", "6", ",", "\n", "\"balance\"", ":", "\"disability\"", ",", "\n", "\"split_method\"", ":", "\"participant_id\"", ",", "\n", "\"data_testing\"", ":", "{", "\"data_type\"", ":", "\"institution_id\"", ",", "\"data_value\"", ":", "[", "0", "]", "}", ",", "\n", "\"train_fraction\"", ":", "0.4", ",", "\n", "\"test_fraction\"", ":", "0.2", "\n", "}", "]", ")", "\n", "def", "test_per_center_balance", "(", "split_params", ")", ":", "\n", "    ", "train", ",", "val", ",", "test", ",", "patient_mapping", "=", "load_dataset", "(", "split_params", ")", "\n", "\n", "# Verify split proportion", "\n", "assert", "np", ".", "isclose", "(", "len", "(", "train", ")", ",", "round", "(", "0.4", "*", "N", ")", ",", "atol", "=", "2", ")", "\n", "\n", "# Verify there is only the test center selected", "\n", "for", "sub", "in", "test", ":", "\n", "        ", "assert", "patient_mapping", "[", "sub", "]", "[", "'center'", "]", "==", "'0'", "\n", "\n", "", "check_balance", "(", "train", ",", "val", ",", "test", ",", "patient_mapping", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.create_tsvfile": [[163, 194], ["range", "PATH_DATA.is_dir", "PATH_DATA.mkdir", "row_participants.append", "str", "row_participants.append", "str", "row_participants.append", "participants.append", "pathlib.Path().open", "csv.writer", "csv.writer.writerow", "sorted", "str", "csv.writer.writerow", "pathlib.Path"], "function", ["None"], ["", "def", "create_tsvfile", "(", ")", ":", "\n", "# Create data path", "\n", "    ", "if", "not", "PATH_DATA", ".", "is_dir", "(", ")", ":", "\n", "        ", "PATH_DATA", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "patient_mapping", "=", "{", "}", "\n", "\n", "# Create participants.tsv with n participants", "\n", "participants", "=", "[", "]", "\n", "for", "participant_id", "in", "range", "(", "N", ")", ":", "\n", "        ", "row_participants", "=", "[", "]", "\n", "patient_id", "=", "'sub-00'", "+", "str", "(", "participant_id", ")", "\n", "row_participants", ".", "append", "(", "patient_id", ")", "\n", "# 3 different disabilities: 0, 1, or 2", "\n", "disability_id", "=", "str", "(", "participant_id", "%", "3", ")", "\n", "row_participants", ".", "append", "(", "disability_id", ")", "\n", "# N_CENTERS different centers: 0, 1, ..., or N_CENTERS", "\n", "center_id", "=", "str", "(", "participant_id", "%", "N_CENTERS", ")", "\n", "row_participants", ".", "append", "(", "center_id", ")", "\n", "patient_mapping", "[", "patient_id", "]", "=", "{", "}", "\n", "patient_mapping", "[", "patient_id", "]", "[", "'disability'", "]", "=", "disability_id", "\n", "patient_mapping", "[", "patient_id", "]", "[", "'center'", "]", "=", "center_id", "\n", "participants", ".", "append", "(", "row_participants", ")", "\n", "\n", "", "with", "Path", "(", "PATH_DATA", ",", "\"participants.tsv\"", ")", ".", "open", "(", "mode", "=", "'w'", ")", "as", "tsv_file", ":", "\n", "        ", "tsv_writer", "=", "csv", ".", "writer", "(", "tsv_file", ",", "delimiter", "=", "'\\t'", ",", "lineterminator", "=", "'\\n'", ")", "\n", "tsv_writer", ".", "writerow", "(", "[", "\"participant_id\"", ",", "\"disability\"", ",", "\"institution_id\"", "]", ")", "\n", "for", "item", "in", "sorted", "(", "participants", ")", ":", "\n", "            ", "tsv_writer", ".", "writerow", "(", "item", ")", "\n", "\n", "", "", "return", "patient_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.create_jsonfile": [[196, 206], ["pathlib.Path().open", "outfile.write", "outfile.close", "json.dumps", "pathlib.Path"], "function", ["None"], ["", "def", "create_jsonfile", "(", ")", ":", "\n", "    ", "\"\"\"Create dataset_description.json.\"\"\"", "\n", "\n", "dataset_description", "=", "{", "}", "\n", "dataset_description", "[", "u'Name'", "]", "=", "'Test'", "\n", "dataset_description", "[", "u'BIDSVersion'", "]", "=", "'1.2.1'", "\n", "\n", "with", "Path", "(", "PATH_DATA", ",", "\"dataset_description.json\"", ")", ".", "open", "(", "mode", "=", "'w'", ")", "as", "outfile", ":", "\n", "        ", "outfile", ".", "write", "(", "json", ".", "dumps", "(", "dataset_description", ",", "indent", "=", "2", ",", "sort_keys", "=", "True", ")", ")", "\n", "outfile", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_split_dataset.teardown_function": [[208, 210], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_orientation.setup_function": [[23, 25], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_orientation.test_image_orientation": [[27, 165], ["pytest.mark.parametrize", "torch.device", "torch.cuda.is_available", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.transforms.prepare_transforms", "torch.cuda.set_device", "loguru.logger.info", "torch.cuda.is_available", "torch.utils.data.DataLoader", "ivadomed.loader.segmentation_pair.SegmentationPair", "nibabel.load", "nib.load.get_fdata", "nibabel.as_closest_canonical().get_fdata", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_data", "enumerate", "str", "ivadomed.loader.bids_dataset.BidsDataset", "ivadomed.loader.bids3d_dataset.Bids3DDataset.load_filenames", "ivadomed.loader.bids3d_dataset.Bids3DDataset", "range", "nibabel.as_closest_canonical", "len", "training_undo_transform", "pred_tmp_lst.append", "z_tmp_lst.append", "training_undo_transform", "nibabel.load", "nibabel.as_closest_canonical", "ivadomed.postprocessing.threshold_predictions", "ivadomed.loader.utils.orient_img_ras", "ivadomed.loader.utils.reorient_image", "int", "range", "numpy.stack", "numpy.array", "ivadomed.metrics.dice_score", "ivadomed.metrics.dice_score", "ivadomed.metrics.dice_score", "tmp_lst.append", "len", "nib.as_closest_canonical.header.get_data_shape", "z_tmp_lst.index"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.prepare_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_ras", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T1w'", "]", ",", "\"balance\"", ":", "{", "}", "}", "\n", "}", "]", ")", "\n", "def", "test_image_orientation", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "device", "=", "torch", ".", "device", "(", "\"cuda:\"", "+", "str", "(", "GPU_ID", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "if", "cuda_available", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "device", ")", "\n", "logger", ".", "info", "(", "f\"Using GPU ID {device}\"", ")", "\n", "\n", "", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "contrast_params", "=", "loader_parameters", "[", "\"contrast_params\"", "]", "\n", "target_suffix", "=", "loader_parameters", "[", "\"target_suffix\"", "]", "\n", "roi_params", "=", "loader_parameters", "[", "\"roi_params\"", "]", "\n", "\n", "train_lst", "=", "[", "'sub-unf01_T1w.nii.gz'", "]", "\n", "\n", "training_transform_dict", "=", "{", "\n", "\"Resample\"", ":", "\n", "{", "\n", "\"wspace\"", ":", "1.5", ",", "\n", "\"hspace\"", ":", "1", ",", "\n", "\"dspace\"", ":", "3", "\n", "}", ",", "\n", "\"CenterCrop\"", ":", "\n", "{", "\n", "\"size\"", ":", "[", "176", ",", "128", ",", "160", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "'im'", "]", "}", "\n", "}", "\n", "\n", "tranform_lst", ",", "training_undo_transform", "=", "imed_transforms", ".", "prepare_transforms", "(", "training_transform_dict", ")", "\n", "\n", "model_params", "=", "{", "\n", "\"name\"", ":", "\"Modified3DUNet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.9", ",", "\n", "\"depth\"", ":", "2", ",", "\n", "\"in_channel\"", ":", "1", ",", "\n", "\"out_channel\"", ":", "1", ",", "\n", "\"length_3D\"", ":", "[", "176", ",", "128", ",", "160", "]", ",", "\n", "\"stride_3D\"", ":", "[", "176", ",", "128", ",", "160", "]", ",", "\n", "\"attention\"", ":", "False", ",", "\n", "\"n_filters\"", ":", "8", "\n", "}", "\n", "\n", "for", "dim", "in", "[", "'2d'", ",", "'3d'", "]", ":", "\n", "        ", "for", "slice_axis", "in", "[", "0", ",", "1", ",", "2", "]", ":", "\n", "            ", "if", "dim", "==", "'2d'", ":", "\n", "                ", "ds", "=", "BidsDataset", "(", "bids_df", "=", "bids_df", ",", "\n", "subject_file_lst", "=", "train_lst", ",", "\n", "target_suffix", "=", "target_suffix", ",", "\n", "contrast_params", "=", "contrast_params", ",", "\n", "model_params", "=", "model_params", ",", "\n", "metadata_choice", "=", "False", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "multichannel", "=", "False", ")", "\n", "ds", ".", "load_filenames", "(", ")", "\n", "", "else", ":", "\n", "                ", "ds", "=", "Bids3DDataset", "(", "bids_df", "=", "bids_df", ",", "\n", "subject_file_lst", "=", "train_lst", ",", "\n", "target_suffix", "=", "target_suffix", ",", "\n", "model_params", "=", "model_params", ",", "\n", "contrast_params", "=", "contrast_params", ",", "\n", "metadata_choice", "=", "False", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "multichannel", "=", "False", ")", "\n", "\n", "", "loader", "=", "DataLoader", "(", "ds", ",", "batch_size", "=", "1", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "1", ")", "\n", "\n", "input_filename", ",", "gt_filename", ",", "roi_filename", ",", "metadata", "=", "ds", ".", "filename_pairs", "[", "0", "]", "\n", "segpair", "=", "SegmentationPair", "(", "input_filename", ",", "gt_filename", ",", "metadata", "=", "metadata", ",", "\n", "slice_axis", "=", "slice_axis", ")", "\n", "nib_original", "=", "nib", ".", "load", "(", "gt_filename", "[", "0", "]", ")", "\n", "# Get image with original, ras and hwd orientations", "\n", "input_init", "=", "nib_original", ".", "get_fdata", "(", ")", "\n", "input_ras", "=", "nib", ".", "as_closest_canonical", "(", "nib_original", ")", ".", "get_fdata", "(", ")", "\n", "img", ",", "gt", "=", "segpair", ".", "get_pair_data", "(", ")", "\n", "input_hwd", "=", "gt", "[", "0", "]", "\n", "\n", "pred_tmp_lst", ",", "z_tmp_lst", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "loader", ")", ":", "\n", "# batch[\"input_metadata\"] = batch[\"input_metadata\"][0]  # Take only metadata from one input", "\n", "# batch[\"gt_metadata\"] = batch[\"gt_metadata\"][0]  # Take only metadata from one label", "\n", "\n", "                ", "for", "smp_idx", "in", "range", "(", "len", "(", "batch", "[", "'gt'", "]", ")", ")", ":", "\n", "# undo transformations", "\n", "                    ", "if", "dim", "==", "'2d'", ":", "\n", "                        ", "preds_idx_undo", ",", "metadata_idx", "=", "training_undo_transform", "(", "batch", "[", "\"gt\"", "]", "[", "smp_idx", "]", ",", "\n", "batch", "[", "\"gt_metadata\"", "]", "[", "smp_idx", "]", ",", "\n", "data_type", "=", "'gt'", ")", "\n", "\n", "# add new sample to pred_tmp_lst", "\n", "pred_tmp_lst", ".", "append", "(", "preds_idx_undo", "[", "0", "]", ")", "\n", "z_tmp_lst", ".", "append", "(", "int", "(", "batch", "[", "'input_metadata'", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'slice_index'", "]", ")", ")", "\n", "\n", "", "else", ":", "\n", "                        ", "preds_idx_undo", ",", "metadata_idx", "=", "training_undo_transform", "(", "batch", "[", "\"gt\"", "]", "[", "smp_idx", "]", ",", "\n", "batch", "[", "\"gt_metadata\"", "]", "[", "smp_idx", "]", ",", "\n", "data_type", "=", "'gt'", ")", "\n", "\n", "", "fname_ref", "=", "metadata_idx", "[", "0", "]", "[", "'gt_filenames'", "]", "[", "0", "]", "\n", "\n", "if", "(", "pred_tmp_lst", "and", "i", "==", "len", "(", "loader", ")", "-", "1", ")", "or", "dim", "==", "'3d'", ":", "\n", "# save the completely processed file as a nii", "\n", "                        ", "nib_ref", "=", "nib", ".", "load", "(", "fname_ref", ")", "\n", "nib_ref_can", "=", "nib", ".", "as_closest_canonical", "(", "nib_ref", ")", "\n", "\n", "if", "dim", "==", "'2d'", ":", "\n", "                            ", "tmp_lst", "=", "[", "]", "\n", "for", "z", "in", "range", "(", "nib_ref_can", ".", "header", ".", "get_data_shape", "(", ")", "[", "slice_axis", "]", ")", ":", "\n", "                                ", "tmp_lst", ".", "append", "(", "pred_tmp_lst", "[", "z_tmp_lst", ".", "index", "(", "z", ")", "]", ")", "\n", "", "arr", "=", "np", ".", "stack", "(", "tmp_lst", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "                            ", "arr", "=", "np", ".", "array", "(", "preds_idx_undo", "[", "0", "]", ")", "\n", "\n", "# verify image after transform, undo transform and 3D reconstruction", "\n", "", "input_hwd_2", "=", "imed_postpro", ".", "threshold_predictions", "(", "arr", ")", "\n", "# Some difference are generated due to transform and undo transform", "\n", "# (e.i. Resample interpolation)", "\n", "assert", "imed_metrics", ".", "dice_score", "(", "input_hwd_2", ",", "input_hwd", ")", ">=", "0.8", "\n", "input_ras_2", "=", "imed_loader_utils", ".", "orient_img_ras", "(", "input_hwd_2", ",", "slice_axis", ")", "\n", "assert", "imed_metrics", ".", "dice_score", "(", "input_ras_2", ",", "input_ras", ")", ">=", "0.8", "\n", "input_init_2", "=", "imed_loader_utils", ".", "reorient_image", "(", "input_hwd_2", ",", "slice_axis", ",", "nib_ref", ",", "nib_ref_can", ")", "\n", "assert", "imed_metrics", ".", "dice_score", "(", "input_init_2", ",", "input_init", ")", ">=", "0.8", "\n", "\n", "# re-init pred_stack_lst", "\n", "pred_tmp_lst", ",", "z_tmp_lst", "=", "[", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_orientation.teardown_function": [[167, 169], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "", "", "", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_testing.setup_function": [[28, 30], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_testing.test_inference": [[32, 124], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "loader_params.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "torch.utils.data.DataLoader", "ivadomed.transforms.UndoCompose", "testing_params.update", "ivadomed.models.Unet", "imed_models.Unet.eval", "ivadomed.metrics.MetricManager", "ivadomed.testing.run_inference", "imed_metrics.MetricManager.", "imed_metrics.MetricManager.get_results", "imed_metrics.MetricManager.reset", "logger.debug", "ivadomed.transforms.Compose", "imed_models.Unet.cuda", "__output_dir__.is_dir", "__output_dir__.mkdir", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.reset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "{", "\n", "\"Resample\"", ":", "{", "\n", "\"wspace\"", ":", "0.75", ",", "\n", "\"hspace\"", ":", "0.75", "\n", "}", ",", "\n", "\"CenterCrop\"", ":", "{", "\n", "\"size\"", ":", "[", "48", ",", "48", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'test_lst'", ",", "[", "[", "'sub-unf01_T2w.nii.gz'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_lesion-manual\"", "]", ",", "[", "\"_seg-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'roi_params'", ",", "[", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'testing_params'", ",", "[", "{", "\n", "\"binarize_prediction\"", ":", "0.5", ",", "\n", "\"uncertainty\"", ":", "{", "\n", "\"applied\"", ":", "False", ",", "\n", "\"epistemic\"", ":", "False", ",", "\n", "\"aleatoric\"", ":", "False", ",", "\n", "\"n_it\"", ":", "0", "\n", "}", "}", "]", ")", "\n", "def", "test_inference", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "test_lst", ",", "target_lst", ",", "roi_params", ",", "testing_params", ")", ":", "\n", "    ", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "model_params", "=", "{", "\"name\"", ":", "\"Unet\"", ",", "\"is_2d\"", ":", "True", "}", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "test_lst", ",", "\n", "\"dataset_type\"", ":", "\"testing\"", ",", "\n", "\"requires_undo\"", ":", "True", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "roi_params", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "SLICE_AXIS", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "loader_params", ".", "update", "(", "{", "\"model_params\"", ":", "model_params", "}", ")", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "# Get Testing dataset", "\n", "ds_test", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "test_loader", "=", "DataLoader", "(", "ds_test", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Undo transform", "\n", "val_undo_transform", "=", "imed_transforms", ".", "UndoCompose", "(", "imed_transforms", ".", "Compose", "(", "transforms_dict", ")", ")", "\n", "\n", "# Update testing_params", "\n", "testing_params", ".", "update", "(", "{", "\n", "\"slice_axis\"", ":", "loader_params", "[", "\"slice_axis\"", "]", ",", "\n", "\"target_suffix\"", ":", "loader_params", "[", "\"target_suffix\"", "]", ",", "\n", "\"undo_transforms\"", ":", "val_undo_transform", "\n", "}", ")", "\n", "\n", "# Model", "\n", "model", "=", "imed_models", ".", "Unet", "(", ")", "\n", "\n", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "metric_fns", "=", "[", "imed_metrics", ".", "dice_score", ",", "\n", "imed_metrics", ".", "hausdorff_score", ",", "\n", "imed_metrics", ".", "precision_score", ",", "\n", "imed_metrics", ".", "recall_score", ",", "\n", "imed_metrics", ".", "specificity_score", ",", "\n", "imed_metrics", ".", "intersection_over_union", ",", "\n", "imed_metrics", ".", "accuracy_score", "]", "\n", "\n", "metric_mgr", "=", "imed_metrics", ".", "MetricManager", "(", "metric_fns", ")", "\n", "\n", "if", "not", "__output_dir__", ".", "is_dir", "(", ")", ":", "\n", "        ", "__output_dir__", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "preds_npy", ",", "gt_npy", "=", "imed_testing", ".", "run_inference", "(", "test_loader", "=", "test_loader", ",", "\n", "model", "=", "model", ",", "\n", "model_params", "=", "model_params", ",", "\n", "testing_params", "=", "testing_params", ",", "\n", "ofolder", "=", "str", "(", "__output_dir__", ")", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "metric_mgr", "(", "preds_npy", ",", "gt_npy", ")", "\n", "metrics_dict", "=", "metric_mgr", ".", "get_results", "(", ")", "\n", "metric_mgr", ".", "reset", "(", ")", "\n", "logger", ".", "debug", "(", "metrics_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_testing.test_inference_2d_microscopy": [[126, 212], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "loader_params.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "torch.utils.data.DataLoader", "ivadomed.transforms.UndoCompose", "testing_params.update", "ivadomed.models.Unet", "imed_models.Unet.eval", "ivadomed.testing.run_inference", "ivadomed.transforms.Compose", "imed_models.Unet.cuda", "__output_dir__.is_dir", "__output_dir__.mkdir", "len", "len", "len", "str", "str", "len", "pathlib.Path", "__output_dir__.iterdir", "x.name.endswith", "__output_dir__.iterdir", "x.name.endswith"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "{", "\n", "\"CenterCrop\"", ":", "{", "\n", "\"size\"", ":", "[", "128", ",", "128", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'test_lst'", ",", "\n", "[", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", ",", "'sub-rat3_ses-02_sample-data10_SEM.png'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_seg-axon-manual\"", ",", "\"_seg-myelin-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'roi_params'", ",", "[", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'testing_params'", ",", "[", "{", "\n", "\"binarize_maxpooling\"", ":", "{", "}", ",", "\n", "\"uncertainty\"", ":", "{", "\n", "\"applied\"", ":", "False", ",", "\n", "\"epistemic\"", ":", "False", ",", "\n", "\"aleatoric\"", ":", "False", ",", "\n", "\"n_it\"", ":", "0", "\n", "}", "}", "]", ")", "\n", "def", "test_inference_2d_microscopy", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "test_lst", ",", "target_lst", ",", "roi_params", ",", "\n", "testing_params", ")", ":", "\n", "    ", "\"\"\"\n    This test checks if the number of NifTI predictions equals the number of test subjects on 2d microscopy data.\n    Used to catch a bug where the last slice of the last volume wasn't appended to the prediction\n    (see: https://github.com/ivadomed/ivadomed/issues/823)\n    Also tests the conversions to PNG predictions when source files are not Nifti and checks if the number of PNG\n    predictions is 2x the number of test subjects (2-class model, outputs 1 PNG per class per subject).\n    \"\"\"", "\n", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "model_params", "=", "{", "\"name\"", ":", "\"Unet\"", ",", "\"is_2d\"", ":", "True", ",", "\"out_channel\"", ":", "3", "}", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "test_lst", ",", "\n", "\"dataset_type\"", ":", "\"testing\"", ",", "\n", "\"requires_undo\"", ":", "True", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'SEM'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "roi_params", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "SLICE_AXIS", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "loader_params", ".", "update", "(", "{", "\"model_params\"", ":", "model_params", "}", ")", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "# Get Testing dataset", "\n", "ds_test", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "test_loader", "=", "DataLoader", "(", "ds_test", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Undo transform", "\n", "val_undo_transform", "=", "imed_transforms", ".", "UndoCompose", "(", "imed_transforms", ".", "Compose", "(", "transforms_dict", ")", ")", "\n", "\n", "# Update testing_params", "\n", "testing_params", ".", "update", "(", "{", "\n", "\"slice_axis\"", ":", "loader_params", "[", "\"slice_axis\"", "]", ",", "\n", "\"target_suffix\"", ":", "loader_params", "[", "\"target_suffix\"", "]", ",", "\n", "\"undo_transforms\"", ":", "val_undo_transform", "\n", "}", ")", "\n", "\n", "# Model", "\n", "model", "=", "imed_models", ".", "Unet", "(", "out_channel", "=", "model_params", "[", "'out_channel'", "]", ")", "\n", "\n", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "if", "not", "__output_dir__", ".", "is_dir", "(", ")", ":", "\n", "        ", "__output_dir__", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "preds_npy", ",", "gt_npy", "=", "imed_testing", ".", "run_inference", "(", "test_loader", "=", "test_loader", ",", "\n", "model", "=", "model", ",", "\n", "model_params", "=", "model_params", ",", "\n", "testing_params", "=", "testing_params", ",", "\n", "ofolder", "=", "str", "(", "__output_dir__", ")", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "assert", "len", "(", "[", "x", "for", "x", "in", "__output_dir__", ".", "iterdir", "(", ")", "if", "x", ".", "name", ".", "endswith", "(", "\".nii.gz\"", ")", "]", ")", "==", "len", "(", "test_lst", ")", "\n", "assert", "len", "(", "[", "x", "for", "x", "in", "__output_dir__", ".", "iterdir", "(", ")", "if", "x", ".", "name", ".", "endswith", "(", "\".png\"", ")", "]", ")", "==", "2", "*", "len", "(", "test_lst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_testing.test_inference_target_suffix": [[214, 307], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "loader_params.update", "pathlib.Path().rglob", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "torch.utils.data.DataLoader", "ivadomed.transforms.UndoCompose", "testing_params.update", "ivadomed.models.Unet", "imed_models.Unet.eval", "ivadomed.testing.run_inference", "__output_dir__.iterdir", "file_path.resolve", "file_path.resolve.rename", "ivadomed.transforms.Compose", "imed_models.Unet.cuda", "__output_dir__.is_dir", "__output_dir__.mkdir", "x.name.endswith", "str", "pathlib.Path", "str().rsplit", "pathlib.Path", "str", "[].endswith", "pathlib.Path", "str", "x.name.rsplit"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "{", "\n", "\"CenterCrop\"", ":", "{", "\n", "\"size\"", ":", "[", "128", ",", "128", "]", "\n", "}", ",", "\n", "\"NormalizeInstance\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", "]", "}", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'test_lst'", ",", "\n", "[", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", ",", "'sub-rat3_ses-02_sample-data10_SEM.png'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_seg-axon_manual\"", ",", "\"_seg-myelin_manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'roi_params'", ",", "[", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'testing_params'", ",", "[", "{", "\n", "\"binarize_maxpooling\"", ":", "{", "}", ",", "\n", "\"uncertainty\"", ":", "{", "\n", "\"applied\"", ":", "False", ",", "\n", "\"epistemic\"", ":", "False", ",", "\n", "\"aleatoric\"", ":", "False", ",", "\n", "\"n_it\"", ":", "0", "\n", "}", "}", "]", ")", "\n", "def", "test_inference_target_suffix", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "test_lst", ",", "target_lst", ",", "roi_params", ",", "\n", "testing_params", ")", ":", "\n", "    ", "\"\"\"\n    This test checks if the filename(s) of the prediction(s) saved as NifTI file(s) in the pred_masks\n    dir conform to the target_suffix or not. Thus, independent of underscore(s) in the target_suffix. As a result,\n    _seg-axon-manual or _seg-axon_manual should yield the same filename(s).\n    (c.f: https://github.com/ivadomed/ivadomed/issues/1135)\n    \"\"\"", "\n", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "model_params", "=", "{", "\"name\"", ":", "\"Unet\"", ",", "\"is_2d\"", ":", "True", ",", "\"out_channel\"", ":", "3", "}", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "test_lst", ",", "\n", "\"dataset_type\"", ":", "\"testing\"", ",", "\n", "\"requires_undo\"", ":", "True", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'SEM'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "roi_params", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "SLICE_AXIS", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "loader_params", ".", "update", "(", "{", "\"model_params\"", ":", "model_params", "}", ")", "\n", "\n", "# restructuring the dataset ", "\n", "gt_path", "=", "f'{loader_params[\"path_data\"][0]}/derivatives/labels/'", "\n", "for", "file_path", "in", "Path", "(", "gt_path", ")", ".", "rglob", "(", "'*.png'", ")", ":", "\n", "      ", "src_filename", "=", "file_path", ".", "resolve", "(", ")", "\n", "dst_filename", "=", "'_'", ".", "join", "(", "str", "(", "src_filename", ")", ".", "rsplit", "(", "'-'", ",", "1", ")", ")", "\n", "src_filename", ".", "rename", "(", "Path", "(", "dst_filename", ")", ")", "\n", "\n", "", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "ds_test", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "test_loader", "=", "DataLoader", "(", "ds_test", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Undo transform", "\n", "val_undo_transform", "=", "imed_transforms", ".", "UndoCompose", "(", "imed_transforms", ".", "Compose", "(", "transforms_dict", ")", ")", "\n", "\n", "# Update testing_params", "\n", "testing_params", ".", "update", "(", "{", "\n", "\"slice_axis\"", ":", "loader_params", "[", "\"slice_axis\"", "]", ",", "\n", "\"target_suffix\"", ":", "loader_params", "[", "\"target_suffix\"", "]", ",", "\n", "\"undo_transforms\"", ":", "val_undo_transform", "\n", "}", ")", "\n", "\n", "# Model", "\n", "model", "=", "imed_models", ".", "Unet", "(", "out_channel", "=", "model_params", "[", "'out_channel'", "]", ")", "\n", "\n", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "if", "not", "__output_dir__", ".", "is_dir", "(", ")", ":", "\n", "        ", "__output_dir__", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "", "preds_npy", ",", "gt_npy", "=", "imed_testing", ".", "run_inference", "(", "test_loader", "=", "test_loader", ",", "\n", "model", "=", "model", ",", "\n", "model_params", "=", "model_params", ",", "\n", "testing_params", "=", "testing_params", ",", "\n", "ofolder", "=", "str", "(", "__output_dir__", ")", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "for", "x", "in", "__output_dir__", ".", "iterdir", "(", ")", ":", "\n", "      ", "if", "x", ".", "name", ".", "endswith", "(", "'_pred.nii.gz'", ")", ":", "\n", "        ", "assert", "x", ".", "name", ".", "rsplit", "(", "'_'", ",", "1", ")", "[", "0", "]", ".", "endswith", "(", "loader_params", "[", "'contrast_params'", "]", "[", "'contrast_lst'", "]", "[", "-", "1", "]", ")", ",", "(", "\n", "'Incompatible filename(s) of the prediction(s) saved as NifTI file(s)!'", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_testing.teardown_function": [[309, 311], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_countception": [[6, 12], ["torch.tensor().float", "ivadomed.Countception", "imed_model.Countception.", "type", "torch.tensor", "range", "range"], "function", ["None"], ["def", "test_countception", "(", ")", ":", "\n", "    ", "a", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "10", ")", "]", "for", "i", "in", "range", "(", "10", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "Countception", "(", "in_channel", "=", "1", ",", "out_channel", "=", "1", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", ")", "==", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_model_3d_att": [[14, 21], ["torch.tensor().float", "ivadomed.Modified3DUNet", "imed_model.Modified3DUNet.", "type", "torch.tensor", "range", "range", "range"], "function", ["None"], ["", "def", "test_model_3d_att", "(", ")", ":", "\n", "# verifying if 3d attention model can be created", "\n", "    ", "a", "=", "[", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "48", ")", "]", "for", "j", "in", "range", "(", "48", ")", "]", "for", "k", "in", "range", "(", "16", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "Modified3DUNet", "(", "in_channel", "=", "1", ",", "out_channel", "=", "1", ",", "attention", "=", "True", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", ")", "==", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_resnet": [[23, 29], ["torch.tensor().float", "ivadomed.ResNet", "imed_model.ResNet.", "type", "torch.tensor", "range", "range"], "function", ["None"], ["", "def", "test_resnet", "(", ")", ":", "\n", "    ", "a", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "100", ")", "]", "for", "i", "in", "range", "(", "100", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "ResNet", "(", "torchvision", ".", "models", ".", "resnet", ".", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", ")", "==", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_densenet": [[31, 37], ["torch.tensor().float", "ivadomed.DenseNet", "imed_model.DenseNet.", "type", "torch.tensor", "range", "range"], "function", ["None"], ["", "def", "test_densenet", "(", ")", ":", "\n", "    ", "a", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "100", ")", "]", "for", "i", "in", "range", "(", "100", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "DenseNet", "(", "32", ",", "(", "6", ",", "12", ",", "24", ",", "16", ")", ",", "64", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", ")", "==", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_filmed_unet": [[39, 45], ["torch.tensor().float", "ivadomed.FiLMedUnet", "imed_model.FiLMedUnet.", "type", "torch.tensor", "range", "range"], "function", ["None"], ["", "def", "test_filmed_unet", "(", ")", ":", "\n", "    ", "a", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "100", ")", "]", "for", "i", "in", "range", "(", "100", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "FiLMedUnet", "(", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", ")", "==", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_model.test_film_generator": [[47, 57], ["torch.tensor().float", "ivadomed.FiLMgenerator", "imed_model.FiLMgenerator.", "type", "type", "len", "type", "type", "torch.tensor", "range", "range"], "function", ["None"], ["", "def", "test_film_generator", "(", ")", ":", "\n", "    ", "a", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "64", ")", "]", "for", "i", "in", "range", "(", "64", ")", "]", "]", "]", "\n", "inp", "=", "torch", ".", "tensor", "(", "a", ")", ".", "float", "(", ")", "\n", "model", "=", "imed_model", ".", "FiLMgenerator", "(", "64", ",", "1", ")", "\n", "inf", "=", "model", "(", "inp", ")", "\n", "assert", "(", "type", "(", "inf", "[", "0", "]", ")", "==", "torch", ".", "Tensor", ")", "\n", "assert", "(", "type", "(", "inf", "[", "1", "]", ")", "==", "list", ")", "\n", "assert", "(", "len", "(", "inf", "[", "1", "]", ")", "==", "2", ")", "\n", "assert", "(", "type", "(", "inf", "[", "1", "]", "[", "0", "]", ")", "==", "torch", ".", "nn", ".", "parameter", ".", "Parameter", ")", "\n", "assert", "(", "type", "(", "inf", "[", "1", "]", "[", "1", "]", ")", "==", "torch", ".", "nn", ".", "parameter", ".", "Parameter", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.setup_function": [[16, 18], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg": [[20, 67], ["numpy.zeros", "range", "numpy.eye", "nibabel.nifti1.Nifti1Image", "int", "scipy.ndimage.convolve", "range", "numpy.ones", "abs", "abs"], "function", ["None"], ["", "def", "nii_dummy_seg", "(", "size_arr", "=", "(", "15", ",", "15", ",", "9", ")", ",", "pixdim", "=", "(", "1", ",", "1", ",", "1", ")", ",", "dtype", "=", "np", ".", "float64", ",", "orientation", "=", "'LPI'", ",", "\n", "shape", "=", "'rectangle'", ",", "radius_RL", "=", "3.0", ",", "radius_AP", "=", "2.0", ",", "zeroslice", "=", "None", ",", "softseg", "=", "False", ")", ":", "\n", "    ", "\"\"\"Create a dummy nibabel object.\n\n    Create either an ellipse or rectangle of ones running from top to bottom in the 3rd\n    dimension.\n\n    Args:\n        size_arr (tuple): (nx, ny, nz)\n        pixdim (tuple): (px, py, pz)\n        dtype: Numpy dtype.\n        orientation: Orientation of the image. Default: LPI\n        shape: {'rectangle', 'ellipse'}\n        radius_RL (float): 1st radius. With a, b = 50.0, 30.0 (in mm), theoretical CSA of ellipse\n            is 4712.4\n        radius_AP: float: 2nd radius\n        zeroslice (list int): zero all slices listed in this param\n        softseg (bool): Generate soft segmentation by applying blurring filter.\n\n    Retunrs:\n        nibabel: Image object\n    \"\"\"", "\n", "if", "zeroslice", "is", "None", ":", "\n", "        ", "zeroslice", "=", "[", "]", "\n", "# Create a 3d array, with dimensions corresponding to x: RL, y: AP, z: IS", "\n", "", "nx", ",", "ny", ",", "nz", "=", "[", "int", "(", "size_arr", "[", "i", "]", "*", "pixdim", "[", "i", "]", ")", "for", "i", "in", "range", "(", "3", ")", "]", "\n", "data", "=", "np", ".", "zeros", "(", "(", "nx", ",", "ny", ",", "nz", ")", ",", "dtype", ")", "\n", "xx", ",", "yy", "=", "np", ".", "mgrid", "[", ":", "nx", ",", ":", "ny", "]", "\n", "# loop across slices and add object", "\n", "for", "iz", "in", "range", "(", "nz", ")", ":", "\n", "        ", "if", "shape", "==", "'rectangle'", ":", "# theoretical CSA: (a*2+1)(b*2+1)", "\n", "            ", "data", "[", ":", ",", ":", ",", "iz", "]", "=", "(", "(", "abs", "(", "xx", "-", "nx", "/", "2", ")", "<=", "radius_RL", ")", "&", "(", "abs", "(", "yy", "-", "ny", "/", "2", ")", "<=", "radius_AP", ")", ")", "*", "1", "\n", "", "if", "shape", "==", "'ellipse'", ":", "\n", "            ", "data", "[", ":", ",", ":", ",", "iz", "]", "=", "(", "(", "(", "xx", "-", "nx", "/", "2", ")", "/", "radius_RL", ")", "**", "2", "+", "(", "(", "yy", "-", "ny", "/", "2", ")", "/", "radius_AP", ")", "**", "2", "<=", "1", ")", "*", "1", "\n", "# Zero specified slices", "\n", "", "", "if", "zeroslice", "is", "not", "[", "]", ":", "\n", "        ", "data", "[", ":", ",", ":", ",", "zeroslice", "]", "=", "0", "\n", "# Apply Gaussian filter (to get soft seg)", "\n", "", "if", "softseg", ":", "\n", "        ", "kernel", "=", "np", ".", "ones", "(", "(", "3", ",", "3", ",", "3", ")", ")", "/", "27", "\n", "data", "=", "scipy", ".", "ndimage", ".", "convolve", "(", "data", ",", "kernel", ")", "\n", "# Create nibabel object", "\n", "", "affine", "=", "np", ".", "eye", "(", "4", ")", "\n", "nii", "=", "nib", ".", "nifti1", ".", "Nifti1Image", "(", "data", ",", "affine", ")", "\n", "# Change orientation", "\n", "# TODO", "\n", "return", "nii", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.check_bin_vs_soft": [[69, 88], ["numpy.array_equal", "arr_in.astype", "numpy.array_equal", "numpy.array_equal", "arr_out.astype", "arr_out.astype"], "function", ["None"], ["", "def", "check_bin_vs_soft", "(", "arr_in", ",", "arr_out", ")", ":", "\n", "    ", "\"\"\"Make sure that if input was bin, output is also bin. Or, if input was soft, output is soft.\n\n    Args:\n        arr_in: TODO\n        arr_out: TODO\n    \"\"\"", "\n", "if", "np", ".", "array_equal", "(", "arr_in", ",", "arr_in", ".", "astype", "(", "bool", ")", ")", ":", "\n", "        ", "if", "np", ".", "array_equal", "(", "arr_out", ",", "arr_out", ".", "astype", "(", "bool", ")", ")", ":", "\n", "# Both arr_in and arr_out are bin", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "", "", "else", ":", "\n", "        ", "if", "np", ".", "array_equal", "(", "arr_out", ",", "arr_out", ".", "astype", "(", "bool", ")", ")", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "# Both arr_in and arr_out are soft", "\n", "            ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_threshold": [[90, 101], ["pytest.mark.parametrize", "ivadomed.postprocessing.threshold_predictions", "isinstance", "numpy.array_equal", "ivadomed.postprocessing.threshold_predictions", "isinstance", "numpy.array_equal", "numpy.copy", "numpy.array", "numpy.array", "test_postprocessing.nii_dummy_seg", "numpy.asanyarray", "imed_postpro.threshold_predictions.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg"], ["", "", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'nii_seg'", ",", "[", "nii_dummy_seg", "(", "softseg", "=", "True", ")", "]", ")", "\n", "def", "test_threshold", "(", "nii_seg", ")", ":", "\n", "# input array", "\n", "    ", "arr_seg_proc", "=", "imed_postpro", ".", "threshold_predictions", "(", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ")", "\n", "assert", "isinstance", "(", "arr_seg_proc", ",", "np", ".", "ndarray", ")", "\n", "# Before thresholding: [0.33333333, 0.66666667, 1.        ] --> after thresholding: [0, 1, 1]", "\n", "assert", "np", ".", "array_equal", "(", "arr_seg_proc", "[", "4", ":", "7", ",", "8", ",", "4", "]", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", "]", ")", ")", "\n", "# input nibabel", "\n", "nii_seg_proc", "=", "imed_postpro", ".", "threshold_predictions", "(", "nii_seg", ")", "\n", "assert", "isinstance", "(", "nii_seg_proc", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "assert", "np", ".", "array_equal", "(", "nii_seg_proc", ".", "get_fdata", "(", ")", "[", "4", ":", "7", ",", "8", ",", "4", "]", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_keep_largest_object": [[103, 118], ["pytest.mark.parametrize", "ivadomed.postprocessing.keep_largest_object", "isinstance", "test_postprocessing.check_bin_vs_soft", "ivadomed.postprocessing.keep_largest_object", "isinstance", "test_postprocessing.check_bin_vs_soft", "numpy.copy", "test_postprocessing.nii_dummy_seg", "test_postprocessing.nii_dummy_seg", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.check_bin_vs_soft", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.check_bin_vs_soft", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'nii_seg'", ",", "[", "nii_dummy_seg", "(", ")", ",", "nii_dummy_seg", "(", "softseg", "=", "True", ")", "]", ")", "\n", "def", "test_keep_largest_object", "(", "nii_seg", ")", ":", "\n", "# Set a voxel to 1 at the corner to make sure it is set to 0 by the function", "\n", "    ", "coord", "=", "(", "1", ",", "1", ",", "1", ")", "\n", "nii_seg", ".", "dataobj", "[", "coord", "]", "=", "1", "\n", "# Test function with array input", "\n", "arr_seg_proc", "=", "imed_postpro", ".", "keep_largest_object", "(", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ")", "\n", "assert", "isinstance", "(", "arr_seg_proc", ",", "np", ".", "ndarray", ")", "\n", "assert", "check_bin_vs_soft", "(", "nii_seg", ".", "dataobj", ",", "arr_seg_proc", ")", "\n", "assert", "arr_seg_proc", "[", "coord", "]", "==", "0", "\n", "# Make sure it works with nibabel input", "\n", "nii_seg_proc", "=", "imed_postpro", ".", "keep_largest_object", "(", "nii_seg", ")", "\n", "assert", "isinstance", "(", "nii_seg_proc", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "assert", "check_bin_vs_soft", "(", "nii_seg", ".", "dataobj", ",", "nii_seg_proc", ".", "dataobj", ")", "\n", "assert", "nii_seg_proc", ".", "dataobj", "[", "coord", "]", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_keep_largest_object_per_slice": [[120, 137], ["pytest.mark.parametrize", "ivadomed.postprocessing.keep_largest_object_per_slice", "isinstance", "test_postprocessing.check_bin_vs_soft", "ivadomed.postprocessing.keep_largest_object_per_slice", "isinstance", "test_postprocessing.check_bin_vs_soft", "numpy.copy", "test_postprocessing.nii_dummy_seg", "test_postprocessing.nii_dummy_seg", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object_per_slice", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.check_bin_vs_soft", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object_per_slice", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.check_bin_vs_soft", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'nii_seg'", ",", "[", "nii_dummy_seg", "(", ")", ",", "nii_dummy_seg", "(", "softseg", "=", "True", ")", "]", ")", "\n", "def", "test_keep_largest_object_per_slice", "(", "nii_seg", ")", ":", "\n", "# Set a voxel to 1 at the corner to make sure it is set to 0 by the function", "\n", "    ", "coord", "=", "(", "1", ",", "1", ",", "1", ")", "\n", "nii_seg", ".", "dataobj", "[", "coord", "]", "=", "1", "\n", "# Test function with array input", "\n", "arr_seg_proc", "=", "imed_postpro", ".", "keep_largest_object_per_slice", "(", "np", ".", "copy", "(", "\n", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ",", "\n", "axis", "=", "2", ")", "\n", "assert", "isinstance", "(", "arr_seg_proc", ",", "np", ".", "ndarray", ")", "\n", "assert", "check_bin_vs_soft", "(", "nii_seg", ".", "dataobj", ",", "arr_seg_proc", ")", "\n", "assert", "arr_seg_proc", "[", "coord", "]", "==", "0", "\n", "# Make sure it works with nibabel input", "\n", "nii_seg_proc", "=", "imed_postpro", ".", "keep_largest_object_per_slice", "(", "nii_seg", ")", "\n", "assert", "isinstance", "(", "nii_seg_proc", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "assert", "check_bin_vs_soft", "(", "nii_seg", ".", "dataobj", ",", "nii_seg_proc", ".", "dataobj", ")", "\n", "assert", "nii_seg_proc", ".", "dataobj", "[", "coord", "]", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_fill_holes": [[139, 152], ["pytest.mark.parametrize", "ivadomed.postprocessing.fill_holes", "isinstance", "ivadomed.postprocessing.fill_holes", "isinstance", "numpy.copy", "test_postprocessing.nii_dummy_seg", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.fill_holes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.fill_holes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'nii_seg'", ",", "[", "nii_dummy_seg", "(", ")", "]", ")", "\n", "def", "test_fill_holes", "(", "nii_seg", ")", ":", "\n", "# Set a voxel to 0 in the middle of the segmentation to make sure it is set to 1 by the function", "\n", "    ", "coord", "=", "(", "7", ",", "7", ",", "4", ")", "\n", "nii_seg", ".", "dataobj", "[", "coord", "]", "=", "0", "\n", "# Test function with array input", "\n", "arr_seg_proc", "=", "imed_postpro", ".", "fill_holes", "(", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ")", "\n", "assert", "isinstance", "(", "arr_seg_proc", ",", "np", ".", "ndarray", ")", "\n", "assert", "arr_seg_proc", "[", "coord", "]", "==", "1", "\n", "# Make sure it works with nibabel input", "\n", "nii_seg_proc", "=", "imed_postpro", ".", "fill_holes", "(", "nii_seg", ")", "\n", "assert", "isinstance", "(", "nii_seg_proc", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "assert", "nii_seg_proc", ".", "dataobj", "[", "coord", "]", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_mask_predictions": [[154, 169], ["pytest.mark.parametrize", "nibabel.nifti1.Nifti1Image", "ivadomed.postprocessing.mask_predictions", "isinstance", "ivadomed.postprocessing.mask_predictions", "isinstance", "numpy.copy", "numpy.copy", "numpy.asanyarray", "test_postprocessing.nii_dummy_seg", "numpy.asanyarray", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.nii_dummy_seg"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'nii_seg'", ",", "[", "nii_dummy_seg", "(", ")", "]", ")", "\n", "def", "test_mask_predictions", "(", "nii_seg", ")", ":", "\n", "# create nii object with a voxel of 0 somewhere in the middle", "\n", "    ", "nii_seg_mask", "=", "nib", ".", "nifti1", ".", "Nifti1Image", "(", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ",", "nii_seg", ".", "affine", ")", "\n", "coord", "=", "(", "7", ",", "7", ",", "4", ")", "\n", "nii_seg_mask", ".", "dataobj", "[", "coord", "]", "=", "0", "\n", "# Test function with array input", "\n", "arr_seg_proc", "=", "imed_postpro", ".", "mask_predictions", "(", "\n", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "nii_seg", ".", "dataobj", ")", ")", ",", "np", ".", "asanyarray", "(", "nii_seg_mask", ".", "dataobj", ")", ")", "\n", "assert", "isinstance", "(", "arr_seg_proc", ",", "np", ".", "ndarray", ")", "\n", "assert", "arr_seg_proc", "[", "coord", "]", "==", "0", "\n", "# Make sure it works with nibabel input", "\n", "nii_seg_proc", "=", "imed_postpro", ".", "mask_predictions", "(", "nii_seg", ",", "nii_seg_mask", ".", "dataobj", ")", "\n", "assert", "isinstance", "(", "nii_seg_proc", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "assert", "nii_seg_proc", ".", "dataobj", "[", "coord", "]", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.test_label_file_from_coordinates": [[171, 181], ["nibabel.load", "ivadomed.postprocessing.label_file_from_coordinates", "isinstance", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.label_file_from_coordinates"], ["", "def", "test_label_file_from_coordinates", "(", "download_data_testing_test_files", ")", ":", "\n", "# create fake coordinate", "\n", "    ", "coord", "=", "[", "[", "0", ",", "0", ",", "0", "]", "]", "\n", "# load test image", "\n", "nifti", "=", "nib", ".", "load", "(", "\n", "Path", "(", "__data_testing_dir__", ",", "'sub-unf01/anat/sub-unf01_T1w.nii.gz'", ")", ")", "\n", "# create fake label", "\n", "label", "=", "imed_postpro", ".", "label_file_from_coordinates", "(", "nifti", ",", "coord", ")", "\n", "# check if it worked", "\n", "assert", "isinstance", "(", "label", ",", "nib", ".", "nifti1", ".", "Nifti1Image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_postprocessing.teardown_function": [[183, 185], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler.setup_function": [[20, 22], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler._cmpt_label": [[24, 39], ["enumerate", "loguru.logger.info", "len", "numpy.any", "gt.numpy"], "function", ["None"], ["", "def", "_cmpt_label", "(", "ds_loader", ")", ":", "\n", "    ", "cmpt_label", ",", "cmpt_sample", "=", "{", "0", ":", "0", ",", "1", ":", "0", "}", ",", "0", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "ds_loader", ")", ":", "\n", "        ", "for", "gt", "in", "batch", "[", "'gt'", "]", ":", "\n", "            ", "if", "np", ".", "any", "(", "gt", ".", "numpy", "(", ")", ")", ":", "\n", "                ", "cmpt_label", "[", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                ", "cmpt_label", "[", "0", "]", "+=", "1", "\n", "", "", "cmpt_sample", "+=", "len", "(", "batch", "[", "'gt'", "]", ")", "\n", "\n", "", "neg_sample_ratio", "=", "cmpt_label", "[", "0", "]", "*", "100.", "/", "cmpt_sample", "\n", "pos_sample_ratio", "=", "cmpt_label", "[", "1", "]", "*", "100.", "/", "cmpt_sample", "\n", "logger", ".", "info", "(", "{", "'neg_sample_ratio'", ":", "neg_sample_ratio", ",", "\n", "'pos_sample_ratio'", ":", "pos_sample_ratio", "}", ")", "\n", "return", "neg_sample_ratio", ",", "pos_sample_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler.test_sampler": [[41, 99], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "loguru.logger.info", "torch.utils.data.DataLoader", "test_sampler._cmpt_label", "loguru.logger.info", "torch.utils.data.DataLoader", "test_sampler._cmpt_label", "abs", "abs", "abs", "ivadomed.loader.balanced_sampler.BalancedSampler"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler._cmpt_label", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler._cmpt_label"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "{", "\n", "\"Resample\"", ":", "\n", "{", "\n", "\"wspace\"", ":", "0.75", ",", "\n", "\"hspace\"", ":", "0.75", "\n", "}", ",", "\n", "\"ROICrop\"", ":", "\n", "{", "\n", "\"size\"", ":", "[", "128", ",", "128", "]", "\n", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'train_lst'", ",", "[", "[", "'sub-unf01_T2w.nii.gz'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_lesion-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'roi_params'", ",", "[", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", "]", ")", "\n", "def", "test_sampler", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "train_lst", ",", "target_lst", ",", "roi_params", ")", ":", "\n", "    ", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "train_lst", ",", "\n", "\"dataset_type\"", ":", "\"training\"", ",", "\n", "\"requires_undo\"", ":", "False", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "roi_params", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "# Get Training dataset", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "ds_train", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "\n", "logger", ".", "info", "(", "\"\\nLoading without sampling\"", ")", "\n", "train_loader", "=", "DataLoader", "(", "ds_train", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "neg_percent", ",", "pos_percent", "=", "_cmpt_label", "(", "train_loader", ")", "\n", "assert", "abs", "(", "neg_percent", "-", "pos_percent", ")", ">", "20", "\n", "\n", "logger", ".", "info", "(", "\"\\nLoading with sampling\"", ")", "\n", "train_loader_balanced", "=", "DataLoader", "(", "ds_train", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "sampler", "=", "BalancedSampler", "(", "ds_train", ")", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "neg_percent_bal", ",", "pos_percent_bal", "=", "_cmpt_label", "(", "train_loader_balanced", ")", "\n", "# Check if the loader is more balanced. The actual distribution comes from a probabilistic model", "\n", "# This is however not very efficient to get close to 50 %", "\n", "# in the case where we have 16 slices, with 87.5 % of one class (positive sample).", "\n", "assert", "abs", "(", "neg_percent_bal", "-", "pos_percent_bal", ")", "<=", "abs", "(", "neg_percent", "-", "pos_percent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_sampler.teardown_function": [[101, 103], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_mixup.setup_function": [[11, 13], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_mixup.test_mixup": [[15, 28], ["pytest.mark.parametrize", "pytest.mark.parametrize", "range", "torch.tensor().float", "torch.tensor().float", "ivadomed.mixup", "range", "str", "str", "torch.tensor", "torch.tensor", "pathlib.Path", "pathlib.Path", "range", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.mixup.mixup"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"debugging\"", ",", "[", "False", ",", "True", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"ofolder\"", ",", "[", "str", "(", "Path", "(", "__tmp_dir__", ",", "\"test\"", ")", ")", ",", "\n", "str", "(", "Path", "(", "__tmp_dir__", ",", "\"mixup_test\"", ")", ")", "]", ")", "\n", "def", "test_mixup", "(", "debugging", ",", "ofolder", ")", ":", "\n", "    ", "inp", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "40", ")", "]", "for", "i", "in", "range", "(", "40", ")", "]", "]", "]", "\n", "targ", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "40", ")", "]", "for", "i", "in", "range", "(", "40", ")", "]", "]", "]", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "10", ")", ":", "\n", "            ", "targ", "[", "0", "]", "[", "0", "]", "[", "i", "]", "[", "j", "]", "=", "1", "\n", "", "", "inp", "=", "torch", ".", "tensor", "(", "inp", ")", ".", "float", "(", ")", "\n", "targ", "=", "torch", ".", "tensor", "(", "targ", ")", ".", "float", "(", ")", "\n", "# just testing if mixup function run", "\n", "imed_mixup", ".", "mixup", "(", "inp", ",", "targ", ",", "alpha", "=", "0.5", ",", "debugging", "=", "debugging", ",", "ofolder", "=", "ofolder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_mixup.teardown_function": [[30, 32], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_automate_training.setup_function": [[633, 635], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], []], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_automate_training.test_get_param_list": [[637, 663], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.scripts.automate_training.get_param_list", "pytest.param"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_param_list"], []], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_automate_training.test_make_config_list": [[665, 700], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.scripts.automate_training.make_config_list", "len", "len", "pytest.param", "pytest.param", "pytest.param", "loguru.logger.debug", "loguru.logger.debug"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.make_config_list"], []], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_automate_training.test_config_sha256": [[702, 727], ["pytest.mark.parametrize", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.utils.generate_sha_256"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.generate_sha_256"], []], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_automate_training.teardown_function": [[729, 731], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], []], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter.setup_function": [[19, 21], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter._cmpt_slice": [[23, 34], ["enumerate", "loguru.logger.debug", "numpy.any", "gt.numpy"], "function", ["None"], ["", "def", "_cmpt_slice", "(", "ds_loader", ")", ":", "\n", "    ", "cmpt_label", "=", "{", "0", ":", "0", ",", "1", ":", "0", "}", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "ds_loader", ")", ":", "\n", "        ", "for", "gt", "in", "batch", "[", "'gt'", "]", ":", "\n", "# TODO: multi label", "\n", "            ", "if", "np", ".", "any", "(", "gt", ".", "numpy", "(", ")", ")", ":", "\n", "                ", "cmpt_label", "[", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                ", "cmpt_label", "[", "0", "]", "+=", "1", "\n", "", "", "", "logger", ".", "debug", "(", "cmpt_label", ")", "\n", "return", "cmpt_label", "[", "0", "]", ",", "cmpt_label", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter.test_slice_filter": [[36, 91], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "loguru.logger.info", "torch.utils.data.DataLoader", "test_slice_filter._cmpt_slice", "loguru.logger.info", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter._cmpt_slice"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transforms_dict'", ",", "[", "\n", "{", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"ROICrop\"", ":", "{", "\"size\"", ":", "[", "48", ",", "48", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "{", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", ",", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", "}", ",", "\n", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "100", ",", "100", "]", ",", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "\"applied_to\"", ":", "[", "\"im\"", ",", "\"gt\"", "]", "}", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'train_lst'", ",", "[", "[", "'sub-unf01_T2w.nii.gz'", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_lesion-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'slice_filter_params'", ",", "[", "\n", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "{", "\"filter_empty_mask\"", ":", "True", ",", "\"filter_empty_input\"", ":", "True", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'roi_params'", ",", "[", "\n", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "0", "}", "]", ")", "\n", "def", "test_slice_filter", "(", "download_data_testing_test_files", ",", "transforms_dict", ",", "train_lst", ",", "target_lst", ",", "roi_params", ",", "slice_filter_params", ")", ":", "\n", "    ", "if", "\"ROICrop\"", "in", "transforms_dict", "and", "roi_params", "[", "\"suffix\"", "]", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "loader_params", "=", "{", "\n", "\"transforms_params\"", ":", "transforms_dict", ",", "\n", "\"data_list\"", ":", "train_lst", ",", "\n", "\"dataset_type\"", ":", "\"training\"", ",", "\n", "\"requires_undo\"", ":", "False", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "roi_params", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "\"slice_filter_params\"", ":", "slice_filter_params", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "\n", "# Get Training dataset", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "ds_train", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "\n", "logger", ".", "info", "(", "f\"\\tNumber of loaded slices: {len(ds_train)}\"", ")", "\n", "\n", "train_loader", "=", "DataLoader", "(", "ds_train", ",", "batch_size", "=", "BATCH_SIZE", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "cmpt_neg", ",", "cmpt_pos", "=", "_cmpt_slice", "(", "train_loader", ")", "\n", "if", "slice_filter_params", "[", "\"filter_empty_mask\"", "]", ":", "\n", "        ", "assert", "cmpt_neg", "==", "0", "\n", "assert", "cmpt_pos", "!=", "0", "\n", "", "else", ":", "\n", "# We verify if there are still some negative slices (they are removed with our filter)", "\n", "        ", "assert", "cmpt_neg", "!=", "0", "and", "cmpt_pos", "!=", "0", "\n", "", "logger", ".", "info", "(", "f\"\\tNumber of Neg/Pos slices in GT: {cmpt_neg/cmpt_pos}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_slice_filter.teardown_function": [[93, 95], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_utils.test_timestamp": [[10, 26], ["ivadomed.utils.get_timestamp", "loguru.logger.debug", "ivadomed.utils.get_timestamp.count", "ivadomed.utils.get_timestamp.count", "ivadomed.utils.get_timestamp.count", "ivadomed.utils.get_timestamp.count", "ivadomed.utils.get_timestamp.count", "ivadomed.utils.get_timestamp.count"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp"], ["def", "test_timestamp", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test the timestamp function.\n    \"\"\"", "\n", "output", "=", "get_timestamp", "(", ")", "\n", "logger", ".", "debug", "(", "output", ")", "\n", "assert", "output", ".", "count", "(", "\"-\"", ")", "==", "2", "\n", "assert", "output", ".", "count", "(", "\".\"", ")", "==", "1", "\n", "assert", "output", ".", "count", "(", "\"T\"", ")", "==", "1", "\n", "for", "I", "in", "string", ".", "ascii_uppercase", ":", "\n", "        ", "if", "I", "==", "\"T\"", ":", "\n", "            ", "assert", "output", ".", "count", "(", "I", ")", "==", "1", "\n", "", "else", ":", "\n", "            ", "assert", "output", ".", "count", "(", "I", ")", "==", "0", "\n", "", "", "for", "i", "in", "string", ".", "ascii_lowercase", ":", "\n", "        ", "assert", "output", ".", "count", "(", "i", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_utils.test_get_win_system_memory": [[27, 36], ["pytest.mark.skipif", "ivadomed.utils.get_win_system_memory"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_win_system_memory"], ["", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "current_platform", "!=", "\"Windows\"", ",", "reason", "=", "\"Function only works for Windows, skip on all other OS\"", ")", "\n", "def", "test_get_win_system_memory", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get Windows memory size\n    Returns:\n\n    \"\"\"", "\n", "# Most computers/clusters should have memory of at least 100mb and no more than 256GB RAM", "\n", "assert", "0.1", "<", "get_win_system_memory", "(", ")", "<", "256", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_utils.test_get_linux_system_memory": [[37, 46], ["pytest.mark.skipif", "ivadomed.utils.get_linux_system_memory"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_linux_system_memory"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "current_platform", "!=", "\"Linux\"", ",", "reason", "=", "\"Function only works for Linux, skip on all other OS\"", ")", "\n", "def", "test_get_linux_system_memory", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get Windows memory size\n    Returns:\n\n    \"\"\"", "\n", "# Most computers/clusters should have memory of at least 100mb and no more than 256GB RAM", "\n", "assert", "0.1", "<", "get_linux_system_memory", "(", ")", "<", "256", "\n", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "current_platform", "!=", "\"Darwin\"", ",", "reason", "=", "\"Function only works for Mac, skip on all other OS\"", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_utils.test_get_mac_system_memory": [[46, 55], ["pytest.mark.skipif", "ivadomed.utils.get_mac_system_memory"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_mac_system_memory"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "current_platform", "!=", "\"Darwin\"", ",", "reason", "=", "\"Function only works for Mac, skip on all other OS\"", ")", "\n", "def", "test_get_mac_system_memory", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get Windows memory size\n    Returns:\n\n    \"\"\"", "\n", "# Most computers/clusters should have memory of at least 100mb and no more than 256GB RAM", "\n", "assert", "0.1", "<", "get_mac_system_memory", "(", ")", "<", "256", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_training_time.setup_function": [[31, 33], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_training_time.test_unet_time": [[35, 210], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.utils.define_device", "loader_params.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "torch.utils.data.DataLoader", "model_params.update", "len", "getattr", "getattr.", "loguru.logger.debug", "torch.optim.Adam", "torch.optim.lr_scheduler.CosineAnnealingLR", "ivadomed.losses.DiceLoss", "tqdm.tqdm", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "len", "model_class.cuda", "model_class.parameters", "range", "time.time", "time.time", "model_class.train", "init_lst.append", "enumerate", "time.time", "schedule_lst.append", "time.time", "tqdm.tqdm.write", "time.time", "time.time", "ivadomed.utils.cuda", "ivadomed.utils.cuda", "load_lst.append", "time.time", "pred_lst.append", "time.time", "imed_losses.DiceLoss.", "optim.Adam.zero_grad", "loss_fct.backward", "optim.Adam.step", "opt_lst.append", "time.time", "optim.lr_scheduler.CosineAnnealingLR.step", "time.time", "gen_lst.append", "time.time", "model_class.", "model_class.", "time.time", "optim.lr_scheduler.CosineAnnealingLR.step", "time.time", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "time.time"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'target_lst'", ",", "[", "[", "\"_lesion-manual\"", "]", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'train_lst, config'", ",", "[", "\n", "(", "[", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"ROICrop\"", ":", "{", "\"size\"", ":", "[", "48", ",", "48", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "}", ")", ",", "\n", "(", "[", "'sub-unf01_T1w.nii.gz'", ",", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"Resample\"", ":", "{", "\"wspace\"", ":", "0.75", ",", "\"hspace\"", ":", "0.75", "}", ",", "\n", "\"ROICrop\"", ":", "{", "\"size\"", ":", "[", "48", ",", "48", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T1w'", ",", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "True", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", "}", ",", "\n", "}", ")", ",", "\n", "(", "[", "'sub-unf01_T1w.nii.gz'", ",", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "96", ",", "96", ",", "16", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "0", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T1w'", ",", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Modified3DUNet\"", ",", "\"length_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\"n_filters\"", ":", "8", ",", "\"stride_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\n", "\"attention\"", ":", "True", "}", ",", "\n", "}", ")", ",", "\n", "(", "[", "'sub-unf01_T1w.nii.gz'", ",", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "96", ",", "96", ",", "16", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "0", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T1w'", ",", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Modified3DUNet\"", ",", "\"length_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\"n_filters\"", ":", "8", ",", "\"stride_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\n", "\"attention\"", ":", "False", "}", ",", "\n", "}", ")", ",", "\n", "(", "[", "'sub-unf01_T1w.nii.gz'", ",", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "96", ",", "96", ",", "16", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "0", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T1w'", ",", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Modified3DUNet\"", ",", "\"length_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\"n_filters\"", ":", "8", ",", "\"stride_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\n", "\"attention\"", ":", "False", ",", "\"metadata\"", ":", "\"contrasts\"", ",", "\"film_layers\"", ":", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "\"n_metadata\"", ":", "2", "}", ",", "\n", "}", ")", ",", "\n", "(", "[", "'sub-unf01_T2w.nii.gz'", "]", ",", "{", "\n", "\"transforms_params\"", ":", "{", "\"CenterCrop\"", ":", "{", "\"size\"", ":", "[", "96", ",", "96", ",", "16", "]", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", "}", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "10", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "'T2w'", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"multichannel\"", ":", "False", ",", "\n", "\"model_params\"", ":", "{", "\"name\"", ":", "\"Unet\"", ",", "'is_2d'", ":", "False", ",", "\"length_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", ",", "\"n_filters\"", ":", "8", ",", "\n", "\"stride_3D\"", ":", "[", "96", ",", "96", ",", "16", "]", "}", ",", "\n", "}", ")", "\n", "]", ")", "\n", "def", "test_unet_time", "(", "download_data_testing_test_files", ",", "train_lst", ",", "target_lst", ",", "config", ")", ":", "\n", "    ", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "GPU_ID", ")", "\n", "\n", "loader_params", "=", "{", "\n", "\"data_list\"", ":", "train_lst", ",", "\n", "\"dataset_type\"", ":", "\"training\"", ",", "\n", "\"requires_undo\"", ":", "False", ",", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "target_lst", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", "\n", "}", "\n", "# Update loader_params with config", "\n", "loader_params", ".", "update", "(", "config", ")", "\n", "# Get Training dataset", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "ds_train", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "loader_params", ")", "\n", "\n", "# Loader", "\n", "train_loader", "=", "DataLoader", "(", "ds_train", ",", "\n", "batch_size", "=", "1", "if", "config", "[", "\"model_params\"", "]", "[", "\"name\"", "]", "==", "\"Modified3DUNet\"", "else", "BATCH_SIZE", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "1", ")", "\n", "\n", "# MODEL", "\n", "model_params", "=", "loader_params", "[", "\"model_params\"", "]", "\n", "model_params", ".", "update", "(", "MODEL_DEFAULT", ")", "\n", "# Get in_channel from contrast_lst", "\n", "if", "loader_params", "[", "\"multichannel\"", "]", ":", "\n", "        ", "model_params", "[", "\"in_channel\"", "]", "=", "len", "(", "loader_params", "[", "\"contrast_params\"", "]", "[", "\"contrast_lst\"", "]", ")", "\n", "", "else", ":", "\n", "        ", "model_params", "[", "\"in_channel\"", "]", "=", "1", "\n", "# Get out_channel from target_suffix", "\n", "", "model_params", "[", "\"out_channel\"", "]", "=", "len", "(", "loader_params", "[", "\"target_suffix\"", "]", ")", "\n", "model_class", "=", "getattr", "(", "imed_models", ",", "model_params", "[", "\"name\"", "]", ")", "\n", "model", "=", "model_class", "(", "**", "model_params", ")", "\n", "\n", "logger", ".", "debug", "(", "f\"Training {model_params['name']}\"", ")", "\n", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "step_scheduler_batch", "=", "False", "\n", "# TODO: Add optim in pytest", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "INIT_LR", ")", "\n", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "optimizer", ",", "N_EPOCHS", ")", "\n", "\n", "# TODO: add to pytest", "\n", "loss_fct", "=", "imed_losses", ".", "DiceLoss", "(", ")", "\n", "\n", "load_lst", ",", "pred_lst", ",", "opt_lst", ",", "schedule_lst", ",", "init_lst", ",", "gen_lst", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "epoch", "in", "tqdm", "(", "range", "(", "1", ",", "N_EPOCHS", "+", "1", ")", ",", "desc", "=", "\"Training\"", ")", ":", "\n", "        ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "start_init", "=", "time", ".", "time", "(", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "\n", "tot_init", "=", "time", ".", "time", "(", ")", "-", "start_init", "\n", "init_lst", ".", "append", "(", "tot_init", ")", "\n", "\n", "num_steps", "=", "0", "\n", "start_gen", "=", "0", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "            ", "if", "i", ">", "0", ":", "\n", "                ", "tot_gen", "=", "time", ".", "time", "(", ")", "-", "start_gen", "\n", "gen_lst", ".", "append", "(", "tot_gen", ")", "\n", "\n", "", "start_load", "=", "time", ".", "time", "(", ")", "\n", "input_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"input\"", "]", ",", "cuda_available", ")", "\n", "gt_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"gt\"", "]", ",", "cuda_available", ",", "non_blocking", "=", "True", ")", "\n", "\n", "tot_load", "=", "time", ".", "time", "(", ")", "-", "start_load", "\n", "load_lst", ".", "append", "(", "tot_load", ")", "\n", "\n", "start_pred", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "'film_layers'", "in", "model_params", ":", "\n", "                ", "preds", "=", "model", "(", "input_samples", ",", "[", "[", "0", ",", "1", "]", "]", ")", "\n", "", "else", ":", "\n", "                ", "preds", "=", "model", "(", "input_samples", ")", "\n", "", "tot_pred", "=", "time", ".", "time", "(", ")", "-", "start_pred", "\n", "pred_lst", ".", "append", "(", "tot_pred", ")", "\n", "\n", "start_opt", "=", "time", ".", "time", "(", ")", "\n", "loss", "=", "loss_fct", "(", "preds", ",", "gt_samples", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "step_scheduler_batch", ":", "\n", "                ", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "num_steps", "+=", "1", "\n", "tot_opt", "=", "time", ".", "time", "(", ")", "-", "start_opt", "\n", "opt_lst", ".", "append", "(", "tot_opt", ")", "\n", "\n", "start_gen", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "start_schedule", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "step_scheduler_batch", ":", "\n", "            ", "scheduler", ".", "step", "(", ")", "\n", "", "tot_schedule", "=", "time", ".", "time", "(", ")", "-", "start_schedule", "\n", "schedule_lst", ".", "append", "(", "tot_schedule", ")", "\n", "\n", "end_time", "=", "time", ".", "time", "(", ")", "\n", "total_time", "=", "end_time", "-", "start_time", "\n", "tqdm", ".", "write", "(", "\"Epoch {} took {:.2f} seconds.\"", ".", "format", "(", "epoch", ",", "total_time", ")", ")", "\n", "\n", "", "logger", ".", "info", "(", "f\"Mean SD init {np.mean(init_lst)} -- {np.std(init_lst)}\"", ")", "\n", "logger", ".", "info", "(", "f\"Mean SD load {np.mean(load_lst)} -- {np.std(load_lst)}\"", ")", "\n", "logger", ".", "info", "(", "f\"Mean SD pred {np.mean(pred_lst)} -- {np.std(pred_lst)}\"", ")", "\n", "logger", ".", "info", "(", "f\"Mean SDopt {np.mean(opt_lst)} --  {np.std(opt_lst)}\"", ")", "\n", "logger", ".", "info", "(", "f\"Mean SD gen {np.mean(gen_lst)} -- {np.std(gen_lst)}\"", ")", "\n", "logger", ".", "info", "(", "f\"Mean SD scheduler {np.mean(schedule_lst)} -- {np.std(schedule_lst)}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_training_time.teardown_function": [[212, 214], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.download_data_testing_test_files": [[17, 23], ["pytest.fixture", "testing.common_testing_util.download_dataset"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.download_dataset"], ["def", "download_functional_test_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    This fixture will attempt to download test data file if there are not present.\n    \"\"\"", "\n", "download_dataset", "(", "\"data_functional_testing\"", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.download_multi_data": [[25, 32], ["pytest.fixture", "testing.common_testing_util.download_dataset"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.download_dataset"], ["    ", "\"\"\"\n    This function checks if sha256 is generated in according to config file\n    \"\"\"", "\n", "initial_config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "file_config", ")", ".", "get_config", "(", ")", "\n", "result", "=", "[", "]", "\n", "name", "=", "\"config_file.json\"", "\n", "for", "path_object", "in", "Path", "(", "initial_config", "[", "\"path_output\"", "]", ")", ".", "parent", ".", "glob", "(", "\"**/*\"", ")", ":", "\n", "        ", "if", "path_object", ".", "is_file", "(", ")", "and", "name", "in", "path_object", ".", "name", ":", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir": [[34, 52], ["testing.common_testing_util.remove_tmp_dir", "pathlib.Path().mkdir", "pathlib.Path().exists", "shutil.copytree", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "", "assert", "result", "!=", "[", "]", "\n", "for", "generated_config", "in", "result", ":", "\n", "        ", "config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "generated_config", ")", ".", "get_config", "(", ")", "\n", "assert", "'training_sha256'", "in", "config", "\n", "\n", "\n", "", "", "def", "create_tmp_dir", "(", "copy_data_testing_dir", "=", "True", ")", ":", "\n", "    ", "\"\"\"Create a temporary directory for data_functional and copy test data files.\n\n    1. Remove the ``tmp`` directory if it exists.\n    2. Copy the ``data_functional_testing`` directory to the ``tmp`` directory.\n\n    Any data files created during testing will go into ``tmp`` directory.\n    This is created/removed for each test.\n\n    Args:\n        copy_data_testing_dir (bool): If true, copy the __data_testing_dir_ref__ folder\n            into the ``tmp`` folder.\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir_multi_session": [[54, 68], ["shutil.ignore_patterns", "testing.common_testing_util.remove_tmp_dir", "pathlib.Path().mkdir", "pathlib.Path().exists", "str", "shutil.copytree", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["Path", "(", "path_temp", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "if", "Path", "(", "path_data_functional_source", ")", ".", "exists", "(", ")", "and", "copy_data_testing_dir", ":", "\n", "        ", "shutil", ".", "copytree", "(", "path_data_functional_source", ",", "\n", "path_data_functional_tmp", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transfer_learning.setup_function": [[17, 19], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transfer_learning.test_transfer_learning": [[21, 56], ["pytest.mark.parametrize", "pytest.mark.parametrize", "torch.device", "torch.device", "loguru.logger.info", "loguru.logger.info", "torch.load", "torch.load", "ivadomed.models.set_model_for_retrain", "loguru.logger.info", "loguru.logger.debug", "sum", "loguru.logger.info", "sum", "loguru.logger.info", "loguru.logger.info", "len", "abs", "len", "abs", "str", "imed_models.set_model_for_retrain.named_parameters", "sum", "p.numel", "p.numel", "zip", "sum", "pathlib.Path", "round", "imed_models.set_model_for_retrain.parameters", "imed_models.set_model_for_retrain.parameters", "torch.load.parameters", "imed_models.set_model_for_retrain.parameters", "round", "p1.data.ne().sum", "p1.data.ne"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.set_model_for_retrain"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'fraction'", ",", "[", "0.1", ",", "0.2", ",", "0.3", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'path_model'", ",", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "'model_unet_test.pt'", ")", ")", "]", ")", "\n", "def", "test_transfer_learning", "(", "download_data_testing_test_files", ",", "path_model", ",", "fraction", ",", "tolerance", "=", "0.15", ")", ":", "\n", "    ", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "logger", ".", "info", "(", "f\"Working on {'cpu'}.\"", ")", "\n", "logger", ".", "info", "(", "__data_testing_dir__", ")", "\n", "\n", "# Load pretrained model", "\n", "model_pretrained", "=", "torch", ".", "load", "(", "path_model", ",", "map_location", "=", "device", ")", "\n", "# Setup model for retrain", "\n", "model_to_retrain", "=", "imed_models", ".", "set_model_for_retrain", "(", "path_model", ",", "retrain_fraction", "=", "fraction", ",", "\n", "map_location", "=", "device", ")", "\n", "\n", "logger", ".", "info", "(", "f\"\\nSet fraction to retrain: {fraction}\"", ")", "\n", "\n", "# Check Frozen part", "\n", "grad_list", "=", "[", "param", ".", "requires_grad", "for", "name", ",", "param", "in", "model_to_retrain", ".", "named_parameters", "(", ")", "]", "\n", "fraction_retrain_measured", "=", "sum", "(", "grad_list", ")", "*", "1.0", "/", "len", "(", "grad_list", ")", "\n", "logger", ".", "debug", "(", "f\"\\nMeasure: retrained fraction of the model: {round(fraction_retrain_measured, 1)}\"", ")", "\n", "# for name, param in model.named_parameters():", "\n", "#    print(\"\\t\", name, param.requires_grad)", "\n", "assert", "(", "abs", "(", "fraction_retrain_measured", "-", "fraction", ")", "<=", "tolerance", ")", "\n", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model_to_retrain", ".", "parameters", "(", ")", ")", "\n", "logger", ".", "info", "(", "f\"{total_params} total parameters.\"", ")", "\n", "total_trainable_params", "=", "sum", "(", "\n", "p", ".", "numel", "(", ")", "for", "p", "in", "model_to_retrain", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "logger", ".", "info", "(", "f\"{total_trainable_params} parameters to retrain.\"", ")", "\n", "assert", "(", "total_params", ">", "total_trainable_params", ")", "\n", "\n", "# Check reset weights", "\n", "reset_list", "=", "[", "(", "p1", ".", "data", ".", "ne", "(", "p2", ".", "data", ")", ".", "sum", "(", ")", ">", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "p1", ",", "p2", "in", "zip", "(", "model_pretrained", ".", "parameters", "(", ")", ",", "model_to_retrain", ".", "parameters", "(", ")", ")", "]", "\n", "reset_measured", "=", "sum", "(", "reset_list", ")", "*", "1.0", "/", "len", "(", "reset_list", ")", "\n", "logger", ".", "info", "(", "f\"\\nMeasure: reset fraction of the model: {round(reset_measured, 1)}\"", ")", "\n", "assert", "(", "abs", "(", "reset_measured", "-", "fraction", ")", "<=", "tolerance", ")", "\n", "# weights_reset = False", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_transfer_learning.teardown_function": [[66, 68], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.setup_function": [[22, 24], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_bids_df_microscopy_png": [[26, 50], ["pytest.mark.parametrize", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df.drop", "df_test.sort_values().reset_index.sort_values().reset_index", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.to_csv", "csv_diff.compare", "csv_diff.load_csv", "csv_diff.load_csv", "df_test.sort_values().reset_index.sort_values", "open", "open", "str", "pathlib.Path"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "[", "\"_seg-myelin-manual\"", ",", "\"_seg-axon-manual\"", "]", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", "}", "\n", "}", "]", ")", "\n", "def", "test_bids_df_microscopy_png", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test for microscopy png file format\n    Test for _sessions.tsv and _scans.tsv files\n    Test for target_suffix as a nested list\n    Test for when no contrast_params are provided\n    \"\"\"", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "df_test", "=", "bids_df", ".", "df", ".", "drop", "(", "columns", "=", "[", "'path'", "]", ")", "\n", "df_test", "=", "df_test", ".", "sort_values", "(", "by", "=", "[", "'filename'", "]", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "csv_ref", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_ref.csv\"", ")", "\n", "csv_test", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_test.csv\"", ")", "\n", "df_test", ".", "to_csv", "(", "csv_test", ",", "index", "=", "False", ")", "\n", "diff", "=", "csv_diff", ".", "compare", "(", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_ref", ")", ")", ",", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_test", ")", ")", ")", "\n", "assert", "diff", "==", "{", "'added'", ":", "[", "]", ",", "'removed'", ":", "[", "]", ",", "'changed'", ":", "[", "]", ",", "'columns_added'", ":", "[", "]", ",", "'columns_removed'", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_bids_df_anat": [[52, 76], ["pytest.mark.parametrize", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df.drop", "df_test.sort_values().reset_index.sort_values().reset_index", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.to_csv", "csv_diff.compare", "csv_diff.load_csv", "csv_diff.load_csv", "df_test.sort_values().reset_index.sort_values", "open", "open"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", "]", ",", "\n", "\"target_suffix\"", ":", "[", "\"_lesion-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "\"_seg-manual\"", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "\"T1w\"", ",", "\"T2w\"", "]", "}", "\n", "}", "]", ")", "\n", "def", "test_bids_df_anat", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test for MRI anat nii.gz file format\n    Test for when no file extensions are provided\n    Test for multiple target_suffix\n    Test behavior when \"roi_suffix\" is not None\n    \"\"\"", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "df_test", "=", "bids_df", ".", "df", ".", "drop", "(", "columns", "=", "[", "'path'", "]", ")", "\n", "df_test", "=", "df_test", ".", "sort_values", "(", "by", "=", "[", "'filename'", "]", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "csv_ref", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_ref.csv\"", ")", "\n", "csv_test", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_test.csv\"", ")", "\n", "df_test", ".", "to_csv", "(", "csv_test", ",", "index", "=", "False", ")", "\n", "diff", "=", "csv_diff", ".", "compare", "(", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_ref", ")", ")", ",", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_test", ")", ")", ")", "\n", "assert", "diff", "==", "{", "'added'", ":", "[", "]", ",", "'removed'", ":", "[", "]", ",", "'changed'", ":", "[", "]", ",", "\n", "'columns_added'", ":", "[", "]", ",", "'columns_removed'", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_bids_df_no_validate": [[78, 111], ["pytest.mark.parametrize", "pathlib.Path().rename", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df.drop", "df_test.sort_values().reset_index.sort_values().reset_index", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.to_csv", "csv_diff.compare", "pathlib.Path().rename", "pathlib.Path", "csv_diff.load_csv", "csv_diff.load_csv", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.sort_values", "open", "open", "pathlib.Path", "str", "pathlib.Path"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"ct_scan\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "\"ct\"", "]", "}", ",", "\n", "\"bids_validate\"", ":", "False", "\n", "}", "]", ")", "\n", "def", "test_bids_df_no_validate", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test for ct-scan nii.gz file format\n    Test for when validate_BIDS is set to False for the loader\n    \"\"\"", "\n", "\n", "# Rename files so the loader won't pick them up if validate_BIDS is true", "\n", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"sub-spleen2\"", ")", ".", "rename", "(", "\n", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"ssub-spleen2\"", ")", ")", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "df_test", "=", "bids_df", ".", "df", ".", "drop", "(", "columns", "=", "[", "'path'", "]", ")", "\n", "df_test", "=", "df_test", ".", "sort_values", "(", "by", "=", "[", "'filename'", "]", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "csv_ref", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_ref.csv\"", ")", "\n", "csv_test", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_test.csv\"", ")", "\n", "df_test", ".", "to_csv", "(", "csv_test", ",", "index", "=", "False", ")", "\n", "diff", "=", "csv_diff", ".", "compare", "(", "\n", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_ref", ")", ")", ",", "\n", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_test", ")", ")", "\n", ")", "\n", "\n", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"ssub-spleen2\"", ")", ".", "rename", "(", "\n", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"sub-spleen2\"", ")", ")", "\n", "assert", "diff", "==", "{", "'added'", ":", "[", "]", ",", "'removed'", ":", "[", "]", ",", "'changed'", ":", "[", "]", ",", "'columns_added'", ":", "[", "]", ",", "'columns_removed'", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_bids_df_multi": [[113, 135], ["pytest.mark.parametrize", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df.drop", "df_test.sort_values().reset_index.sort_values().reset_index", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.to_csv", "csv_diff.compare", "csv_diff.load_csv", "csv_diff.load_csv", "df_test.sort_values().reset_index.sort_values", "open", "open", "str", "pathlib.Path"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "__data_testing_dir__", ",", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-manual\"", ",", "\"seg-axon-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", ",", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "\"T1w\"", ",", "\"T2w\"", ",", "\"SEM\"", "]", "}", "\n", "}", "]", ")", "\n", "def", "test_bids_df_multi", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test for multiple folders in path_data\n    \"\"\"", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "df_test", "=", "bids_df", ".", "df", ".", "drop", "(", "columns", "=", "[", "'path'", "]", ")", "\n", "df_test", "=", "df_test", ".", "sort_values", "(", "by", "=", "[", "'filename'", "]", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "csv_ref", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_ref_multi.csv\"", ")", "\n", "csv_test", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_test_multi.csv\"", ")", "\n", "df_test", ".", "to_csv", "(", "csv_test", ",", "index", "=", "False", ")", "\n", "diff", "=", "csv_diff", ".", "compare", "(", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_ref", ")", ")", ",", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_test", ")", ")", ")", "\n", "assert", "diff", "==", "{", "'added'", ":", "[", "]", ",", "'removed'", ":", "[", "]", ",", "'changed'", ":", "[", "]", ",", "\n", "'columns_added'", ":", "[", "]", ",", "'columns_removed'", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_bids_df_ctscan": [[137, 159], ["pytest.mark.parametrize", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df.drop", "df_test.sort_values().reset_index.sort_values().reset_index", "pathlib.Path", "pathlib.Path", "df_test.sort_values().reset_index.to_csv", "csv_diff.compare", "csv_diff.load_csv", "csv_diff.load_csv", "df_test.sort_values().reset_index.sort_values", "open", "open", "str", "pathlib.Path"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"ct_scan\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".nii.gz\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "\"ct\"", "]", "}", "\n", "}", "]", ")", "\n", "def", "test_bids_df_ctscan", "(", "download_data_testing_test_files", ",", "loader_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test for ct-scan nii.gz file format\n    Test for when dataset_description.json is not present in derivatives folder\n    \"\"\"", "\n", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "df_test", "=", "bids_df", ".", "df", ".", "drop", "(", "columns", "=", "[", "'path'", "]", ")", "\n", "df_test", "=", "df_test", ".", "sort_values", "(", "by", "=", "[", "'filename'", "]", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "csv_ref", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_ref.csv\"", ")", "\n", "csv_test", "=", "Path", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "[", "0", "]", ",", "\"df_test.csv\"", ")", "\n", "df_test", ".", "to_csv", "(", "csv_test", ",", "index", "=", "False", ")", "\n", "diff", "=", "csv_diff", ".", "compare", "(", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_ref", ")", ")", ",", "csv_diff", ".", "load_csv", "(", "open", "(", "csv_test", ")", ")", ")", "\n", "assert", "diff", "==", "{", "'added'", ":", "[", "]", ",", "'removed'", ":", "[", "]", ",", "'changed'", ":", "[", "]", ",", "'columns_added'", ":", "[", "]", ",", "'columns_removed'", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_dropout_input": [[161, 179], ["pytest.mark.parametrize", "seg_pair[].size", "ivadomed.dropout_input", "len", "sum", "sum", "torch.rand", "torch.rand", "torch.rand", "torch.unique", "torch.rand", "torch.tensor", "torch.rand", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.dropout_input"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'seg_pair'", ",", "[", "\n", "{", "\"input\"", ":", "torch", ".", "rand", "(", "(", "2", ",", "5", ",", "5", ")", ")", "}", ",", "\n", "{", "\"input\"", ":", "torch", ".", "rand", "(", "(", "1", ",", "5", ",", "5", ")", ")", "}", ",", "\n", "{", "\"input\"", ":", "torch", ".", "rand", "(", "(", "5", ",", "5", ",", "5", ",", "5", ")", ")", "}", ",", "\n", "{", "\"input\"", ":", "(", "torch", ".", "rand", "(", "(", "5", ",", "5", ",", "5", ",", "3", ")", ")", "*", "torch", ".", "tensor", "(", "[", "1", ",", "0", ",", "1", "]", ",", "dtype", "=", "torch", ".", "float", ")", ")", ".", "transpose", "(", "0", ",", "-", "1", ")", "}", ",", "\n", "{", "\"input\"", ":", "(", "torch", ".", "rand", "(", "(", "7", ",", "7", ",", "4", ")", ")", "*", "torch", ".", "tensor", "(", "[", "1", ",", "0", ",", "0", ",", "0", "]", ",", "dtype", "=", "torch", ".", "float", ")", ")", ".", "transpose", "(", "0", ",", "-", "1", ")", "}", "\n", "]", ")", "\n", "def", "test_dropout_input", "(", "seg_pair", ")", ":", "\n", "    ", "n_channels", "=", "seg_pair", "[", "'input'", "]", ".", "size", "(", "0", ")", "\n", "seg_pair", "=", "imed_loader_utils", ".", "dropout_input", "(", "seg_pair", ")", "\n", "empty_channels", "=", "[", "len", "(", "torch", ".", "unique", "(", "input_data", ")", ")", "==", "1", "for", "input_data", "in", "seg_pair", "[", "'input'", "]", "]", "\n", "\n", "# If multichannel", "\n", "if", "n_channels", ">", "1", ":", "\n", "# Verify that there is still at least one channel remaining", "\n", "        ", "assert", "sum", "(", "empty_channels", ")", "<=", "n_channels", "\n", "", "else", ":", "\n", "        ", "assert", "sum", "(", "empty_channels", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_load_dataset_2d_png": [[181, 222], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "ivadomed.update_filename_to_nifti", "pathlib.Path().exists", "numpy.unique().tolist", "pathlib.Path", "numpy.unique", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-myelin-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"final_activation\"", ":", "\"sigmoid\"", ",", "\n", "\"depth\"", ":", "3", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transform_parameters'", ",", "[", "{", "\n", "\"NumpyToTensor\"", ":", "{", "}", ",", "\n", "}", "]", ")", "\n", "def", "test_load_dataset_2d_png", "(", "download_data_testing_test_files", ",", "\n", "loader_parameters", ",", "model_parameters", ",", "transform_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test to make sure load_dataset runs with 2D PNG files, writes corresponding NIfTI files,\n    and binarizes ground-truth values to 0 and 1.\n    \"\"\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "data_lst", "=", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", "]", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "fname_png", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "data_lst", "[", "0", "]", "]", "[", "'path'", "]", ".", "values", "[", "0", "]", "\n", "fname_nii", "=", "imed_loader_utils", ".", "update_filename_to_nifti", "(", "fname_png", ")", "\n", "assert", "Path", "(", "fname_nii", ")", ".", "exists", "(", ")", "==", "1", "\n", "assert", "ds", "[", "0", "]", "[", "'input'", "]", ".", "shape", "==", "(", "1", ",", "756", ",", "764", ")", "\n", "assert", "ds", "[", "0", "]", "[", "'gt'", "]", ".", "shape", "==", "(", "1", ",", "756", ",", "764", ")", "\n", "assert", "np", ".", "unique", "(", "ds", "[", "0", "]", "[", "'gt'", "]", ")", ".", "tolist", "(", ")", "==", "[", "0", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_2d_patches_and_resampling": [[224, 269], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "len", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-myelin-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"final_activation\"", ":", "\"sigmoid\"", ",", "\n", "\"depth\"", ":", "3", ",", "\n", "\"length_2D\"", ":", "[", "256", ",", "128", "]", ",", "\n", "\"stride_2D\"", ":", "[", "244", ",", "116", "]", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transform_parameters'", ",", "[", "{", "\n", "\"Resample\"", ":", "{", "\n", "\"wspace\"", ":", "0.0002", ",", "\n", "\"hspace\"", ":", "0.0001", "\n", "}", ",", "\n", "\"NumpyToTensor\"", ":", "{", "}", ",", "\n", "}", "]", ")", "\n", "def", "test_2d_patches_and_resampling", "(", "download_data_testing_test_files", ",", "\n", "loader_parameters", ",", "model_parameters", ",", "transform_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test that 2d patching is done properly.\n    Test that microscopy pixelsize and resampling are applied on the right dimensions.\n    \"\"\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "data_lst", "=", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", "]", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "assert", "ds", ".", "is_2d_patch", "==", "True", "\n", "assert", "ds", "[", "0", "]", "[", "'input'", "]", ".", "shape", "==", "(", "1", ",", "256", ",", "128", ")", "\n", "assert", "ds", "[", "0", "]", "[", "'input_metadata'", "]", "[", "0", "]", ".", "metadata", "[", "MetadataKW", ".", "INDEX_SHAPE", "]", "==", "(", "1512", ",", "382", ")", "\n", "assert", "len", "(", "ds", ")", "==", "28", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_get_target_filename_list": [[271, 306], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "len", "len", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-myelin-manual\"", ",", "\"_seg-axon-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"depth\"", ":", "2", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transform_parameters'", ",", "[", "{", "\n", "\"NumpyToTensor\"", ":", "{", "}", ",", "\n", "}", "]", ")", "\n", "def", "test_get_target_filename_list", "(", "loader_parameters", ",", "model_parameters", ",", "transform_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test that all target_suffix are considered for target filename when list\n    \"\"\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "data_lst", "=", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", "]", "\n", "test_ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "target_filename", "=", "test_ds", ".", "filename_pairs", "[", "0", "]", "[", "1", "]", "\n", "\n", "assert", "len", "(", "target_filename", ")", "==", "len", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_get_target_filename_list_multiple_raters": [[308, 345], ["pytest.mark.parametrize", "pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "len", "len", "len", "len", "len", "len", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "[", "\"_seg-myelin-manual\"", ",", "\"_seg-axon-manual\"", "]", ",", "[", "\"_seg-myelin-manual\"", ",", "\"_seg-axon-manual\"", "]", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"depth\"", ":", "2", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'transform_parameters'", ",", "[", "{", "\n", "\"NumpyToTensor\"", ":", "{", "}", ",", "\n", "}", "]", ")", "\n", "def", "test_get_target_filename_list_multiple_raters", "(", "loader_parameters", ",", "model_parameters", ",", "transform_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test that all target_suffix are considered for target filename when list\n    \"\"\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "data_lst", "=", "[", "'sub-rat3_ses-01_sample-data9_SEM.png'", "]", "\n", "test_ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "target_filename", "=", "test_ds", ".", "filename_pairs", "[", "0", "]", "[", "1", "]", "\n", "\n", "assert", "len", "(", "target_filename", ")", "==", "len", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", ")", "\n", "assert", "len", "(", "target_filename", "[", "0", "]", ")", "==", "len", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", "[", "0", "]", ")", "\n", "assert", "len", "(", "target_filename", "[", "1", "]", ")", "==", "len", "(", "loader_parameters", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_microscopy_pixelsize": [[347, 400], ["pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.loader.load_dataset", "ivadomed.loader.loader.load_dataset", "ivadomed.loader.loader.load_dataset", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"microscopy_png\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-myelin-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"final_activation\"", ":", "\"sigmoid\"", ",", "\n", "\"depth\"", ":", "3", "\n", "}", "]", ")", "\n", "def", "test_microscopy_pixelsize", "(", "download_data_testing_test_files", ",", "loader_parameters", ",", "model_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test that PixelSize and PixelSizeUnits microscopy metadata\n    are handled properly for PixelSizeUnits: \"mm\", \"um\" and \"nm\"\n    \"\"\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "True", ")", "\n", "\n", "# PixelSizeUnits: \"mm\"", "\n", "data_lst", "=", "[", "'sub-rat2_sample-data5_SEM.png'", "]", "\n", "transform_parameters", "=", "{", "TransformationKW", ".", "RESAMPLE", ":", "{", "\"wspace\"", ":", "0.000093", ",", "\"hspace\"", ":", "0.000093", "}", "}", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "assert", "ds", "[", "0", "]", "[", "'input'", "]", ".", "shape", "==", "(", "1", ",", "725", ",", "725", ")", "\n", "\n", "# PixelSizeUnits: \"um\"", "\n", "data_lst", "=", "[", "'sub-rat3_ses-02_sample-data11_run-1_SEM.png'", "]", "\n", "transform_parameters", "=", "{", "TransformationKW", ".", "RESAMPLE", ":", "{", "\"wspace\"", ":", "0.0001", ",", "\"hspace\"", ":", "0.0001", "}", "}", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "assert", "ds", "[", "0", "]", "[", "'input'", "]", ".", "shape", "==", "(", "1", ",", "839", ",", "769", ")", "\n", "\n", "# PixelSizeUnits: \"nm\"", "\n", "data_lst", "=", "[", "'sub-rat3_ses-02_sample-data10_SEM.png'", "]", "\n", "transform_parameters", "=", "{", "TransformationKW", ".", "RESAMPLE", ":", "{", "\"wspace\"", ":", "0.0001", ",", "\"hspace\"", ":", "0.0001", "}", "}", "\n", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "\n", "**", "{", "**", "loader_parameters", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_parameters", ",", "\n", "'dataset_type'", ":", "'training'", "}", "}", ")", "\n", "assert", "ds", "[", "0", "]", "[", "'input'", "]", ".", "shape", "==", "(", "1", ",", "758", ",", "737", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_read_png_tif": [[402, 440], ["pytest.mark.parametrize", "pytest.mark.parametrize", "loader_parameters.update", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.bids_dataframe.BidsDataframe.df[].tolist", "ivadomed.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset", "imed_loader_mri2dseg.MRI2DSegmentationDataset.load_filenames", "isinstance", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'loader_parameters'", ",", "[", "{", "\n", "\"path_data\"", ":", "[", "str", "(", "Path", "(", "__data_testing_dir__", ",", "\"data_test_png_tif\"", ")", ")", "]", ",", "\n", "\"bids_config\"", ":", "f\"{path_repo_root}/ivadomed/config/config_bids.json\"", ",", "\n", "\"target_suffix\"", ":", "[", "\"_seg-myelin-manual\"", "]", ",", "\n", "\"extensions\"", ":", "[", "\".png\"", ",", "\".tif\"", "]", ",", "\n", "\"roi_params\"", ":", "{", "\"suffix\"", ":", "None", ",", "\"slice_filter_roi\"", ":", "None", "}", ",", "\n", "\"contrast_params\"", ":", "{", "\"contrast_lst\"", ":", "[", "]", ",", "\"balance\"", ":", "{", "}", "}", ",", "\n", "\"slice_axis\"", ":", "\"axial\"", ",", "\n", "\"slice_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "True", "}", ",", "\n", "\"patch_filter_params\"", ":", "{", "\"filter_empty_mask\"", ":", "False", ",", "\"filter_empty_input\"", ":", "False", "}", ",", "\n", "\"multichannel\"", ":", "False", "\n", "}", "]", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'model_parameters'", ",", "[", "{", "\n", "\"name\"", ":", "\"Unet\"", ",", "\n", "\"dropout_rate\"", ":", "0.3", ",", "\n", "\"bn_momentum\"", ":", "0.1", ",", "\n", "\"final_activation\"", ":", "\"sigmoid\"", ",", "\n", "\"depth\"", ":", "3", "\n", "}", "]", ")", "\n", "def", "test_read_png_tif", "(", "download_data_testing_test_files", ",", "loader_parameters", ",", "model_parameters", ")", ":", "\n", "    ", "\"\"\"\n    Test to make sure all combinaitions of PNG/TIF, 8/16 bits, Grayscale/RGB/RGBA files\n    can be loaded without errors.\n    \"\"\"", "\n", "metadata", "=", "{", "}", "\n", "metadata", "[", "MetadataKW", ".", "PIXEL_SIZE", "]", "=", "[", "0.07", ",", "0.07", "]", "\n", "metadata", "[", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "]", "=", "\"um\"", "\n", "loader_parameters", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_parameters", "}", ")", "\n", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "__tmp_dir__", ",", "derivatives", "=", "False", ")", "\n", "file_lst", "=", "bids_df", ".", "df", "[", "'path'", "]", ".", "tolist", "(", ")", "\n", "filename_pairs", "=", "[", "(", "file_lst", ",", "None", ",", "None", ",", "metadata", "if", "isinstance", "(", "metadata", ",", "list", ")", "else", "[", "metadata", "]", ")", "]", "\n", "slice_axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "loader_parameters", "[", "LoaderParamsKW", ".", "SLICE_AXIS", "]", "]", "\n", "ds", "=", "imed_loader_mri2dseg", ".", "MRI2DSegmentationDataset", "(", "filename_pairs", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "nibabel_cache", "=", "True", ",", "\n", "transform", "=", "[", "None", ",", "None", "]", ",", "\n", "slice_filter_fn", "=", "None", ")", "\n", "ds", ".", "load_filenames", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.test_create_cache_folder": [[441, 450], ["ivadomed.create_temp_directory", "print", "os.path.exists", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.create_temp_directory"], ["", "def", "test_create_cache_folder", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test to make sure the cache folder is created when it doesn't exist, remove it afterwards.\n    NOTE: this means this test cannot be parallelized with other tests that utilize this folder!\n    \"\"\"", "\n", "path_cache", "=", "imed_loader_utils", ".", "create_temp_directory", "(", ")", "\n", "print", "(", "path_cache", ")", "\n", "assert", "(", "os", ".", "path", ".", "exists", "(", "path_cache", ")", ")", "\n", "shutil", ".", "rmtree", "(", "path_cache", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_loader.teardown_function": [[451, 453], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.setup_function": [[11, 13], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_multi_class_dice_score": [[15, 19], ["pytest.mark.parametrize", "ivadomed.multi_class_dice_score", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.multi_class_dice_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "def", "test_multi_class_dice_score", "(", "image", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "multi_class_dice_score", "(", "image", ",", "image", ")", "\n", "assert", "results", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_mse": [[21, 25], ["pytest.mark.parametrize", "ivadomed.mse", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.mse"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "def", "test_mse", "(", "image", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "mse", "(", "image", ",", "image", ")", "\n", "assert", "results", "==", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_haussdorf_4d": [[27, 31], ["pytest.mark.parametrize", "ivadomed.hausdorff_score", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.hausdorff_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", "]", ")", ")", "\n", "def", "test_haussdorf_4d", "(", "image", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "hausdorff_score", "(", "image", ",", "image", ")", "\n", "assert", "results", "==", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_err_prec": [[34, 39], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.precision_score", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.precision_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image_2\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "def", "test_err_prec", "(", "image", ",", "image_2", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "precision_score", "(", "image", ",", "image_2", ")", "\n", "assert", "results", "==", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_err_rec": [[41, 46], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.recall_score", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.recall_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image_2\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "def", "test_err_rec", "(", "image", ",", "image_2", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "recall_score", "(", "image", ",", "image_2", ",", "err_value", "=", "1", ")", "\n", "assert", "results", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_err_spec": [[48, 53], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.specificity_score", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.specificity_score"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", "]", ")", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image_2\"", ",", "np", ".", "array", "(", "[", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", "]", ")", ")", "\n", "def", "test_err_spec", "(", "image", ",", "image_2", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "specificity_score", "(", "image", ",", "image_2", ",", "err_value", "=", "12", ")", "\n", "assert", "results", "==", "12", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_err_iou": [[55, 60], ["pytest.mark.parametrize", "pytest.mark.parametrize", "ivadomed.intersection_over_union", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.intersection_over_union"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"image_2\"", ",", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "]", ")", ")", "\n", "def", "test_err_iou", "(", "image", ",", "image_2", ")", ":", "\n", "    ", "results", "=", "imed_metrics", ".", "intersection_over_union", "(", "image", ",", "image_2", ",", "err_value", "=", "12", ")", "\n", "assert", "results", "==", "12", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_plot_roc_curve": [[62, 70], ["pathlib.Path", "ivadomed.plot_roc_curve", "pathlib.Path.is_file", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_roc_curve"], ["", "def", "test_plot_roc_curve", "(", ")", ":", "\n", "    ", "\"\"\"Test if plotting code ran.\"\"\"", "\n", "tpr", "=", "[", "0", ",", "0.1", ",", "0.5", ",", "0.6", ",", "0.9", "]", "\n", "fpr", "=", "[", "1", ",", "0.8", ",", "0.5", ",", "0.3", ",", "0.1", "]", "\n", "opt_thr_idx", "=", "3", "\n", "__output_file__", "=", "Path", "(", "__tmp_dir__", ",", "\"roc_test.png\"", ")", "\n", "imed_metrics", ".", "plot_roc_curve", "(", "tpr", ",", "fpr", ",", "opt_thr_idx", ",", "str", "(", "__output_file__", ")", ")", "\n", "assert", "__output_file__", ".", "is_file", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.test_dice_plot": [[72, 78], ["pathlib.Path", "ivadomed.plot_dice_thr", "pathlib.Path.is_file", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_dice_thr"], ["", "def", "test_dice_plot", "(", ")", ":", "\n", "    ", "thr_list", "=", "[", "0.1", ",", "0.3", ",", "0.5", ",", "0.7", "]", "\n", "dice_list", "=", "[", "0.6", ",", "0.7", ",", "0.8", ",", "0.75", "]", "\n", "__output_file__", "=", "Path", "(", "__tmp_dir__", ",", "\"test_dice.png\"", ")", "\n", "imed_metrics", ".", "plot_dice_thr", "(", "thr_list", ",", "dice_list", ",", "2", ",", "str", "(", "__output_file__", ")", ")", "\n", "assert", "__output_file__", ".", "is_file", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_metrics.teardown_function": [[80, 82], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_tensorboard_save.setup_function": [[14, 16], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_tensorboard_save.test_tensorboard_save": [[18, 38], ["torch.tensor", "torch.tensor", "torch.tensor", "pathlib.Path", "pathlib.Path.mkdir", "torch.utils.tensorboard.SummaryWriter", "ivadomed.save_img", "torch.utils.tensorboard.SummaryWriter.flush", "range", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.zeros", "numpy.zeros", "numpy.zeros", "tensorboard.backend.event_processing.event_accumulator.EventAccumulator().Reload", "len", "ivadomed.rescale_values_array", "ivadomed.rescale_values_array", "ivadomed.rescale_values_array", "str", "pathlib.Path.iterdir", "numpy.array", "numpy.array", "numpy.array", "tensorboard.backend.event_processing.event_accumulator.EventAccumulator", "summary_iterators[].Tags", "PIL.Image.open", "PIL.Image.open", "PIL.Image.open", "str", "io.BytesIO", "io.BytesIO", "io.BytesIO", "summary_iterators[].Images", "summary_iterators[].Images", "summary_iterators[].Images"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_img", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array"], ["", "def", "test_tensorboard_save", "(", ")", ":", "\n", "    ", "inp", "=", "torch", ".", "tensor", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "15", ",", "15", ")", ")", ")", "\n", "gt", "=", "torch", ".", "tensor", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "15", ",", "15", ")", ")", ")", "\n", "pred", "=", "torch", ".", "tensor", "(", "np", ".", "zeros", "(", "(", "1", ",", "1", ",", "15", ",", "15", ")", ")", ")", "\n", "dpath", "=", "Path", "(", "__tmp_dir__", ",", "\"test_tensorboard_save\"", ")", "\n", "dpath", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "str", "(", "dpath", ")", ")", "\n", "imed_visualize", ".", "save_img", "(", "writer", ",", "1", ",", "\"Training\"", ",", "inp", ",", "pred", ",", "gt", ")", "\n", "writer", ".", "flush", "(", ")", "\n", "\n", "summary_iterators", "=", "[", "EventAccumulator", "(", "str", "(", "dname", ")", ")", ".", "Reload", "(", ")", "for", "dname", "in", "dpath", ".", "iterdir", "(", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "summary_iterators", ")", ")", ":", "\n", "        ", "if", "summary_iterators", "[", "i", "]", ".", "Tags", "(", ")", "[", "'images'", "]", "==", "[", "'Training/Input'", ",", "'Training/Predictions'", ",", "'Training/Ground Truth'", "]", ":", "\n", "            ", "input_retrieve", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "io", ".", "BytesIO", "(", "summary_iterators", "[", "i", "]", ".", "Images", "(", "'Training/Input'", ")", "[", "0", "]", "[", "2", "]", ")", ")", ")", "\n", "pred_retrieve", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "io", ".", "BytesIO", "(", "summary_iterators", "[", "i", "]", ".", "Images", "(", "'Training/Predictions'", ")", "[", "0", "]", "[", "2", "]", ")", ")", ")", "\n", "gt_retrieve", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "io", ".", "BytesIO", "(", "summary_iterators", "[", "i", "]", ".", "Images", "(", "'Training/Ground Truth'", ")", "[", "0", "]", "[", "2", "]", ")", ")", ")", "\n", "\n", "", "", "assert", "np", ".", "allclose", "(", "imed_math", ".", "rescale_values_array", "(", "input_retrieve", "[", ":", ",", ":", ",", "0", "]", ",", "0", ",", "1", ")", ",", "inp", "[", "0", ",", "0", ",", ":", ",", ":", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "imed_math", ".", "rescale_values_array", "(", "pred_retrieve", "[", ":", ",", ":", ",", "0", "]", ",", "0", ",", "1", ")", ",", "pred", "[", "0", ",", "0", ",", ":", ",", ":", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "imed_math", ".", "rescale_values_array", "(", "gt_retrieve", "[", ":", ",", ":", ",", "0", "]", ",", "0", ",", "1", ")", ",", "gt", "[", "0", ",", "0", ",", ":", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_tensorboard_save.teardown_function": [[40, 42], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_rgb.setup_function": [[8, 10], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_rgb.test_save_rgb": [[12, 28], ["range", "numpy.array", "ivadomed.visualize.save_color_labels", "range", "str", "str", "range", "pathlib.Path", "pathlib.Path", "range", "range"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_color_labels"], ["", "def", "test_save_rgb", "(", "download_data_testing_test_files", ")", ":", "\n", "# Create image with shape HxWxDxC", "\n", "    ", "image", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "10", ")", "]", "for", "i", "in", "range", "(", "10", ")", "]", "for", "i", "in", "range", "(", "4", ")", "]", "for", "i", "in", "range", "(", "3", ")", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "image", "[", "0", "]", "[", "2", "]", "[", "5", "]", "[", "i", "]", "=", "1", "\n", "image", "[", "1", "]", "[", "2", "]", "[", "5", "]", "[", "i", "+", "3", "]", "=", "1", "\n", "image", "[", "2", "]", "[", "2", "]", "[", "5", "]", "[", "i", "+", "6", "]", "=", "1", "\n", "", "image_n", "=", "np", ".", "array", "(", "image", ")", "\n", "imed_visualize", ".", "save_color_labels", "(", "\n", "gt_data", "=", "image_n", ",", "\n", "binarize", "=", "False", ",", "\n", "gt_filename", "=", "str", "(", "Path", "(", "\n", "__data_testing_dir__", ",", "\n", "\"rgb_test_file.nii.gz\"", ")", ")", ",", "\n", "output_filename", "=", "str", "(", "Path", "(", "__tmp_dir__", ",", "\"rgb_test.nii.gz\"", ")", ")", ",", "\n", "slice_axis", "=", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_rgb.test_rgb_conversion": [[31, 41], ["range", "numpy.array", "torch.tensor", "ivadomed.visualize.convert_labels_to_RGB", "range", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.convert_labels_to_RGB"], ["", "def", "test_rgb_conversion", "(", ")", ":", "\n", "# Create image with shape HxWxn_classxbatch_size", "\n", "    ", "image", "=", "[", "[", "[", "[", "0", "for", "i", "in", "range", "(", "10", ")", "]", "for", "i", "in", "range", "(", "10", ")", "]", "for", "i", "in", "range", "(", "3", ")", "]", "for", "i", "in", "range", "(", "3", ")", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "image", "[", "0", "]", "[", "2", "]", "[", "5", "]", "[", "i", "]", "=", "1", "\n", "image", "[", "1", "]", "[", "2", "]", "[", "5", "]", "[", "i", "+", "3", "]", "=", "1", "\n", "image", "[", "2", "]", "[", "2", "]", "[", "5", "]", "[", "i", "+", "6", "]", "=", "1", "\n", "", "image_n", "=", "np", ".", "array", "(", "image", ")", "\n", "tensor_multi", "=", "torch", ".", "tensor", "(", "image_n", ")", "\n", "imed_visualize", ".", "convert_labels_to_RGB", "(", "tensor_multi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_rgb.teardown_function": [[43, 45], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_onnx.setup_function": [[15, 17], ["testing.unit_tests.t_utils.create_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.t_utils.create_tmp_dir"], ["def", "setup_function", "(", ")", ":", "\n", "    ", "create_tmp_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_onnx.test_onnx": [[26, 44], ["ivadomed.models.Modified3DUNet", "torch.save", "torch.tensor().unsqueeze().unsqueeze", "torch.randn", "ivadomed.utils.save_onnx_model", "torch.load", "torch.load.eval", "torch.load.detach().numpy", "ivadomed.inference.onnx_inference().numpy", "shutil.rmtree", "numpy.allclose", "PATH_MODEL.exists", "PATH_MODEL.mkdir", "nibabel.load().get_fdata().astype", "str", "torch.tensor().unsqueeze", "torch.load.detach", "ivadomed.inference.onnx_inference", "nibabel.load().get_fdata", "str", "torch.tensor", "torch.load.", "nibabel.load"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.save_onnx_model", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.onnx_inference"], ["def", "test_onnx", "(", "download_data_testing_test_files", ")", ":", "\n", "    ", "model", "=", "imed_models", ".", "Modified3DUNet", "(", "1", ",", "1", ")", "\n", "if", "not", "PATH_MODEL", ".", "exists", "(", ")", ":", "\n", "        ", "PATH_MODEL", ".", "mkdir", "(", ")", "\n", "", "torch", ".", "save", "(", "model", ",", "PATH_MODEL_PT", ")", "\n", "img", "=", "nib", ".", "load", "(", "IMAGE_PATH", ")", ".", "get_fdata", "(", ")", ".", "astype", "(", "'float32'", ")", "[", ":", "16", ",", ":", "64", ",", ":", "32", "]", "\n", "# Add batch and channel dimensions", "\n", "img_tensor", "=", "torch", ".", "tensor", "(", "img", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "dummy_input", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "32", ",", "32", ",", "32", ")", "\n", "imed_utils", ".", "save_onnx_model", "(", "model", ",", "dummy_input", ",", "str", "(", "PATH_MODEL_ONNX", ")", ")", "\n", "\n", "model", "=", "torch", ".", "load", "(", "PATH_MODEL_PT", ")", "\n", "model", ".", "eval", "(", ")", "\n", "out_pt", "=", "model", "(", "img_tensor", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "out_onnx", "=", "imed_inference", ".", "onnx_inference", "(", "str", "(", "PATH_MODEL_ONNX", ")", ",", "img_tensor", ")", ".", "numpy", "(", ")", "\n", "shutil", ".", "rmtree", "(", "PATH_MODEL", ")", "\n", "assert", "np", ".", "allclose", "(", "out_pt", ",", "out_onnx", ",", "rtol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_onnx.teardown_function": [[46, 48], ["testing.common_testing_util.remove_tmp_dir"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.testing.common_testing_util.remove_tmp_dir"], ["", "def", "teardown_function", "(", ")", ":", "\n", "    ", "remove_tmp_dir", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_multiclassdiceloss": [[13, 53], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.MultiClassDiceLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "MultiClassDiceLoss", "(", "None", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "MultiClassDiceLoss", "(", "None", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1", "/", "3", ",", "\n", "MultiClassDiceLoss", "(", "None", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1", ",", "\n", "MultiClassDiceLoss", "(", "None", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "(", "1", "+", "1", "/", "2", ")", "/", "2", ",", "\n", "MultiClassDiceLoss", "(", "None", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "(", "1", "/", "3", ")", ",", "\n", "MultiClassDiceLoss", "(", "classes_of_interest", "=", "[", "1", "]", ")", ")", "\n", "]", ")", "\n", "def", "test_multiclassdiceloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test MultiClassDiceLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_generalizeddiceloss": [[55, 102], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.GeneralizedDiceLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "-", "1.", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ",", "include_background", "=", "True", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.8", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ",", "include_background", "=", "False", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "11", "/", "16", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "3", "/", "8", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "0.0", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ",", "include_background", "=", "False", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "18", "/", "23", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", ",", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", ",", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.8", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ",", "include_background", "=", "False", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", ",", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", ",", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "11", "/", "16", ",", "\n", "GeneralizedDiceLoss", "(", "epsilon", "=", "1e-5", ",", "include_background", "=", "True", ")", ")", "\n", "]", ")", "\n", "def", "test_generalizeddiceloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test GeneralizedDiceLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_diceloss": [[104, 129], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.DiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.DiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.DiceLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "DiceLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1", "/", "3", ",", "\n", "DiceLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1", ",", "\n", "DiceLoss", "(", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_diceloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test DiceLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_tverskyloss": [[131, 176], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.TverskyLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.625", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.417", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.3", ",", "beta", "=", "0.7", ",", "smooth", "=", "1.", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.0071", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.3", ",", "beta", "=", "0.7", ",", "smooth", "=", "0.01", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.3", ",", "beta", "=", "0.7", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "(", "2", "/", "(", "1", "+", "1", ")", "+", "(", "1", "/", "(", "1", "+", "0.7", ")", ")", ")", "/", "2", ",", "\n", "TverskyLoss", "(", "alpha", "=", "0.3", ",", "beta", "=", "0.7", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_tverskyloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test TverskyLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_focaltverskyloss": [[178, 218], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalTverskyLoss", "loss_fct.forward.detach().cpu", "pow", "pow", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "0.52", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ",", "gamma", "=", "1.5", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "0.375", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ",", "gamma", "=", "1", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "0.0", "]", "]", ",", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "(", "pow", "(", "1", "-", "(", "2", "/", "(", "1", "+", "1", ")", ")", ",", "1", "/", "1.33", ")", "+", "pow", "(", "1", "-", "(", "1", "/", "(", "1", "+", "0.3", ")", ")", ",", "1", "/", "1.33", ")", ")", "/", "2", ",", "\n", "FocalTverskyLoss", "(", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ",", "gamma", "=", "1.33", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_focaltverskyloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test FocalTverskyLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_L2loss": [[220, 252], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.L2loss", "torch.tensor", "torch.tensor", "ivadomed.losses.L2loss", "torch.tensor", "torch.tensor", "ivadomed.losses.L2loss", "torch.tensor", "torch.tensor", "ivadomed.losses.L2loss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "L2loss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "L2loss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "1.0", ",", "\n", "L2loss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "1.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "0.375", ",", "\n", "L2loss", "(", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_L2loss", "(", "params", ")", ":", "\n", "    ", "\"\"\"test L2Loss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n\n    \"\"\"", "\n", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_adapwingloss": [[254, 286], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.AdapWingLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.AdapWingLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.AdapWingLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.AdapWingLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "0.", ",", "\n", "AdapWingLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "29.0147", ",", "\n", "AdapWingLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "41.4496", ",", "\n", "AdapWingLoss", "(", "omega", "=", "20", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "1.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "8.2703", ",", "\n", "AdapWingLoss", "(", "epsilon", "=", "2", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_adapwingloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test AdapWingLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n\n    \"\"\"", "\n", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_losscombination": [[288, 314], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.LossCombination", "torch.tensor", "torch.tensor", "ivadomed.losses.LossCombination", "torch.tensor", "torch.tensor", "ivadomed.losses.LossCombination", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.0", ",", "\n", "LossCombination", "(", "[", "\"DiceLoss\"", ",", "\"L2loss\"", "]", ",", "[", "None", ",", "None", "]", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "1.0", ",", "\n", "LossCombination", "(", "[", "\"DiceLoss\"", ",", "\"L2loss\"", "]", ",", "[", "None", ",", "None", "]", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "1.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "0.3173", ",", "\n", "LossCombination", "(", "[", "\"DiceLoss\"", ",", "\"L2loss\"", "]", ",", "[", "None", ",", "None", "]", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_losscombination", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test LossCombination class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n\n    \"\"\"", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_losses.test_focaldiceloss": [[316, 343], ["pytest.mark.parametrize", "loss_fct.forward", "math.isclose", "loss_fct.forward.detach().cpu().numpy", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalDiceLoss", "torch.tensor", "torch.tensor", "ivadomed.losses.FocalDiceLoss", "loss_fct.forward.detach().cpu", "loss_fct.forward.detach"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'params'", ",", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "-", "16.1181", ",", "\n", "FocalDiceLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "3.6897", ",", "\n", "FocalDiceLoss", "(", ")", ")", ",", "\n", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", "]", "]", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0.5", ",", "1.0", "]", ",", "[", "1.0", ",", "1.0", "]", "]", "]", "]", ")", ",", "\n", "-", "1.1619", ",", "\n", "FocalDiceLoss", "(", ")", ")", ",", "\n", "]", ")", "\n", "def", "test_focaldiceloss", "(", "params", ")", ":", "\n", "    ", "\"\"\"Test FocalDiceLoss class in ivadomed.losses.\n\n    Args:\n        params (tuple): containing input tensor, target tensor, expected value, loss function\n\n    \"\"\"", "\n", "\n", "input", ",", "target", ",", "expected_value", ",", "loss_fct", "=", "params", "\n", "loss", "=", "loss_fct", ".", "forward", "(", "input", ",", "target", ")", "\n", "assert", "isclose", "(", "loss", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "expected_value", ",", "rel_tol", "=", "1e-2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.unit_tests.test_main.test_check_multiple_raters": [[5, 15], ["pytest.mark.parametrize", "pytest.raises", "ivadomed.main.check_multiple_raters"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.check_multiple_raters"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'is_train, loader_params'", ",", "[", "\n", "(", "False", ",", "{", "\"target_suffix\"", ":", "\n", "[", "[", "\"_seg-axon-manual1\"", ",", "\"_seg-axon-manual2\"", "]", ",", "\n", "[", "\"_seg-myelin-manual1\"", ",", "\"_seg-myelin-manual2\"", "]", "]", "\n", "}", ")", "\n", "]", ")", "\n", "def", "test_check_multiple_raters", "(", "is_train", ",", "loader_params", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "SystemExit", ")", ":", "\n", "        ", "check_multiple_raters", "(", "is_train", ",", "loader_params", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.source.conf.parse_keys_section": [[46, 48], ["conf.._format_fields", "conf.._consume_fields"], "function", ["None"], ["def", "parse_keys_section", "(", "self", ",", "section", ")", ":", "\n", "    ", "return", "self", ".", "_format_fields", "(", "'Keys'", ",", "self", ".", "_consume_fields", "(", ")", ")", "\n", "", "GoogleDocstring", ".", "_parse_keys_section", "=", "parse_keys_section", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.source.conf.parse_attributes_section": [[51, 53], ["conf.._format_fields", "conf.._consume_fields"], "function", ["None"], ["def", "parse_attributes_section", "(", "self", ",", "section", ")", ":", "\n", "    ", "return", "self", ".", "_format_fields", "(", "'Attributes'", ",", "self", ".", "_consume_fields", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.source.conf.parse_class_attributes_section": [[58, 60], ["conf.._format_fields", "conf.._consume_fields"], "function", ["None"], ["def", "parse_class_attributes_section", "(", "self", ",", "section", ")", ":", "\n", "    ", "return", "self", ".", "_format_fields", "(", "'Class Attributes'", ",", "self", ".", "_consume_fields", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.source.conf.patched_parse": [[67, 71], ["conf.._unpatched_parse"], "function", ["None"], ["def", "patched_parse", "(", "self", ")", ":", "\n", "    ", "self", ".", "_sections", "[", "'keys'", "]", "=", "self", ".", "_parse_keys_section", "\n", "self", ".", "_sections", "[", "'class attributes'", "]", "=", "self", ".", "_parse_class_attributes_section", "\n", "self", ".", "_unpatched_parse", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.source.conf._patched_sphinx_jsonschema_simpletype": [[300, 344], ["_original_sphinx_jsonschema_simpletype", "_original_sphinx_jsonschema_simpletype.append", "_original_sphinx_jsonschema_simpletype.append", "_original_sphinx_jsonschema_simpletype.append", "schema[].keys", "Exception", "conf.._line", "conf.._line", "conf.._line", "conf.._cell", "isinstance", "conf.._cell", "conf.._cell", "conf.._cell", "conf.._cell", "conf.._cell", "_original_sphinx_jsonschema_simpletype.extend", "_original_sphinx_jsonschema_simpletype.append", "conf.._line", "conf.._dispatch", "conf.._cell"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["def", "_patched_sphinx_jsonschema_simpletype", "(", "self", ",", "schema", ")", ":", "\n", "    ", "\"\"\"Render the *extra* ``required`` and ``options`` schema properties for every object.\"\"\"", "\n", "rows", "=", "_original_sphinx_jsonschema_simpletype", "(", "self", ",", "schema", ")", "\n", "\n", "if", "\"required\"", "in", "schema", ":", "\n", "        ", "required", "=", "schema", "[", "\"required\"", "]", "\n", "if", "required", "not", "in", "[", "\"true\"", ",", "\"false\"", "]", ":", "\n", "            ", "raise", "Exception", "(", "\"The required argument must be one of true, false\"", ")", "\n", "", "rows", ".", "append", "(", "self", ".", "_line", "(", "self", ".", "_cell", "(", "\"required\"", ")", ",", "self", ".", "_cell", "(", "required", ")", ")", ")", "\n", "del", "schema", "[", "\"required\"", "]", "\n", "\n", "", "if", "\"range\"", "in", "schema", ":", "\n", "        ", "range", "=", "schema", "[", "\"range\"", "]", "\n", "rows", ".", "append", "(", "self", ".", "_line", "(", "self", ".", "_cell", "(", "\"range\"", ")", ",", "self", ".", "_cell", "(", "range", ")", ")", ")", "\n", "del", "schema", "[", "\"range\"", "]", "\n", "\n", "# if \"options\" in schema:", "\n", "#     rows.append(self._line(self._cell(\"options\"), self._cell(\"\")))", "\n", "#     for option in schema[\"options\"]:", "\n", "#         rows.append(self._line(self._cell(\"\"), self._cell(f\"``{option}``\"), self._cell(\"test\")))", "\n", "#", "\n", "#     del schema[\"options\"]", "\n", "\n", "", "if", "\"options\"", "in", "schema", ":", "\n", "        ", "key", "=", "\"options\"", "\n", "rows", ".", "append", "(", "self", ".", "_line", "(", "self", ".", "_cell", "(", "key", ")", ")", ")", "\n", "\n", "for", "prop", "in", "schema", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "# insert spaces around the regexp OR operator", "\n", "# allowing the regexp to be split over multiple lines.", "\n", "# proplist = prop.split('|')", "\n", "# dispprop = self._escape(' | '.join(proplist))", "\n", "            ", "dispprop", "=", "prop", "\n", "bold", "=", "'``'", "\n", "label", "=", "self", ".", "_cell", "(", "bold", "+", "dispprop", "+", "bold", ")", "\n", "\n", "if", "isinstance", "(", "schema", "[", "key", "]", "[", "prop", "]", ",", "dict", ")", ":", "\n", "                ", "obj", "=", "schema", "[", "key", "]", "[", "prop", "]", "\n", "rows", ".", "extend", "(", "self", ".", "_dispatch", "(", "obj", ",", "label", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "rows", ".", "append", "(", "self", ".", "_line", "(", "label", ",", "self", ".", "_cell", "(", "schema", "[", "key", "]", "[", "prop", "]", ")", ")", ")", "\n", "", "", "del", "schema", "[", "key", "]", "\n", "\n", "", "return", "rows", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.__init__": [[269, 276], ["scipy.ndimage.generate_binary_structure"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "postprocessing_params", ",", "data_pred", ",", "dim_lst", ",", "filename_prefix", ")", ":", "\n", "        ", "self", ".", "postprocessing_dict", "=", "postprocessing_params", "\n", "self", ".", "data_pred", "=", "data_pred", "\n", "self", ".", "filename_prefix", "=", "filename_prefix", "\n", "self", ".", "px", ",", "self", ".", "py", ",", "self", ".", "pz", "=", "dim_lst", "\n", "h", ",", "w", ",", "d", ",", "self", ".", "n_classes", "=", "self", ".", "data_pred", ".", "shape", "\n", "self", ".", "bin_struct", "=", "generate_binary_structure", "(", "3", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply": [[277, 283], ["getattr"], "methods", ["None"], ["", "def", "apply", "(", "self", ")", ":", "\n", "        ", "\"\"\"Parse postprocessing parameters and apply postprocessing steps to data.\n        \"\"\"", "\n", "for", "postprocessing", "in", "self", ".", "postprocessing_dict", ":", "\n", "            ", "getattr", "(", "self", ",", "postprocessing", ")", "(", "**", "self", ".", "postprocessing_dict", "[", "postprocessing", "]", ")", "\n", "", "return", "self", ".", "data_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.binarize_prediction": [[284, 289], ["postprocessing.threshold_predictions"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "def", "binarize_prediction", "(", "self", ",", "thr", ")", ":", "\n", "        ", "\"\"\"Binarize output.\n        \"\"\"", "\n", "if", "thr", ">=", "0", ":", "\n", "            ", "self", ".", "data_pred", "=", "threshold_predictions", "(", "self", ".", "data_pred", ",", "thr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.binarize_maxpooling": [[290, 307], ["numpy.ones", "range", "numpy.concatenate", "numpy.argmax", "numpy.zeros_like", "range"], "methods", ["None"], ["", "", "def", "binarize_maxpooling", "(", "self", ")", ":", "\n", "        ", "\"\"\"Binarize by setting to 1 the voxel having the max prediction across all classes.\n        \"\"\"", "\n", "# Generate background class", "\n", "background", "=", "np", ".", "ones", "(", "self", ".", "data_pred", "[", "...", ",", "0", "]", ".", "shape", ")", "\n", "n_class", "=", "self", ".", "data_pred", ".", "shape", "[", "-", "1", "]", "\n", "for", "c", "in", "range", "(", "n_class", ")", ":", "\n", "            ", "background", "-=", "self", ".", "data_pred", "[", "...", ",", "c", "]", "\n", "\n", "# Concatenate background class", "\n", "", "pred_with_background", "=", "np", ".", "concatenate", "(", "(", "background", "[", "...", ",", "None", "]", ",", "self", ".", "data_pred", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "# Find class with max pred", "\n", "class_pred", "=", "np", ".", "argmax", "(", "pred_with_background", ",", "axis", "=", "-", "1", ")", "\n", "self", ".", "data_pred", "=", "np", ".", "zeros_like", "(", "self", ".", "data_pred", ")", "\n", "for", "c", "in", "range", "(", "n_class", ")", ":", "\n", "            ", "self", ".", "data_pred", "[", "...", ",", "c", "]", "=", "class_pred", "==", "c", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.uncertainty": [[308, 326], ["pathlib.Path().exists", "nibabel.load().get_fdata", "ValueError", "pathlib.Path", "postprocessing.mask_predictions", "postprocessing.mask_predictions", "nibabel.load"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions"], ["", "", "def", "uncertainty", "(", "self", ",", "thr", ",", "suffix", ")", ":", "\n", "        ", "\"\"\"Removes the most uncertain predictions.\n\n        Args:\n            thr (float): Uncertainty threshold.\n            suffix (str): Suffix of uncertainty filename.\n\n        \"\"\"", "\n", "if", "thr", ">=", "0", ":", "\n", "            ", "uncertainty_path", "=", "self", ".", "filename_prefix", "+", "suffix", "\n", "if", "Path", "(", "uncertainty_path", ")", ".", "exists", "(", ")", ":", "\n", "                ", "data_uncertainty", "=", "nib", ".", "load", "(", "uncertainty_path", ")", ".", "get_fdata", "(", ")", "\n", "if", "suffix", "==", "\"_unc-iou.nii.gz\"", "or", "suffix", "==", "\"_soft.nii.gz\"", ":", "\n", "                    ", "self", ".", "data_pred", "=", "mask_predictions", "(", "self", ".", "data_pred", ",", "data_uncertainty", ">", "thr", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "data_pred", "=", "mask_predictions", "(", "self", ".", "data_pred", ",", "data_uncertainty", "<", "thr", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'No uncertainty file found.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.remove_small": [[327, 355], ["isinstance", "range", "isinstance", "ValueError", "postprocessing.remove_small_objects", "len", "numpy.round", "loguru.logger.error", "exit", "len"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.remove_small_objects"], ["", "", "", "def", "remove_small", "(", "self", ",", "unit", ",", "thr", ")", ":", "\n", "        ", "\"\"\"Remove small objects\n\n        Args:\n            unit (str): Indicates the units of the objects: \"mm3\" or \"vox\"\n            thr (int or list): Minimal object size to keep in input data.\n\n        \"\"\"", "\n", "if", "isinstance", "(", "thr", ",", "list", ")", "and", "(", "self", ".", "n_classes", "!=", "len", "(", "thr", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Length mismatch for remove small object postprocessing step: threshold length of {} \"", "\n", "\"while the number of predicted class is {}.\"", ".", "format", "(", "len", "(", "thr", ")", ",", "self", ".", "n_classes", ")", ")", "\n", "\n", "# Convert thr to list", "\n", "", "if", "isinstance", "(", "thr", ",", "int", ")", ":", "\n", "            ", "thr", "=", "[", "thr", "]", "*", "self", ".", "n_classes", "\n", "\n", "", "if", "unit", "==", "'vox'", ":", "\n", "            ", "size_min", "=", "thr", "\n", "", "elif", "unit", "==", "'mm3'", ":", "\n", "            ", "size_min", "=", "np", ".", "round", "(", "thr", "/", "(", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", ")", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "error", "(", "'Please choose a different unit for removeSmall. Choices: vox or mm3'", ")", "\n", "exit", "(", ")", "\n", "\n", "", "for", "idx", "in", "range", "(", "self", ".", "n_classes", ")", ":", "\n", "            ", "self", ".", "data_pred", "[", "...", ",", "idx", "]", "=", "remove_small_objects", "(", "data", "=", "self", ".", "data_pred", "[", "...", ",", "idx", "]", ",", "\n", "bin_structure", "=", "self", ".", "bin_struct", ",", "\n", "size_min", "=", "size_min", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.fill_holes": [[356, 362], ["postprocessing.threshold_predictions", "postprocessing.Postprocessing.fill_holes"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.fill_holes"], ["", "", "def", "fill_holes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Fill holes in the predictions\n        \"\"\"", "\n", "# Function fill_holes requires a binary input", "\n", "self", ".", "data_pred", "=", "threshold_predictions", "(", "self", ".", "data_pred", ")", "\n", "self", ".", "data_pred", "=", "fill_holes", "(", "self", ".", "data_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.keep_largest": [[363, 367], ["postprocessing.keep_largest_object"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object"], ["", "def", "keep_largest", "(", "self", ")", ":", "\n", "        ", "\"\"\"Keep largest object in prediction\n        \"\"\"", "\n", "self", ".", "data_pred", "=", "keep_largest_object", "(", "self", ".", "data_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.remove_noise": [[368, 378], ["postprocessing.mask_predictions"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions"], ["", "def", "remove_noise", "(", "self", ",", "thr", ")", ":", "\n", "        ", "\"\"\"Remove prediction values under the given threshold\n\n        Args:\n            thr (float): Threshold under which predictions are set to 0.\n\n       \"\"\"", "\n", "if", "thr", ">=", "0", ":", "\n", "            ", "mask", "=", "self", ".", "data_pred", ">", "thr", "\n", "self", ".", "data_pred", "=", "mask_predictions", "(", "self", ".", "data_pred", ",", "mask", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.nifti_capable": [[13, 34], ["functools.wraps", "isinstance", "wrapped", "nibabel.Nifti1Image", "postprocessing.nifti_capable.wrapper"], "function", ["None"], ["def", "nifti_capable", "(", "wrapped", ")", ":", "\n", "    ", "\"\"\"Decorator to make a given function compatible with input being Nifti objects.\n\n    Args:\n        wrapped: Given function.\n\n    Returns:\n        Functions' return.\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "wrapped", ")", "\n", "def", "wrapper", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "isinstance", "(", "data", ",", "nib", ".", "Nifti1Image", ")", ":", "\n", "            ", "return", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "wrapper", "(", "np", ".", "copy", "(", "np", ".", "asanyarray", "(", "data", ".", "dataobj", ")", ")", ",", "*", "args", ",", "**", "kwargs", ")", ",", "\n", "affine", "=", "data", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "data", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "", "return", "wrapped", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.binarize_with_low_threshold": [[36, 53], ["functools.wraps", "wrapped", "numpy.array_equal", "postprocessing.mask_predictions", "data.astype", "postprocessing.nifti_capable.wrapper"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions"], ["", "def", "binarize_with_low_threshold", "(", "wrapped", ")", ":", "\n", "    ", "\"\"\"Decorator to set low values (< 0.001) to 0.\n\n    Args:\n        wrapped: Given function.\n\n    Returns:\n        Functions' return.\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "wrapped", ")", "\n", "def", "wrapper", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "not", "np", ".", "array_equal", "(", "data", ",", "data", ".", "astype", "(", "bool", ")", ")", ":", "\n", "            ", "return", "mask_predictions", "(", "data", ",", "wrapper", "(", "threshold_predictions", "(", "data", ",", "thr", "=", "0.001", ")", ",", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "", "return", "wrapped", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.multilabel_capable": [[55, 76], ["functools.wraps", "wrapped", "len", "range", "numpy.array().transpose", "wrapped", "label_list.append", "numpy.array"], "function", ["None"], ["", "def", "multilabel_capable", "(", "wrapped", ")", ":", "\n", "    ", "\"\"\"Decorator to make a given function compatible multilabel images.\n\n    Args:\n        wrapped: Given function.\n\n    Returns:\n        Functions' return.\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "wrapped", ")", "\n", "def", "wrapper", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "len", "(", "data", ".", "shape", ")", "==", "4", ":", "\n", "            ", "label_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "                ", "out_data", "=", "wrapped", "(", "data", "[", "...", ",", "i", "]", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "label_list", ".", "append", "(", "out_data", ")", "\n", "", "return", "np", ".", "array", "(", "label_list", ")", ".", "transpose", "(", "(", "1", ",", "2", ",", "3", ",", "0", ")", ")", "\n", "", "return", "wrapped", "(", "data", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions": [[78, 97], ["thresholded_preds.astype", "numpy.copy"], "function", ["None"], ["", "@", "nifti_capable", "\n", "def", "threshold_predictions", "(", "predictions", ",", "thr", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Threshold a soft (i.e. not binary) array of predictions given a threshold value, and returns\n    a binary array.\n\n    Args:\n        predictions (ndarray or nibabel object): Image to binarize.\n        thr (float): Threshold value: voxels with a value < to thr are assigned 0 as value, 1\n            otherwise.\n\n    Returns:\n        ndarray: ndarray or nibabel (same object as the input) containing only zeros or ones. Output type is int.\n    \"\"\"", "\n", "thresholded_preds", "=", "np", ".", "copy", "(", "predictions", ")", "[", ":", "]", "\n", "low_values_indices", "=", "thresholded_preds", "<", "thr", "\n", "thresholded_preds", "[", "low_values_indices", "]", "=", "0", "\n", "low_values_indices", "=", "thresholded_preds", ">=", "thr", "\n", "thresholded_preds", "[", "low_values_indices", "]", "=", "1", "\n", "return", "thresholded_preds", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object": [[99, 117], ["scipy.ndimage.label", "numpy.copy", "numpy.where", "[].argmax", "numpy.bincount"], "function", ["None"], ["", "@", "nifti_capable", "\n", "@", "binarize_with_low_threshold", "\n", "def", "keep_largest_object", "(", "predictions", ")", ":", "\n", "    ", "\"\"\"Keep the largest connected object from the input array (2D or 3D).\n\n    Args:\n        predictions (ndarray or nibabel object): Input segmentation. Image could be 2D or 3D.\n\n    Returns:\n        ndarray or nibabel (same object as the input).\n    \"\"\"", "\n", "# Find number of closed objects using skimage \"label\"", "\n", "labeled_obj", ",", "num_obj", "=", "label", "(", "np", ".", "copy", "(", "predictions", ")", ")", "\n", "# If more than one object is found, keep the largest one", "\n", "if", "num_obj", ">", "1", ":", "\n", "# Keep the largest object", "\n", "        ", "predictions", "[", "np", ".", "where", "(", "labeled_obj", "!=", "(", "np", ".", "bincount", "(", "labeled_obj", ".", "flat", ")", "[", "1", ":", "]", ".", "argmax", "(", ")", "+", "1", ")", ")", "]", "=", "0", "\n", "", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object_per_slice": [[119, 139], ["numpy.split", "range", "numpy.stack", "len", "postprocessing.keep_largest_object", "list_preds_out.append", "numpy.squeeze"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object"], ["", "@", "nifti_capable", "\n", "def", "keep_largest_object_per_slice", "(", "predictions", ",", "axis", "=", "2", ")", ":", "\n", "    ", "\"\"\"Keep the largest connected object for each 2D slice, along a specified axis.\n\n    Args:\n        predictions (ndarray or nibabel object): Input segmentation. Image could be 2D or 3D.\n        axis (int): 2D slices are extracted along this axis.\n\n    Returns:\n        ndarray or nibabel (same object as the input).\n    \"\"\"", "\n", "# Split the 3D input array as a list of slice along axis", "\n", "list_preds_in", "=", "np", ".", "split", "(", "predictions", ",", "predictions", ".", "shape", "[", "axis", "]", ",", "axis", "=", "axis", ")", "\n", "# Init list of processed slices", "\n", "list_preds_out", "=", "[", "]", "\n", "# Loop across the slices along the given axis", "\n", "for", "idx", "in", "range", "(", "len", "(", "list_preds_in", ")", ")", ":", "\n", "        ", "slice_processed", "=", "keep_largest_object", "(", "np", ".", "squeeze", "(", "list_preds_in", "[", "idx", "]", ",", "axis", "=", "axis", ")", ")", "\n", "list_preds_out", ".", "append", "(", "slice_processed", ")", "\n", "", "return", "np", ".", "stack", "(", "list_preds_out", ",", "axis", "=", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.fill_holes": [[141, 158], ["numpy.array_equal", "scipy.ndimage.binary_fill_holes().astype", "predictions.astype", "len", "len", "scipy.ndimage.binary_fill_holes", "numpy.ones"], "function", ["None"], ["", "@", "nifti_capable", "\n", "@", "multilabel_capable", "\n", "def", "fill_holes", "(", "predictions", ",", "structure", "=", "(", "3", ",", "3", ",", "3", ")", ")", ":", "\n", "    ", "\"\"\"Fill holes in the predictions using a given structuring element.\n    Note: This function only works for binary segmentation.\n\n    Args:\n        predictions (ndarray or nibabel object): Input binary segmentation. Image could be 2D or 3D.\n        structure (tuple of integers): Structuring element, number of ints equals\n            number of dimensions in the input array.\n\n    Returns:\n        ndrray or nibabel (same object as the input). Output type is int.\n    \"\"\"", "\n", "assert", "np", ".", "array_equal", "(", "predictions", ",", "predictions", ".", "astype", "(", "bool", ")", ")", "\n", "assert", "len", "(", "structure", ")", "==", "len", "(", "predictions", ".", "shape", ")", "\n", "return", "binary_fill_holes", "(", "predictions", ",", "structure", "=", "np", ".", "ones", "(", "structure", ")", ")", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.mask_predictions": [[160, 174], ["numpy.array_equal", "mask_binary.astype"], "function", ["None"], ["", "@", "nifti_capable", "\n", "def", "mask_predictions", "(", "predictions", ",", "mask_binary", ")", ":", "\n", "    ", "\"\"\"Mask predictions using a binary mask: sets everything outside the mask to zero.\n\n    Args:\n        predictions (ndarray or nibabel object): Input binary segmentation. Image could be 2D or 3D.\n        mask_binary (ndarray): Numpy array with the same shape as predictions, containing only zeros or ones.\n\n    Returns:\n        ndarray or nibabel (same object as the input).\n    \"\"\"", "\n", "assert", "predictions", ".", "shape", "==", "mask_binary", ".", "shape", "\n", "assert", "np", ".", "array_equal", "(", "mask_binary", ",", "mask_binary", ".", "astype", "(", "bool", ")", ")", "\n", "return", "predictions", "*", "mask_binary", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.coordinate_from_heatmap": [[176, 192], ["numpy.array", "skimage.feature.peak_local_max"], "function", ["None"], ["", "def", "coordinate_from_heatmap", "(", "nifti_image", ",", "thresh", "=", "0.3", ")", ":", "\n", "    ", "\"\"\"\n    Retrieve coordinates of local maxima in a soft segmentation.\n    Args:\n        nifti_image (nibabel object): nifti image of the soft segmentation.\n        thresh (float): Relative threshold for local maxima, i.e., after normalizing\n        the min and max between 0 and 1, respectively.\n\n    Returns:\n        list: A list of computed coordinates found by local maximum. each element will be a list composed of\n        [x, y, z]\n    \"\"\"", "\n", "\n", "image", "=", "np", ".", "array", "(", "nifti_image", ".", "dataobj", ")", "\n", "coordinates_tmp", "=", "peak_local_max", "(", "image", ",", "min_distance", "=", "5", ",", "threshold_rel", "=", "thresh", ")", "\n", "return", "coordinates_tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.label_file_from_coordinates": [[194, 222], ["list", "numpy.zeros", "range", "nibabel.Nifti1Image", "tuple", "len", "numpy.array", "nifti_image.header.get_best_affine"], "function", ["None"], ["", "def", "label_file_from_coordinates", "(", "nifti_image", ",", "coord_list", ")", ":", "\n", "    ", "\"\"\"\n    Creates a nifti object with single-voxel labels. Each label has a value of 1. The nifti object as the same\n    orientation as the input.\n    Args:\n        nifti_image (nibabel object): Path to the image which affine matrix will be used to generate a new image with\n        labels.\n        coord_list (list): list of coordinates. Each element is [x, y, z]. Orientation should be the same as the image\n\n    Returns:\n        nib_pred: A nifti object containing the singe-voxel label of value 1. The matrix will be the same size as\n        `nifti_image`.\n\n    \"\"\"", "\n", "\n", "imsh", "=", "list", "(", "np", ".", "array", "(", "nifti_image", ".", "dataobj", ")", ".", "shape", ")", "\n", "# create an empty 3d object.", "\n", "label_array", "=", "np", ".", "zeros", "(", "tuple", "(", "imsh", ")", ")", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "coord_list", ")", ")", ":", "\n", "        ", "label_array", "[", "coord_list", "[", "j", "]", "[", "0", "]", ",", "coord_list", "[", "j", "]", "[", "1", "]", ",", "coord_list", "[", "j", "]", "[", "2", "]", "]", "=", "1", "\n", "\n", "", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "label_array", ",", "\n", "affine", "=", "nifti_image", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", ")", "\n", "\n", "return", "nib_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.remove_small_objects": [[224, 246], ["scipy.ndimage.label", "range", "numpy.count_nonzero"], "function", ["None"], ["", "def", "remove_small_objects", "(", "data", ",", "bin_structure", ",", "size_min", ")", ":", "\n", "    ", "\"\"\"Removes all unconnected objects smaller than the minimum specified size.\n\n    Args:\n        data (ndarray): Input data.\n        bin_structure (ndarray): Structuring element that defines feature connections.\n        size_min (int): Minimal object size to keep in input data.\n\n    Returns:\n        ndarray: Array with small objects.\n    \"\"\"", "\n", "\n", "data_label", ",", "n", "=", "label", "(", "data", ",", "structure", "=", "bin_structure", ")", "\n", "\n", "for", "idx", "in", "range", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "        ", "data_idx", "=", "(", "data_label", "==", "idx", ")", ".", "astype", "(", "int", ")", "\n", "n_nonzero", "=", "np", ".", "count_nonzero", "(", "data_idx", ")", "\n", "\n", "if", "n_nonzero", "<", "size_min", ":", "\n", "            ", "data", "[", "data_label", "==", "idx", "]", "=", "0", "\n", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.run_uncertainty": [[11, 56], ["list", "tqdm.tqdm", "set", "pathlib.Path", "pathlib.Path", "pathlib.Path().iterdir", "pathlib.Path", "pathlib.Path", "file.name.split", "pathlib.Path().iterdir", "uncertainty.combine_predictions", "pathlib.Path.is_file", "uncertainty.voxelwise_uncertainty", "pathlib.Path().is_file", "uncertainty.structurewise_uncertainty", "file.name.endswith", "pathlib.Path().is_file", "pathlib.Path", "fname_pred_lst.append", "fname_pred.is_file", "fname_soft.is_file", "len", "str", "str", "str", "str", "str", "str", "pathlib.Path", "str", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.combine_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.voxelwise_uncertainty", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.structurewise_uncertainty"], ["def", "run_uncertainty", "(", "image_folder", ")", ":", "\n", "    ", "\"\"\"Compute uncertainty from model prediction.\n\n    This function loops across the model predictions (nifti masks) and estimates the uncertainty from the Monte Carlo\n    samples. Both voxel-wise and structure-wise uncertainty are estimates.\n\n    Args:\n        image_folder (str): Folder containing the Monte Carlo samples.\n    \"\"\"", "\n", "# list subj_acq prefixes", "\n", "subj_acq_lst", "=", "[", "file", ".", "name", ".", "split", "(", "'_pred'", ")", "[", "0", "]", "for", "file", "in", "Path", "(", "image_folder", ")", ".", "iterdir", "(", ")", "\n", "if", "file", ".", "name", ".", "endswith", "(", "'.nii.gz'", ")", "and", "'_pred'", "in", "file", ".", "name", "]", "\n", "# remove duplicates", "\n", "subj_acq_lst", "=", "list", "(", "set", "(", "subj_acq_lst", ")", ")", "\n", "# keep only the images where unc has not been computed yet", "\n", "subj_acq_lst", "=", "[", "file", "for", "file", "in", "subj_acq_lst", "if", "not", "Path", "(", "image_folder", ",", "file", "+", "'_unc-cv.nii.gz'", ")", ".", "is_file", "(", ")", "]", "\n", "\n", "# loop across subj_acq", "\n", "for", "subj_acq", "in", "tqdm", "(", "subj_acq_lst", ",", "desc", "=", "\"Uncertainty Computation\"", ")", ":", "\n", "# hard segmentation from MC samples", "\n", "        ", "fname_pred", ":", "Path", "=", "Path", "(", "image_folder", ",", "subj_acq", "+", "'_pred.nii.gz'", ")", "\n", "# fname for soft segmentation from MC simulations", "\n", "fname_soft", ":", "Path", "=", "Path", "(", "image_folder", ",", "subj_acq", "+", "'_soft.nii.gz'", ")", "\n", "# find Monte Carlo simulations", "\n", "fname_pred_lst", ":", "List", "[", "str", "]", "=", "[", "]", "\n", "for", "file", "in", "Path", "(", "image_folder", ")", ".", "iterdir", "(", ")", ":", "\n", "            ", "if", "subj_acq", "+", "'_pred_'", "in", "file", ".", "name", "and", "(", "'_painted'", "not", "in", "file", ".", "name", ")", "and", "(", "'_color'", "not", "in", "file", ".", "name", ")", ":", "\n", "                ", "fname_pred_lst", ".", "append", "(", "str", "(", "file", ")", ")", "\n", "\n", "# if final segmentation from Monte Carlo simulations has not been generated yet", "\n", "", "", "if", "not", "fname_pred", ".", "is_file", "(", ")", "or", "not", "fname_soft", ".", "is_file", "(", ")", ":", "\n", "# threshold used for the hard segmentation", "\n", "            ", "thr", "=", "1.", "/", "len", "(", "fname_pred_lst", ")", "# 1 for all voxels where at least on MC sample predicted 1", "\n", "# average then argmax", "\n", "combine_predictions", "(", "fname_pred_lst", ",", "str", "(", "fname_pred", ")", ",", "str", "(", "fname_soft", ")", ",", "thr", "=", "thr", ")", "\n", "\n", "", "fname_unc_vox", "=", "Path", "(", "image_folder", ",", "subj_acq", "+", "'_unc-vox.nii.gz'", ")", "\n", "if", "not", "fname_unc_vox", ".", "is_file", "(", ")", ":", "\n", "# compute voxel-wise uncertainty map", "\n", "            ", "voxelwise_uncertainty", "(", "fname_pred_lst", ",", "str", "(", "fname_unc_vox", ")", ")", "\n", "\n", "", "fname_unc_struct", "=", "Path", "(", "image_folder", ",", "subj_acq", "+", "'_unc.nii.gz'", ")", "\n", "if", "not", "Path", "(", "image_folder", ",", "subj_acq", "+", "'_unc-cv.nii.gz'", ")", ".", "is_file", "(", ")", ":", "\n", "# compute structure-wise uncertainty", "\n", "            ", "structurewise_uncertainty", "(", "fname_pred_lst", ",", "str", "(", "fname_pred", ")", ",", "str", "(", "fname_unc_vox", ")", ",", "str", "(", "fname_unc_struct", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.combine_predictions": [[58, 94], ["numpy.array", "numpy.mean", "nibabel.Nifti1Image", "nibabel.save", "ivadomed.postprocessing.threshold_predictions().astype", "nibabel.Nifti1Image", "nibabel.save", "nibabel.load", "nibabel.load().get_fdata", "first_file_header.get_best_affine", "first_file_header.copy", "ivadomed.postprocessing.threshold_predictions", "first_file_header.get_best_affine", "first_file_header.copy", "nibabel.load"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "", "", "def", "combine_predictions", "(", "fname_lst", ",", "fname_hard", ",", "fname_prob", ",", "thr", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Combine predictions from Monte Carlo simulations.\n\n    Combine predictions from Monte Carlo simulations and save the resulting as:\n        (1) `fname_prob`, a soft segmentation obtained by averaging the Monte Carlo samples.\n        (2) `fname_hard`, a hard segmentation obtained thresholding with `thr`.\n\n    Args:\n        fname_lst (list of str): List of the Monte Carlo samples.\n        fname_hard (str): Filename for the output hard segmentation.\n        fname_prob (str): Filename for the output soft segmentation.\n        thr (float): Between 0 and 1. Used to threshold the soft segmentation and generate the hard segmentation.\n    \"\"\"", "\n", "# collect all MC simulations", "\n", "mc_data", "=", "np", ".", "array", "(", "[", "nib", ".", "load", "(", "fname", ")", ".", "get_fdata", "(", ")", "for", "fname", "in", "fname_lst", "]", ")", "\n", "first_file_header", "=", "nib", ".", "load", "(", "fname_lst", "[", "0", "]", ")", ".", "header", "\n", "\n", "# average over all the MC simulations", "\n", "data_prob", "=", "np", ".", "mean", "(", "mc_data", ",", "axis", "=", "0", ")", "\n", "# save prob segmentation", "\n", "nib_prob", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "data_prob", ",", "\n", "affine", "=", "first_file_header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "first_file_header", ".", "copy", "(", ")", "\n", ")", "\n", "nib", ".", "save", "(", "nib_prob", ",", "fname_prob", ")", "\n", "\n", "# argmax operator", "\n", "data_hard", "=", "imed_postpro", ".", "threshold_predictions", "(", "data_prob", ",", "thr", "=", "thr", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "# save hard segmentation", "\n", "nib_hard", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "data_hard", ",", "\n", "affine", "=", "first_file_header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "first_file_header", ".", "copy", "(", ")", "\n", ")", "\n", "nib", ".", "save", "(", "nib_hard", ",", "fname_hard", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.voxelwise_uncertainty": [[96, 121], ["numpy.array", "nibabel.load().header.get_best_affine", "numpy.repeat", "nibabel.Nifti1Image", "nibabel.save", "numpy.expand_dims", "numpy.sum", "nibabel.load().get_fdata", "nibabel.load", "numpy.mean", "numpy.log", "nibabel.load", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "voxelwise_uncertainty", "(", "fname_lst", ",", "fname_out", ",", "eps", "=", "1e-5", ")", ":", "\n", "    ", "\"\"\"Estimate voxel wise uncertainty.\n\n    Voxel-wise uncertainty is estimated as entropy over all N MC probability maps, and saved in `fname_out`.\n\n    Args:\n        fname_lst (list of str): List of the Monte Carlo samples.\n        fname_out (str): Output filename.\n        eps (float): Epsilon value to deal with np.log(0).\n    \"\"\"", "\n", "# collect all MC simulations", "\n", "mc_data", "=", "np", ".", "array", "(", "[", "nib", ".", "load", "(", "fname", ")", ".", "get_fdata", "(", ")", "for", "fname", "in", "fname_lst", "]", ")", "\n", "affine", "=", "nib", ".", "load", "(", "fname_lst", "[", "0", "]", ")", ".", "header", ".", "get_best_affine", "(", ")", "\n", "\n", "# entropy", "\n", "unc", "=", "np", ".", "repeat", "(", "np", ".", "expand_dims", "(", "mc_data", ",", "-", "1", ")", ",", "2", ",", "-", "1", ")", "# n_it, x, y, z, 2", "\n", "unc", "[", "...", ",", "0", "]", "=", "1", "-", "unc", "[", "...", ",", "1", "]", "\n", "unc", "=", "-", "np", ".", "sum", "(", "np", ".", "mean", "(", "unc", ",", "0", ")", "*", "np", ".", "log", "(", "np", ".", "mean", "(", "unc", ",", "0", ")", "+", "eps", ")", ",", "-", "1", ")", "\n", "\n", "# Clip values to 0", "\n", "unc", "[", "unc", "<", "0", "]", "=", "0", "\n", "\n", "# save uncertainty map", "\n", "nib_unc", "=", "nib", ".", "Nifti1Image", "(", "unc", ",", "affine", ")", "\n", "nib", ".", "save", "(", "nib_unc", ",", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.structurewise_uncertainty": [[123, 251], ["numpy.array", "nibabel.load", "nib.load.get_fdata", "nibabel.load().get_fdata", "range", "nibabel.Nifti1Image", "nibabel.Nifti1Image", "nibabel.Nifti1Image", "nibabel.save", "nibabel.save", "nibabel.save", "scipy.ndimage.generate_binary_structure", "nibabel.load().get_fdata", "mc_dict[].append", "mc_dict[].append", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.unique", "scipy.ndimage.label", "range", "nibabel.load", "numpy.where", "range", "numpy.logical_and", "numpy.logical_or", "range", "numpy.mean", "numpy.std", "numpy.mean", "fname_out.split", "fname_out.split", "fname_out.split", "nib.load.header.get_best_affine", "nib.load.header.copy", "nib.load.header.get_best_affine", "nib.load.header.copy", "nib.load.header.get_best_affine", "nib.load.header.copy", "nibabel.load", "scipy.ndimage.label", "range", "len", "numpy.unique", "numpy.zeros", "data_class_obj_mc.append", "len", "numpy.logical_and", "numpy.logical_or", "numpy.sum", "numpy.sum", "range", "np.zeros.astype", "numpy.sum", "range", "numpy.array", "len", "len", "numpy.argmax"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "structurewise_uncertainty", "(", "fname_lst", ",", "fname_hard", ",", "fname_unc_vox", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"Estimate structure wise uncertainty.\n\n    Structure-wise uncertainty from N MC probability maps (`fname_lst`) and saved in `fname_out` with the following\n    suffixes:\n\n        * '-cv.nii.gz': coefficient of variation\n        * '-iou.nii.gz': intersection over union\n        * '-avgUnc.nii.gz': average voxel-wise uncertainty within the structure.\n\n    Args:\n        fname_lst (list of str): List of the Monte Carlo samples.\n        fname_hard (str): Filename of the hard segmentation, which is used to compute the `avgUnc` by providing a mask\n            of the structures.\n        fname_unc_vox (str): Filename of the voxel-wise uncertainty, which is used to compute the `avgUnc`.\n        fname_out (str): Output filename.\n    \"\"\"", "\n", "# 18-connectivity", "\n", "bin_struct", "=", "np", ".", "array", "(", "generate_binary_structure", "(", "3", ",", "2", ")", ")", "\n", "\n", "# load hard segmentation", "\n", "nib_hard", "=", "nib", ".", "load", "(", "fname_hard", ")", "\n", "data_hard", "=", "nib_hard", ".", "get_fdata", "(", ")", "\n", "# Label each object of each class", "\n", "data_hard_labeled", "=", "[", "label", "(", "data_hard", "[", "...", ",", "i_class", "]", ",", "structure", "=", "bin_struct", ")", "[", "0", "]", "for", "i_class", "in", "\n", "range", "(", "data_hard", ".", "shape", "[", "-", "1", "]", ")", "]", "\n", "\n", "# load all MC simulations (in mc_dict[\"mc_data\"]) and label them (in mc_dict[\"mc_labeled\"])", "\n", "mc_dict", "=", "{", "\"mc_data\"", ":", "[", "]", ",", "\"mc_labeled\"", ":", "[", "]", "}", "\n", "for", "fname", "in", "fname_lst", ":", "\n", "        ", "data", "=", "nib", ".", "load", "(", "fname", ")", ".", "get_fdata", "(", ")", "\n", "mc_dict", "[", "\"mc_data\"", "]", ".", "append", "(", "[", "data", "[", "...", ",", "i_class", "]", "for", "i_class", "in", "range", "(", "data", ".", "shape", "[", "-", "1", "]", ")", "]", ")", "\n", "\n", "labeled_list", "=", "[", "label", "(", "data", "[", "...", ",", "i_class", "]", ",", "structure", "=", "bin_struct", ")", "[", "0", "]", "for", "i_class", "in", "range", "(", "data", ".", "shape", "[", "-", "1", "]", ")", "]", "\n", "mc_dict", "[", "\"mc_labeled\"", "]", ".", "append", "(", "labeled_list", ")", "\n", "\n", "# load uncertainty map", "\n", "", "data_uncVox", "=", "nib", ".", "load", "(", "fname_unc_vox", ")", ".", "get_fdata", "(", ")", "\n", "\n", "# Init output arrays", "\n", "data_iou", ",", "data_cv", ",", "data_avgUnc", "=", "np", ".", "zeros", "(", "data_hard", ".", "shape", ")", ",", "np", ".", "zeros", "(", "data_hard", ".", "shape", ")", ",", "np", ".", "zeros", "(", "data_hard", ".", "shape", ")", "\n", "\n", "# Loop across classes", "\n", "for", "i_class", "in", "range", "(", "data_hard", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "# Hard segmentation of the i_class that has been labeled", "\n", "        ", "data_hard_labeled_class", "=", "data_hard_labeled", "[", "i_class", "]", "\n", "# Get number of objects in", "\n", "l", ",", "l_count", "=", "np", ".", "unique", "(", "data_hard_labeled_class", ",", "return_counts", "=", "True", ")", "\n", "\n", "# Get all non zero labels and exclude structure of 1 pixel", "\n", "labels", "=", "l", "[", "l_count", "!=", "1", "]", "[", "1", ":", "]", "\n", "# Loop across objects", "\n", "for", "i_obj", "in", "labels", ":", "\n", "# select the current structure, remaining voxels are set to zero", "\n", "            ", "data_hard_labeled_class_obj", "=", "(", "np", ".", "array", "(", "data_hard_labeled_class", ")", "==", "i_obj", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Get object coordinates", "\n", "xx_obj", ",", "yy_obj", ",", "zz_obj", "=", "np", ".", "where", "(", "data_hard_labeled_class_obj", ")", "\n", "\n", "# Loop across the MC samples and mask the structure of interest", "\n", "data_class_obj_mc", "=", "[", "]", "\n", "for", "i_mc", "in", "range", "(", "len", "(", "fname_lst", ")", ")", ":", "\n", "# Get index of the structure of interest in the MC sample labeled", "\n", "                ", "i_mc_labels", ",", "i_mc_counts", "=", "np", ".", "unique", "(", "data_hard_labeled_class_obj", "*", "mc_dict", "[", "\"mc_labeled\"", "]", "[", "i_mc", "]", "[", "i_class", "]", ",", "\n", "return_counts", "=", "True", ")", "\n", "i_mc_label", "=", "i_mc_labels", "[", "np", ".", "argmax", "(", "i_mc_counts", "[", "1", ":", "]", ")", "+", "1", "]", "if", "len", "(", "i_mc_counts", ")", ">", "1", "else", "0", "\n", "\n", "data_tmp", "=", "np", ".", "zeros", "(", "mc_dict", "[", "\"mc_data\"", "]", "[", "i_mc", "]", "[", "i_class", "]", ".", "shape", ")", "\n", "# If i_mc_label is zero, it means the structure is not present in this mc_sample", "\n", "if", "i_mc_label", ">", "0", ":", "\n", "                    ", "data_tmp", "[", "mc_dict", "[", "\"mc_labeled\"", "]", "[", "i_mc", "]", "[", "i_class", "]", "==", "i_mc_label", "]", "=", "1.", "\n", "\n", "", "data_class_obj_mc", ".", "append", "(", "data_tmp", ".", "astype", "(", "np", ".", "bool", ")", ")", "\n", "\n", "# COMPUTE IoU", "\n", "# Init intersection and union", "\n", "", "intersection", "=", "np", ".", "logical_and", "(", "data_class_obj_mc", "[", "0", "]", ",", "data_class_obj_mc", "[", "1", "]", ")", "\n", "union", "=", "np", ".", "logical_or", "(", "data_class_obj_mc", "[", "0", "]", ",", "data_class_obj_mc", "[", "1", "]", ")", "\n", "# Loop across remaining MC samples", "\n", "for", "i_mc", "in", "range", "(", "2", ",", "len", "(", "data_class_obj_mc", ")", ")", ":", "\n", "                ", "intersection", "=", "np", ".", "logical_and", "(", "intersection", ",", "data_class_obj_mc", "[", "i_mc", "]", ")", "\n", "union", "=", "np", ".", "logical_or", "(", "union", ",", "data_class_obj_mc", "[", "i_mc", "]", ")", "\n", "# Compute float", "\n", "", "iou", "=", "np", ".", "sum", "(", "intersection", ")", "*", "1.", "/", "np", ".", "sum", "(", "union", ")", "\n", "# assign uncertainty value to the structure", "\n", "data_iou", "[", "xx_obj", ",", "yy_obj", ",", "zz_obj", ",", "i_class", "]", "=", "iou", "\n", "\n", "# COMPUTE COEFFICIENT OF VARIATION", "\n", "# List of volumes for each MC sample", "\n", "vol_mc_lst", "=", "[", "np", ".", "sum", "(", "data_class_obj_mc", "[", "i_mc", "]", ")", "for", "i_mc", "in", "range", "(", "len", "(", "data_class_obj_mc", ")", ")", "]", "\n", "# Mean volume", "\n", "mu_mc", "=", "np", ".", "mean", "(", "vol_mc_lst", ")", "\n", "# STD volume", "\n", "sigma_mc", "=", "np", ".", "std", "(", "vol_mc_lst", ")", "\n", "# Coefficient of variation", "\n", "cv", "=", "sigma_mc", "/", "mu_mc", "\n", "# assign uncertainty value to the structure", "\n", "data_cv", "[", "xx_obj", ",", "yy_obj", ",", "zz_obj", ",", "i_class", "]", "=", "cv", "\n", "\n", "# COMPUTE AVG VOXEL WISE UNC", "\n", "avgUnc", "=", "np", ".", "mean", "(", "data_uncVox", "[", "xx_obj", ",", "yy_obj", ",", "zz_obj", ",", "i_class", "]", ")", "\n", "# assign uncertainty value to the structure", "\n", "data_avgUnc", "[", "xx_obj", ",", "yy_obj", ",", "zz_obj", ",", "i_class", "]", "=", "avgUnc", "\n", "\n", "# save nifti files", "\n", "", "", "fname_iou", "=", "fname_out", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'-iou.nii.gz'", "\n", "fname_cv", "=", "fname_out", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'-cv.nii.gz'", "\n", "fname_avgUnc", "=", "fname_out", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'-avgUnc.nii.gz'", "\n", "\n", "nib_iou", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "data_iou", ",", "\n", "affine", "=", "nib_hard", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_hard", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "nib_cv", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "data_cv", ",", "\n", "affine", "=", "nib_hard", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_hard", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "nib_avgUnc", "=", "nib", ".", "Nifti1Image", "(", "\n", "data_avgUnc", ",", "\n", "affine", "=", "nib_hard", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_hard", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "\n", "nib", ".", "save", "(", "nib_iou", ",", "fname_iou", ")", "\n", "nib", ".", "save", "(", "nib_cv", ",", "fname_cv", ")", "\n", "nib", ".", "save", "(", "nib_avgUnc", ",", "fname_avgUnc", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.ImedTransform.__call__": [[87, 89], ["NotImplementedError"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"You need to implement the transform() method.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Compose.__init__": [[111, 149], ["dict_transforms.keys", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "globals", "ValueError", "list_tr_im.append", "list_tr_roi.append", "list_tr_gt.append", "hasattr", "loguru.logger.info", "globals"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["def", "__init__", "(", "self", ",", "dict_transforms", ",", "requires_undo", "=", "False", ")", ":", "\n", "        ", "list_tr_im", ",", "list_tr_gt", ",", "list_tr_roi", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "transform", "in", "dict_transforms", ".", "keys", "(", ")", ":", "\n", "            ", "parameters", "=", "dict_transforms", "[", "transform", "]", "\n", "\n", "# Get list of data type", "\n", "if", "\"applied_to\"", "in", "parameters", ":", "\n", "                ", "list_applied_to", "=", "parameters", "[", "\"applied_to\"", "]", "\n", "", "else", ":", "\n", "                ", "list_applied_to", "=", "[", "\"im\"", ",", "\"gt\"", ",", "\"roi\"", "]", "\n", "\n", "# call transform", "\n", "", "if", "transform", "in", "globals", "(", ")", ":", "\n", "                ", "if", "transform", "==", "\"NumpyToTensor\"", ":", "\n", "                    ", "continue", "\n", "", "params_cur", "=", "{", "k", ":", "parameters", "[", "k", "]", "for", "k", "in", "parameters", "if", "k", "!=", "\"applied_to\"", "and", "k", "!=", "\"preprocessing\"", "}", "\n", "transform_obj", "=", "globals", "(", ")", "[", "transform", "]", "(", "**", "params_cur", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'ERROR: {} transform is not available. '", "\n", "'Please check its compatibility with your model json file.'", ".", "format", "(", "transform", ")", ")", "\n", "\n", "# check if undo_transform method is implemented", "\n", "", "if", "requires_undo", ":", "\n", "                ", "if", "not", "hasattr", "(", "transform_obj", ",", "'undo_transform'", ")", ":", "\n", "                    ", "logger", ".", "info", "(", "'{} transform not included since no undo_transform available for it.'", ".", "format", "(", "transform", ")", ")", "\n", "continue", "\n", "\n", "", "", "if", "\"im\"", "in", "list_applied_to", ":", "\n", "                ", "list_tr_im", ".", "append", "(", "transform_obj", ")", "\n", "", "if", "\"roi\"", "in", "list_applied_to", ":", "\n", "                ", "list_tr_roi", ".", "append", "(", "transform_obj", ")", "\n", "", "if", "\"gt\"", "in", "list_applied_to", ":", "\n", "                ", "list_tr_gt", ".", "append", "(", "transform_obj", ")", "\n", "\n", "", "", "self", ".", "transform", "=", "{", "\n", "\"im\"", ":", "torchvision_transforms", ".", "Compose", "(", "list_tr_im", ")", ",", "\n", "\"gt\"", ":", "torchvision_transforms", ".", "Compose", "(", "list_tr_gt", ")", ",", "\n", "\"roi\"", ":", "torchvision_transforms", ".", "Compose", "(", "list_tr_roi", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Compose.__call__": [[150, 162], ["len", "tr", "torchvision.transforms.NumpyToTensor", "NumpyToTensor."], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", ",", "data_type", "=", "'im'", ",", "preprocessing", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "transform", "[", "data_type", "]", "is", "None", "or", "len", "(", "metadata", ")", "==", "0", ":", "\n", "# In case self.transform[data_type] is None", "\n", "            ", "return", "None", ",", "None", "\n", "", "else", ":", "\n", "            ", "for", "tr", "in", "self", ".", "transform", "[", "data_type", "]", ".", "transforms", ":", "\n", "                ", "sample", ",", "metadata", "=", "tr", "(", "sample", ",", "metadata", ")", "\n", "\n", "", "if", "not", "preprocessing", ":", "\n", "                ", "numpy_to_tensor", "=", "NumpyToTensor", "(", ")", "\n", "sample", ",", "metadata", "=", "numpy_to_tensor", "(", "sample", ",", "metadata", ")", "\n", "", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.UndoCompose.__init__": [[176, 178], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "compose", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "compose", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.UndoCompose.__call__": [[179, 189], ["torchvision.transforms.NumpyToTensor", "torchvision.transforms.NumpyToTensor.undo_transform", "tr.undo_transform"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform"], ["", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", ",", "data_type", "=", "'gt'", ")", ":", "\n", "        ", "if", "self", ".", "transforms", ".", "transform", "[", "data_type", "]", "is", "None", ":", "\n", "# In case self.transforms.transform[data_type] is None", "\n", "            ", "return", "None", ",", "None", "\n", "", "else", ":", "\n", "            ", "numpy_to_tensor", "=", "NumpyToTensor", "(", ")", "\n", "sample", ",", "metadata", "=", "numpy_to_tensor", ".", "undo_transform", "(", "sample", ",", "metadata", ")", "\n", "for", "tr", "in", "self", ".", "transforms", ".", "transform", "[", "data_type", "]", ".", "transforms", "[", ":", ":", "-", "1", "]", ":", "\n", "                ", "sample", ",", "metadata", "=", "tr", ".", "undo_transform", "(", "sample", ",", "metadata", ")", "\n", "", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.UndoTransform.__init__": [[201, 203], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transform", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.UndoTransform.__call__": [[204, 206], ["torchvision.transforms.UndoTransform.transform.undo_transform"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform"], ["", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "return", "self", ".", "transform", ".", "undo_transform", "(", "sample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.NumpyToTensor.undo_transform": [[211, 214], ["list", "sample.numpy"], "methods", ["None"], ["def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"Converts Tensor to nd array.\"\"\"", "\n", "return", "list", "(", "sample", ".", "numpy", "(", ")", ")", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.NumpyToTensor.__call__": [[215, 221], ["numpy.array", "numpy.ascontiguousarray", "torch.from_numpy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"Converts nd array to Tensor.\"\"\"", "\n", "sample", "=", "np", ".", "array", "(", "sample", ")", "\n", "# Use np.ascontiguousarray to avoid axes permutations issues", "\n", "arr_contig", "=", "np", ".", "ascontiguousarray", "(", "sample", ",", "dtype", "=", "sample", ".", "dtype", ")", "\n", "return", "torch", ".", "from_numpy", "(", "arr_contig", ")", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Resample.__init__": [[234, 238], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "hspace", ",", "wspace", ",", "dspace", "=", "1.", ")", ":", "\n", "        ", "self", ".", "hspace", "=", "hspace", "\n", "self", ".", "wspace", "=", "wspace", "\n", "self", ".", "dspace", "=", "dspace", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Resample.undo_transform": [[239, 262], ["scipy.ndimage.zoom", "data_out.astype.astype.astype", "zip"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"Resample to original resolution.\"\"\"", "\n", "assert", "MetadataKW", ".", "DATA_SHAPE", "in", "metadata", "\n", "is_2d", "=", "sample", ".", "shape", "[", "-", "1", "]", "==", "1", "\n", "\n", "# Get params", "\n", "original_shape", "=", "metadata", "[", "MetadataKW", ".", "PRE_RESAMPLE_SHAPE", "]", "\n", "current_shape", "=", "sample", ".", "shape", "\n", "params_undo", "=", "[", "x", "/", "y", "for", "x", ",", "y", "in", "zip", "(", "original_shape", ",", "current_shape", ")", "]", "\n", "if", "is_2d", ":", "\n", "            ", "params_undo", "[", "-", "1", "]", "=", "1.0", "\n", "\n", "# Undo resampling", "\n", "", "data_out", "=", "zoom", "(", "sample", ",", "\n", "zoom", "=", "params_undo", ",", "\n", "order", "=", "1", "if", "metadata", "[", "MetadataKW", ".", "DATA_TYPE", "]", "==", "'gt'", "else", "2", ")", "\n", "\n", "# Data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Resample.__call__": [[263, 292], ["list", "scipy.ndimage.zoom", "data_out.astype.astype.astype", "len"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "multichannel_capable", "# for multiple raters during training/preprocessing", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "\"\"\"Resample to a given resolution, in millimeters.\"\"\"", "\n", "# Get params", "\n", "# Voxel dimension in mm", "\n", "is_2d", "=", "sample", ".", "shape", "[", "-", "1", "]", "==", "1", "\n", "metadata", "[", "MetadataKW", ".", "PRE_RESAMPLE_SHAPE", "]", "=", "sample", ".", "shape", "\n", "# metadata is not a dictionary!", "\n", "zooms", "=", "list", "(", "metadata", "[", "MetadataKW", ".", "ZOOMS", "]", ")", "\n", "\n", "if", "len", "(", "zooms", ")", "==", "2", ":", "\n", "            ", "zooms", "+=", "[", "1.0", "]", "\n", "\n", "", "hfactor", "=", "zooms", "[", "0", "]", "/", "self", ".", "hspace", "\n", "wfactor", "=", "zooms", "[", "1", "]", "/", "self", ".", "wspace", "\n", "dfactor", "=", "zooms", "[", "2", "]", "/", "self", ".", "dspace", "\n", "params_resample", "=", "(", "hfactor", ",", "wfactor", ",", "dfactor", ")", "if", "not", "is_2d", "else", "(", "hfactor", ",", "wfactor", ",", "1.0", ")", "\n", "\n", "# Run resampling", "\n", "data_out", "=", "zoom", "(", "sample", ",", "\n", "zoom", "=", "params_resample", ",", "\n", "order", "=", "1", "if", "metadata", "[", "MetadataKW", ".", "DATA_TYPE", "]", "==", "'gt'", "else", "2", ")", "\n", "\n", "# Data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.NormalizeInstance.undo_transform": [[297, 301], ["None"], "methods", ["None"], ["@", "multichannel_capable", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# Nothing", "\n", "        ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.NormalizeInstance.__call__": [[302, 306], ["sample.std", "sample.mean"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "data_out", "=", "(", "sample", "-", "sample", ".", "mean", "(", ")", ")", "/", "sample", ".", "std", "(", ")", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.CroppableArray.__getitem__": [[314, 372], ["range", "numpy.ndarray.__getitem__", "numpy.pad", "isinstance", "tuple", "tuple", "len", "len", "all_in_slices.append", "pad.append", "all_in_slices.append", "pad.append", "isinstance", "isinstance", "slice", "slice", "all_in_slices.append", "pad.append", "numpy.ndarray.__getitem__", "slice", "tuple", "slice"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__getitem__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__getitem__"], ["def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "all_in_slices", "=", "[", "]", "\n", "pad", "=", "[", "]", "\n", "for", "dim", "in", "range", "(", "self", ".", "ndim", ")", ":", "\n", "# If the slice has no length then it's a single argument.", "\n", "# If it's just an integer then we just return, this is", "\n", "# needed for the representation to work properly", "\n", "# If it's not then create a list containing None-slices", "\n", "# for dim>=1 and continue down the loop", "\n", "            ", "try", ":", "\n", "                ", "len", "(", "item", ")", "\n", "", "except", "TypeError", ":", "\n", "                ", "if", "isinstance", "(", "item", ",", "int", ")", ":", "\n", "                    ", "return", "super", "(", ")", ".", "__getitem__", "(", "item", ")", "\n", "", "newitem", "=", "[", "slice", "(", "None", ")", "]", "*", "self", ".", "ndim", "\n", "newitem", "[", "0", "]", "=", "item", "\n", "item", "=", "newitem", "\n", "# We're out of items, just append noop slices", "\n", "", "if", "dim", ">=", "len", "(", "item", ")", ":", "\n", "                ", "all_in_slices", ".", "append", "(", "slice", "(", "0", ",", "self", ".", "shape", "[", "dim", "]", ")", ")", "\n", "pad", ".", "append", "(", "(", "0", ",", "0", ")", ")", "\n", "# We're dealing with an integer (no padding even if it's", "\n", "# out of bounds)", "\n", "", "if", "isinstance", "(", "item", "[", "dim", "]", ",", "int", ")", ":", "\n", "                ", "all_in_slices", ".", "append", "(", "slice", "(", "item", "[", "dim", "]", ",", "item", "[", "dim", "]", "+", "1", ")", ")", "\n", "pad", ".", "append", "(", "(", "0", ",", "0", ")", ")", "\n", "# Dealing with a slice, here it get's complicated, we need", "\n", "# to correctly deal with None start/stop as well as with", "\n", "# out-of-bound values and correct padding", "\n", "", "elif", "isinstance", "(", "item", "[", "dim", "]", ",", "slice", ")", ":", "\n", "# Placeholders for values", "\n", "                ", "start", ",", "stop", "=", "0", ",", "self", ".", "shape", "[", "dim", "]", "\n", "this_pad", "=", "[", "0", ",", "0", "]", "\n", "if", "item", "[", "dim", "]", ".", "start", "is", "None", ":", "\n", "                    ", "start", "=", "0", "\n", "", "else", ":", "\n", "                    ", "if", "item", "[", "dim", "]", ".", "start", "<", "0", ":", "\n", "                        ", "this_pad", "[", "0", "]", "=", "-", "item", "[", "dim", "]", ".", "start", "\n", "start", "=", "0", "\n", "", "else", ":", "\n", "                        ", "start", "=", "item", "[", "dim", "]", ".", "start", "\n", "", "", "if", "item", "[", "dim", "]", ".", "stop", "is", "None", ":", "\n", "                    ", "stop", "=", "self", ".", "shape", "[", "dim", "]", "\n", "", "else", ":", "\n", "                    ", "if", "item", "[", "dim", "]", ".", "stop", ">", "self", ".", "shape", "[", "dim", "]", ":", "\n", "                        ", "this_pad", "[", "1", "]", "=", "item", "[", "dim", "]", ".", "stop", "-", "self", ".", "shape", "[", "dim", "]", "\n", "stop", "=", "self", ".", "shape", "[", "dim", "]", "\n", "", "else", ":", "\n", "                        ", "stop", "=", "item", "[", "dim", "]", ".", "stop", "\n", "", "", "all_in_slices", ".", "append", "(", "slice", "(", "start", ",", "stop", ")", ")", "\n", "pad", ".", "append", "(", "tuple", "(", "this_pad", ")", ")", "\n", "\n", "# Let numpy deal with slicing", "\n", "", "", "ret", "=", "super", "(", ")", ".", "__getitem__", "(", "tuple", "(", "all_in_slices", ")", ")", "\n", "# and padding", "\n", "ret", "=", "np", ".", "pad", "(", "ret", ",", "tuple", "(", "pad", ")", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Crop.__init__": [[384, 386], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "self", ".", "size", "=", "size", "if", "len", "(", "size", ")", "==", "3", "else", "size", "+", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Crop._adjust_padding": [[387, 411], ["enumerate", "npad_out_tuple.append", "numpy.swapaxes", "numpy.swapaxes", "abs", "abs"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_adjust_padding", "(", "npad", ",", "sample", ")", ":", "\n", "        ", "npad_out_tuple", "=", "[", "]", "\n", "for", "idx_dim", ",", "tuple_pad", "in", "enumerate", "(", "npad", ")", ":", "\n", "            ", "pad_start", ",", "pad_end", "=", "tuple_pad", "\n", "if", "pad_start", "<", "0", "or", "pad_end", "<", "0", ":", "\n", "# Move axis of interest", "\n", "                ", "sample_reorient", "=", "np", ".", "swapaxes", "(", "sample", ",", "0", ",", "idx_dim", ")", "\n", "# Adjust pad and crop", "\n", "if", "pad_start", "<", "0", "and", "pad_end", "<", "0", ":", "\n", "                    ", "sample_crop", "=", "sample_reorient", "[", "abs", "(", "pad_start", ")", ":", "pad_end", ",", "]", "\n", "pad_end", ",", "pad_start", "=", "0", ",", "0", "\n", "", "elif", "pad_start", "<", "0", ":", "\n", "                    ", "sample_crop", "=", "sample_reorient", "[", "abs", "(", "pad_start", ")", ":", ",", "]", "\n", "pad_start", "=", "0", "\n", "", "else", ":", "# i.e. pad_end < 0:", "\n", "                    ", "sample_crop", "=", "sample_reorient", "[", ":", "pad_end", ",", "]", "\n", "pad_end", "=", "0", "\n", "# Reorient", "\n", "", "sample", "=", "np", ".", "swapaxes", "(", "sample_crop", ",", "0", ",", "idx_dim", ")", "\n", "\n", "", "npad_out_tuple", ".", "append", "(", "(", "pad_start", ",", "pad_end", ")", ")", "\n", "\n", "", "return", "npad_out_tuple", ",", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Crop.__call__": [[412, 429], ["metadata[].get", "sample.view", "sample.view"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "multichannel_capable", "# for multiple raters during training/preprocessing", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", ")", ":", "\n", "# Get params", "\n", "        ", "is_2d", "=", "sample", ".", "shape", "[", "-", "1", "]", "==", "1", "\n", "th", ",", "tw", ",", "td", "=", "self", ".", "size", "\n", "fh", ",", "fw", ",", "fd", ",", "h", ",", "w", ",", "d", "=", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", ".", "get", "(", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "# Crop data", "\n", "# Note we use here CroppableArray in order to deal with \"out of boundaries\" crop", "\n", "# e.g. if fh is negative or fh+th out of bounds, then it will pad", "\n", "if", "is_2d", ":", "\n", "            ", "data_out", "=", "sample", ".", "view", "(", "CroppableArray", ")", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "data_out", "=", "sample", ".", "view", "(", "CroppableArray", ")", "[", "fh", ":", "fh", "+", "th", ",", "fw", ":", "fw", "+", "tw", ",", "fd", ":", "fd", "+", "td", "]", "\n", "\n", "", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Crop.undo_transform": [[430, 457], ["metadata[].get", "torchvision.transforms.Crop._adjust_padding", "numpy.pad().astype", "sample.copy", "numpy.pad"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Crop._adjust_padding"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# Get crop params", "\n", "        ", "is_2d", "=", "sample", ".", "shape", "[", "-", "1", "]", "==", "1", "\n", "th", ",", "tw", ",", "td", "=", "self", ".", "size", "\n", "fh", ",", "fw", ",", "fd", ",", "h", ",", "w", ",", "d", "=", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", ".", "get", "(", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n", "# Compute params to undo transform", "\n", "pad_left", "=", "fw", "\n", "pad_right", "=", "w", "-", "pad_left", "-", "tw", "\n", "pad_top", "=", "fh", "\n", "pad_bottom", "=", "h", "-", "pad_top", "-", "th", "\n", "pad_front", "=", "fd", "if", "not", "is_2d", "else", "0", "\n", "pad_back", "=", "d", "-", "pad_front", "-", "td", "if", "not", "is_2d", "else", "0", "\n", "npad", "=", "[", "(", "pad_top", ",", "pad_bottom", ")", ",", "(", "pad_left", ",", "pad_right", ")", ",", "(", "pad_front", ",", "pad_back", ")", "]", "\n", "\n", "# Check and adjust npad if needed, i.e. if crop out of boundaries", "\n", "npad_adj", ",", "sample_adj", "=", "self", ".", "_adjust_padding", "(", "npad", ",", "sample", ".", "copy", "(", ")", ")", "\n", "\n", "# Apply padding", "\n", "data_out", "=", "np", ".", "pad", "(", "sample_adj", ",", "\n", "npad_adj", ",", "\n", "mode", "=", "'constant'", ",", "\n", "constant_values", "=", "0", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.CenterCrop.__call__": [[462, 477], ["int", "int", "int", "torchvision.transforms.Crop.__call__", "round", "round", "round"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__"], ["@", "multichannel_capable", "\n", "@", "multichannel_capable", "# for multiple raters during training/preprocessing", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# Crop parameters", "\n", "        ", "th", ",", "tw", ",", "td", "=", "self", ".", "size", "\n", "h", ",", "w", ",", "d", "=", "sample", ".", "shape", "\n", "fh", "=", "int", "(", "round", "(", "(", "h", "-", "th", ")", "/", "2.", ")", ")", "\n", "fw", "=", "int", "(", "round", "(", "(", "w", "-", "tw", ")", "/", "2.", ")", ")", "\n", "fd", "=", "int", "(", "round", "(", "(", "d", "-", "td", ")", "/", "2.", ")", ")", "\n", "params", "=", "(", "fh", ",", "fw", ",", "fd", ",", "h", ",", "w", ",", "d", ")", "\n", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "self", ".", "__class__", ".", "__name__", "]", "=", "params", "\n", "\n", "# Call base method", "\n", "return", "super", "(", ")", ".", "__call__", "(", "sample", ",", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.ROICrop.__call__": [[482, 507], ["torchvision.transforms.Crop.__call__", "scipy.ndimage.center_of_mass", "sample.astype", "int", "int", "int", "int", "int", "int", "round", "round", "round", "round", "round", "round"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__"], ["@", "multichannel_capable", "\n", "@", "multichannel_capable", "# for multiple raters during training/preprocessing", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# If crop_params are not in metadata,", "\n", "# then we are here dealing with ROI data to determine crop params", "\n", "        ", "if", "self", ".", "__class__", ".", "__name__", "not", "in", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", ":", "\n", "# Compute center of mass of the ROI", "\n", "            ", "h_roi", ",", "w_roi", ",", "d_roi", "=", "center_of_mass", "(", "sample", ".", "astype", "(", "int", ")", ")", "\n", "h_roi", ",", "w_roi", ",", "d_roi", "=", "int", "(", "round", "(", "h_roi", ")", ")", ",", "int", "(", "round", "(", "w_roi", ")", ")", ",", "int", "(", "round", "(", "d_roi", ")", ")", "\n", "th", ",", "tw", ",", "td", "=", "self", ".", "size", "\n", "th_half", ",", "tw_half", ",", "td_half", "=", "int", "(", "round", "(", "th", "/", "2.", ")", ")", ",", "int", "(", "round", "(", "tw", "/", "2.", ")", ")", ",", "int", "(", "round", "(", "td", "/", "2.", ")", ")", "\n", "\n", "# compute top left corner of the crop area", "\n", "fh", "=", "h_roi", "-", "th_half", "\n", "fw", "=", "w_roi", "-", "tw_half", "\n", "fd", "=", "d_roi", "-", "td_half", "\n", "\n", "# Crop params", "\n", "h", ",", "w", ",", "d", "=", "sample", ".", "shape", "\n", "params", "=", "(", "fh", ",", "fw", ",", "fd", ",", "h", ",", "w", ",", "d", ")", "\n", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "self", ".", "__class__", ".", "__name__", "]", "=", "params", "\n", "\n", "# Call base method", "\n", "", "return", "super", "(", ")", ".", "__call__", "(", "sample", ",", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.__init__": [[523, 525], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dilation_factor", ")", ":", "\n", "        ", "self", ".", "dil_factor", "=", "dilation_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.dilate_lesion": [[526, 543], ["scipy.ndimage.binary_dilation", "numpy.logical_xor().astype", "numpy.logical_xor"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "dilate_lesion", "(", "arr_bin", ",", "arr_soft", ",", "label_values", ")", ":", "\n", "        ", "for", "lb", "in", "label_values", ":", "\n", "# binary dilation with 1 iteration", "\n", "            ", "arr_dilated", "=", "binary_dilation", "(", "arr_bin", ",", "iterations", "=", "1", ")", "\n", "\n", "# isolate new voxels, i.e. the ones from the dilation", "\n", "new_voxels", "=", "np", ".", "logical_xor", "(", "arr_dilated", ",", "arr_bin", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# assign a soft value (]0, 1[) to the new voxels", "\n", "soft_new_voxels", "=", "lb", "*", "new_voxels", "\n", "\n", "# add the new voxels to the input mask", "\n", "arr_soft", "+=", "soft_new_voxels", "\n", "arr_bin", "=", "(", "arr_soft", ">", "0", ")", ".", "astype", "(", "int", ")", "\n", "\n", "", "return", "arr_bin", ",", "arr_soft", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.dilate_arr": [[544, 569], ["scipy.ndimage.label", "range", "numpy.sum", "numpy.sum", "arr.astype", "numpy.copy().astype", "int", "torchvision.transforms.DilateGT.dilate_lesion", "arr_bin_lst.append", "arr_soft_lst.append", "numpy.array", "numpy.array", "numpy.clip", "numpy.clip", "arr_soft_clip.astype", "arr_bin_clip.astype", "round", "numpy.copy", "range", "math.sqrt", "arr_bin_obj.sum"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.dilate_lesion"], ["", "def", "dilate_arr", "(", "self", ",", "arr", ",", "dil_factor", ")", ":", "\n", "# identify each object", "\n", "        ", "arr_labeled", ",", "lb_nb", "=", "label", "(", "arr", ".", "astype", "(", "int", ")", ")", "\n", "\n", "# loop across each object", "\n", "arr_bin_lst", ",", "arr_soft_lst", "=", "[", "]", ",", "[", "]", "\n", "for", "obj_idx", "in", "range", "(", "1", ",", "lb_nb", "+", "1", ")", ":", "\n", "            ", "arr_bin_obj", "=", "(", "arr_labeled", "==", "obj_idx", ")", ".", "astype", "(", "int", ")", "\n", "arr_soft_obj", "=", "np", ".", "copy", "(", "arr_bin_obj", ")", ".", "astype", "(", "float", ")", "\n", "# compute the number of dilation iterations depending on the size of the lesion", "\n", "nb_it", "=", "int", "(", "round", "(", "dil_factor", "*", "math", ".", "sqrt", "(", "arr_bin_obj", ".", "sum", "(", ")", ")", ")", ")", "\n", "# values of the voxels added to the input mask", "\n", "soft_label_values", "=", "[", "x", "/", "(", "nb_it", "+", "1", ")", "for", "x", "in", "range", "(", "nb_it", ",", "0", ",", "-", "1", ")", "]", "\n", "# dilate lesion", "\n", "arr_bin_dil", ",", "arr_soft_dil", "=", "self", ".", "dilate_lesion", "(", "arr_bin_obj", ",", "arr_soft_obj", ",", "soft_label_values", ")", "\n", "arr_bin_lst", ".", "append", "(", "arr_bin_dil", ")", "\n", "arr_soft_lst", ".", "append", "(", "arr_soft_dil", ")", "\n", "\n", "# sum dilated objects", "\n", "", "arr_bin_idx", "=", "np", ".", "sum", "(", "np", ".", "array", "(", "arr_bin_lst", ")", ",", "axis", "=", "0", ")", "\n", "arr_soft_idx", "=", "np", ".", "sum", "(", "np", ".", "array", "(", "arr_soft_lst", ")", ",", "axis", "=", "0", ")", "\n", "# clip values in case dilated voxels overlap", "\n", "arr_bin_clip", ",", "arr_soft_clip", "=", "np", ".", "clip", "(", "arr_bin_idx", ",", "0", ",", "1", ")", ",", "np", ".", "clip", "(", "arr_soft_idx", ",", "0.0", ",", "1.0", ")", "\n", "\n", "return", "arr_soft_clip", ".", "astype", "(", "float", ")", ",", "arr_bin_clip", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.random_holes": [[570, 591], ["numpy.copy", "numpy.where", "random.random", "random.sample", "numpy.logical_xor", "range", "int", "round"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "random_holes", "(", "arr_in", ",", "arr_soft", ",", "arr_bin", ")", ":", "\n", "        ", "arr_soft_out", "=", "np", ".", "copy", "(", "arr_soft", ")", "\n", "\n", "# coordinates of the new voxels, i.e. the ones from the dilation", "\n", "new_voxels_xx", ",", "new_voxels_yy", ",", "new_voxels_zz", "=", "np", ".", "where", "(", "np", ".", "logical_xor", "(", "arr_bin", ",", "arr_in", ")", ")", "\n", "nb_new_voxels", "=", "new_voxels_xx", ".", "shape", "[", "0", "]", "\n", "\n", "# ratio of voxels added to the input mask from the dilated mask", "\n", "new_voxel_ratio", "=", "random", ".", "random", "(", ")", "\n", "# randomly select new voxel indexes to remove", "\n", "idx_to_remove", "=", "random", ".", "sample", "(", "range", "(", "nb_new_voxels", ")", ",", "\n", "int", "(", "round", "(", "nb_new_voxels", "*", "(", "1", "-", "new_voxel_ratio", ")", ")", ")", ")", "\n", "\n", "# set to zero the here-above randomly selected new voxels", "\n", "arr_soft_out", "[", "new_voxels_xx", "[", "idx_to_remove", "]", ",", "\n", "new_voxels_yy", "[", "idx_to_remove", "]", ",", "\n", "new_voxels_zz", "[", "idx_to_remove", "]", "]", "=", "0.0", "\n", "arr_bin_out", "=", "(", "arr_soft_out", ">", "0", ")", ".", "astype", "(", "int", ")", "\n", "\n", "return", "arr_soft_out", ",", "arr_bin_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.post_processing": [[592, 612], ["scipy.ndimage.label", "range", "numpy.ones", "scipy.ndimage.binary_closing", "scipy.ndimage.binary_fill_holes", "numpy.sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "post_processing", "(", "arr_in", ",", "arr_soft", ",", "arr_bin", ",", "arr_dil", ")", ":", "\n", "# remove new object that are not connected to the input mask", "\n", "        ", "arr_labeled", ",", "lb_nb", "=", "label", "(", "arr_bin", ")", "\n", "\n", "connected_to_in", "=", "arr_labeled", "*", "arr_in", "\n", "for", "lb", "in", "range", "(", "1", ",", "lb_nb", "+", "1", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "connected_to_in", "==", "lb", ")", "==", "0", ":", "\n", "                ", "arr_soft", "[", "arr_labeled", "==", "lb", "]", "=", "0", "\n", "\n", "", "", "struct", "=", "np", ".", "ones", "(", "(", "3", ",", "3", ",", "1", ")", "if", "arr_soft", ".", "shape", "[", "2", "]", "==", "1", "else", "(", "3", ",", "3", ",", "3", ")", ")", "\n", "# binary closing", "\n", "arr_bin_closed", "=", "binary_closing", "(", "(", "arr_soft", ">", "0", ")", ".", "astype", "(", "int", ")", ",", "structure", "=", "struct", ")", "\n", "# fill binary holes", "\n", "arr_bin_filled", "=", "binary_fill_holes", "(", "arr_bin_closed", ")", "\n", "\n", "# recover the soft-value assigned to the filled-holes", "\n", "arr_soft_out", "=", "arr_bin_filled", "*", "arr_dil", "\n", "\n", "return", "arr_soft_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.__call__": [[613, 634], ["numpy.sum", "torchvision.transforms.DilateGT.dilate_arr", "gt_dil.astype"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.DilateGT.dilate_arr"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# binarize for processing", "\n", "        ", "gt_data_np", "=", "(", "sample", ">", "0.5", ")", ".", "astype", "(", "np", ".", "int_", ")", "\n", "\n", "if", "self", ".", "dil_factor", ">", "0", "and", "np", ".", "sum", "(", "sample", ")", ":", "\n", "# dilation", "\n", "            ", "gt_dil", ",", "gt_dil_bin", "=", "self", ".", "dilate_arr", "(", "gt_data_np", ",", "self", ".", "dil_factor", ")", "\n", "\n", "# random holes in dilated area", "\n", "# gt_holes, gt_holes_bin = self.random_holes(gt_data_np, gt_dil, gt_dil_bin)", "\n", "\n", "# post-processing", "\n", "# gt_pp = self.post_processing(gt_data_np, gt_holes, gt_holes_bin, gt_dil)", "\n", "\n", "# return gt_pp.astype(np.float32), metadata", "\n", "return", "gt_dil", ".", "astype", "(", "np", ".", "float32", ")", ",", "metadata", "\n", "\n", "", "else", ":", "\n", "            ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.BoundingBoxCrop.__call__": [[639, 649], ["torchvision.transforms.Crop.__call__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__"], ["@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", ")", ":", "\n", "        ", "assert", "MetadataKW", ".", "BOUNDING_BOX", "in", "metadata", "\n", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", ",", "z_min", ",", "z_max", "=", "metadata", "[", "MetadataKW", ".", "BOUNDING_BOX", "]", "\n", "x", ",", "y", ",", "z", "=", "sample", ".", "shape", "\n", "metadata", "[", "MetadataKW", ".", "CROP_PARAMS", "]", "[", "self", ".", "__class__", ".", "__name__", "]", "=", "(", "x_min", ",", "y_min", ",", "z_min", ",", "x", ",", "y", ",", "z", ")", "\n", "\n", "# Call base method", "\n", "return", "super", "(", ")", ".", "__call__", "(", "sample", ",", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomAffine.__init__": [[669, 703], ["isinstance", "ValueError", "isinstance", "isinstance", "len", "scale.append", "isinstance", "len", "translate.append", "len", "ValueError", "ValueError", "len", "len", "len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "degrees", "=", "0", ",", "translate", "=", "None", ",", "scale", "=", "None", ")", ":", "\n", "# Rotation", "\n", "        ", "if", "isinstance", "(", "degrees", ",", "numbers", ".", "Number", ")", ":", "\n", "            ", "if", "degrees", "<", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"If degrees is a single number, it must be positive.\"", ")", "\n", "", "self", ".", "degrees", "=", "(", "-", "degrees", ",", "degrees", ")", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "degrees", ",", "(", "tuple", ",", "list", ")", ")", "and", "len", "(", "degrees", ")", "==", "2", ",", "\"degrees should be a list or tuple and it must be of length 2.\"", "\n", "self", ".", "degrees", "=", "degrees", "\n", "\n", "# Scale", "\n", "", "if", "scale", "is", "not", "None", ":", "\n", "            ", "assert", "isinstance", "(", "scale", ",", "(", "tuple", ",", "list", ")", ")", "and", "(", "len", "(", "scale", ")", "==", "2", "or", "len", "(", "scale", ")", "==", "3", ")", ",", "\"scale should be a list or tuple and it must be of length 2 or 3.\"", "\n", "for", "s", "in", "scale", ":", "\n", "                ", "if", "not", "(", "0.0", "<=", "s", "<=", "1.0", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"scale values should be between 0 and 1\"", ")", "\n", "", "", "if", "len", "(", "scale", ")", "==", "2", ":", "\n", "                ", "scale", ".", "append", "(", "0.0", ")", "\n", "", "self", ".", "scale", "=", "scale", "\n", "", "else", ":", "\n", "            ", "self", ".", "scale", "=", "[", "0.", ",", "0.", ",", "0.", "]", "\n", "\n", "# Translation", "\n", "", "if", "translate", "is", "not", "None", ":", "\n", "            ", "assert", "isinstance", "(", "translate", ",", "(", "tuple", ",", "list", ")", ")", "and", "(", "len", "(", "translate", ")", "==", "2", "or", "len", "(", "translate", ")", "==", "3", ")", ",", "\"translate should be a list or tuple and it must be of length 2 or 3.\"", "\n", "for", "t", "in", "translate", ":", "\n", "                ", "if", "not", "(", "0.0", "<=", "t", "<=", "1.0", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\"translation values should be between 0 and 1\"", ")", "\n", "", "", "if", "len", "(", "translate", ")", "==", "2", ":", "\n", "                ", "translate", ".", "append", "(", "0.0", ")", "\n", "", "", "self", ".", "translate", "=", "translate", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomAffine.__call__": [[704, 777], ["numpy.array", "scipy.ndimage.affine_transform().astype", "math.radians", "list", "list.sort", "random.uniform", "random.uniform", "random.uniform", "numpy.array", "numpy.array", "numpy.array.dot", "numpy.array.dot", "numpy.random.uniform", "random.sample", "numpy.array", "shape.dot", "scipy.ndimage.affine_transform", "range", "numpy.round", "numpy.round", "numpy.round", "numpy.array", "ValueError", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# Rotation", "\n", "# If angle and metadata have been already defined for this sample, then use them", "\n", "        ", "if", "MetadataKW", ".", "ROTATION", "in", "metadata", ":", "\n", "            ", "angle", ",", "axes", "=", "metadata", "[", "MetadataKW", ".", "ROTATION", "]", "\n", "# Otherwise, get random ones", "\n", "", "else", ":", "\n", "# Get the random angle", "\n", "            ", "angle", "=", "math", ".", "radians", "(", "np", ".", "random", ".", "uniform", "(", "self", ".", "degrees", "[", "0", "]", ",", "self", ".", "degrees", "[", "1", "]", ")", ")", "\n", "# Get the two axes that define the plane of rotation", "\n", "axes", "=", "list", "(", "random", ".", "sample", "(", "range", "(", "3", "if", "sample", ".", "shape", "[", "2", "]", ">", "1", "else", "2", ")", ",", "2", ")", ")", "\n", "axes", ".", "sort", "(", ")", "\n", "# Save params", "\n", "metadata", "[", "MetadataKW", ".", "ROTATION", "]", "=", "[", "angle", ",", "axes", "]", "\n", "\n", "# Scale", "\n", "", "if", "MetadataKW", ".", "SCALE", "in", "metadata", ":", "\n", "            ", "scale_x", ",", "scale_y", ",", "scale_z", "=", "metadata", "[", "MetadataKW", ".", "SCALE", "]", "\n", "", "else", ":", "\n", "            ", "scale_x", "=", "random", ".", "uniform", "(", "1", "-", "self", ".", "scale", "[", "0", "]", ",", "1", "+", "self", ".", "scale", "[", "0", "]", ")", "\n", "scale_y", "=", "random", ".", "uniform", "(", "1", "-", "self", ".", "scale", "[", "1", "]", ",", "1", "+", "self", ".", "scale", "[", "1", "]", ")", "\n", "scale_z", "=", "random", ".", "uniform", "(", "1", "-", "self", ".", "scale", "[", "2", "]", ",", "1", "+", "self", ".", "scale", "[", "2", "]", ")", "\n", "metadata", "[", "MetadataKW", ".", "SCALE", "]", "=", "[", "scale_x", ",", "scale_y", ",", "scale_z", "]", "\n", "\n", "# Get params", "\n", "", "if", "MetadataKW", ".", "TRANSLATION", "in", "metadata", ":", "\n", "            ", "translations", "=", "metadata", "[", "MetadataKW", ".", "TRANSLATION", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "data_shape", "=", "sample", ".", "shape", "\n", "\n", "if", "self", ".", "translate", "is", "not", "None", ":", "\n", "                ", "max_dx", "=", "self", ".", "translate", "[", "0", "]", "*", "self", ".", "data_shape", "[", "0", "]", "\n", "max_dy", "=", "self", ".", "translate", "[", "1", "]", "*", "self", ".", "data_shape", "[", "1", "]", "\n", "max_dz", "=", "self", ".", "translate", "[", "2", "]", "*", "self", ".", "data_shape", "[", "2", "]", "\n", "translations", "=", "(", "np", ".", "round", "(", "np", ".", "random", ".", "uniform", "(", "-", "max_dx", ",", "max_dx", ")", ")", ",", "\n", "np", ".", "round", "(", "np", ".", "random", ".", "uniform", "(", "-", "max_dy", ",", "max_dy", ")", ")", ",", "\n", "np", ".", "round", "(", "np", ".", "random", ".", "uniform", "(", "-", "max_dz", ",", "max_dz", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "translations", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "\n", "", "metadata", "[", "MetadataKW", ".", "TRANSLATION", "]", "=", "translations", "\n", "\n", "# Do rotation", "\n", "", "shape", "=", "0.5", "*", "np", ".", "array", "(", "sample", ".", "shape", ")", "\n", "if", "axes", "==", "[", "0", ",", "1", "]", ":", "\n", "            ", "rotate", "=", "np", ".", "array", "(", "[", "[", "math", ".", "cos", "(", "angle", ")", ",", "-", "math", ".", "sin", "(", "angle", ")", ",", "0", "]", ",", "\n", "[", "math", ".", "sin", "(", "angle", ")", ",", "math", ".", "cos", "(", "angle", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "", "elif", "axes", "==", "[", "0", ",", "2", "]", ":", "\n", "            ", "rotate", "=", "np", ".", "array", "(", "[", "[", "math", ".", "cos", "(", "angle", ")", ",", "0", ",", "math", ".", "sin", "(", "angle", ")", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "-", "math", ".", "sin", "(", "angle", ")", ",", "0", ",", "math", ".", "cos", "(", "angle", ")", "]", "]", ")", "\n", "", "elif", "axes", "==", "[", "1", ",", "2", "]", ":", "\n", "            ", "rotate", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "math", ".", "cos", "(", "angle", ")", ",", "-", "math", ".", "sin", "(", "angle", ")", "]", ",", "\n", "[", "0", ",", "math", ".", "sin", "(", "angle", ")", ",", "math", ".", "cos", "(", "angle", ")", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown axes value\"", ")", "\n", "\n", "", "scale", "=", "np", ".", "array", "(", "[", "[", "1", "/", "scale_x", ",", "0", ",", "0", "]", ",", "[", "0", ",", "1", "/", "scale_y", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", "/", "scale_z", "]", "]", ")", "\n", "if", "MetadataKW", ".", "UNDO", "in", "metadata", "and", "metadata", "[", "MetadataKW", ".", "UNDO", "]", ":", "\n", "            ", "transforms", "=", "scale", ".", "dot", "(", "rotate", ")", "\n", "", "else", ":", "\n", "            ", "transforms", "=", "rotate", ".", "dot", "(", "scale", ")", "\n", "\n", "", "offset", "=", "shape", "-", "shape", ".", "dot", "(", "transforms", ")", "+", "translations", "\n", "\n", "data_out", "=", "affine_transform", "(", "sample", ",", "transforms", ".", "T", ",", "order", "=", "1", ",", "offset", "=", "offset", ",", "\n", "output_shape", "=", "sample", ".", "shape", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomAffine.undo_transform": [[778, 799], ["torchvision.transforms.RandomAffine.__call__", "scipy.ndimage.affine_transform().astype", "numpy.array", "numpy.array", "scipy.ndimage.affine_transform", "numpy.identity"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "assert", "MetadataKW", ".", "ROTATION", "in", "metadata", "\n", "assert", "MetadataKW", ".", "SCALE", "in", "metadata", "\n", "assert", "MetadataKW", ".", "TRANSLATION", "in", "metadata", "\n", "# Opposite rotation, same axes", "\n", "angle", ",", "axes", "=", "-", "metadata", "[", "MetadataKW", ".", "ROTATION", "]", "[", "0", "]", ",", "metadata", "[", "MetadataKW", ".", "ROTATION", "]", "[", "1", "]", "\n", "scale", "=", "1", "/", "np", ".", "array", "(", "metadata", "[", "MetadataKW", ".", "SCALE", "]", ")", "\n", "translation", "=", "-", "np", ".", "array", "(", "metadata", "[", "MetadataKW", ".", "TRANSLATION", "]", ")", "\n", "\n", "# Undo rotation", "\n", "dict_params", "=", "{", "MetadataKW", ".", "ROTATION", ":", "[", "angle", ",", "axes", "]", ",", "MetadataKW", ".", "SCALE", ":", "scale", ",", "\n", "MetadataKW", ".", "TRANSLATION", ":", "[", "0", ",", "0", ",", "0", "]", ",", "MetadataKW", ".", "UNDO", ":", "True", "}", "\n", "\n", "data_out", ",", "_", "=", "self", ".", "__call__", "(", "sample", ",", "dict_params", ")", "\n", "\n", "data_out", "=", "affine_transform", "(", "data_out", ",", "np", ".", "identity", "(", "3", ")", ",", "order", "=", "1", ",", "offset", "=", "translation", ",", "\n", "output_shape", "=", "sample", ".", "shape", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomReverse.__call__": [[804, 821], ["enumerate", "numpy.flip().copy", "numpy.random.randint", "numpy.flip"], "methods", ["None"], ["@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "MetadataKW", ".", "REVERSE", "in", "metadata", ":", "\n", "            ", "flip_axes", "=", "metadata", "[", "MetadataKW", ".", "REVERSE", "]", "\n", "", "else", ":", "\n", "# Flip axis booleans", "\n", "            ", "flip_axes", "=", "[", "np", ".", "random", ".", "randint", "(", "2", ")", "==", "1", "for", "_", "in", "[", "0", ",", "1", ",", "2", "]", "]", "\n", "# Save in metadata", "\n", "metadata", "[", "MetadataKW", ".", "REVERSE", "]", "=", "flip_axes", "\n", "\n", "# Run flip", "\n", "", "for", "idx_axis", ",", "flip_bool", "in", "enumerate", "(", "flip_axes", ")", ":", "\n", "            ", "if", "flip_bool", ":", "\n", "                ", "sample", "=", "np", ".", "flip", "(", "sample", ",", "axis", "=", "idx_axis", ")", ".", "copy", "(", ")", "\n", "\n", "", "", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomReverse.undo_transform": [[822, 827], ["torchvision.transforms.RandomReverse.__call__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "assert", "MetadataKW", ".", "REVERSE", "in", "metadata", "\n", "return", "self", ".", "__call__", "(", "sample", ",", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.__init__": [[838, 841], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "shift_range", ",", "prob", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "shift_range", "=", "shift_range", "\n", "self", ".", "prob", "=", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.__call__": [[842, 855], ["numpy.random.random", "numpy.random.uniform"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random", "(", ")", "<", "self", ".", "prob", ":", "\n", "# Get random offset", "\n", "            ", "offset", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "shift_range", "[", "0", "]", ",", "self", ".", "shift_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "0.0", "\n", "\n", "# Update metadata", "\n", "", "metadata", "[", "MetadataKW", ".", "OFFSET", "]", "=", "offset", "\n", "# Shift intensity", "\n", "data", "=", "(", "sample", "+", "offset", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "return", "data", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomShiftIntensity.undo_transform": [[856, 864], ["None"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "undo_transform", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "assert", "MetadataKW", ".", "OFFSET", "in", "metadata", "\n", "# Get offset", "\n", "offset", "=", "metadata", "[", "MetadataKW", ".", "OFFSET", "]", "\n", "# Substract offset", "\n", "data", "=", "(", "sample", "-", "offset", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "return", "data", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.ElasticTransform.__init__": [[878, 882], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "alpha_range", ",", "sigma_range", ",", "p", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "alpha_range", "=", "alpha_range", "\n", "self", ".", "sigma_range", "=", "sigma_range", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.ElasticTransform.__call__": [[883, 932], ["any", "numpy.meshgrid", "scipy.ndimage.map_coordinates", "data_out.astype.astype.reshape", "data_out.astype.astype.astype", "numpy.random.random", "numpy.random.uniform", "numpy.random.uniform", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "scipy.ndimage.gaussian_filter", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "# if params already defined, i.e. sample is GT", "\n", "        ", "if", "MetadataKW", ".", "ELASTIC", "in", "metadata", ":", "\n", "            ", "alpha", ",", "sigma", "=", "metadata", "[", "MetadataKW", ".", "ELASTIC", "]", "\n", "\n", "", "elif", "np", ".", "random", ".", "random", "(", ")", "<", "self", ".", "p", ":", "\n", "# Get params", "\n", "            ", "alpha", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "alpha_range", "[", "0", "]", ",", "self", ".", "alpha_range", "[", "1", "]", ")", "\n", "sigma", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "sigma_range", "[", "0", "]", ",", "self", ".", "sigma_range", "[", "1", "]", ")", "\n", "\n", "# Save params", "\n", "metadata", "[", "MetadataKW", ".", "ELASTIC", "]", "=", "[", "alpha", ",", "sigma", "]", "\n", "\n", "", "else", ":", "\n", "            ", "metadata", "[", "MetadataKW", ".", "ELASTIC", "]", "=", "[", "None", ",", "None", "]", "\n", "\n", "", "if", "any", "(", "metadata", "[", "MetadataKW", ".", "ELASTIC", "]", ")", ":", "\n", "# Get shape", "\n", "            ", "shape", "=", "sample", ".", "shape", "\n", "\n", "# Compute random deformation", "\n", "dx", "=", "gaussian_filter", "(", "(", "np", ".", "random", ".", "rand", "(", "*", "shape", ")", "*", "2", "-", "1", ")", ",", "\n", "sigma", ",", "mode", "=", "\"constant\"", ",", "cval", "=", "0", ")", "*", "alpha", "\n", "dy", "=", "gaussian_filter", "(", "(", "np", ".", "random", ".", "rand", "(", "*", "shape", ")", "*", "2", "-", "1", ")", ",", "\n", "sigma", ",", "mode", "=", "\"constant\"", ",", "cval", "=", "0", ")", "*", "alpha", "\n", "dz", "=", "gaussian_filter", "(", "(", "np", ".", "random", ".", "rand", "(", "*", "shape", ")", "*", "2", "-", "1", ")", ",", "\n", "sigma", ",", "mode", "=", "\"constant\"", ",", "cval", "=", "0", ")", "*", "alpha", "\n", "if", "shape", "[", "2", "]", "==", "1", ":", "\n", "                ", "dz", "=", "0", "# No deformation along the last dimension", "\n", "", "x", ",", "y", ",", "z", "=", "np", ".", "meshgrid", "(", "np", ".", "arange", "(", "shape", "[", "0", "]", ")", ",", "\n", "np", ".", "arange", "(", "shape", "[", "1", "]", ")", ",", "\n", "np", ".", "arange", "(", "shape", "[", "2", "]", ")", ",", "indexing", "=", "'ij'", ")", "\n", "indices", "=", "np", ".", "reshape", "(", "x", "+", "dx", ",", "(", "-", "1", ",", "1", ")", ")", ",", "np", ".", "reshape", "(", "y", "+", "dy", ",", "(", "-", "1", ",", "1", ")", ")", ",", "np", ".", "reshape", "(", "z", "+", "dz", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# Apply deformation", "\n", "data_out", "=", "map_coordinates", "(", "sample", ",", "indices", ",", "order", "=", "1", ",", "mode", "=", "'reflect'", ")", "\n", "# Keep input shape", "\n", "data_out", "=", "data_out", ".", "reshape", "(", "shape", ")", "\n", "# Keep data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n", "", "else", ":", "\n", "            ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.AdditiveGaussianNoise.__init__": [[942, 945], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", "=", "0.0", ",", "std", "=", "0.01", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.AdditiveGaussianNoise.__call__": [[946, 959], ["numpy.random.normal", "noise.astype.astype.astype", "data_out.astype"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "MetadataKW", ".", "GAUSSIAN_NOISE", "in", "metadata", ":", "\n", "            ", "noise", "=", "metadata", "[", "MetadataKW", ".", "GAUSSIAN_NOISE", "]", "\n", "", "else", ":", "\n", "# Get random noise", "\n", "            ", "noise", "=", "np", ".", "random", ".", "normal", "(", "self", ".", "mean", ",", "self", ".", "std", ",", "sample", ".", "shape", ")", "\n", "noise", "=", "noise", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Apply noise", "\n", "", "data_out", "=", "sample", "+", "noise", "\n", "\n", "return", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Clahe.__init__": [[979, 982], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "clip_limit", "=", "3.0", ",", "kernel_size", "=", "(", "8", ",", "8", ")", ")", ":", "\n", "        ", "self", ".", "clip_limit", "=", "clip_limit", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.Clahe.__call__": [[983, 992], ["skimage.exposure.equalize_adapthist().astype", "len", "len", "skimage.exposure.equalize_adapthist"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "assert", "len", "(", "self", ".", "kernel_size", ")", "==", "len", "(", "sample", ".", "shape", ")", "\n", "# Run equalization", "\n", "data_out", "=", "equalize_adapthist", "(", "sample", ",", "\n", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "clip_limit", "=", "self", ".", "clip_limit", ")", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.HistogramClipping.__init__": [[1002, 1005], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_percentile", "=", "5.0", ",", "max_percentile", "=", "95.0", ")", ":", "\n", "        ", "self", ".", "min_percentile", "=", "min_percentile", "\n", "self", ".", "max_percentile", "=", "max_percentile", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.HistogramClipping.__call__": [[1006, 1015], ["numpy.copy", "numpy.percentile", "numpy.percentile"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "data", "=", "np", ".", "copy", "(", "sample", ")", "\n", "# Run clipping", "\n", "percentile1", "=", "np", ".", "percentile", "(", "sample", ",", "self", ".", "min_percentile", ")", "\n", "percentile2", "=", "np", ".", "percentile", "(", "sample", ",", "self", ".", "max_percentile", ")", "\n", "data", "[", "sample", "<=", "percentile1", "]", "=", "percentile1", "\n", "data", "[", "sample", ">=", "percentile2", "]", "=", "percentile2", "\n", "return", "data", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomGamma.__init__": [[1025, 1028], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log_gamma_range", ",", "p", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "log_gamma_range", "=", "log_gamma_range", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomGamma.__call__": [[1029, 1058], ["any", "numpy.random.random", "numpy.exp", "numpy.random.uniform", "numpy.errstate", "numpy.nan_to_num.astype", "numpy.nan_to_num", "numpy.sign", "numpy.abs"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random", "(", ")", "<", "self", ".", "p", ":", "\n", "# Get params", "\n", "            ", "gamma", "=", "np", ".", "exp", "(", "np", ".", "random", ".", "uniform", "(", "self", ".", "log_gamma_range", "[", "0", "]", ",", "self", ".", "log_gamma_range", "[", "1", "]", ")", ")", "\n", "\n", "# Save params", "\n", "metadata", "[", "MetadataKW", ".", "GAMMA", "]", "=", "[", "gamma", "]", "\n", "\n", "", "else", ":", "\n", "            ", "metadata", "[", "MetadataKW", ".", "GAMMA", "]", "=", "[", "None", "]", "\n", "\n", "", "if", "any", "(", "metadata", "[", "MetadataKW", ".", "GAMMA", "]", ")", ":", "\n", "# Suppress the overflow case (due to exponentiation)", "\n", "            ", "with", "np", ".", "errstate", "(", "over", "=", "'ignore'", ")", ":", "\n", "# Apply gamma contrast", "\n", "                ", "data_out", "=", "np", ".", "sign", "(", "sample", ")", "*", "(", "np", ".", "abs", "(", "sample", ")", "**", "gamma", ")", "\n", "\n", "# Keep data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "# Clip +/- inf values to the max/min quantization of the native dtype", "\n", "data_out", "=", "np", ".", "nan_to_num", "(", "data_out", ")", "\n", "\n", "", "return", "data_out", ",", "metadata", "\n", "\n", "", "else", ":", "\n", "            ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomBiasField.__init__": [[1069, 1073], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "coefficients", ",", "order", ",", "p", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "coefficients", "=", "coefficients", "\n", "self", ".", "order", "=", "order", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomBiasField.__call__": [[1074, 1103], ["any", "numpy.random.random", "torchio.Compose", "transforms.tio_transform", "data_out.astype.astype.astype", "torchio.RandomBiasField"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.tio_transform"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random", "(", ")", "<", "self", ".", "p", ":", "\n", "# Get params", "\n", "            ", "random_bias_field", "=", "tio", ".", "Compose", "(", "[", "tio", ".", "RandomBiasField", "(", "coefficients", "=", "self", ".", "coefficients", ",", "\n", "order", "=", "self", ".", "order", ",", "\n", "p", "=", "self", ".", "p", ")", "]", ")", "\n", "\n", "# Save params", "\n", "metadata", "[", "MetadataKW", ".", "BIAS_FIELD", "]", "=", "[", "random_bias_field", "]", "\n", "\n", "", "else", ":", "\n", "            ", "metadata", "[", "MetadataKW", ".", "BIAS_FIELD", "]", "=", "[", "None", "]", "\n", "\n", "", "if", "any", "(", "metadata", "[", "MetadataKW", ".", "BIAS_FIELD", "]", ")", ":", "\n", "# Apply random bias field", "\n", "            ", "data_out", ",", "history", "=", "tio_transform", "(", "x", "=", "sample", ",", "transform", "=", "random_bias_field", ")", "\n", "\n", "# Keep data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "# Update metadata to history", "\n", "metadata", "[", "MetadataKW", ".", "BIAS_FIELD", "]", "=", "[", "history", "]", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n", "", "else", ":", "\n", "            ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomBlur.__init__": [[1113, 1116], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sigma_range", ",", "p", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "sigma_range", "=", "sigma_range", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.RandomBlur.__call__": [[1117, 1141], ["any", "numpy.random.random", "numpy.random.uniform", "scipy.ndimage.gaussian_filter", "data_out.astype.astype.astype"], "methods", ["None"], ["", "@", "multichannel_capable", "\n", "@", "two_dim_compatible", "\n", "def", "__call__", "(", "self", ",", "sample", ",", "metadata", "=", "None", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random", "(", ")", "<", "self", ".", "p", ":", "\n", "# Get params", "\n", "            ", "sigma", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "sigma_range", "[", "0", "]", ",", "self", ".", "sigma_range", "[", "1", "]", ")", "\n", "\n", "# Save params", "\n", "metadata", "[", "MetadataKW", ".", "BLUR", "]", "=", "[", "sigma", "]", "\n", "\n", "", "else", ":", "\n", "            ", "metadata", "[", "MetadataKW", ".", "BLUR", "]", "=", "[", "None", "]", "\n", "\n", "", "if", "any", "(", "metadata", "[", "MetadataKW", ".", "BLUR", "]", ")", ":", "\n", "# Apply random blur", "\n", "            ", "data_out", "=", "gaussian_filter", "(", "sample", ",", "sigma", ")", "\n", "\n", "# Keep data type", "\n", "data_out", "=", "data_out", ".", "astype", "(", "sample", ".", "dtype", ")", "\n", "\n", "return", "data_out", ",", "metadata", "\n", "\n", "", "else", ":", "\n", "            ", "return", "sample", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.multichannel_capable": [[24, 56], ["functools.wraps", "isinstance", "zip", "wrapped", "wrapped", "list_data.append", "list_metadata.append", "len", "isinstance", "ivadomed.loader.utils.update_metadata", "ivadomed.loader.utils.update_metadata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata"], ["def", "multichannel_capable", "(", "wrapped", ")", ":", "\n", "    ", "\"\"\"Decorator to make a given function compatible multichannel images.\n\n    Args:\n        wrapped: Given function.\n\n    Returns:\n        Functions' return.\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "wrapped", ")", "\n", "def", "wrapper", "(", "self", ",", "sample", ",", "metadata", ")", ":", "\n", "        ", "if", "isinstance", "(", "sample", ",", "list", ")", ":", "\n", "            ", "list_data", ",", "list_metadata", "=", "[", "]", ",", "[", "]", "\n", "for", "s_cur", ",", "m_cur", "in", "zip", "(", "sample", ",", "metadata", ")", ":", "\n", "                ", "if", "len", "(", "list_metadata", ")", ">", "0", ":", "\n", "                    ", "if", "not", "isinstance", "(", "list_metadata", "[", "-", "1", "]", ",", "list", ")", ":", "\n", "                        ", "imed_loader_utils", ".", "update_metadata", "(", "[", "list_metadata", "[", "-", "1", "]", "]", ",", "[", "m_cur", "]", ")", "\n", "", "else", ":", "\n", "                        ", "imed_loader_utils", ".", "update_metadata", "(", "list_metadata", "[", "-", "1", "]", ",", "[", "m_cur", "]", ")", "\n", "# Run function for each sample of the list", "\n", "", "", "data_cur", ",", "metadata_cur", "=", "wrapped", "(", "self", ",", "s_cur", ",", "m_cur", ")", "\n", "list_data", ".", "append", "(", "data_cur", ")", "\n", "list_metadata", ".", "append", "(", "metadata_cur", ")", "\n", "", "return", "list_data", ",", "list_metadata", "\n", "# If sample is None, then return a pair (None, None)", "\n", "", "if", "sample", "is", "None", ":", "\n", "            ", "return", "None", ",", "None", "\n", "", "else", ":", "\n", "            ", "return", "wrapped", "(", "self", ",", "sample", ",", "metadata", ")", "\n", "\n", "", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.two_dim_compatible": [[58, 82], ["functools.wraps", "len", "numpy.expand_dims", "wrapped", "wrapped", "numpy.squeeze"], "function", ["None"], ["", "def", "two_dim_compatible", "(", "wrapped", ")", ":", "\n", "    ", "\"\"\"Decorator to make a given function compatible 2D or 3D images.\n\n    Args:\n        wrapped: Given function.\n\n    Returns:\n        Functions' return.\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "wrapped", ")", "\n", "def", "wrapper", "(", "self", ",", "sample", ",", "metadata", ")", ":", "\n", "# Check if sample is 2D", "\n", "        ", "if", "len", "(", "sample", ".", "shape", ")", "==", "2", ":", "\n", "# Add one dimension", "\n", "            ", "sample", "=", "np", ".", "expand_dims", "(", "sample", ",", "axis", "=", "-", "1", ")", "\n", "# Run transform", "\n", "result_sample", ",", "result_metadata", "=", "wrapped", "(", "self", ",", "sample", ",", "metadata", ")", "\n", "# Remove last dimension", "\n", "return", "np", ".", "squeeze", "(", "result_sample", ",", "axis", "=", "-", "1", ")", ",", "result_metadata", "\n", "", "else", ":", "\n", "            ", "return", "wrapped", "(", "self", ",", "sample", ",", "metadata", ")", "\n", "\n", "", "", "return", "wrapper", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_subdatasets_transforms": [[1143, 1168], ["copy.deepcopy", "zip"], "function", ["None"], ["", "", "", "def", "get_subdatasets_transforms", "(", "transform_params", ")", ":", "\n", "    ", "\"\"\"Get transformation parameters for each subdataset: training, validation and testing.\n\n    Args:\n        transform_params (dict):\n\n    Returns:\n        dict, dict, dict: Training, Validation and Testing transformations.\n    \"\"\"", "\n", "transform_params", "=", "copy", ".", "deepcopy", "(", "transform_params", ")", "\n", "train", ",", "valid", ",", "test", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "subdataset_default", "=", "[", "\"training\"", ",", "\"validation\"", ",", "\"testing\"", "]", "\n", "# Loop across transformations", "\n", "for", "transform_name", "in", "transform_params", ":", "\n", "        ", "subdataset_list", "=", "[", "\"training\"", ",", "\"validation\"", ",", "\"testing\"", "]", "\n", "# Only consider subdatasets listed in dataset_type", "\n", "if", "\"dataset_type\"", "in", "transform_params", "[", "transform_name", "]", ":", "\n", "            ", "subdataset_list", "=", "transform_params", "[", "transform_name", "]", "[", "\"dataset_type\"", "]", "\n", "# Add current transformation to the relevant subdataset transformation dictionaries", "\n", "", "for", "subds_name", ",", "subds_dict", "in", "zip", "(", "subdataset_default", ",", "[", "train", ",", "valid", ",", "test", "]", ")", ":", "\n", "            ", "if", "subds_name", "in", "subdataset_list", ":", "\n", "                ", "subds_dict", "[", "transform_name", "]", "=", "transform_params", "[", "transform_name", "]", "\n", "if", "\"dataset_type\"", "in", "subds_dict", "[", "transform_name", "]", ":", "\n", "                    ", "del", "subds_dict", "[", "transform_name", "]", "[", "\"dataset_type\"", "]", "\n", "", "", "", "", "return", "train", ",", "valid", ",", "test", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_preprocessing_transforms": [[1170, 1188], ["copy.deepcopy", "copy.deepcopy", "enumerate"], "function", ["None"], ["", "def", "get_preprocessing_transforms", "(", "transforms", ")", ":", "\n", "    ", "\"\"\"Checks the transformations parameters and selects the transformations which are done during preprocessing only.\n\n    Args:\n        transforms (dict): Transformation dictionary.\n\n    Returns:\n        dict: Preprocessing transforms.\n    \"\"\"", "\n", "original_transforms", "=", "copy", ".", "deepcopy", "(", "transforms", ")", "\n", "preprocessing_transforms", "=", "copy", ".", "deepcopy", "(", "transforms", ")", "\n", "for", "idx", ",", "tr", "in", "enumerate", "(", "original_transforms", ")", ":", "\n", "        ", "if", "tr", "==", "TransformationKW", ".", "RESAMPLE", "or", "tr", "==", "TransformationKW", ".", "CENTERCROP", "or", "tr", "==", "TransformationKW", ".", "ROICROP", ":", "\n", "            ", "del", "transforms", "[", "tr", "]", "\n", "", "else", ":", "\n", "            ", "del", "preprocessing_transforms", "[", "tr", "]", "\n", "\n", "", "", "return", "preprocessing_transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.apply_preprocessing_transforms": [[1190, 1239], ["torchvision.transforms", "ivadomed.loader.utils.update_metadata", "torchvision.transforms", "torchvision.transforms", "ivadomed.loader.utils.update_metadata", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata"], ["", "def", "apply_preprocessing_transforms", "(", "transforms", ",", "seg_pair", ",", "roi_pair", "=", "None", ")", "->", "Tuple", "[", "dict", ",", "dict", "]", ":", "\n", "    ", "\"\"\"\n    Applies preprocessing transforms to segmentation pair (input, gt and metadata).\n\n    Args:\n        transforms (Compose): Preprocessing transforms.\n        seg_pair (dict): Segmentation pair containing input and gt.\n        roi_pair (dict): Segementation pair containing input and roi.\n\n    Returns:\n        tuple: Segmentation pair and roi pair.\n    \"\"\"", "\n", "if", "transforms", "is", "None", ":", "\n", "        ", "return", "(", "seg_pair", ",", "roi_pair", ")", "\n", "\n", "", "metadata_input", "=", "seg_pair", "[", "'input_metadata'", "]", "\n", "if", "roi_pair", "is", "not", "None", ":", "\n", "        ", "stack_roi", ",", "metadata_roi", "=", "transforms", "(", "sample", "=", "roi_pair", "[", "\"gt\"", "]", ",", "\n", "metadata", "=", "roi_pair", "[", "'gt_metadata'", "]", ",", "\n", "data_type", "=", "\"roi\"", ",", "\n", "preprocessing", "=", "True", ")", "\n", "metadata_input", "=", "imed_loader_utils", ".", "update_metadata", "(", "metadata_roi", ",", "metadata_input", ")", "\n", "# Run transforms on images", "\n", "", "stack_input", ",", "metadata_input", "=", "transforms", "(", "sample", "=", "seg_pair", "[", "\"input\"", "]", ",", "\n", "metadata", "=", "metadata_input", ",", "\n", "data_type", "=", "\"im\"", ",", "\n", "preprocessing", "=", "True", ")", "\n", "# Run transforms on images", "\n", "metadata_gt", "=", "imed_loader_utils", ".", "update_metadata", "(", "metadata_input", ",", "seg_pair", "[", "'gt_metadata'", "]", ")", "\n", "stack_gt", ",", "metadata_gt", "=", "transforms", "(", "sample", "=", "seg_pair", "[", "\"gt\"", "]", ",", "\n", "metadata", "=", "metadata_gt", ",", "\n", "data_type", "=", "\"gt\"", ",", "\n", "preprocessing", "=", "True", ")", "\n", "\n", "seg_pair", "=", "{", "\n", "'input'", ":", "stack_input", ",", "\n", "'gt'", ":", "stack_gt", ",", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "metadata_input", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "metadata_gt", "\n", "}", "\n", "\n", "if", "roi_pair", "is", "not", "None", "and", "len", "(", "roi_pair", "[", "'gt'", "]", ")", ":", "\n", "        ", "roi_pair", "=", "{", "\n", "'input'", ":", "stack_input", ",", "\n", "'gt'", ":", "stack_roi", ",", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "metadata_input", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "metadata_roi", "\n", "}", "\n", "", "return", "(", "seg_pair", ",", "roi_pair", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.prepare_transforms": [[1241, 1261], ["transforms.get_preprocessing_transforms", "transforms.Compose", "transforms.Compose", "transforms.UndoCompose", "transforms.Compose", "len", "transform_dict.copy"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_preprocessing_transforms"], ["", "def", "prepare_transforms", "(", "transform_dict", ",", "requires_undo", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    This function separates the preprocessing transforms from the others and generates the undo transforms related.\n\n    Args:\n        transform_dict (dict): Dictionary containing the transforms and there parameters.\n        requires_undo (bool): Boolean indicating if transforms can be undone.\n\n    Returns:\n        list, UndoCompose: transform lst containing the preprocessing transforms and regular transforms, UndoCompose\n            object containing the transform to undo.\n    \"\"\"", "\n", "training_undo_transform", "=", "None", "\n", "if", "requires_undo", ":", "\n", "        ", "training_undo_transform", "=", "UndoCompose", "(", "Compose", "(", "transform_dict", ".", "copy", "(", ")", ")", ")", "\n", "", "preprocessing_transforms", "=", "get_preprocessing_transforms", "(", "transform_dict", ")", "\n", "prepro_transforms", "=", "Compose", "(", "preprocessing_transforms", ",", "requires_undo", "=", "requires_undo", ")", "\n", "transforms", "=", "Compose", "(", "transform_dict", ",", "requires_undo", "=", "requires_undo", ")", "\n", "tranform_lst", "=", "[", "prepro_transforms", "if", "len", "(", "preprocessing_transforms", ")", "else", "None", ",", "transforms", "]", "\n", "return", "tranform_lst", ",", "training_undo_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.tio_transform": [[1263, 1277], ["torchio.Subject", "transform", "transform.get_composed_history", "torchio.ScalarImage", "transform.input.numpy"], "function", ["None"], ["", "def", "tio_transform", "(", "x", ",", "transform", ")", ":", "\n", "    ", "\"\"\"\n    Applies TorchIO transformations to a given image and returns the transformed image and history.\n\n    Args:\n        x (np.ndarray): input image\n        transform (tio.transforms.Transform): TorchIO transform\n\n    Returns:\n        np.ndarray, list: transformed image, history of parameters used for the applied transformation\n    \"\"\"", "\n", "tio_subject", "=", "tio", ".", "Subject", "(", "input", "=", "tio", ".", "ScalarImage", "(", "tensor", "=", "x", "[", "np", ".", "newaxis", ",", "...", "]", ")", ")", "\n", "transformed", "=", "transform", "(", "tio_subject", ")", "\n", "return", "transformed", ".", "input", ".", "numpy", "(", ")", "[", "0", "]", ",", "transformed", ".", "get_composed_history", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet.__init__": [[28, 78], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "models.ResNet.modules", "len", "ValueError", "isinstance", "models.ResNet.modules", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "isinstance", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._make_layer", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._make_layer", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._make_layer", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._make_layer"], ["def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "num_classes", "=", "2", ",", "zero_init_residual", "=", "False", ",", "\n", "groups", "=", "1", ",", "width_per_group", "=", "64", ",", "replace_stride_with_dilation", "=", "None", ",", "\n", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "norm_layer", "is", "None", ":", "\n", "            ", "norm_layer", "=", "nn", ".", "BatchNorm2d", "\n", "", "self", ".", "_norm_layer", "=", "norm_layer", "\n", "\n", "self", ".", "inplanes", "=", "64", "\n", "self", ".", "dilation", "=", "1", "\n", "if", "replace_stride_with_dilation", "is", "None", ":", "\n", "# each element in the tuple indicates if we should replace", "\n", "# the 2x2 stride with a dilated convolution instead", "\n", "            ", "replace_stride_with_dilation", "=", "[", "False", ",", "False", ",", "False", "]", "\n", "", "if", "len", "(", "replace_stride_with_dilation", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"replace_stride_with_dilation should be None \"", "\n", "\"or a 3-element tuple, got {}\"", ".", "format", "(", "replace_stride_with_dilation", ")", ")", "\n", "", "self", ".", "groups", "=", "groups", "\n", "self", ".", "base_width", "=", "width_per_group", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "1", ",", "self", ".", "inplanes", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "self", ".", "inplanes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "0", "]", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "1", "]", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ",", "\n", "dilate", "=", "replace_stride_with_dilation", "[", "2", "]", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm2d", ",", "nn", ".", "GroupNorm", ")", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "# Zero-initialize the last BN in each residual branch,", "\n", "# so that the residual branch starts with zeros, and each residual block behaves like an identity.", "\n", "# This improves the model by 0.2~0.3% according to https://arxiv.org/abs/1706.02677", "\n", "", "", "if", "zero_init_residual", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "torchvision", ".", "models", ".", "resnet", ".", "Bottleneck", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn3", ".", "weight", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "torchvision", ".", "models", ".", "resnet", ".", "BasicBlock", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn2", ".", "weight", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._make_layer": [[79, 102], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torchvision.models.resnet.conv1x1", "norm_layer", "block"], "methods", ["None"], ["", "", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dilate", "=", "False", ")", ":", "\n", "        ", "norm_layer", "=", "self", ".", "_norm_layer", "\n", "downsample", "=", "None", "\n", "previous_dilation", "=", "self", ".", "dilation", "\n", "if", "dilate", ":", "\n", "            ", "self", ".", "dilation", "*=", "stride", "\n", "stride", "=", "1", "\n", "", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "torchvision", ".", "models", ".", "resnet", ".", "conv1x1", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "stride", ")", ",", "\n", "norm_layer", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ",", "self", ".", "groups", ",", "\n", "self", ".", "base_width", ",", "previous_dilation", ",", "norm_layer", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "groups", "=", "self", ".", "groups", ",", "\n", "base_width", "=", "self", ".", "base_width", ",", "dilation", "=", "self", ".", "dilation", ",", "\n", "norm_layer", "=", "norm_layer", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._forward_impl": [[103, 123], ["models.ResNet.conv1", "models.ResNet.bn1", "models.ResNet.relu", "models.ResNet.maxpool", "models.ResNet.layer1", "models.ResNet.layer2", "models.ResNet.layer3", "models.ResNet.layer4", "models.ResNet.avgpool", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "models.ResNet.fc", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["None"], ["", "def", "_forward_impl", "(", "self", ",", "x", ")", ":", "\n", "# See note [TorchScript super()]", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "preds", "=", "F", ".", "softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "# Remove background class", "\n", "preds", "=", "preds", "[", ":", ",", "1", ":", "]", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet.forward": [[124, 126], ["models.ResNet._forward_impl"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ResNet._forward_impl"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "_forward_impl", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.resnet18.__init__": [[129, 131], ["models.ResNet.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "torchvision", ".", "models", ".", "resnet", ".", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.DenseNet.__init__": [[149, 197], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "enumerate", "models.DenseNet.features.add_module", "torch.Linear", "torch.Linear", "torch.Linear", "models.DenseNet.modules", "collections.OrderedDict", "torchvision.models.densenet._DenseBlock", "models.DenseNet.features.add_module", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "isinstance", "torchvision.models.densenet._Transition", "models.DenseNet.features.add_module", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "isinstance", "len", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "isinstance", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "growth_rate", "=", "32", ",", "block_config", "=", "(", "6", ",", "12", ",", "24", ",", "16", ")", ",", "\n", "num_init_features", "=", "64", ",", "bn_size", "=", "4", ",", "dropout_rate", "=", "0.3", ",", "num_classes", "=", "2", ",", "memory_efficient", "=", "False", ")", ":", "\n", "\n", "        ", "super", "(", "DenseNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# First convolution", "\n", "self", ".", "features", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'conv0'", ",", "nn", ".", "Conv2d", "(", "1", ",", "num_init_features", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "\n", "padding", "=", "3", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "'norm0'", ",", "nn", ".", "BatchNorm2d", "(", "num_init_features", ")", ")", ",", "\n", "(", "'relu0'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ",", "\n", "(", "'pool0'", ",", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", ")", ",", "\n", "]", ")", ")", "\n", "\n", "# Each denseblock", "\n", "num_features", "=", "num_init_features", "\n", "for", "i", ",", "num_layers", "in", "enumerate", "(", "block_config", ")", ":", "\n", "            ", "block", "=", "torchvision", ".", "models", ".", "densenet", ".", "_DenseBlock", "(", "\n", "num_layers", "=", "num_layers", ",", "\n", "num_input_features", "=", "num_features", ",", "\n", "bn_size", "=", "bn_size", ",", "\n", "growth_rate", "=", "growth_rate", ",", "\n", "drop_rate", "=", "dropout_rate", ",", "\n", "memory_efficient", "=", "memory_efficient", "\n", ")", "\n", "self", ".", "features", ".", "add_module", "(", "'denseblock%d'", "%", "(", "i", "+", "1", ")", ",", "block", ")", "\n", "num_features", "=", "num_features", "+", "num_layers", "*", "growth_rate", "\n", "if", "i", "!=", "len", "(", "block_config", ")", "-", "1", ":", "\n", "                ", "trans", "=", "torchvision", ".", "models", ".", "densenet", ".", "_Transition", "(", "num_input_features", "=", "num_features", ",", "\n", "num_output_features", "=", "num_features", "//", "2", ")", "\n", "self", ".", "features", ".", "add_module", "(", "'transition%d'", "%", "(", "i", "+", "1", ")", ",", "trans", ")", "\n", "num_features", "=", "num_features", "//", "2", "\n", "\n", "# Final batch norm", "\n", "", "", "self", ".", "features", ".", "add_module", "(", "'norm5'", ",", "nn", ".", "BatchNorm2d", "(", "num_features", ")", ")", "\n", "\n", "# Linear layer", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "num_features", ",", "num_classes", ")", "\n", "\n", "# Official init from torch repo.", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.DenseNet.forward": [[198, 208], ["models.DenseNet.features", "torch.relu", "torch.relu", "torch.relu", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "models.DenseNet.classifier", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "features", "=", "self", ".", "features", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "features", ",", "inplace", "=", "True", ")", "\n", "out", "=", "F", ".", "adaptive_avg_pool2d", "(", "out", ",", "(", "1", ",", "1", ")", ")", "\n", "out", "=", "torch", ".", "flatten", "(", "out", ",", "1", ")", "\n", "out", "=", "self", ".", "classifier", "(", "out", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "out", ",", "dim", "=", "1", ")", "\n", "# Remove background class", "\n", "preds", "=", "preds", "[", ":", ",", "1", ":", "]", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.densenet121.__init__": [[211, 213], ["models.DenseNet.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "32", ",", "(", "6", ",", "12", ",", "24", ",", "16", ")", ",", "64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.DownConv.__init__": [[235, 253], ["torch.nn.Module.__init__", "conv", "bn", "dropout", "conv", "bn", "dropout"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_feat", ",", "out_feat", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "is_2d", "=", "True", ")", ":", "\n", "        ", "super", "(", "DownConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "is_2d", ":", "\n", "            ", "conv", "=", "nn", ".", "Conv2d", "\n", "bn", "=", "nn", ".", "BatchNorm2d", "\n", "dropout", "=", "nn", ".", "Dropout2d", "\n", "", "else", ":", "\n", "            ", "conv", "=", "nn", ".", "Conv3d", "\n", "bn", "=", "nn", ".", "InstanceNorm3d", "\n", "dropout", "=", "nn", ".", "Dropout3d", "\n", "\n", "", "self", ".", "conv1", "=", "conv", "(", "in_feat", ",", "out_feat", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv1_bn", "=", "bn", "(", "out_feat", ",", "momentum", "=", "bn_momentum", ")", "\n", "self", ".", "conv1_drop", "=", "dropout", "(", "dropout_rate", ")", "\n", "\n", "self", ".", "conv2", "=", "conv", "(", "out_feat", ",", "out_feat", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv2_bn", "=", "bn", "(", "out_feat", ",", "momentum", "=", "bn_momentum", ")", "\n", "self", ".", "conv2_drop", "=", "dropout", "(", "dropout_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.DownConv.forward": [[254, 263], ["torch.relu", "torch.relu", "torch.relu", "models.DownConv.conv1_bn", "models.DownConv.conv1_drop", "torch.relu", "torch.relu", "torch.relu", "models.DownConv.conv2_bn", "models.DownConv.conv2_drop", "models.DownConv.conv1", "models.DownConv.conv2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "conv1_bn", "(", "x", ")", "\n", "x", "=", "self", ".", "conv1_drop", "(", "x", ")", "\n", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "conv2_bn", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2_drop", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.UpConv.__init__": [[280, 284], ["torch.nn.Module.__init__", "models.DownConv"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_feat", ",", "out_feat", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "is_2d", "=", "True", ")", ":", "\n", "        ", "super", "(", "UpConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "is_2d", "=", "is_2d", "\n", "self", ".", "downconv", "=", "DownConv", "(", "in_feat", ",", "out_feat", ",", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.UpConv.forward": [[285, 295], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.UpConv.downconv", "hasattr", "y.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "# For retrocompatibility purposes", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "\"is_2d\"", ")", ":", "\n", "            ", "self", ".", "is_2d", "=", "True", "\n", "", "mode", "=", "'bilinear'", "if", "self", ".", "is_2d", "else", "'trilinear'", "\n", "dims", "=", "-", "2", "if", "self", ".", "is_2d", "else", "-", "3", "\n", "x", "=", "F", ".", "interpolate", "(", "x", ",", "size", "=", "y", ".", "size", "(", ")", "[", "dims", ":", "]", ",", "mode", "=", "mode", ",", "align_corners", "=", "True", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "y", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "downconv", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Encoder.__init__": [[318, 338], ["torch.nn.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "models.Encoder.down_path.append", "models.Encoder.down_path.append", "models.Encoder.down_path.append", "range", "models.DownConv", "models.DownConv", "max_pool", "models.Encoder.down_path.append", "models.Encoder.down_path.append", "models.Encoder.down_path.append", "models.FiLMlayer", "models.FiLMlayer", "models.DownConv", "max_pool", "models.FiLMlayer"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", "=", "1", ",", "depth", "=", "3", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "n_metadata", "=", "None", ",", "film_layers", "=", "None", ",", "\n", "is_2d", "=", "True", ",", "n_filters", "=", "64", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "down_path", "=", "nn", ".", "ModuleList", "(", ")", "\n", "# first block", "\n", "self", ".", "down_path", ".", "append", "(", "DownConv", "(", "in_channel", ",", "n_filters", ",", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", ")", "\n", "self", ".", "down_path", ".", "append", "(", "FiLMlayer", "(", "n_metadata", ",", "n_filters", ")", "if", "film_layers", "and", "film_layers", "[", "0", "]", "else", "None", ")", "\n", "max_pool", "=", "nn", ".", "MaxPool2d", "if", "is_2d", "else", "nn", ".", "MaxPool3d", "\n", "self", ".", "down_path", ".", "append", "(", "max_pool", "(", "2", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "depth", "-", "1", ")", ":", "\n", "            ", "self", ".", "down_path", ".", "append", "(", "DownConv", "(", "n_filters", ",", "n_filters", "*", "2", ",", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", ")", "\n", "self", ".", "down_path", ".", "append", "(", "FiLMlayer", "(", "n_metadata", ",", "n_filters", "*", "2", ")", "if", "film_layers", "and", "film_layers", "[", "i", "+", "1", "]", "else", "None", ")", "\n", "self", ".", "down_path", ".", "append", "(", "max_pool", "(", "2", ")", ")", "\n", "n_filters", "=", "n_filters", "*", "2", "\n", "\n", "# Bottom", "\n", "", "self", ".", "conv_bottom", "=", "DownConv", "(", "n_filters", ",", "n_filters", ",", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", "\n", "self", ".", "film_bottom", "=", "FiLMlayer", "(", "n_metadata", ",", "n_filters", ")", "if", "film_layers", "and", "film_layers", "[", "self", ".", "depth", "]", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Encoder.forward": [[339, 364], ["features.append", "range", "models.Encoder.conv_bottom", "features.append", "features.append", "models.Encoder.film_bottom", "locals", "locals", "locals"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "context", "=", "None", ")", ":", "\n", "        ", "features", "=", "[", "]", "\n", "\n", "# First block", "\n", "x", "=", "self", ".", "down_path", "[", "0", "]", "(", "x", ")", "\n", "if", "self", ".", "down_path", "[", "1", "]", ":", "\n", "            ", "x", ",", "w_film", "=", "self", ".", "down_path", "[", "1", "]", "(", "x", ",", "context", ",", "None", ")", "\n", "", "features", ".", "append", "(", "x", ")", "\n", "x", "=", "self", ".", "down_path", "[", "2", "]", "(", "x", ")", "\n", "\n", "# Down-sampling path (other blocks)", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "depth", ")", ":", "\n", "            ", "x", "=", "self", ".", "down_path", "[", "i", "*", "3", "]", "(", "x", ")", "\n", "if", "self", ".", "down_path", "[", "i", "*", "3", "+", "1", "]", ":", "\n", "                ", "x", ",", "w_film", "=", "self", ".", "down_path", "[", "i", "*", "3", "+", "1", "]", "(", "x", ",", "context", ",", "None", "if", "'w_film'", "not", "in", "locals", "(", ")", "else", "w_film", ")", "\n", "", "features", ".", "append", "(", "x", ")", "\n", "x", "=", "self", ".", "down_path", "[", "i", "*", "3", "+", "2", "]", "(", "x", ")", "\n", "\n", "# Bottom level", "\n", "", "x", "=", "self", ".", "conv_bottom", "(", "x", ")", "\n", "if", "self", ".", "film_bottom", ":", "\n", "            ", "x", ",", "w_film", "=", "self", ".", "film_bottom", "(", "x", ",", "context", ",", "None", "if", "'w_film'", "not", "in", "locals", "(", ")", "else", "w_film", ")", "\n", "", "features", ".", "append", "(", "x", ")", "\n", "\n", "return", "features", ",", "None", "if", "'w_film'", "not", "in", "locals", "(", ")", "else", "w_film", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Decoder.__init__": [[390, 432], ["torch.nn.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "conv", "torch.Softmax", "torch.Softmax", "torch.Softmax", "models.Decoder.up_path.append", "models.Decoder.up_path.append", "models.Decoder.up_path.append", "models.FiLMlayer", "models.UpConv", "models.Decoder.up_path.append", "models.Decoder.up_path.append", "models.UpConv", "models.Decoder.up_path.append", "models.Decoder.up_path.append", "models.UpConv", "models.Decoder.up_path.append", "models.Decoder.up_path.append", "models.FiLMlayer", "models.FiLMlayer", "models.FiLMlayer", "int"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "out_channel", "=", "1", ",", "depth", "=", "3", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "\n", "n_metadata", "=", "None", ",", "film_layers", "=", "None", ",", "hemis", "=", "False", ",", "final_activation", "=", "\"sigmoid\"", ",", "is_2d", "=", "True", ",", "n_filters", "=", "64", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "out_channel", "=", "out_channel", "\n", "self", ".", "final_activation", "=", "final_activation", "\n", "# Up-Sampling path", "\n", "self", ".", "up_path", "=", "nn", ".", "ModuleList", "(", ")", "\n", "if", "hemis", ":", "\n", "            ", "in_channel", "=", "n_filters", "*", "2", "**", "self", ".", "depth", "\n", "self", ".", "up_path", ".", "append", "(", "UpConv", "(", "in_channel", "*", "2", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "1", ")", ",", "dropout_rate", ",", "bn_momentum", ",", "\n", "is_2d", ")", ")", "\n", "if", "film_layers", "and", "film_layers", "[", "self", ".", "depth", "+", "1", "]", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "FiLMlayer", "(", "n_metadata", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "None", ")", "\n", "# self.depth += 1", "\n", "", "", "else", ":", "\n", "            ", "in_channel", "=", "n_filters", "*", "2", "**", "self", ".", "depth", "\n", "\n", "self", ".", "up_path", ".", "append", "(", "UpConv", "(", "in_channel", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "1", ")", ",", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", ")", "\n", "if", "film_layers", "and", "film_layers", "[", "self", ".", "depth", "+", "1", "]", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "FiLMlayer", "(", "n_metadata", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "None", ")", "\n", "\n", "", "", "for", "i", "in", "range", "(", "1", ",", "depth", ")", ":", "\n", "            ", "in_channel", "//=", "2", "\n", "\n", "self", ".", "up_path", ".", "append", "(", "\n", "UpConv", "(", "in_channel", "+", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "i", "-", "1", "+", "int", "(", "hemis", ")", ")", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "i", "-", "1", ")", ",", "\n", "dropout_rate", ",", "bn_momentum", ",", "is_2d", ")", ")", "\n", "if", "film_layers", "and", "film_layers", "[", "self", ".", "depth", "+", "i", "+", "1", "]", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "FiLMlayer", "(", "n_metadata", ",", "n_filters", "*", "2", "**", "(", "self", ".", "depth", "-", "i", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "up_path", ".", "append", "(", "None", ")", "\n", "\n", "# Last Convolution", "\n", "", "", "conv", "=", "nn", ".", "Conv2d", "if", "is_2d", "else", "nn", ".", "Conv3d", "\n", "self", ".", "last_conv", "=", "conv", "(", "in_channel", "//", "2", ",", "out_channel", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "last_film", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "out_channel", ")", "if", "film_layers", "and", "film_layers", "[", "-", "1", "]", "else", "None", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Decoder.forward": [[433, 470], ["reversed", "models.Decoder.last_conv", "range", "models.Decoder.last_film", "hasattr", "ValueError", "hasattr", "models.Decoder.softmax", "hasattr", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid.sum().unsqueeze", "torch.sigmoid.sum().unsqueeze", "torch.sigmoid.sum().unsqueeze", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.isnan", "torch.sigmoid.sum", "torch.sigmoid.sum", "torch.sigmoid.sum", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ",", "context", "=", "None", ",", "w_film", "=", "None", ")", ":", "\n", "        ", "x", "=", "features", "[", "-", "1", "]", "\n", "\n", "for", "i", "in", "reversed", "(", "range", "(", "self", ".", "depth", ")", ")", ":", "\n", "            ", "x", "=", "self", ".", "up_path", "[", "-", "(", "i", "+", "1", ")", "*", "2", "]", "(", "x", ",", "features", "[", "i", "]", ")", "\n", "if", "self", ".", "up_path", "[", "-", "(", "i", "+", "1", ")", "*", "2", "+", "1", "]", ":", "\n", "                ", "x", ",", "w_film", "=", "self", ".", "up_path", "[", "-", "(", "i", "+", "1", ")", "*", "2", "+", "1", "]", "(", "x", ",", "context", ",", "w_film", ")", "\n", "\n", "# Last convolution", "\n", "", "", "x", "=", "self", ".", "last_conv", "(", "x", ")", "\n", "if", "self", ".", "last_film", ":", "\n", "            ", "x", ",", "w_film", "=", "self", ".", "last_film", "(", "x", ",", "context", ",", "w_film", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "not", "in", "[", "\"softmax\"", ",", "\"relu\"", ",", "\"sigmoid\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"final_activation value has to be either softmax, relu, or sigmoid\"", ")", "\n", "", "elif", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "==", "\"softmax\"", ":", "\n", "            ", "preds", "=", "self", ".", "softmax", "(", "x", ")", "\n", "", "elif", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "==", "\"relu\"", ":", "\n", "            ", "preds", "=", "nn", ".", "ReLU", "(", ")", "(", "x", ")", "/", "nn", ".", "ReLU", "(", ")", "(", "x", ")", ".", "max", "(", ")", "\n", "# If nn.ReLU()(x).max()==0, then nn.ReLU()(x) will also ==0. So, here any zero division will always be 0/0.", "\n", "# For float values, 0/0=nan. So, we can handle zero division (without checking data!) by setting nans to 0.", "\n", "preds", "[", "torch", ".", "isnan", "(", "preds", ")", "]", "=", "0.", "\n", "# If model multiclass", "\n", "if", "self", ".", "out_channel", ">", "1", ":", "\n", "                ", "class_sum", "=", "preds", ".", "sum", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "# Avoid division by zero", "\n", "class_sum", "[", "class_sum", "==", "0", "]", "=", "1", "\n", "preds", "/=", "class_sum", "\n", "", "", "else", ":", "\n", "            ", "preds", "=", "torch", ".", "sigmoid", "(", "x", ")", "\n", "\n", "# If model multiclass", "\n", "", "if", "self", ".", "out_channel", ">", "1", ":", "\n", "# Remove background class", "\n", "            ", "preds", "=", "preds", "[", ":", ",", "1", ":", ",", "]", "\n", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Unet.__init__": [[496, 507], ["torch.nn.Module.__init__", "models.Encoder", "models.Decoder"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", "=", "1", ",", "out_channel", "=", "1", ",", "depth", "=", "3", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "final_activation", "=", "'sigmoid'", ",", "\n", "is_2d", "=", "True", ",", "n_filters", "=", "64", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Unet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Encoder path", "\n", "self", ".", "encoder", "=", "Encoder", "(", "in_channel", "=", "in_channel", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ",", "\n", "is_2d", "=", "is_2d", ",", "n_filters", "=", "n_filters", ")", "\n", "\n", "# Decoder path", "\n", "self", ".", "decoder", "=", "Decoder", "(", "out_channel", "=", "out_channel", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ",", "\n", "final_activation", "=", "final_activation", ",", "is_2d", "=", "is_2d", ",", "n_filters", "=", "n_filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Unet.forward": [[508, 513], ["models.Unet.encoder", "models.Unet.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "features", ",", "_", "=", "self", ".", "encoder", "(", "x", ")", "\n", "preds", "=", "self", ".", "decoder", "(", "features", ")", "\n", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMedUnet.__init__": [[535, 553], ["models.Unet.__init__", "models.Encoder", "models.Decoder", "len", "ValueError", "len"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", "=", "1", ",", "out_channel", "=", "1", ",", "depth", "=", "3", ",", "dropout_rate", "=", "0.3", ",", "\n", "bn_momentum", "=", "0.1", ",", "n_metadata", "=", "None", ",", "film_layers", "=", "None", ",", "is_2d", "=", "True", ",", "n_filters", "=", "64", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channel", "=", "in_channel", ",", "out_channel", "=", "out_channel", ",", "depth", "=", "depth", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ")", "\n", "\n", "# Verify if the length of boolean FiLM layers corresponds to the depth", "\n", "if", "film_layers", ":", "\n", "            ", "if", "len", "(", "film_layers", ")", "!=", "2", "*", "depth", "+", "2", ":", "\n", "                ", "raise", "ValueError", "(", "\"The number of FiLM layers {} entered does not correspond to the \"", "\n", "\"UNet depth. There should 2 * depth + 2 layers.\"", ".", "format", "(", "len", "(", "film_layers", ")", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "film_layers", "=", "[", "0", "]", "*", "(", "2", "*", "depth", "+", "2", ")", "\n", "# Encoder path", "\n", "", "self", ".", "encoder", "=", "Encoder", "(", "in_channel", "=", "in_channel", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ",", "\n", "n_metadata", "=", "n_metadata", ",", "film_layers", "=", "film_layers", ",", "is_2d", "=", "is_2d", ",", "n_filters", "=", "n_filters", ")", "\n", "# Decoder path", "\n", "self", ".", "decoder", "=", "Decoder", "(", "out_channel", "=", "out_channel", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ",", "\n", "n_metadata", "=", "n_metadata", ",", "film_layers", "=", "film_layers", ",", "is_2d", "=", "is_2d", ",", "n_filters", "=", "n_filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMedUnet.forward": [[554, 559], ["models.FiLMedUnet.encoder", "models.FiLMedUnet.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "context", "=", "None", ")", ":", "\n", "        ", "features", ",", "w_film", "=", "self", ".", "encoder", "(", "x", ",", "context", ")", "\n", "preds", "=", "self", ".", "decoder", "(", "features", ",", "context", ",", "w_film", ")", "\n", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMgenerator.__init__": [[579, 585], ["torch.nn.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "n_features", ",", "n_channels", ",", "n_hid", "=", "64", ")", ":", "\n", "        ", "super", "(", "FiLMgenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "n_features", ",", "n_hid", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "n_hid", ",", "n_hid", "//", "4", ")", "\n", "self", ".", "linear3", "=", "nn", ".", "Linear", "(", "n_hid", "//", "4", ",", "n_channels", "*", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMgenerator.forward": [[586, 599], ["models.FiLMgenerator.linear1", "models.FiLMgenerator.sig", "models.FiLMgenerator.linear2", "models.FiLMgenerator.sig", "models.FiLMgenerator.linear3", "models.FiLMgenerator.sig"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "shared_weights", "=", "None", ")", ":", "\n", "        ", "if", "shared_weights", "is", "not", "None", ":", "# weight sharing", "\n", "            ", "self", ".", "linear1", ".", "weight", "=", "shared_weights", "[", "0", "]", "\n", "self", ".", "linear2", ".", "weight", "=", "shared_weights", "[", "1", "]", "\n", "\n", "", "x", "=", "self", ".", "linear1", "(", "x", ")", "\n", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "x", "=", "self", ".", "linear2", "(", "x", ")", "\n", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "x", "=", "self", ".", "linear3", "(", "x", ")", "\n", "\n", "out", "=", "self", ".", "sig", "(", "x", ")", "\n", "return", "out", ",", "[", "self", ".", "linear1", ".", "weight", ",", "self", ".", "linear2", ".", "weight", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMlayer.__init__": [[621, 633], ["torch.nn.Module.__init__", "models.FiLMgenerator"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "n_metadata", ",", "n_channels", ")", ":", "\n", "        ", "super", "(", "FiLMlayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "batch_size", "=", "None", "\n", "self", ".", "height", "=", "None", "\n", "self", ".", "width", "=", "None", "\n", "self", ".", "depth", "=", "None", "\n", "self", ".", "feature_size", "=", "None", "\n", "self", ".", "generator", "=", "FiLMgenerator", "(", "n_metadata", ",", "n_channels", ")", "\n", "# Add the parameters gammas and betas to access them out of the class.", "\n", "self", ".", "gammas", "=", "None", "\n", "self", ".", "betas", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.FiLMlayer.forward": [[634, 667], ["torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "models.FiLMlayer.generator", "len", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "len", "film_params.repeat.repeat.unsqueeze().unsqueeze", "film_params.repeat.repeat.repeat", "film_params.repeat.repeat.unsqueeze().unsqueeze().unsqueeze", "film_params.repeat.repeat.repeat", "len", "ValueError", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "film_params.repeat.repeat.unsqueeze", "film_params.repeat.repeat.unsqueeze().unsqueeze", "film_params.repeat.repeat.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "def", "forward", "(", "self", ",", "feature_maps", ",", "context", ",", "w_shared", ")", ":", "\n", "        ", "data_shape", "=", "feature_maps", ".", "data", ".", "shape", "\n", "if", "len", "(", "data_shape", ")", "==", "4", ":", "\n", "            ", "_", ",", "self", ".", "feature_size", ",", "self", ".", "height", ",", "self", ".", "width", "=", "data_shape", "\n", "", "elif", "len", "(", "data_shape", ")", "==", "5", ":", "\n", "            ", "_", ",", "self", ".", "feature_size", ",", "self", ".", "height", ",", "self", ".", "width", ",", "self", ".", "depth", "=", "data_shape", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Data should be either 2D (tensor length: 4) or 3D (tensor length: 5), found shape: {}\"", ".", "format", "(", "data_shape", ")", ")", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "context", "=", "torch", ".", "Tensor", "(", "context", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "            ", "context", "=", "torch", ".", "Tensor", "(", "context", ")", "\n", "\n", "# Estimate the FiLM parameters using a FiLM generator from the contioning metadata", "\n", "", "film_params", ",", "new_w_shared", "=", "self", ".", "generator", "(", "context", ",", "w_shared", ")", "\n", "\n", "# FiLM applies a different affine transformation to each channel,", "\n", "# consistent accross spatial locations", "\n", "if", "len", "(", "data_shape", ")", "==", "4", ":", "\n", "            ", "film_params", "=", "film_params", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "film_params", "=", "film_params", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "height", ",", "self", ".", "width", ")", "\n", "", "else", ":", "\n", "            ", "film_params", "=", "film_params", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "film_params", "=", "film_params", ".", "repeat", "(", "1", ",", "1", ",", "self", ".", "height", ",", "self", ".", "width", ",", "self", ".", "depth", ")", "\n", "\n", "", "self", ".", "gammas", "=", "film_params", "[", ":", ",", ":", "self", ".", "feature_size", ",", "]", "\n", "self", ".", "betas", "=", "film_params", "[", ":", ",", "self", ".", "feature_size", ":", ",", "]", "\n", "\n", "# Apply the linear modulation", "\n", "output", "=", "self", ".", "gammas", "*", "feature_maps", "+", "self", ".", "betas", "\n", "\n", "return", "output", ",", "new_w_shared", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.HeMISUnet.__init__": [[701, 714], ["torch.nn.Module.__init__", "torch.ModuleDict", "torch.ModuleDict", "torch.ModuleDict", "models.Decoder", "models.Encoder"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "contrasts", ",", "out_channel", "=", "1", ",", "depth", "=", "3", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "HeMISUnet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "contrasts", "=", "contrasts", "\n", "\n", "# Encoder path", "\n", "self", ".", "Encoder_mod", "=", "nn", ".", "ModuleDict", "(", "\n", "[", "[", "'Encoder_{}'", ".", "format", "(", "Mod", ")", ",", "Encoder", "(", "in_channel", "=", "1", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "\n", "bn_momentum", "=", "bn_momentum", ")", "]", "for", "Mod", "in", "self", ".", "contrasts", "]", ")", "\n", "\n", "# Decoder path", "\n", "self", ".", "decoder", "=", "Decoder", "(", "out_channel", "=", "out_channel", ",", "depth", "=", "depth", ",", "dropout_rate", "=", "dropout_rate", ",", "\n", "bn_momentum", "=", "bn_momentum", ",", "hemis", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.HeMISUnet.forward": [[715, 743], ["enumerate", "range", "models.HeMISUnet.decoder", "range", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat().transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "features_mod[].append", "features[].unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "torch.cat().unsqueeze", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "[].squeeze().mean", "[].squeeze().var", "[].squeeze", "[].squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x_mods", ",", "indexes_mod", ")", ":", "\n", "        ", "\"\"\"\n        X is list like X = [x_T1, x_T2, x_T2S, x_F]\n        indexes_mod: list of arrays like [[1, 1, 1], [1, 1, 0], [1, 0, 1], [1, 1, 0]]\n        N.B. len(list) = number of contrasts.\n        len(list[i]) = Batch size\n        \"\"\"", "\n", "features_mod", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "depth", "+", "1", ")", "]", "\n", "\n", "# Down-sampling", "\n", "for", "i", ",", "Mod", "in", "enumerate", "(", "self", ".", "contrasts", ")", ":", "\n", "            ", "features", ",", "_", "=", "self", ".", "Encoder_mod", "[", "'Encoder_{}'", ".", "format", "(", "Mod", ")", "]", "(", "x_mods", "[", "i", "]", ")", "\n", "\n", "for", "j", "in", "range", "(", "self", ".", "depth", "+", "1", ")", ":", "\n", "                ", "features_mod", "[", "j", "]", ".", "append", "(", "features", "[", "j", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "# Abstraction", "\n", "", "", "for", "j", "in", "range", "(", "self", ".", "depth", "+", "1", ")", ":", "\n", "            ", "features_cat", "=", "torch", ".", "cat", "(", "features_mod", "[", "j", "]", ",", "0", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n", "features_mod", "[", "j", "]", "=", "torch", ".", "cat", "(", "[", "torch", ".", "cat", "(", "[", "features_cat", "[", "i", "]", "[", "indexes_mod", "[", "i", "]", "]", ".", "squeeze", "(", "1", ")", ".", "mean", "(", "0", ")", ",", "\n", "features_cat", "[", "i", "]", "[", "indexes_mod", "[", "i", "]", "]", ".", "squeeze", "(", "1", ")", ".", "var", "(", "0", ")", "]", ",", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "indexes_mod", ")", ")", "]", ",", "0", ")", "\n", "\n", "# Up-sampling", "\n", "", "preds", "=", "self", ".", "decoder", "(", "features_mod", ")", "\n", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.__init__": [[776, 938], ["torch.Module.__init__", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Dropout3d", "torch.Dropout3d", "torch.Dropout3d", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_conv", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_conv", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "models.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "models.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "models.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "models.Modified3DUNet.conv_norm_lrelu", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "models.FiLMlayer", "models.FiLMlayer", "models.FiLMlayer", "models.FiLMlayer", "models.Modified3DUNet.norm_lrelu", "models.FiLMlayer", "models.Modified3DUNet.upscale_conv_norm_lrelu", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "models.FiLMlayer", "models.UnetGridGatingSignal3", "models.GridAttentionBlockND", "models.GridAttentionBlockND", "models.GridAttentionBlockND", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "models.FiLMlayer", "models.FiLMlayer", "models.FiLMlayer", "models.FiLMlayer"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.lrelu_conv", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_conv", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.upscale_conv_norm_lrelu", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu"], ["def", "__init__", "(", "self", ",", "in_channel", ",", "out_channel", ",", "n_filters", "=", "16", ",", "attention", "=", "False", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "\n", "final_activation", "=", "\"sigmoid\"", ",", "n_metadata", "=", "None", ",", "film_layers", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Modified3DUNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channel", "\n", "self", ".", "n_classes", "=", "out_channel", "\n", "self", ".", "base_n_filter", "=", "n_filters", "\n", "self", ".", "attention", "=", "attention", "\n", "self", ".", "momentum", "=", "bn_momentum", "\n", "self", ".", "final_activation", "=", "final_activation", "\n", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "dropout3d", "=", "nn", ".", "Dropout3d", "(", "p", "=", "dropout_rate", ")", "\n", "self", ".", "upsacle", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "# Level 1 context pathway", "\n", "self", ".", "conv3d_c1_1", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "in_channels", ",", "self", ".", "base_n_filter", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer1", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", ")", "if", "film_layers", "and", "film_layers", "[", "0", "]", "else", "None", "\n", "self", ".", "conv3d_c1_2", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "lrelu_conv_c1", "=", "self", ".", "lrelu_conv", "(", "\n", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", ")", "\n", "self", ".", "inorm3d_c1", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Level 2 context pathway", "\n", "self", ".", "conv3d_c2", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", ",", "self", ".", "base_n_filter", "*", "2", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer2", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "2", ")", "if", "film_layers", "and", "film_layers", "[", "1", "]", "else", "None", "\n", "self", ".", "norm_lrelu_conv_c2", "=", "self", ".", "norm_lrelu_conv", "(", "\n", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "inorm3d_c2", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "2", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Level 3 context pathway", "\n", "self", ".", "conv3d_c3", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "4", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer3", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "4", ")", "if", "film_layers", "and", "film_layers", "[", "2", "]", "else", "None", "\n", "self", ".", "norm_lrelu_conv_c3", "=", "self", ".", "norm_lrelu_conv", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "inorm3d_c3", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "4", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Level 4 context pathway", "\n", "self", ".", "conv3d_c4", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "8", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer4", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "8", ")", "if", "film_layers", "and", "film_layers", "[", "3", "]", "else", "None", "\n", "self", ".", "norm_lrelu_conv_c4", "=", "self", ".", "norm_lrelu_conv", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "inorm3d_c4", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Level 5 context pathway, level 0 localization pathway", "\n", "self", ".", "conv3d_c5", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "16", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", "\n", ")", "\n", "\n", "self", ".", "norm_lrelu_conv_c5", "=", "self", ".", "norm_lrelu_conv", "(", "\n", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "\n", "if", "film_layers", "and", "film_layers", "[", "4", "]", ":", "\n", "            ", "self", ".", "norm_lrelu_0", "=", "self", ".", "norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "film_layer5", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "upscale_conv_norm_lrelu_0", "=", "self", ".", "upscale_conv_norm_lrelu", "(", "self", ".", "base_n_filter", "*", "16", ",", "\n", "self", ".", "base_n_filter", "*", "8", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "\n", "", "self", ".", "conv3d_l0", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer6", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "8", ")", "if", "film_layers", "and", "film_layers", "[", "5", "]", "else", "None", "\n", "self", ".", "inorm3d_l0", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "8", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Attention UNet", "\n", "if", "self", ".", "attention", ":", "\n", "            ", "self", ".", "gating", "=", "UnetGridGatingSignal3", "(", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "8", ",", "kernel_size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "\n", "is_batchnorm", "=", "True", ")", "\n", "\n", "# attention blocks", "\n", "self", ".", "attentionblock2", "=", "GridAttentionBlockND", "(", "in_channels", "=", "self", ".", "base_n_filter", "*", "2", ",", "\n", "gating_channels", "=", "self", ".", "base_n_filter", "*", "8", ",", "\n", "inter_channels", "=", "self", ".", "base_n_filter", "*", "2", ",", "\n", "sub_sample_factor", "=", "(", "2", ",", "2", ",", "2", ")", ",", "\n", ")", "\n", "self", ".", "attentionblock3", "=", "GridAttentionBlockND", "(", "in_channels", "=", "self", ".", "base_n_filter", "*", "4", ",", "\n", "gating_channels", "=", "self", ".", "base_n_filter", "*", "8", ",", "\n", "inter_channels", "=", "self", ".", "base_n_filter", "*", "4", ",", "\n", "sub_sample_factor", "=", "(", "2", ",", "2", ",", "2", ")", ",", "\n", ")", "\n", "self", ".", "attentionblock4", "=", "GridAttentionBlockND", "(", "in_channels", "=", "self", ".", "base_n_filter", "*", "8", ",", "\n", "gating_channels", "=", "self", ".", "base_n_filter", "*", "8", ",", "\n", "inter_channels", "=", "self", ".", "base_n_filter", "*", "8", ",", "\n", "sub_sample_factor", "=", "(", "2", ",", "2", ",", "2", ")", ",", "\n", ")", "\n", "self", ".", "inorm3d_l0", "=", "nn", ".", "InstanceNorm3d", "(", "self", ".", "base_n_filter", "*", "16", ",", "momentum", "=", "self", ".", "momentum", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "", "self", ".", "conv_norm_lrelu_l1", "=", "self", ".", "conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "16", ")", "\n", "self", ".", "conv3d_l1", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "16", ",", "self", ".", "base_n_filter", "*", "8", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer7", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "4", ")", "if", "film_layers", "and", "film_layers", "[", "6", "]", "else", "None", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "\n", "# Level 2 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l2", "=", "self", ".", "conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "8", ")", "\n", "self", ".", "conv3d_l2", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "base_n_filter", "*", "4", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer8", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", "*", "2", ")", "if", "film_layers", "and", "film_layers", "[", "7", "]", "else", "None", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l3", "=", "self", ".", "conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "4", ")", "\n", "self", ".", "conv3d_l3", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "base_n_filter", "*", "2", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer9", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "base_n_filter", ")", "if", "film_layers", "and", "film_layers", "[", "8", "]", "else", "None", "\n", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "self", ".", "conv_norm_lrelu_l4", "=", "self", ".", "conv_norm_lrelu", "(", "\n", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "base_n_filter", "*", "2", ")", "\n", "self", ".", "conv3d_l4", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "2", ",", "self", ".", "n_classes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "# self.film_layer10 = FiLMlayer(n_metadata, ) if film_layers and film_layers[9] else None", "\n", "\n", "self", ".", "ds2_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "8", ",", "self", ".", "n_classes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "ds3_1x1_conv3d", "=", "nn", ".", "Conv3d", "(", "\n", "self", ".", "base_n_filter", "*", "4", ",", "self", ".", "n_classes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", "\n", ")", "\n", "self", ".", "film_layer10", "=", "FiLMlayer", "(", "n_metadata", ",", "self", ".", "n_classes", ")", "if", "film_layers", "and", "film_layers", "[", "9", "]", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.conv_norm_lrelu": [[939, 945], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_conv": [[946, 952], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "norm_lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.lrelu_conv": [[953, 958], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d"], "methods", ["None"], ["", "def", "lrelu_conv", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu": [[959, 969], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "norm_lrelu_upscale_conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.norm_lrelu": [[970, 974], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "norm_lrelu", "(", "self", ",", "feat_in", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_in", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.upscale_conv_norm_lrelu": [[975, 983], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.InstanceNorm3d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["None"], ["", "def", "upscale_conv_norm_lrelu", "(", "self", ",", "feat_in", ",", "feat_out", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ",", "\n", "# should be feat_in*2 or feat_in", "\n", "nn", ".", "Conv3d", "(", "feat_in", ",", "feat_out", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "InstanceNorm3d", "(", "feat_out", ",", "momentum", "=", "self", ".", "momentum", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Modified3DUNet.forward": [[984, 1132], ["models.Modified3DUNet.conv3d_c1_1", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.conv3d_c1_2", "models.Modified3DUNet.dropout3d", "models.Modified3DUNet.lrelu_conv_c1", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.inorm3d_c1", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.conv3d_c2", "models.Modified3DUNet.norm_lrelu_conv_c2", "models.Modified3DUNet.dropout3d", "models.Modified3DUNet.norm_lrelu_conv_c2", "models.Modified3DUNet.inorm3d_c2", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.conv3d_c3", "models.Modified3DUNet.norm_lrelu_conv_c3", "models.Modified3DUNet.dropout3d", "models.Modified3DUNet.norm_lrelu_conv_c3", "models.Modified3DUNet.inorm3d_c3", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.conv3d_c4", "models.Modified3DUNet.norm_lrelu_conv_c4", "models.Modified3DUNet.dropout3d", "models.Modified3DUNet.norm_lrelu_conv_c4", "models.Modified3DUNet.inorm3d_c4", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.conv3d_c5", "models.Modified3DUNet.norm_lrelu_conv_c5", "models.Modified3DUNet.dropout3d", "models.Modified3DUNet.norm_lrelu_conv_c5", "models.Modified3DUNet.conv3d_l0", "models.Modified3DUNet.inorm3d_l0", "models.Modified3DUNet.lrelu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Modified3DUNet.conv_norm_lrelu_l1", "models.Modified3DUNet.conv3d_l1", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Modified3DUNet.conv_norm_lrelu_l2", "models.Modified3DUNet.conv3d_l2", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Modified3DUNet.conv_norm_lrelu_l3", "models.Modified3DUNet.conv3d_l3", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Modified3DUNet.conv_norm_lrelu_l4", "models.Modified3DUNet.conv3d_l4", "models.Modified3DUNet.ds2_1x1_conv3d", "models.Modified3DUNet.upsacle", "models.Modified3DUNet.ds3_1x1_conv3d", "models.Modified3DUNet.upsacle", "hasattr", "models.Modified3DUNet.film_layer1", "hasattr", "models.Modified3DUNet.film_layer2", "hasattr", "models.Modified3DUNet.film_layer3", "hasattr", "models.Modified3DUNet.film_layer4", "models.Modified3DUNet.inorm3d_l0", "models.Modified3DUNet.lrelu", "models.Modified3DUNet.gating", "models.Modified3DUNet.attentionblock4", "models.Modified3DUNet.attentionblock3", "models.Modified3DUNet.attentionblock2", "hasattr", "models.Modified3DUNet.norm_lrelu_0", "models.Modified3DUNet.film_layer5", "models.Modified3DUNet.upscale_conv_norm_lrelu_0", "models.Modified3DUNet.norm_lrelu_upscale_conv_norm_lrelu_l0", "hasattr", "models.Modified3DUNet.film_layer6", "hasattr", "models.Modified3DUNet.film_layer7", "hasattr", "models.Modified3DUNet.film_layer8", "hasattr", "models.Modified3DUNet.film_layer9", "hasattr", "models.Modified3DUNet.film_layer10", "hasattr", "ValueError", "hasattr", "models.Modified3DUNet.softmax", "hasattr", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "bool", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "context", "=", "None", ",", "w_film", "=", "None", ")", ":", "\n", "#  Level 1 context pathway", "\n", "        ", "out", "=", "self", ".", "conv3d_c1_1", "(", "x", ")", "\n", "residual_1", "=", "out", "\n", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_c1_2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu_conv_c1", "(", "out", ")", "\n", "# Element Wise Summation", "\n", "out", "+=", "residual_1", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "context_1", "=", "out", "\n", "out", "=", "self", ".", "inorm3d_c1", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer1'", ")", "and", "self", ".", "film_layer1", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer1", "(", "out", ",", "context", ",", "w_film", ")", "\n", "\n", "# Level 2 context pathway", "\n", "", "out", "=", "self", ".", "conv3d_c2", "(", "out", ")", "\n", "residual_2", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c2", "(", "out", ")", "\n", "out", "+=", "residual_2", "\n", "out", "=", "self", ".", "inorm3d_c2", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer2'", ")", "and", "self", ".", "film_layer2", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer2", "(", "out", ",", "context", ",", "w_film", ")", "\n", "", "context_2", "=", "out", "\n", "\n", "# Level 3 context pathway", "\n", "out", "=", "self", ".", "conv3d_c3", "(", "out", ")", "\n", "residual_3", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c3", "(", "out", ")", "\n", "out", "+=", "residual_3", "\n", "out", "=", "self", ".", "inorm3d_c3", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer3'", ")", "and", "self", ".", "film_layer3", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer3", "(", "out", ",", "context", ",", "w_film", ")", "\n", "", "context_3", "=", "out", "\n", "\n", "# Level 4 context pathway", "\n", "out", "=", "self", ".", "conv3d_c4", "(", "out", ")", "\n", "residual_4", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c4", "(", "out", ")", "\n", "out", "+=", "residual_4", "\n", "out", "=", "self", ".", "inorm3d_c4", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer4'", ")", "and", "self", ".", "film_layer4", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer4", "(", "out", ",", "context", ",", "w_film", ")", "\n", "", "context_4", "=", "out", "\n", "\n", "# Level 5", "\n", "out", "=", "self", ".", "conv3d_c5", "(", "out", ")", "\n", "residual_5", "=", "out", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout3d", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_conv_c5", "(", "out", ")", "\n", "out", "+=", "residual_5", "\n", "\n", "if", "self", ".", "attention", ":", "\n", "            ", "out", "=", "self", ".", "inorm3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "\n", "gating", "=", "self", ".", "gating", "(", "out", ")", "\n", "context_4", ",", "att4", "=", "self", ".", "attentionblock4", "(", "context_4", ",", "gating", ")", "\n", "context_3", ",", "att3", "=", "self", ".", "attentionblock3", "(", "context_3", ",", "gating", ")", "\n", "context_2", ",", "att2", "=", "self", ".", "attentionblock2", "(", "context_2", ",", "gating", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ",", "'film_layer5'", ")", "and", "self", ".", "film_layer5", ":", "\n", "            ", "out", "=", "self", ".", "norm_lrelu_0", "(", "out", ")", "\n", "out", ",", "w_film", "=", "self", ".", "film_layer5", "(", "out", ",", "context", ",", "w_film", ")", "\n", "out", "=", "self", ".", "upscale_conv_norm_lrelu_0", "(", "out", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l0", "(", "out", ")", "\n", "\n", "", "out", "=", "self", ".", "conv3d_l0", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "inorm3d_l0", "(", "out", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer6'", ")", "and", "self", ".", "film_layer6", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer6", "(", "out", ",", "context", ",", "w_film", ")", "\n", "\n", "# Level 1 localization pathway", "\n", "", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_4", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv3d_l1", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l1", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer7'", ")", "and", "self", ".", "film_layer7", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer7", "(", "out", ",", "context", ",", "w_film", ")", "\n", "\n", "\n", "# Level 2 localization pathway", "\n", "", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_3", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l2", "(", "out", ")", "\n", "ds2", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l2", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l2", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer8'", ")", "and", "self", ".", "film_layer8", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer8", "(", "out", ",", "context", ",", "w_film", ")", "\n", "\n", "# Level 3 localization pathway", "\n", "", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "context_2", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l3", "(", "out", ")", "\n", "ds3", "=", "out", "\n", "out", "=", "self", ".", "conv3d_l3", "(", "out", ")", "\n", "out", "=", "self", ".", "norm_lrelu_upscale_conv_norm_lrelu_l3", "(", "out", ")", "\n", "if", "hasattr", "(", "self", ",", "'film_layer9'", ")", "and", "self", ".", "film_layer9", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer9", "(", "out", ",", "context", ",", "w_film", ")", "\n", "\n", "# Level 4 localization pathway", "\n", "", "out", "=", "torch", ".", "cat", "(", "[", "context_1", ",", "out", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_norm_lrelu_l4", "(", "out", ")", "\n", "\n", "out_pred", "=", "self", ".", "conv3d_l4", "(", "out", ")", "\n", "\n", "ds2_1x1_conv", "=", "self", ".", "ds2_1x1_conv3d", "(", "ds2", ")", "\n", "ds1_ds2_sum_upscale", "=", "self", ".", "upsacle", "(", "ds2_1x1_conv", ")", "\n", "ds3_1x1_conv", "=", "self", ".", "ds3_1x1_conv3d", "(", "ds3", ")", "\n", "ds1_ds2_sum_upscale_ds3_sum", "=", "ds1_ds2_sum_upscale", "+", "ds3_1x1_conv", "\n", "ds1_ds2_sum_upscale_ds3_sum_upscale", "=", "self", ".", "upsacle", "(", "\n", "ds1_ds2_sum_upscale_ds3_sum", ")", "\n", "\n", "out", "=", "out_pred", "+", "ds1_ds2_sum_upscale_ds3_sum_upscale", "\n", "if", "hasattr", "(", "self", ",", "'film_layer10'", ")", "and", "self", ".", "film_layer10", ":", "\n", "            ", "out", ",", "w_film", "=", "self", ".", "film_layer10", "(", "out", ",", "context", ",", "w_film", ")", "\n", "", "seg_layer", "=", "out", "\n", "\n", "if", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "not", "in", "[", "\"softmax\"", ",", "\"relu\"", ",", "\"sigmoid\"", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"final_activation value has to be either softmax, relu, or sigmoid\"", ")", "\n", "", "elif", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "==", "\"softmax\"", ":", "\n", "            ", "out", "=", "self", ".", "softmax", "(", "out", ")", "\n", "", "elif", "hasattr", "(", "self", ",", "\"final_activation\"", ")", "and", "self", ".", "final_activation", "==", "\"relu\"", ":", "\n", "            ", "out", "=", "nn", ".", "ReLU", "(", ")", "(", "seg_layer", ")", "/", "nn", ".", "ReLU", "(", ")", "(", "seg_layer", ")", ".", "max", "(", ")", "if", "bool", "(", "nn", ".", "ReLU", "(", ")", "(", "seg_layer", ")", ".", "max", "(", ")", ")", "else", "nn", ".", "ReLU", "(", ")", "(", "seg_layer", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "torch", ".", "sigmoid", "(", "out", ")", "\n", "\n", "", "if", "self", ".", "n_classes", ">", "1", ":", "\n", "# Remove background class", "\n", "            ", "out", "=", "out", "[", ":", ",", "1", ":", ",", "]", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.UNet3D.__init__": [[1138, 1144], ["models.Modified3DUNet.__init__", "models.Modified3DUNet"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", ",", "out_channel", ",", "n_filters", "=", "16", ",", "attention", "=", "False", ",", "dropout_rate", "=", "0.3", ",", "bn_momentum", "=", "0.1", ",", "\n", "final_activation", "=", "\"sigmoid\"", ",", "n_metadata", "=", "None", ",", "film_layers", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "UNet3D", ",", "self", ")", ".", "__init__", "(", ")", "\n", "Modified3DUNet", "(", "in_channel", "=", "in_channel", ",", "out_channel", "=", "out_channel", ",", "n_filters", "=", "n_filters", ",", "attention", "=", "attention", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "bn_momentum", "=", "bn_momentum", ",", "final_activation", "=", "final_activation", ",", "\n", "n_metadata", "=", "n_metadata", ",", "film_layers", "=", "film_layers", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.GridAttentionBlockND.__init__": [[1174, 1234], ["torch.Module.__init__", "isinstance", "torch.Sequential", "torch.Sequential", "torch.Sequential", "conv_nd", "conv_nd", "conv_nd", "models.GridAttentionBlockND.children", "isinstance", "conv_nd", "bn", "m.apply", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "gating_channels", ",", "inter_channels", "=", "None", ",", "dimension", "=", "3", ",", "\n", "sub_sample_factor", "=", "(", "2", ",", "2", ",", "2", ")", ")", ":", "\n", "        ", "super", "(", "GridAttentionBlockND", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "dimension", "in", "[", "2", ",", "3", "]", "\n", "\n", "# Downsampling rate for the input featuremap", "\n", "if", "isinstance", "(", "sub_sample_factor", ",", "tuple", ")", ":", "\n", "            ", "self", ".", "sub_sample_factor", "=", "sub_sample_factor", "\n", "", "elif", "isinstance", "(", "sub_sample_factor", ",", "list", ")", ":", "\n", "            ", "self", ".", "sub_sample_factor", "=", "tuple", "(", "sub_sample_factor", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sub_sample_factor", "=", "tuple", "(", "[", "sub_sample_factor", "]", ")", "*", "dimension", "\n", "\n", "# Default parameter set", "\n", "", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "sub_sample_kernel_size", "=", "self", ".", "sub_sample_factor", "\n", "\n", "# Number of channels (pixel dimensions)", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "gating_channels", "=", "gating_channels", "\n", "self", ".", "inter_channels", "=", "inter_channels", "\n", "\n", "if", "self", ".", "inter_channels", "is", "None", ":", "\n", "            ", "self", ".", "inter_channels", "=", "in_channels", "//", "2", "\n", "if", "self", ".", "inter_channels", "==", "0", ":", "\n", "                ", "self", ".", "inter_channels", "=", "1", "\n", "\n", "", "", "if", "dimension", "==", "3", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv3d", "\n", "bn", "=", "nn", ".", "BatchNorm3d", "\n", "self", ".", "upsample_mode", "=", "'trilinear'", "\n", "", "elif", "dimension", "==", "2", ":", "\n", "            ", "conv_nd", "=", "nn", ".", "Conv2d", "\n", "bn", "=", "nn", ".", "BatchNorm2d", "\n", "self", ".", "upsample_mode", "=", "'bilinear'", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "# Output transform", "\n", "", "self", ".", "W", "=", "nn", ".", "Sequential", "(", "\n", "conv_nd", "(", "in_channels", "=", "self", ".", "in_channels", ",", "out_channels", "=", "self", ".", "in_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", ",", "\n", "bn", "(", "self", ".", "in_channels", ")", ",", "\n", ")", "\n", "\n", "# Theta^T * x_ij + Phi^T * gating_signal + bias", "\n", "self", ".", "theta", "=", "conv_nd", "(", "in_channels", "=", "self", ".", "in_channels", ",", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "self", ".", "sub_sample_kernel_size", ",", "stride", "=", "self", ".", "sub_sample_factor", ",", "padding", "=", "0", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "phi", "=", "conv_nd", "(", "in_channels", "=", "self", ".", "gating_channels", ",", "out_channels", "=", "self", ".", "inter_channels", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", "\n", "self", ".", "psi", "=", "conv_nd", "(", "in_channels", "=", "self", ".", "inter_channels", ",", "out_channels", "=", "1", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "True", ")", "\n", "\n", "# Initialise weights", "\n", "for", "m", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "m", ".", "apply", "(", "weights_init_kaiming", ")", "\n", "\n", "# Define the operation", "\n", "", "self", ".", "operation_function", "=", "self", ".", "_concatenation", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.GridAttentionBlockND.forward": [[1235, 1238], ["models.GridAttentionBlockND.operation_function"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "g", ")", ":", "\n", "        ", "output", "=", "self", ".", "operation_function", "(", "x", ",", "g", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.GridAttentionBlockND._concatenation": [[1239, 1263], ["x.size", "models.GridAttentionBlockND.theta", "models.GridAttentionBlockND.size", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.relu", "torch.relu", "torch.relu", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.interpolate", "torch.interpolate", "torch.interpolate", "models.GridAttentionBlockND.W", "g.size", "models.GridAttentionBlockND.phi", "models.GridAttentionBlockND.psi", "torch.interpolate.expand_as"], "methods", ["None"], ["", "def", "_concatenation", "(", "self", ",", "x", ",", "g", ")", ":", "\n", "        ", "input_size", "=", "x", ".", "size", "(", ")", "\n", "batch_size", "=", "input_size", "[", "0", "]", "\n", "assert", "batch_size", "==", "g", ".", "size", "(", "0", ")", "\n", "\n", "# theta => (b, c, t, h, w) -> (b, i_c, t, h, w) -> (b, i_c, thw)", "\n", "# phi   => (b, g_d) -> (b, i_c)", "\n", "theta_x", "=", "self", ".", "theta", "(", "x", ")", "\n", "theta_x_size", "=", "theta_x", ".", "size", "(", ")", "\n", "\n", "# g (b, c, t', h', w') -> phi_g (b, i_c, t', h', w')", "\n", "#  Relu(theta_x + phi_g + bias) -> f = (b, i_c, thw) -> (b, i_c, t/s1, h/s2, w/s3)", "\n", "phi_g", "=", "F", ".", "interpolate", "(", "self", ".", "phi", "(", "g", ")", ",", "size", "=", "theta_x_size", "[", "2", ":", "]", ",", "mode", "=", "self", ".", "upsample_mode", ",", "align_corners", "=", "True", ")", "\n", "f", "=", "F", ".", "relu", "(", "theta_x", "+", "phi_g", ",", "inplace", "=", "True", ")", "\n", "\n", "#  psi^T * f -> (b, psi_i_c, t/s1, h/s2, w/s3)", "\n", "sigm_psi_f", "=", "torch", ".", "sigmoid", "(", "self", ".", "psi", "(", "f", ")", ")", "\n", "\n", "# upsample the attentions and multiply", "\n", "sigm_psi_f", "=", "F", ".", "interpolate", "(", "sigm_psi_f", ",", "size", "=", "input_size", "[", "2", ":", "]", ",", "mode", "=", "self", ".", "upsample_mode", ",", "align_corners", "=", "True", ")", "\n", "y", "=", "sigm_psi_f", ".", "expand_as", "(", "x", ")", "*", "x", "\n", "W_y", "=", "self", ".", "W", "(", "y", ")", "\n", "\n", "return", "W_y", ",", "sigm_psi_f", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.UnetGridGatingSignal3.__init__": [[1294, 1310], ["torch.Module.__init__", "models.UnetGridGatingSignal3.children", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "models.weights_init_kaiming", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.BatchNorm3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.weights_init_kaiming"], ["def", "__init__", "(", "self", ",", "in_size", ",", "out_size", ",", "kernel_size", "=", "(", "1", ",", "1", ",", "1", ")", ",", "is_batchnorm", "=", "True", ")", ":", "\n", "        ", "super", "(", "UnetGridGatingSignal3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "is_batchnorm", ":", "\n", "            ", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv3d", "(", "in_size", ",", "out_size", ",", "kernel_size", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "0", ",", "0", ")", ")", ",", "\n", "nn", ".", "BatchNorm3d", "(", "out_size", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv3d", "(", "in_size", ",", "out_size", ",", "kernel_size", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "0", ",", "0", ")", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n", "\n", "# initialise the blocks", "\n", "", "for", "m", "in", "self", ".", "children", "(", ")", ":", "\n", "            ", "weights_init_kaiming", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.UnetGridGatingSignal3.forward": [[1311, 1314], ["models.UnetGridGatingSignal3.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "outputs", "=", "self", ".", "conv1", "(", "inputs", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ConvBlock.__init__": [[1317, 1332], ["torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan", ",", "ksize", "=", "3", ",", "stride", "=", "1", ",", "pad", "=", "0", ",", "activation", "=", "nn", ".", "LeakyReLU", "(", ")", ")", ":", "\n", "        ", "\"\"\"\n        Perform convolution, activation and batch normalization.\n        Args:\n            in_chan (int): number of channels on input\n            out_chan (int): number of channel on output\n            ksize (int): size of kernel for the 2d convolution\n            stride (int): strides for 2d convolution\n            pad (int): pad for nn.conv2d\n            activation (nn.layers): activation layer. default Leaky ReLu\n        \"\"\"", "\n", "super", "(", "ConvBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_chan", ",", "out_chan", ",", "kernel_size", "=", "ksize", ",", "stride", "=", "stride", ",", "padding", "=", "pad", ")", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "batch_norm", "=", "nn", ".", "BatchNorm2d", "(", "out_chan", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.ConvBlock.forward": [[1333, 1335], ["models.ConvBlock.activation", "models.ConvBlock.batch_norm", "models.ConvBlock.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "activation", "(", "self", ".", "batch_norm", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.SimpleBlock.__init__": [[1338, 1353], ["torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Module.__init__", "models.ConvBlock", "models.ConvBlock", "models.ConvBlock", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_chan", ",", "out_chan_1x1", ",", "out_chan_3x3", ",", "activation", "=", "nn", ".", "LeakyReLU", "(", ")", ")", ":", "\n", "        ", "\"\"\"\n        Inception module with 3 convolutions with different kernel size with separate activation.\n        The 3 outputs are then concatenated. Max pooling performed on concatenation.\n        Args:\n            in_chan (int): number of channel of input\n            out_chan_1x1 (int): number of channel after first convolution block\n            out_chan_3x3 (int): number of channel for the other convolution blocks\n            activation (nn.layers): activation layer used in convolution block\n        \"\"\"", "\n", "super", "(", "SimpleBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "ConvBlock", "(", "in_chan", ",", "out_chan_1x1", ",", "ksize", "=", "3", ",", "pad", "=", "0", ",", "activation", "=", "activation", ")", "\n", "self", ".", "conv2", "=", "ConvBlock", "(", "in_chan", ",", "out_chan_3x3", ",", "ksize", "=", "5", ",", "pad", "=", "1", ",", "activation", "=", "activation", ")", "\n", "self", ".", "conv3", "=", "ConvBlock", "(", "in_chan", ",", "out_chan_3x3", ",", "ksize", "=", "9", ",", "pad", "=", "3", ",", "activation", "=", "activation", ")", "\n", "self", ".", "MP", "=", "nn", ".", "MaxPool2d", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.SimpleBlock.forward": [[1354, 1361], ["models.SimpleBlock.conv1", "models.SimpleBlock.conv2", "models.SimpleBlock.conv3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.SimpleBlock.MP"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "conv1_out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "conv2_out", "=", "self", ".", "conv2", "(", "x", ")", "\n", "conv3_out", "=", "self", ".", "conv3", "(", "x", ")", "\n", "output", "=", "torch", ".", "cat", "(", "[", "conv1_out", ",", "conv2_out", ",", "conv3_out", "]", ",", "1", ")", "\n", "output", "=", "self", ".", "MP", "(", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Countception.__init__": [[1381, 1420], ["torch.nn.Module.__init__", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "models.ConvBlock", "models.SimpleBlock", "models.SimpleBlock", "models.ConvBlock", "models.SimpleBlock", "models.SimpleBlock", "models.SimpleBlock", "models.SimpleBlock", "models.ConvBlock", "models.ConvBlock", "models.ConvBlock", "models.Countception.modules", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "models.ConvBlock", "isinstance", "isinstance", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "isinstance", "models.ConvBlock", "m.weight.data.fill_", "m.bias.data.zero_", "range", "torch.nn.init.calculate_gain", "torch.nn.init.calculate_gain", "torch.nn.init.calculate_gain"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", "=", "3", ",", "out_channel", "=", "1", ",", "use_logits", "=", "False", ",", "logits_per_output", "=", "12", ",", "name", "=", "'CC'", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Countception", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# params", "\n", "self", ".", "in_channel", "=", "in_channel", "\n", "self", ".", "out_channel", "=", "out_channel", "\n", "self", ".", "activation", "=", "nn", ".", "LeakyReLU", "(", "0.01", ")", "\n", "self", ".", "final_activation", "=", "nn", ".", "LeakyReLU", "(", "0.3", ")", "\n", "self", ".", "patch_size", "=", "40", "\n", "self", ".", "use_logits", "=", "use_logits", "\n", "self", ".", "logits_per_output", "=", "logits_per_output", "\n", "\n", "torch", ".", "LongTensor", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "ConvBlock", "(", "self", ".", "in_channel", ",", "64", ",", "ksize", "=", "3", ",", "pad", "=", "self", ".", "patch_size", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple1", "=", "SimpleBlock", "(", "64", ",", "16", ",", "16", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple2", "=", "SimpleBlock", "(", "48", ",", "16", ",", "32", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "conv2", "=", "ConvBlock", "(", "80", ",", "16", ",", "ksize", "=", "14", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple3", "=", "SimpleBlock", "(", "16", ",", "112", ",", "48", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple4", "=", "SimpleBlock", "(", "208", ",", "64", ",", "32", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple5", "=", "SimpleBlock", "(", "128", ",", "40", ",", "40", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "simple6", "=", "SimpleBlock", "(", "120", ",", "32", ",", "96", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "conv3", "=", "ConvBlock", "(", "224", ",", "32", ",", "ksize", "=", "20", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "conv4", "=", "ConvBlock", "(", "32", ",", "64", ",", "ksize", "=", "10", ",", "activation", "=", "self", ".", "activation", ")", "\n", "self", ".", "conv5", "=", "ConvBlock", "(", "64", ",", "32", ",", "ksize", "=", "9", ",", "activation", "=", "self", ".", "activation", ")", "\n", "\n", "if", "use_logits", ":", "\n", "            ", "self", ".", "conv6", "=", "nn", ".", "ModuleList", "(", "[", "ConvBlock", "(", "\n", "64", ",", "logits_per_output", ",", "ksize", "=", "1", ",", "activation", "=", "self", ".", "final_activation", ")", "for", "_", "in", "range", "(", "out_channel", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv6", "=", "ConvBlock", "(", "32", ",", "self", ".", "out_channel", ",", "ksize", "=", "20", ",", "pad", "=", "1", ",", "activation", "=", "self", ".", "final_activation", ")", "\n", "\n", "# Weight initialization", "\n", "", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ",", "gain", "=", "init", ".", "calculate_gain", "(", "'leaky_relu'", ",", "param", "=", "0.01", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.Countception.forward": [[1421, 1441], ["models.Countception.conv1", "models.Countception.simple1", "models.Countception.simple2", "models.Countception.conv2", "models.Countception.simple3", "models.Countception.simple4", "models.Countception.simple5", "models.Countception.simple6", "models.Countception.conv3", "models.Countception.conv4", "models.Countception.conv5", "models.Countception.conv6", "c", "models.Countception._print"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "net", "=", "self", ".", "conv1", "(", "x", ")", "# 32", "\n", "net", "=", "self", ".", "simple1", "(", "net", ")", "\n", "net", "=", "self", ".", "simple2", "(", "net", ")", "\n", "net", "=", "self", ".", "conv2", "(", "net", ")", "\n", "net", "=", "self", ".", "simple3", "(", "net", ")", "\n", "net", "=", "self", ".", "simple4", "(", "net", ")", "\n", "net", "=", "self", ".", "simple5", "(", "net", ")", "\n", "net", "=", "self", ".", "simple6", "(", "net", ")", "\n", "net", "=", "self", ".", "conv3", "(", "net", ")", "\n", "net", "=", "self", ".", "conv4", "(", "net", ")", "\n", "net", "=", "self", ".", "conv5", "(", "net", ")", "\n", "\n", "if", "self", ".", "use_logits", ":", "\n", "            ", "net", "=", "[", "c", "(", "net", ")", "for", "c", "in", "self", ".", "conv6", "]", "\n", "[", "self", ".", "_print", "(", "n", ")", "for", "n", "in", "net", "]", "\n", "", "else", ":", "\n", "            ", "net", "=", "self", ".", "conv6", "(", "net", ")", "\n", "\n", "", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.weights_init_kaiming": [[1265, 1278], ["classname.find", "torch.nn.init.kaiming_normal_", "classname.find", "torch.nn.init.kaiming_normal_", "classname.find", "torch.nn.init.normal_", "torch.nn.init.constant_"], "function", ["None"], ["", "", "def", "weights_init_kaiming", "(", "m", ")", ":", "\n", "    ", "\"\"\"Initialize weights according to method describe here:\n    https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/He_Delving_Deep_into_ICCV_2015_paper.pdf\n    \"\"\"", "\n", "\n", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'Conv'", ")", "!=", "-", "1", ":", "\n", "        ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "", "elif", "classname", ".", "find", "(", "'Linear'", ")", "!=", "-", "1", ":", "\n", "        ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "", "elif", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "        ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "1.0", ",", "0.02", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.set_model_for_retrain": [[1443, 1483], ["torch.load", "torch.load", "torch.load", "len", "int", "torch.load.named_parameters", "round", "torch.load.named_modules", "torch.load.named_modules", "hasattr", "name.startswith", "layer.reset_parameters"], "function", ["None"], ["", "", "def", "set_model_for_retrain", "(", "model_path", ",", "retrain_fraction", ",", "map_location", ",", "reset", "=", "True", ")", ":", "\n", "    ", "\"\"\"Set model for transfer learning.\n\n    The first layers (defined by 1-retrain_fraction) are frozen (i.e. requires_grad=False).\n    The weights of the last layers (defined by retrain_fraction) are reset unless reset option is False.\n\n    Args:\n        model_path (str): Pretrained model path.\n        retrain_fraction (float): Fraction of the model that will be retrained, between 0 and 1. If set to 0.3,\n            then the 30% last fraction of the model will be re-initalised and retrained.\n        map_location (str): Device.\n        reset (bool): if the un-frozen weight should be reset or kept as loaded.\n\n    Returns:\n        torch.Module: Model ready for retrain.\n    \"\"\"", "\n", "# Load pretrained model", "\n", "model", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "map_location", ")", "\n", "# Get number of layers with learnt parameters", "\n", "layer_names", "=", "[", "name", "for", "name", ",", "layer", "in", "model", ".", "named_modules", "(", ")", "if", "hasattr", "(", "layer", ",", "'reset_parameters'", ")", "]", "\n", "n_layers", "=", "len", "(", "layer_names", ")", "\n", "# Compute the number of these layers we want to freeze", "\n", "n_freeze", "=", "int", "(", "round", "(", "n_layers", "*", "(", "1", "-", "retrain_fraction", ")", ")", ")", "\n", "# Last frozen layer", "\n", "last_frozen_layer", "=", "layer_names", "[", "n_freeze", "]", "\n", "\n", "# Set freeze first layers", "\n", "for", "name", ",", "layer", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "not", "name", ".", "startswith", "(", "last_frozen_layer", ")", ":", "\n", "            ", "layer", ".", "requires_grad", "=", "False", "\n", "", "else", ":", "\n", "            ", "break", "\n", "\n", "# Reset weights of the last layers", "\n", "", "", "if", "reset", ":", "\n", "        ", "for", "name", ",", "layer", "in", "model", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "name", "in", "layer_names", "[", "n_freeze", ":", "]", ":", "\n", "                ", "layer", ".", "reset_parameters", "(", ")", "\n", "\n", "", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.get_model_filenames": [[1485, 1523], ["pathlib.Path().is_dir", "pathlib.Path", "pathlib.Path", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "pathlib.Path", "FileNotFoundError", "str", "str", "pathlib.Path", "pathlib.Path", "FileNotFoundError", "pathlib.Path.is_file", "FileNotFoundError", "pathlib.Path.is_file", "pathlib.Path.is_file", "pathlib.Path.is_file", "str", "str", "pathlib.Path.is_file", "pathlib.Path.is_file", "str", "pathlib.Path.is_file"], "function", ["None"], ["", "def", "get_model_filenames", "(", "folder_model", ")", ":", "\n", "    ", "\"\"\"Get trained model filenames from its folder path.\n\n    This function checks if the folder_model exists and get trained model path (.pt or .onnx based on\n    model and GPU availability) and its configuration file (.json) from it.\n\n    Args:\n        folder_name (str): Path of the model folder.\n\n    Returns:\n        str, str: Paths of the model (.pt or .onnx) and its configuration file (.json).\n    \"\"\"", "\n", "if", "Path", "(", "folder_model", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "prefix_model", "=", "Path", "(", "folder_model", ")", ".", "name", "\n", "fname_model_onnx", "=", "Path", "(", "folder_model", ",", "prefix_model", "+", "'.onnx'", ")", "\n", "fname_model_pt", "=", "Path", "(", "folder_model", ",", "prefix_model", "+", "'.pt'", ")", "\n", "cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "# Assign '.pt' or '.onnx' model based on file existence and GPU/CPU device availability", "\n", "if", "not", "fname_model_pt", ".", "is_file", "(", ")", "and", "not", "fname_model_onnx", ".", "is_file", "(", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f\"Model files not found in model folder: \"", "\n", "f\"'{str(fname_model_onnx)}' or '{str(fname_model_pt)}'\"", ")", "\n", "# '.pt' is preferred on GPU, or on CPU if '.onnx' doesn't exist", "\n", "", "elif", "(", "(", "cuda_available", "and", "fname_model_pt", ".", "is_file", "(", ")", ")", "or", "\n", "(", "not", "cuda_available", "and", "not", "fname_model_onnx", ".", "is_file", "(", ")", ")", ")", ":", "\n", "            ", "fname_model", "=", "fname_model_pt", "\n", "# '.onnx' is preferred on CPU, or on GPU if '.pt' doesn't exist", "\n", "", "elif", "(", "(", "not", "cuda_available", "and", "fname_model_onnx", ".", "is_file", "(", ")", ")", "or", "\n", "(", "cuda_available", "and", "not", "fname_model_pt", ".", "is_file", "(", ")", ")", ")", ":", "\n", "            ", "fname_model", "=", "fname_model_onnx", "\n", "\n", "", "fname_model_metadata", "=", "Path", "(", "folder_model", ",", "prefix_model", "+", "'.json'", ")", "\n", "if", "not", "fname_model_metadata", ".", "is_file", "(", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f\"Model config file not found in model folder: '{str(fname_model_metadata)}'\"", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "FileNotFoundError", "(", "folder_model", ")", "\n", "\n", "", "return", "str", "(", "fname_model", ")", ",", "str", "(", "fname_model_metadata", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_parser": [[34, 76], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_mutually_exclusive_group", "parser.add_mutually_exclusive_group.add_argument", "parser.add_mutually_exclusive_group.add_argument", "parser.add_mutually_exclusive_group.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument_group", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument", "parser.add_argument_group.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "add_help", "=", "False", ")", "\n", "\n", "command_group", "=", "parser", ".", "add_mutually_exclusive_group", "(", "required", "=", "False", ")", "\n", "\n", "command_group", ".", "add_argument", "(", "\"--train\"", ",", "dest", "=", "'train'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Perform training on data.\"", ")", "\n", "command_group", ".", "add_argument", "(", "\"--test\"", ",", "dest", "=", "'test'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Perform testing on trained model.\"", ")", "\n", "command_group", ".", "add_argument", "(", "\"--segment\"", ",", "dest", "=", "'segment'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Perform segmentation on data.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--config\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Path to configuration file.\"", ")", "\n", "\n", "# OPTIONAL ARGUMENTS", "\n", "optional_args", "=", "parser", ".", "add_argument_group", "(", "'OPTIONAL ARGUMENTS'", ")", "\n", "\n", "optional_args", ".", "add_argument", "(", "\"-pd\"", ",", "\"--path-data\"", ",", "dest", "=", "\"path_data\"", ",", "required", "=", "False", ",", "type", "=", "str", ",", "\n", "nargs", "=", "\"*\"", ",", "help", "=", "\"\"\"Path to data in BIDs format. You may list one\n                               or more paths; separate each path with a space, e.g.\n                               --path-data some/path/a some/path/b\"\"\"", ")", "\n", "optional_args", ".", "add_argument", "(", "\"-po\"", ",", "\"--path-output\"", ",", "required", "=", "False", ",", "type", "=", "str", ",", "dest", "=", "\"path_output\"", ",", "\n", "help", "=", "\"Path to output directory.\"", ")", "\n", "optional_args", ".", "add_argument", "(", "'-g'", ",", "'--gif'", ",", "required", "=", "False", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'Number of GIF files to output. Each GIF file corresponds to a 2D slice showing the '", "\n", "'prediction over epochs (one frame per epoch). The prediction is run on the '", "\n", "'validation dataset. GIF files are saved in the output path.'", ")", "\n", "optional_args", ".", "add_argument", "(", "'-t'", ",", "'--thr-increment'", ",", "dest", "=", "\"thr_increment\"", ",", "required", "=", "False", ",", "type", "=", "float", ",", "\n", "help", "=", "'A threshold analysis is performed at the end of the training using the trained '", "\n", "'model and the training+validation sub-datasets to find the optimal binarization '", "\n", "'threshold. The specified value indicates the increment between 0 and 1 used during '", "\n", "'the analysis (e.g. 0.1). Plot is saved under \"[PATH_OUTPUT]/thr.png\" and the '", "\n", "'optimal threshold in \"[PATH_OUTPUT]/config_file.json as \"binarize_prediction\" '", "\n", "'parameter.'", ")", "\n", "optional_args", ".", "add_argument", "(", "'--resume-training'", ",", "dest", "=", "\"resume_training\"", ",", "required", "=", "False", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Load a saved model (\"checkpoint.pth.tar\" in the output directory specified either with flag \"--path-output\" or via the config file \"output_path\" argument)  '", "\n", "'for resume training. This training state is saved everytime a new best model is saved in the output directory specified with flag \"--path-output\"'", ")", "\n", "optional_args", ".", "add_argument", "(", "'-h'", ",", "'--help'", ",", "action", "=", "'help'", ",", "default", "=", "argparse", ".", "SUPPRESS", ",", "\n", "help", "=", "'Shows function documentation.'", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.create_path_model": [[78, 91], ["pathlib.Path", "pathlib.Path.is_dir", "loguru.logger.info", "pathlib.Path.mkdir", "loguru.logger.info", "any", "joblib.dump", "pathlib.Path.joinpath", "joblib.dump", "pathlib.Path.joinpath"], "function", ["None"], ["", "def", "create_path_model", "(", "context", ",", "model_params", ",", "ds_train", ",", "path_output", ",", "train_onehotencoder", ")", ":", "\n", "    ", "path_model", "=", "Path", "(", "path_output", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", ")", "\n", "if", "not", "path_model", ".", "is_dir", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Creating model directory: {path_model}'", ")", "\n", "path_model", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "            ", "joblib", ".", "dump", "(", "train_onehotencoder", ",", "path_model", ".", "joinpath", "(", "\"one_hot_encoder.joblib\"", ")", ")", "\n", "if", "MetadataKW", ".", "METADATA_DICT", "in", "ds_train", "[", "0", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "0", "]", ":", "\n", "                ", "metadata_dict", "=", "ds_train", "[", "0", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "0", "]", "[", "MetadataKW", ".", "METADATA_DICT", "]", "\n", "joblib", ".", "dump", "(", "metadata_dict", ",", "path_model", ".", "joinpath", "(", "\"metadata_dict.joblib\"", ")", ")", "\n", "\n", "", "", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f'Model directory already exists: {path_model}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.check_multiple_raters": [[93, 102], ["any", "loguru.logger.info", "isinstance", "loguru.logger.error", "sys.exit"], "function", ["None"], ["", "", "def", "check_multiple_raters", "(", "is_train", ",", "loader_params", ")", ":", "\n", "    ", "if", "any", "(", "[", "isinstance", "(", "class_suffix", ",", "list", ")", "for", "class_suffix", "in", "loader_params", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", "]", ")", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"Annotations from multiple raters will be used during model training, one annotation from one rater \"", "\n", "\"randomly selected at each iteration.\\n\"", ")", "\n", "if", "not", "is_train", ":", "\n", "            ", "logger", ".", "error", "(", "\n", "\"Please provide only one annotation per class in 'target_suffix' when not training a model.\\n\"", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.film_normalize_data": [[104, 118], ["ivadomed.loader.film.get_film_metadata_models", "ivadomed.loader.film.normalize_metadata", "model_params.update", "joblib.dump", "joblib.dump", "pathlib.Path", "pathlib.Path", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.get_film_metadata_models", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.normalize_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "", "", "def", "film_normalize_data", "(", "context", ",", "model_params", ",", "ds_train", ",", "ds_valid", ",", "path_output", ")", ":", "\n", "# Normalize metadata before sending to the FiLM network", "\n", "    ", "results", "=", "imed_film", ".", "get_film_metadata_models", "(", "ds_train", "=", "ds_train", ",", "\n", "metadata_type", "=", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", ",", "\n", "debugging", "=", "context", "[", "ConfigKW", ".", "DEBUGGING", "]", ")", "\n", "ds_train", ",", "train_onehotencoder", ",", "metadata_clustering_models", "=", "results", "\n", "ds_valid", "=", "imed_film", ".", "normalize_metadata", "(", "ds_valid", ",", "metadata_clustering_models", ",", "context", "[", "ConfigKW", ".", "DEBUGGING", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", ")", "\n", "model_params", ".", "update", "(", "{", "ModelParamsKW", ".", "FILM_ONEHOTENCODER", ":", "train_onehotencoder", ",", "\n", "ModelParamsKW", ".", "N_METADATA", ":", "len", "(", "[", "ll", "for", "l", "in", "train_onehotencoder", ".", "categories_", "for", "ll", "in", "l", "]", ")", "}", ")", "\n", "joblib", ".", "dump", "(", "metadata_clustering_models", ",", "Path", "(", "path_output", ",", "\"clustering_models.joblib\"", ")", ")", "\n", "joblib", ".", "dump", "(", "train_onehotencoder", ",", "Path", "(", "path_output", "+", "\"one_hot_encoder.joblib\"", ")", ")", "\n", "\n", "return", "model_params", ",", "ds_train", ",", "ds_valid", ",", "train_onehotencoder", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_dataset": [[120, 126], ["ivadomed.loader.loader.load_dataset"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset"], ["", "def", "get_dataset", "(", "bids_df", ",", "loader_params", ",", "data_lst", ",", "transform_params", ",", "cuda_available", ",", "device", ",", "ds_type", ")", ":", "\n", "    ", "ds", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "{", "**", "loader_params", ",", "**", "{", "'data_list'", ":", "data_lst", ",", "\n", "'transforms_params'", ":", "transform_params", ",", "\n", "'dataset_type'", ":", "ds_type", "}", "}", ",", "device", "=", "device", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "return", "ds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.save_config_file": [[128, 135], ["pathlib.Path().open", "json.dump", "pathlib.Path().open", "json.dump", "pathlib.Path", "pathlib.Path"], "function", ["None"], ["", "def", "save_config_file", "(", "context", ",", "path_output", ")", ":", "\n", "# Save config file within path_output and path_output/model_name", "\n", "# Done after the threshold_analysis to propate this info in the config files", "\n", "    ", "with", "Path", "(", "path_output", ",", "\"config_file.json\"", ")", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "context", ",", "fp", ",", "indent", "=", "4", ")", "\n", "", "with", "Path", "(", "path_output", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", "+", "\".json\"", ")", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "context", ",", "fp", ",", "indent", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_loader_params": [[137, 154], ["copy.deepcopy", "copy.deepcopy.update", "copy.deepcopy.update"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "", "def", "set_loader_params", "(", "context", ",", "is_train", ")", ":", "\n", "    ", "loader_params", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", ")", "\n", "if", "is_train", ":", "\n", "        ", "loader_params", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", "=", "loader_params", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "TRAINING_VALIDATION", "]", "\n", "", "else", ":", "\n", "        ", "loader_params", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", "=", "loader_params", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "TESTING", "]", "\n", "", "if", "ConfigKW", ".", "FILMED_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", "[", "ModelParamsKW", ".", "APPLIED", "]", ":", "\n", "        ", "loader_params", ".", "update", "(", "{", "LoaderParamsKW", ".", "METADATA_TYPE", ":", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", "[", "ModelParamsKW", ".", "METADATA", "]", "}", ")", "\n", "\n", "# Load metadata necessary to balance the loader", "\n", "", "if", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "APPLIED", "]", "and", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "TYPE", "]", "!=", "'gt'", ":", "\n", "        ", "loader_params", ".", "update", "(", "{", "LoaderParamsKW", ".", "METADATA_TYPE", ":", "\n", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "TYPE", "]", "}", ")", "\n", "", "return", "loader_params", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_model_params": [[156, 199], ["copy.deepcopy", "copy.deepcopy", "len", "ivadomed.utils.display_selected_model_spec", "loader_params.update", "len", "copy.deepcopy.update", "len", "copy.deepcopy.update", "object_detection_params.update", "loader_params.update", "range", "len", "len", "copy.deepcopy.update", "len", "loguru.logger.error", "exit"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_model_spec", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "def", "set_model_params", "(", "context", ",", "loader_params", ")", ":", "\n", "    ", "model_params", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", ")", "\n", "model_params", "[", "ModelParamsKW", ".", "FOLDER_NAME", "]", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", ")", "\n", "model_context_list", "=", "[", "model_name", "for", "model_name", "in", "MODEL_LIST", "\n", "if", "model_name", "in", "context", "and", "context", "[", "model_name", "]", "[", "ModelParamsKW", ".", "APPLIED", "]", "]", "\n", "if", "len", "(", "model_context_list", ")", "==", "1", ":", "\n", "        ", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "=", "model_context_list", "[", "0", "]", "\n", "model_params", ".", "update", "(", "context", "[", "model_context_list", "[", "0", "]", "]", ")", "\n", "", "elif", "ConfigKW", ".", "MODIFIED_3D_UNET", "in", "model_context_list", "and", "ConfigKW", ".", "FILMED_UNET", "in", "model_context_list", "and", "len", "(", "model_context_list", ")", "==", "2", ":", "\n", "        ", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "=", "ConfigKW", ".", "MODIFIED_3D_UNET", "\n", "for", "i", "in", "range", "(", "len", "(", "model_context_list", ")", ")", ":", "\n", "            ", "model_params", ".", "update", "(", "context", "[", "model_context_list", "[", "i", "]", "]", ")", "\n", "", "", "elif", "len", "(", "model_context_list", ")", ">", "1", ":", "\n", "        ", "logger", ".", "error", "(", "f'ERROR: Several models are selected in the configuration file: {model_context_list}.'", "\n", "'Please select only one (i.e. only one where: \"applied\": true).'", ")", "\n", "exit", "(", ")", "\n", "\n", "", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", "=", "False", "if", "ConfigKW", ".", "MODIFIED_3D_UNET", "in", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "else", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", "\n", "# Get in_channel from contrast_lst", "\n", "if", "loader_params", "[", "LoaderParamsKW", ".", "MULTICHANNEL", "]", ":", "\n", "        ", "model_params", "[", "ModelParamsKW", ".", "IN_CHANNEL", "]", "=", "len", "(", "loader_params", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", ")", "\n", "", "else", ":", "\n", "        ", "model_params", "[", "ModelParamsKW", ".", "IN_CHANNEL", "]", "=", "1", "\n", "# Get out_channel from target_suffix", "\n", "", "model_params", "[", "ModelParamsKW", ".", "OUT_CHANNEL", "]", "=", "len", "(", "loader_params", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", ")", "\n", "# If multi-class output, then add background class", "\n", "if", "model_params", "[", "ModelParamsKW", ".", "OUT_CHANNEL", "]", ">", "1", ":", "\n", "        ", "model_params", ".", "update", "(", "{", "ModelParamsKW", ".", "OUT_CHANNEL", ":", "model_params", "[", "ModelParamsKW", ".", "OUT_CHANNEL", "]", "+", "1", "}", ")", "\n", "# Display for spec' check", "\n", "", "imed_utils", ".", "display_selected_model_spec", "(", "params", "=", "model_params", ")", "\n", "# Update loader params", "\n", "if", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", "in", "context", ":", "\n", "        ", "object_detection_params", "=", "context", "[", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", "]", "\n", "object_detection_params", ".", "update", "(", "{", "ObjectDetectionParamsKW", ".", "GPU_IDS", ":", "context", "[", "ConfigKW", ".", "GPU_IDS", "]", "[", "0", "]", ",", "\n", "ObjectDetectionParamsKW", ".", "PATH_OUTPUT", ":", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "}", ")", "\n", "loader_params", ".", "update", "(", "{", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", ":", "object_detection_params", "}", ")", "\n", "\n", "", "loader_params", ".", "update", "(", "{", "LoaderParamsKW", ".", "MODEL_PARAMS", ":", "model_params", "}", ")", "\n", "\n", "return", "model_params", ",", "loader_params", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_output_path": [[201, 210], ["copy.deepcopy", "pathlib.Path().is_dir", "loguru.logger.info", "pathlib.Path().mkdir", "loguru.logger.info", "pathlib.Path", "pathlib.Path"], "function", ["None"], ["", "def", "set_output_path", "(", "context", ")", ":", "\n", "    ", "path_output", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ")", "\n", "if", "not", "Path", "(", "path_output", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Creating output path: {path_output}'", ")", "\n", "Path", "(", "path_output", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f'Output path already exists: {path_output}'", ")", "\n", "\n", "", "return", "path_output", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.update_film_model_params": [[212, 224], ["pathlib.Path", "joblib.load", "pathlib.Path", "joblib.load", "ivadomed.loader.film.normalize_metadata", "model_params.update", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.normalize_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "def", "update_film_model_params", "(", "context", ",", "ds_test", ",", "model_params", ",", "path_output", ")", ":", "\n", "    ", "clustering_path", "=", "Path", "(", "path_output", ",", "\"clustering_models.joblib\"", ")", "\n", "metadata_clustering_models", "=", "joblib", ".", "load", "(", "clustering_path", ")", "\n", "# Model directory", "\n", "ohe_path", "=", "Path", "(", "path_output", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", ",", "\"one_hot_encoder.joblib\"", ")", "\n", "one_hot_encoder", "=", "joblib", ".", "load", "(", "ohe_path", ")", "\n", "ds_test", "=", "imed_film", ".", "normalize_metadata", "(", "ds_test", ",", "metadata_clustering_models", ",", "context", "[", "ConfigKW", ".", "DEBUGGING", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", ")", "\n", "model_params", ".", "update", "(", "{", "ModelParamsKW", ".", "FILM_ONEHOTENCODER", ":", "one_hot_encoder", ",", "\n", "ModelParamsKW", ".", "N_METADATA", ":", "len", "(", "[", "ll", "for", "l", "in", "one_hot_encoder", ".", "categories_", "for", "ll", "in", "l", "]", ")", "}", ")", "\n", "\n", "return", "ds_test", ",", "model_params", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_segment_command": [[226, 317], ["ivadomed.loader.bids_dataframe.BidsDataframe", "sorted", "pathlib.Path", "pathlib.Path", "ivadomed.config_manager.load_json", "context.get", "context.get", "context.get", "ivadomed.loader.bids_dataframe.BidsDataframe.df.get().to_list", "str", "pathlib.Path.open", "json.dump", "context.get().get", "re.sub", "[].to_list", "any", "ivadomed.inference.segment_volume", "pathlib.Path", "zip", "ivadomed.loader.utils.get_file_extension", "ivadomed.loader.bids_dataframe.BidsDataframe.df.get", "context.get", "seen_subj_ids.append", "str", "pathlib.Path.exists", "pathlib.Path.mkdir", "nibabel.save", "ivadomed.inference.pred_to_png", "len", "len", "loguru.logger.warning", "range", "pathlib.Path", "str().replace", "provided_contrasts.append", "[].to_list.append", "len", "str", "ivadomed.loader.bids_dataframe.BidsDataframe.df[].str.contains", "ivadomed.loader.bids_dataframe.BidsDataframe.df[].str.contains", "subject.split", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.load_json", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_png"], ["", "def", "run_segment_command", "(", "context", ",", "model_params", ")", ":", "\n", "# BIDSDataframe of all image files", "\n", "# Indexing of derivatives is False for command segment", "\n", "# split_method is unused for command segment", "\n", "    ", "bids_df", "=", "BidsDataframe", "(", "\n", "context", ".", "get", "(", "ConfigKW", ".", "LOADER_PARAMETERS", ")", ",", "\n", "context", ".", "get", "(", "ConfigKW", ".", "PATH_OUTPUT", ")", ",", "\n", "derivatives", "=", "False", ",", "\n", "split_method", "=", "None", "\n", ")", "\n", "\n", "# Append subjects filenames into a list", "\n", "bids_subjects", "=", "sorted", "(", "bids_df", ".", "df", ".", "get", "(", "'filename'", ")", ".", "to_list", "(", ")", ")", "\n", "\n", "# Add postprocessing to packaged model", "\n", "path_model", "=", "Path", "(", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", ")", "\n", "path_model_config", "=", "Path", "(", "path_model", ",", "context", "[", "ConfigKW", ".", "MODEL_NAME", "]", "+", "\".json\"", ")", "\n", "model_config", "=", "imed_config_manager", ".", "load_json", "(", "str", "(", "path_model_config", ")", ")", "\n", "model_config", "[", "ConfigKW", ".", "POSTPROCESSING", "]", "=", "context", ".", "get", "(", "ConfigKW", ".", "POSTPROCESSING", ")", "\n", "with", "path_model_config", ".", "open", "(", "mode", "=", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "model_config", ",", "fp", ",", "indent", "=", "4", ")", "\n", "", "options", "=", "{", "}", "\n", "\n", "# Initialize a list of already seen subject ids for multichannel", "\n", "seen_subj_ids", "=", "[", "]", "\n", "\n", "for", "subject", "in", "bids_subjects", ":", "\n", "        ", "if", "context", ".", "get", "(", "ConfigKW", ".", "LOADER_PARAMETERS", ")", ".", "get", "(", "LoaderParamsKW", ".", "MULTICHANNEL", ")", ":", "\n", "# Get subject_id for multichannel", "\n", "            ", "df_sub", "=", "bids_df", ".", "df", ".", "loc", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "subject", "]", "\n", "subj_id", "=", "re", ".", "sub", "(", "r'_'", "+", "df_sub", "[", "'suffix'", "]", ".", "values", "[", "0", "]", "+", "'.*'", ",", "''", ",", "subject", ")", "\n", "if", "subj_id", "not", "in", "seen_subj_ids", ":", "\n", "# if subj_id has not been seen yet", "\n", "                ", "fname_img", "=", "[", "]", "\n", "provided_contrasts", "=", "[", "]", "\n", "contrasts", "=", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "CONTRAST_PARAMS", "]", "[", "ContrastParamsKW", ".", "TESTING", "]", "\n", "# Keep contrast order", "\n", "for", "c", "in", "contrasts", ":", "\n", "                    ", "df_tmp", "=", "bids_df", ".", "df", "[", "\n", "bids_df", ".", "df", "[", "'filename'", "]", ".", "str", ".", "contains", "(", "subj_id", ")", "&", "bids_df", ".", "df", "[", "'suffix'", "]", ".", "str", ".", "contains", "(", "c", ")", "]", "\n", "if", "~", "df_tmp", ".", "empty", ":", "\n", "                        ", "provided_contrasts", ".", "append", "(", "c", ")", "\n", "fname_img", ".", "append", "(", "df_tmp", "[", "'path'", "]", ".", "values", "[", "0", "]", ")", "\n", "", "", "seen_subj_ids", ".", "append", "(", "subj_id", ")", "\n", "if", "len", "(", "fname_img", ")", "!=", "len", "(", "contrasts", ")", ":", "\n", "                    ", "logger", ".", "warning", "(", "f\"Missing contrast for subject {subj_id}. {provided_contrasts} were provided but \"", "\n", "f\"{contrasts} are required. Skipping subject.\"", ")", "\n", "continue", "\n", "", "", "else", ":", "\n", "# Returns an empty list for subj_id already seen", "\n", "                ", "fname_img", "=", "[", "]", "\n", "", "", "else", ":", "\n", "            ", "fname_img", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "subject", "]", "[", "'path'", "]", ".", "to_list", "(", ")", "\n", "\n", "# Add film metadata to options for segment_volume", "\n", "", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", "and", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", ":", "\n", "            ", "metadata", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "subject", "]", "[", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", "]", ".", "values", "[", "0", "]", "\n", "options", "[", "OptionKW", ".", "METADATA", "]", "=", "metadata", "\n", "\n", "# Add microscopy pixel size and pixel size units metadata to options for segment_volume", "\n", "", "if", "MetadataKW", ".", "PIXEL_SIZE", "in", "bids_df", ".", "df", ".", "columns", ":", "\n", "            ", "options", "[", "OptionKW", ".", "PIXEL_SIZE", "]", "=", "bids_df", ".", "df", ".", "loc", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "subject", "]", "[", "MetadataKW", ".", "PIXEL_SIZE", "]", ".", "values", "[", "0", "]", "\n", "", "if", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "in", "bids_df", ".", "df", ".", "columns", ":", "\n", "            ", "options", "[", "OptionKW", ".", "PIXEL_SIZE_UNITS", "]", "=", "bids_df", ".", "df", ".", "loc", "[", "bids_df", ".", "df", "[", "'filename'", "]", "==", "subject", "]", "[", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "]", ".", "values", "[", "0", "]", "\n", "\n", "", "if", "fname_img", ":", "\n", "            ", "pred_list", ",", "target_list", "=", "imed_inference", ".", "segment_volume", "(", "str", "(", "path_model", ")", ",", "\n", "fname_images", "=", "fname_img", ",", "\n", "gpu_id", "=", "context", "[", "ConfigKW", ".", "GPU_IDS", "]", "[", "0", "]", ",", "\n", "options", "=", "options", ")", "\n", "pred_path", "=", "Path", "(", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ",", "\"pred_masks\"", ")", "\n", "if", "not", "pred_path", ".", "exists", "(", ")", ":", "\n", "                ", "pred_path", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# Reformat target list to include class index and be compatible with multiple raters", "\n", "", "target_list", "=", "[", "\"_class-%d\"", "%", "i", "for", "i", "in", "range", "(", "len", "(", "target_list", ")", ")", "]", "\n", "\n", "for", "pred", ",", "target", "in", "zip", "(", "pred_list", ",", "target_list", ")", ":", "\n", "                ", "filename", "=", "subject", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "target", "+", "\"_pred\"", "+", "\".nii.gz\"", "\n", "nib", ".", "save", "(", "pred", ",", "Path", "(", "pred_path", ",", "filename", ")", ")", "\n", "\n", "# For Microscopy PNG/TIF files (TODO: implement OMETIFF behavior)", "\n", "", "extension", "=", "imed_loader_utils", ".", "get_file_extension", "(", "subject", ")", "\n", "if", "\"nii\"", "not", "in", "extension", ":", "\n", "                ", "imed_inference", ".", "pred_to_png", "(", "pred_list", ",", "\n", "target_list", ",", "\n", "str", "(", "Path", "(", "pred_path", ",", "subject", ")", ")", ".", "replace", "(", "extension", ",", "''", ")", ",", "\n", "suffix", "=", "\"_pred.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_command": [[319, 520], ["copy.deepcopy", "main.set_output_path", "pathlib.Path", "loguru.logger.remove", "loguru.logger.add", "loguru.logger.add", "main.create_dataset_and_ivadomed_version_log", "ivadomed.utils.define_device", "ivadomed.utils.format_path_data", "main.set_loader_params", "ivadomed.transforms.get_subdatasets_transforms", "main.set_model_params", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.utils.get_subdatasets_subject_files_list", "ivadomed.utils.generate_sha_256", "ivadomed.transforms.UndoCompose", "copy.deepcopy", "copy.deepcopy.update", "copy.deepcopy.update", "main.check_multiple_raters", "context.get", "context.get", "str", "main.run_segment_command", "context.get().get", "ivadomed.transforms.Compose", "ivadomed.utils.display_selected_transfoms", "ivadomed.utils.display_selected_transfoms", "main.get_dataset", "main.get_dataset", "ivadomed.metrics.get_metric_fns", "main.create_path_model", "main.save_config_file", "ivadomed.training.train", "main.get_dataset", "pathlib.Path", "ivadomed.testing.threshold_analysis", "main.save_config_file", "ivadomed.loader.loader.load_dataset", "ivadomed.metrics.get_metric_fns", "ivadomed.testing.test", "ivadomed.evaluation.evaluate", "context.get().get", "ivadomed.utils.display_selected_transfoms", "any", "main.film_normalize_data", "main.get_dataset", "loguru.logger.warning", "any", "main.update_film_model_params", "context.get", "context.get", "str", "str", "context.get", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_output_path", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.create_dataset_and_ivadomed_version_log", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.format_path_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_loader_params", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_subdatasets_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.set_model_params", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_subdatasets_subject_files_list", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.generate_sha_256", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.check_multiple_raters", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_segment_command", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_transfoms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_transfoms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.get_metric_fns", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.create_path_model", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.save_config_file", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.threshold_analysis", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.save_config_file", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.get_metric_fns", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.test", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.evaluate", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_transfoms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.film_normalize_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.get_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.update_film_model_params"], ["", "", "", "", "def", "run_command", "(", "context", ",", "n_gif", "=", "0", ",", "thr_increment", "=", "None", ",", "resume_training", "=", "False", ")", ":", "\n", "    ", "\"\"\"Run main command.\n\n    This function is central in the ivadomed project as training / testing / evaluation commands\n    are run via this function. All the process parameters are defined in the config.\n\n    Args:\n        context (dict): Dictionary containing all parameters that are needed for a given process. See\n            :doc:`configuration_file` for more details.\n        n_gif (int): Generates a GIF during training if larger than zero, one frame per epoch for a given slice. The\n            parameter indicates the number of 2D slices used to generate GIFs, one GIF per slice. A GIF shows\n            predictions of a given slice from the validation sub-dataset. They are saved within the output path.\n        thr_increment (float): A threshold analysis is performed at the end of the training using the trained model and\n            the training + validation sub-dataset to find the optimal binarization threshold. The specified value\n            indicates the increment between 0 and 1 used during the ROC analysis (e.g. 0.1).\n        resume_training (bool): Load a saved model (\"checkpoint.pth.tar\" in the output directory specified with flag \"--path-output\" or via the config file \"output_path\" '            This training state is saved everytime a new best model is saved in the log\n            argument) for resume training directory.\n\n    Returns:\n        float or pandas.DataFrame or None:\n            * If \"train\" command: Returns floats: best loss score for both training and validation.\n            * If \"test\" command: Returns a pandas Dataframe: of metrics computed for each subject of\n              the testing sub-dataset and return the prediction metrics before evaluation.\n            * If \"segment\" command: No return value.\n\n    \"\"\"", "\n", "command", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "COMMAND", "]", ")", "\n", "path_output", "=", "set_output_path", "(", "context", ")", "\n", "path_log", "=", "Path", "(", "context", ".", "get", "(", "'path_output'", ")", ",", "context", ".", "get", "(", "'log_file'", ")", ")", "\n", "logger", ".", "remove", "(", ")", "\n", "logger", ".", "add", "(", "str", "(", "path_log", ")", ")", "\n", "logger", ".", "add", "(", "sys", ".", "stdout", ")", "\n", "\n", "# Create a log with the version of the Ivadomed software and the version of the Annexed dataset (if present)", "\n", "create_dataset_and_ivadomed_version_log", "(", "context", ")", "\n", "\n", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "context", "[", "ConfigKW", ".", "GPU_IDS", "]", "[", "0", "]", ")", "\n", "\n", "# BACKWARDS COMPATIBILITY: If bids_path is string, assign to list - Do this here so it propagates to all functions", "\n", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "=", "imed_utils", ".", "format_path_data", "(", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", ")", "\n", "\n", "# Loader params", "\n", "loader_params", "=", "set_loader_params", "(", "context", ",", "command", "==", "\"train\"", ")", "\n", "\n", "# Get transforms for each subdataset", "\n", "transform_train_params", ",", "transform_valid_params", ",", "transform_test_params", "=", "imed_transforms", ".", "get_subdatasets_transforms", "(", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", ")", "\n", "\n", "# MODEL PARAMETERS", "\n", "model_params", ",", "loader_params", "=", "set_model_params", "(", "context", ",", "loader_params", ")", "\n", "\n", "if", "command", "==", "'segment'", ":", "\n", "        ", "run_segment_command", "(", "context", ",", "model_params", ")", "\n", "return", "\n", "\n", "# BIDSDataframe of all image files", "\n", "# Indexing of derivatives is True for commands train and test", "\n", "# split_method is used for removing unused subject files in bids_df for commands train and test", "\n", "", "bids_df", "=", "BidsDataframe", "(", "loader_params", ",", "path_output", ",", "derivatives", "=", "True", ",", "\n", "split_method", "=", "context", ".", "get", "(", "ConfigKW", ".", "SPLIT_DATASET", ")", ".", "get", "(", "SplitDatasetKW", ".", "SPLIT_METHOD", ")", ")", "\n", "\n", "# Get subject filenames lists. \"segment\" command uses all participants of data path, hence no need to split", "\n", "train_lst", ",", "valid_lst", ",", "test_lst", "=", "imed_loader_utils", ".", "get_subdatasets_subject_files_list", "(", "context", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", ",", "\n", "bids_df", ".", "df", ",", "\n", "path_output", ",", "\n", "context", ".", "get", "(", "ConfigKW", ".", "LOADER_PARAMETERS", ")", ".", "get", "(", "\n", "LoaderParamsKW", ".", "SUBJECT_SELECTION", ")", ")", "\n", "\n", "# Generating sha256 for the training files", "\n", "imed_utils", ".", "generate_sha_256", "(", "context", ",", "bids_df", ".", "df", ",", "train_lst", ")", "\n", "\n", "# TESTING PARAMS", "\n", "# Aleatoric uncertainty", "\n", "if", "context", "[", "ConfigKW", ".", "UNCERTAINTY", "]", "[", "UncertaintyKW", ".", "ALEATORIC", "]", "and", "context", "[", "ConfigKW", ".", "UNCERTAINTY", "]", "[", "UncertaintyKW", ".", "N_IT", "]", ">", "0", ":", "\n", "        ", "transformation_dict", "=", "transform_train_params", "\n", "", "else", ":", "\n", "        ", "transformation_dict", "=", "transform_test_params", "\n", "", "undo_transforms", "=", "imed_transforms", ".", "UndoCompose", "(", "imed_transforms", ".", "Compose", "(", "transformation_dict", ",", "requires_undo", "=", "True", ")", ")", "\n", "testing_params", "=", "copy", ".", "deepcopy", "(", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", ")", "\n", "testing_params", ".", "update", "(", "{", "ConfigKW", ".", "UNCERTAINTY", ":", "context", "[", "ConfigKW", ".", "UNCERTAINTY", "]", "}", ")", "\n", "testing_params", ".", "update", "(", "{", "LoaderParamsKW", ".", "TARGET_SUFFIX", ":", "loader_params", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", ",", "\n", "ConfigKW", ".", "UNDO_TRANSFORMS", ":", "undo_transforms", ",", "\n", "LoaderParamsKW", ".", "SLICE_AXIS", ":", "loader_params", "[", "LoaderParamsKW", ".", "SLICE_AXIS", "]", "}", ")", "\n", "\n", "if", "command", "==", "\"train\"", ":", "\n", "        ", "imed_utils", ".", "display_selected_transfoms", "(", "transform_train_params", ",", "dataset_type", "=", "[", "\"training\"", "]", ")", "\n", "imed_utils", ".", "display_selected_transfoms", "(", "transform_valid_params", ",", "dataset_type", "=", "[", "\"validation\"", "]", ")", "\n", "", "elif", "command", "==", "\"test\"", ":", "\n", "        ", "imed_utils", ".", "display_selected_transfoms", "(", "transformation_dict", ",", "dataset_type", "=", "[", "\"testing\"", "]", ")", "\n", "\n", "# Check if multiple raters", "\n", "", "check_multiple_raters", "(", "command", "==", "\"train\"", ",", "loader_params", ")", "\n", "\n", "if", "command", "==", "'train'", ":", "\n", "# Get Validation dataset", "\n", "        ", "ds_valid", "=", "get_dataset", "(", "bids_df", ",", "loader_params", ",", "valid_lst", ",", "transform_valid_params", ",", "cuda_available", ",", "device", ",", "\n", "'validation'", ")", "\n", "\n", "# Get Training dataset", "\n", "ds_train", "=", "get_dataset", "(", "bids_df", ",", "loader_params", ",", "train_lst", ",", "transform_train_params", ",", "cuda_available", ",", "device", ",", "\n", "'training'", ")", "\n", "metric_fns", "=", "imed_metrics", ".", "get_metric_fns", "(", "ds_train", ".", "task", ")", "\n", "\n", "# If FiLM, normalize data", "\n", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "            ", "model_params", ",", "ds_train", ",", "ds_valid", ",", "train_onehotencoder", "=", "film_normalize_data", "(", "context", ",", "model_params", ",", "ds_train", ",", "ds_valid", ",", "path_output", ")", "\n", "", "else", ":", "\n", "            ", "train_onehotencoder", "=", "None", "\n", "\n", "# Model directory", "\n", "", "create_path_model", "(", "context", ",", "model_params", ",", "ds_train", ",", "path_output", ",", "train_onehotencoder", ")", "\n", "\n", "save_config_file", "(", "context", ",", "path_output", ")", "\n", "\n", "# RUN TRAINING", "\n", "best_training_dice", ",", "best_training_loss", ",", "best_validation_dice", ",", "best_validation_loss", "=", "imed_training", ".", "train", "(", "\n", "model_params", "=", "model_params", ",", "\n", "dataset_train", "=", "ds_train", ",", "\n", "dataset_val", "=", "ds_valid", ",", "\n", "training_params", "=", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", ",", "\n", "wandb_params", "=", "context", ".", "get", "(", "ConfigKW", ".", "WANDB", ")", ",", "\n", "path_output", "=", "path_output", ",", "\n", "device", "=", "device", ",", "\n", "cuda_available", "=", "cuda_available", ",", "\n", "metric_fns", "=", "metric_fns", ",", "\n", "n_gif", "=", "n_gif", ",", "\n", "resume_training", "=", "resume_training", ",", "\n", "debugging", "=", "context", "[", "ConfigKW", ".", "DEBUGGING", "]", ")", "\n", "\n", "", "if", "thr_increment", ":", "\n", "# LOAD DATASET", "\n", "        ", "if", "command", "!=", "'train'", ":", "# If command == train, then ds_valid already load", "\n", "# Get Validation dataset", "\n", "            ", "ds_valid", "=", "get_dataset", "(", "bids_df", ",", "loader_params", ",", "valid_lst", ",", "transform_valid_params", ",", "cuda_available", ",", "device", ",", "\n", "'validation'", ")", "\n", "\n", "# Get Training dataset with no Data Augmentation", "\n", "", "ds_train", "=", "get_dataset", "(", "bids_df", ",", "loader_params", ",", "train_lst", ",", "transform_valid_params", ",", "cuda_available", ",", "device", ",", "\n", "'training'", ")", "\n", "\n", "# Choice of optimisation metric", "\n", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "in", "imed_utils", ".", "CLASSIFIER_LIST", ":", "\n", "            ", "metric", "=", "MetricsKW", ".", "RECALL_SPECIFICITY", "\n", "", "else", ":", "\n", "            ", "metric", "=", "MetricsKW", ".", "DICE", "\n", "\n", "# Model path", "\n", "", "model_path", "=", "Path", "(", "path_output", ",", "\"best_model.pt\"", ")", "\n", "\n", "# Run analysis", "\n", "thr", "=", "imed_testing", ".", "threshold_analysis", "(", "model_path", "=", "str", "(", "model_path", ")", ",", "\n", "ds_lst", "=", "[", "ds_train", ",", "ds_valid", "]", ",", "\n", "model_params", "=", "model_params", ",", "\n", "testing_params", "=", "testing_params", ",", "\n", "metric", "=", "metric", ",", "\n", "increment", "=", "thr_increment", ",", "\n", "fname_out", "=", "str", "(", "Path", "(", "path_output", ",", "\"roc.png\"", ")", ")", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "# Update threshold in config file", "\n", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", "[", "PostprocessingKW", ".", "BINARIZE_PREDICTION", "]", "=", "{", "BinarizeProdictionKW", ".", "THR", ":", "thr", "}", "\n", "save_config_file", "(", "context", ",", "path_output", ")", "\n", "\n", "", "if", "command", "==", "'train'", ":", "\n", "        ", "return", "best_training_dice", ",", "best_training_loss", ",", "best_validation_dice", ",", "best_validation_loss", "\n", "\n", "", "if", "command", "==", "'test'", ":", "\n", "# LOAD DATASET", "\n", "# Warn user that the input-level dropout is set during inference", "\n", "        ", "if", "loader_params", "[", "LoaderParamsKW", ".", "IS_INPUT_DROPOUT", "]", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Input-level dropout is set during testing. To turn this option off, set 'is_input_dropout'\"", "\n", "\"to 'false' in the configuration file.\"", ")", "\n", "", "ds_test", "=", "imed_loader", ".", "load_dataset", "(", "bids_df", ",", "**", "{", "**", "loader_params", ",", "**", "{", "'data_list'", ":", "test_lst", ",", "\n", "'transforms_params'", ":", "transformation_dict", ",", "\n", "'dataset_type'", ":", "'testing'", ",", "\n", "'requires_undo'", ":", "True", "}", "}", ",", "device", "=", "device", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "metric_fns", "=", "imed_metrics", ".", "get_metric_fns", "(", "ds_test", ".", "task", ")", "\n", "\n", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "            ", "ds_test", ",", "model_params", "=", "update_film_model_params", "(", "context", ",", "ds_test", ",", "model_params", ",", "path_output", ")", "\n", "\n", "# RUN INFERENCE", "\n", "", "pred_metrics", "=", "imed_testing", ".", "test", "(", "model_params", "=", "model_params", ",", "\n", "dataset_test", "=", "ds_test", ",", "\n", "testing_params", "=", "testing_params", ",", "\n", "path_output", "=", "path_output", ",", "\n", "device", "=", "device", ",", "\n", "cuda_available", "=", "cuda_available", ",", "\n", "metric_fns", "=", "metric_fns", ",", "\n", "postprocessing", "=", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", ")", "\n", "\n", "# RUN EVALUATION", "\n", "df_results", "=", "imed_evaluation", ".", "evaluate", "(", "bids_df", ",", "path_output", "=", "path_output", ",", "\n", "target_suffix", "=", "loader_params", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", ",", "\n", "eval_params", "=", "context", "[", "ConfigKW", ".", "EVALUATION_PARAMETERS", "]", ")", "\n", "return", "df_results", ",", "pred_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.create_dataset_and_ivadomed_version_log": [[522, 585], ["context.get().get", "ivadomed.utils._version_string", "isinstance", "pathlib.Path", "path_log.open.write", "ivadomed.utils.format_path_data", "path_log.open.write", "path_log.open.write", "range", "path_log.open.write", "path_log.open.write", "path_log.open.write", "path_log.open.write", "path_log.open.close", "isinstance", "context.get", "pathlib.Path.open", "len", "platform_running.find", "context.items", "context.viewitems", "context.get", "ivadomed.utils.__get_commit", "loguru.logger.error", "Exception", "path_log.open.write", "path_log.open.write", "platform_running.find", "multiprocessing.cpu_count", "path_log.open.write", "path_log.open.write", "datasets_version.append", "platform_running.find", "platform_running.find", "platform.platform", "ivadomed.utils.__get_commit", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils._version_string", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.format_path_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_commit", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_commit"], ["", "", "def", "create_dataset_and_ivadomed_version_log", "(", "context", ")", ":", "\n", "    ", "path_data", "=", "context", ".", "get", "(", "ConfigKW", ".", "LOADER_PARAMETERS", ")", ".", "get", "(", "LoaderParamsKW", ".", "PATH_DATA", ")", "\n", "\n", "ivadomed_version", "=", "imed_utils", ".", "_version_string", "(", ")", "\n", "datasets_version", "=", "[", "]", "\n", "\n", "if", "isinstance", "(", "path_data", ",", "str", ")", ":", "\n", "        ", "datasets_version", "=", "[", "imed_utils", ".", "__get_commit", "(", "path_to_git_folder", "=", "path_data", ")", "]", "\n", "", "elif", "isinstance", "(", "path_data", ",", "list", ")", ":", "\n", "        ", "for", "Dataset", "in", "path_data", ":", "\n", "            ", "datasets_version", ".", "append", "(", "imed_utils", ".", "__get_commit", "(", "path_to_git_folder", "=", "Dataset", ")", ")", "\n", "\n", "", "", "path_log", "=", "Path", "(", "context", ".", "get", "(", "ConfigKW", ".", "PATH_OUTPUT", ")", ",", "'version_info.log'", ")", "\n", "\n", "try", ":", "\n", "        ", "f", "=", "path_log", ".", "open", "(", "mode", "=", "\"w\"", ")", "\n", "", "except", "OSError", "as", "err", ":", "\n", "        ", "logger", ".", "error", "(", "f\"OS error: {err}\"", ")", "\n", "raise", "Exception", "(", "\"Have you selected a log folder, and do you have write permissions for that folder?\"", ")", "\n", "\n", "# IVADOMED", "\n", "", "f", ".", "write", "(", "'IVADOMED TOOLBOX\\n----------------\\n('", "+", "ivadomed_version", "+", "')'", ")", "\n", "\n", "# DATASETS", "\n", "path_data", "=", "imed_utils", ".", "format_path_data", "(", "path_data", ")", "\n", "f", ".", "write", "(", "'\\n\\n\\nDATASET VERSION\\n---------------\\n'", ")", "\n", "\n", "f", ".", "write", "(", "'The following BIDS dataset(s) were used for training.\\n'", ")", "\n", "\n", "for", "i_dataset", "in", "range", "(", "len", "(", "path_data", ")", ")", ":", "\n", "        ", "if", "datasets_version", "[", "i_dataset", "]", "not", "in", "[", "''", ",", "'?!?'", "]", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "i_dataset", "+", "1", ")", "+", "'. '", "+", "path_data", "[", "i_dataset", "]", "+", "' - Dataset Annex version: '", "+", "datasets_version", "[", "\n", "i_dataset", "]", "+", "'\\n'", ")", "\n", "", "else", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "i_dataset", "+", "1", ")", "+", "'. '", "+", "path_data", "[", "i_dataset", "]", "+", "' - Dataset is not Annexed.\\n'", ")", "\n", "\n", "# SYSTEM INFO", "\n", "", "", "f", ".", "write", "(", "'\\n\\nSYSTEM INFO\\n-------------\\n'", ")", "\n", "platform_running", "=", "sys", ".", "platform", "\n", "if", "platform_running", ".", "find", "(", "'darwin'", ")", "!=", "-", "1", ":", "\n", "        ", "os_running", "=", "'osx'", "\n", "", "elif", "platform_running", ".", "find", "(", "'linux'", ")", "!=", "-", "1", ":", "\n", "        ", "os_running", "=", "'linux'", "\n", "", "elif", "platform_running", ".", "find", "(", "'win32'", ")", "or", "platform_running", ".", "find", "(", "'win64'", ")", ":", "\n", "        ", "os_running", "=", "'windows'", "\n", "", "else", ":", "\n", "        ", "os_running", "=", "'NA'", "\n", "\n", "", "f", ".", "write", "(", "'OS: '", "+", "os_running", "+", "' ('", "+", "platform", ".", "platform", "(", ")", "+", "')\\n'", ")", "\n", "\n", "# Display number of CPU cores", "\n", "f", ".", "write", "(", "'CPU cores: Available: {}\\n\\n\\n\\n\\n'", ".", "format", "(", "multiprocessing", ".", "cpu_count", "(", ")", ")", ")", "\n", "\n", "# USER INPUTS", "\n", "f", ".", "write", "(", "'CONFIG INPUTS\\n-------------\\n'", ")", "\n", "if", "sys", ".", "version_info", "[", "0", "]", ">", "2", ":", "\n", "        ", "for", "k", ",", "v", "in", "context", ".", "items", "(", ")", ":", "\n", "            ", "f", ".", "write", "(", "str", "(", "k", ")", "+", "': '", "+", "str", "(", "v", ")", "+", "'\\n'", ")", "# Making sure all numbers are converted to strings", "\n", "", "", "else", ":", "\n", "        ", "for", "k", ",", "v", "in", "context", ".", "viewitems", "(", ")", ":", "# Python2", "\n", "            ", "f", ".", "write", "(", "str", "(", "k", ")", "+", "': '", "+", "str", "(", "v", ")", "+", "'\\n'", ")", "\n", "\n", "", "", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_main": [[587, 606], ["ivadomed.utils.init_ivadomed", "main.get_parser", "get_parser.parse_args", "ivadomed.config_manager.ConfigurationManager().get_config", "ivadomed.utils.get_command", "ivadomed.utils.get_path_output", "ivadomed.utils.get_path_data", "main.run_command", "ivadomed.config_manager.ConfigurationManager", "bool"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_command", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_path_output", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_path_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_command"], ["", "def", "run_main", "(", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Get context from configuration file", "\n", "path_config_file", "=", "args", ".", "config", "\n", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "path_config_file", ")", ".", "get_config", "(", ")", "\n", "\n", "context", "[", "ConfigKW", ".", "COMMAND", "]", "=", "imed_utils", ".", "get_command", "(", "args", ",", "context", ")", "\n", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "=", "imed_utils", ".", "get_path_output", "(", "args", ",", "context", ")", "\n", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "=", "imed_utils", ".", "get_path_data", "(", "args", ",", "context", ")", "\n", "\n", "# Run command", "\n", "run_command", "(", "context", "=", "context", ",", "\n", "n_gif", "=", "args", ".", "gif", "if", "args", ".", "gif", "is", "not", "None", "else", "0", ",", "\n", "thr_increment", "=", "args", ".", "thr_increment", "if", "args", ".", "thr_increment", "else", "None", ",", "\n", "resume_training", "=", "bool", "(", "args", ".", "resume_training", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array": [[6, 26], ["numpy.min", "numpy.max", "arr.astype.astype"], "function", ["None"], ["def", "rescale_values_array", "(", "arr", ",", "minv", "=", "0.0", ",", "maxv", "=", "1.0", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "    ", "\"\"\"Rescale the values of numpy array `arr` to be from `minv` to `maxv`.\n\n    Args:\n        arr (ndarry): Array whose values will be rescaled.\n        minv (float): Minimum value of the output array.\n        maxv (float): Maximum value of the output array.\n        dtype (type): Cast array to this type before performing the rescaling.\n    \"\"\"", "\n", "if", "dtype", "is", "not", "None", ":", "\n", "        ", "arr", "=", "arr", ".", "astype", "(", "dtype", ")", "\n", "\n", "", "mina", "=", "np", ".", "min", "(", "arr", ")", "\n", "maxa", "=", "np", ".", "max", "(", "arr", ")", "\n", "\n", "if", "mina", "==", "maxa", ":", "\n", "        ", "return", "arr", "*", "minv", "\n", "\n", "", "norm", "=", "(", "arr", "-", "mina", ")", "/", "(", "maxa", "-", "mina", ")", "# normalize the array first", "\n", "return", "(", "norm", "*", "(", "maxv", "-", "minv", ")", ")", "+", "minv", "# rescale by minv and maxv, which is the normalized array by default", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.gaussian_kernel": [[28, 43], ["numpy.linspace", "numpy.diff", "numpy.outer", "maths.rescale_values_array", "scipy.stats.norm.cdf", "np.outer.sum"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array"], ["", "def", "gaussian_kernel", "(", "kernlen", "=", "10", ")", ":", "\n", "    ", "\"\"\"\n    Create a 2D gaussian kernel with user-defined size.\n\n    Args:\n        kernlen (int): size of kernel\n\n    Returns:\n        ndarray: a 2D array of size (kernlen,kernlen)\n    \"\"\"", "\n", "\n", "x", "=", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "kernlen", "+", "1", ")", "\n", "kern1d", "=", "np", ".", "diff", "(", "scipy", ".", "stats", ".", "norm", ".", "cdf", "(", "x", ")", ")", "\n", "kern2d", "=", "np", ".", "outer", "(", "kern1d", ",", "kern1d", ")", "\n", "return", "rescale_values_array", "(", "kern2d", "/", "kern2d", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.heatmap_generation": [[45, 60], ["maths.gaussian_kernel", "scipy.signal.convolve", "maths.rescale_values_array"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.gaussian_kernel", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array"], ["", "def", "heatmap_generation", "(", "image", ",", "kernel_size", ")", ":", "\n", "    ", "\"\"\"\n    Generate heatmap from image containing sing voxel label using\n    convolution with gaussian kernel\n    Args:\n        image (ndarray): 2D array containing single voxel label\n        kernel_size (int): size of gaussian kernel\n\n    Returns:\n        ndarray: 2D array heatmap matching the label.\n\n    \"\"\"", "\n", "kernel", "=", "gaussian_kernel", "(", "kernel_size", ")", "\n", "map", "=", "scipy", ".", "signal", ".", "convolve", "(", "image", ",", "kernel", ",", "mode", "=", "'same'", ")", "\n", "return", "rescale_values_array", "(", "map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.__init__": [[35, 39], ["collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "metric_fns", ")", ":", "\n", "        ", "self", ".", "metric_fns", "=", "metric_fns", "\n", "self", ".", "num_samples", "=", "0", "\n", "self", ".", "result_dict", "=", "defaultdict", "(", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.__call__": [[40, 47], ["len", "zip", "metric_fn", "metrics.MetricManager.result_dict[].append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "prediction", ",", "ground_truth", ")", ":", "\n", "        ", "self", ".", "num_samples", "+=", "len", "(", "prediction", ")", "\n", "for", "metric_fn", "in", "self", ".", "metric_fns", ":", "\n", "            ", "for", "p", ",", "gt", "in", "zip", "(", "prediction", ",", "ground_truth", ")", ":", "\n", "                ", "res", "=", "metric_fn", "(", "p", ",", "gt", ")", "\n", "dict_key", "=", "metric_fn", ".", "__name__", "\n", "self", ".", "result_dict", "[", "dict_key", "]", ".", "append", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results": [[48, 56], ["metrics.MetricManager.result_dict.items", "numpy.all", "numpy.isnan", "numpy.nanmean"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items"], ["", "", "", "def", "get_results", "(", "self", ")", ":", "\n", "        ", "res_dict", "=", "{", "}", "\n", "for", "key", ",", "val", "in", "self", ".", "result_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "np", ".", "all", "(", "np", ".", "isnan", "(", "val", ")", ")", ":", "# if all values are np.nan", "\n", "                ", "res_dict", "[", "key", "]", "=", "None", "\n", "", "else", ":", "\n", "                ", "res_dict", "[", "key", "]", "=", "np", ".", "nanmean", "(", "val", ")", "\n", "", "", "return", "res_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.reset": [[57, 60], ["collections.defaultdict"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "num_samples", "=", "0", "\n", "self", ".", "result_dict", "=", "defaultdict", "(", "float", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.get_metric_fns": [[9, 21], ["None"], "function", ["None"], ["def", "get_metric_fns", "(", "task", ")", ":", "\n", "    ", "metric_fns", "=", "[", "dice_score", ",", "\n", "multi_class_dice_score", ",", "\n", "precision_score", ",", "\n", "recall_score", ",", "\n", "specificity_score", ",", "\n", "intersection_over_union", ",", "\n", "accuracy_score", "]", "\n", "if", "task", "==", "\"segmentation\"", ":", "\n", "        ", "metric_fns", "=", "metric_fns", "+", "[", "hausdorff_score", "]", "\n", "\n", "", "return", "metric_fns", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score": [[62, 89], ["float", "float", "float", "float", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "", "def", "numeric_score", "(", "prediction", ",", "groundtruth", ")", ":", "\n", "    ", "\"\"\"Computation of statistical numerical scores:\n\n    * FP = Soft False Positives\n    * FN = Soft False Negatives\n    * TP = Soft True Positives\n    * TN = Soft True Negatives\n\n    Robust to hard or soft input masks. For example::\n        prediction=np.asarray([0, 0.5, 1])\n        groundtruth=np.asarray([0, 1, 1])\n        Leads to FP = 1.5\n\n    Note: It assumes input values are between 0 and 1.\n\n    Args:\n        prediction (ndarray): Binary prediction.\n        groundtruth (ndarray): Binary groundtruth.\n\n    Returns:\n        float, float, float, float: FP, FN, TP, TN\n    \"\"\"", "\n", "FP", "=", "float", "(", "np", ".", "sum", "(", "prediction", "*", "(", "1.0", "-", "groundtruth", ")", ")", ")", "\n", "FN", "=", "float", "(", "np", ".", "sum", "(", "(", "1.0", "-", "prediction", ")", "*", "groundtruth", ")", ")", "\n", "TP", "=", "float", "(", "np", ".", "sum", "(", "prediction", "*", "groundtruth", ")", ")", "\n", "TN", "=", "float", "(", "np", ".", "sum", "(", "(", "1.0", "-", "prediction", ")", "*", "(", "1.0", "-", "groundtruth", ")", ")", ")", "\n", "return", "FP", ",", "FN", ",", "TP", ",", "TN", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score": [[91, 118], ["numpy.asarray", "numpy.asarray", "ValueError", "np.asarray.sum", "np.asarray.sum"], "function", ["None"], ["", "def", "dice_score", "(", "im1", ",", "im2", ",", "empty_score", "=", "np", ".", "nan", ")", ":", "\n", "    ", "\"\"\"Computes the Dice coefficient between im1 and im2.\n\n    Compute a soft Dice coefficient between im1 and im2, ie equals twice the sum of the two masks product, divided by\n    the sum of each mask sum.\n    If both images are empty, then it returns empty_score.\n\n    Args:\n        im1 (ndarray): First array.\n        im2 (ndarray): Second array.\n        empty_score (float): Returned value if both input array are empty.\n\n    Returns:\n        float: Dice coefficient.\n    \"\"\"", "\n", "im1", "=", "np", ".", "asarray", "(", "im1", ")", "\n", "im2", "=", "np", ".", "asarray", "(", "im2", ")", "\n", "\n", "if", "im1", ".", "shape", "!=", "im2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\"Shape mismatch: im1 and im2 must have the same shape.\"", ")", "\n", "\n", "", "im_sum", "=", "im1", ".", "sum", "(", ")", "+", "im2", ".", "sum", "(", ")", "\n", "if", "im_sum", "==", "0", ":", "\n", "        ", "return", "empty_score", "\n", "\n", "", "intersection", "=", "(", "im1", "*", "im2", ")", ".", "sum", "(", ")", "\n", "return", "(", "2.", "*", "intersection", ")", "/", "im_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.mse": [[120, 142], ["numpy.asarray", "numpy.asarray", "numpy.sum", "float", "ValueError", "np.asarray.astype", "np.asarray.astype"], "function", ["None"], ["", "def", "mse", "(", "im1", ",", "im2", ")", ":", "\n", "    ", "\"\"\"Compute the Mean Squared Error.\n\n    Compute the Mean Squared Error between the two images, i.e. sum of the squared difference.\n\n    Args:\n        im1 (ndarray): First array.\n        im2 (ndarray): Second array.\n\n    Returns:\n        float: Mean Squared Error.\n    \"\"\"", "\n", "im1", "=", "np", ".", "asarray", "(", "im1", ")", "\n", "im2", "=", "np", ".", "asarray", "(", "im2", ")", "\n", "\n", "if", "im1", ".", "shape", "!=", "im2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\"Shape mismatch: im1 and im2 must have the same shape.\"", ")", "\n", "\n", "", "err", "=", "np", ".", "sum", "(", "(", "im1", ".", "astype", "(", "\"float\"", ")", "-", "im2", ".", "astype", "(", "\"float\"", ")", ")", "**", "2", ")", "\n", "err", "/=", "float", "(", "im1", ".", "shape", "[", "0", "]", "*", "im1", ".", "shape", "[", "1", "]", ")", "\n", "\n", "return", "err", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.hausdorff_score": [[144, 170], ["len", "prediction.reshape.reshape", "groundtruth.reshape.reshape", "len", "range", "scipy.spatial.distance.directed_hausdorff", "scipy.spatial.distance.directed_hausdorff"], "function", ["None"], ["", "def", "hausdorff_score", "(", "prediction", ",", "groundtruth", ")", ":", "\n", "    ", "\"\"\"Compute the directed Hausdorff distance between two N-D arrays.\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n\n    Returns:\n        float: Hausdorff distance.\n    \"\"\"", "\n", "if", "len", "(", "prediction", ".", "shape", ")", "==", "4", ":", "\n", "        ", "n_classes", ",", "height", ",", "depth", ",", "width", "=", "prediction", ".", "shape", "\n", "# Reshape to have only 3 dimensions where prediction[:, idx, :] represents each 2D slice", "\n", "prediction", "=", "prediction", ".", "reshape", "(", "(", "height", ",", "n_classes", "*", "depth", ",", "width", ")", ")", "\n", "groundtruth", "=", "groundtruth", ".", "reshape", "(", "(", "height", ",", "n_classes", "*", "depth", ",", "width", ")", ")", "\n", "\n", "", "if", "len", "(", "prediction", ".", "shape", ")", "==", "3", ":", "\n", "        ", "mean_hansdorff", "=", "0", "\n", "for", "idx", "in", "range", "(", "prediction", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "pred", "=", "prediction", "[", ":", ",", "idx", ",", ":", "]", "\n", "gt", "=", "groundtruth", "[", ":", ",", "idx", ",", ":", "]", "\n", "mean_hansdorff", "+=", "spatial", ".", "distance", ".", "directed_hausdorff", "(", "pred", ",", "gt", ")", "[", "0", "]", "\n", "", "mean_hansdorff", "=", "mean_hansdorff", "/", "prediction", ".", "shape", "[", "1", "]", "\n", "return", "mean_hansdorff", "\n", "\n", "", "return", "spatial", ".", "distance", ".", "directed_hausdorff", "(", "prediction", ",", "groundtruth", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.precision_score": [[172, 192], ["metrics.numeric_score", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score"], ["", "def", "precision_score", "(", "prediction", ",", "groundtruth", ",", "err_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Positive predictive value (PPV).\n\n    Precision equals the number of true positive voxels divided by the sum of true and false positive voxels.\n    True and false positives are computed on soft masks, see ``\"numeric_score\"``.\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n        err_value (float): Value returned in case of error.\n\n    Returns:\n        float: Precision score.\n    \"\"\"", "\n", "FP", ",", "FN", ",", "TP", ",", "TN", "=", "numeric_score", "(", "prediction", ",", "groundtruth", ")", "\n", "if", "(", "TP", "+", "FP", ")", "<=", "0.0", ":", "\n", "        ", "return", "err_value", "\n", "\n", "", "precision", "=", "np", ".", "divide", "(", "TP", ",", "TP", "+", "FP", ")", "\n", "return", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.recall_score": [[194, 213], ["metrics.numeric_score", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score"], ["", "def", "recall_score", "(", "prediction", ",", "groundtruth", ",", "err_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"True positive rate (TPR).\n\n    Recall equals the number of true positive voxels divided by the sum of true positive and false negative voxels.\n    True positive and false negative values are computed on soft masks, see ``\"numeric_score\"``.\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n        err_value (float): Value returned in case of error.\n\n    Returns:\n        float: Recall score.\n    \"\"\"", "\n", "FP", ",", "FN", ",", "TP", ",", "TN", "=", "numeric_score", "(", "prediction", ",", "groundtruth", ")", "\n", "if", "(", "TP", "+", "FN", ")", "<=", "0.0", ":", "\n", "        ", "return", "err_value", "\n", "", "TPR", "=", "np", ".", "divide", "(", "TP", ",", "TP", "+", "FN", ")", "\n", "return", "TPR", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.specificity_score": [[215, 234], ["metrics.numeric_score", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score"], ["", "def", "specificity_score", "(", "prediction", ",", "groundtruth", ",", "err_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"True negative rate (TNR).\n\n    Specificity equals the number of true negative voxels divided by the sum of true negative and false positive voxels.\n    True negative and false positive values are computed on soft masks, see ``\"numeric_score\"``.\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n        err_value (float): Value returned in case of error.\n\n    Returns:\n        float: Specificity score.\n    \"\"\"", "\n", "FP", ",", "FN", ",", "TP", ",", "TN", "=", "numeric_score", "(", "prediction", ",", "groundtruth", ")", "\n", "if", "(", "TN", "+", "FP", ")", "<=", "0.0", ":", "\n", "        ", "return", "err_value", "\n", "", "TNR", "=", "np", ".", "divide", "(", "TN", ",", "TN", "+", "FP", ")", "\n", "return", "TNR", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.intersection_over_union": [[236, 251], ["metrics.numeric_score"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score"], ["", "def", "intersection_over_union", "(", "prediction", ",", "groundtruth", ",", "err_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Intersection of two (soft) arrays over their union (IoU).\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n        err_value (float): Value returned in case of error.\n\n    Returns:\n        float: IoU.\n    \"\"\"", "\n", "FP", ",", "FN", ",", "TP", ",", "TN", "=", "numeric_score", "(", "prediction", ",", "groundtruth", ")", "\n", "if", "(", "TP", "+", "FP", "+", "FN", ")", "<=", "0.0", ":", "\n", "        ", "return", "err_value", "\n", "", "return", "TP", "/", "(", "TP", "+", "FP", "+", "FN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.accuracy_score": [[253, 272], ["metrics.numeric_score", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.numeric_score"], ["", "def", "accuracy_score", "(", "prediction", ",", "groundtruth", ",", "err_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Accuracy.\n\n    Accuracy equals the number of true positive and true negative voxels divided by the total number of voxels.\n    True positive/negative and false positive/negative values are computed on soft masks, see ``\"numeric_score\"``.\n\n    Args:\n        prediction (ndarray): First array.\n        groundtruth (ndarray): Second array.\n\n    Returns:\n        float: Accuracy.\n    \"\"\"", "\n", "FP", ",", "FN", ",", "TP", ",", "TN", "=", "numeric_score", "(", "prediction", ",", "groundtruth", ")", "\n", "N", "=", "FP", "+", "FN", "+", "TP", "+", "TN", "\n", "if", "N", "<=", "0.0", ":", "\n", "        ", "return", "err_value", "\n", "", "accuracy", "=", "np", ".", "divide", "(", "TP", "+", "TN", ",", "N", ")", "\n", "return", "accuracy", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.multi_class_dice_score": [[274, 294], ["range", "metrics.dice_score"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score"], ["", "def", "multi_class_dice_score", "(", "im1", ",", "im2", ")", ":", "\n", "    ", "\"\"\"Dice score for multi-label images.\n\n    Multi-class Dice score equals the average of the Dice score for each class.\n    The first dimension of the input arrays is assumed to represent the classes.\n\n    Args:\n        im1 (ndarray): First array.\n        im2 (ndarray): Second array.\n\n    Returns:\n        float: Multi-class dice.\n    \"\"\"", "\n", "dice_per_class", "=", "0", "\n", "n_classes", "=", "im1", ".", "shape", "[", "0", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_classes", ")", ":", "\n", "        ", "dice_per_class", "+=", "dice_score", "(", "im1", "[", "i", ",", "]", ",", "im2", "[", "i", ",", "]", ",", "empty_score", "=", "1.0", ")", "\n", "\n", "", "return", "dice_per_class", "/", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_roc_curve": [[296, 316], ["matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.savefig"], "function", ["None"], ["", "def", "plot_roc_curve", "(", "tpr", ",", "fpr", ",", "opt_thr_idx", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"Plot ROC curve.\n\n    Args:\n        tpr (list): True positive rates.\n        fpr (list): False positive rates.\n        opt_thr_idx (int): Index of the optimal threshold.\n        fname_out (str): Output filename.\n    \"\"\"", "\n", "plt", ".", "figure", "(", ")", "\n", "lw", "=", "2", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "marker", "=", "'o'", ")", "\n", "plt", ".", "plot", "(", "[", "fpr", "[", "opt_thr_idx", "]", "]", ",", "[", "tpr", "[", "opt_thr_idx", "]", "]", ",", "color", "=", "\"darkgreen\"", ",", "marker", "=", "\"o\"", ",", "linestyle", "=", "\"None\"", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "'navy'", ",", "lw", "=", "lw", ",", "linestyle", "=", "'--'", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'ROC curve'", ")", "\n", "plt", ".", "savefig", "(", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_dice_thr": [[318, 337], ["matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.savefig", "min", "max"], "function", ["None"], ["", "def", "plot_dice_thr", "(", "thr_list", ",", "dice_list", ",", "opt_thr_idx", ",", "fname_out", ")", ":", "\n", "    ", "\"\"\"Plot Dice results against thresholds.\n\n    Args:\n        thr_list (list): Thresholds list.\n        dice_list (list): Dice results.\n        opt_thr_idx (int): Index of the optimal threshold.\n        fname_out (str): Output filename.\n    \"\"\"", "\n", "plt", ".", "figure", "(", ")", "\n", "lw", "=", "2", "\n", "plt", ".", "plot", "(", "thr_list", ",", "dice_list", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "marker", "=", "'o'", ")", "\n", "plt", ".", "plot", "(", "[", "thr_list", "[", "opt_thr_idx", "]", "]", ",", "[", "dice_list", "[", "opt_thr_idx", "]", "]", ",", "color", "=", "\"darkgreen\"", ",", "marker", "=", "\"o\"", ",", "linestyle", "=", "\"None\"", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "min", "(", "dice_list", ")", "-", "0.02", ",", "max", "(", "dice_list", ")", "+", "0.02", "]", ")", "\n", "plt", ".", "xlabel", "(", "'Thresholds'", ")", "\n", "plt", ".", "ylabel", "(", "'Dice'", ")", "\n", "plt", ".", "title", "(", "'Threshold analysis'", ")", "\n", "plt", ".", "savefig", "(", "fname_out", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.onnx_inference": [[31, 46], ["numpy.array", "onnxruntime.InferenceSession", "onnxruntime.InferenceSession.run", "torch.tensor", "np.array.cpu", "onnxruntime.InferenceSession.get_inputs"], "function", ["None"], ["def", "onnx_inference", "(", "model_path", ":", "str", ",", "inputs", ":", "tensor", ")", "->", "tensor", ":", "\n", "    ", "\"\"\"Run ONNX inference\n\n    Args:\n        model_path (str): Path to the ONNX model.\n        inputs (Tensor): Batch of input image.\n\n    Returns:\n        Tensor: Network output.\n    \"\"\"", "\n", "inputs", "=", "np", ".", "array", "(", "inputs", ".", "cpu", "(", ")", ")", "\n", "ort_session", "=", "onnxruntime", ".", "InferenceSession", "(", "model_path", ")", "\n", "ort_inputs", "=", "{", "ort_session", ".", "get_inputs", "(", ")", "[", "0", "]", ".", "name", ":", "inputs", "}", "\n", "ort_outs", "=", "ort_session", ".", "run", "(", "None", ",", "ort_inputs", ")", "\n", "return", "torch", ".", "tensor", "(", "ort_outs", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.get_preds": [[48, 97], ["ivadomed.utils.define_device", "torch.no_grad", "ivadomed.utils.cuda", "fname_model.lower().endswith", "loguru.logger.debug", "model.cpu", "loguru.logger.debug", "loguru.logger.debug", "torch.load", "loguru.logger.debug", "torch.load.eval", "loguru.logger.debug", "loguru.logger.debug", "inference.onnx_inference", "fname_model.lower", "ivadomed.training.get_metadata", "torch.load.", "torch.load.", "context[].get", "context[].get"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.onnx_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_metadata"], ["", "def", "get_preds", "(", "context", ":", "dict", ",", "fname_model", ":", "str", ",", "model_params", ":", "dict", ",", "gpu_id", ":", "int", ",", "batch", ":", "dict", ")", "->", "tensor", ":", "\n", "    ", "\"\"\"Returns the predictions from the given model.\n\n    Args:\n        context (dict): configuration dict.\n        fname_model (str): name of file containing model.\n        model_params (dict): dictionary containing model parameters.\n        gpu_id (int): Number representing gpu number if available. Currently does NOT support multiple GPU segmentation.\n        batch (dict): dictionary containing input, gt and metadata\n\n    Returns:\n        tensor: predictions from the model.\n    \"\"\"", "\n", "# Define device", "\n", "cuda_available", ",", "device", "=", "imed_utils", ".", "define_device", "(", "gpu_id", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "# Load the Input", "\n", "        ", "img", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "'input'", "]", ",", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "# Load the PyTorch model and evaluate if model files exist.", "\n", "if", "fname_model", ".", "lower", "(", ")", ".", "endswith", "(", "'.pt'", ")", ":", "\n", "            ", "logger", ".", "debug", "(", "f\"PyTorch model detected at: {fname_model}\"", ")", "\n", "logger", ".", "debug", "(", "f\"Loading model from: {fname_model}\"", ")", "\n", "model", "=", "torch", ".", "load", "(", "fname_model", ",", "map_location", "=", "device", ")", "\n", "# Inference time", "\n", "logger", ".", "debug", "(", "f\"Evaluating model: {fname_model}\"", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "# Films/Hemis based prediction require meta data load", "\n", "if", "(", "ConfigKW", ".", "FILMED_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", ".", "get", "(", "ModelParamsKW", ".", "APPLIED", ")", ")", "or", "(", "ConfigKW", ".", "HEMIS_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "HEMIS_UNET", "]", ".", "get", "(", "ModelParamsKW", ".", "APPLIED", ")", ")", ":", "\n", "# Load meta data before prediction", "\n", "                ", "metadata", "=", "imed_training", ".", "get_metadata", "(", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ",", "model_params", ")", "\n", "preds", "=", "model", "(", "img", ",", "metadata", ")", "\n", "", "else", ":", "\n", "                ", "preds", "=", "model", "(", "img", ")", "\n", "# Otherwise, Onnex Inference (PyTorch can't load .onnx)", "\n", "", "", "else", ":", "\n", "            ", "logger", ".", "debug", "(", "f\"Likely ONNX model detected at: {fname_model}\"", ")", "\n", "logger", ".", "debug", "(", "f\"Conduct ONNX model inference... \"", ")", "\n", "preds", "=", "onnx_inference", "(", "fname_model", ",", "img", ")", "\n", "\n", "", "logger", ".", "debug", "(", "\"Sending predictions to CPU\"", ")", "\n", "# Move prediction to CPU", "\n", "preds", "=", "preds", ".", "cpu", "(", ")", "\n", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.get_onehotencoder": [[99, 123], ["joblib.load", "joblib.load", "pathlib.Path", "range", "context[].get", "ivadomed.loader.film.normalize_metadata", "pathlib.Path", "len", "options.get"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.normalize_metadata"], ["", "def", "get_onehotencoder", "(", "context", ":", "dict", ",", "folder_model", ":", "str", ",", "options", ":", "dict", ",", "ds", ":", "Dataset", ")", "->", "dict", ":", "\n", "    ", "\"\"\"Returns one hot encoder which is needed to update the model parameters when FiLMedUnet is applied.\n\n    Args:\n        context (dict): Configuration dict.\n        folder_model (str): Foldername which contains trained model and its configuration file.\n        options (dict): Contains film metadata information.\n        ds (Dataset): Dataset used for the segmentation.\n\n    Returns:\n        dict: onehotencoder used in the model params.\n    \"\"\"", "\n", "metadata_dict", "=", "joblib", ".", "load", "(", "Path", "(", "folder_model", ",", "'metadata_dict.joblib'", ")", ")", "\n", "for", "idx", "in", "ds", ".", "indexes", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "idx", ")", ")", ":", "\n", "            ", "idx", "[", "i", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "0", "]", "[", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", "[", "ModelParamsKW", ".", "METADATA", "]", "]", "=", "options", ".", "get", "(", "OptionKW", ".", "METADATA", ")", "\n", "idx", "[", "i", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "0", "]", "[", "MetadataKW", ".", "METADATA_DICT", "]", "=", "metadata_dict", "\n", "\n", "", "", "if", "ConfigKW", ".", "DEBUGGING", "in", "context", "and", "ConfigKW", ".", "FILMED_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", ".", "get", "(", "ModelParamsKW", ".", "METADATA", ")", ":", "\n", "        ", "ds", "=", "imed_film", ".", "normalize_metadata", "(", "\n", "ds", ",", "None", ",", "context", "[", "ConfigKW", ".", "DEBUGGING", "]", ",", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", "[", "ModelParamsKW", ".", "METADATA", "]", ")", "\n", "\n", "", "return", "joblib", ".", "load", "(", "Path", "(", "folder_model", ",", "'one_hot_encoder.joblib'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_nib": [[125, 213], ["ivadomed.loader.utils.update_filename_to_nifti", "nibabel.load", "nibabel.as_closest_canonical", "nibabel.Nifti1Image", "range", "numpy.stack", "len", "range", "numpy.asarray().transpose", "ivadomed.loader.utils.reorient_image", "ivadomed.postprocessing.threshold_predictions", "ivadomed.postprocessing.Postprocessing", "imed_postpro.Postprocessing.apply", "nibabel.save", "loguru.logger.debug", "oriented_volumes.append", "nib.load.header.get_best_affine", "nib.load.header.copy", "nib.as_closest_canonical.header.get_data_shape", "tmp_lst.append", "tmp_lst.append", "loguru.logger.debug", "ivadomed.loader.utils.reorient_image", "numpy.asarray", "fname_out.split", "numpy.zeros", "len", "z_lst.index"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image"], ["", "def", "pred_to_nib", "(", "data_lst", ":", "List", "[", "np", ".", "ndarray", "]", ",", "z_lst", ":", "List", "[", "int", "]", ",", "fname_ref", ":", "str", ",", "fname_out", ":", "str", ",", "slice_axis", ":", "int", ",", "\n", "debug", ":", "bool", "=", "False", ",", "kernel_dim", ":", "str", "=", "'2d'", ",", "bin_thr", ":", "float", "=", "0.5", ",", "discard_noise", ":", "bool", "=", "True", ",", "\n", "postprocessing", ":", "dict", "=", "None", ")", "->", "nib", ".", "Nifti1Image", ":", "\n", "    ", "\"\"\"Save the network predictions as nibabel object.\n\n    Based on the header of `fname_ref` image, it creates a nibabel object from the Network predictions (`data_lst`).\n\n    Args:\n        data_lst (list of np arrays): Predictions, either 2D slices either 3D patches.\n        z_lst (list of ints): Slice indexes to reconstruct a 3D volume for 2D slices.\n        fname_ref (str): Filename of the input image: its header is copied to the output nibabel object.\n        fname_out (str): If not None, then the generated nibabel object is saved with this filename.\n        slice_axis (int): Indicates the axis used for the 2D slice extraction: Sagittal: 0, Coronal: 1, Axial: 2.\n        debug (bool): If True, extended verbosity and intermediate outputs.\n        kernel_dim (str): Indicates whether the predictions were done on 2D or 3D patches. Choices: '2d', '3d'.\n        bin_thr (float): If positive, then the segmentation is binarized with this given threshold. Otherwise, a soft\n            segmentation is output.\n        discard_noise (bool): If True, predictions that are lower than 0.01 are set to zero.\n        postprocessing (dict): Contains postprocessing steps to be applied.\n\n    Returns:\n        nibabel.Nifti1Image: NiBabel object containing the Network prediction.\n    \"\"\"", "\n", "\n", "# Check fname_ref extention and update path if not NifTI", "\n", "fname_ref", "=", "imed_loader_utils", ".", "update_filename_to_nifti", "(", "fname_ref", ")", "\n", "\n", "# Load reference nibabel object", "\n", "nib_ref", "=", "nib", ".", "load", "(", "fname_ref", ")", "\n", "nib_ref_can", "=", "nib", ".", "as_closest_canonical", "(", "nib_ref", ")", "\n", "\n", "if", "kernel_dim", "==", "'2d'", ":", "\n", "# complete missing z with zeros", "\n", "        ", "tmp_lst", "=", "[", "]", "\n", "for", "z", "in", "range", "(", "nib_ref_can", ".", "header", ".", "get_data_shape", "(", ")", "[", "slice_axis", "]", ")", ":", "\n", "            ", "if", "z", "not", "in", "z_lst", ":", "\n", "                ", "tmp_lst", ".", "append", "(", "np", ".", "zeros", "(", "data_lst", "[", "0", "]", ".", "shape", ")", ")", "\n", "", "else", ":", "\n", "                ", "tmp_lst", ".", "append", "(", "data_lst", "[", "z_lst", ".", "index", "(", "z", ")", "]", ")", "\n", "\n", "", "", "if", "debug", ":", "\n", "            ", "logger", ".", "debug", "(", "f\"Len {len(tmp_lst)}\"", ")", "\n", "for", "arr", "in", "tmp_lst", ":", "\n", "                ", "logger", ".", "debug", "(", "f\"Shape element lst {arr.shape}\"", ")", "\n", "\n", "# create data and stack on depth dimension", "\n", "", "", "arr_pred_ref_space", "=", "np", ".", "stack", "(", "tmp_lst", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "else", ":", "\n", "        ", "arr_pred_ref_space", "=", "data_lst", "[", "0", "]", "\n", "\n", "", "n_channel", "=", "arr_pred_ref_space", ".", "shape", "[", "0", "]", "\n", "oriented_volumes", "=", "[", "]", "\n", "if", "len", "(", "arr_pred_ref_space", ".", "shape", ")", "==", "4", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_channel", ")", ":", "\n", "            ", "oriented_volumes", ".", "append", "(", "\n", "imed_loader_utils", ".", "reorient_image", "(", "arr_pred_ref_space", "[", "i", ",", "]", ",", "slice_axis", ",", "nib_ref", ",", "nib_ref_can", ")", ")", "\n", "# transpose to locate the channel dimension at the end to properly see image on viewer", "\n", "", "arr_pred_ref_space", "=", "np", ".", "asarray", "(", "oriented_volumes", ")", ".", "transpose", "(", "(", "1", ",", "2", ",", "3", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "        ", "arr_pred_ref_space", "=", "imed_loader_utils", ".", "reorient_image", "(", "arr_pred_ref_space", ",", "slice_axis", ",", "nib_ref", ",", "nib_ref_can", ")", "\n", "\n", "", "if", "bin_thr", ">=", "0", ":", "\n", "        ", "arr_pred_ref_space", "=", "imed_postpro", ".", "threshold_predictions", "(", "arr_pred_ref_space", ",", "thr", "=", "bin_thr", ")", "\n", "", "elif", "discard_noise", ":", "# discard noise", "\n", "        ", "arr_pred_ref_space", "[", "arr_pred_ref_space", "<=", "1e-2", "]", "=", "0", "\n", "\n", "# create nibabel object", "\n", "", "if", "postprocessing", ":", "\n", "        ", "fname_prefix", "=", "fname_out", ".", "split", "(", "\"_pred.nii.gz\"", ")", "[", "0", "]", "if", "fname_out", "is", "not", "None", "else", "None", "\n", "postpro", "=", "imed_postpro", ".", "Postprocessing", "(", "postprocessing", ",", "\n", "arr_pred_ref_space", ",", "\n", "nib_ref", ".", "header", "[", "'pixdim'", "]", "[", "1", ":", "4", "]", ",", "\n", "fname_prefix", ")", "\n", "arr_pred_ref_space", "=", "postpro", ".", "apply", "(", ")", "\n", "\n", "# Here we prefer to copy the header (rather than just the affine matrix), in order to preserve the qform_code.", "\n", "# See: https://github.com/ivadomed/ivadomed/issues/711", "\n", "", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "arr_pred_ref_space", ",", "\n", "affine", "=", "nib_ref", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_ref", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "# save as NifTI file", "\n", "if", "fname_out", "is", "not", "None", ":", "\n", "        ", "nib", ".", "save", "(", "nib_pred", ",", "fname_out", ")", "\n", "\n", "", "return", "nib_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_png": [[215, 229], ["zip", "pred.get_fdata", "imageio.imwrite"], "function", ["None"], ["", "def", "pred_to_png", "(", "pred_list", ":", "list", ",", "target_list", ":", "list", ",", "subj_path", ":", "str", ",", "suffix", ":", "str", "=", "''", ")", ":", "\n", "    ", "\"\"\"Save the network predictions as PNG files with suffix \"_target_pred\".\n\n    Args:\n        pred_list (list of np arrays): list of 2D predictions.\n        target_list (list of str): list of target suffixes.\n        subj_path (str): Path of the subject filename in output folder without extension\n            (e.g. \"path_output/pred_masks/sub-01_sample-01_SEM\").\n        suffix (str): additional suffix to append to the filename (e.g. \"_pred.png\")\n    \"\"\"", "\n", "for", "pred", ",", "target", "in", "zip", "(", "pred_list", ",", "target_list", ")", ":", "\n", "        ", "filename", "=", "subj_path", "+", "target", "+", "suffix", "\n", "data", "=", "pred", ".", "get_fdata", "(", ")", "\n", "imageio", ".", "imwrite", "(", "filename", ",", "data", ",", "format", "=", "'png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.process_transformations": [[231, 267], ["loguru.logger.warning", "context[].items", "ivadomed.object_detection.utils.bounding_box_prior", "context[].keys", "len", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.bounding_box_prior", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "", "def", "process_transformations", "(", "context", ":", "dict", ",", "fname_roi", ":", "str", ",", "fname_prior", ":", "str", ",", "metadata", ":", "dict", ",", "slice_axis", ":", "int", ",", "\n", "fname_images", ":", "list", ")", "->", "dict", ":", "\n", "    ", "\"\"\"Sets the transformation based on context parameters. When ROI is not provided center-cropping is applied.\n\n    If there is an object_detection_path, then we modify the metadata to store transformation data.\n\n    Args:\n        context (dict): configuration dictionary.\n        fname_roi (str): filename containing region for cropping image prior to segmentation.\n        fname_prior (str): prior image filename.\n        metadata (dict): metadata used in setting bounding box when we have object_detection_params.\n        slice_axis (int): Indicates the axis used for the 2D slice extraction: Sagittal: 0, Coronal: 1, Axial: 2.\n        fname_images (list): list of image filenames (e.g. .nii.gz) to segment.\n\n    Returns:\n        dict: metadata.\n    \"\"\"", "\n", "if", "fname_roi", "is", "None", "and", "TransformationKW", ".", "ROICROP", "in", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", ".", "keys", "(", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "\n", "\"fname_roi has not been specified, then a cropping around the center of the image is \"", "\n", "\"performed instead of a cropping around a Region of Interest.\"", ")", "\n", "\n", "# Convert transformation configuration into dict.", "\n", "for", "(", "key", ",", "value", ")", "in", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", "!=", "TransformationKW", ".", "ROICROP", ":", "\n", "                ", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", "=", "dict", "(", "key", ",", "value", ")", "\n", "", "else", ":", "\n", "                ", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", "=", "dict", "(", "TransformationKW", ".", "CENTERCROP", ",", "value", ")", "\n", "\n", "", "", "", "if", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", "in", "context", "and", "context", "[", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", "]", "[", "ObjectDetectionParamsKW", ".", "OBJECT_DETECTION_PATH", "]", "is", "not", "None", ":", "\n", "        ", "imed_obj_detect", ".", "bounding_box_prior", "(", "fname_prior", ",", "metadata", ",", "slice_axis", ",", "\n", "context", "[", "ConfigKW", ".", "OBJECT_DETECTION_PARAMS", "]", "[", "ObjectDetectionParamsKW", ".", "SAFETY_FACTOR", "]", ")", "\n", "metadata", "=", "[", "metadata", "]", "*", "len", "(", "fname_images", ")", "\n", "\n", "", "return", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_option": [[269, 289], ["ivadomed.keywords.OptionKW.BINARIZE_MAXPOOLING", "ivadomed.keywords.OptionKW.KEEP_LARGEST", "ivadomed.keywords.OptionKW.FILL_HOLES"], "function", ["None"], ["", "def", "set_option", "(", "options", ":", "dict", ",", "postpro", ":", "dict", ",", "context", ":", "dict", ",", "key", ":", "str", ")", ":", "\n", "    ", "\"\"\"Generalized function that sets postprocessing option based on given list of options.\n\n    When given key already exists in options, we initialize the key value for the postprocessing dictionary\n    Otherwise, when the key is already found in the postprocessing attritute of the context, we remove it\n\n    Args:\n        options (dict): Contains postprocessing steps information.\n        postpro (dict): Postprocessing settings.\n        context (dict): Configuration dict.\n        key (str): The key of the postprocessing option we wish to set.\n\n    Returns:\n        dict: postprocessing settings.\n    \"\"\"", "\n", "if", "options", "[", "key", "]", ":", "\n", "        ", "postpro", "[", "key", "]", "=", "{", "}", "\n", "# Remove key in context if value set to 0", "\n", "", "elif", "key", "in", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", ":", "\n", "        ", "del", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_postprocessing_options": [[291, 319], ["context[].update", "inference.set_option", "inference.set_option", "inference.set_option", "options.get", "options.get", "options.get", "options.get", "int", "t.replace"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_option", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_option", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_option"], ["", "", "def", "set_postprocessing_options", "(", "options", ":", "dict", ",", "context", ":", "dict", ")", ":", "\n", "    ", "\"\"\"Updates the postprocessing options based on existing settings found in options.\n\n    Args:\n        options (dict): Contains postprocessing steps information.\n        context (dict): Configuration dict.\n    \"\"\"", "\n", "postpro", "=", "{", "}", "\n", "\n", "if", "OptionKW", ".", "BINARIZE_PREDICTION", "in", "options", "and", "options", "[", "OptionKW", ".", "BINARIZE_PREDICTION", "]", "is", "not", "None", ":", "\n", "        ", "postpro", "[", "OptionKW", ".", "BINARIZE_PREDICTION", "]", "=", "{", "\"thr\"", ":", "options", "[", "OptionKW", ".", "BINARIZE_PREDICTION", "]", "}", "\n", "\n", "", "if", "OptionKW", ".", "BINARIZE_MAXPOOLING", "in", "options", "and", "options", ".", "get", "(", "OptionKW", ".", "BINARIZE_MAXPOOLING", ")", "is", "not", "None", ":", "\n", "        ", "set_option", "(", "options", ",", "postpro", ",", "context", ",", "OptionKW", ".", "BINARIZE_MAXPOOLING", ")", "\n", "\n", "", "if", "OptionKW", ".", "KEEP_LARGEST", "in", "options", "and", "options", ".", "get", "(", "OptionKW", ".", "KEEP_LARGEST", ")", "is", "not", "None", ":", "\n", "        ", "set_option", "(", "options", ",", "postpro", ",", "context", ",", "OptionKW", ".", "KEEP_LARGEST", ")", "\n", "\n", "", "if", "OptionKW", ".", "FILL_HOLES", "in", "options", "and", "options", ".", "get", "(", "OptionKW", ".", "FILL_HOLES", ")", "is", "not", "None", ":", "\n", "        ", "set_option", "(", "options", ",", "postpro", ",", "context", ",", "OptionKW", ".", "FILL_HOLES", ")", "\n", "\n", "", "if", "OptionKW", ".", "REMOVE_SMALL", "in", "options", "and", "options", ".", "get", "(", "OptionKW", ".", "REMOVE_SMALL", ")", "and", "(", "'mm'", "in", "options", "[", "OptionKW", ".", "REMOVE_SMALL", "]", "[", "-", "1", "]", "or", "'vox'", "in", "options", "[", "OptionKW", ".", "REMOVE_SMALL", "]", "[", "-", "1", "]", ")", ":", "\n", "        ", "unit", "=", "'mm3'", "if", "'mm3'", "in", "options", "[", "OptionKW", ".", "REMOVE_SMALL", "]", "[", "-", "1", "]", "else", "'vox'", "\n", "thr", "=", "[", "int", "(", "t", ".", "replace", "(", "unit", ",", "\"\"", ")", ")", "for", "t", "in", "options", "[", "OptionKW", ".", "REMOVE_SMALL", "]", "]", "\n", "postpro", "[", "OptionKW", ".", "REMOVE_SMALL", "]", "=", "{", "\"unit\"", ":", "unit", ",", "\"thr\"", ":", "thr", "}", "\n", "\n", "", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", ".", "update", "(", "postpro", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume": [[321, 487], ["ivadomed.models.get_model_filenames", "ivadomed.config_manager.ConfigurationManager().get_config", "ivadomed.transforms.get_subdatasets_transforms", "ivadomed.transforms.prepare_transforms", "bool", "torch.utils.data.DataLoader", "enumerate", "any", "inference.set_postprocessing_options", "options.get", "inference.process_transformations", "loguru.logger.warning", "bool", "options.get", "options.get", "options.get", "ivadomed.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset", "loguru.logger.info", "ivadomed.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset", "ivadomed.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames", "inference.get_onehotencoder", "model_params.update", "inference.get_preds", "inference.reconstruct_3d_object", "ivadomed.config_manager.ConfigurationManager", "loguru.logger.info", "loguru.logger.info", "zip", "isinstance", "ivadomed.loader.slice_filter.SliceFilter", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.get_model_filenames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_subdatasets_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.prepare_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.set_postprocessing_options", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.process_transformations", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.get_onehotencoder", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.get_preds", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.reconstruct_3d_object"], ["", "def", "segment_volume", "(", "folder_model", ":", "str", ",", "fname_images", ":", "list", ",", "gpu_id", ":", "int", "=", "0", ",", "options", ":", "dict", "=", "None", ")", ":", "\n", "    ", "\"\"\"Segment an image.\n\n    Segment an image (`fname_image`) using a pre-trained model (`folder_model`). If provided, a region of interest\n    (`fname_roi`) is used to crop the image prior to segment it.\n\n    Args:\n        folder_model (str): foldername which contains\n            (1) the model ('folder_model/folder_model.pt') to use\n            (2) its configuration file ('folder_model/folder_model.json') used for the training,\n            see https://github.com/neuropoly/ivadomed/wiki/configuration-file\n        fname_images (list): list of image filenames (e.g. .nii.gz) to segment. Multichannel models require multiple\n            images to segment, e.i., len(fname_images) > 1.\n        gpu_id (int): Number representing gpu number if available. Currently does NOT support multiple GPU segmentation.\n        options (dict): This can optionally contain any of the following key-value pairs:\n\n            * 'binarize_prediction': (float) Binarize segmentation with specified threshold. \\\n                Predictions below the threshold become 0, and predictions above or equal to \\\n                threshold become 1. Set to -1 for no thresholding (i.e., soft segmentation).\n            * 'binarize_maxpooling': (bool) Binarize by setting to 1 the voxel having the maximum prediction across \\\n                all classes. Useful for multiclass models.\n            * 'fill_holes': (bool) Fill small holes in the segmentation.\n            * 'keep_largest': (bool) Keep the largest connected-object for each class from the output segmentation.\n            * 'remove_small': (list of str) Minimal object size to keep with unit (mm3 or vox). A single value can be provided \\\n                              or one value per prediction class. Single value example: [\"1mm3\"], [\"5vox\"]. Multiple values \\\n                              example: [\"10\", \"20\", \"10vox\"] (remove objects smaller than 10 voxels for class 1 and 3, \\\n                              and smaller than 20 voxels for class 2).\n            * 'pixel_size': (list of float) List of microscopy pixel size in micrometers. \\\n                            Length equals 2 [PixelSizeX, PixelSizeY] for 2D or 3 [PixelSizeX, PixelSizeY, PixelSizeZ] for 3D, \\\n                            where X is the width, Y the height and Z the depth of the image.\n            * 'pixel_size_units': (str) Units of pixel size (Must be either \"mm\", \"um\" or \"nm\")\n            * 'overlap_2D': (list of int) List of overlaps in pixels for 2D patching. Length equals 2 [OverlapX, OverlapY], \\\n                            where X is the width and Y the height of the image.\n            * 'metadata': (str) Film metadata.\n            * 'fname_prior': (str) An image filename (e.g., .nii.gz) containing processing information \\\n                (e.g., spinal cord segmentation, spinal location or MS lesion classification, spinal cord centerline), \\\n                used to crop the image prior to segment it if provided. \\\n                The segmentation is not performed on the slices that are empty in this image.\n\n    Returns:\n        list, list: List of nibabel objects containing the soft segmentation(s), one per prediction class, \\\n            List of target suffix associated with each prediction in `pred_list`\n\n    \"\"\"", "\n", "\n", "# Check if model folder exists and get filenames to be stored as string", "\n", "fname_model", ":", "str", "\n", "fname_model_metadata", ":", "str", "\n", "fname_model", ",", "fname_model_metadata", "=", "imed_models", ".", "get_model_filenames", "(", "folder_model", ")", "\n", "\n", "# Load model training config", "\n", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "fname_model_metadata", ")", ".", "get_config", "(", ")", "\n", "\n", "postpro_list", "=", "[", "'binarize_prediction'", ",", "'binarize_maxpooling'", ",", "'keep_largest'", ",", "' fill_holes'", ",", "\n", "'remove_small'", "]", "\n", "if", "options", "is", "not", "None", "and", "any", "(", "pp", "in", "options", "for", "pp", "in", "postpro_list", ")", ":", "\n", "        ", "set_postprocessing_options", "(", "options", ",", "context", ")", "\n", "\n", "# LOADER", "\n", "", "loader_params", "=", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "\n", "slice_axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "loader_params", "[", "LoaderParamsKW", ".", "SLICE_AXIS", "]", "]", "\n", "metadata", "=", "{", "}", "\n", "fname_roi", "=", "None", "\n", "\n", "if", "(", "options", "is", "not", "None", ")", "and", "(", "OptionKW", ".", "FNAME_PRIOR", "in", "options", ")", ":", "\n", "        ", "fname_prior", "=", "options", ".", "get", "(", "OptionKW", ".", "FNAME_PRIOR", ")", "\n", "", "else", ":", "\n", "        ", "fname_prior", "=", "None", "\n", "\n", "", "if", "fname_prior", "is", "not", "None", ":", "\n", "        ", "if", "LoaderParamsKW", ".", "ROI_PARAMS", "in", "loader_params", "and", "loader_params", "[", "LoaderParamsKW", ".", "ROI_PARAMS", "]", "[", "ROIParamsKW", ".", "SUFFIX", "]", "is", "not", "None", ":", "\n", "            ", "fname_roi", "=", "fname_prior", "\n", "# TRANSFORMATIONS", "\n", "", "metadata", "=", "process_transformations", "(", "context", ",", "fname_roi", ",", "fname_prior", ",", "metadata", ",", "slice_axis", ",", "fname_images", ")", "\n", "\n", "# Compose transforms", "\n", "", "_", ",", "_", ",", "transform_test_params", "=", "imed_transforms", ".", "get_subdatasets_transforms", "(", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", ")", "\n", "\n", "tranform_lst", ",", "undo_transforms", "=", "imed_transforms", ".", "prepare_transforms", "(", "transform_test_params", ")", "\n", "\n", "# Force filter_empty_mask to False if fname_roi = None", "\n", "if", "fname_roi", "is", "None", "and", "SliceFilterParamsKW", ".", "FILTER_EMPTY_MASK", "in", "loader_params", "[", "LoaderParamsKW", ".", "SLICE_FILTER_PARAMS", "]", ":", "\n", "        ", "logger", ".", "warning", "(", "\"fname_roi has not been specified, then the entire volume is processed.\"", ")", "\n", "loader_params", "[", "LoaderParamsKW", ".", "SLICE_FILTER_PARAMS", "]", "[", "SliceFilterParamsKW", ".", "FILTER_EMPTY_MASK", "]", "=", "False", "\n", "\n", "", "kernel_3D", "=", "bool", "(", "ConfigKW", ".", "MODIFIED_3D_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "MODIFIED_3D_UNET", "]", "[", "ModelParamsKW", ".", "APPLIED", "]", ")", "or", "not", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", "[", "ModelParamsKW", ".", "IS_2D", "]", "\n", "\n", "# Assign length_2D and stride_2D for 2D patching", "\n", "length_2D", "=", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", "[", "ModelParamsKW", ".", "LENGTH_2D", "]", "if", "ModelParamsKW", ".", "LENGTH_2D", "in", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", "else", "[", "]", "\n", "stride_2D", "=", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", "[", "ModelParamsKW", ".", "STRIDE_2D", "]", "if", "ModelParamsKW", ".", "STRIDE_2D", "in", "context", "[", "ConfigKW", ".", "DEFAULT_MODEL", "]", "else", "[", "]", "\n", "is_2d_patch", "=", "bool", "(", "length_2D", ")", "\n", "\n", "if", "is_2d_patch", "and", "(", "options", "is", "not", "None", ")", "and", "(", "OptionKW", ".", "OVERLAP_2D", "in", "options", ")", ":", "\n", "        ", "overlap_2D", "=", "options", ".", "get", "(", "OptionKW", ".", "OVERLAP_2D", ")", "\n", "# Swap OverlapX and OverlapY resulting in an array in order [OverlapY, OverlapX]", "\n", "# to match length_2D and stride_2D in [Height, Width] orientation.", "\n", "overlap_2D", "[", "1", "]", ",", "overlap_2D", "[", "0", "]", "=", "overlap_2D", "[", "0", "]", ",", "overlap_2D", "[", "1", "]", "\n", "# Adjust stride_2D with overlap_2D", "\n", "stride_2D", "=", "[", "x1", "-", "x2", "for", "(", "x1", ",", "x2", ")", "in", "zip", "(", "length_2D", ",", "overlap_2D", ")", "]", "\n", "\n", "# Add microscopy pixel size and pixel size units from options to metadata for filenames_pairs", "\n", "", "if", "(", "options", "is", "not", "None", ")", "and", "(", "OptionKW", ".", "PIXEL_SIZE", "in", "options", ")", ":", "\n", "        ", "metadata", "[", "MetadataKW", ".", "PIXEL_SIZE", "]", "=", "options", ".", "get", "(", "OptionKW", ".", "PIXEL_SIZE", ")", "\n", "", "if", "(", "options", "is", "not", "None", ")", "and", "(", "OptionKW", ".", "PIXEL_SIZE_UNITS", "in", "options", ")", ":", "\n", "        ", "metadata", "[", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "]", "=", "options", ".", "get", "(", "OptionKW", ".", "PIXEL_SIZE_UNITS", ")", "\n", "\n", "", "filename_pairs", "=", "[", "(", "fname_images", ",", "None", ",", "fname_roi", ",", "metadata", "if", "isinstance", "(", "metadata", ",", "list", ")", "else", "[", "metadata", "]", ")", "]", "\n", "\n", "if", "kernel_3D", ":", "\n", "        ", "ds", "=", "MRI3DSubVolumeSegmentationDataset", "(", "filename_pairs", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "length", "=", "context", "[", "ConfigKW", ".", "MODIFIED_3D_UNET", "]", "[", "ModelParamsKW", ".", "LENGTH_3D", "]", ",", "\n", "stride", "=", "context", "[", "ConfigKW", ".", "MODIFIED_3D_UNET", "]", "[", "ModelParamsKW", ".", "STRIDE_3D", "]", ",", "\n", "slice_axis", "=", "slice_axis", ")", "\n", "logger", ".", "info", "(", "f\"Loaded {len(ds)} {loader_params[LoaderParamsKW.SLICE_AXIS]} volumes of shape \"", "\n", "f\"{context[ConfigKW.MODIFIED_3D_UNET][ModelParamsKW.LENGTH_3D]}.\"", ")", "\n", "", "else", ":", "\n", "        ", "ds", "=", "MRI2DSegmentationDataset", "(", "filename_pairs", ",", "\n", "length", "=", "length_2D", ",", "\n", "stride", "=", "stride_2D", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "nibabel_cache", "=", "True", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "slice_filter_fn", "=", "SliceFilter", "(", "\n", "**", "loader_params", "[", "LoaderParamsKW", ".", "SLICE_FILTER_PARAMS", "]", ")", ")", "\n", "ds", ".", "load_filenames", "(", ")", "\n", "if", "is_2d_patch", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Loaded {len(ds)} {loader_params[LoaderParamsKW.SLICE_AXIS]} patches of shape {length_2D}.\"", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Loaded {len(ds)} {loader_params[LoaderParamsKW.SLICE_AXIS]} slices.\"", ")", "\n", "\n", "", "", "model_params", "=", "{", "}", "\n", "if", "ConfigKW", ".", "FILMED_UNET", "in", "context", "and", "context", "[", "ConfigKW", ".", "FILMED_UNET", "]", "[", "ModelParamsKW", ".", "APPLIED", "]", ":", "\n", "        ", "onehotencoder", "=", "get_onehotencoder", "(", "context", ",", "folder_model", ",", "options", ",", "ds", ")", "\n", "model_params", ".", "update", "(", "{", "ModelParamsKW", ".", "NAME", ":", "ConfigKW", ".", "FILMED_UNET", ",", "\n", "ModelParamsKW", ".", "FILM_ONEHOTENCODER", ":", "onehotencoder", ",", "\n", "ModelParamsKW", ".", "N_METADATA", ":", "len", "(", "[", "ll", "for", "l", "in", "onehotencoder", ".", "categories_", "for", "ll", "in", "l", "]", ")", "}", ")", "\n", "\n", "# Data Loader", "\n", "", "data_loader", "=", "DataLoader", "(", "ds", ",", "batch_size", "=", "context", "[", "ConfigKW", ".", "TRAINING_PARAMETERS", "]", "[", "TrainingParamsKW", ".", "BATCH_SIZE", "]", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Loop across batches", "\n", "preds_list", ",", "slice_idx_list", "=", "[", "]", ",", "[", "]", "\n", "last_sample_bool", ",", "weight_matrix", ",", "volume", ",", "image", "=", "False", ",", "None", ",", "None", ",", "None", "\n", "for", "i_batch", ",", "batch", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "preds", "=", "get_preds", "(", "context", ",", "fname_model", ",", "model_params", ",", "gpu_id", ",", "batch", ")", "\n", "\n", "# Set datatype to gt since prediction should be processed the same way as gt", "\n", "for", "b", "in", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ":", "\n", "            ", "for", "modality", "in", "b", ":", "\n", "                ", "modality", "[", "'data_type'", "]", "=", "'gt'", "\n", "\n", "# Reconstruct 3D object", "\n", "", "", "pred_list", ",", "target_list", ",", "last_sample_bool", ",", "weight_matrix", ",", "volume", ",", "image", "=", "reconstruct_3d_object", "(", "\n", "context", ",", "batch", ",", "undo_transforms", ",", "preds", ",", "preds_list", ",", "kernel_3D", ",", "is_2d_patch", ",", "slice_axis", ",", "\n", "slice_idx_list", ",", "data_loader", ",", "fname_images", ",", "i_batch", ",", "last_sample_bool", ",", "weight_matrix", ",", "\n", "volume", ",", "image", "\n", ")", "\n", "\n", "", "return", "pred_list", ",", "target_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.split_classes": [[489, 504], ["nib_prediction.get_fdata", "range", "nibabel.Nifti1Image", "pred_list.append", "pred[].astype", "nib_prediction.header.get_best_affine", "nib_prediction.header.copy"], "function", ["None"], ["", "def", "split_classes", "(", "nib_prediction", ")", ":", "\n", "    ", "\"\"\"Split a 4D nibabel multi-class segmentation file in multiple 3D nibabel binary segmentation files.\n\n    Args:\n        nib_prediction (nibabelObject): 4D nibabel object.\n    Returns:\n        list of nibabelObject.\n     \"\"\"", "\n", "pred", "=", "nib_prediction", ".", "get_fdata", "(", ")", "\n", "pred_list", "=", "[", "]", "\n", "for", "c", "in", "range", "(", "pred", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "        ", "class_pred", "=", "nib", ".", "Nifti1Image", "(", "pred", "[", "...", ",", "c", "]", ".", "astype", "(", "'float32'", ")", ",", "nib_prediction", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "nib_prediction", ".", "header", ".", "copy", "(", ")", ")", "\n", "pred_list", ".", "append", "(", "class_pred", ")", "\n", "", "return", "pred_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.reconstruct_3d_object": [[506, 589], ["range", "len", "ivadomed.object_detection.utils.adjust_undo_transforms", "inference.volume_reconstruction", "inference.pred_to_nib", "inference.split_classes", "inference.image_reconstruction", "undo_transforms", "preds_list.append", "slice_idx_list.append", "numpy.array", "preds_list.append", "slice_idx_list.append", "numpy.array", "int", "numpy.array", "int", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_undo_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.volume_reconstruction", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_nib", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.split_classes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.image_reconstruction"], ["", "def", "reconstruct_3d_object", "(", "context", ":", "dict", ",", "batch", ":", "dict", ",", "undo_transforms", ":", "UndoCompose", ",", "preds", ":", "torch", ".", "tensor", ",", "\n", "preds_list", ":", "list", ",", "kernel_3D", ":", "bool", ",", "is_2d_patch", ":", "bool", ",", "slice_axis", ":", "int", ",", "slice_idx_list", ":", "list", ",", "\n", "data_loader", ":", "DataLoader", ",", "fname_images", ":", "list", ",", "i_batch", ":", "int", ",", "last_sample_bool", ":", "bool", ",", "\n", "weight_matrix", ":", "tensor", ",", "volume", ":", "tensor", ",", "image", ":", "tensor", ")", ":", "\n", "    ", "\"\"\"Reconstructs the 3D object from the current batch, and returns the list of predictions and targets.\n\n    Args:\n        context (dict): configuration dict.\n        batch (dict): Dictionary containing input, gt and metadata\n        undo_transforms (UndoCompose): Undo transforms so prediction match original image resolution and shape\n        preds (tensor): Subvolume predictions\n        preds_list (list of tensor): list of subvolume predictions.\n        kernel_3D (bool): true when using 3D kernel.\n        is_2d_patch (bool): True if length in default model params.\n        slice_axis (int): Indicates the axis used for the 2D slice extraction: Sagittal: 0, Coronal: 1, Axial: 2.\n        slice_idx_list (list of int): list of indices for the axis slices.\n        data_loader (DataLoader): DataLoader object containing batches using in object construction.\n        fname_images (list): list of image filenames (e.g. .nii.gz) to segment.\n        i_batch (int): index of current batch.\n        last_sample_bool (bool) : flag to indicate whether this is the last sample in the 3D volume\n        weight_matrix (tensor): the weight matrix\n        volume (tensor): the volume tensor that is being partially reconstructed through the loop\n        image (tensor): the image tensor that is being partially reconstructed through the loop\n\n    Returns:\n        pred_list (list): list of predictions\n        target_list (list): list of targets\n        last_sample_bool (bool): flag to indicate whether this is the last sample in the 3D volume\n        weight_matrix (tensor): the weight matrix. Must be returned as passing tensor by reference is NOT reliable.\n        volume (tensor): the volume tensor that is being partially reconstructed through the loop. Must be returned \\\n            as passing tensor by reference is NOT reliable.\n        image (tensor): the vimage tensor that is being partially reconstructed through the loop. Must be returned \\\n            as passing tensor by reference is NOT reliable.\n    \"\"\"", "\n", "pred_list", "=", "[", "]", "\n", "target_list", "=", "[", "]", "\n", "for", "i_slice", "in", "range", "(", "len", "(", "preds", ")", ")", ":", "\n", "        ", "if", "\"bounding_box\"", "in", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "i_slice", "]", "[", "0", "]", ":", "\n", "            ", "imed_obj_detect", ".", "adjust_undo_transforms", "(", "undo_transforms", ".", "transforms", ",", "batch", ",", "i_slice", ")", "\n", "\n", "", "batch", "[", "MetadataKW", ".", "GT_METADATA", "]", "=", "[", "[", "metadata", "[", "0", "]", "]", "*", "preds", ".", "shape", "[", "1", "]", "for", "metadata", "in", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "]", "\n", "if", "kernel_3D", ":", "\n", "            ", "preds_undo", ",", "metadata", ",", "last_sample_bool", ",", "volume", ",", "weight_matrix", "=", "volume_reconstruction", "(", "batch", ",", "preds", ",", "undo_transforms", ",", "i_slice", ",", "volume", ",", "weight_matrix", ")", "\n", "if", "last_sample_bool", ":", "\n", "                ", "preds_list", "=", "[", "np", ".", "array", "(", "preds_undo", ")", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "is_2d_patch", ":", "\n", "# undo transformations for patch and reconstruct slice", "\n", "                ", "preds_i_undo", ",", "metadata_idx", ",", "last_patch_bool", ",", "image", ",", "weight_matrix", "=", "image_reconstruction", "(", "batch", ",", "preds", ",", "undo_transforms", ",", "i_slice", ",", "image", ",", "weight_matrix", ")", "\n", "# If last patch of the slice", "\n", "if", "last_patch_bool", ":", "\n", "# Add new segmented slice to preds_list", "\n", "                    ", "preds_list", ".", "append", "(", "np", ".", "array", "(", "preds_i_undo", ")", ")", "\n", "# Store the slice index of preds_i_undo in the original 3D image", "\n", "slice_idx_list", ".", "append", "(", "int", "(", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "i_slice", "]", "[", "0", "]", "[", "'slice_index'", "]", ")", ")", "\n", "", "", "else", ":", "\n", "# undo transformations for slice", "\n", "                ", "preds_i_undo", ",", "metadata_idx", "=", "undo_transforms", "(", "preds", "[", "i_slice", "]", ",", "\n", "batch", "[", "MetadataKW", ".", "GT_METADATA", "]", "[", "i_slice", "]", ",", "\n", "data_type", "=", "'gt'", ")", "\n", "# Add new segmented slice to preds_list", "\n", "preds_list", ".", "append", "(", "np", ".", "array", "(", "preds_i_undo", ")", ")", "\n", "# Store the slice index of preds_i_undo in the original 3D image", "\n", "slice_idx_list", ".", "append", "(", "int", "(", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "i_slice", "]", "[", "0", "]", "[", "'slice_index'", "]", ")", ")", "\n", "\n", "# If last batch and last sample of this batch, then reconstruct 3D object", "\n", "", "", "if", "(", "i_batch", "==", "len", "(", "data_loader", ")", "-", "1", "and", "i_slice", "==", "len", "(", "batch", "[", "'gt'", "]", ")", "-", "1", ")", "or", "last_sample_bool", ":", "\n", "            ", "pred_nib", "=", "pred_to_nib", "(", "data_lst", "=", "preds_list", ",", "\n", "fname_ref", "=", "fname_images", "[", "0", "]", ",", "\n", "fname_out", "=", "None", ",", "\n", "z_lst", "=", "slice_idx_list", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "kernel_dim", "=", "'3d'", "if", "kernel_3D", "else", "'2d'", ",", "\n", "debug", "=", "False", ",", "\n", "bin_thr", "=", "-", "1", ",", "\n", "postprocessing", "=", "context", "[", "ConfigKW", ".", "POSTPROCESSING", "]", ")", "\n", "\n", "pred_list", "=", "split_classes", "(", "pred_nib", ")", "\n", "target_list", "=", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "TARGET_SUFFIX", "]", "\n", "\n", "", "", "return", "pred_list", ",", "target_list", ",", "last_sample_bool", ",", "weight_matrix", ",", "volume", ",", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.volume_reconstruction": [[591, 638], ["torch.zeros", "torch.zeros", "undo_transforms"], "function", ["None"], ["", "def", "volume_reconstruction", "(", "batch", ":", "dict", ",", "pred", ":", "tensor", ",", "undo_transforms", ":", "UndoCompose", ",", "smp_idx", ":", "int", ",", "\n", "volume", ":", "tensor", "=", "None", ",", "weight_matrix", ":", "tensor", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Reconstructs volume prediction from subvolumes used during training\n    Args:\n        batch (dict): Dictionary containing input, gt and metadata\n        pred (tensor): Subvolume prediction\n        undo_transforms (UndoCompose): Undo transforms so prediction match original image resolution and shap\n        smp_idx (int): Batch index\n        volume (tensor): Reconstructed volume\n        weight_matrix (tensor): Weights containing the number of predictions for each voxel\n\n    Returns:\n        pred_undo (tensor): undone subvolume,\n        metadata (dict): metadata,\n        last_sample_bool (bool): boolean representing if its the last sample of the volume\n        volume (tensor): representing the volume reconstructed\n        weight_matrix (tensor): weight matrix\n    \"\"\"", "\n", "pred_undo", ",", "metadata", "=", "None", ",", "None", "\n", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", ",", "z_min", ",", "z_max", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'coord'", "]", "\n", "num_pred", "=", "pred", "[", "smp_idx", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# A boolean flag indicate whether the current volume is the VERY first subvolume of the entire 3D volume/space.", "\n", "# Formed by check if x_min/y_min/z_min are all NOT zero.", "\n", "first_sample", ":", "bool", "=", "(", "x_min", "==", "0", "and", "y_min", "==", "0", "and", "z_min", "==", "0", ")", "\n", "\n", "# Get the Dimension", "\n", "x", ",", "y", ",", "z", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'index_shape'", "]", "\n", "\n", "# If this is the first sample, instantiate a ZERO tensor based on the dimension", "\n", "if", "first_sample", ":", "\n", "        ", "volume", "=", "torch", ".", "zeros", "(", "(", "num_pred", ",", "x", ",", "y", ",", "z", ")", ")", "\n", "weight_matrix", "=", "torch", ".", "zeros", "(", "(", "num_pred", ",", "x", ",", "y", ",", "z", ")", ")", "\n", "\n", "", "last_sample_bool", "=", "x_max", "==", "x", "and", "y_max", "==", "y", "and", "z_max", "==", "z", "\n", "\n", "# Average predictions", "\n", "volume", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", ",", "z_min", ":", "z_max", "]", "+=", "pred", "[", "smp_idx", "]", "\n", "weight_matrix", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", ",", "z_min", ":", "z_max", "]", "+=", "1", "\n", "\n", "if", "last_sample_bool", ":", "\n", "        ", "volume", "/=", "weight_matrix", "\n", "pred_undo", ",", "metadata", "=", "undo_transforms", "(", "volume", ",", "\n", "batch", "[", "MetadataKW", ".", "GT_METADATA", "]", "[", "smp_idx", "]", ",", "\n", "data_type", "=", "'gt'", ")", "\n", "", "return", "pred_undo", ",", "metadata", ",", "last_sample_bool", ",", "volume", ",", "weight_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.image_reconstruction": [[640, 685], ["torch.zeros", "torch.zeros", "undo_transforms"], "function", ["None"], ["", "def", "image_reconstruction", "(", "batch", ":", "dict", ",", "pred", ":", "tensor", ",", "undo_transforms", ":", "UndoCompose", ",", "smp_idx", ":", "int", ",", "\n", "image", ":", "tensor", "=", "None", ",", "weight_matrix", ":", "tensor", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Reconstructs image prediction from patches used during training\n    Args:\n        batch (dict): Dictionary containing input, gt and metadata\n        pred (tensor): Patch prediction\n        undo_transforms (UndoCompose): Undo transforms so prediction match original image resolution and shape\n        smp_idx (int): Batch index\n        image (tensor): Reconstructed image\n        weight_matrix (tensor): Weights containing the number of predictions for each pixel\n\n    Returns:\n        pred_undo (tensor): undone image\n        metadata (dict): metadata\n        last_patch_bool (bool): boolean representing if its the last patch of the image\n        image (tensor): representing the image reconstructed\n        weight_matrix (tensor): weight matrix\n    \"\"\"", "\n", "pred_undo", ",", "metadata", "=", "None", ",", "None", "\n", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'coord'", "]", "\n", "num_pred", "=", "pred", "[", "smp_idx", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# A boolean flag indicate whether the current patch is the VERY first patch of the entire 2D image.", "\n", "# Formed by check if x_min/y_min are all NOT zero", "\n", "first_patch", ":", "bool", "=", "(", "x_min", "==", "0", "and", "y_min", "==", "0", ")", "\n", "\n", "# Get the Dimension", "\n", "x", ",", "y", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'index_shape'", "]", "\n", "\n", "# If this is the first sample, instantiate a ZERO tensor based on the dimension", "\n", "if", "first_patch", ":", "\n", "        ", "image", "=", "torch", ".", "zeros", "(", "(", "num_pred", ",", "x", ",", "y", ")", ")", "\n", "weight_matrix", "=", "torch", ".", "zeros", "(", "(", "num_pred", ",", "x", ",", "y", ")", ")", "\n", "\n", "", "last_patch_bool", "=", "x_max", "==", "x", "and", "y_max", "==", "y", "\n", "\n", "# Average predictions", "\n", "image", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", "]", "+=", "pred", "[", "smp_idx", "]", "\n", "weight_matrix", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", "]", "+=", "1", "\n", "if", "last_patch_bool", ":", "\n", "        ", "image", "/=", "weight_matrix", "\n", "pred_undo", ",", "metadata", "=", "undo_transforms", "(", "image", ",", "batch", "[", "MetadataKW", ".", "GT_METADATA", "]", "[", "smp_idx", "]", ",", "data_type", "=", "'gt'", ")", "\n", "\n", "", "return", "pred_undo", ",", "metadata", ",", "last_patch_bool", ",", "image", ",", "weight_matrix", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.preprocessing.get_midslice_average": [[7, 43], ["nibabel.load", "nibabel.as_closest_canonical", "numpy.array", "slice", "numpy.mean", "ivadomed.reorient_image().astype", "nibabel.Nifti1Image", "len", "slice", "ivadomed.reorient_image", "nib.load.header.get_best_affine", "nib.load.header.copy", "tuple", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image"], ["def", "get_midslice_average", "(", "path_im", ",", "ind", ",", "slice_axis", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Extract an average 2D slice out of a 3D volume. This image is generated by\n    averaging the 7 slices in the middle of the volume\n    Args:\n        path_im (string): path to image\n        ind (int): index of the slice around which we will average\n        slice_axis (int): Slice axis according to RAS convention\n\n    Returns:\n        nifti: a single slice nifti object containing the average image in the image space.\n\n    \"\"\"", "\n", "image", "=", "nib", ".", "load", "(", "path_im", ")", "\n", "image_can", "=", "nib", ".", "as_closest_canonical", "(", "image", ")", "\n", "arr_can", "=", "np", ".", "array", "(", "image_can", ".", "dataobj", ")", "\n", "numb_of_slice", "=", "3", "\n", "# Avoid out of bound error by changing the number of slice taken if needed", "\n", "if", "ind", "+", "3", ">", "arr_can", ".", "shape", "[", "slice_axis", "]", ":", "\n", "        ", "numb_of_slice", "=", "arr_can", ".", "shape", "[", "slice_axis", "]", "-", "ind", "\n", "", "if", "ind", "-", "numb_of_slice", "<", "0", ":", "\n", "        ", "numb_of_slice", "=", "ind", "\n", "\n", "", "slc", "=", "[", "slice", "(", "None", ")", "]", "*", "len", "(", "arr_can", ".", "shape", ")", "\n", "slc", "[", "slice_axis", "]", "=", "slice", "(", "ind", "-", "numb_of_slice", ",", "ind", "+", "numb_of_slice", ")", "\n", "mid", "=", "np", ".", "mean", "(", "arr_can", "[", "tuple", "(", "slc", ")", "]", ",", "slice_axis", ")", "\n", "\n", "arr_pred_ref_space", "=", "imed_loader_utils", ".", "reorient_image", "(", "np", ".", "expand_dims", "(", "mid", "[", ":", ",", ":", "]", ",", "axis", "=", "slice_axis", ")", ",", "2", ",", "image", ",", "\n", "image_can", ")", ".", "astype", "(", "'float32'", ")", "\n", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "arr_pred_ref_space", ",", "\n", "affine", "=", "image", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "image", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "\n", "return", "nib_pred", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.mixup.mixup": [[7, 39], ["torch.randperm", "numpy.random.beta", "max", "torch.FloatTensor().to", "data.size", "mixup.save_mixup_sample", "torch.FloatTensor"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.mixup.save_mixup_sample"], ["def", "mixup", "(", "data", ",", "targets", ",", "alpha", ",", "debugging", "=", "False", ",", "ofolder", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the mixup data.\n\n    .. seealso::\n        Zhang, Hongyi, et al. \"mixup: Beyond empirical risk minimization.\"\n        arXiv preprint arXiv:1710.09412 (2017).\n\n    Args:\n        data (Tensor): Input images.\n        targets (Tensor): Input masks.\n        alpha (float): MixUp parameter.\n        debugging (Bool): If True, then samples of mixup are saved as png files.\n        ofolder (str): If debugging, output folder where \"mixup\" folder is created and samples are saved.\n\n    Returns:\n        Tensor, Tensor: Mixed image, Mixed mask.\n    \"\"\"", "\n", "indices", "=", "torch", ".", "randperm", "(", "data", ".", "size", "(", "0", ")", ")", "\n", "data2", "=", "data", "[", "indices", "]", "\n", "targets2", "=", "targets", "[", "indices", "]", "\n", "\n", "lambda_", "=", "np", ".", "random", ".", "beta", "(", "alpha", ",", "alpha", ")", "\n", "lambda_", "=", "max", "(", "lambda_", ",", "1", "-", "lambda_", ")", "# ensure lambda_ >= 0.5", "\n", "lambda_tensor", "=", "torch", ".", "FloatTensor", "(", "[", "lambda_", "]", ")", ".", "to", "(", "data", ".", "device", ")", "\n", "\n", "data", "=", "data", "*", "lambda_tensor", "+", "data2", "*", "(", "1", "-", "lambda_tensor", ")", "\n", "targets", "=", "targets", "*", "lambda_tensor", "+", "targets2", "*", "(", "1", "-", "lambda_tensor", ")", "\n", "\n", "if", "debugging", ":", "\n", "        ", "save_mixup_sample", "(", "ofolder", ",", "data", ",", "targets", ",", "lambda_tensor", ")", "\n", "\n", "", "return", "data", ",", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.mixup.save_mixup_sample": [[41, 72], ["pathlib.Path", "numpy.random.randint", "pathlib.Path", "matplotlib.figure", "matplotlib.subplot", "matplotlib.axis", "matplotlib.imshow", "matplotlib.subplot", "matplotlib.axis", "matplotlib.imshow", "matplotlib.savefig", "matplotlib.close", "pathlib.Path.is_dir", "pathlib.Path.mkdir", "input_data.cpu().data.numpy", "labeled_data.cpu().data.numpy", "input_data.size", "str().zfill", "str", "str", "input_data.cpu", "labeled_data.cpu", "lambda_tensor.cpu().data.numpy", "lambda_tensor.cpu"], "function", ["None"], ["", "def", "save_mixup_sample", "(", "ofolder", ",", "input_data", ",", "labeled_data", ",", "lambda_tensor", ")", ":", "\n", "    ", "\"\"\"Save mixup samples as png files in a \"mixup\" folder.\n\n    Args:\n        ofolder (str): Output folder where \"mixup\" folder is created and samples are saved.\n        input_data (Tensor): Input image.\n        labeled_data (Tensor): Input masks.\n        lambda_tensor (Tensor):\n    \"\"\"", "\n", "# Mixup folder", "\n", "mixup_folder", "=", "Path", "(", "ofolder", ",", "'mixup'", ")", "\n", "if", "not", "mixup_folder", ".", "is_dir", "(", ")", ":", "\n", "        ", "mixup_folder", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "# Random sample", "\n", "", "random_idx", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "input_data", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "# Output fname", "\n", "ofname", "=", "str", "(", "lambda_tensor", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "[", "0", "]", ")", "+", "'_'", "+", "str", "(", "random_idx", ")", ".", "zfill", "(", "3", ")", "+", "'.png'", "\n", "ofname", "=", "Path", "(", "mixup_folder", ",", "ofname", ")", "\n", "# Tensor to Numpy", "\n", "x", "=", "input_data", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "[", "random_idx", ",", "0", ",", ":", ",", ":", "]", "\n", "y", "=", "labeled_data", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "[", "random_idx", ",", "0", ",", ":", ",", ":", "]", "\n", "# Plot", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "20", ",", "10", ")", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "x", ",", "interpolation", "=", "'nearest'", ",", "aspect", "=", "'auto'", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "y", ",", "interpolation", "=", "'nearest'", ",", "aspect", "=", "'auto'", ",", "cmap", "=", "'jet'", ",", "vmin", "=", "0", ",", "vmax", "=", "1", ")", "\n", "plt", ".", "savefig", "(", "ofname", ",", "bbox_inches", "=", "'tight'", ",", "pad_inches", "=", "0", ",", "dpi", "=", "100", ")", "\n", "plt", ".", "close", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.LoopingPillowWriter.finish": [[30, 34], ["visualize.LoopingPillowWriter._frames[].save", "int"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["    ", "def", "finish", "(", "self", ")", ":", "\n", "        ", "self", ".", "_frames", "[", "0", "]", ".", "save", "(", "\n", "self", ".", "outfile", ",", "save_all", "=", "True", ",", "append_images", "=", "self", ".", "_frames", "[", "1", ":", "]", ",", "\n", "duration", "=", "int", "(", "1000", "/", "self", ".", "fps", ")", ",", "loop", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.__init__": [[49, 58], ["matplotlib.figure", "matplotlib.figure", "visualize.AnimatedGif.fig.set_size_inches", "visualize.AnimatedGif.fig.add_axes", "visualize.AnimatedGif.ax.set_xticks", "visualize.AnimatedGif.ax.set_yticks"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "self", ".", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "self", ".", "fig", ".", "set_size_inches", "(", "size", "[", "0", "]", "/", "50", ",", "size", "[", "1", "]", "/", "50", ")", "\n", "self", ".", "size_x", "=", "size", "[", "0", "]", "\n", "self", ".", "size_y", "=", "size", "[", "1", "]", "\n", "self", ".", "ax", "=", "self", ".", "fig", ".", "add_axes", "(", "[", "0", ",", "0", ",", "1", ",", "1", "]", ",", "frameon", "=", "False", ",", "aspect", "=", "1", ")", "\n", "self", ".", "ax", ".", "set_xticks", "(", "[", "]", ")", "\n", "self", ".", "ax", ".", "set_yticks", "(", "[", "]", ")", "\n", "self", ".", "images", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add": [[59, 63], ["visualize.AnimatedGif.ax.imshow", "visualize.AnimatedGif.ax.text", "visualize.AnimatedGif.images.append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "image", ",", "label", "=", "''", ")", ":", "\n", "        ", "plt_im", "=", "self", ".", "ax", ".", "imshow", "(", "image", ",", "cmap", "=", "'Greys'", ",", "vmin", "=", "0", ",", "vmax", "=", "1", ",", "animated", "=", "True", ")", "\n", "plt_txt", "=", "self", ".", "ax", ".", "text", "(", "self", ".", "size_x", "*", "3", "//", "4", ",", "self", ".", "size_y", "-", "10", ",", "label", ",", "color", "=", "'red'", ",", "animated", "=", "True", ")", "\n", "self", ".", "images", ".", "append", "(", "[", "plt_im", ",", "plt_txt", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.save": [[64, 68], ["matplotlib.ArtistAnimation", "matplotlib.ArtistAnimation", "matplotlib.ArtistAnimation.save", "visualize.LoopingPillowWriter"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "        ", "animation", "=", "anim", ".", "ArtistAnimation", "(", "self", ".", "fig", ",", "self", ".", "images", ",", "interval", "=", "50", ",", "blit", "=", "True", ",", "\n", "repeat_delay", "=", "500", ")", "\n", "animation", ".", "save", "(", "filename", ",", "writer", "=", "LoopingPillowWriter", "(", "fps", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.HookBasedFeatureExtractor.__init__": [[271, 282], ["torch.Module.__init__", "visualize.HookBasedFeatureExtractor.submodule.eval"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "submodule", ",", "layername", ",", "upscale", "=", "False", ")", ":", "\n", "        ", "super", "(", "HookBasedFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "submodule", "=", "submodule", "\n", "self", ".", "submodule", ".", "eval", "(", ")", "\n", "self", ".", "layername", "=", "layername", "\n", "self", ".", "outputs_size", "=", "None", "\n", "self", ".", "outputs", "=", "None", "\n", "self", ".", "inputs", "=", "None", "\n", "self", ".", "inputs_size", "=", "None", "\n", "self", ".", "upscale", "=", "upscale", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.HookBasedFeatureExtractor.get_input_array": [[283, 289], ["isinstance", "loguru.logger.info", "i[].data.clone", "input.size", "range", "len"], "methods", ["None"], ["", "def", "get_input_array", "(", "self", ",", "m", ",", "i", ",", "o", ")", ":", "\n", "        ", "assert", "(", "isinstance", "(", "i", ",", "tuple", ")", ")", "\n", "self", ".", "inputs", "=", "[", "i", "[", "index", "]", ".", "data", ".", "clone", "(", ")", "for", "index", "in", "range", "(", "len", "(", "i", ")", ")", "]", "\n", "self", ".", "inputs_size", "=", "[", "input", ".", "size", "(", ")", "for", "input", "in", "self", ".", "inputs", "]", "\n", "\n", "logger", ".", "info", "(", "'Input Array Size: '", ",", "self", ".", "inputs_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.HookBasedFeatureExtractor.get_output_array": [[290, 295], ["isinstance", "loguru.logger.info", "o[].data.clone", "output.size", "range", "len"], "methods", ["None"], ["", "def", "get_output_array", "(", "self", ",", "m", ",", "i", ",", "o", ")", ":", "\n", "        ", "assert", "(", "isinstance", "(", "i", ",", "tuple", ")", ")", "\n", "self", ".", "outputs", "=", "[", "o", "[", "index", "]", ".", "data", ".", "clone", "(", ")", "for", "index", "in", "range", "(", "len", "(", "o", ")", ")", "]", "\n", "self", ".", "outputs_size", "=", "[", "output", ".", "size", "(", ")", "for", "output", "in", "self", ".", "outputs", "]", "\n", "logger", ".", "info", "(", "'Output Array Size: '", ",", "self", ".", "outputs_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.HookBasedFeatureExtractor.forward": [[296, 307], ["visualize.HookBasedFeatureExtractor.submodule._modules.get", "visualize.HookBasedFeatureExtractor.register_forward_hook", "visualize.HookBasedFeatureExtractor.register_forward_hook", "visualize.HookBasedFeatureExtractor.submodule", "visualize.HookBasedFeatureExtractor.register_forward_hook.remove", "visualize.HookBasedFeatureExtractor.register_forward_hook.remove"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "target_layer", "=", "self", ".", "submodule", ".", "_modules", ".", "get", "(", "self", ".", "layername", ")", "\n", "\n", "# Collect the output tensor", "\n", "h_inp", "=", "target_layer", ".", "register_forward_hook", "(", "self", ".", "get_input_array", ")", "\n", "h_out", "=", "target_layer", ".", "register_forward_hook", "(", "self", ".", "get_output_array", ")", "\n", "self", ".", "submodule", "(", "x", ")", "\n", "h_inp", ".", "remove", "(", ")", "\n", "h_out", ".", "remove", "(", ")", "\n", "\n", "return", "self", ".", "inputs", ",", "self", ".", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.overlap_im_seg": [[18, 27], ["matplotlib.cm.jet", "matplotlib.cm.binary_r", "numpy.copy", "numpy.where", "numpy.where", "matplotlib.Normalize", "matplotlib.Normalize", "numpy.amin", "numpy.amax"], "function", ["None"], ["def", "overlap_im_seg", "(", "img", ",", "seg", ")", ":", "\n", "    ", "\"\"\"Overlap image (background, greyscale) and segmentation (foreground, jet).\"\"\"", "\n", "seg_zero", ",", "seg_nonzero", "=", "np", ".", "where", "(", "seg", "<=", "0.1", ")", ",", "np", ".", "where", "(", "seg", ">", "0.1", ")", "\n", "seg_jet", "=", "plt", ".", "cm", ".", "jet", "(", "plt", ".", "Normalize", "(", "vmin", "=", "0", ",", "vmax", "=", "1.", ")", "(", "seg", ")", ")", "\n", "seg_jet", "[", "seg_zero", "]", "=", "0.0", "\n", "img_grey", "=", "plt", ".", "cm", ".", "binary_r", "(", "plt", ".", "Normalize", "(", "vmin", "=", "np", ".", "amin", "(", "img", ")", ",", "vmax", "=", "np", ".", "amax", "(", "img", ")", ")", "(", "img", ")", ")", "\n", "img_out", "=", "np", ".", "copy", "(", "img_grey", ")", "\n", "img_out", "[", "seg_nonzero", "]", "=", "seg_jet", "[", "seg_nonzero", "]", "\n", "return", "img_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_color_labels": [[70, 106], ["range", "numpy.zeros", "numpy.random.seed", "numpy.dtype", "multi_labeled_pred.copy().astype().view().reshape.copy().astype().view().reshape", "ivadomed.inference.pred_to_nib", "ivadomed.postprocessing.threshold_predictions", "numpy.random.randint", "multi_labeled_pred.copy().astype().view().reshape.copy().astype().view", "multi_labeled_pred.copy().astype().view().reshape.copy().astype", "multi_labeled_pred.copy().astype().view().reshape.copy"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_nib", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "", "def", "save_color_labels", "(", "gt_data", ",", "binarize", ",", "gt_filename", ",", "output_filename", ",", "slice_axis", ")", ":", "\n", "    ", "\"\"\"Saves labels encoded in RGB in specified output file.\n\n    Args:\n        gt_data (ndarray): Input image with dimensions (Number of classes, height, width, depth).\n        binarize (bool): If True binarizes gt_data to 0 and 1 values, else soft values are kept.\n        gt_filename (str): GT path and filename.\n        output_filename (str): Name of the output file where the colored labels are saved.\n        slice_axis (int): Indicates the axis used to extract slices: \"axial\": 2, \"sagittal\": 0, \"coronal\": 1.\n\n    Returns:\n        ndarray: RGB labels.\n    \"\"\"", "\n", "n_class", ",", "h", ",", "w", ",", "d", "=", "gt_data", ".", "shape", "\n", "labels", "=", "range", "(", "n_class", ")", "\n", "# Generate color labels", "\n", "multi_labeled_pred", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "d", ",", "3", ")", ")", "\n", "if", "binarize", ":", "\n", "        ", "gt_data", "=", "imed_postpro", ".", "threshold_predictions", "(", "gt_data", ")", "\n", "\n", "# Keep always the same color labels", "\n", "", "np", ".", "random", ".", "seed", "(", "6", ")", "\n", "\n", "for", "label", "in", "labels", ":", "\n", "        ", "r", ",", "g", ",", "b", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "size", "=", "3", ")", "\n", "multi_labeled_pred", "[", "...", ",", "0", "]", "+=", "r", "*", "gt_data", "[", "label", ",", "]", "\n", "multi_labeled_pred", "[", "...", ",", "1", "]", "+=", "g", "*", "gt_data", "[", "label", ",", "]", "\n", "multi_labeled_pred", "[", "...", ",", "2", "]", "+=", "b", "*", "gt_data", "[", "label", ",", "]", "\n", "\n", "", "rgb_dtype", "=", "np", ".", "dtype", "(", "[", "(", "'R'", ",", "'u1'", ")", ",", "(", "'G'", ",", "'u1'", ")", ",", "(", "'B'", ",", "'u1'", ")", "]", ")", "\n", "multi_labeled_pred", "=", "multi_labeled_pred", ".", "copy", "(", ")", ".", "astype", "(", "'u1'", ")", ".", "view", "(", "dtype", "=", "rgb_dtype", ")", ".", "reshape", "(", "(", "h", ",", "w", ",", "d", ")", ")", "\n", "\n", "imed_inference", ".", "pred_to_nib", "(", "[", "multi_labeled_pred", "]", ",", "[", "]", ",", "gt_filename", ",", "\n", "output_filename", ",", "slice_axis", "=", "slice_axis", ",", "kernel_dim", "=", "'3d'", ",", "bin_thr", "=", "-", "1", ",", "discard_noise", "=", "False", ")", "\n", "\n", "return", "multi_labeled_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.convert_labels_to_RGB": [[108, 130], ["torch.zeros", "torch.zeros", "torch.zeros", "numpy.random.seed", "range", "numpy.random.randint"], "function", ["None"], ["", "def", "convert_labels_to_RGB", "(", "grid_img", ")", ":", "\n", "    ", "\"\"\"Converts 2D images to RGB encoded images for display in tensorboard.\n\n    Args:\n        grid_img (Tensor): GT or prediction tensor with dimensions (batch size, number of classes, height, width).\n\n    Returns:\n        tensor: RGB image with shape (height, width, 3).\n    \"\"\"", "\n", "# Keep always the same color labels", "\n", "batch_size", ",", "n_class", ",", "h", ",", "w", "=", "grid_img", ".", "shape", "\n", "rgb_img", "=", "torch", ".", "zeros", "(", "(", "batch_size", ",", "3", ",", "h", ",", "w", ")", ")", "\n", "\n", "# Keep always the same color labels", "\n", "np", ".", "random", ".", "seed", "(", "6", ")", "\n", "for", "i", "in", "range", "(", "n_class", ")", ":", "\n", "        ", "r", ",", "g", ",", "b", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "size", "=", "3", ")", "\n", "rgb_img", "[", ":", ",", "0", ",", "]", "=", "r", "*", "grid_img", "[", ":", ",", "i", ",", "]", "\n", "rgb_img", "[", ":", ",", "1", ",", "]", "=", "g", "*", "grid_img", "[", ":", ",", "i", ",", "]", "\n", "rgb_img", "[", ":", ",", "2", ",", "]", "=", "b", "*", "grid_img", "[", ":", ",", "i", ",", "]", "\n", "\n", "", "return", "rgb_img", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_img": [[132, 194], ["isinstance", "preds.clone", "gt_samples.clone", "range", "torch.cat.copy", "torch.cat.clone", "torchvision.make_grid", "writer.add_image", "torchvision.make_grid", "writer.add_image", "torchvision.make_grid", "writer.add_image", "torch.cat", "torch.cat", "torch.cat", "isinstance", "wandb.log", "visualize.convert_labels_to_RGB", "wandb.log", "visualize.convert_labels_to_RGB", "wandb.log", "gt_samples.sum", "isinstance", "wandb.Image", "wandb.Image", "wandb.Image"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.convert_labels_to_RGB", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.convert_labels_to_RGB"], ["", "def", "save_img", "(", "writer", ",", "epoch", ",", "dataset_type", ",", "input_samples", ",", "gt_samples", ",", "preds", ",", "wandb_tracking", "=", "False", ",", "is_three_dim", "=", "False", ")", ":", "\n", "    ", "\"\"\"Saves input images, gt and predictions in tensorboard (and wandb depending upon the inputs in the config file).\n\n    Args:\n        writer (SummaryWriter): Tensorboard's summary writer.\n        epoch (int): Epoch number.\n        dataset_type (str): Choice between Training or Validation.\n        input_samples (Tensor): Input images with shape (batch size, number of channel, height, width, depth) if 3D else\n            (batch size, number of channel, height, width)\n        gt_samples (Tensor): GT images with shape (batch size, number of channel, height, width, depth) if 3D else\n            (batch size, number of channel, height, width)\n        preds (Tensor): Model's prediction with shape (batch size, number of channel, height, width, depth) if 3D else\n            (batch size, number of channel, height, width)\n        is_three_dim (bool): True if 3D input, else False.\n    \"\"\"", "\n", "if", "is_three_dim", ":", "\n", "# Take all images stacked on depth dimension", "\n", "        ", "num_2d_img", "=", "input_samples", ".", "shape", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "        ", "num_2d_img", "=", "1", "\n", "", "if", "isinstance", "(", "input_samples", ",", "list", ")", ":", "\n", "        ", "input_samples_copy", "=", "input_samples", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "        ", "input_samples_copy", "=", "input_samples", ".", "clone", "(", ")", "\n", "", "preds_copy", "=", "preds", ".", "clone", "(", ")", "\n", "gt_samples_copy", "=", "gt_samples", ".", "clone", "(", ")", "\n", "for", "idx", "in", "range", "(", "num_2d_img", ")", ":", "\n", "        ", "if", "is_three_dim", ":", "\n", "            ", "input_samples", "=", "input_samples_copy", "[", "...", ",", "idx", "]", "\n", "preds", "=", "preds_copy", "[", "...", ",", "idx", "]", "\n", "gt_samples", "=", "gt_samples_copy", "[", "...", ",", "idx", "]", "\n", "# Only display images with labels", "\n", "if", "gt_samples", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "# take only one modality for grid", "\n", "", "", "if", "not", "isinstance", "(", "input_samples", ",", "list", ")", "and", "input_samples", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "tensor", "=", "input_samples", "[", ":", ",", "0", ",", "]", "[", ":", ",", "None", ",", "]", "\n", "input_samples", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "tensor", ",", "tensor", ")", ",", "1", ")", "\n", "", "elif", "isinstance", "(", "input_samples", ",", "list", ")", ":", "\n", "            ", "input_samples", "=", "input_samples", "[", "0", "]", "\n", "\n", "", "grid_img", "=", "vutils", ".", "make_grid", "(", "input_samples", ",", "\n", "normalize", "=", "True", ",", "\n", "scale_each", "=", "True", ")", "\n", "writer", ".", "add_image", "(", "dataset_type", "+", "'/Input'", ",", "grid_img", ",", "epoch", ")", "\n", "if", "wandb_tracking", ":", "\n", "            ", "wandb", ".", "log", "(", "{", "dataset_type", "+", "\"/Input\"", ":", "wandb", ".", "Image", "(", "grid_img", ")", "}", ")", "\n", "\n", "", "grid_img", "=", "vutils", ".", "make_grid", "(", "convert_labels_to_RGB", "(", "preds", ")", ",", "\n", "normalize", "=", "True", ",", "\n", "scale_each", "=", "True", ")", "\n", "writer", ".", "add_image", "(", "dataset_type", "+", "'/Predictions'", ",", "grid_img", ",", "epoch", ")", "\n", "if", "wandb_tracking", ":", "\n", "            ", "wandb", ".", "log", "(", "{", "dataset_type", "+", "\"/Predictions\"", ":", "wandb", ".", "Image", "(", "grid_img", ")", "}", ")", "\n", "\n", "", "grid_img", "=", "vutils", ".", "make_grid", "(", "convert_labels_to_RGB", "(", "gt_samples", ")", ",", "\n", "normalize", "=", "True", ",", "\n", "scale_each", "=", "True", ")", "\n", "writer", ".", "add_image", "(", "dataset_type", "+", "'/Ground Truth'", ",", "grid_img", ",", "epoch", ")", "\n", "if", "wandb_tracking", ":", "\n", "            ", "wandb", ".", "log", "(", "{", "dataset_type", "+", "\"/Ground-Truth\"", ":", "wandb", ".", "Image", "(", "grid_img", ")", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_feature_map": [[196, 249], ["range", "pathlib.Path().exists", "pathlib.Path().mkdir", "batch[].size", "visualize.HookBasedFeatureExtractor.forward", "[].cpu().numpy", "torch.interpolate().data.cpu().numpy", "pathlib.Path", "nibabel.load", "nibabel.as_closest_canonical", "ivadomed.loader.utils.reorient_image", "nibabel.Nifti1Image", "nibabel.save", "pathlib.Path", "ivadomed.loader.utils.reorient_image", "nibabel.Nifti1Image", "nibabel.save", "torch.autograd.Variable", "path.split", "pathlib.Path", "pathlib.Path", "visualize.HookBasedFeatureExtractor", "[].cpu", "torch.interpolate().data.cpu", "nib.load.header.get_best_affine", "nib.load.header.copy", "basename.split", "nib.load.header.get_best_affine", "nib.load.header.copy", "torch.interpolate", "[].size"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "", "", "def", "save_feature_map", "(", "batch", ",", "layer_name", ",", "path_output", ",", "model", ",", "test_input", ",", "slice_axis", ")", ":", "\n", "    ", "\"\"\"Save model feature maps.\n\n    Args:\n        batch (dict):\n        layer_name (str):\n        path_output (str): Output folder.\n        model (nn.Module): Network.\n        test_input (Tensor):\n        slice_axis (int): Indicates the axis used for the 2D slice extraction: Sagittal: 0, Coronal: 1, Axial: 2.\n    \"\"\"", "\n", "if", "not", "Path", "(", "path_output", ",", "layer_name", ")", ".", "exists", "(", ")", ":", "\n", "        ", "Path", "(", "path_output", ",", "layer_name", ")", ".", "mkdir", "(", ")", "\n", "\n", "# Save for subject in batch", "\n", "", "for", "i", "in", "range", "(", "batch", "[", "'input'", "]", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "inp_fmap", ",", "out_fmap", "=", "HookBasedFeatureExtractor", "(", "model", ",", "layer_name", ",", "False", ")", ".", "forward", "(", "Variable", "(", "test_input", "[", "i", "]", "[", "None", ",", "]", ")", ")", "\n", "\n", "# Display the input image and Down_sample the input image", "\n", "orig_input_img", "=", "test_input", "[", "i", "]", "[", "None", ",", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "upsampled_attention", "=", "F", ".", "interpolate", "(", "out_fmap", "[", "1", "]", ",", "\n", "size", "=", "test_input", "[", "i", "]", "[", "None", ",", "]", ".", "size", "(", ")", "[", "2", ":", "]", ",", "\n", "mode", "=", "'trilinear'", ",", "\n", "align_corners", "=", "True", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "path", "=", "batch", "[", "\"input_metadata\"", "]", "[", "0", "]", "[", "i", "]", "[", "\"input_filenames\"", "]", "\n", "\n", "basename", "=", "path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "save_directory", "=", "Path", "(", "path_output", ",", "layer_name", ",", "basename", ")", "\n", "\n", "# Write the attentions to a nifti image", "\n", "nib_ref", "=", "nib", ".", "load", "(", "path", ")", "\n", "nib_ref_can", "=", "nib", ".", "as_closest_canonical", "(", "nib_ref", ")", "\n", "oriented_image", "=", "imed_loader_utils", ".", "reorient_image", "(", "orig_input_img", "[", "0", ",", "0", ",", ":", ",", ":", ",", ":", "]", ",", "slice_axis", ",", "nib_ref", ",", "nib_ref_can", ")", "\n", "\n", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "oriented_image", ",", "\n", "affine", "=", "nib_ref", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_ref", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "nib", ".", "save", "(", "nib_pred", ",", "save_directory", ")", "\n", "\n", "basename", "=", "basename", ".", "split", "(", "\".\"", ")", "[", "0", "]", "+", "\"_att.nii.gz\"", "\n", "save_directory", "=", "Path", "(", "path_output", ",", "layer_name", ",", "basename", ")", "\n", "attention_map", "=", "imed_loader_utils", ".", "reorient_image", "(", "upsampled_attention", "[", "0", ",", "0", ",", ":", ",", ":", ",", ":", "]", ",", "slice_axis", ",", "nib_ref", ",", "nib_ref_can", ")", "\n", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "attention_map", ",", "\n", "affine", "=", "nib_ref", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_ref", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "\n", "nib", ".", "save", "(", "nib_pred", ",", "save_directory", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.test": [[27, 90], ["torch.utils.data.DataLoader", "pathlib.Path", "loguru.logger.info", "torch.load", "torch.load", "torch.load.eval", "pathlib.Path", "ivadomed.metrics.MetricManager", "range", "imed_metrics.MetricManager.get_results", "imed_metrics.MetricManager.reset", "loguru.logger.info", "torch.load.cuda", "pathlib.Path.is_dir", "pathlib.Path.mkdir", "loguru.logger.info", "testing.run_inference", "imed_metrics.MetricManager.", "str", "ivadomed.uncertainty.run_uncertainty", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.reset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.uncertainty.run_uncertainty"], ["def", "test", "(", "model_params", ",", "dataset_test", ",", "testing_params", ",", "path_output", ",", "device", ",", "cuda_available", "=", "True", ",", "\n", "metric_fns", "=", "None", ",", "postprocessing", "=", "None", ")", ":", "\n", "    ", "\"\"\"Main command to test the network.\n\n    Args:\n        model_params (dict): Model's parameters.\n        dataset_test (imed_loader): Testing dataset.\n        testing_params (dict): Testing parameters.\n        path_output (str): Folder where predictions are saved.\n        device (torch.device): Indicates the CPU or GPU ID.\n        cuda_available (bool): If True, CUDA is available.\n        metric_fns (list): List of metrics, see :mod:`ivadomed.metrics`.\n        postprocessing (dict): Contains postprocessing steps.\n\n    Returns:\n        dict: result metrics.\n    \"\"\"", "\n", "# DATA LOADER", "\n", "test_loader", "=", "DataLoader", "(", "dataset_test", ",", "batch_size", "=", "testing_params", "[", "\"batch_size\"", "]", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# LOAD TRAIN MODEL", "\n", "fname_model", "=", "Path", "(", "path_output", ",", "\"best_model.pt\"", ")", "\n", "logger", ".", "info", "(", "'Loading model: {}'", ".", "format", "(", "fname_model", ")", ")", "\n", "model", "=", "torch", ".", "load", "(", "fname_model", ",", "map_location", "=", "device", ")", "\n", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "\n", "# CREATE OUTPUT FOLDER", "\n", "path_3Dpred", "=", "Path", "(", "path_output", ",", "'pred_masks'", ")", "\n", "if", "not", "path_3Dpred", ".", "is_dir", "(", ")", ":", "\n", "        ", "path_3Dpred", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# METRIC MANAGER", "\n", "", "metric_mgr", "=", "imed_metrics", ".", "MetricManager", "(", "metric_fns", ")", "\n", "\n", "# UNCERTAINTY SETTINGS", "\n", "if", "(", "testing_params", "[", "'uncertainty'", "]", "[", "'epistemic'", "]", "or", "testing_params", "[", "'uncertainty'", "]", "[", "'aleatoric'", "]", ")", "and", "testing_params", "[", "'uncertainty'", "]", "[", "'n_it'", "]", ">", "0", ":", "\n", "        ", "n_monteCarlo", "=", "testing_params", "[", "'uncertainty'", "]", "[", "'n_it'", "]", "+", "1", "\n", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", "=", "True", "\n", "logger", ".", "info", "(", "'Computing model uncertainty over {} iterations.'", ".", "format", "(", "n_monteCarlo", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", "=", "False", "\n", "n_monteCarlo", "=", "1", "\n", "\n", "", "for", "i_monteCarlo", "in", "range", "(", "n_monteCarlo", ")", ":", "\n", "        ", "preds_npy", ",", "gt_npy", "=", "run_inference", "(", "test_loader", ",", "model", ",", "model_params", ",", "testing_params", ",", "str", "(", "path_3Dpred", ")", ",", "\n", "cuda_available", ",", "i_monteCarlo", ",", "postprocessing", ")", "\n", "metric_mgr", "(", "preds_npy", ",", "gt_npy", ")", "\n", "# If uncertainty computation, don't apply it on last iteration for prediction", "\n", "if", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", "and", "(", "n_monteCarlo", "-", "2", "==", "i_monteCarlo", ")", ":", "\n", "            ", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", "=", "False", "\n", "# COMPUTE UNCERTAINTY MAPS", "\n", "imed_uncertainty", ".", "run_uncertainty", "(", "image_folder", "=", "str", "(", "path_3Dpred", ")", ")", "\n", "\n", "", "", "metrics_dict", "=", "metric_mgr", ".", "get_results", "(", ")", "\n", "metric_mgr", ".", "reset", "(", ")", "\n", "logger", ".", "info", "(", "metrics_dict", ")", "\n", "return", "metrics_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference": [[92, 322], ["enumerate", "any", "tqdm.tqdm", "model.cpu", "ivadomed.utils.get_task", "range", "any", "ivadomed.loader.film.save_film_params", "torch.no_grad", "torch.no_grad", "ivadomed.utils.cuda", "ivadomed.visualize.save_feature_map", "any", "ivadomed.loader.film.store_film_params", "gt_npy_list.append", "preds_npy_list.append", "len", "ofolder.replace", "range", "range", "ivadomed.utils.cuda", "ivadomed.utils.cuda", "model.modules", "ivadomed.training.get_metadata", "model", "model", "str", "imed_utils.cuda.cpu().numpy", "preds.cpu.data.numpy", "len", "ivadomed.object_detection.utils.adjust_undo_transforms", "ivadomed.inference.volume_reconstruction", "str", "ivadomed.utils.unstack_tensors", "m.__class__.__name__.startswith", "any", "ivadomed.inference.image_reconstruction", "numpy.array", "pred_tmp_lst.append", "z_tmp_lst.append", "ivadomed.inference.pred_to_nib", "imed_inference.pred_to_nib.get_fdata().transpose", "preds_npy_list.append", "testing.get_gt", "gt_npy_list.append", "ivadomed.loader.utils.get_file_extension", "numpy.array", "ivadomed.inference.pred_to_nib", "imed_inference.pred_to_nib.get_fdata().transpose", "preds_npy_list.append", "testing.get_gt", "gt_npy_list.append", "m.train", "pathlib.Path", "imed_utils.cuda.cpu", "list", "int", "str", "imed_inference.pred_to_nib.get_fdata", "loguru.logger.warning", "ivadomed.inference.split_classes", "ivadomed.inference.pred_to_png", "str", "loguru.logger.warning", "len", "filter", "pathlib.Path", "imed_inference.pred_to_nib.get_fdata", "len", "pathlib.Path", "imed_inference.pred_to_nib.get_fdata", "str.split", "range", "str.split", "str.split", "pathlib.Path", "str().zfill", "len", "pathlib.Path", "str().zfill", "str.split", "str", "str.split", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_task", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.save_film_params", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_feature_map", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.store_film_params", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_undo_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.volume_reconstruction", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.unstack_tensors", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.image_reconstruction", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_nib", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.get_gt", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_nib", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.get_gt", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.split_classes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_png"], ["", "def", "run_inference", "(", "test_loader", ",", "model", ",", "model_params", ",", "testing_params", ",", "ofolder", ",", "cuda_available", ",", "\n", "i_monte_carlo", "=", "None", ",", "postprocessing", "=", "None", ")", ":", "\n", "    ", "\"\"\"Run inference on the test data and save results as nibabel files.\n\n    Args:\n        test_loader (torch DataLoader):\n        model (nn.Module):\n        model_params (dict):\n        testing_params (dict):\n        ofolder (str): Folder where predictions are saved.\n        cuda_available (bool): If True, CUDA is available.\n        i_monte_carlo (int): i_th Monte Carlo iteration.\n        postprocessing (dict): Indicates postprocessing steps.\n\n    Returns:\n        ndarray, ndarray: Prediction, Ground-truth of shape n_sample, n_label, h, w, d.\n    \"\"\"", "\n", "# INIT STORAGE VARIABLES", "\n", "preds_npy_list", ",", "gt_npy_list", ",", "filenames", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "pred_tmp_lst", ",", "z_tmp_lst", "=", "[", "]", ",", "[", "]", "\n", "image", "=", "None", "\n", "volume", "=", "None", "\n", "weight_matrix", "=", "None", "\n", "\n", "# Create dict containing gammas and betas after each FiLM layer.", "\n", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "# 2 * model_params[\"depth\"] + 2 is the number of FiLM layers. 1 is added since the range starts at one.", "\n", "        ", "gammas_dict", "=", "{", "i", ":", "[", "]", "for", "i", "in", "range", "(", "1", ",", "2", "*", "model_params", "[", "\"depth\"", "]", "+", "3", ")", "}", "\n", "betas_dict", "=", "{", "i", ":", "[", "]", "for", "i", "in", "range", "(", "1", ",", "2", "*", "model_params", "[", "\"depth\"", "]", "+", "3", ")", "}", "\n", "metadata_values_lst", "=", "[", "]", "\n", "\n", "", "for", "i", ",", "batch", "in", "enumerate", "(", "tqdm", "(", "test_loader", ",", "desc", "=", "\"Inference - Iteration \"", "+", "str", "(", "i_monte_carlo", ")", ")", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# GET SAMPLES", "\n", "# input_samples: list of batch_size tensors, whose size is n_channels X height X width X depth", "\n", "# gt_samples: idem with n_labels", "\n", "# batch['*_metadata']: list of batch_size lists, whose size is n_channels or n_labels", "\n", "            ", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "                ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "imed_utils", ".", "unstack_tensors", "(", "batch", "[", "\"input\"", "]", ")", ",", "cuda_available", ")", "\n", "", "else", ":", "\n", "                ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"input\"", "]", ",", "cuda_available", ")", "\n", "", "gt_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"gt\"", "]", ",", "cuda_available", ",", "non_blocking", "=", "True", ")", "\n", "\n", "# EPISTEMIC UNCERTAINTY", "\n", "if", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", "and", "testing_params", "[", "'uncertainty'", "]", "[", "'epistemic'", "]", ":", "\n", "                ", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "                    ", "if", "m", ".", "__class__", ".", "__name__", ".", "startswith", "(", "'Dropout'", ")", ":", "\n", "                        ", "m", ".", "train", "(", ")", "\n", "\n", "# RUN MODEL", "\n", "", "", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", "or", "(", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ")", ":", "\n", "                ", "metadata", "=", "get_metadata", "(", "batch", "[", "\"input_metadata\"", "]", ",", "model_params", ")", "\n", "preds", "=", "model", "(", "input_samples", ",", "metadata", ")", "\n", "", "else", ":", "\n", "                ", "preds", "=", "model", "(", "input_samples", ")", "\n", "\n", "", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "# Reconstruct image with only one modality", "\n", "            ", "input_samples", "=", "batch", "[", "'input'", "]", "[", "0", "]", "\n", "\n", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "MODIFIED_3D_UNET", "and", "model_params", "[", "ModelParamsKW", ".", "ATTENTION", "]", "and", "ofolder", ":", "\n", "            ", "imed_visualize", ".", "save_feature_map", "(", "batch", ",", "\"attentionblock2\"", ",", "str", "(", "Path", "(", "ofolder", ")", ".", "parent", ")", ",", "model", ",", "input_samples", ",", "\n", "slice_axis", "=", "test_loader", ".", "dataset", ".", "slice_axis", ")", "\n", "\n", "", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "# Store the values of gammas and betas after the last epoch for each batch", "\n", "            ", "gammas_dict", ",", "betas_dict", ",", "metadata_values_lst", "=", "store_film_params", "(", "gammas_dict", ",", "betas_dict", ",", "\n", "metadata_values_lst", ",", "\n", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ",", "model", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "DEPTH", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "METADATA", "]", ")", "\n", "\n", "# PREDS TO CPU", "\n", "", "preds_cpu", "=", "preds", ".", "cpu", "(", ")", "\n", "\n", "task", "=", "imed_utils", ".", "get_task", "(", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", ")", "\n", "if", "task", "==", "\"classification\"", ":", "\n", "            ", "gt_npy_list", ".", "append", "(", "gt_samples", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "preds_npy_list", ".", "append", "(", "preds_cpu", ".", "data", ".", "numpy", "(", ")", ")", "\n", "\n", "# RECONSTRUCT 3D IMAGE", "\n", "", "last_batch_bool", "=", "(", "i", "==", "len", "(", "test_loader", ")", "-", "1", ")", "\n", "\n", "slice_axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "testing_params", "[", "'slice_axis'", "]", "]", "\n", "\n", "# LOOP ACROSS SAMPLES", "\n", "for", "smp_idx", "in", "range", "(", "len", "(", "preds_cpu", ")", ")", ":", "\n", "            ", "if", "\"bounding_box\"", "in", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", ":", "\n", "                ", "imed_obj_detect", ".", "adjust_undo_transforms", "(", "testing_params", "[", "\"undo_transforms\"", "]", ".", "transforms", ",", "batch", ",", "smp_idx", ")", "\n", "\n", "", "if", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", ":", "\n", "                ", "preds_idx_arr", "=", "None", "\n", "idx_slice", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'slice_index'", "]", "\n", "n_slices", "=", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "smp_idx", "]", "[", "0", "]", "[", "'data_shape'", "]", "[", "-", "1", "]", "\n", "last_slice_bool", "=", "(", "idx_slice", "+", "1", "==", "n_slices", ")", "\n", "last_sample_bool", "=", "(", "last_batch_bool", "and", "smp_idx", "==", "len", "(", "preds_cpu", ")", "-", "1", ")", "\n", "\n", "length_2D", "=", "model_params", "[", "ModelParamsKW", ".", "LENGTH_2D", "]", "if", "ModelParamsKW", ".", "LENGTH_2D", "in", "model_params", "else", "[", "]", "\n", "stride_2D", "=", "model_params", "[", "ModelParamsKW", ".", "STRIDE_2D", "]", "if", "ModelParamsKW", ".", "STRIDE_2D", "in", "model_params", "else", "[", "]", "\n", "if", "length_2D", ":", "\n", "# undo transformations for patch and reconstruct slice", "\n", "                    ", "preds_idx_undo", ",", "metadata_idx", ",", "last_patch_bool", ",", "image", ",", "weight_matrix", "=", "imed_inference", ".", "image_reconstruction", "(", "batch", ",", "preds_cpu", ",", "testing_params", "[", "'undo_transforms'", "]", ",", "\n", "smp_idx", ",", "image", ",", "weight_matrix", ")", "\n", "", "else", ":", "\n", "# Set last_patch_bool to True (only one patch per slice)", "\n", "                    ", "last_patch_bool", "=", "True", "\n", "# undo transformations for slice", "\n", "preds_idx_undo", ",", "metadata_idx", "=", "testing_params", "[", "\"undo_transforms\"", "]", "(", "preds_cpu", "[", "smp_idx", "]", ",", "\n", "batch", "[", "'gt_metadata'", "]", "[", "smp_idx", "]", ",", "\n", "data_type", "=", "'gt'", ")", "\n", "", "if", "last_patch_bool", ":", "\n", "# preds_idx_undo is a list n_label arrays", "\n", "                    ", "preds_idx_arr", "=", "np", ".", "array", "(", "preds_idx_undo", ")", "\n", "\n", "# TODO: gt_filenames should not be a list", "\n", "fname_ref", "=", "list", "(", "filter", "(", "None", ",", "metadata_idx", "[", "0", "]", "[", "MetadataKW", ".", "GT_FILENAMES", "]", ")", ")", "[", "0", "]", "\n", "\n", "", "if", "preds_idx_arr", "is", "not", "None", ":", "\n", "# add new sample to pred_tmp_lst, of size n_label X h X w ...", "\n", "                    ", "pred_tmp_lst", ".", "append", "(", "preds_idx_arr", ")", "\n", "\n", "# TODO: slice_index should be stored in gt_metadata as well", "\n", "z_tmp_lst", ".", "append", "(", "int", "(", "idx_slice", ")", ")", "\n", "filenames", "=", "metadata_idx", "[", "0", "]", "[", "MetadataKW", ".", "GT_FILENAMES", "]", "\n", "\n", "# NEW COMPLETE VOLUME", "\n", "", "if", "(", "pred_tmp_lst", "and", "(", "(", "last_patch_bool", "and", "last_slice_bool", ")", "or", "last_sample_bool", ")", "\n", "and", "task", "!=", "\"classification\"", ")", ":", "\n", "# save the completely processed file as a NifTI file", "\n", "                    ", "if", "ofolder", ":", "\n", "                        ", "fname_pred", "=", "str", "(", "Path", "(", "ofolder", ",", "Path", "(", "fname_ref", ")", ".", "name", ")", ")", "\n", "fname_pred", "=", "fname_pred", ".", "split", "(", "testing_params", "[", "'target_suffix'", "]", "[", "0", "]", ")", "[", "0", "]", "+", "'_pred.nii.gz'", "\n", "# If Uncertainty running, then we save each simulation result", "\n", "if", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", ":", "\n", "                            ", "fname_pred", "=", "fname_pred", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'_'", "+", "str", "(", "i_monte_carlo", ")", ".", "zfill", "(", "2", ")", "+", "'.nii.gz'", "\n", "postprocessing", "=", "None", "\n", "", "", "else", ":", "\n", "                        ", "fname_pred", "=", "None", "\n", "", "output_nii", "=", "imed_inference", ".", "pred_to_nib", "(", "data_lst", "=", "pred_tmp_lst", ",", "\n", "z_lst", "=", "z_tmp_lst", ",", "\n", "fname_ref", "=", "fname_ref", ",", "\n", "fname_out", "=", "fname_pred", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "kernel_dim", "=", "'2d'", ",", "\n", "bin_thr", "=", "-", "1", ",", "\n", "postprocessing", "=", "postprocessing", ")", "\n", "output_data", "=", "output_nii", ".", "get_fdata", "(", ")", ".", "transpose", "(", "3", ",", "0", ",", "1", ",", "2", ")", "\n", "preds_npy_list", ".", "append", "(", "output_data", ")", "\n", "\n", "gt", "=", "get_gt", "(", "filenames", ")", "\n", "gt_npy_list", ".", "append", "(", "gt", ")", "\n", "\n", "output_nii_shape", "=", "output_nii", ".", "get_fdata", "(", ")", ".", "shape", "\n", "if", "len", "(", "output_nii_shape", ")", "==", "4", "and", "output_nii_shape", "[", "-", "1", "]", ">", "1", "and", "ofolder", ":", "\n", "                        ", "logger", ".", "warning", "(", "'No color labels saved due to a temporary issue. For more details see:'", "\n", "'https://github.com/ivadomed/ivadomed/issues/720'", ")", "\n", "# TODO: put back the code below. See #720", "\n", "# imed_visualize.save_color_labels(np.stack(pred_tmp_lst, -1),", "\n", "#                              False,", "\n", "#                              fname_ref,", "\n", "#                              fname_pred.split(\".nii.gz\")[0] + '_color.nii.gz',", "\n", "#                              imed_utils.AXIS_DCT[testing_params['slice_axis']])", "\n", "\n", "# For Microscopy PNG/TIF files (TODO: implement OMETIFF behavior)", "\n", "", "extension", "=", "imed_loader_utils", ".", "get_file_extension", "(", "fname_ref", ")", "\n", "if", "\"nii\"", "not", "in", "extension", "and", "fname_pred", ":", "\n", "                        ", "output_list", "=", "imed_inference", ".", "split_classes", "(", "output_nii", ")", "\n", "# Reformat target list to include class index and be compatible with multiple raters", "\n", "target_list", "=", "[", "\"_class-%d\"", "%", "i", "for", "i", "in", "range", "(", "len", "(", "testing_params", "[", "'target_suffix'", "]", ")", ")", "]", "\n", "imed_inference", ".", "pred_to_png", "(", "output_list", ",", "\n", "target_list", ",", "\n", "fname_pred", ".", "split", "(", "\"_pred.nii.gz\"", ")", "[", "0", "]", ",", "\n", "suffix", "=", "\"_pred.png\"", ")", "\n", "\n", "# re-init pred_stack_lst and last_slice_bool", "\n", "", "pred_tmp_lst", ",", "z_tmp_lst", "=", "[", "]", ",", "[", "]", "\n", "last_slice_bool", "=", "False", "\n", "\n", "", "", "else", ":", "\n", "                ", "pred_undo", ",", "metadata", ",", "last_sample_bool", ",", "volume", ",", "weight_matrix", "=", "imed_inference", ".", "volume_reconstruction", "(", "batch", ",", "\n", "preds_cpu", ",", "\n", "testing_params", "[", "'undo_transforms'", "]", ",", "\n", "smp_idx", ",", "volume", ",", "weight_matrix", ")", "\n", "# Indicator of last batch", "\n", "if", "last_sample_bool", ":", "\n", "                    ", "pred_undo", "=", "np", ".", "array", "(", "pred_undo", ")", "\n", "fname_ref", "=", "metadata", "[", "0", "]", "[", "MetadataKW", ".", "GT_FILENAMES", "]", "[", "0", "]", "\n", "if", "ofolder", ":", "\n", "                        ", "fname_pred", "=", "str", "(", "Path", "(", "ofolder", ",", "Path", "(", "fname_ref", ")", ".", "name", ")", ")", "\n", "fname_pred", "=", "fname_pred", ".", "split", "(", "testing_params", "[", "'target_suffix'", "]", "[", "0", "]", ")", "[", "0", "]", "+", "'_pred.nii.gz'", "\n", "# If uncertainty running, then we save each simulation result", "\n", "if", "testing_params", "[", "'uncertainty'", "]", "[", "'applied'", "]", ":", "\n", "                            ", "fname_pred", "=", "fname_pred", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'_'", "+", "str", "(", "i_monte_carlo", ")", ".", "zfill", "(", "2", ")", "+", "'.nii.gz'", "\n", "postprocessing", "=", "None", "\n", "", "", "else", ":", "\n", "                        ", "fname_pred", "=", "None", "\n", "# Choose only one modality", "\n", "", "output_nii", "=", "imed_inference", ".", "pred_to_nib", "(", "data_lst", "=", "[", "pred_undo", "]", ",", "\n", "z_lst", "=", "[", "]", ",", "\n", "fname_ref", "=", "fname_ref", ",", "\n", "fname_out", "=", "fname_pred", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "kernel_dim", "=", "'3d'", ",", "\n", "bin_thr", "=", "-", "1", ",", "\n", "postprocessing", "=", "postprocessing", ")", "\n", "output_data", "=", "output_nii", ".", "get_fdata", "(", ")", ".", "transpose", "(", "3", ",", "0", ",", "1", ",", "2", ")", "\n", "preds_npy_list", ".", "append", "(", "output_data", ")", "\n", "\n", "gt", "=", "get_gt", "(", "metadata", "[", "0", "]", "[", "MetadataKW", ".", "GT_FILENAMES", "]", ")", "\n", "gt_npy_list", ".", "append", "(", "gt", ")", "\n", "# Save merged labels with color", "\n", "\n", "if", "pred_undo", ".", "shape", "[", "0", "]", ">", "1", "and", "ofolder", ":", "\n", "                        ", "logger", ".", "warning", "(", "'No color labels saved due to a temporary issue. For more details see:'", "\n", "'https://github.com/ivadomed/ivadomed/issues/720'", ")", "\n", "# TODO: put back the code below. See #720", "\n", "# imed_visualize.save_color_labels(pred_undo,", "\n", "#                              False,", "\n", "#                              batch[MetadataKW.INPUT_METADATA][smp_idx][0]['input_filenames'],", "\n", "#                              fname_pred.split(\".nii.gz\")[0] + '_color.nii.gz',", "\n", "#                              slice_axis)", "\n", "\n", "", "", "", "", "", "if", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ":", "\n", "        ", "save_film_params", "(", "gammas_dict", ",", "betas_dict", ",", "metadata_values_lst", ",", "model_params", "[", "ModelParamsKW", ".", "DEPTH", "]", ",", "\n", "ofolder", ".", "replace", "(", "\"pred_masks\"", ",", "\"\"", ")", ")", "\n", "", "return", "preds_npy_list", ",", "gt_npy_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.threshold_analysis": [[324, 414], ["torch.load", "torch.load", "torch.load.eval", "torch.utils.data.DataLoader", "testing.run_inference", "loguru.logger.info", "tqdm.tqdm", "numpy.max", "loguru.logger.info", "loguru.logger.info", "ValueError", "list", "ivadomed.metrics.MetricManager", "torch.utils.data.ConcatDataset", "ivadomed.postprocessing.threshold_predictions", "metric_dict[].get_results", "tpr_list.append", "fpr_list.append", "dice_list.append", "numpy.where", "ivadomed.metrics.plot_dice_thr", "ivadomed.metrics.plot_roc_curve", "numpy.arange", "ivadomed.postprocessing.threshold_predictions", "copy.deepcopy", "zip", "numpy.max"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.run_inference", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_dice_thr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.plot_roc_curve", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "def", "threshold_analysis", "(", "model_path", ",", "ds_lst", ",", "model_params", ",", "testing_params", ",", "metric", "=", "\"dice\"", ",", "increment", "=", "0.1", ",", "\n", "fname_out", "=", "\"thr.png\"", ",", "cuda_available", "=", "True", ")", ":", "\n", "    ", "\"\"\"Run a threshold analysis to find the optimal threshold on a sub-dataset.\n\n    Args:\n        model_path (str): Model path.\n        ds_lst (list): List of loaders.\n        model_params (dict): Model's parameters.\n        testing_params (dict): Testing parameters\n        metric (str): Choice between \"dice\" and \"recall_specificity\". If \"recall_specificity\", then a ROC analysis\n            is performed.\n        increment (float): Increment between tested thresholds.\n        fname_out (str): Plot output filename.\n        cuda_available (bool): If True, CUDA is available.\n\n    Returns:\n        float: optimal threshold.\n    \"\"\"", "\n", "if", "metric", "not", "in", "[", "\"dice\"", ",", "\"recall_specificity\"", "]", ":", "\n", "        ", "raise", "ValueError", "(", "'\\nChoice of metric for threshold analysis: dice, recall_specificity.'", ")", "\n", "\n", "# Adjust some testing parameters", "\n", "", "testing_params", "[", "\"uncertainty\"", "]", "[", "\"applied\"", "]", "=", "False", "\n", "\n", "# Load model", "\n", "model", "=", "torch", ".", "load", "(", "model_path", ")", "\n", "# Eval mode", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "# List of thresholds", "\n", "thr_list", "=", "list", "(", "np", ".", "arange", "(", "0.0", ",", "1.0", ",", "increment", ")", ")", "[", "1", ":", "]", "\n", "\n", "# Init metric manager for each thr", "\n", "metric_fns", "=", "[", "imed_metrics", ".", "recall_score", ",", "\n", "imed_metrics", ".", "dice_score", ",", "\n", "imed_metrics", ".", "specificity_score", "]", "\n", "metric_dict", "=", "{", "thr", ":", "imed_metrics", ".", "MetricManager", "(", "metric_fns", ")", "for", "thr", "in", "thr_list", "}", "\n", "\n", "# Load", "\n", "loader", "=", "DataLoader", "(", "ConcatDataset", "(", "ds_lst", ")", ",", "batch_size", "=", "testing_params", "[", "\"batch_size\"", "]", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "True", ",", "sampler", "=", "None", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Run inference", "\n", "preds_npy", ",", "gt_npy", "=", "run_inference", "(", "loader", ",", "model", ",", "model_params", ",", "\n", "testing_params", ",", "\n", "ofolder", "=", "None", ",", "\n", "cuda_available", "=", "cuda_available", ")", "\n", "\n", "logger", ".", "info", "(", "'Running threshold analysis to find optimal threshold'", ")", "\n", "# Make sure the GT is binarized", "\n", "gt_npy", "=", "[", "threshold_predictions", "(", "gt", ",", "thr", "=", "0.5", ")", "for", "gt", "in", "gt_npy", "]", "\n", "# Move threshold", "\n", "for", "thr", "in", "tqdm", "(", "thr_list", ",", "desc", "=", "\"Search\"", ")", ":", "\n", "        ", "preds_thr", "=", "[", "threshold_predictions", "(", "copy", ".", "deepcopy", "(", "pred", ")", ",", "thr", "=", "thr", ")", "for", "pred", "in", "preds_npy", "]", "\n", "metric_dict", "[", "thr", "]", "(", "preds_thr", ",", "gt_npy", ")", "\n", "\n", "# Get results", "\n", "", "tpr_list", ",", "fpr_list", ",", "dice_list", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "thr", "in", "thr_list", ":", "\n", "        ", "result_thr", "=", "metric_dict", "[", "thr", "]", ".", "get_results", "(", ")", "\n", "tpr_list", ".", "append", "(", "result_thr", "[", "\"recall_score\"", "]", ")", "\n", "fpr_list", ".", "append", "(", "1", "-", "result_thr", "[", "\"specificity_score\"", "]", ")", "\n", "dice_list", ".", "append", "(", "result_thr", "[", "\"dice_score\"", "]", ")", "\n", "\n", "# Get optimal threshold", "\n", "", "if", "metric", "==", "\"dice\"", ":", "\n", "        ", "diff_list", "=", "dice_list", "\n", "", "else", ":", "\n", "        ", "diff_list", "=", "[", "tpr", "-", "fpr", "for", "tpr", ",", "fpr", "in", "zip", "(", "tpr_list", ",", "fpr_list", ")", "]", "\n", "\n", "", "optimal_idx", "=", "np", ".", "max", "(", "np", ".", "where", "(", "diff_list", "==", "np", ".", "max", "(", "diff_list", ")", ")", ")", "\n", "optimal_threshold", "=", "thr_list", "[", "optimal_idx", "]", "\n", "logger", ".", "info", "(", "'\\tOptimal threshold: {}'", ".", "format", "(", "optimal_threshold", ")", ")", "\n", "\n", "# Save plot", "\n", "logger", ".", "info", "(", "'\\tSaving plot: {}'", ".", "format", "(", "fname_out", ")", ")", "\n", "if", "metric", "==", "\"dice\"", ":", "\n", "# Run plot", "\n", "        ", "imed_metrics", ".", "plot_dice_thr", "(", "thr_list", ",", "dice_list", ",", "optimal_idx", ",", "fname_out", ")", "\n", "", "else", ":", "\n", "# Add 0 and 1 as extrema", "\n", "        ", "tpr_list", "=", "[", "0.0", "]", "+", "tpr_list", "+", "[", "1.0", "]", "\n", "fpr_list", "=", "[", "0.0", "]", "+", "fpr_list", "+", "[", "1.0", "]", "\n", "optimal_idx", "+=", "1", "\n", "# Run plot", "\n", "imed_metrics", ".", "plot_roc_curve", "(", "tpr_list", ",", "fpr_list", ",", "optimal_idx", ",", "fname_out", ")", "\n", "\n", "", "return", "optimal_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.testing.get_gt": [[416, 435], ["numpy.array", "ivadomed.loader.utils.update_filename_to_nifti", "gt_lst.append", "gt_lst.append", "nibabel.load().get_fdata", "numpy.zeros", "nibabel.load", "nibabel.load().get_fdata", "nibabel.load", "list", "filter"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti"], ["", "def", "get_gt", "(", "filenames", ")", ":", "\n", "    ", "\"\"\"Get ground truth data as numpy array.\n    \n    Args:\n        filenames (list): List of ground truth filenames, one per class.\n    Returns:\n        ndarray: 4D numpy array.\n    \"\"\"", "\n", "# Check filenames extentions and update paths if not NifTI", "\n", "filenames", "=", "[", "imed_loader_utils", ".", "update_filename_to_nifti", "(", "fname", ")", "for", "fname", "in", "filenames", "]", "\n", "\n", "gt_lst", "=", "[", "]", "\n", "for", "gt", "in", "filenames", ":", "\n", "# For multi-label, if all labels are not in every image", "\n", "        ", "if", "gt", "is", "not", "None", ":", "\n", "            ", "gt_lst", ".", "append", "(", "nib", ".", "load", "(", "gt", ")", ".", "get_fdata", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "gt_lst", ".", "append", "(", "np", ".", "zeros", "(", "nib", ".", "load", "(", "list", "(", "filter", "(", "None", ",", "filenames", ")", ")", "[", "0", "]", ")", ".", "get_fdata", "(", ")", ".", "shape", ")", ")", "\n", "", "", "return", "np", ".", "array", "(", "gt_lst", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.train": [[30, 402], ["torch.utils.tensorboard.SummaryWriter", "ivadomed.utils.initialize_wandb", "all", "training.get_sampler", "torch.utils.data.DataLoader", "filter", "torch.optim.Adam", "training.get_scheduler", "loguru.logger.info", "pathlib.Path", "loguru.logger.info", "loguru.logger.info", "training.get_loss_function", "ivadomed.losses.DiceLoss", "time.time", "tqdm.tqdm", "pathlib.Path", "torch.save", "torch.save", "pathlib.Path.is_file", "pathlib.Path", "range", "torch.utils.tensorboard.SummaryWriter.close", "wandb.finish", "time.time", "loguru.logger.info", "wandb_params.get", "wandb_params.get", "wandb_params.get", "wandb.init", "training.get_sampler", "torch.utils.data.DataLoader", "range", "loguru.logger.info", "loguru.logger.info", "ivadomed.models.set_model_for_retrain", "loguru.logger.info", "getattr", "getattr.", "model_class.cuda", "model_class.parameters", "copy.copy", "wandb.watch", "training.load_checkpoint", "optim.Adam.state.values", "copy.copy", "float", "float", "float", "float", "range", "time.time", "torch.utils.tensorboard.SummaryWriter.add_scalar", "model_class.train", "enumerate", "loguru.logger.info", "tqdm.tqdm.write", "model_class.eval", "ivadomed.metrics.MetricManager", "torch.load", "torch.load", "pathlib.Path", "model_class.load_state_dict", "torch.save", "torch.save", "pathlib.Path", "torch.save", "torch.save", "loguru.logger.info", "pathlib.Path.mkdir", "pathlib.Path", "[].save", "loguru.logger.info", "random.sample", "dict", "gif_dict[].append", "gif_dict[].append", "ivadomed.visualize.AnimatedGif", "gif_dict[].append", "torch.load.items", "scheduler.get_last_lr", "wandb.log", "ivadomed.utils.cuda", "get_loss_function.", "loss_fct.item", "imed_losses.DiceLoss.item", "optim.Adam.zero_grad", "loss_fct.backward", "optim.Adam.step", "scheduler.step", "dataset_train.update", "enumerate", "imed_metrics.MetricManager.get_results", "imed_metrics.MetricManager.reset", "torch.utils.tensorboard.SummaryWriter.add_scalars", "torch.utils.tensorboard.SummaryWriter.add_scalars", "loguru.logger.info", "time.time", "loguru.logger.info", "pathlib.Path", "ivadomed.utils.save_onnx_model", "loguru.logger.info", "pathlib.Path.is_dir", "str", "str", "str", "range", "copy.copy", "str", "torch.is_tensor", "torch.is_tensor", "ivadomed.utils.cuda", "ivadomed.utils.cuda", "ivadomed.mixup.mixup", "training.get_metadata", "model_class.", "model_class.", "scheduler.step", "ivadomed.visualize.save_img", "imed_utils.cuda.cpu().numpy", "model.data.cpu().numpy", "imed_metrics.MetricManager.", "wandb.log", "wandb.log", "torch.save", "torch.save", "pathlib.Path", "torch.save", "torch.save", "str", "loguru.logger.warning", "[].split", "[].split", "datetime.timedelta", "len", "v.to", "ivadomed.utils.unstack_tensors", "any", "imed_losses.DiceLoss.", "torch.no_grad", "torch.no_grad", "ivadomed.utils.cuda", "get_loss_function.", "loss_fct.item", "imed_losses.DiceLoss.item", "range", "ivadomed.visualize.save_img", "model_class.state_dict", "optim.Adam.state_dict", "abs", "loguru.logger.info", "time.strftime", "ivadomed.utils.cuda", "ivadomed.utils.cuda", "training.get_metadata", "model_class.", "model_class.", "len", "range", "imed_utils.cuda.cpu", "model.data.cpu", "time.localtime", "[].numpy", "ivadomed.utils.unstack_tensors", "any", "imed_losses.DiceLoss.", "[].split", "[].split", "time.strftime", "input_samples[].cpu().numpy", "preds[].cpu().numpy", "ivadomed.visualize.overlap_im_seg", "[].add", "time.localtime", "met.__getitem__", "met.__getitem__", "input_samples[].cpu", "preds[].cpu", "str", "[].split"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.initialize_wandb", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_sampler", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_scheduler", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_loss_function", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.LoopingPillowWriter.finish", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_sampler", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.models.set_model_for_retrain", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.load_checkpoint", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.get_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.MetricManager.reset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.save_onnx_model", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.mixup.mixup", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_img", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.unstack_tensors", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.save_img", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.unstack_tensors", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.overlap_im_seg", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.visualize.AnimatedGif.add", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__getitem__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__getitem__"], ["def", "train", "(", "model_params", ",", "dataset_train", ",", "dataset_val", ",", "training_params", ",", "path_output", ",", "device", ",", "wandb_params", "=", "None", ",", "\n", "cuda_available", "=", "True", ",", "metric_fns", "=", "None", ",", "n_gif", "=", "0", ",", "resume_training", "=", "False", ",", "debugging", "=", "False", ")", ":", "\n", "    ", "\"\"\"Main command to train the network.\n\n    Args:\n        model_params (dict): Model's parameters.\n        dataset_train (imed_loader): Training dataset.\n        dataset_val (imed_loader): Validation dataset.\n        training_params (dict):\n        path_output (str): Folder where log files, best and final models are saved.\n        device (str): Indicates the CPU or GPU ID.\n        cuda_available (bool): If True, CUDA is available.\n        metric_fns (list): List of metrics, see :mod:`ivadomed.metrics`.\n        n_gif (int): Generates a GIF during training if larger than zero, one frame per epoch for a given slice. The\n            parameter indicates the number of 2D slices used to generate GIFs, one GIF per slice. A GIF shows\n            predictions of a given slice from the validation sub-dataset. They are saved within the output path.\n        resume_training (bool): Load a saved model (\"checkpoint.pth.tar\" in the path_output) for resume\n                                training. This training state is saved everytime a new best model is saved in the log\n                                directory.\n        debugging (bool): If True, extended verbosity and intermediate outputs.\n\n    Returns:\n        float, float, float, float: best_training_dice, best_training_loss, best_validation_dice,\n            best_validation_loss.\n    \"\"\"", "\n", "# Write the metrics, images, etc to TensorBoard format", "\n", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "path_output", ")", "\n", "\n", "# Enable wandb tracking  if the required params are found in the config file and the api key is correct", "\n", "wandb_tracking", "=", "imed_utils", ".", "initialize_wandb", "(", "wandb_params", ")", "\n", "\n", "if", "wandb_tracking", ":", "\n", "# Collect all hyperparameters into a dictionary", "\n", "        ", "cfg", "=", "{", "**", "training_params", ",", "**", "model_params", "}", "\n", "\n", "# Get the actual project, group, and run names if they exist, else choose the temporary names as default", "\n", "project_name", "=", "wandb_params", ".", "get", "(", "WandbKW", ".", "PROJECT_NAME", ",", "\"temp_project\"", ")", "\n", "group_name", "=", "wandb_params", ".", "get", "(", "WandbKW", ".", "GROUP_NAME", ",", "\"temp_group\"", ")", "\n", "run_name", "=", "wandb_params", ".", "get", "(", "WandbKW", ".", "RUN_NAME", ",", "\"temp_run\"", ")", "\n", "\n", "if", "project_name", "==", "\"temp_project\"", "or", "group_name", "==", "\"temp_group\"", "or", "run_name", "==", "\"temp_run\"", ":", "\n", "            ", "logger", ".", "info", "(", "\"{PROJECT/GROUP/RUN} name not found, initializing as {'temp_project'/'temp_group'/'temp_run'}\"", ")", "\n", "\n", "# Initialize WandB with metrics and hyperparameters", "\n", "", "wandb", ".", "init", "(", "project", "=", "project_name", ",", "group", "=", "group_name", ",", "name", "=", "run_name", ",", "config", "=", "cfg", ")", "\n", "\n", "# BALANCE SAMPLES AND PYTORCH LOADER", "\n", "", "conditions", "=", "all", "(", "[", "training_params", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "APPLIED", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "!=", "\"HeMIS\"", "]", ")", "\n", "sampler_train", ",", "shuffle_train", "=", "get_sampler", "(", "dataset_train", ",", "conditions", ",", "\n", "training_params", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "TYPE", "]", ")", "\n", "\n", "train_loader", "=", "DataLoader", "(", "dataset_train", ",", "batch_size", "=", "training_params", "[", "TrainingParamsKW", ".", "BATCH_SIZE", "]", ",", "\n", "shuffle", "=", "shuffle_train", ",", "pin_memory", "=", "True", ",", "sampler", "=", "sampler_train", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "gif_dict", "=", "{", "\"image_path\"", ":", "[", "]", ",", "\"slice_id\"", ":", "[", "]", ",", "\"gif\"", ":", "[", "]", "}", "\n", "if", "dataset_val", ":", "\n", "        ", "sampler_val", ",", "shuffle_val", "=", "get_sampler", "(", "dataset_val", ",", "conditions", ",", "\n", "training_params", "[", "TrainingParamsKW", ".", "BALANCE_SAMPLES", "]", "[", "BalanceSamplesKW", ".", "TYPE", "]", ")", "\n", "\n", "val_loader", "=", "DataLoader", "(", "dataset_val", ",", "batch_size", "=", "training_params", "[", "TrainingParamsKW", ".", "BATCH_SIZE", "]", ",", "\n", "shuffle", "=", "shuffle_val", ",", "pin_memory", "=", "True", ",", "sampler", "=", "sampler_val", ",", "\n", "collate_fn", "=", "imed_loader_utils", ".", "imed_collate", ",", "\n", "num_workers", "=", "0", ")", "\n", "\n", "# Init GIF", "\n", "if", "n_gif", ">", "0", ":", "\n", "            ", "indexes_gif", "=", "random", ".", "sample", "(", "range", "(", "len", "(", "dataset_val", ")", ")", ",", "n_gif", ")", "\n", "", "for", "i_gif", "in", "range", "(", "n_gif", ")", ":", "\n", "            ", "random_metadata", "=", "dict", "(", "dataset_val", "[", "indexes_gif", "[", "i_gif", "]", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "0", "]", ")", "\n", "gif_dict", "[", "\"image_path\"", "]", ".", "append", "(", "random_metadata", "[", "MetadataKW", ".", "INPUT_FILENAMES", "]", ")", "\n", "gif_dict", "[", "\"slice_id\"", "]", ".", "append", "(", "random_metadata", "[", "MetadataKW", ".", "SLICE_INDEX", "]", ")", "\n", "gif_obj", "=", "imed_visualize", ".", "AnimatedGif", "(", "size", "=", "dataset_val", "[", "indexes_gif", "[", "i_gif", "]", "]", "[", "\"input\"", "]", ".", "numpy", "(", ")", "[", "0", "]", ".", "shape", ")", "\n", "gif_dict", "[", "\"gif\"", "]", ".", "append", "(", "copy", ".", "copy", "(", "gif_obj", ")", ")", "\n", "\n", "# GET MODEL", "\n", "", "", "if", "training_params", "[", "\"transfer_learning\"", "]", "[", "\"retrain_model\"", "]", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading pretrained model's weights: {}.\"", ")", "\n", "logger", ".", "info", "(", "\"\\tFreezing the {}% first layers.\"", ".", "format", "(", "\n", "100", "-", "training_params", "[", "\"transfer_learning\"", "]", "[", "'retrain_fraction'", "]", "*", "100.", ")", ")", "\n", "old_model_path", "=", "training_params", "[", "\"transfer_learning\"", "]", "[", "\"retrain_model\"", "]", "\n", "fraction", "=", "training_params", "[", "\"transfer_learning\"", "]", "[", "'retrain_fraction'", "]", "\n", "if", "'reset'", "in", "training_params", "[", "\"transfer_learning\"", "]", ":", "\n", "            ", "reset", "=", "training_params", "[", "\"transfer_learning\"", "]", "[", "'reset'", "]", "\n", "", "else", ":", "\n", "            ", "reset", "=", "True", "\n", "# Freeze first layers and reset last layers", "\n", "", "model", "=", "imed_models", ".", "set_model_for_retrain", "(", "old_model_path", ",", "retrain_fraction", "=", "fraction", ",", "map_location", "=", "device", ",", "\n", "reset", "=", "reset", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Initialising model's weights from scratch.\"", ")", "\n", "model_class", "=", "getattr", "(", "imed_models", ",", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", ")", "\n", "model", "=", "model_class", "(", "**", "model_params", ")", "\n", "", "if", "cuda_available", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "num_epochs", "=", "training_params", "[", "\"training_time\"", "]", "[", "\"num_epochs\"", "]", "\n", "\n", "# OPTIMIZER", "\n", "initial_lr", "=", "training_params", "[", "\"scheduler\"", "]", "[", "\"initial_lr\"", "]", "\n", "# filter out the parameters you are going to fine-tuning", "\n", "params_to_opt", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "model", ".", "parameters", "(", ")", ")", "\n", "# Using Adam", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "params_to_opt", ",", "lr", "=", "initial_lr", ")", "\n", "scheduler", ",", "step_scheduler_batch", "=", "get_scheduler", "(", "copy", ".", "copy", "(", "training_params", "[", "\"scheduler\"", "]", "[", "\"lr_scheduler\"", "]", ")", ",", "optimizer", ",", "\n", "num_epochs", ")", "\n", "logger", ".", "info", "(", "\"Scheduler parameters: {}\"", ".", "format", "(", "training_params", "[", "\"scheduler\"", "]", "[", "\"lr_scheduler\"", "]", ")", ")", "\n", "\n", "# Only call wandb methods if required params are found in the config file", "\n", "if", "wandb_tracking", ":", "\n", "# Logs gradients (at every log_freq steps) to the dashboard.", "\n", "        ", "wandb", ".", "watch", "(", "model", ",", "log", "=", "\"gradients\"", ",", "log_freq", "=", "wandb_params", "[", "\"log_grads_every\"", "]", ")", "\n", "\n", "# Resume", "\n", "", "start_epoch", "=", "1", "\n", "resume_path", "=", "Path", "(", "path_output", ",", "\"checkpoint.pth.tar\"", ")", "\n", "if", "resume_training", ":", "\n", "        ", "model", ",", "optimizer", ",", "gif_dict", ",", "start_epoch", ",", "val_loss_total_avg", ",", "scheduler", ",", "patience_count", "=", "load_checkpoint", "(", "\n", "model", "=", "model", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "gif_dict", "=", "gif_dict", ",", "\n", "scheduler", "=", "scheduler", ",", "\n", "fname", "=", "str", "(", "resume_path", ")", ")", "\n", "# Individually transfer the optimizer parts", "\n", "# TODO: check if following lines are needed", "\n", "for", "state", "in", "optimizer", ".", "state", ".", "values", "(", ")", ":", "\n", "            ", "for", "k", ",", "v", "in", "state", ".", "items", "(", ")", ":", "\n", "                ", "if", "torch", ".", "is_tensor", "(", "v", ")", ":", "\n", "                    ", "state", "[", "k", "]", "=", "v", ".", "to", "(", "device", ")", "\n", "\n", "# LOSS", "\n", "", "", "", "", "logger", ".", "info", "(", "\"Selected Loss: {}\"", ".", "format", "(", "training_params", "[", "\"loss\"", "]", "[", "\"name\"", "]", ")", ")", "\n", "logger", ".", "info", "(", "\"\\twith the parameters: {}\"", ".", "format", "(", "\n", "[", "training_params", "[", "\"loss\"", "]", "[", "k", "]", "for", "k", "in", "training_params", "[", "\"loss\"", "]", "if", "k", "!=", "\"name\"", "]", ")", ")", "\n", "loss_fct", "=", "get_loss_function", "(", "copy", ".", "copy", "(", "training_params", "[", "\"loss\"", "]", ")", ")", "\n", "loss_dice_fct", "=", "imed_losses", ".", "DiceLoss", "(", ")", "# For comparison when another loss is used", "\n", "\n", "# INIT TRAINING VARIABLES", "\n", "best_training_dice", ",", "best_training_loss", "=", "float", "(", "\"inf\"", ")", ",", "float", "(", "\"inf\"", ")", "\n", "best_validation_loss", ",", "best_validation_dice", "=", "float", "(", "\"inf\"", ")", ",", "float", "(", "\"inf\"", ")", "\n", "patience_count", "=", "0", "\n", "begin_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# EPOCH LOOP", "\n", "for", "epoch", "in", "tqdm", "(", "range", "(", "num_epochs", ")", ",", "desc", "=", "\"Training\"", ",", "initial", "=", "start_epoch", ")", ":", "\n", "        ", "epoch", "=", "epoch", "+", "start_epoch", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "lr", "=", "scheduler", ".", "get_last_lr", "(", ")", "[", "0", "]", "\n", "writer", ".", "add_scalar", "(", "'learning_rate'", ",", "lr", ",", "epoch", ")", "\n", "if", "wandb_tracking", ":", "\n", "            ", "wandb", ".", "log", "(", "{", "\"learning_rate\"", ":", "lr", "}", ")", "\n", "\n", "# Training loop -----------------------------------------------------------", "\n", "", "model", ".", "train", "(", ")", "\n", "train_loss_total", ",", "train_dice_loss_total", "=", "0.0", ",", "0.0", "\n", "num_steps", "=", "0", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "# GET SAMPLES", "\n", "            ", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "                ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "imed_utils", ".", "unstack_tensors", "(", "batch", "[", "\"input\"", "]", ")", ",", "cuda_available", ")", "\n", "", "else", ":", "\n", "                ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"input\"", "]", ",", "cuda_available", ")", "\n", "", "gt_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"gt\"", "]", ",", "cuda_available", ",", "non_blocking", "=", "True", ")", "\n", "\n", "# MIXUP", "\n", "if", "training_params", "[", "\"mixup_alpha\"", "]", ":", "\n", "                ", "input_samples", ",", "gt_samples", "=", "imed_mixup", ".", "mixup", "(", "input_samples", ",", "gt_samples", ",", "training_params", "[", "\"mixup_alpha\"", "]", ",", "\n", "debugging", "and", "epoch", "==", "1", ",", "path_output", ")", "\n", "\n", "# RUN MODEL", "\n", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", "or", "(", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ")", ":", "\n", "                ", "metadata", "=", "get_metadata", "(", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ",", "model_params", ")", "\n", "preds", "=", "model", "(", "input_samples", ",", "metadata", ")", "\n", "", "else", ":", "\n", "                ", "preds", "=", "model", "(", "input_samples", ")", "\n", "\n", "# LOSS", "\n", "", "loss", "=", "loss_fct", "(", "preds", ",", "gt_samples", ")", "\n", "train_loss_total", "+=", "loss", ".", "item", "(", ")", "\n", "train_dice_loss_total", "+=", "loss_dice_fct", "(", "preds", ",", "gt_samples", ")", ".", "item", "(", ")", "\n", "\n", "# UPDATE OPTIMIZER", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "step_scheduler_batch", ":", "\n", "                ", "scheduler", ".", "step", "(", ")", "\n", "", "num_steps", "+=", "1", "\n", "\n", "# Save image at every 50th step if debugging is true", "\n", "if", "i", "%", "50", "==", "0", "and", "debugging", ":", "\n", "                ", "imed_visualize", ".", "save_img", "(", "writer", ",", "epoch", ",", "\"Train\"", ",", "input_samples", ",", "gt_samples", ",", "preds", ",", "\n", "wandb_tracking", "=", "wandb_tracking", ",", "\n", "is_three_dim", "=", "not", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", ")", "\n", "\n", "", "", "if", "not", "step_scheduler_batch", ":", "\n", "            ", "scheduler", ".", "step", "(", ")", "\n", "\n", "# TRAINING LOSS", "\n", "", "train_loss_total_avg", "=", "train_loss_total", "/", "num_steps", "\n", "msg", "=", "\"Epoch {} training loss: {:.4f}.\"", ".", "format", "(", "epoch", ",", "train_loss_total_avg", ")", "\n", "train_dice_loss_total_avg", "=", "train_dice_loss_total", "/", "num_steps", "\n", "if", "training_params", "[", "\"loss\"", "]", "[", "\"name\"", "]", "!=", "\"DiceLoss\"", ":", "\n", "            ", "msg", "+=", "\"\\tDice training loss: {:.4f}.\"", ".", "format", "(", "train_dice_loss_total_avg", ")", "\n", "", "logger", ".", "info", "(", "msg", ")", "\n", "tqdm", ".", "write", "(", "msg", ")", "\n", "\n", "# CURRICULUM LEARNING", "\n", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "# Increase the probability of a missing modality", "\n", "            ", "model_params", "[", "ModelParamsKW", ".", "MISSING_PROBABILITY", "]", "**=", "model_params", "[", "ModelParamsKW", ".", "MISSING_PROBABILITY_GROWTH", "]", "\n", "dataset_train", ".", "update", "(", "p", "=", "model_params", "[", "ModelParamsKW", ".", "MISSING_PROBABILITY", "]", ")", "\n", "\n", "# Validation loop -----------------------------------------------------", "\n", "", "model", ".", "eval", "(", ")", "\n", "val_loss_total", ",", "val_dice_loss_total", "=", "0.0", ",", "0.0", "\n", "num_steps", "=", "0", "\n", "metric_mgr", "=", "imed_metrics", ".", "MetricManager", "(", "metric_fns", ")", "\n", "if", "dataset_val", ":", "\n", "            ", "for", "i", ",", "batch", "in", "enumerate", "(", "val_loader", ")", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# GET SAMPLES", "\n", "                    ", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "                        ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "imed_utils", ".", "unstack_tensors", "(", "batch", "[", "\"input\"", "]", ")", ",", "cuda_available", ")", "\n", "", "else", ":", "\n", "                        ", "input_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"input\"", "]", ",", "cuda_available", ")", "\n", "", "gt_samples", "=", "imed_utils", ".", "cuda", "(", "batch", "[", "\"gt\"", "]", ",", "cuda_available", ",", "non_blocking", "=", "True", ")", "\n", "\n", "# RUN MODEL", "\n", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", "or", "(", "ModelParamsKW", ".", "FILM_LAYERS", "in", "model_params", "and", "any", "(", "model_params", "[", "ModelParamsKW", ".", "FILM_LAYERS", "]", ")", ")", ":", "\n", "                        ", "metadata", "=", "get_metadata", "(", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ",", "model_params", ")", "\n", "preds", "=", "model", "(", "input_samples", ",", "metadata", ")", "\n", "", "else", ":", "\n", "                        ", "preds", "=", "model", "(", "input_samples", ")", "\n", "\n", "# LOSS", "\n", "", "loss", "=", "loss_fct", "(", "preds", ",", "gt_samples", ")", "\n", "val_loss_total", "+=", "loss", ".", "item", "(", ")", "\n", "val_dice_loss_total", "+=", "loss_dice_fct", "(", "preds", ",", "gt_samples", ")", ".", "item", "(", ")", "\n", "\n", "# Add frame to GIF", "\n", "for", "i_", "in", "range", "(", "len", "(", "input_samples", ")", ")", ":", "\n", "                        ", "im", ",", "pr", ",", "met", "=", "input_samples", "[", "i_", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ",", "preds", "[", "i_", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ",", "batch", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "i_", "]", "[", "0", "]", "\n", "for", "i_gif", "in", "range", "(", "n_gif", ")", ":", "\n", "                            ", "if", "gif_dict", "[", "\"image_path\"", "]", "[", "i_gif", "]", "==", "met", ".", "__getitem__", "(", "'input_filenames'", ")", "and", "gif_dict", "[", "\"slice_id\"", "]", "[", "i_gif", "]", "==", "met", ".", "__getitem__", "(", "'slice_index'", ")", ":", "\n", "                                ", "overlap", "=", "imed_visualize", ".", "overlap_im_seg", "(", "im", ",", "pr", ")", "\n", "gif_dict", "[", "\"gif\"", "]", "[", "i_gif", "]", ".", "add", "(", "overlap", ",", "label", "=", "str", "(", "epoch", ")", ")", "\n", "\n", "", "", "", "", "num_steps", "+=", "1", "\n", "\n", "# METRICS COMPUTATION", "\n", "gt_npy", "=", "gt_samples", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "preds_npy", "=", "preds", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "metric_mgr", "(", "preds_npy", ",", "gt_npy", ")", "\n", "\n", "# Save image at every 10th step if debugging is true", "\n", "if", "i", "%", "50", "==", "0", "and", "debugging", ":", "\n", "                    ", "imed_visualize", ".", "save_img", "(", "writer", ",", "epoch", ",", "\"Validation\"", ",", "input_samples", ",", "gt_samples", ",", "preds", ",", "\n", "wandb_tracking", "=", "wandb_tracking", ",", "\n", "is_three_dim", "=", "not", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", ")", "\n", "\n", "# METRICS COMPUTATION FOR CURRENT EPOCH", "\n", "", "", "val_loss_total_avg_old", "=", "val_loss_total_avg", "if", "epoch", ">", "1", "else", "None", "\n", "metrics_dict", "=", "metric_mgr", ".", "get_results", "(", ")", "\n", "metric_mgr", ".", "reset", "(", ")", "\n", "val_loss_total_avg", "=", "val_loss_total", "/", "num_steps", "\n", "# log losses on Tensorboard by default", "\n", "writer", ".", "add_scalars", "(", "'Validation/Metrics'", ",", "metrics_dict", ",", "epoch", ")", "\n", "writer", ".", "add_scalars", "(", "'losses'", ",", "{", "\n", "'train_loss'", ":", "train_loss_total_avg", ",", "\n", "'val_loss'", ":", "val_loss_total_avg", ",", "\n", "}", ",", "epoch", ")", "\n", "# log on wandb if the corresponding dictionary is provided", "\n", "if", "wandb_tracking", ":", "\n", "                ", "wandb", ".", "log", "(", "{", "\"validation-metrics\"", ":", "metrics_dict", "}", ")", "\n", "wandb", ".", "log", "(", "{", "\"losses\"", ":", "{", "\n", "'train_loss'", ":", "train_loss_total_avg", ",", "\n", "'val_loss'", ":", "val_loss_total_avg", ",", "\n", "}", "}", ")", "\n", "", "msg", "=", "\"Epoch {} validation loss: {:.4f}.\"", ".", "format", "(", "epoch", ",", "val_loss_total_avg", ")", "\n", "val_dice_loss_total_avg", "=", "val_dice_loss_total", "/", "num_steps", "\n", "if", "training_params", "[", "\"loss\"", "]", "[", "\"name\"", "]", "!=", "\"DiceLoss\"", ":", "\n", "                ", "msg", "+=", "\"\\tDice validation loss: {:.4f}.\"", ".", "format", "(", "val_dice_loss_total_avg", ")", "\n", "", "logger", ".", "info", "(", "msg", ")", "\n", "end_time", "=", "time", ".", "time", "(", ")", "\n", "total_time", "=", "end_time", "-", "start_time", "\n", "msg_epoch", "=", "\"Epoch {} took {:.2f} seconds.\"", ".", "format", "(", "epoch", ",", "total_time", ")", "\n", "logger", ".", "info", "(", "msg_epoch", ")", "\n", "\n", "# UPDATE BEST RESULTS", "\n", "if", "val_loss_total_avg", "<", "best_validation_loss", ":", "\n", "# Save checkpoint", "\n", "                ", "state", "=", "{", "'epoch'", ":", "epoch", "+", "1", ",", "\n", "'state_dict'", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'gif_dict'", ":", "gif_dict", ",", "\n", "'scheduler'", ":", "scheduler", ",", "\n", "'patience_count'", ":", "patience_count", ",", "\n", "'validation_loss'", ":", "val_loss_total_avg", "}", "\n", "torch", ".", "save", "(", "state", ",", "resume_path", ")", "\n", "\n", "# Save best model file", "\n", "model_path", "=", "Path", "(", "path_output", ",", "\"best_model.pt\"", ")", "\n", "torch", ".", "save", "(", "model", ",", "model_path", ")", "\n", "\n", "# Update best scores", "\n", "best_validation_loss", ",", "best_training_loss", "=", "val_loss_total_avg", ",", "train_loss_total_avg", "\n", "best_validation_dice", ",", "best_training_dice", "=", "val_dice_loss_total_avg", ",", "train_dice_loss_total_avg", "\n", "\n", "# EARLY STOPPING", "\n", "", "if", "epoch", ">", "1", ":", "\n", "                ", "val_diff", "=", "(", "val_loss_total_avg_old", "-", "val_loss_total_avg", ")", "*", "100", "/", "abs", "(", "val_loss_total_avg", ")", "\n", "if", "val_diff", "<", "training_params", "[", "\"training_time\"", "]", "[", "\"early_stopping_epsilon\"", "]", ":", "\n", "                    ", "patience_count", "+=", "1", "\n", "", "if", "patience_count", ">=", "training_params", "[", "\"training_time\"", "]", "[", "\"early_stopping_patience\"", "]", ":", "\n", "                    ", "logger", ".", "info", "(", "\"Stopping training due to {} epochs without improvements\"", ".", "format", "(", "patience_count", ")", ")", "\n", "break", "\n", "\n", "# Save final model", "\n", "", "", "", "", "final_model_path", "=", "Path", "(", "path_output", ",", "\"final_model.pt\"", ")", "\n", "torch", ".", "save", "(", "model", ",", "final_model_path", ")", "\n", "\n", "# Save best model in output path", "\n", "if", "resume_path", ".", "is_file", "(", ")", ":", "\n", "        ", "state", "=", "torch", ".", "load", "(", "resume_path", ")", "\n", "model_path", "=", "Path", "(", "path_output", ",", "\"best_model.pt\"", ")", "\n", "model", ".", "load_state_dict", "(", "state", "[", "'state_dict'", "]", ")", "\n", "torch", ".", "save", "(", "model", ",", "model_path", ")", "\n", "# Save best model as ONNX in the model directory", "\n", "try", ":", "\n", "# Convert best model to ONNX and save it in model directory", "\n", "            ", "best_model_path", "=", "Path", "(", "path_output", ",", "model_params", "[", "ModelParamsKW", ".", "FOLDER_NAME", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "FOLDER_NAME", "]", "+", "\".onnx\"", ")", "\n", "imed_utils", ".", "save_onnx_model", "(", "model", ",", "input_samples", ",", "str", "(", "best_model_path", ")", ")", "\n", "logger", ".", "info", "(", "f\"Model saved as '.onnx': {best_model_path}\"", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "logger", ".", "warning", "(", "f\"Failed to save the model as '.onnx': {e}\"", ")", "\n", "\n", "# Save best model as PT in the model directory", "\n", "", "best_model_path", "=", "Path", "(", "path_output", ",", "model_params", "[", "ModelParamsKW", ".", "FOLDER_NAME", "]", ",", "\n", "model_params", "[", "ModelParamsKW", ".", "FOLDER_NAME", "]", "+", "\".pt\"", ")", "\n", "torch", ".", "save", "(", "model", ",", "best_model_path", ")", "\n", "logger", ".", "info", "(", "f\"Model saved as '.pt': {best_model_path}\"", ")", "\n", "\n", "# Save GIFs", "\n", "", "gif_folder", "=", "Path", "(", "path_output", ",", "\"gifs\"", ")", "\n", "if", "n_gif", ">", "0", "and", "not", "gif_folder", ".", "is_dir", "(", ")", ":", "\n", "        ", "gif_folder", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "for", "i_gif", "in", "range", "(", "n_gif", ")", ":", "\n", "        ", "fname_out", "=", "gif_dict", "[", "\"image_path\"", "]", "[", "i_gif", "]", ".", "split", "(", "os", ".", "sep", ")", "[", "-", "3", "]", "+", "\"__\"", "\n", "fname_out", "+=", "gif_dict", "[", "\"image_path\"", "]", "[", "i_gif", "]", ".", "split", "(", "os", ".", "sep", ")", "[", "-", "1", "]", ".", "split", "(", "\".nii.gz\"", ")", "[", "0", "]", ".", "split", "(", "\n", "gif_dict", "[", "\"image_path\"", "]", "[", "i_gif", "]", ".", "split", "(", "os", ".", "sep", ")", "[", "-", "3", "]", "+", "\"_\"", ")", "[", "1", "]", "+", "\"__\"", "\n", "fname_out", "+=", "str", "(", "gif_dict", "[", "\"slice_id\"", "]", "[", "i_gif", "]", ")", "+", "\".gif\"", "\n", "path_gif_out", "=", "Path", "(", "gif_folder", ",", "fname_out", ")", "\n", "gif_dict", "[", "\"gif\"", "]", "[", "i_gif", "]", ".", "save", "(", "str", "(", "path_gif_out", ")", ")", "\n", "\n", "", "writer", ".", "close", "(", ")", "\n", "wandb", ".", "finish", "(", ")", "\n", "final_time", "=", "time", ".", "time", "(", ")", "\n", "duration_time", "=", "final_time", "-", "begin_time", "\n", "logger", ".", "info", "(", "'begin '", "+", "time", ".", "strftime", "(", "'%H:%M:%S'", ",", "time", ".", "localtime", "(", "begin_time", ")", ")", "+", "\"| End \"", "+", "\n", "time", ".", "strftime", "(", "'%H:%M:%S'", ",", "time", ".", "localtime", "(", "final_time", ")", ")", "+", "\n", "\"| duration \"", "+", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "duration_time", ")", ")", ")", "\n", "\n", "return", "best_training_dice", ",", "best_training_loss", ",", "best_validation_dice", ",", "best_validation_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_sampler": [[404, 419], ["ivadomed.loader.balanced_sampler.BalancedSampler"], "function", ["None"], ["", "def", "get_sampler", "(", "ds", ",", "balance_bool", ",", "metadata", ")", ":", "\n", "    ", "\"\"\"Get sampler.\n\n    Args:\n        ds (BidsDataset): BidsDataset object.\n        balance_bool (bool): If True, a sampler is generated that balance positive and negative samples.\n\n    Returns:\n        If balance_bool is True: Returns BalancedSampler, Bool: Sampler and boolean for shuffling (set to False).\n        Otherwise: Returns None and True.\n    \"\"\"", "\n", "if", "balance_bool", ":", "\n", "        ", "return", "BalancedSampler", "(", "ds", ",", "metadata", ")", ",", "False", "\n", "", "else", ":", "\n", "        ", "return", "None", ",", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_scheduler": [[421, 448], ["torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingWarmRestarts", "torch.optim.lr_scheduler.CyclicLR", "ValueError"], "function", ["None"], ["", "", "def", "get_scheduler", "(", "params", ",", "optimizer", ",", "num_epochs", "=", "0", ")", ":", "\n", "    ", "\"\"\"Get scheduler.\n\n    Args:\n        params (dict): scheduler parameters, see `PyTorch documentation <https://pytorch.org/docs/stable/optim.html>`__\n        optimizer (torch optim):\n        num_epochs (int): number of epochs.\n\n    Returns:\n        torch.optim, bool, which indicates if the scheduler is updated for each batch (True), or for each epoch (False).\n    \"\"\"", "\n", "step_scheduler_batch", "=", "False", "\n", "scheduler_name", "=", "params", "[", "\"name\"", "]", "\n", "del", "params", "[", "\"name\"", "]", "\n", "if", "scheduler_name", "==", "\"CosineAnnealingLR\"", ":", "\n", "        ", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "optimizer", ",", "num_epochs", ")", "\n", "", "elif", "scheduler_name", "==", "\"CosineAnnealingWarmRestarts\"", ":", "\n", "        ", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "CosineAnnealingWarmRestarts", "(", "optimizer", ",", "**", "params", ")", "\n", "", "elif", "scheduler_name", "==", "\"CyclicLR\"", ":", "\n", "        ", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "CyclicLR", "(", "optimizer", ",", "**", "params", ",", "mode", "=", "\"triangular2\"", ",", "cycle_momentum", "=", "False", ")", "\n", "step_scheduler_batch", "=", "True", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"{} is an unknown LR Scheduler name, please choose between 'CosineAnnealingLR', \"", "\n", "\"'CosineAnnealingWarmRestarts', or 'CyclicLR'\"", ".", "format", "(", "scheduler_name", ")", ")", "\n", "\n", "", "return", "scheduler", ",", "step_scheduler_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_loss_function": [[450, 474], ["getattr", "getattr.", "ValueError"], "function", ["None"], ["", "def", "get_loss_function", "(", "params", ")", ":", "\n", "    ", "\"\"\"Get Loss function.\n\n    Args:\n        params (dict): See :mod:`ivadomed.losses`.\n\n    Returns:\n        imed_losses object.\n    \"\"\"", "\n", "# Loss function name", "\n", "loss_name", "=", "params", "[", "\"name\"", "]", "\n", "del", "params", "[", "\"name\"", "]", "\n", "\n", "# Check if implemented", "\n", "loss_function_available", "=", "[", "\"DiceLoss\"", ",", "\"FocalLoss\"", ",", "\"GeneralizedDiceLoss\"", ",", "\"FocalDiceLoss\"", ",", "\"MultiClassDiceLoss\"", ",", "\n", "\"BinaryCrossEntropyLoss\"", ",", "\"TverskyLoss\"", ",", "\"FocalTverskyLoss\"", ",", "\"AdapWingLoss\"", ",", "\"L2loss\"", ",", "\n", "\"LossCombination\"", "]", "\n", "if", "loss_name", "not", "in", "loss_function_available", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Unknown Loss function: {}, please choose between {}\"", ".", "format", "(", "loss_name", ",", "loss_function_available", ")", ")", "\n", "\n", "", "loss_class", "=", "getattr", "(", "imed_losses", ",", "loss_name", ")", "\n", "loss_fct", "=", "loss_class", "(", "**", "params", ")", "\n", "return", "loss_fct", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.get_metadata": [[476, 492], ["numpy.array", "model_params[].transform().tolist", "range", "len", "model_params[].transform"], "function", ["None"], ["", "def", "get_metadata", "(", "metadata", ",", "model_params", ")", ":", "\n", "    ", "\"\"\"Get metadata during batch loop.\n\n    Args:\n        metadata (batch):\n        model_params (dict):\n\n    Returns:\n        If FiLMedUnet, Returns a list of metadata, that have been transformed by the One Hot Encoder.\n        If HeMISUnet, Returns a numpy array where each row represents a sample and each column represents a contrast.\n    \"\"\"", "\n", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "HEMIS_UNET", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "m", "[", "0", "]", "[", "\"missing_mod\"", "]", "for", "m", "in", "metadata", "]", ")", "\n", "", "else", ":", "\n", "        ", "return", "[", "model_params", "[", "ModelParamsKW", ".", "FILM_ONEHOTENCODER", "]", ".", "transform", "(", "[", "metadata", "[", "k", "]", "[", "0", "]", "[", "'film_input'", "]", "]", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "metadata", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.training.load_checkpoint": [[494, 527], ["loguru.logger.info", "torch.load", "torch.load", "model.load_state_dict", "optimizer.load_state_dict", "loguru.logger.info", "loguru.logger.warning"], "function", ["None"], ["", "", "def", "load_checkpoint", "(", "model", ",", "optimizer", ",", "gif_dict", ",", "scheduler", ",", "fname", ")", ":", "\n", "    ", "\"\"\"Load checkpoint.\n\n    This function check if a checkpoint is available. If so, it updates the state of the input objects.\n\n    Args:\n        model (nn.Module): Init model.\n        optimizer (torch.optim): Model's optimizer.\n        gif_dict (dict): Dictionary containing a GIF of the training.\n        scheduler (_LRScheduler): Learning rate scheduler.\n        fname (str): Checkpoint filename.\n\n    Return:\n        nn.Module, torch, dict, int, float, _LRScheduler, int\n    \"\"\"", "\n", "start_epoch", "=", "1", "\n", "validation_loss", "=", "0", "\n", "patience_count", "=", "0", "\n", "try", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading checkpoint: {}\"", ".", "format", "(", "fname", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "fname", ")", "\n", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "validation_loss", "=", "checkpoint", "[", "'validation_loss'", "]", "\n", "scheduler", "=", "checkpoint", "[", "'scheduler'", "]", "\n", "gif_dict", "=", "checkpoint", "[", "'gif_dict'", "]", "\n", "patience_count", "=", "checkpoint", "[", "'patience_count'", "]", "\n", "logger", ".", "info", "(", "\"... Resume training from epoch #{}\"", ".", "format", "(", "start_epoch", ")", ")", "\n", "", "except", ":", "\n", "        ", "logger", ".", "warning", "(", "\"\\nNo checkpoint found at: {}\"", ".", "format", "(", "fname", ")", ")", "\n", "\n", "", "return", "model", ",", "optimizer", ",", "gif_dict", ",", "start_epoch", ",", "validation_loss", ",", "scheduler", ",", "patience_count", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.__init__": [[87, 96], ["config_manager.ConfigurationManager._validate_path", "str", "config_manager.load_json", "config_manager.load_json", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager._validate_path", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.load_json", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.load_json"], ["def", "__init__", "(", "self", ",", "path_context", ")", ":", "\n", "        ", "self", ".", "path_context", "=", "path_context", "\n", "self", ".", "key_change_dict", "=", "KEY_CHANGE_DICT", "\n", "self", ".", "key_split_dataset_change_lst", "=", "KEY_SPLIT_DATASET_CHANGE_LST", "\n", "self", ".", "_validate_path", "(", ")", "\n", "default_config_path", "=", "str", "(", "Path", "(", "imed_utils", ".", "__ivadomed_dir__", ",", "\"ivadomed\"", ",", "\"config\"", ",", "\"config_default.json\"", ")", ")", "\n", "self", ".", "config_default", "=", "load_json", "(", "default_config_path", ")", "\n", "self", ".", "context_original", "=", "load_json", "(", "path_context", ")", "\n", "self", ".", "config_updated", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.config_updated": [[101, 112], ["copy.deepcopy", "config_manager.ConfigurationManager.change_keys", "config_manager.update", "config_manager.ConfigurationManager.change_keys_values", "config_manager.ConfigurationManager._display_differing_keys", "list", "config_updated[].keys", "copy.deepcopy.keys"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.change_keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.change_keys_values", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager._display_differing_keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "@", "config_updated", ".", "setter", "\n", "def", "config_updated", "(", "self", ",", "config_updated", ")", ":", "\n", "        ", "if", "config_updated", "==", "{", "}", ":", "\n", "            ", "context", "=", "copy", ".", "deepcopy", "(", "self", ".", "context_original", ")", "\n", "self", ".", "change_keys", "(", "context", ",", "list", "(", "context", ".", "keys", "(", ")", ")", ")", "\n", "config_updated", "=", "update", "(", "self", ".", "config_default", ",", "context", ")", "\n", "self", ".", "change_keys_values", "(", "config_updated", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", ",", "config_updated", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", ".", "keys", "(", ")", ")", "\n", "\n", "", "self", ".", "_config_updated", "=", "config_updated", "\n", "if", "config_updated", "[", "'debugging'", "]", ":", "\n", "            ", "self", ".", "_display_differing_keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config": [[113, 119], ["None"], "methods", ["None"], ["", "", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get updated configuration file with all parameters from the default config file.\n        Returns:\n            dict: Updated configuration dict.\n        \"\"\"", "\n", "return", "self", ".", "config_updated", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.change_keys": [[120, 137], ["isinstance", "config_manager.ConfigurationManager.change_keys", "list", "v.keys"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.change_keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "change_keys", "(", "self", ",", "context", ",", "keys", ")", ":", "\n", "        ", "for", "k", "in", "keys", ":", "\n", "# Verify if key is still in the dict", "\n", "            ", "if", "k", "in", "context", ":", "\n", "                ", "if", "k", "==", "\"NumpyToTensor\"", ":", "\n", "                    ", "del", "context", "[", "k", "]", "\n", "continue", "\n", "", "v", "=", "context", "[", "k", "]", "\n", "# Verify if value is a dictionary", "\n", "if", "isinstance", "(", "v", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "                    ", "self", ".", "change_keys", "(", "v", ",", "list", "(", "v", ".", "keys", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "# Change keys from the key_change_dict", "\n", "                    ", "for", "key", "in", "self", ".", "key_change_dict", ":", "\n", "                        ", "if", "key", "in", "context", ":", "\n", "                            ", "context", "[", "self", ".", "key_change_dict", "[", "key", "]", "]", "=", "context", "[", "key", "]", "\n", "del", "context", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.change_keys_values": [[138, 149], ["None"], "methods", ["None"], ["", "", "", "", "", "", "def", "change_keys_values", "(", "self", ",", "config_updated", ",", "keys", ")", ":", "\n", "        ", "for", "k", "in", "self", ".", "key_split_dataset_change_lst", ":", "\n", "            ", "if", "k", "in", "keys", ":", "\n", "                ", "value", "=", "config_updated", "[", "k", "]", "\n", "if", "k", "==", "'method'", "and", "value", "==", "\"per_center\"", ":", "\n", "                    ", "config_updated", "[", "SplitDatasetKW", ".", "DATA_TESTING", "]", "[", "DataTestingKW", ".", "DATA_TYPE", "]", "=", "\"institution_id\"", "\n", "", "if", "k", "==", "'center_test'", "and", "config_updated", "[", "SplitDatasetKW", ".", "DATA_TESTING", "]", "[", "DataTestingKW", ".", "DATA_TYPE", "]", "==", "\"institution_id\"", "and", "value", "is", "not", "None", ":", "\n", "                    ", "config_updated", "[", "SplitDatasetKW", ".", "DATA_TESTING", "]", "[", "DataTestingKW", ".", "DATA_VALUE", "]", "=", "value", "\n", "", "del", "config_updated", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager._display_differing_keys": [[150, 156], ["loguru.logger.info", "config_manager.deep_dict_compare", "loguru.logger.info"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.deep_dict_compare"], ["", "", "", "def", "_display_differing_keys", "(", "self", ")", ":", "\n", "        ", "\"\"\"Display differences between dictionaries.\n        \"\"\"", "\n", "logger", ".", "info", "(", "'Adding the following keys to the configuration file'", ")", "\n", "deep_dict_compare", "(", "self", ".", "context_original", ",", "self", ".", "config_updated", ")", "\n", "logger", ".", "info", "(", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager._validate_path": [[157, 177], ["pathlib.Path().exists", "ValueError", "pathlib.Path().is_dir", "IsADirectoryError", "pathlib.Path", "pathlib.Path", "pathlib.Path().is_file", "FileNotFoundError", "pathlib.Path().absolute", "config_manager.ConfigurationManager.path_context.endswith", "config_manager.ConfigurationManager.path_context.endswith", "ValueError", "pathlib.Path().absolute", "pathlib.Path", "config_manager.ConfigurationManager.path_context.endswith", "ValueError", "pathlib.Path", "pathlib.Path().absolute", "pathlib.Path", "pathlib.Path().absolute", "pathlib.Path", "pathlib.Path().absolute", "pathlib.Path", "pathlib.Path"], "methods", ["None"], ["", "def", "_validate_path", "(", "self", ")", ":", "\n", "        ", "\"\"\"Ensure validity of configuration file path.\n        \"\"\"", "\n", "if", "not", "Path", "(", "self", ".", "path_context", ")", ".", "exists", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"\\nERROR: The provided configuration file path (.json) does not exist: \"", "\n", "f\"{Path(self.path_context).absolute()}\\n\"", ")", "\n", "", "elif", "Path", "(", "self", ".", "path_context", ")", ".", "is_dir", "(", ")", ":", "\n", "            ", "raise", "IsADirectoryError", "(", "f\"ERROR: The provided configuration file path (.json) is a directory not a file: \"", "\n", "f\"{Path(self.path_context).absolute()}\\n\"", ")", "\n", "", "elif", "not", "Path", "(", "self", ".", "path_context", ")", ".", "is_file", "(", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "f\"ERROR: The provided configuration file path (.json) is not found: \"", "\n", "f\"{Path(self.path_context).absolute()}\\n\"", ")", "\n", "", "elif", "self", ".", "path_context", ".", "endswith", "(", "'.yaml'", ")", "or", "self", ".", "path_context", ".", "endswith", "(", "'.yml'", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"\\nERROR: The provided configuration file path (.json) is a yaml file not a json file, \"", "\n", "f\"yaml files are not yet supported: {Path(self.path_context).absolute()}\\n\"", ")", "\n", "", "elif", "not", "self", ".", "path_context", ".", "endswith", "(", "'.json'", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"\\nERROR: The provided configuration file path (.json) is not a json file: \"", "\n", "f\"{Path(self.path_context).absolute()}\\n\"", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update": [[10, 30], ["u.items", "isinstance", "config_manager.update", "d.get", "isinstance", "isinstance"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["def", "update", "(", "d", ",", "u", ")", ":", "\n", "    ", "\"\"\"Update dictionary and nested dictionaries.\n\n    Args:\n        d (dict): Source dictionary that is updated by destination dictionary.\n        u (dict): Destination dictionary.\n\n    Returns:\n        dict: updated dictionary\n    \"\"\"", "\n", "for", "k", ",", "v", "in", "u", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "            ", "d", "[", "k", "]", "=", "update", "(", "d", ".", "get", "(", "k", ",", "{", "}", ")", ",", "v", ")", "\n", "", "else", ":", "\n", "# If source dictionary has keys that the destination dict doesn't have, keep these keys", "\n", "            ", "if", "k", "in", "d", "and", "isinstance", "(", "d", "[", "k", "]", ",", "collections", ".", "abc", ".", "Mapping", ")", "and", "not", "isinstance", "(", "v", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "d", "[", "k", "]", "=", "v", "\n", "", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.deep_dict_compare": [[32, 53], ["loguru.logger.info", "isinstance", "isinstance", "config_manager.deep_dict_compare", "config_manager.deep_dict_compare"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.deep_dict_compare", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.deep_dict_compare"], ["", "def", "deep_dict_compare", "(", "source_dict", ",", "dest_dict", ",", "keyname", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compare and display differences between dictionaries (and nested dictionaries).\n\n    Args:\n        source_dict (dict): Source dictionary.\n        dest_dict (dict): Destination dictionary.\n        keyname (str): Key name to indicate the path to nested parameter.\n\n    \"\"\"", "\n", "for", "key", "in", "dest_dict", ":", "\n", "        ", "if", "key", "not", "in", "source_dict", ":", "\n", "            ", "key_str", "=", "key", "if", "keyname", "is", "None", "else", "keyname", "+", "key", "\n", "logger", ".", "info", "(", "f'    {key_str}: {dest_dict[key]}'", ")", "\n", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "dest_dict", "[", "key", "]", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "                ", "if", "isinstance", "(", "source_dict", "[", "key", "]", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "                    ", "deep_dict_compare", "(", "source_dict", "[", "key", "]", ",", "dest_dict", "[", "key", "]", ",", "key", "+", "\": \"", ")", "\n", "# In case a new dictionary appears in updated file", "\n", "", "else", ":", "\n", "                    ", "deep_dict_compare", "(", "source_dict", ",", "dest_dict", "[", "key", "]", ",", "key", "+", "\": \"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.load_json": [[55, 68], ["open", "json.load"], "function", ["None"], ["", "", "", "", "", "def", "load_json", "(", "config_path", ")", ":", "\n", "    ", "\"\"\"Load json file content\n\n    Args:\n        config_path (str): Path to json file.\n\n    Returns:\n        dict: config dictionary.\n\n    \"\"\"", "\n", "with", "open", "(", "config_path", ",", "\"r\"", ")", "as", "fhandle", ":", "\n", "        ", "default_config", "=", "json", ".", "load", "(", "fhandle", ")", "\n", "", "return", "default_config", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.Metavar.__str__": [[33, 35], ["None"], "methods", ["None"], ["def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.initialize_wandb": [[37, 60], ["wandb.login", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info"], "function", ["None"], ["", "", "def", "initialize_wandb", "(", "wandb_params", ")", ":", "\n", "    ", "try", ":", "\n", "# Log on to WandB (assuming that the API Key is correct)", "\n", "# if not, login would raise an exception for the cases invalid API key and not found", "\n", "        ", "wandb", ".", "login", "(", "key", "=", "wandb_params", "[", "WandbKW", ".", "WANDB_API_KEY", "]", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "# log error mssg for unsuccessful wandb authentication", "\n", "        ", "if", "wandb_params", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "\"Incorrect WandB API Key! Please re-check the entered API key.\"", ")", "\n", "logger", ".", "info", "(", "\"Disabling WandB Tracking, continuing with Tensorboard Logging\"", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "\"No WandB parameters found! Continuing with Tensorboard Logging\"", ")", "\n", "\n", "# set flag", "\n", "", "wandb_tracking", "=", "False", "\n", "\n", "", "else", ":", "\n", "# setting flag after successful authentication", "\n", "        ", "logger", ".", "info", "(", "\"WandB API Authentication Successful!\"", ")", "\n", "wandb_tracking", "=", "True", "\n", "\n", "", "return", "wandb_tracking", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_task": [[62, 64], ["None"], "function", ["None"], ["", "def", "get_task", "(", "model_name", ")", ":", "\n", "    ", "return", "\"classification\"", "if", "model_name", "in", "CLASSIFIER_LIST", "else", "\"segmentation\"", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda": [[66, 84], ["isinstance", "input_var.cuda", "t.cuda"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "def", "cuda", "(", "input_var", ",", "cuda_available", "=", "True", ",", "non_blocking", "=", "False", ")", ":", "\n", "    ", "\"\"\"Passes input_var to GPU.\n\n    Args:\n        input_var (Tensor): either a tensor or a list of tensors.\n        cuda_available (bool): If False, then return identity\n        non_blocking (bool):\n\n    Returns:\n        Tensor\n    \"\"\"", "\n", "if", "cuda_available", ":", "\n", "        ", "if", "isinstance", "(", "input_var", ",", "list", ")", ":", "\n", "            ", "return", "[", "t", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "for", "t", "in", "input_var", "]", "\n", "", "else", ":", "\n", "            ", "return", "input_var", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "\n", "", "", "else", ":", "\n", "        ", "return", "input_var", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.unstack_tensors": [[86, 99], ["range", "list_tensor.append", "sample[].unsqueeze"], "function", ["None"], ["", "", "def", "unstack_tensors", "(", "sample", ")", ":", "\n", "    ", "\"\"\"Unstack tensors.\n\n    Args:\n        sample (Tensor):\n\n    Returns:\n        list: list of Tensors.\n    \"\"\"", "\n", "list_tensor", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "sample", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "list_tensor", ".", "append", "(", "sample", "[", ":", ",", "i", ",", "]", ".", "unsqueeze", "(", "1", ")", ")", "\n", "", "return", "list_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.generate_sha_256": [[101, 125], ["isinstance", "hashlib.sha256", "open", "iter", "hashlib.sha256.hexdigest", "hashlib.sha256.update", "f.read"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "def", "generate_sha_256", "(", "context", ":", "dict", ",", "df", ",", "file_lst", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "    ", "\"\"\"generate sha256 for a training file\n\n    Args:\n        context (dict): configuration context.\n        df (pd.DataFrame): Dataframe containing all BIDS image files indexed and their metadata.\n        file_lst (List[str]): list of strings containing training files\n    \"\"\"", "\n", "from", "pandas", "import", "DataFrame", "\n", "assert", "isinstance", "(", "df", ",", "DataFrame", ")", "\n", "\n", "# generating sha256 for list of data", "\n", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "=", "{", "}", "\n", "# file_list is a list of filename strings", "\n", "for", "file", "in", "file_lst", ":", "\n", "# bids_df is a dataframe with column values path...filename...", "\n", "# so df_sub is the row with matching filename=file", "\n", "        ", "df_sub", "=", "df", ".", "loc", "[", "df", "[", "'filename'", "]", "==", "file", "]", "\n", "file_path", "=", "df_sub", "[", "'path'", "]", ".", "values", "[", "0", "]", "\n", "sha256_hash", "=", "hashlib", ".", "sha256", "(", ")", "\n", "with", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "for", "byte_block", "in", "iter", "(", "lambda", ":", "f", ".", "read", "(", "4096", ")", ",", "b\"\"", ")", ":", "\n", "                ", "sha256_hash", ".", "update", "(", "byte_block", ")", "\n", "", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "[", "file", "]", "=", "sha256_hash", ".", "hexdigest", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.save_onnx_model": [[127, 145], ["model.eval", "torch.onnx.export", "len"], "function", ["None"], ["", "", "", "def", "save_onnx_model", "(", "model", ",", "inputs", ",", "model_path", ")", ":", "\n", "    ", "\"\"\"Convert PyTorch model to ONNX model and save it as `model_path`.\n\n    Args:\n        model (nn.Module): PyTorch model.\n        inputs (Tensor): Tensor, used to inform shape and axes.\n        model_path (str): Output filename for the ONNX model.\n    \"\"\"", "\n", "import", "torch", "\n", "model", ".", "eval", "(", ")", "\n", "dynamic_axes", "=", "{", "0", ":", "'batch'", ",", "1", ":", "'num_channels'", ",", "2", ":", "'height'", ",", "3", ":", "'width'", ",", "4", ":", "'depth'", "}", "\n", "if", "len", "(", "inputs", ".", "shape", ")", "==", "4", ":", "\n", "        ", "del", "dynamic_axes", "[", "4", "]", "\n", "", "torch", ".", "onnx", ".", "export", "(", "model", ",", "inputs", ",", "model_path", ",", "\n", "opset_version", "=", "11", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "dynamic_axes", "=", "{", "'input'", ":", "dynamic_axes", ",", "'output'", ":", "dynamic_axes", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.define_device": [[147, 168], ["torch.device", "torch.cuda.is_available", "loguru.logger.info", "loguru.logger.info", "int", "torch.cuda.set_device", "loguru.logger.info", "torch.cuda.is_available", "str"], "function", ["None"], ["", "def", "define_device", "(", "gpu_id", ")", ":", "\n", "    ", "\"\"\"Define the device used for the process of interest.\n\n    Args:\n        gpu_id (int): GPU ID.\n\n    Returns:\n        Bool, device: True if cuda is available.\n    \"\"\"", "\n", "import", "torch", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:\"", "+", "str", "(", "gpu_id", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "if", "not", "cuda_available", ":", "\n", "        ", "logger", ".", "info", "(", "\"Cuda is not available.\"", ")", "\n", "logger", ".", "info", "(", "\"Working on {}.\"", ".", "format", "(", "device", ")", ")", "\n", "", "if", "cuda_available", ":", "\n", "# Set the GPU", "\n", "        ", "gpu_id", "=", "int", "(", "gpu_id", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "gpu_id", ")", "\n", "logger", ".", "info", "(", "f\"Using GPU ID {gpu_id}\"", ")", "\n", "", "return", "cuda_available", ",", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_model_spec": [[170, 180], ["loguru.logger.info", "list", "params.keys", "loguru.logger.info"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "display_selected_model_spec", "(", "params", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected model and its parameters.\n\n    Args:\n        params (dict): Keys are param names and values are param values.\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Selected architecture: {}, with the following parameters:'", ".", "format", "(", "params", "[", "\"name\"", "]", ")", ")", "\n", "for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "k", "!=", "\"name\"", ":", "\n", "            ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.display_selected_transfoms": [[182, 192], ["loguru.logger.info", "list", "params.keys", "loguru.logger.info"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "", "", "def", "display_selected_transfoms", "(", "params", ",", "dataset_type", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected transforms for a given dataset.\n\n    Args:\n        params (dict):\n        dataset_type (list): e.g. ['testing'] or ['training', 'validation']\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Selected transformations for the {} dataset:'", ".", "format", "(", "dataset_type", ")", ")", "\n", "for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample": [[194, 229], ["plt.interactive", "plt.rcParams.update", "plt.figure", "plt.subplot", "plt.axis", "plt.imshow", "plt.title", "plt.subplot", "plt.axis", "plt.imshow", "plt.title", "len", "plt.savefig", "plt.show"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update"], ["", "", "def", "plot_transformed_sample", "(", "before", ",", "after", ",", "list_title", "=", "None", ",", "fname_out", "=", "\"\"", ",", "cmap", "=", "\"jet\"", ")", ":", "\n", "    ", "\"\"\"Utils tool to plot sample before and after transform, for debugging.\n\n    Args:\n        before (ndarray): Sample before transform.\n        after (ndarray): Sample after transform.\n        list_title (list of str): Sub titles of before and after, resp.\n        fname_out (str): Output filename where the plot is saved if provided.\n        cmap (str): Matplotlib colour map.\n    \"\"\"", "\n", "import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "if", "list_title", "is", "None", ":", "\n", "        ", "list_title", "=", "[", "]", "\n", "", "if", "len", "(", "list_title", ")", "==", "0", ":", "\n", "        ", "list_title", "=", "[", "'Sample before transform'", ",", "'Sample after transform'", "]", "\n", "\n", "", "plt", ".", "interactive", "(", "False", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'figure.max_open_warning'", ":", "0", "}", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "20", ",", "10", ")", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "before", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "0", "]", ",", "fontsize", "=", "20", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "after", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "1", "]", ",", "fontsize", "=", "20", ")", "\n", "\n", "if", "fname_out", ":", "\n", "        ", "plt", ".", "savefig", "(", "fname_out", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils._git_info": [[231, 258], ["os.getenv", "os.getenv", "pathlib.Path", "utils.check_exe", "pathlib.Path().is_dir", "pathlib.Path.open", "f.read().strip", "utils.__get_commit", "utils.__get_branch", "pathlib.Path", "f.read"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.check_exe", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_commit", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_branch"], ["", "", "def", "_git_info", "(", "commit_env", "=", "'IVADOMED_COMMIT'", ",", "branch_env", "=", "'IVADOMED_BRANCH'", ")", ":", "\n", "    ", "\"\"\"Get ivadomed version info from GIT.\n\n    This functions retrieves the ivadomed version, commit, branch and installation type.\n\n    Args:\n        commit_env (str):\n        branch_env (str):\n    Returns:\n        str, str, str, str: installation type, commit, branch, version.\n    \"\"\"", "\n", "ivadomed_commit", "=", "os", ".", "getenv", "(", "commit_env", ",", "\"unknown\"", ")", "\n", "ivadomed_branch", "=", "os", ".", "getenv", "(", "branch_env", ",", "\"unknown\"", ")", "\n", "if", "check_exe", "(", "\"git\"", ")", "and", "Path", "(", "__ivadomed_dir__", ",", "\".git\"", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "ivadomed_commit", "=", "__get_commit", "(", ")", "or", "ivadomed_commit", "\n", "ivadomed_branch", "=", "__get_branch", "(", ")", "or", "ivadomed_branch", "\n", "\n", "", "if", "ivadomed_commit", "!=", "'unknown'", ":", "\n", "        ", "install_type", "=", "'git'", "\n", "", "else", ":", "\n", "        ", "install_type", "=", "'package'", "\n", "\n", "", "path_version", "=", "Path", "(", "__ivadomed_dir__", ",", "'ivadomed'", ",", "'version.txt'", ")", "\n", "with", "path_version", ".", "open", "(", ")", "as", "f", ":", "\n", "        ", "version_ivadomed", "=", "f", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "\n", "", "return", "install_type", ",", "ivadomed_commit", ",", "ivadomed_branch", ",", "version_ivadomed", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.check_exe": [[260, 283], ["pathlib.Path", "utils.check_exe.is_exe"], "function", ["None"], ["", "def", "check_exe", "(", "name", ")", ":", "\n", "    ", "\"\"\"Ensure that a program exists.\n\n    Args:\n        name (str): Name or path to program.\n    Returns:\n        str or None: path of the program or None\n    \"\"\"", "\n", "\n", "def", "is_exe", "(", "fpath", ")", ":", "\n", "        ", "return", "Path", "(", "fpath", ")", ".", "is_file", "(", ")", "and", "os", ".", "access", "(", "fpath", ",", "os", ".", "X_OK", ")", "\n", "\n", "", "fpath", "=", "Path", "(", "name", ")", ".", "parent", "\n", "if", "fpath", "and", "is_exe", "(", "name", ")", ":", "\n", "        ", "return", "fpath", "\n", "", "else", ":", "\n", "        ", "for", "path", "in", "os", ".", "environ", "[", "\"PATH\"", "]", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "            ", "path", "=", "path", ".", "strip", "(", "'\"'", ")", "\n", "exe_file", "=", "str", "(", "Path", "(", "path", ",", "name", ")", ")", "\n", "if", "is_exe", "(", "exe_file", ")", ":", "\n", "                ", "return", "exe_file", "\n", "\n", "", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments": [[289, 307], ["parser.parse_args", "utils.ArgParseException", "sys.exit"], "function", ["None"], ["", "def", "get_arguments", "(", "parser", ",", "args", ")", ":", "\n", "    ", "\"\"\"Get arguments from function input or command line.\n\n    Arguments:\n        parser (argparse.ArgumentParser): ArgumentParser object\n        args (list): either a list of arguments or None. The list\n            should be formatted like this:\n            [\"-d\", \"SOME_ARG\", \"--model\", \"SOME_ARG\"]\n    \"\"\"", "\n", "try", ":", "\n", "        ", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "", "except", "SystemExit", "as", "e", ":", "\n", "        ", "if", "e", ".", "code", "!=", "0", ":", "# Calling `--help` raises SystemExit with 0 exit code (i.e. not an ArgParseException)", "\n", "            ", "raise", "ArgParseException", "(", "'Error parsing args'", ")", "\n", "", "else", ":", "\n", "            ", "sys", ".", "exit", "(", "0", ")", "\n", "\n", "", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_commit": [[309, 348], ["subprocess.Popen", "subprocess.Popen.communicate", "subprocess.Popen", "subprocess.Popen.communicate", "pathlib.Path().expanduser().absolute", "output.decode().strip", "output.decode().strip().splitlines", "line.rstrip.rstrip", "line.rstrip.startswith", "pathlib.Path().expanduser", "output.decode", "output.decode().strip", "pathlib.Path", "output.decode"], "function", ["None"], ["", "def", "__get_commit", "(", "path_to_git_folder", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get GIT ivadomed commit.\n\n    Args:\n        path_to_git_folder (str): Path to GIT folder.\n    Returns:\n        str: git commit ID, with trailing '*' if modified.\n    \"\"\"", "\n", "if", "path_to_git_folder", "is", "None", ":", "\n", "        ", "path_to_git_folder", "=", "__ivadomed_dir__", "\n", "", "else", ":", "\n", "        ", "path_to_git_folder", "=", "Path", "(", "path_to_git_folder", ")", ".", "expanduser", "(", ")", ".", "absolute", "(", ")", "\n", "\n", "", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"rev-parse\"", ",", "\"HEAD\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ",", "\n", "cwd", "=", "path_to_git_folder", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "if", "status", "==", "0", ":", "\n", "        ", "commit", "=", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", "\n", "", "else", ":", "\n", "        ", "commit", "=", "\"?!?\"", "\n", "\n", "", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"status\"", ",", "\"--porcelain\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ",", "\n", "cwd", "=", "path_to_git_folder", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "if", "status", "==", "0", ":", "\n", "        ", "unclean", "=", "True", "\n", "for", "line", "in", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", ".", "splitlines", "(", ")", ":", "\n", "            ", "line", "=", "line", ".", "rstrip", "(", ")", "\n", "if", "line", ".", "startswith", "(", "\"??\"", ")", ":", "# ignore ignored files, they can't hurt", "\n", "                ", "continue", "\n", "", "break", "\n", "", "else", ":", "\n", "            ", "unclean", "=", "False", "\n", "", "if", "unclean", ":", "\n", "            ", "commit", "+=", "\"*\"", "\n", "\n", "", "", "return", "commit", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.__get_branch": [[350, 365], ["subprocess.Popen", "subprocess.Popen.communicate", "output.decode().strip", "output.decode"], "function", ["None"], ["", "def", "__get_branch", "(", ")", ":", "\n", "    ", "\"\"\"Get ivadomed branch.\n\n    Args:\n\n    Returns:\n        str: ivadomed branch.\n    \"\"\"", "\n", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"rev-parse\"", ",", "\"--abbrev-ref\"", ",", "\"HEAD\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "\n", "stderr", "=", "subprocess", ".", "PIPE", ",", "cwd", "=", "__ivadomed_dir__", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "\n", "if", "status", "==", "0", ":", "\n", "        ", "return", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils._version_string": [[367, 373], ["utils._git_info", "locals"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils._git_info"], ["", "", "def", "_version_string", "(", ")", ":", "\n", "    ", "install_type", ",", "ivadomed_commit", ",", "ivadomed_branch", ",", "version_ivadomed", "=", "_git_info", "(", ")", "\n", "if", "install_type", "==", "\"package\"", ":", "\n", "        ", "return", "version_ivadomed", "\n", "", "else", ":", "\n", "        ", "return", "\"{install_type}-{ivadomed_branch}-{ivadomed_commit}\"", ".", "format", "(", "**", "locals", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_command": [[379, 398], ["loguru.logger.info", "loguru.logger.error", "loguru.logger.error"], "function", ["None"], ["def", "get_command", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "train", ":", "\n", "        ", "return", "\"train\"", "\n", "", "elif", "args", ".", "test", ":", "\n", "        ", "return", "\"test\"", "\n", "", "elif", "args", ".", "segment", ":", "\n", "        ", "return", "\"segment\"", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"No CLI argument given for command: ( --train | --test | --segment ). Will check config file for command...\"", ")", "\n", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "COMMAND", "]", "==", "\"train\"", "or", "context", "[", "ConfigKW", ".", "COMMAND", "]", "==", "\"test\"", "or", "context", "[", "\n", "ConfigKW", ".", "COMMAND", "]", "==", "\"segment\"", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "COMMAND", "]", "\n", "", "else", ":", "\n", "                ", "logger", ".", "error", "(", "\"Specified invalid command argument in config file.\"", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a command argument via CLI nor config file.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_path_output": [[400, 411], ["loguru.logger.info", "loguru.logger.error"], "function", ["None"], ["", "", "", "def", "get_path_output", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "path_output", ":", "\n", "        ", "return", "args", ".", "path_output", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"CLI flag --path-output not used to specify output directory. Will check config file for directory...\"", ")", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a path-output argument via CLI nor config file.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_path_data": [[413, 424], ["loguru.logger.info", "loguru.logger.error"], "function", ["None"], ["", "", "", "def", "get_path_data", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "path_data", ":", "\n", "        ", "return", "args", ".", "path_data", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"CLI flag --path-data not used to specify BIDS data directory. Will check config file for directory...\"", ")", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a path-data argument via CLI nor config file.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.format_path_data": [[426, 438], ["isinstance", "isinstance", "isinstance"], "function", ["None"], ["", "", "", "def", "format_path_data", "(", "path_data", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        path_data (list or str): Either a list of paths, or just one path.\n\n    Returns:\n        list: A list of paths\n    \"\"\"", "\n", "assert", "isinstance", "(", "path_data", ",", "str", ")", "or", "isinstance", "(", "path_data", ",", "list", ")", "\n", "if", "isinstance", "(", "path_data", ",", "str", ")", ":", "\n", "        ", "path_data", "=", "[", "path_data", "]", "\n", "", "return", "path_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.similarity_score": [[440, 449], ["difflib.SequenceMatcher().ratio", "difflib.SequenceMatcher"], "function", ["None"], ["", "def", "similarity_score", "(", "a", ":", "str", ",", "b", ":", "str", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    use DiffLIb SequenceMatcher to resolve the similarity between text. Help make better choice in terms of derivatives.\n    Args:\n        a: a string\n        b: another string\n    Returns: a score indicative of the similarity between the sequence.\n    \"\"\"", "\n", "return", "SequenceMatcher", "(", "None", ",", "a", ",", "b", ")", ".", "ratio", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed": [[451, 455], ["loguru.logger.info"], "function", ["None"], ["", "def", "init_ivadomed", "(", ")", ":", "\n", "    ", "\"\"\"Initialize the ivadomed for typical terminal usage.\"\"\"", "\n", "# Display ivadomed version", "\n", "logger", ".", "info", "(", "'\\nivadomed ({})\\n'", ".", "format", "(", "__version__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.print_stats": [[457, 461], ["loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "numpy.mean", "numpy.median", "numpy.percentile", "numpy.percentile"], "function", ["None"], ["", "def", "print_stats", "(", "arr", ")", ":", "\n", "    ", "logger", ".", "info", "(", "f\"\\tMean: {np.mean(arr)} %\"", ")", "\n", "logger", ".", "info", "(", "f\"\\tMedian: {np.median(arr)} %\"", ")", "\n", "logger", ".", "info", "(", "f\"\\tInter-quartile range: [{np.percentile(arr, 25)}, {np.percentile(arr, 75)}] %\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp": [[463, 470], ["datetime.datetime.now().isoformat().replace", "datetime.datetime.now().isoformat", "datetime.datetime.now"], "function", ["None"], ["", "def", "get_timestamp", "(", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Return a datetime string in the format YYYY-MM-DDTHHMMSS.(sub-precision)\n    Returns:\n    \"\"\"", "\n", "timestamp", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "isoformat", "(", ")", ".", "replace", "(", "\":\"", ",", "\"\"", ")", "\n", "return", "timestamp", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_system_memory": [[472, 484], ["platform.system", "utils.get_linux_system_memory", "utils.get_win_system_memory", "utils.get_mac_system_memory"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_linux_system_memory", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_win_system_memory", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_mac_system_memory"], ["", "def", "get_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Return the system memory in GB.\n    Returns:\n    \"\"\"", "\n", "current_platform", "=", "platform", ".", "system", "(", ")", "\n", "if", "current_platform", "==", "\"Linux\"", ":", "\n", "        ", "return", "get_linux_system_memory", "(", ")", "\n", "", "elif", "current_platform", "==", "\"Windows\"", ":", "\n", "        ", "return", "get_win_system_memory", "(", ")", "\n", "", "elif", "current_platform", "==", "\"Darwin\"", ":", "\n", "        ", "return", "get_mac_system_memory", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_win_system_memory": [[486, 499], ["os.popen", "os.popen.read", "os.popen.close", "process.read.split", "int"], "function", ["None"], ["", "", "def", "get_win_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on Windows system.\n    Returns: memory in GB\n    Source: https://stackoverflow.com/a/21589439\n    \"\"\"", "\n", "process", "=", "os", ".", "popen", "(", "'wmic memorychip get capacity'", ")", "\n", "result", "=", "process", ".", "read", "(", ")", "\n", "process", ".", "close", "(", ")", "\n", "totalMem", "=", "0", "\n", "for", "m", "in", "result", ".", "split", "(", "\"  \\n\\n\"", ")", "[", "1", ":", "-", "1", "]", ":", "\n", "        ", "totalMem", "+=", "int", "(", "m", ")", "\n", "", "return", "totalMem", "/", "(", "1024", "**", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_linux_system_memory": [[501, 511], ["os.sysconf", "os.sysconf"], "function", ["None"], ["", "def", "get_linux_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on Linux system.\n    Returns: memory in GB\n    Source: https://stackoverflow.com/a/28161352\n    \"\"\"", "\n", "import", "os", "\n", "mem_bytes", "=", "os", ".", "sysconf", "(", "'SC_PAGE_SIZE'", ")", "*", "os", ".", "sysconf", "(", "'SC_PHYS_PAGES'", ")", "# e.g. 4015976448", "\n", "mem_gib", "=", "mem_bytes", "/", "(", "1024.", "**", "3", ")", "# e.g. 3.74", "\n", "return", "mem_gib", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_mac_system_memory": [[513, 540], ["[].decode", "[].decode.split", "re.compile", "range", "len", "processLines[].strip", "re.compile.split", "subprocess.Popen().communicate", "float", "subprocess.Popen"], "function", ["None"], ["", "def", "get_mac_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on MacOS system.\n    Returns: memory in GB\n    Source: https://apple.stackexchange.com/a/4296\n    \"\"\"", "\n", "\n", "import", "subprocess", "\n", "import", "re", "\n", "\n", "# Get process info", "\n", "ps", "=", "subprocess", ".", "Popen", "(", "[", "'ps'", ",", "'-caxm'", ",", "'-orss,comm'", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "communicate", "(", ")", "[", "0", "]", ".", "decode", "(", ")", "\n", "\n", "# Iterate processes", "\n", "processLines", "=", "ps", ".", "split", "(", "'\\n'", ")", "\n", "sep", "=", "re", ".", "compile", "(", "'[\\s]+'", ")", "\n", "rssTotal", "=", "0", "# kB", "\n", "for", "row", "in", "range", "(", "1", ",", "len", "(", "processLines", ")", ")", ":", "\n", "        ", "rowText", "=", "processLines", "[", "row", "]", ".", "strip", "(", ")", "\n", "rowElements", "=", "sep", ".", "split", "(", "rowText", ")", "\n", "try", ":", "\n", "            ", "rss", "=", "float", "(", "rowElements", "[", "0", "]", ")", "*", "1024", "\n", "", "except", ":", "\n", "            ", "rss", "=", "0", "# ignore...", "\n", "", "rssTotal", "+=", "rss", "\n", "\n", "", "return", "rssTotal", "/", "1024", "**", "3", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.__init__": [[151, 213], ["scipy.ndimage.generate_binary_structure", "numpy.zeros", "numpy.zeros", "range", "numpy.copy", "len", "numpy.expand_dims", "len", "numpy.expand_dims", "evaluation.Evaluation3DMetrics._get_size_ranges", "numpy.zeros", "numpy.zeros", "range", "scipy.ndimage.label", "scipy.ndimage.label", "evaluation.Evaluation3DMetrics.label_per_size", "list", "evaluation.Evaluation3DMetrics.label_per_size", "list", "evaluation.Evaluation3DMetrics.label_size_lst.append", "set", "set", "numpy.round", "numpy.nonzero", "numpy.nonzero", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_size_ranges", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.label_per_size", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.label_per_size"], ["def", "__init__", "(", "self", ",", "data_pred", ",", "data_gt", ",", "dim_lst", ",", "params", "=", "None", ")", ":", "\n", "        ", "if", "params", "is", "None", ":", "\n", "            ", "params", "=", "{", "}", "\n", "\n", "", "self", ".", "data_pred", "=", "data_pred", "\n", "if", "len", "(", "self", ".", "data_pred", ".", "shape", ")", "==", "3", ":", "\n", "            ", "self", ".", "data_pred", "=", "np", ".", "expand_dims", "(", "self", ".", "data_pred", ",", "-", "1", ")", "\n", "\n", "", "self", ".", "data_gt", "=", "data_gt", "\n", "if", "len", "(", "self", ".", "data_gt", ".", "shape", ")", "==", "3", ":", "\n", "            ", "self", ".", "data_gt", "=", "np", ".", "expand_dims", "(", "self", ".", "data_gt", ",", "-", "1", ")", "\n", "\n", "", "h", ",", "w", ",", "d", ",", "self", ".", "n_classes", "=", "self", ".", "data_gt", ".", "shape", "\n", "self", ".", "px", ",", "self", ".", "py", ",", "self", ".", "pz", "=", "dim_lst", "\n", "\n", "self", ".", "bin_struct", "=", "generate_binary_structure", "(", "3", ",", "2", ")", "# 18-connectivity", "\n", "self", ".", "postprocessing_dict", "=", "{", "}", "\n", "self", ".", "size_min", "=", "0", "\n", "\n", "if", "\"target_size\"", "in", "params", ":", "\n", "            ", "self", ".", "size_rng_lst", ",", "self", ".", "size_suffix_lst", "=", "self", ".", "_get_size_ranges", "(", "thr_lst", "=", "params", "[", "\"target_size\"", "]", "[", "\"thr\"", "]", ",", "\n", "unit", "=", "params", "[", "\"target_size\"", "]", "[", "\"unit\"", "]", ")", "\n", "self", ".", "label_size_lst", "=", "[", "]", "\n", "self", ".", "data_gt_per_size", "=", "np", ".", "zeros", "(", "self", ".", "data_gt", ".", "shape", ")", "\n", "self", ".", "data_pred_per_size", "=", "np", ".", "zeros", "(", "self", ".", "data_gt", ".", "shape", ")", "\n", "for", "idx", "in", "range", "(", "self", ".", "n_classes", ")", ":", "\n", "                ", "self", ".", "data_gt_per_size", "[", "...", ",", "idx", "]", "=", "self", ".", "label_per_size", "(", "self", ".", "data_gt", "[", "...", ",", "idx", "]", ")", "\n", "label_gt_size_lst", "=", "list", "(", "set", "(", "self", ".", "data_gt_per_size", "[", "np", ".", "nonzero", "(", "self", ".", "data_gt_per_size", ")", "]", ")", ")", "\n", "self", ".", "data_pred_per_size", "[", "...", ",", "idx", "]", "=", "self", ".", "label_per_size", "(", "self", ".", "data_pred", "[", "...", ",", "idx", "]", ")", "\n", "label_pred_size_lst", "=", "list", "(", "set", "(", "self", ".", "data_pred_per_size", "[", "np", ".", "nonzero", "(", "self", ".", "data_pred_per_size", ")", "]", ")", ")", "\n", "self", ".", "label_size_lst", ".", "append", "(", "[", "label_gt_size_lst", "+", "label_pred_size_lst", ",", "\n", "[", "'gt'", "]", "*", "len", "(", "label_gt_size_lst", ")", "+", "[", "'pred'", "]", "*", "len", "(", "label_pred_size_lst", ")", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "label_size_lst", "=", "[", "[", "[", "]", ",", "[", "]", "]", "]", "*", "self", ".", "n_classes", "\n", "\n", "# 18-connected components", "\n", "", "self", ".", "data_pred_label", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "d", ",", "self", ".", "n_classes", ")", ",", "dtype", "=", "'u1'", ")", "\n", "self", ".", "data_gt_label", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "d", ",", "self", ".", "n_classes", ")", ",", "dtype", "=", "'u1'", ")", "\n", "self", ".", "n_pred", "=", "[", "None", "]", "*", "self", ".", "n_classes", "\n", "self", ".", "n_gt", "=", "[", "None", "]", "*", "self", ".", "n_classes", "\n", "for", "idx", "in", "range", "(", "self", ".", "n_classes", ")", ":", "\n", "            ", "self", ".", "data_pred_label", "[", "...", ",", "idx", "]", ",", "self", ".", "n_pred", "[", "idx", "]", "=", "label", "(", "self", ".", "data_pred", "[", "...", ",", "idx", "]", ",", "\n", "structure", "=", "self", ".", "bin_struct", ")", "\n", "self", ".", "data_gt_label", "[", "...", ",", "idx", "]", ",", "self", ".", "n_gt", "[", "idx", "]", "=", "label", "(", "self", ".", "data_gt", "[", "...", ",", "idx", "]", ",", "\n", "structure", "=", "self", ".", "bin_struct", ")", "\n", "\n", "# painted data, object wise", "\n", "", "self", ".", "data_painted", "=", "np", ".", "copy", "(", "self", ".", "data_pred", ")", "\n", "\n", "# overlap_vox is used to define the object-wise TP, FP, FN", "\n", "if", "\"overlap\"", "in", "params", ":", "\n", "            ", "if", "params", "[", "\"overlap\"", "]", "[", "\"unit\"", "]", "==", "'vox'", ":", "\n", "                ", "self", ".", "overlap_vox", "=", "params", "[", "\"overlap\"", "]", "[", "\"thr\"", "]", "\n", "", "elif", "params", "[", "\"overlap\"", "]", "[", "\"unit\"", "]", "==", "'mm3'", ":", "\n", "                ", "self", ".", "overlap_vox", "=", "np", ".", "round", "(", "params", "[", "\"overlap\"", "]", "[", "\"thr\"", "]", "/", "(", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", ")", ")", "\n", "", "elif", "params", "[", "\"overlap\"", "]", "[", "\"unit\"", "]", "==", "'ratio'", ":", "# The ratio of the GT object", "\n", "                ", "self", ".", "overlap_ratio", "=", "params", "[", "\"overlap\"", "]", "[", "\"thr\"", "]", "\n", "self", ".", "overlap_vox", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "overlap_vox", "=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_size_ranges": [[214, 252], ["enumerate", "rng_lst.append", "suffix_lst.append", "rng_lst.append", "suffix_lst.append", "numpy.round", "numpy.round", "numpy.round", "str", "str", "str"], "methods", ["None"], ["", "", "def", "_get_size_ranges", "(", "self", ",", "thr_lst", ",", "unit", ")", ":", "\n", "        ", "\"\"\"Get size ranges of objects in image.\n\n        Args:\n            thr_lst (list): Bins ranging each size category.\n            unit (str): Choice between 'vox' for voxel of 'mm3'.\n\n        Returns:\n            list, list: range list, suffix related to range\n        \"\"\"", "\n", "assert", "unit", "in", "[", "'vox'", ",", "'mm3'", "]", "\n", "\n", "rng_lst", ",", "suffix_lst", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "thr", "in", "enumerate", "(", "thr_lst", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "thr_low", "=", "self", ".", "size_min", "\n", "", "else", ":", "\n", "                ", "thr_low", "=", "thr_lst", "[", "i", "-", "1", "]", "+", "1", "\n", "\n", "", "thr_high", "=", "thr", "\n", "\n", "if", "unit", "==", "'mm3'", ":", "\n", "                ", "thr_low", "=", "np", ".", "round", "(", "thr_low", "/", "(", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", ")", ")", "\n", "thr_high", "=", "np", ".", "round", "(", "thr_high", "/", "(", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", ")", ")", "\n", "\n", "", "rng_lst", ".", "append", "(", "[", "thr_low", ",", "thr_high", "]", ")", "\n", "\n", "suffix_lst", ".", "append", "(", "'_'", "+", "str", "(", "thr_low", ")", "+", "'-'", "+", "str", "(", "thr_high", ")", "+", "unit", ")", "\n", "\n", "# last subgroup", "\n", "", "thr_low", "=", "thr_lst", "[", "i", "]", "+", "1", "\n", "if", "unit", "==", "'mm3'", ":", "\n", "            ", "thr_low", "=", "np", ".", "round", "(", "thr_low", "/", "(", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", ")", ")", "\n", "", "thr_high", "=", "np", ".", "inf", "\n", "rng_lst", ".", "append", "(", "[", "thr_low", ",", "thr_high", "]", ")", "\n", "suffix_lst", ".", "append", "(", "'_'", "+", "str", "(", "thr_low", ")", "+", "'-INF'", "+", "unit", ")", "\n", "\n", "return", "rng_lst", ",", "suffix_lst", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.label_per_size": [[253, 275], ["scipy.ndimage.label", "numpy.zeros", "range", "numpy.zeros.astype", "numpy.count_nonzero", "enumerate", "numpy.nonzero"], "methods", ["None"], ["", "def", "label_per_size", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Get data with labels corresponding to label size.\n\n        Args:\n            data (ndarray): Input data.\n\n        Returns:\n            ndarray\n        \"\"\"", "\n", "data_label", ",", "n", "=", "label", "(", "data", ",", "\n", "structure", "=", "self", ".", "bin_struct", ")", "\n", "data_out", "=", "np", ".", "zeros", "(", "data", ".", "shape", ")", "\n", "\n", "for", "idx", "in", "range", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "            ", "data_idx", "=", "(", "data_label", "==", "idx", ")", ".", "astype", "(", "int", ")", "\n", "n_nonzero", "=", "np", ".", "count_nonzero", "(", "data_idx", ")", "\n", "\n", "for", "idx_size", ",", "rng", "in", "enumerate", "(", "self", ".", "size_rng_lst", ")", ":", "\n", "                ", "if", "n_nonzero", ">=", "rng", "[", "0", "]", "and", "n_nonzero", "<=", "rng", "[", "1", "]", ":", "\n", "                    ", "data_out", "[", "np", ".", "nonzero", "(", "data_idx", ")", "]", "=", "idx_size", "+", "1", "\n", "\n", "", "", "", "return", "data_out", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_vol": [[276, 281], ["numpy.sum"], "methods", ["None"], ["", "def", "get_vol", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Get volume.\"\"\"", "\n", "vol", "=", "np", ".", "sum", "(", "data", ")", "\n", "vol", "*=", "self", ".", "px", "*", "self", ".", "py", "*", "self", ".", "pz", "\n", "return", "vol", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_rvd": [[282, 301], ["evaluation.Evaluation3DMetrics.get_vol", "evaluation.Evaluation3DMetrics.get_vol"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_vol", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_vol"], ["", "def", "get_rvd", "(", "self", ")", ":", "\n", "        ", "\"\"\"Relative volume difference.\n\n        The volume is here defined by the physical volume, in mm3, of the non-zero voxels of a given mask.\n        Relative volume difference equals the difference between the ground-truth and prediction volumes, divided by the\n        ground-truth volume.\n        Optimal value is zero. Negative value indicates over-segmentation, while positive value indicates\n        under-segmentation.\n        \"\"\"", "\n", "vol_gt", "=", "self", ".", "get_vol", "(", "self", ".", "data_gt", ")", "\n", "vol_pred", "=", "self", ".", "get_vol", "(", "self", ".", "data_pred", ")", "\n", "\n", "if", "vol_gt", "==", "0.0", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n", "", "rvd", "=", "(", "vol_gt", "-", "vol_pred", ")", "\n", "rvd", "/=", "vol_gt", "\n", "\n", "return", "rvd", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_avd": [[302, 310], ["abs", "evaluation.Evaluation3DMetrics.get_rvd"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_rvd"], ["", "def", "get_avd", "(", "self", ")", ":", "\n", "        ", "\"\"\"Absolute volume difference.\n\n        The volume is here defined by the physical volume, in mm3, of the non-zero voxels of a given mask.\n        Absolute volume difference equals the absolute value of the Relative Volume Difference.\n        Optimal value is zero.\n        \"\"\"", "\n", "return", "abs", "(", "self", ".", "get_rvd", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_ltp_lfn": [[311, 349], ["range", "numpy.max", "numpy.round", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.nonzero"], "methods", ["None"], ["", "def", "_get_ltp_lfn", "(", "self", ",", "label_size", ",", "class_idx", "=", "0", ")", ":", "\n", "        ", "\"\"\"Number of true positive and false negative lesion.\n\n        Args:\n            label_size (int): Size of label.\n            class_idx (int): Label index. If monolabel 0, else ranges from 0 to number of output channels - 1.\n\n        Note1: if two lesion_pred overlap with the current lesion_gt,\n            then only one detection is counted.\n        \"\"\"", "\n", "ltp", ",", "lfn", ",", "n_obj", "=", "0", ",", "0", ",", "0", "\n", "\n", "for", "idx", "in", "range", "(", "1", ",", "self", ".", "n_gt", "[", "class_idx", "]", "+", "1", ")", ":", "\n", "            ", "data_gt_idx", "=", "(", "self", ".", "data_gt_label", "[", "...", ",", "class_idx", "]", "==", "idx", ")", ".", "astype", "(", "int", ")", "\n", "overlap", "=", "(", "data_gt_idx", "*", "self", ".", "data_pred", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# if label_size is None, then we look at all object sizes", "\n", "# we check if the currrent object belongs to the current size range", "\n", "if", "label_size", "is", "None", "or", "np", ".", "max", "(", "self", ".", "data_gt_per_size", "[", "...", ",", "class_idx", "]", "[", "np", ".", "nonzero", "(", "data_gt_idx", ")", "]", ")", "==", "label_size", ":", "\n", "\n", "                ", "if", "self", ".", "overlap_vox", "is", "None", ":", "\n", "                    ", "overlap_vox", "=", "np", ".", "round", "(", "np", ".", "count_nonzero", "(", "data_gt_idx", ")", "*", "self", ".", "overlap_ratio", ")", "\n", "", "else", ":", "\n", "                    ", "overlap_vox", "=", "self", ".", "overlap_vox", "\n", "\n", "", "if", "np", ".", "count_nonzero", "(", "overlap", ")", ">=", "overlap_vox", ":", "\n", "                    ", "ltp", "+=", "1", "\n", "\n", "", "else", ":", "\n", "                    ", "lfn", "+=", "1", "\n", "\n", "if", "label_size", "is", "None", ":", "# painting is done while considering all objects", "\n", "                        ", "self", ".", "data_painted", "[", "...", ",", "class_idx", "]", "[", "self", ".", "data_gt_label", "[", "...", ",", "class_idx", "]", "==", "idx", "]", "=", "FN_COLOUR", "\n", "\n", "", "", "n_obj", "+=", "1", "\n", "\n", "", "", "return", "ltp", ",", "lfn", ",", "n_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_lfp": [[350, 384], ["range", "numpy.max", "numpy.max", "numpy.round", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.nonzero"], "methods", ["None"], ["", "def", "_get_lfp", "(", "self", ",", "label_size", ",", "class_idx", "=", "0", ")", ":", "\n", "        ", "\"\"\"Number of false positive lesion.\n\n        Args:\n            label_size (int): Size of label.\n            class_idx (int): Label index. If monolabel 0, else ranges from 0 to number of output channels - 1.\n        \"\"\"", "\n", "lfp", "=", "0", "\n", "for", "idx", "in", "range", "(", "1", ",", "self", ".", "n_pred", "[", "class_idx", "]", "+", "1", ")", ":", "\n", "            ", "data_pred_idx", "=", "(", "self", ".", "data_pred_label", "[", "...", ",", "class_idx", "]", "==", "idx", ")", ".", "astype", "(", "int", ")", "\n", "overlap", "=", "(", "data_pred_idx", "*", "self", ".", "data_gt", ")", ".", "astype", "(", "int", ")", "\n", "\n", "label_gt", "=", "np", ".", "max", "(", "data_pred_idx", "*", "self", ".", "data_gt_label", "[", "...", ",", "class_idx", "]", ")", "\n", "data_gt_idx", "=", "(", "self", ".", "data_gt_label", "[", "...", ",", "class_idx", "]", "==", "label_gt", ")", ".", "astype", "(", "int", ")", "\n", "# if label_size is None, then we look at all object sizes", "\n", "# we check if the current object belongs to the current size range", "\n", "\n", "if", "label_size", "is", "None", "or", "np", ".", "max", "(", "self", ".", "data_pred_per_size", "[", "...", ",", "class_idx", "]", "[", "np", ".", "nonzero", "(", "data_gt_idx", ")", "]", ")", "==", "label_size", ":", "\n", "\n", "                ", "if", "self", ".", "overlap_vox", "is", "None", ":", "\n", "                    ", "overlap_thr", "=", "np", ".", "round", "(", "np", ".", "count_nonzero", "(", "data_gt_idx", ")", "*", "self", ".", "overlap_ratio", ")", "\n", "", "else", ":", "\n", "                    ", "overlap_thr", "=", "self", ".", "overlap_vox", "\n", "\n", "", "if", "np", ".", "count_nonzero", "(", "overlap", ")", "<", "overlap_thr", ":", "\n", "                    ", "lfp", "+=", "1", "\n", "if", "label_size", "is", "None", ":", "# painting is done while considering all objects", "\n", "                        ", "self", ".", "data_painted", "[", "...", ",", "class_idx", "]", "[", "self", ".", "data_pred_label", "[", "...", ",", "class_idx", "]", "==", "idx", "]", "=", "FP_COLOUR", "\n", "", "", "else", ":", "\n", "                    ", "if", "label_size", "is", "None", ":", "# painting is done while considering all objects", "\n", "                        ", "self", ".", "data_painted", "[", "...", ",", "class_idx", "]", "[", "self", ".", "data_pred_label", "[", "...", ",", "class_idx", "]", "==", "idx", "]", "=", "TP_COLOUR", "\n", "\n", "", "", "", "", "return", "lfp", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_ltpr": [[385, 401], ["evaluation.Evaluation3DMetrics._get_ltp_lfn"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_ltp_lfn"], ["", "def", "get_ltpr", "(", "self", ",", "label_size", "=", "None", ",", "class_idx", "=", "0", ")", ":", "\n", "        ", "\"\"\"Lesion True Positive Rate / Recall / Sensitivity.\n\n        Args:\n            label_size (int): Size of label.\n            class_idx (int): Label index. If monolabel 0, else ranges from 0 to number of output channels - 1.\n\n        Note: computed only if n_obj >= 1.\n        \"\"\"", "\n", "ltp", ",", "lfn", ",", "n_obj", "=", "self", ".", "_get_ltp_lfn", "(", "label_size", ",", "class_idx", ")", "\n", "\n", "denom", "=", "ltp", "+", "lfn", "\n", "if", "denom", "==", "0", "or", "n_obj", "==", "0", ":", "\n", "            ", "return", "np", ".", "nan", ",", "n_obj", "\n", "\n", "", "return", "ltp", "/", "denom", ",", "n_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_lfdr": [[402, 419], ["evaluation.Evaluation3DMetrics._get_ltp_lfn", "evaluation.Evaluation3DMetrics._get_lfp"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_ltp_lfn", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics._get_lfp"], ["", "def", "get_lfdr", "(", "self", ",", "label_size", "=", "None", ",", "class_idx", "=", "0", ")", ":", "\n", "        ", "\"\"\"Lesion False Detection Rate / 1 - Precision.\n\n        Args:\n            label_size (int): Size of label.\n            class_idx (int): Label index. If monolabel 0, else ranges from 0 to number of output channels - 1.\n\n        Note: computed only if n_obj >= 1.\n        \"\"\"", "\n", "ltp", ",", "_", ",", "n_obj", "=", "self", ".", "_get_ltp_lfn", "(", "label_size", ",", "class_idx", ")", "\n", "lfp", "=", "self", ".", "_get_lfp", "(", "label_size", ",", "class_idx", ")", "\n", "\n", "denom", "=", "ltp", "+", "lfp", "\n", "if", "denom", "==", "0", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "\n", "", "return", "lfp", "/", "denom", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.run_eval": [[420, 459], ["evaluation.Evaluation3DMetrics.data_gt.copy", "evaluation.Evaluation3DMetrics.data_pred.copy", "range", "evaluation.Evaluation3DMetrics.get_vol", "evaluation.Evaluation3DMetrics.get_vol", "ivadomed.metrics.dice_score", "ivadomed.metrics.recall_score", "ivadomed.metrics.precision_score", "ivadomed.metrics.specificity_score", "evaluation.Evaluation3DMetrics.get_ltpr", "evaluation.Evaluation3DMetrics.get_lfdr", "ivadomed.metrics.mse", "zip", "numpy.squeeze", "evaluation.Evaluation3DMetrics.get_rvd", "evaluation.Evaluation3DMetrics.get_avd", "evaluation.Evaluation3DMetrics.get_ltpr", "evaluation.Evaluation3DMetrics.get_lfdr", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "int", "str", "str"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_vol", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_vol", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.dice_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.recall_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.precision_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.specificity_score", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_ltpr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_lfdr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.metrics.mse", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_rvd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_avd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_ltpr", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.get_lfdr"], ["", "def", "run_eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stores evaluation results in dictionary\n\n        Returns:\n            dict, ndarray: dictionary containing evaluation results, data with each object painted a different color\n        \"\"\"", "\n", "dct", "=", "{", "}", "\n", "data_gt", "=", "self", ".", "data_gt", ".", "copy", "(", ")", "\n", "data_pred", "=", "self", ".", "data_pred", ".", "copy", "(", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "n_classes", ")", ":", "\n", "            ", "self", ".", "data_pred", "=", "data_pred", "[", "...", ",", "n", "]", "\n", "self", ".", "data_gt", "=", "data_gt", "[", "...", ",", "n", "]", "\n", "dct", "[", "'vol_pred_class'", "+", "str", "(", "n", ")", "]", "=", "self", ".", "get_vol", "(", "self", ".", "data_pred", ")", "\n", "dct", "[", "'vol_gt_class'", "+", "str", "(", "n", ")", "]", "=", "self", ".", "get_vol", "(", "self", ".", "data_gt", ")", "\n", "dct", "[", "'rvd_class'", "+", "str", "(", "n", ")", "]", ",", "dct", "[", "'avd_class'", "+", "str", "(", "n", ")", "]", "=", "self", ".", "get_rvd", "(", ")", ",", "self", ".", "get_avd", "(", ")", "\n", "dct", "[", "'dice_class'", "+", "str", "(", "n", ")", "]", "=", "imed_metrics", ".", "dice_score", "(", "self", ".", "data_gt", ",", "self", ".", "data_pred", ")", "\n", "dct", "[", "'recall_class'", "+", "str", "(", "n", ")", "]", "=", "imed_metrics", ".", "recall_score", "(", "self", ".", "data_pred", ",", "self", ".", "data_gt", ",", "err_value", "=", "np", ".", "nan", ")", "\n", "dct", "[", "'precision_class'", "+", "str", "(", "n", ")", "]", "=", "imed_metrics", ".", "precision_score", "(", "self", ".", "data_pred", ",", "self", ".", "data_gt", ",", "\n", "err_value", "=", "np", ".", "nan", ")", "\n", "dct", "[", "'specificity_class'", "+", "str", "(", "n", ")", "]", "=", "imed_metrics", ".", "specificity_score", "(", "self", ".", "data_pred", ",", "self", ".", "data_gt", ",", "\n", "err_value", "=", "np", ".", "nan", ")", "\n", "dct", "[", "'n_pred_class'", "+", "str", "(", "n", ")", "]", ",", "dct", "[", "'n_gt_class'", "+", "str", "(", "n", ")", "]", "=", "self", ".", "n_pred", "[", "n", "]", ",", "self", ".", "n_gt", "[", "n", "]", "\n", "dct", "[", "'ltpr_class'", "+", "str", "(", "n", ")", "]", ",", "_", "=", "self", ".", "get_ltpr", "(", "class_idx", "=", "n", ")", "\n", "dct", "[", "'lfdr_class'", "+", "str", "(", "n", ")", "]", "=", "self", ".", "get_lfdr", "(", "class_idx", "=", "n", ")", "\n", "dct", "[", "'mse_class'", "+", "str", "(", "n", ")", "]", "=", "imed_metrics", ".", "mse", "(", "self", ".", "data_gt", ",", "self", ".", "data_pred", ")", "\n", "\n", "for", "lb_size", ",", "gt_pred", "in", "zip", "(", "self", ".", "label_size_lst", "[", "n", "]", "[", "0", "]", ",", "self", ".", "label_size_lst", "[", "n", "]", "[", "1", "]", ")", ":", "\n", "                ", "suffix", "=", "self", ".", "size_suffix_lst", "[", "int", "(", "lb_size", ")", "-", "1", "]", "\n", "\n", "if", "gt_pred", "==", "'gt'", ":", "\n", "                    ", "dct", "[", "'ltpr'", "+", "suffix", "+", "\"_class\"", "+", "str", "(", "n", ")", "]", ",", "dct", "[", "'n'", "+", "suffix", "]", "=", "self", ".", "get_ltpr", "(", "label_size", "=", "lb_size", ",", "\n", "class_idx", "=", "n", ")", "\n", "", "else", ":", "# gt_pred == 'pred'", "\n", "                    ", "dct", "[", "'lfdr'", "+", "suffix", "+", "\"_class\"", "+", "str", "(", "n", ")", "]", "=", "self", ".", "get_lfdr", "(", "label_size", "=", "lb_size", ",", "class_idx", "=", "n", ")", "\n", "\n", "", "", "", "if", "self", ".", "n_classes", "==", "1", ":", "\n", "            ", "self", ".", "data_painted", "=", "np", ".", "squeeze", "(", "self", ".", "data_painted", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "return", "dct", ",", "self", ".", "data_painted", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.evaluate": [[20, 117], ["pathlib.Path", "loguru.logger.info", "pathlib.Path", "pandas.DataFrame", "bids_df.get_deriv_fnames", "tqdm.tqdm", "df_results.append.set_index", "df_results.append.to_csv", "loguru.logger.info", "pathlib.Path.is_dir", "pathlib.Path.mkdir", "pathlib.Path.joinpath", "[].to_list", "ivadomed.loader.utils.get_file_extension", "nibabel.load", "nib.load.get_fdata", "len", "numpy.zeros", "enumerate", "evaluation.Evaluation3DMetrics", "evaluation.Evaluation3DMetrics.run_eval", "nibabel.Nifti1Image", "nibabel.save", "df_results.append.append", "str", "df_results.append.head", "f.name.split", "pathlib.Path.iterdir", "f.name.endswith", "len", "enumerate", "ivadomed.loader.utils.update_filename_to_nifti", "pathlib.Path().exists", "ivadomed.inference.split_classes", "ivadomed.inference.pred_to_png", "pathlib.Path.joinpath", "nibabel.load().get_fdata", "numpy.zeros", "str().split", "nib.load.header.get_best_affine", "nib.load.header.copy", "str", "pathlib.Path", "range", "pathlib.Path.joinpath", "nibabel.load", "str", "len", "bids_df.df[].str.contains", "bids_df.get_derivatives"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_deriv_fnames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.evaluation.Evaluation3DMetrics.run_eval", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.split_classes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.pred_to_png", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_derivatives"], ["def", "evaluate", "(", "bids_df", ",", "path_output", ",", "target_suffix", ",", "eval_params", ")", ":", "\n", "    ", "\"\"\"Evaluate predictions from inference step.\n\n    Args:\n        bids_df (BidsDataframe): Object containing dataframe with all BIDS image files and their metadata.\n        path_output (str): Folder where the output folder \"results_eval\" is be created.\n        target_suffix (list): List of suffixes that indicates the target mask(s).\n        eval_params (dict): Evaluation parameters.\n\n    Returns:\n        pd.Dataframe: results for each image.\n    \"\"\"", "\n", "path_preds", "=", "Path", "(", "path_output", ",", "'pred_masks'", ")", "\n", "logger", ".", "info", "(", "'\\nRun Evaluation on {}\\n'", ".", "format", "(", "path_preds", ")", ")", "\n", "\n", "# OUTPUT RESULT FOLDER", "\n", "path_results", "=", "Path", "(", "path_output", ",", "'results_eval'", ")", "\n", "if", "not", "path_results", ".", "is_dir", "(", ")", ":", "\n", "        ", "path_results", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# INIT DATA FRAME", "\n", "", "df_results", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "# LIST PREDS", "\n", "subj_acq_lst", "=", "[", "f", ".", "name", ".", "split", "(", "'_pred'", ")", "[", "0", "]", "for", "f", "in", "path_preds", ".", "iterdir", "(", ")", "if", "f", ".", "name", ".", "endswith", "(", "'_pred.nii.gz'", ")", "]", "\n", "\n", "# Get all derivatives filenames", "\n", "all_deriv", "=", "bids_df", ".", "get_deriv_fnames", "(", ")", "\n", "\n", "# LOOP ACROSS PREDS", "\n", "for", "subj_acq", "in", "tqdm", "(", "subj_acq_lst", ",", "desc", "=", "\"Evaluation\"", ")", ":", "\n", "# Fnames of pred and ground-truth", "\n", "        ", "fname_pred", "=", "path_preds", ".", "joinpath", "(", "subj_acq", "+", "'_pred.nii.gz'", ")", "\n", "derivatives", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "\n", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "bids_df", ".", "get_derivatives", "(", "subj_acq", ",", "all_deriv", ")", ")", ")", "]", "[", "'path'", "]", ".", "to_list", "(", ")", "\n", "# Ordering ground-truth the same as target_suffix", "\n", "fname_gt", "=", "[", "None", "]", "*", "len", "(", "target_suffix", ")", "\n", "for", "deriv", "in", "derivatives", ":", "\n", "            ", "for", "idx", ",", "suffix", "in", "enumerate", "(", "target_suffix", ")", ":", "\n", "                ", "if", "suffix", "in", "deriv", ":", "\n", "                    ", "fname_gt", "[", "idx", "]", "=", "deriv", "\n", "\n", "# Get filename extension of first ground-truth before updating path to NifTI", "\n", "", "", "", "extension", "=", "imed_loader_utils", ".", "get_file_extension", "(", "fname_gt", "[", "0", "]", ")", "\n", "\n", "# Check fname_gt extentions and update paths if not NifTI", "\n", "fname_gt", "=", "[", "imed_loader_utils", ".", "update_filename_to_nifti", "(", "fname", ")", "for", "fname", "in", "fname_gt", "]", "\n", "\n", "# Uncertainty", "\n", "data_uncertainty", "=", "None", "\n", "\n", "# 3D evaluation", "\n", "nib_pred", "=", "nib", ".", "load", "(", "fname_pred", ")", "\n", "data_pred", "=", "nib_pred", ".", "get_fdata", "(", ")", "\n", "\n", "h", ",", "w", ",", "d", "=", "data_pred", ".", "shape", "[", ":", "3", "]", "\n", "n_classes", "=", "len", "(", "fname_gt", ")", "\n", "data_gt", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "d", ",", "n_classes", ")", ")", "\n", "for", "idx", ",", "file", "in", "enumerate", "(", "fname_gt", ")", ":", "\n", "            ", "if", "Path", "(", "file", ")", ".", "exists", "(", ")", ":", "\n", "                ", "data_gt", "[", "...", ",", "idx", "]", "=", "nib", ".", "load", "(", "file", ")", ".", "get_fdata", "(", ")", "\n", "", "else", ":", "\n", "                ", "data_gt", "[", "...", ",", "idx", "]", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "d", ")", ",", "dtype", "=", "'u1'", ")", "\n", "", "", "eval", "=", "Evaluation3DMetrics", "(", "data_pred", "=", "data_pred", ",", "\n", "data_gt", "=", "data_gt", ",", "\n", "dim_lst", "=", "nib_pred", ".", "header", "[", "'pixdim'", "]", "[", "1", ":", "4", "]", ",", "\n", "params", "=", "eval_params", ")", "\n", "results_pred", ",", "data_painted", "=", "eval", ".", "run_eval", "(", ")", "\n", "\n", "# SAVE PAINTED DATA, TP FP FN", "\n", "fname_paint", "=", "str", "(", "fname_pred", ")", ".", "split", "(", "'.nii.gz'", ")", "[", "0", "]", "+", "'_painted.nii.gz'", "\n", "nib_painted", "=", "nib", ".", "Nifti1Image", "(", "\n", "dataobj", "=", "data_painted", ",", "\n", "affine", "=", "nib_pred", ".", "header", ".", "get_best_affine", "(", ")", ",", "\n", "header", "=", "nib_pred", ".", "header", ".", "copy", "(", ")", "\n", ")", "\n", "nib", ".", "save", "(", "nib_painted", ",", "fname_paint", ")", "\n", "\n", "# For Microscopy PNG/TIF files (TODO: implement OMETIFF behavior)", "\n", "if", "\"nii\"", "not", "in", "extension", ":", "\n", "            ", "painted_list", "=", "imed_inference", ".", "split_classes", "(", "nib_painted", ")", "\n", "# Reformat target list to include class index and be compatible with multiple raters", "\n", "target_list", "=", "[", "\"_class-%d\"", "%", "i", "for", "i", "in", "range", "(", "len", "(", "target_suffix", ")", ")", "]", "\n", "imed_inference", ".", "pred_to_png", "(", "painted_list", ",", "\n", "target_list", ",", "\n", "str", "(", "path_preds", ".", "joinpath", "(", "subj_acq", ")", ")", ",", "\n", "suffix", "=", "\"_pred_painted.png\"", ")", "\n", "\n", "# SAVE RESULTS FOR THIS PRED", "\n", "", "results_pred", "[", "'image_id'", "]", "=", "subj_acq", "\n", "df_results", "=", "df_results", ".", "append", "(", "results_pred", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "df_results", "=", "df_results", ".", "set_index", "(", "'image_id'", ")", "\n", "df_results", ".", "to_csv", "(", "str", "(", "path_results", ".", "joinpath", "(", "'evaluation_3Dmetrics.csv'", ")", ")", ")", "\n", "\n", "logger", ".", "info", "(", "df_results", ".", "head", "(", "5", ")", ")", "\n", "return", "df_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.MultiClassDiceLoss.__init__": [[23, 27], ["torch.Module.__init__", "losses.DiceLoss"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "classes_of_interest", "=", "None", ")", ":", "\n", "        ", "super", "(", "MultiClassDiceLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "classes_of_interest", "=", "classes_of_interest", "\n", "self", ".", "dice_loss", "=", "DiceLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.MultiClassDiceLoss.forward": [[28, 39], ["range", "losses.MultiClassDiceLoss.dice_loss", "len"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "prediction", ",", "target", ")", ":", "\n", "        ", "dice_per_class", "=", "0", "\n", "n_classes", "=", "prediction", ".", "shape", "[", "1", "]", "\n", "\n", "if", "self", ".", "classes_of_interest", "is", "None", ":", "\n", "            ", "self", ".", "classes_of_interest", "=", "range", "(", "n_classes", ")", "\n", "\n", "", "for", "i", "in", "self", ".", "classes_of_interest", ":", "\n", "            ", "dice_per_class", "+=", "self", ".", "dice_loss", "(", "prediction", "[", ":", ",", "i", ",", "]", ",", "target", "[", ":", ",", "i", ",", "]", ")", "\n", "\n", "", "return", "dice_per_class", "/", "len", "(", "self", ".", "classes_of_interest", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.DiceLoss.__init__": [[54, 57], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "smooth", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "DiceLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "smooth", "=", "smooth", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.DiceLoss.forward": [[58, 64], ["prediction.reshape", "target.reshape", "prediction.reshape.sum", "target.reshape.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "prediction", ",", "target", ")", ":", "\n", "        ", "iflat", "=", "prediction", ".", "reshape", "(", "-", "1", ")", "\n", "tflat", "=", "target", ".", "reshape", "(", "-", "1", ")", "\n", "intersection", "=", "(", "iflat", "*", "tflat", ")", ".", "sum", "(", ")", "\n", "\n", "return", "-", "(", "2.0", "*", "intersection", "+", "self", ".", "smooth", ")", "/", "(", "iflat", ".", "sum", "(", ")", "+", "tflat", ".", "sum", "(", ")", "+", "self", ".", "smooth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.BinaryCrossEntropyLoss.__init__": [[73, 76], ["torch.Module.__init__", "torch.BCELoss", "torch.BCELoss"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "BinaryCrossEntropyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loss_fct", "=", "nn", ".", "BCELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.BinaryCrossEntropyLoss.forward": [[77, 79], ["losses.BinaryCrossEntropyLoss.loss_fct", "target.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "prediction", ",", "target", ")", ":", "\n", "        ", "return", "self", ".", "loss_fct", "(", "prediction", ",", "target", ".", "float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalLoss.__init__": [[102, 107], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "gamma", "=", "2", ",", "alpha", "=", "0.25", ",", "eps", "=", "1e-7", ")", ":", "\n", "        ", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalLoss.forward": [[108, 121], ["input.clamp.clamp.clamp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "focal_loss.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "input", "=", "input", ".", "clamp", "(", "self", ".", "eps", ",", "1.", "-", "self", ".", "eps", ")", "\n", "\n", "cross_entropy", "=", "-", "(", "target", "*", "torch", ".", "log", "(", "input", ")", "+", "(", "1", "-", "target", ")", "*", "torch", ".", "log", "(", "1", "-", "input", ")", ")", "# eq1", "\n", "logpt", "=", "-", "cross_entropy", "\n", "pt", "=", "torch", ".", "exp", "(", "logpt", ")", "# eq2", "\n", "\n", "at", "=", "self", ".", "alpha", "*", "target", "+", "(", "1", "-", "self", ".", "alpha", ")", "*", "(", "1", "-", "target", ")", "\n", "balanced_cross_entropy", "=", "-", "at", "*", "logpt", "# eq3", "\n", "\n", "focal_loss", "=", "balanced_cross_entropy", "*", "(", "(", "1", "-", "pt", ")", "**", "self", ".", "gamma", ")", "# eq5", "\n", "\n", "return", "focal_loss", ".", "sum", "(", ")", "\n", "# return focal_loss.mean()", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalDiceLoss.__init__": [[146, 151], ["torch.Module.__init__", "losses.FocalLoss", "losses.DiceLoss"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "beta", "=", "1", ",", "gamma", "=", "2", ",", "alpha", "=", "0.25", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "focal", "=", "FocalLoss", "(", "gamma", ",", "alpha", ")", "\n", "self", ".", "dice", "=", "DiceLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalDiceLoss.forward": [[152, 167], ["losses.FocalDiceLoss.focal", "losses.FocalDiceLoss.dice", "torch.log", "torch.log", "torch.log", "torch.log", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.log", "torch.log", "torch.log", "torch.log", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "dc_loss", "=", "-", "self", ".", "dice", "(", "input", ",", "target", ")", "\n", "fc_loss", "=", "self", ".", "focal", "(", "input", ",", "target", ")", "\n", "\n", "# used to fine tune beta", "\n", "# with torch.no_grad():", "\n", "#     print('DICE loss:', dc_loss.cpu().numpy(), 'Focal loss:', fc_loss.cpu().numpy())", "\n", "#     log_dc_loss = torch.log(torch.clamp(dc_loss, 1e-7))", "\n", "#     log_fc_loss = torch.log(torch.clamp(fc_loss, 1e-7))", "\n", "#     print('Log DICE loss:', log_dc_loss.cpu().numpy(), 'Log Focal loss:', log_fc_loss.cpu().numpy())", "\n", "#     print('*'*20)", "\n", "\n", "loss", "=", "torch", ".", "log", "(", "torch", ".", "clamp", "(", "fc_loss", ",", "1e-7", ")", ")", "-", "self", ".", "beta", "*", "torch", ".", "log", "(", "torch", ".", "clamp", "(", "dc_loss", ",", "1e-7", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.GeneralizedDiceLoss.__init__": [[186, 190], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "epsilon", "=", "1e-5", ",", "include_background", "=", "True", ")", ":", "\n", "        ", "super", "(", "GeneralizedDiceLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "include_background", "=", "include_background", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.GeneralizedDiceLoss.forward": [[191, 219], ["torch.cat.float", "torch.cat.float", "tuple", "torch.cat.sum", "torch.cat.sum", "torch.Parameter", "torch.Parameter", "ValueError", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "denominator.clamp", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "len", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "list", "torch.zeros.to", "torch.zeros.to", "torch.zeros.to", "torch.zeros.to", "torch.cat.size", "torch.cat.size", "torch.cat.sum", "torch.cat.sum", "torch.cat.sum", "torch.cat.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "if", "not", "(", "target", ".", "size", "(", ")", "==", "input", ".", "size", "(", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Target size ({}) must be the same as input size ({})\"", ".", "format", "(", "target", ".", "size", "(", ")", ",", "input", ".", "size", "(", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "include_background", ":", "\n", "# init", "\n", "            ", "size_background", "=", "[", "input", ".", "size", "(", "0", ")", ",", "1", "]", "+", "list", "(", "input", ".", "size", "(", ")", ")", "[", "2", ":", "]", "\n", "input_background", "=", "torch", ".", "zeros", "(", "size_background", ",", "dtype", "=", "input", ".", "dtype", ")", "\n", "target_background", "=", "torch", ".", "zeros", "(", "size_background", ",", "dtype", "=", "target", ".", "dtype", ")", "\n", "# fill with opposite", "\n", "input_background", "[", "input", ".", "sum", "(", "1", ")", "[", ":", ",", "None", ",", ":", ",", ":", "]", "==", "0", "]", "=", "1", "\n", "target_background", "[", "target", ".", "sum", "(", "1", ")", "[", ":", ",", "None", ",", ":", ",", ":", "]", "==", "0", "]", "=", "1", "\n", "# Concat", "\n", "input", "=", "torch", ".", "cat", "(", "[", "input", ",", "input_background", ".", "to", "(", "input", ".", "device", ")", "]", ",", "dim", "=", "1", ")", "\n", "target", "=", "torch", ".", "cat", "(", "[", "target", ",", "target_background", ".", "to", "(", "target", ".", "device", ")", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# Compute class weights", "\n", "", "target", "=", "target", ".", "float", "(", ")", "\n", "axes_to_sum", "=", "tuple", "(", "range", "(", "2", ",", "len", "(", "target", ".", "shape", ")", ")", ")", "\n", "target_sum", "=", "target", ".", "sum", "(", "axis", "=", "axes_to_sum", ")", "\n", "class_weights", "=", "nn", ".", "Parameter", "(", "1.", "/", "(", "target_sum", "*", "target_sum", ")", ".", "clamp", "(", "min", "=", "self", ".", "epsilon", ")", ")", "\n", "# W Intersection", "\n", "intersect", "=", "(", "(", "input", "*", "target", ")", ".", "sum", "(", "axis", "=", "axes_to_sum", ")", "*", "class_weights", ")", ".", "sum", "(", ")", "\n", "\n", "# W Union", "\n", "denominator", "=", "(", "(", "input", "+", "target", ")", ".", "sum", "(", "axis", "=", "axes_to_sum", ")", "*", "class_weights", ")", ".", "sum", "(", ")", "\n", "\n", "return", "-", "2.", "*", "intersect", "/", "denominator", ".", "clamp", "(", "min", "=", "self", ".", "epsilon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.TverskyLoss.__init__": [[244, 249], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ",", "smooth", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "TverskyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "smooth", "=", "smooth", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.TverskyLoss.tversky_index": [[250, 272], ["y_true.float.float.float", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "tversky_index", "(", "self", ",", "y_pred", ",", "y_true", ")", ":", "\n", "        ", "\"\"\"Compute Tversky index.\n\n        Args:\n            y_pred (torch Tensor): Prediction.\n            y_true (torch Tensor): Target.\n\n        Returns:\n            float: Tversky index.\n        \"\"\"", "\n", "# Compute TP", "\n", "y_true", "=", "y_true", ".", "float", "(", ")", "\n", "tp", "=", "torch", ".", "sum", "(", "y_true", "*", "y_pred", ")", "\n", "# Compute FN", "\n", "fn", "=", "torch", ".", "sum", "(", "y_true", "*", "(", "1", "-", "y_pred", ")", ")", "\n", "# Compute FP", "\n", "fp", "=", "torch", ".", "sum", "(", "(", "1", "-", "y_true", ")", "*", "y_pred", ")", "\n", "# Compute Tversky for the current class, see Equation 3 of the original paper", "\n", "numerator", "=", "tp", "+", "self", ".", "smooth", "\n", "denominator", "=", "tp", "+", "self", ".", "alpha", "*", "fp", "+", "self", ".", "beta", "*", "fn", "+", "self", ".", "smooth", "\n", "tversky_label", "=", "numerator", "/", "denominator", "\n", "return", "tversky_label", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.TverskyLoss.forward": [[273, 285], ["range", "losses.TverskyLoss.tversky_index"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.TverskyLoss.tversky_index"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "n_classes", "=", "input", ".", "shape", "[", "1", "]", "\n", "tversky_sum", "=", "0.", "\n", "\n", "# TODO: Add class_of_interest?", "\n", "for", "i_label", "in", "range", "(", "n_classes", ")", ":", "\n", "# Get samples for a given class", "\n", "            ", "y_pred", ",", "y_true", "=", "input", "[", ":", ",", "i_label", ",", "]", ",", "target", "[", ":", ",", "i_label", ",", "]", "\n", "# Compute Tversky index", "\n", "tversky_sum", "+=", "self", ".", "tversky_index", "(", "y_pred", ",", "y_true", ")", "\n", "\n", "", "return", "-", "tversky_sum", "/", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalTverskyLoss.__init__": [[308, 312], ["losses.TverskyLoss.__init__", "losses.TverskyLoss"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "alpha", "=", "0.7", ",", "beta", "=", "0.3", ",", "gamma", "=", "1.33", ",", "smooth", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "FocalTverskyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "tversky", "=", "TverskyLoss", "(", "alpha", "=", "alpha", ",", "beta", "=", "beta", ",", "smooth", "=", "smooth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.FocalTverskyLoss.forward": [[313, 327], ["range", "losses.FocalTverskyLoss.tversky.tversky_index", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.TverskyLoss.tversky_index"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "n_classes", "=", "input", ".", "shape", "[", "1", "]", "\n", "focal_tversky_sum", "=", "0.", "\n", "\n", "# TODO: Add class_of_interest?", "\n", "for", "i_label", "in", "range", "(", "n_classes", ")", ":", "\n", "# Get samples for a given class", "\n", "            ", "y_pred", ",", "y_true", "=", "input", "[", ":", ",", "i_label", ",", "]", ",", "target", "[", ":", ",", "i_label", ",", "]", "\n", "# Compute Tversky index", "\n", "tversky_index", "=", "self", ".", "tversky", ".", "tversky_index", "(", "y_pred", ",", "y_true", ")", "\n", "# Compute Focal Tversky loss, Equation 4 in the original paper", "\n", "focal_tversky_sum", "+=", "torch", ".", "pow", "(", "1", "-", "tversky_index", ",", "exponent", "=", "1", "/", "self", ".", "gamma", ")", "\n", "\n", "", "return", "focal_tversky_sum", "/", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.L2loss.__init__": [[334, 336], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "L2loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.L2loss.forward": [[337, 339], ["torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "return", "torch", ".", "sum", "(", "(", "input", "-", "target", ")", "**", "2", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.AdapWingLoss.__init__": [[358, 364], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "theta", "=", "0.5", ",", "alpha", "=", "2.1", ",", "omega", "=", "14", ",", "epsilon", "=", "1", ")", ":", "\n", "        ", "self", ".", "theta", "=", "theta", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "omega", "=", "omega", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "super", "(", "AdapWingLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.AdapWingLoss.forward": [[365, 407], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "range", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "target.size", "target.size", "len", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "scipy.ndimage.generate_binary_structure", "list", "list.append", "numpy.concatenate", "scipy.ndimage.binary_opening", "scipy.ndimage.binary_opening", "scipy.ndimage.binary_opening", "scipy.ndimage.binary_opening", "numpy.array", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.log", "torch.log", "torch.log", "torch.log", "numpy.round", "numpy.expand_dims", "torch.log", "torch.log", "torch.log", "torch.log", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "target[].cpu().numpy", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "target[].cpu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "eps", "=", "self", ".", "epsilon", "\n", "# Compute adaptative factor", "\n", "A", "=", "self", ".", "omega", "*", "(", "1", "/", "(", "1", "+", "torch", ".", "pow", "(", "self", ".", "theta", "/", "eps", ",", "\n", "self", ".", "alpha", "-", "target", ")", ")", ")", "*", "(", "self", ".", "alpha", "-", "target", ")", "*", "torch", ".", "pow", "(", "self", ".", "theta", "/", "eps", ",", "\n", "self", ".", "alpha", "-", "target", "-", "1", ")", "*", "(", "1", "/", "eps", ")", "\n", "\n", "# Constant term to link linear and non linear part", "\n", "C", "=", "(", "self", ".", "theta", "*", "A", "-", "self", ".", "omega", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "pow", "(", "self", ".", "theta", "/", "eps", ",", "self", ".", "alpha", "-", "target", ")", ")", ")", "\n", "\n", "batch_size", "=", "target", ".", "size", "(", ")", "[", "0", "]", "\n", "hm_num", "=", "target", ".", "size", "(", ")", "[", "1", "]", "\n", "\n", "mask", "=", "torch", ".", "zeros_like", "(", "target", ")", "\n", "kernel", "=", "scipy", ".", "ndimage", ".", "generate_binary_structure", "(", "2", ",", "2", ")", "\n", "# For 3D segmentation tasks", "\n", "if", "len", "(", "input", ".", "shape", ")", "==", "5", ":", "\n", "            ", "kernel", "=", "scipy", ".", "ndimage", ".", "generate_binary_structure", "(", "3", ",", "2", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "img_list", "=", "list", "(", ")", "\n", "img_list", ".", "append", "(", "np", ".", "round", "(", "target", "[", "i", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "255", ")", ")", "\n", "img_merge", "=", "np", ".", "concatenate", "(", "img_list", ")", "\n", "img_dilate", "=", "scipy", ".", "ndimage", ".", "binary_opening", "(", "img_merge", ",", "np", ".", "expand_dims", "(", "kernel", ",", "axis", "=", "0", ")", ")", "\n", "img_dilate", "[", "img_dilate", "<", "51", "]", "=", "1", "# 0*omega+1", "\n", "img_dilate", "[", "img_dilate", ">=", "51", "]", "=", "1", "+", "self", ".", "omega", "# 1*omega+1", "\n", "img_dilate", "=", "np", ".", "array", "(", "img_dilate", ",", "dtype", "=", "int", ")", "\n", "\n", "mask", "[", "i", "]", "=", "torch", ".", "tensor", "(", "img_dilate", ")", "\n", "\n", "", "diff_hm", "=", "torch", ".", "abs", "(", "target", "-", "input", ")", "\n", "AWingLoss", "=", "A", "*", "diff_hm", "-", "C", "\n", "idx", "=", "diff_hm", "<", "self", ".", "theta", "\n", "AWingLoss", "[", "idx", "]", "=", "self", ".", "omega", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "pow", "(", "diff_hm", "/", "eps", ",", "self", ".", "alpha", "-", "target", ")", ")", "[", "idx", "]", "\n", "\n", "AWingLoss", "*=", "mask", "\n", "sum_loss", "=", "torch", ".", "sum", "(", "AWingLoss", ")", "\n", "all_pixel", "=", "torch", ".", "sum", "(", "mask", ")", "\n", "mean_loss", "=", "sum_loss", "# / all_pixel", "\n", "\n", "return", "mean_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.__init__": [[424, 428], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "losses_list", ",", "params_list", "=", "None", ")", ":", "\n", "        ", "self", ".", "losses_list", "=", "losses_list", "\n", "self", ".", "params_list", "=", "params_list", "\n", "super", "(", "LossCombination", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.losses.LossCombination.forward": [[429, 443], ["range", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "len", "eval", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "output.append", "output.append", "eval.", "eval.", "eval.unsqueeze", "eval.", "eval."], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "output", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "losses_list", ")", ")", ":", "\n", "            ", "loss_class", "=", "eval", "(", "self", ".", "losses_list", "[", "i", "]", ")", "\n", "if", "self", ".", "params_list", "is", "not", "None", ":", "\n", "                ", "if", "self", ".", "params_list", "[", "i", "]", "is", "not", "None", ":", "\n", "                    ", "loss_fct", "=", "loss_class", "(", "**", "self", ".", "params_list", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                    ", "loss_fct", "=", "loss_class", "(", ")", "\n", "", "output", ".", "append", "(", "loss_fct", "(", "input", ",", "target", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "else", ":", "\n", "                ", "output", ".", "append", "(", "loss_class", "(", ")", "(", "input", ",", "target", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "", "", "return", "torch", ".", "sum", "(", "torch", ".", "cat", "(", "output", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.get_bounding_boxes": [[16, 40], ["scipy.ndimage.label", "numpy.unique", "numpy.where", "range", "bounding_boxes.append", "len", "dimensions.append", "dimensions.append", "int", "int", "coords[].min", "coords[].max"], "function", ["None"], ["\n", "AXIS_DCT", "=", "{", "'sagittal'", ":", "0", ",", "'coronal'", ":", "1", ",", "'axial'", ":", "2", "}", "\n", "\n", "# List of classification models (ie not segmentation output)", "\n", "CLASSIFIER_LIST", "=", "[", "'resnet18'", ",", "'densenet121'", "]", "\n", "\n", "\n", "class", "Metavar", "(", "Enum", ")", ":", "\n", "    ", "\"\"\"This class is used to display intuitive input types via the metavar field of argparse.\"\"\"", "\n", "\n", "file", "=", "\"<file>\"", "\n", "str", "=", "\"<str>\"", "\n", "folder", "=", "\"<folder>\"", "\n", "int", "=", "\"<int>\"", "\n", "list", "=", "\"<list>\"", "\n", "float", "=", "\"<float>\"", "\n", "\n", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "value", "\n", "\n", "\n", "", "", "def", "initialize_wandb", "(", "wandb_params", ")", ":", "\n", "    ", "try", ":", "\n", "# Log on to WandB (assuming that the API Key is correct)", "\n", "# if not, login would raise an exception for the cases invalid API key and not found", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_bb_size": [[42, 68], ["range", "coord.append", "coord.append", "len", "int", "int", "round", "max"], "function", ["None"], ["\n", "", "except", "Exception", "as", "e", ":", "\n", "# log error mssg for unsuccessful wandb authentication", "\n", "        ", "if", "wandb_params", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "\"Incorrect WandB API Key! Please re-check the entered API key.\"", ")", "\n", "logger", ".", "info", "(", "\"Disabling WandB Tracking, continuing with Tensorboard Logging\"", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "\"No WandB parameters found! Continuing with Tensorboard Logging\"", ")", "\n", "\n", "# set flag", "\n", "", "wandb_tracking", "=", "False", "\n", "\n", "", "else", ":", "\n", "# setting flag after successful authentication", "\n", "        ", "logger", ".", "info", "(", "\"WandB API Authentication Successful!\"", ")", "\n", "wandb_tracking", "=", "True", "\n", "\n", "", "return", "wandb_tracking", "\n", "\n", "\n", "", "def", "get_task", "(", "model_name", ")", ":", "\n", "    ", "return", "\"classification\"", "if", "model_name", "in", "CLASSIFIER_LIST", "else", "\"segmentation\"", "\n", "\n", "\n", "", "def", "cuda", "(", "input_var", ",", "cuda_available", "=", "True", ",", "non_blocking", "=", "False", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.resize_to_multiple": [[70, 87], ["zip", "new_dim.append"], "function", ["None"], ["\n", "if", "cuda_available", ":", "\n", "        ", "if", "isinstance", "(", "input_var", ",", "list", ")", ":", "\n", "            ", "return", "[", "t", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "for", "t", "in", "input_var", "]", "\n", "", "else", ":", "\n", "            ", "return", "input_var", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "\n", "", "", "else", ":", "\n", "        ", "return", "input_var", "\n", "\n", "\n", "", "", "def", "unstack_tensors", "(", "sample", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.generate_bounding_box_file": [[89, 132], ["pathlib.Path", "imed_inference.segment_volume", "pathlib.Path", "nibabel.save", "nibabel.as_closest_canonical", "ivadomed.loader.utils.orient_img_hwd", "utils.get_bounding_boxes", "pathlib.Path.open", "json.dump", "ivadomed.postprocessing.keep_largest_object", "pathlib.Path.exists", "pathlib.Path.mkdir", "pathlib.Path", "nib.as_closest_canonical.get_fdata", "utils.adjust_bb_size", "subject_path.split"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.inference.segment_volume", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.get_bounding_boxes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.keep_largest_object", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_bb_size"], ["\n", "list_tensor", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "sample", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "list_tensor", ".", "append", "(", "sample", "[", ":", ",", "i", ",", "]", ".", "unsqueeze", "(", "1", ")", ")", "\n", "", "return", "list_tensor", "\n", "\n", "\n", "", "def", "generate_sha_256", "(", "context", ":", "dict", ",", "df", ",", "file_lst", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "    ", "\"\"\"generate sha256 for a training file\n\n    Args:\n        context (dict): configuration context.\n        df (pd.DataFrame): Dataframe containing all BIDS image files indexed and their metadata.\n        file_lst (List[str]): list of strings containing training files\n    \"\"\"", "\n", "from", "pandas", "import", "DataFrame", "\n", "assert", "isinstance", "(", "df", ",", "DataFrame", ")", "\n", "\n", "# generating sha256 for list of data", "\n", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "=", "{", "}", "\n", "# file_list is a list of filename strings", "\n", "for", "file", "in", "file_lst", ":", "\n", "# bids_df is a dataframe with column values path...filename...", "\n", "# so df_sub is the row with matching filename=file", "\n", "        ", "df_sub", "=", "df", ".", "loc", "[", "df", "[", "'filename'", "]", "==", "file", "]", "\n", "file_path", "=", "df_sub", "[", "'path'", "]", ".", "values", "[", "0", "]", "\n", "sha256_hash", "=", "hashlib", ".", "sha256", "(", ")", "\n", "with", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "for", "byte_block", "in", "iter", "(", "lambda", ":", "f", ".", "read", "(", "4096", ")", ",", "b\"\"", ")", ":", "\n", "                ", "sha256_hash", ".", "update", "(", "byte_block", ")", "\n", "", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "[", "file", "]", "=", "sha256_hash", ".", "hexdigest", "(", ")", "\n", "\n", "\n", "", "", "", "def", "save_onnx_model", "(", "model", ",", "inputs", ",", "model_path", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.resample_bounding_box": [[134, 156], ["enumerate", "utils.adjust_bb_size", "range", "range", "len", "len", "ivadomed.transforms"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_bb_size"], ["\n", "import", "torch", "\n", "model", ".", "eval", "(", ")", "\n", "dynamic_axes", "=", "{", "0", ":", "'batch'", ",", "1", ":", "'num_channels'", ",", "2", ":", "'height'", ",", "3", ":", "'width'", ",", "4", ":", "'depth'", "}", "\n", "if", "len", "(", "inputs", ".", "shape", ")", "==", "4", ":", "\n", "        ", "del", "dynamic_axes", "[", "4", "]", "\n", "", "torch", ".", "onnx", ".", "export", "(", "model", ",", "inputs", ",", "model_path", ",", "\n", "opset_version", "=", "11", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "dynamic_axes", "=", "{", "'input'", ":", "dynamic_axes", ",", "'output'", ":", "dynamic_axes", "}", ")", "\n", "\n", "\n", "", "def", "define_device", "(", "gpu_id", ")", ":", "\n", "    ", "\"\"\"Define the device used for the process of interest.\n\n    Args:\n        gpu_id (int): GPU ID.\n\n    Returns:\n        Bool, device: True if cuda is available.\n    \"\"\"", "\n", "import", "torch", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_transforms": [[158, 202], ["enumerate", "utils.resample_bounding_box", "enumerate", "ivadomed.transforms.Compose", "enumerate", "index_shape.append", "ivadomed.transforms.BoundingBoxCrop", "imed_transforms.Compose.transform[].transforms.insert", "enumerate", "utils.resize_to_multiple", "tuple", "len", "imed_transforms.Compose.transform[].transforms.pop", "set"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.resample_bounding_box", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.resize_to_multiple"], ["cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "if", "not", "cuda_available", ":", "\n", "        ", "logger", ".", "info", "(", "\"Cuda is not available.\"", ")", "\n", "logger", ".", "info", "(", "\"Working on {}.\"", ".", "format", "(", "device", ")", ")", "\n", "", "if", "cuda_available", ":", "\n", "# Set the GPU", "\n", "        ", "gpu_id", "=", "int", "(", "gpu_id", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "gpu_id", ")", "\n", "logger", ".", "info", "(", "f\"Using GPU ID {gpu_id}\"", ")", "\n", "", "return", "cuda_available", ",", "device", "\n", "\n", "\n", "", "def", "display_selected_model_spec", "(", "params", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected model and its parameters.\n\n    Args:\n        params (dict): Keys are param names and values are param values.\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Selected architecture: {}, with the following parameters:'", ".", "format", "(", "params", "[", "\"name\"", "]", ")", ")", "\n", "for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "k", "!=", "\"name\"", ":", "\n", "            ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n", "\n", "", "", "", "def", "display_selected_transfoms", "(", "params", ",", "dataset_type", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected transforms for a given dataset.\n\n    Args:\n        params (dict):\n        dataset_type (list): e.g. ['testing'] or ['training', 'validation']\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Selected transformations for the {} dataset:'", ".", "format", "(", "dataset_type", ")", ")", "\n", "for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n", "\n", "", "", "def", "plot_transformed_sample", "(", "before", ",", "after", ",", "list_title", "=", "None", ",", "fname_out", "=", "\"\"", ",", "cmap", "=", "\"jet\"", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_undo_transforms": [[204, 224], ["enumerate", "list", "ivadomed.transforms.BoundingBoxCrop", "ivadomed.transforms.transform[].transforms.insert", "ivadomed.transforms.transform[].transforms.pop"], "function", ["None"], ["import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "if", "list_title", "is", "None", ":", "\n", "        ", "list_title", "=", "[", "]", "\n", "", "if", "len", "(", "list_title", ")", "==", "0", ":", "\n", "        ", "list_title", "=", "[", "'Sample before transform'", ",", "'Sample after transform'", "]", "\n", "\n", "", "plt", ".", "interactive", "(", "False", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'figure.max_open_warning'", ":", "0", "}", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "20", ",", "10", ")", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "before", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "0", "]", ",", "fontsize", "=", "20", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "after", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "1", "]", ",", "fontsize", "=", "20", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.load_bounding_boxes": [[226, 261], ["pathlib.Path", "pathlib.Path.exists", "object_detection_params.get", "pathlib.Path.open", "json.load", "pathlib.Path().exists", "utils.generate_bounding_box_file", "RuntimeError", "pathlib.Path", "object_detection_params.get"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.generate_bounding_box_file"], ["        ", "plt", ".", "savefig", "(", "fname_out", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "\n", "", "", "def", "_git_info", "(", "commit_env", "=", "'IVADOMED_COMMIT'", ",", "branch_env", "=", "'IVADOMED_BRANCH'", ")", ":", "\n", "    ", "\"\"\"Get ivadomed version info from GIT.\n\n    This functions retrieves the ivadomed version, commit, branch and installation type.\n\n    Args:\n        commit_env (str):\n        branch_env (str):\n    Returns:\n        str, str, str, str: installation type, commit, branch, version.\n    \"\"\"", "\n", "ivadomed_commit", "=", "os", ".", "getenv", "(", "commit_env", ",", "\"unknown\"", ")", "\n", "ivadomed_branch", "=", "os", ".", "getenv", "(", "branch_env", ",", "\"unknown\"", ")", "\n", "if", "check_exe", "(", "\"git\"", ")", "and", "Path", "(", "__ivadomed_dir__", ",", "\".git\"", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "ivadomed_commit", "=", "__get_commit", "(", ")", "or", "ivadomed_commit", "\n", "ivadomed_branch", "=", "__get_branch", "(", ")", "or", "ivadomed_branch", "\n", "\n", "", "if", "ivadomed_commit", "!=", "'unknown'", ":", "\n", "        ", "install_type", "=", "'git'", "\n", "", "else", ":", "\n", "        ", "install_type", "=", "'package'", "\n", "\n", "", "path_version", "=", "Path", "(", "__ivadomed_dir__", ",", "'ivadomed'", ",", "'version.txt'", ")", "\n", "with", "path_version", ".", "open", "(", ")", "as", "f", ":", "\n", "        ", "version_ivadomed", "=", "f", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "\n", "", "return", "install_type", ",", "ivadomed_commit", ",", "ivadomed_branch", ",", "version_ivadomed", "\n", "\n", "\n", "", "def", "check_exe", "(", "name", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.verify_metadata": [[263, 281], ["all", "range", "len"], "function", ["None"], ["\n", "\n", "def", "is_exe", "(", "fpath", ")", ":", "\n", "        ", "return", "Path", "(", "fpath", ")", ".", "is_file", "(", ")", "and", "os", ".", "access", "(", "fpath", ",", "os", ".", "X_OK", ")", "\n", "\n", "", "fpath", "=", "Path", "(", "name", ")", ".", "parent", "\n", "if", "fpath", "and", "is_exe", "(", "name", ")", ":", "\n", "        ", "return", "fpath", "\n", "", "else", ":", "\n", "        ", "for", "path", "in", "os", ".", "environ", "[", "\"PATH\"", "]", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "            ", "path", "=", "path", ".", "strip", "(", "'\"'", ")", "\n", "exe_file", "=", "str", "(", "Path", "(", "path", ",", "name", ")", ")", "\n", "if", "is_exe", "(", "exe_file", ")", ":", "\n", "                ", "return", "exe_file", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.bounding_box_prior": [[283, 306], ["nibabel.load", "nibabel.as_closest_canonical", "ivadomed.loader.utils.orient_img_hwd", "nib.as_closest_canonical.get_fdata", "utils.get_bounding_boxes", "utils.adjust_bb_size", "len", "nib.as_closest_canonical.get_fdata", "nib.as_closest_canonical.get_fdata"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.get_bounding_boxes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_bb_size"], ["\n", "\n", "", "class", "ArgParseException", "(", "Exception", ")", ":", "\n", "    ", "pass", "\n", "\n", "\n", "", "def", "get_arguments", "(", "parser", ",", "args", ")", ":", "\n", "    ", "\"\"\"Get arguments from function input or command line.\n\n    Arguments:\n        parser (argparse.ArgumentParser): ArgumentParser object\n        args (list): either a list of arguments or None. The list\n            should be formatted like this:\n            [\"-d\", \"SOME_ARG\", \"--model\", \"SOME_ARG\"]\n    \"\"\"", "\n", "try", ":", "\n", "        ", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "", "except", "SystemExit", "as", "e", ":", "\n", "        ", "if", "e", ".", "code", "!=", "0", ":", "# Calling `--help` raises SystemExit with 0 exit code (i.e. not an ArgParseException)", "\n", "            ", "raise", "ArgParseException", "(", "'Error parsing args'", ")", "\n", "", "else", ":", "\n", "            ", "sys", ".", "exit", "(", "0", ")", "\n", "\n", "", "", "return", "args", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.compute_bb_statistics": [[308, 329], ["loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "pathlib.Path().open", "json.load", "h.append", "w.append", "d.append", "v.append", "statistics.mean", "statistics.stdev", "min", "max", "statistics.mean", "statistics.stdev", "min", "max", "statistics.mean", "statistics.stdev", "min", "max", "statistics.mean", "statistics.stdev", "min", "max", "pathlib.Path"], "function", ["None"], ["\n", "", "def", "__get_commit", "(", "path_to_git_folder", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get GIT ivadomed commit.\n\n    Args:\n        path_to_git_folder (str): Path to GIT folder.\n    Returns:\n        str: git commit ID, with trailing '*' if modified.\n    \"\"\"", "\n", "if", "path_to_git_folder", "is", "None", ":", "\n", "        ", "path_to_git_folder", "=", "__ivadomed_dir__", "\n", "", "else", ":", "\n", "        ", "path_to_git_folder", "=", "Path", "(", "path_to_git_folder", ")", ".", "expanduser", "(", ")", ".", "absolute", "(", ")", "\n", "\n", "", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"rev-parse\"", ",", "\"HEAD\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ",", "\n", "cwd", "=", "path_to_git_folder", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "if", "status", "==", "0", ":", "\n", "        ", "commit", "=", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", "\n", "", "else", ":", "\n", "        ", "commit", "=", "\"?!?\"", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.get_parser": [[15, 37], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-i\"", ",", "\"--input\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Input BIDS folder.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--number\"", ",", "required", "=", "False", ",", "default", "=", "1", ",", "\n", "help", "=", "\"Number of subjects.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--contrasts\"", ",", "required", "=", "False", ",", "\n", "help", "=", "\"Contrast list.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "list", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Output BIDS Folder.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-s\"", ",", "\"--seed\"", ",", "required", "=", "False", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"\"\"Set np.random.RandomState to ensure reproducibility: the same\n                                subjects will be selected if the script is run several times on the\n                                same dataset. Set to -1 (default) otherwise.\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "\"--derivatives\"", ",", "\n", "dest", "=", "\"derivatives\"", ",", "\n", "default", "=", "1", ",", "\n", "help", "=", "\"\"\"If true, include derivatives/labels content.\n                                1 = true, 0 = false\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.is_good_contrast": [[39, 44], ["None"], "function", ["None"], ["", "def", "is_good_contrast", "(", "fname", ",", "good_contrast_list", ")", ":", "\n", "    ", "for", "good_contrast", "in", "good_contrast_list", ":", "\n", "        ", "if", "\"_\"", "+", "good_contrast", "in", "fname", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.remove_some_contrasts": [[46, 57], ["pathlib.Path().iterdir", "file.unlink", "file_list.append", "extract_small_dataset.is_good_contrast", "rm_file_list.append", "pathlib.Path", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.is_good_contrast"], ["", "def", "remove_some_contrasts", "(", "folder", ",", "subject_list", ",", "good_contrast_list", ")", ":", "\n", "    ", "file_list", ":", "List", "[", "Path", "]", "=", "[", "]", "\n", "for", "s", "in", "subject_list", ":", "\n", "        ", "for", "f", "in", "Path", "(", "folder", ",", "s", ",", "\"anat\"", ")", ".", "iterdir", "(", ")", ":", "\n", "            ", "file_list", ".", "append", "(", "f", ")", "\n", "", "", "rm_file_list", ":", "List", "[", "Path", "]", "=", "[", "]", "\n", "for", "file", "in", "file_list", ":", "\n", "        ", "if", "not", "is_good_contrast", "(", "str", "(", "file", ")", ",", "good_contrast_list", ")", ":", "\n", "            ", "rm_file_list", ".", "append", "(", "file", ")", "\n", "", "", "for", "file", "in", "rm_file_list", ":", "\n", "        ", "file", ".", "unlink", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.extract_small_dataset": [[59, 150], ["pathlib.Path", "pathlib.Path", "shutil.copyfile", "pathlib.Path().joinpath().is_file", "pathlib.Path", "pathlib.Path", "pandas.read_csv", "pd.read_csv.to_csv", "pathlib.Path().is_dir", "pathlib.Path().mkdir", "pathlib.Path", "pathlib.Path", "pathlib.Path", "numpy.random.RandomState", "list", "list", "loguru.logger.debug", "pathlib.Path", "pathlib.Path", "pathlib.Path.is_dir", "loguru.logger.debug", "shutil.copytree", "pathlib.Path().is_dir", "extract_small_dataset.remove_some_contrasts", "str", "str", "pathlib.Path", "pathlib.Path", "shutil.copyfile", "str", "str", "pathlib.Path.is_dir", "pathlib.Path.mkdir", "pathlib.Path.is_dir", "pathlib.Path.mkdir", "pathlib.Path().iterdir", "np.random.RandomState.choice", "numpy.random.choice", "str", "str", "shutil.rmtree", "pathlib.Path", "pathlib.Path", "pathlib.Path.is_dir", "loguru.logger.debug", "shutil.copytree", "pathlib.Path().is_dir", "extract_small_dataset.remove_some_contrasts", "pathlib.Path().joinpath", "str", "str", "pd.read_csv.participant_id.isin", "pathlib.Path", "pathlib.Path", "s.name.startswith", "s.is_dir", "pathlib.Path", "str", "str", "str", "shutil.rmtree", "str", "pathlib.Path", "pathlib.Path", "pathlib.Path", "str", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.remove_some_contrasts", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.remove_some_contrasts"], ["", "", "def", "extract_small_dataset", "(", "input", ",", "output", ",", "n", "=", "10", ",", "contrast_list", "=", "None", ",", "include_derivatives", "=", "True", ",", "\n", "seed", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"Extract small BIDS dataset from a larger BIDS dataset.\n\n    Example::\n\n         ivadomed_extract_small_dataset -i path/to/BIDS/dataset -o path/of/small/BIDS/dataset \\\n            -n 10 -c T1w,T2w -d 0 -s 1234\n\n    Args:\n        input (str): Input BIDS folder. Flag: ``--input``, ``-i``\n        output (str): Output folder. Flag: ``--output``, ``-o``\n        n (int): Number of subjects in the output folder. Flag: ``--number``, ``-n``\n        contrast_list (list): List of image contrasts to include. If set to None, then all\n            available contrasts are included. Flag: ``--contrasts``, ``-c``\n        include_derivatives (bool): If True, derivatives/labels/ content is also copied,\n            only the raw images otherwise. Flag: ``--derivatives``, ``-d``\n        seed (int): Set np.random.RandomState to ensure reproducibility: the same subjects will be\n            selected if the function is run several times on the same dataset. If set to -1,\n            each function run is independent. Flag: ``--seed``, ``-s``.\n    \"\"\"", "\n", "# Create output folders", "\n", "if", "not", "Path", "(", "output", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "Path", "(", "output", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "if", "include_derivatives", ":", "\n", "        ", "out_derivatives", "=", "Path", "(", "output", ",", "\"derivatives\"", ")", "\n", "if", "not", "out_derivatives", ".", "is_dir", "(", ")", ":", "\n", "            ", "out_derivatives", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "out_derivatives", "=", "Path", "(", "out_derivatives", ",", "\"labels\"", ")", "\n", "if", "not", "out_derivatives", ".", "is_dir", "(", ")", ":", "\n", "            ", "out_derivatives", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "in_derivatives", "=", "Path", "(", "input", ",", "\"derivatives\"", ",", "\"labels\"", ")", "\n", "\n", "# Get subject list", "\n", "", "subject_list", "=", "[", "s", ".", "name", "for", "s", "in", "Path", "(", "input", ")", ".", "iterdir", "(", ")", "\n", "if", "s", ".", "name", ".", "startswith", "(", "\"sub-\"", ")", "and", "s", ".", "is_dir", "(", ")", "\n", "and", "s", ".", "name", "not", "in", "EXCLUDED_SUBJECT", "]", "\n", "\n", "# Randomly select subjects", "\n", "if", "seed", "!=", "-", "1", ":", "\n", "# Reproducibility", "\n", "        ", "r", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "subject_random_list", "=", "list", "(", "r", ".", "choice", "(", "subject_list", ",", "n", ")", ")", "\n", "", "else", ":", "\n", "        ", "subject_random_list", "=", "list", "(", "np", ".", "random", ".", "choice", "(", "subject_list", ",", "n", ",", "replace", "=", "False", ")", ")", "\n", "\n", "# Loop across subjects", "\n", "", "for", "subject", "in", "subject_random_list", ":", "\n", "        ", "logger", ".", "debug", "(", "f\"\\nSubject: {subject}\"", ")", "\n", "# Copy images", "\n", "in_subj_folder", "=", "Path", "(", "input", ",", "subject", ")", "\n", "out_subj_folder", "=", "Path", "(", "output", ",", "subject", ")", "\n", "assert", "in_subj_folder", ".", "is_dir", "(", ")", "\n", "logger", ".", "debug", "(", "f\"\\tCopying {in_subj_folder} to {out_subj_folder}.\"", ")", "\n", "shutil", ".", "copytree", "(", "str", "(", "in_subj_folder", ")", ",", "str", "(", "out_subj_folder", ")", ")", "\n", "# Remove dwi data", "\n", "if", "Path", "(", "output", ",", "subject", ",", "\"dwi\"", ")", ".", "is_dir", "(", ")", ":", "\n", "            ", "shutil", ".", "rmtree", "(", "str", "(", "Path", "(", "output", ",", "subject", ",", "\"dwi\"", ")", ")", ")", "\n", "# Copy labels", "\n", "", "if", "include_derivatives", ":", "\n", "            ", "in_subj_derivatives", "=", "Path", "(", "in_derivatives", ",", "subject", ")", "\n", "out_subj_derivatives", "=", "Path", "(", "out_derivatives", ",", "subject", ")", "\n", "assert", "in_subj_derivatives", ".", "is_dir", "(", ")", "\n", "logger", ".", "debug", "(", "f\"\\tCopying {in_subj_derivatives} to {out_subj_derivatives}.\"", ")", "\n", "shutil", ".", "copytree", "(", "str", "(", "in_subj_derivatives", ")", ",", "str", "(", "out_subj_derivatives", ")", ")", "\n", "# Remove dwi data", "\n", "if", "Path", "(", "out_subj_derivatives", ",", "subject", ",", "\"dwi\"", ")", ".", "is_dir", "(", ")", ":", "\n", "                ", "shutil", ".", "rmtree", "(", "str", "(", "Path", "(", "out_subj_derivatives", ",", "subject", ",", "\"dwi\"", ")", ")", ")", "\n", "\n", "", "", "", "if", "contrast_list", ":", "\n", "        ", "remove_some_contrasts", "(", "output", ",", "subject_random_list", ",", "contrast_list", ")", "\n", "if", "include_derivatives", ":", "\n", "            ", "remove_some_contrasts", "(", "str", "(", "Path", "(", "output", ",", "\"derivatives\"", ",", "\"labels\"", ")", ")", ",", "\n", "subject_random_list", ",", "contrast_list", ")", "\n", "\n", "# Copy dataset_description.json", "\n", "", "", "in_dataset_json", "=", "Path", "(", "input", ",", "\"dataset_description.json\"", ")", "\n", "out_dataset_json", "=", "Path", "(", "output", ",", "\"dataset_description.json\"", ")", "\n", "shutil", ".", "copyfile", "(", "str", "(", "in_dataset_json", ")", ",", "str", "(", "out_dataset_json", ")", ")", "\n", "# Copy participants.json if it exist", "\n", "if", "Path", "(", "input", ")", ".", "joinpath", "(", "\"participants.json\"", ")", ".", "is_file", "(", ")", ":", "\n", "        ", "in_participants_json", "=", "Path", "(", "input", ",", "\"participants.json\"", ")", "\n", "out_participants_json", "=", "Path", "(", "output", ",", "\"participants.json\"", ")", "\n", "shutil", ".", "copyfile", "(", "str", "(", "in_participants_json", ")", ",", "str", "(", "out_participants_json", ")", ")", "\n", "# Copy participants.tsv", "\n", "", "in_participants_tsv", "=", "Path", "(", "input", ",", "\"participants.tsv\"", ")", "\n", "out_participants_tsv", "=", "Path", "(", "output", ",", "\"participants.tsv\"", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "str", "(", "in_participants_tsv", ")", ",", "sep", "=", "'\\t'", ")", "\n", "# Drop subjects", "\n", "df", "=", "df", "[", "df", ".", "participant_id", ".", "isin", "(", "subject_random_list", ")", "]", "\n", "df", ".", "to_csv", "(", "str", "(", "out_participants_tsv", ")", ",", "sep", "=", "'\\t'", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.main": [[152, 163], ["ivadomed.utils.init_ivadomed", "extract_small_dataset.get_parser", "ivadomed.utils.get_arguments", "extract_small_dataset.extract_small_dataset", "imed_utils.get_arguments.contrasts.split", "int", "bool", "int", "int"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.extract_small_dataset.extract_small_dataset"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "if", "args", ".", "contrasts", "is", "not", "None", ":", "\n", "        ", "contrast_list", "=", "args", ".", "contrasts", ".", "split", "(", "\",\"", ")", "\n", "", "else", ":", "\n", "        ", "contrast_list", "=", "None", "\n", "\n", "", "extract_small_dataset", "(", "args", ".", "input", ",", "args", ".", "output", ",", "int", "(", "args", ".", "number", ")", ",", "contrast_list", ",", "\n", "bool", "(", "int", "(", "args", ".", "derivatives", ")", ")", ",", "int", "(", "args", ".", "seed", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.mask2label": [[11, 42], ["nibabel.load", "nibabel.as_closest_canonical", "numpy.array", "range", "list_label_image.sort", "len", "np.array.nonzero", "np.array.nonzero", "np.array.nonzero", "np.array.nonzero", "list_label_image.append", "list_label_image.append"], "function", ["None"], ["def", "mask2label", "(", "path_label", ",", "aim", "=", "0", ")", ":", "\n", "    ", "\"\"\"Retrieve points coordinates and value from a label file containing singl voxel label.\n\n    Args:\n        path_label (str): path of nifti image\n        aim (int): -1 will return all points with label between 3 and 30 , any other int > 0\n            will return only the coordinates of points with label defined by aim.\n\n    Returns:\n        ndarray: array containing the asked point in the format [x,y,z,value] in the RAS orientation.\n\n    \"\"\"", "\n", "image", "=", "nib", ".", "load", "(", "path_label", ")", "\n", "image", "=", "nib", ".", "as_closest_canonical", "(", "image", ")", "\n", "arr", "=", "np", ".", "array", "(", "image", ".", "dataobj", ")", "\n", "list_label_image", "=", "[", "]", "\n", "# Arr non zero used since these are single voxel label", "\n", "for", "i", "in", "range", "(", "len", "(", "arr", ".", "nonzero", "(", ")", "[", "0", "]", ")", ")", ":", "\n", "        ", "x", "=", "arr", ".", "nonzero", "(", ")", "[", "0", "]", "[", "i", "]", "\n", "y", "=", "arr", ".", "nonzero", "(", ")", "[", "1", "]", "[", "i", "]", "\n", "z", "=", "arr", ".", "nonzero", "(", ")", "[", "2", "]", "[", "i", "]", "\n", "# need to check every points", "\n", "if", "aim", "==", "0", ":", "\n", "# we don't want to account for pmj (label 49) nor C1/C2 which is hard to distinguish.", "\n", "            ", "if", "arr", "[", "x", ",", "y", ",", "z", "]", "<", "30", "and", "arr", "[", "x", ",", "y", ",", "z", "]", "!=", "1", ":", "\n", "                ", "list_label_image", ".", "append", "(", "[", "x", ",", "y", ",", "z", ",", "arr", "[", "x", ",", "y", ",", "z", "]", "]", ")", "\n", "", "", "elif", "aim", ">", "0", ":", "\n", "            ", "if", "arr", "[", "x", ",", "y", ",", "z", "]", "==", "aim", ":", "\n", "                ", "list_label_image", ".", "append", "(", "[", "x", ",", "y", ",", "z", ",", "arr", "[", "x", ",", "y", ",", "z", "]", "]", ")", "\n", "", "", "", "list_label_image", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "3", "]", ")", "\n", "return", "list_label_image", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.extract_mid_slice_and_convert_coordinates_to_heatmaps": [[44, 93], ["range", "len", "pathlib.Path", "pathlib.Path.is_file", "pathlib.Path().iterdir", "pathlib.Path", "prepare_dataset_vertebral_labeling.mask2label", "nibabel.load", "nibabel.as_closest_canonical", "ivadomed.get_midslice_average", "nibabel.save", "nibabel.load", "nibabel.as_closest_canonical", "numpy.zeros", "range", "ivadomed.heatmap_generation", "ivadomed.reorient_image", "nibabel.Nifti1Image", "nibabel.save", "str", "numpy.array", "str", "pathlib.Path", "len", "numpy.expand_dims", "pathlib.Path", "pathlib.Path", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.mask2label", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.preprocessing.get_midslice_average", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.heatmap_generation", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "extract_mid_slice_and_convert_coordinates_to_heatmaps", "(", "path", ",", "suffix", ",", "aim", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"\n    This function takes as input a path to a dataset  and generates a set of images:\n    (i) mid-sagittal image and\n    (ii) heatmap of disc labels associated with the mid-sagittal image.\n\n    Example::\n\n        ivadomed_prepare_dataset_vertebral_labeling -p path/to/bids -s _T2w -a 0\n\n    Args:\n        path (string): path to BIDS dataset form which images will be generated.\n            Flag: ``--path``, ``-p``\n        suffix (string): suffix of image that will be processed (e.g., T2w).\n            Flag: ``--suffix``, ``-s``\n        aim (int): If aim is not 0, retrieves only labels with value = aim, else create heatmap\n            with all labels. Flag: ``--aim``, ``-a``\n\n    Returns:\n        None. Images are saved in BIDS folder\n    \"\"\"", "\n", "t", "=", "[", "path_object", ".", "name", "for", "path_object", "in", "Path", "(", "path", ")", ".", "iterdir", "(", ")", "if", "path_object", ".", "name", "!=", "'derivatives'", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "t", ")", ")", ":", "\n", "        ", "subject", "=", "t", "[", "i", "]", "\n", "path_image", "=", "Path", "(", "path", ",", "subject", ",", "'anat'", ",", "subject", "+", "suffix", "+", "'.nii.gz'", ")", "\n", "if", "path_image", ".", "is_file", "(", ")", ":", "\n", "            ", "path_label", "=", "Path", "(", "path", ",", "'derivatives'", ",", "'labels'", ",", "subject", ",", "'anat'", ",", "subject", "+", "suffix", "+", "\n", "'_labels-disc-manual.nii.gz'", ")", "\n", "list_points", "=", "mask2label", "(", "str", "(", "path_label", ")", ",", "aim", "=", "aim", ")", "\n", "image_ref", "=", "nib", ".", "load", "(", "path_image", ")", "\n", "nib_ref_can", "=", "nib", ".", "as_closest_canonical", "(", "image_ref", ")", "\n", "imsh", "=", "np", ".", "array", "(", "nib_ref_can", ".", "dataobj", ")", ".", "shape", "\n", "mid_nifti", "=", "imed_preprocessing", ".", "get_midslice_average", "(", "str", "(", "path_image", ")", ",", "list_points", "[", "0", "]", "[", "0", "]", ",", "slice_axis", "=", "0", ")", "\n", "nib", ".", "save", "(", "mid_nifti", ",", "Path", "(", "path", ",", "subject", ",", "'anat'", ",", "subject", "+", "suffix", "+", "'_mid.nii.gz'", ")", ")", "\n", "lab", "=", "nib", ".", "load", "(", "path_label", ")", "\n", "nib_ref_can", "=", "nib", ".", "as_closest_canonical", "(", "lab", ")", "\n", "label_array", "=", "np", ".", "zeros", "(", "imsh", "[", "1", ":", "]", ")", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "list_points", ")", ")", ":", "\n", "                ", "label_array", "[", "list_points", "[", "j", "]", "[", "1", "]", ",", "list_points", "[", "j", "]", "[", "2", "]", "]", "=", "1", "\n", "\n", "", "heatmap", "=", "imed_maths", ".", "heatmap_generation", "(", "label_array", "[", ":", ",", ":", "]", ",", "10", ")", "\n", "arr_pred_ref_space", "=", "imed_loader_utils", ".", "reorient_image", "(", "np", ".", "expand_dims", "(", "heatmap", "[", ":", ",", ":", "]", ",", "axis", "=", "0", ")", ",", "2", ",", "lab", ",", "nib_ref_can", ")", "\n", "nib_pred", "=", "nib", ".", "Nifti1Image", "(", "arr_pred_ref_space", ",", "lab", ".", "affine", ")", "\n", "nib", ".", "save", "(", "nib_pred", ",", "Path", "(", "path", ",", "'derivatives'", ",", "'labels'", ",", "subject", ",", "'anat'", ",", "subject", "+", "suffix", "+", "\n", "'_mid_heatmap'", "+", "str", "(", "aim", ")", "+", "'.nii.gz'", ")", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.get_parser": [[95, 109], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "", "", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-p\"", ",", "\"--path\"", ",", "dest", "=", "\"path\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Path to bids folder\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-s\"", ",", "\"--suffix\"", ",", "dest", "=", "\"suffix\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"\"\"Suffix of the input file as in\n                                sub-xxxSUFFIX.nii.gz (E.g., _T2w)\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "str", ")", "\n", "parser", ".", "add_argument", "(", "\"-a\"", ",", "\"--aim\"", ",", "dest", "=", "\"aim\"", ",", "default", "=", "-", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"\"\"-1 or positive int. If set to any positive int,\n                                only label with this value will be taken into account\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.main": [[111, 117], ["ivadomed.utils.init_ivadomed", "prepare_dataset_vertebral_labeling.get_parser", "ivadomed.utils.get_arguments", "prepare_dataset_vertebral_labeling.extract_mid_slice_and_convert_coordinates_to_heatmaps"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.prepare_dataset_vertebral_labeling.extract_mid_slice_and_convert_coordinates_to_heatmaps"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "extract_mid_slice_and_convert_coordinates_to_heatmaps", "(", "path", "=", "args", ".", "path", ",", "suffix", "=", "args", ".", "suffix", ",", "\n", "aim", "=", "args", ".", "aim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_parser": [[20, 37], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-i\"", ",", "\"--input\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Input image filename.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--config\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Config filename.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--number\"", ",", "required", "=", "False", ",", "default", "=", "1", ",", "\n", "help", "=", "\"Number of random slices to visualize.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output\"", ",", "required", "=", "False", ",", "default", "=", "\"./\"", ",", "\n", "help", "=", "\"Output folder.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-r\"", ",", "\"--roi\"", ",", "required", "=", "False", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ",", "\n", "help", "=", "\"ROI filename. Only required if ROICrop is part of the transformations.\"", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data": [[39, 58], ["nibabel.load", "nibabel.as_closest_canonical", "nib.as_closest_canonical.get_fdata", "ivadomed.loader.utils.orient_img_hwd"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd"], ["", "def", "get_data", "(", "fname_in", ",", "axis", ")", ":", "\n", "    ", "\"\"\"Get data from fname along an axis.\n\n    Args:\n         fname_in string: image fname\n         axis int:\n\n    Returns:\n        nibabel, ndarray\n    \"\"\"", "\n", "# Load image", "\n", "input_img", "=", "nib", ".", "load", "(", "fname_in", ")", "\n", "# Reorient as canonical", "\n", "input_img", "=", "nib", ".", "as_closest_canonical", "(", "input_img", ")", "\n", "# Get input data", "\n", "input_data", "=", "input_img", ".", "get_fdata", "(", "dtype", "=", "np", ".", "float32", ")", "\n", "# Reorient data", "\n", "input_data", "=", "imed_loader_utils", ".", "orient_img_hwd", "(", "input_data", ",", "slice_axis", "=", "axis", ")", "\n", "return", "input_img", ",", "input_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.run_visualization": [[60, 177], ["ivadomed.config_manager.ConfigurationManager().get_config", "visualize_transforms.get_data", "numpy.array_equal", "ivadomed.loader.utils.orient_shapes_hwd", "random.sample", "ivadomed.transforms.get_subdatasets_transforms", "pathlib.Path().is_dir", "pathlib.Path().mkdir", "input_data.astype", "input_img.header.get_zooms", "range", "dict_transforms.update", "ivadomed.transforms.Compose", "ivadomed.config_manager.ConfigurationManager", "pathlib.Path().is_file", "visualize_transforms.get_data", "ValueError", "ivadomed.loader.sample_meta_data.SampleMetadata", "imed_transforms.Compose.", "str", "loguru.logger.debug", "loguru.logger.debug", "isinstance", "ivadomed.utils.plot_transformed_sample", "pathlib.Path", "pathlib.Path", "ivadomed.loader.sample_meta_data.SampleMetadata.__setitem__", "pathlib.Path", "len", "numpy.rot90", "numpy.rot90", "numpy.rot90", "pathlib.Path", "pathlib.Path().is_file", "stg_transforms[].split", "ivadomed.maths.rescale_values_array", "ivadomed.maths.rescale_values_array", "ivadomed.maths.rescale_values_array", "dict", "stack_im[].numpy", "pathlib.Path", "range", "str", "stg_transforms[].split", "stg_transforms[].split"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.get_subdatasets_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.get_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.plot_transformed_sample", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__setitem__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.maths.rescale_values_array"], ["", "def", "run_visualization", "(", "input", ",", "config", ",", "number", ",", "output", ",", "roi", ")", ":", "\n", "    ", "\"\"\"Utility function to visualize Data Augmentation transformations.\n\n    Data augmentation is a key part of the Deep Learning training scheme. This script aims at facilitating the\n    fine-tuning of data augmentation parameters. To do so, this script provides a step-by-step visualization of the\n    transformations that are applied on data.\n\n    This function applies a series of transformations (defined in a configuration file\n    ``-c``) to ``-n`` 2D slices randomly extracted from an input image (``-i``), and save as png the resulting sample\n    after each transform.\n\n    For example::\n\n        ivadomed_visualize_transforms -i t2s.nii.gz -n 1 -c config.json -r t2s_seg.nii.gz\n\n    Provides a visualization of a series of three transformation on a randomly selected slice:\n\n    .. image:: https://raw.githubusercontent.com/ivadomed/doc-figures/main/scripts/transforms_im.png\n        :width: 600px\n        :align: center\n\n    And on a binary mask::\n\n        ivadomed_visualize_transforms -i t2s_gmseg.nii.gz -n 1 -c config.json -r t2s_seg.nii.gz\n\n    Gives:\n\n    .. image:: https://raw.githubusercontent.com/ivadomed/doc-figures/main/scripts/transforms_gt.png\n        :width: 600px\n        :align: center\n\n    Args:\n         input (string): Image filename. Flag: ``--input``, ``-i``\n         config (string): Configuration file filename. Flag: ``--config``, ``-c``\n         number (int): Number of slices randomly extracted. Flag: ``--number``, ``-n``\n         output (string): Folder path where the results are saved. Flag: ``--ofolder``, ``-o``\n         roi (string): Filename of the region of interest. Only needed if ROICrop is part of the transformations.\n                       Flag: ``--roi``, ``-r``\n    \"\"\"", "\n", "# Load context", "\n", "context", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "config", ")", ".", "get_config", "(", ")", "\n", "\n", "# Create output folder", "\n", "if", "not", "Path", "(", "output", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "Path", "(", "output", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# Slice extracted according to below axis", "\n", "", "axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "SLICE_AXIS", "]", "]", "\n", "# Get data", "\n", "input_img", ",", "input_data", "=", "get_data", "(", "input", ",", "axis", ")", "\n", "# Image or Mask", "\n", "is_mask", "=", "np", ".", "array_equal", "(", "input_data", ",", "input_data", ".", "astype", "(", "bool", ")", ")", "\n", "# Get zooms", "\n", "zooms", "=", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "input_img", ".", "header", ".", "get_zooms", "(", ")", ",", "slice_axis", "=", "axis", ")", "\n", "# Get indexes", "\n", "indexes", "=", "random", ".", "sample", "(", "range", "(", "0", ",", "input_data", ".", "shape", "[", "2", "]", ")", ",", "number", ")", "\n", "\n", "# Get training transforms", "\n", "training_transforms", ",", "_", ",", "_", "=", "imed_transforms", ".", "get_subdatasets_transforms", "(", "context", "[", "ConfigKW", ".", "TRANSFORMATION", "]", ")", "\n", "\n", "if", "TransformationKW", ".", "ROICROP", "in", "training_transforms", ":", "\n", "        ", "if", "roi", "and", "Path", "(", "roi", ")", ".", "is_file", "(", ")", ":", "\n", "            ", "roi_img", ",", "roi_data", "=", "get_data", "(", "roi", ",", "axis", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"\\nPlease provide ROI image (-r) in order to apply ROICrop transformation.\"", ")", "\n", "\n", "# Compose transforms", "\n", "", "", "dict_transforms", "=", "{", "}", "\n", "stg_transforms", "=", "\"\"", "\n", "for", "transform_name", "in", "training_transforms", ":", "\n", "# We skip NumpyToTensor transform since that s only a change of data type", "\n", "        ", "if", "transform_name", "==", "\"NumpyToTensor\"", ":", "\n", "            ", "continue", "\n", "\n", "# Update stg_transforms", "\n", "", "stg_transforms", "+=", "transform_name", "+", "\"_\"", "\n", "\n", "# Add new transform to Compose", "\n", "dict_transforms", ".", "update", "(", "{", "transform_name", ":", "training_transforms", "[", "transform_name", "]", "}", ")", "\n", "composed_transforms", "=", "imed_transforms", ".", "Compose", "(", "dict_transforms", ")", "\n", "\n", "# Loop across slices", "\n", "for", "i", "in", "indexes", ":", "\n", "            ", "data", "=", "[", "input_data", "[", ":", ",", ":", ",", "i", "]", "]", "\n", "# Init metadata", "\n", "metadata", "=", "SampleMetadata", "(", "{", "MetadataKW", ".", "ZOOMS", ":", "zooms", ",", "MetadataKW", ".", "DATA_TYPE", ":", "\"gt\"", "if", "is_mask", "else", "\"im\"", "}", ")", "\n", "\n", "# Apply transformations to ROI", "\n", "if", "TransformationKW", ".", "CENTERCROP", "in", "training_transforms", "or", "(", "TransformationKW", ".", "ROICROP", "in", "training_transforms", "and", "Path", "(", "roi", ")", ".", "is_file", "(", ")", ")", ":", "\n", "                ", "metadata", ".", "__setitem__", "(", "MetadataKW", ".", "CROP_PARAMS", ",", "{", "}", ")", "\n", "\n", "# Apply transformations to image", "\n", "", "stack_im", ",", "_", "=", "composed_transforms", "(", "sample", "=", "data", ",", "\n", "metadata", "=", "[", "metadata", "for", "_", "in", "range", "(", "number", ")", "]", ",", "\n", "data_type", "=", "\"im\"", ")", "\n", "\n", "# Plot before / after transformation", "\n", "fname_out", "=", "str", "(", "Path", "(", "output", ",", "stg_transforms", "+", "\"slice\"", "+", "str", "(", "i", ")", "+", "\".png\"", ")", ")", "\n", "logger", ".", "debug", "(", "f\"Fname out: {fname_out}.\"", ")", "\n", "logger", ".", "debug", "(", "f\"\\t{dict(metadata)}\"", ")", "\n", "# rescale intensities", "\n", "if", "len", "(", "stg_transforms", "[", ":", "-", "1", "]", ".", "split", "(", "\"_\"", ")", ")", "==", "1", ":", "\n", "                ", "before", "=", "np", ".", "rot90", "(", "imed_maths", ".", "rescale_values_array", "(", "data", "[", "0", "]", ",", "0.0", ",", "1.0", ")", ")", "\n", "", "else", ":", "\n", "                ", "before", "=", "after", "\n", "", "if", "isinstance", "(", "stack_im", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "after", "=", "np", ".", "rot90", "(", "imed_maths", ".", "rescale_values_array", "(", "stack_im", "[", "0", "]", ".", "numpy", "(", ")", ",", "0.0", ",", "1.0", ")", ")", "\n", "", "else", ":", "\n", "                ", "after", "=", "np", ".", "rot90", "(", "imed_maths", ".", "rescale_values_array", "(", "stack_im", "[", "0", "]", ",", "0.0", ",", "1.0", ")", ")", "\n", "# Plot", "\n", "", "imed_utils", ".", "plot_transformed_sample", "(", "before", ",", "\n", "after", ",", "\n", "list_title", "=", "[", "\"\\n\"", ".", "join", "(", "stg_transforms", "[", ":", "-", "1", "]", ".", "split", "(", "\"_\"", ")", "[", ":", "-", "1", "]", ")", ",", "\n", "\"\\n\"", ".", "join", "(", "stg_transforms", "[", ":", "-", "1", "]", ".", "split", "(", "\"_\"", ")", ")", "]", ",", "\n", "fname_out", "=", "fname_out", ",", "\n", "cmap", "=", "\"jet\"", "if", "is_mask", "else", "\"gray\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.main": [[179, 185], ["ivadomed.utils.init_ivadomed", "visualize_transforms.get_parser", "ivadomed.utils.get_arguments", "visualize_transforms.run_visualization", "int"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_transforms.run_visualization"], ["", "", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "run_visualization", "(", "input", "=", "args", ".", "input", ",", "config", "=", "args", ".", "config", ",", "number", "=", "int", "(", "args", ".", "number", ")", ",", "\n", "output", "=", "args", ".", "output", ",", "roi", "=", "args", ".", "roi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.convert_to_onnx.get_parser": [[6, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-m\"", ",", "\"--model\"", ",", "dest", "=", "\"model\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Path to .pt model.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "\"--dimension\"", ",", "dest", "=", "\"dimension\"", ",", "required", "=", "True", ",", "\n", "type", "=", "int", ",", "help", "=", "\"Input dimension (2 for 2D inputs, 3 for 3D inputs).\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--n_channels\"", ",", "dest", "=", "\"n_channels\"", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Number of input channels of the model.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-g\"", ",", "\"--gpu_id\"", ",", "dest", "=", "\"gpu_id\"", ",", "default", "=", "0", ",", "type", "=", "str", ",", "\n", "help", "=", "\"GPU number if available.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.convert_to_onnx.convert_pytorch_to_onnx": [[21, 45], ["torch.cuda.is_available", "torch.load", "ivadomed.utils.save_onnx_model", "torch.randn", "torch.randn", "model.replace", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.save_onnx_model"], ["", "def", "convert_pytorch_to_onnx", "(", "model", ",", "dimension", ",", "n_channels", ",", "gpu_id", "=", "0", ")", ":", "\n", "    ", "\"\"\"Convert PyTorch model to ONNX.\n\n    The integration of Deep Learning models into the clinical routine requires cpu optimized models. To export the\n    PyTorch models to `ONNX <https://github.com/onnx/onnx>`_ format and to run the inference using\n    `ONNX Runtime <https://github.com/microsoft/onnxruntime>`_ is a time and memory efficient way to answer this need.\n\n    This function converts a model from PyTorch to ONNX format, with information of whether it is a 2D or 3D model\n    (``-d``).\n\n    Args:\n        model (string): Model filename. Flag: ``--model``, ``-m``.\n        dimension (int): Indicates whether the model is 2D or 3D. Choice between 2 or 3. Flag: ``--dimension``, ``-d``\n        gpu_id (string): GPU ID, if available. Flag: ``--gpu_id``, ``-g``\n    \"\"\"", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "\"cuda:\"", "+", "str", "(", "gpu_id", ")", "\n", "", "else", ":", "\n", "        ", "device", "=", "\"cpu\"", "\n", "\n", "", "model_net", "=", "torch", ".", "load", "(", "model", ",", "map_location", "=", "device", ")", "\n", "dummy_input", "=", "torch", ".", "randn", "(", "1", ",", "n_channels", ",", "96", ",", "96", ",", "device", "=", "device", ")", "if", "dimension", "==", "2", "else", "torch", ".", "randn", "(", "1", ",", "n_channels", ",", "96", ",", "96", ",", "96", ",", "device", "=", "device", ")", "\n", "imed_utils", ".", "save_onnx_model", "(", "model_net", ",", "dummy_input", ",", "model", ".", "replace", "(", "\"pt\"", ",", "\"onnx\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.convert_to_onnx.main": [[47, 57], ["ivadomed.utils.init_ivadomed", "convert_to_onnx.get_parser", "ivadomed.utils.get_arguments", "int", "str", "convert_to_onnx.convert_pytorch_to_onnx"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.convert_to_onnx.convert_pytorch_to_onnx"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "fname_model", "=", "args", ".", "model", "\n", "dimension", "=", "int", "(", "args", ".", "dimension", ")", "\n", "gpu_id", "=", "str", "(", "args", ".", "gpu_id", ")", "\n", "n_channels", "=", "args", ".", "n_channels", "\n", "\n", "convert_pytorch_to_onnx", "(", "fname_model", ",", "dimension", ",", "n_channels", ",", "gpu_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.compare_models.get_parser": [[21, 36], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-df\"", ",", "\"--dataframe\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to saved dataframe (csv file).\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--n-iterations\"", ",", "required", "=", "True", ",", "dest", "=", "\"n_iterations\"", ",", "\n", "type", "=", "int", ",", "help", "=", "\"Number of times each config was run .\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"--run_test\"", ",", "dest", "=", "'run_test'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Evaluate the trained model on the testing sub-set instead of\n                                validation.\"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output\"", ",", "dest", "=", "'out'", ",", "default", "=", "\"comparison_models.csv\"", ",", "\n", "help", "=", "\"if defined will represents the output csv file.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.compare_models.compute_statistics": [[38, 95], ["dataframe.groupby().mean", "dataframe.groupby().std", "loguru.logger.info", "loguru.logger.info", "list", "numpy.zeros", "pandas.DataFrame", "loguru.logger.info", "loguru.logger.info", "pandas.concat", "pd.concat.to_csv", "dataframe.groupby", "dataframe.groupby", "len", "len", "dataframe.groupby().mean.add_prefix().drop", "dataframe.groupby().std.add_prefix().drop", "pd.DataFrame.add_prefix", "scipy.stats.ttest_ind_from_stats", "scipy.stats.ttest_ind_from_stats", "dataframe.groupby().mean.add_prefix", "dataframe.groupby().std.add_prefix"], "function", ["None"], ["", "def", "compute_statistics", "(", "dataframe", ",", "n_iterations", ",", "run_test", "=", "True", ",", "csv_out", "=", "'comparison_models.csv'", ")", ":", "\n", "    ", "\"\"\"Compares the performance of models at inference time on a common testing dataset using paired t-tests.\n\n    It uses a dataframe generated by ``scripts/automate_training.py`` with the parameter ``--run-test`` (used to run the\n    models on the testing dataset). It output dataframes that stores the different statistic (average, std and p_value\n    between runs). All can be combined and stored in a csv.\n\n    .. csv-table:: Example of dataframe\n       :file: ../../images/df_compare.csv\n\n    Usage example::\n\n        ivadomed_compare_models -df results.csv -n 2 --run_test\n\n    Args:\n        dataframe (pandas.Dataframe): Dataframe of results generated by automate_training. Flag: ``--dataframe``, ``-df``\n        n_iterations (int): Indicates the number of time that each experiment (ie set of parameter) was run.\n                            Flag: ``--n_iteration``, ``-n``\n        run_test (int): Indicates if the comparison is done on the performances on either the testing subdataset (True)\n            either on the training/validation subdatasets. Flag: ``--run_test``\n        csv_out (string): Output csv name to store computed value (e.g., df.csv). Default value is model_comparison.csv. Flag ``-o``, ``--output``\n    \"\"\"", "\n", "avg", "=", "dataframe", ".", "groupby", "(", "[", "'path_output'", "]", ")", ".", "mean", "(", ")", "\n", "std", "=", "dataframe", ".", "groupby", "(", "[", "'path_output'", "]", ")", ".", "std", "(", ")", "\n", "\n", "logger", ".", "info", "(", "f\"Average dataframe: {avg}\"", ")", "\n", "logger", ".", "info", "(", "f\"Standard deviation dataframe: {std}\"", ")", "\n", "\n", "config_logs", "=", "list", "(", "avg", ".", "index", ".", "values", ")", "\n", "p_values", "=", "np", ".", "zeros", "(", "(", "len", "(", "config_logs", ")", ",", "len", "(", "config_logs", ")", ")", ")", "\n", "i", ",", "j", "=", "0", ",", "0", "\n", "for", "confA", "in", "config_logs", ":", "\n", "        ", "j", "=", "0", "\n", "for", "confB", "in", "config_logs", ":", "\n", "            ", "if", "run_test", ":", "\n", "                ", "p_values", "[", "i", ",", "j", "]", "=", "ttest_ind_from_stats", "(", "mean1", "=", "avg", ".", "loc", "[", "confA", "]", "[", "\"test_dice\"", "]", ",", "\n", "std1", "=", "std", ".", "loc", "[", "confA", "]", "[", "\"test_dice\"", "]", ",", "\n", "nobs1", "=", "n_iterations", ",", "mean2", "=", "avg", ".", "loc", "[", "confB", "]", "[", "\"test_dice\"", "]", ",", "\n", "std2", "=", "std", ".", "loc", "[", "confB", "]", "[", "\"test_dice\"", "]", ",", "nobs2", "=", "n_iterations", ")", ".", "pvalue", "\n", "", "else", ":", "\n", "                ", "p_values", "[", "i", ",", "j", "]", "=", "ttest_ind_from_stats", "(", "mean1", "=", "avg", ".", "loc", "[", "confA", "]", "[", "\"best_validation_dice\"", "]", ",", "\n", "std1", "=", "std", ".", "loc", "[", "confA", "]", "[", "\"best_validation_dice\"", "]", ",", "\n", "nobs1", "=", "n_iterations", ",", "mean2", "=", "avg", ".", "loc", "[", "confB", "]", "[", "\"best_validation_dice\"", "]", ",", "\n", "std2", "=", "std", ".", "loc", "[", "confB", "]", "[", "\"best_validation_dice\"", "]", ",", "\n", "nobs2", "=", "n_iterations", ")", ".", "pvalue", "\n", "", "j", "+=", "1", "\n", "", "i", "+=", "1", "\n", "\n", "", "p_df", "=", "pd", ".", "DataFrame", "(", "p_values", ",", "index", "=", "config_logs", ",", "columns", "=", "config_logs", ")", "\n", "logger", ".", "info", "(", "\"P-values dataframe\"", ")", "\n", "logger", ".", "info", "(", "p_df", ")", "\n", "if", "csv_out", "is", "not", "None", ":", "\n", "# Unnamed 0 column correspond to run number so we remoe that and add prefix for better readability", "\n", "        ", "df_concat", "=", "pd", ".", "concat", "(", "[", "avg", ".", "add_prefix", "(", "'avg_'", ")", ".", "drop", "(", "[", "'avg_Unnamed: 0'", "]", ",", "axis", "=", "1", ")", ",", "\n", "std", ".", "add_prefix", "(", "'std_'", ")", ".", "drop", "(", "[", "'std_Unnamed: 0'", "]", ",", "axis", "=", "1", ")", ",", "p_df", ".", "add_prefix", "(", "'p-value_'", ")", "]", ",", "\n", "axis", "=", "1", ")", "\n", "df_concat", ".", "to_csv", "(", "csv_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.compare_models.main": [[97, 103], ["ivadomed.utils.init_ivadomed", "compare_models.get_parser", "ivadomed.utils.get_arguments", "pandas.read_csv", "compare_models.compute_statistics", "int", "bool"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.compare_models.compute_statistics"], ["", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "args", ".", "dataframe", ")", "\n", "compute_statistics", "(", "df", ",", "int", "(", "args", ".", "n_iterations", ")", ",", "bool", "(", "args", ".", "run_test", ")", ",", "args", ".", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.get_parser": [[16, 42], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-i\"", ",", "\"--input\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"\"\"Input path. If using --multiple, this parameter indicates\n                                the prefix path of all log directories of interest. To compare\n                                trainings (not using ``--multiple``) or set of trainings\n                                (using ``--multiple``) with subplots, please list the paths by separating\n                                them with commas, e.g. path_output1,path_output2.\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "str", ")", "\n", "parser", ".", "add_argument", "(", "\"--multiple\"", ",", "required", "=", "False", ",", "dest", "=", "\"multiple\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Multiple log directories are considered: all available folders\n                                with -i as prefix. The plot represents the mean value (hard line)\n                                surrounded by the standard deviation envelope.\"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lr\"", ",", "required", "=", "False", ",", "dest", "=", "\"learning_rate\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"\"\"Summary event file for learning rate is considered, the limits on\n                                the y-axis plot are automatically defined.\"\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-y\"", ",", "\"--ylim_loss\"", ",", "required", "=", "False", ",", "type", "=", "str", ",", "\n", "help", "=", "\"\"\"Indicates the limits on the y-axis for the loss plots, otherwise\n                                these limits are automatically defined. Please separate the lower\n                                and the upper limit by a comma, e.g. -1,0. Note: for the validation\n                                metrics: the y-limits are always 0.0 and 1.0 except for the hausdorff\n                                score where the limits are automatically defined.\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "float", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output\"", ",", "required", "=", "True", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Output folder.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.get_events_path_list": [[44, 83], ["pathlib.Path().iterdir", "sorted", "fold_path.is_dir", "len", "pathlib.Path", "len", "pathlib.Path().iterdir", "f.name.startswith", "len", "ValueError", "sorted.append", "fold_path.iterdir", "f.name.startswith", "len", "ValueError", "sorted.append", "pathlib.Path", "pathlib.Path", "pathlib.Path"], "function", ["None"], ["", "def", "get_events_path_list", "(", "input_folder", ",", "learning_rate", ")", ":", "\n", "    ", "\"\"\"Check to make sure there is at most one summary event in any folder or any subfolder,\n    and returns a list of summary event paths.\n\n    A summary is defined as any file of the format ``events.out.tfevents.{...}```\n\n    Args:\n        input_folder (str): Input folder path.\n        learning_rate (bool): Indicate if learning_rate is considered.\n    Returns:\n        list : a list of events paths\n    \"\"\"", "\n", "events_path_list", "=", "[", "]", "\n", "\n", "# Check for events file in sub-folders", "\n", "for", "fold_path", "in", "Path", "(", "input_folder", ")", ".", "iterdir", "(", ")", ":", "\n", "        ", "if", "fold_path", ".", "is_dir", "(", ")", ":", "\n", "            ", "event_list", "=", "[", "f", ".", "name", "for", "f", "in", "fold_path", ".", "iterdir", "(", ")", "if", "f", ".", "name", ".", "startswith", "(", "\"events.out.tfevents.\"", ")", "]", "\n", "if", "len", "(", "event_list", ")", ":", "\n", "                ", "if", "len", "(", "event_list", ")", ">", "1", ":", "\n", "                    ", "raise", "ValueError", "(", "f\"Multiple summary found in this folder: {fold_path}.\\n\"", "\n", "f\"Please keep only one before running this script again.\"", ")", "\n", "", "else", ":", "\n", "                    ", "events_path_list", ".", "append", "(", "fold_path", ")", "\n", "# Sort events_path_list alphabetically", "\n", "", "", "", "", "events_path_list", "=", "sorted", "(", "events_path_list", ")", "\n", "\n", "if", "learning_rate", ":", "\n", "# Check for events file at the root of input_folder (contains learning_rate)", "\n", "        ", "event_list", "=", "[", "f", ".", "name", "for", "f", "in", "Path", "(", "input_folder", ")", ".", "iterdir", "(", ")", "if", "f", ".", "name", ".", "startswith", "(", "\"events.out.tfevents.\"", ")", "]", "\n", "if", "len", "(", "event_list", ")", ":", "\n", "            ", "if", "len", "(", "event_list", ")", ">", "1", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Multiple summary found in this folder: {Path(input_folder)}.\\n\"", "\n", "f\"Please keep only one before running this script again.\"", ")", "\n", "", "else", ":", "\n", "# Append learning_rate events file at the end of events_path_list", "\n", "                ", "events_path_list", ".", "append", "(", "Path", "(", "input_folder", ")", ")", "\n", "\n", "", "", "", "return", "events_path_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.plot_curve": [[85, 119], ["max", "range", "data_list[].keys", "fig_ax.legend", "fig_ax.grid", "fig_ax.set_xlabel", "fig_ax.set_ylabel", "warnings.filterwarnings", "fig_ax.set_xlim", "fig_ax.title.set_text", "pandas.concat", "pd.concat.mean", "pd.concat.std", "mean_data_k.tolist.tolist", "fig_ax.plot", "fig_ax.fill_between", "data_list[].keys", "fig_ax.set_ylim", "len", "textwrap.wrap", "range", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "plot_curve", "(", "data_list", ",", "y_label", ",", "fig_ax", ",", "subplot_title", ",", "y_lim", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plot curve of metrics or losses for each epoch.\n\n    Args:\n        data_list (list): list of pd.DataFrame, one for each path_output\n        y_label (str): Label for the y-axis.\n        fig_ax (plt.subplot):\n        subplot_title (str): Title of the subplot\n        y_lim (list): List of the lower and upper limits of the y-axis.\n    \"\"\"", "\n", "# Create count of the number of epochs", "\n", "max_nb_epoch", "=", "max", "(", "[", "len", "(", "data_list", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "data_list", ")", ")", "]", ")", "\n", "epoch_count", "=", "range", "(", "1", ",", "max_nb_epoch", "+", "1", ")", "\n", "\n", "for", "k", "in", "data_list", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "        ", "data_k", "=", "pd", ".", "concat", "(", "[", "data_list", "[", "i", "]", "[", "k", "]", "for", "i", "in", "range", "(", "len", "(", "data_list", ")", ")", "]", ",", "axis", "=", "1", ")", "\n", "mean_data_k", "=", "data_k", ".", "mean", "(", "axis", "=", "1", ",", "skipna", "=", "True", ")", "\n", "std_data_k", "=", "data_k", ".", "std", "(", "axis", "=", "1", ",", "skipna", "=", "True", ")", "\n", "std_minus_data_k", "=", "(", "mean_data_k", "-", "std_data_k", ")", ".", "tolist", "(", ")", "\n", "std_plus_data_k", "=", "(", "mean_data_k", "+", "std_data_k", ")", ".", "tolist", "(", ")", "\n", "mean_data_k", "=", "mean_data_k", ".", "tolist", "(", ")", "\n", "fig_ax", ".", "plot", "(", "epoch_count", ",", "mean_data_k", ",", ")", "\n", "fig_ax", ".", "fill_between", "(", "epoch_count", ",", "std_minus_data_k", ",", "std_plus_data_k", ",", "alpha", "=", "0.3", ")", "\n", "\n", "", "fig_ax", ".", "legend", "(", "data_list", "[", "0", "]", ".", "keys", "(", ")", ",", "loc", "=", "\"best\"", ")", "\n", "fig_ax", ".", "grid", "(", "linestyle", "=", "'dotted'", ")", "\n", "fig_ax", ".", "set_xlabel", "(", "'Epoch'", ")", "\n", "fig_ax", ".", "set_ylabel", "(", "y_label", ")", "\n", "if", "y_lim", "is", "not", "None", ":", "\n", "        ", "fig_ax", ".", "set_ylim", "(", "y_lim", ")", "\n", "\n", "", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "UserWarning", ")", "\n", "fig_ax", ".", "set_xlim", "(", "[", "1", ",", "max_nb_epoch", "]", ")", "\n", "fig_ax", ".", "title", ".", "set_text", "(", "'\\n'", ".", "join", "(", "wrap", "(", "subplot_title", ",", "80", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.run_plot_training_curves": [[121, 235], ["Path().expanduser.split", "pathlib.Path().is_dir", "enumerate", "loguru.logger.warning", "loguru.logger.info", "pathlib.Path().mkdir", "len", "int", "pathlib.Path().expanduser", "plt_dict[].add_subplot", "training_curve.plot_curve", "events_df_list[].keys", "plt_dict[].savefig", "pathlib.Path", "numpy.ceil", "training_curve.get_events_path_list", "training_curve.tensorboard_retrieve_event", "tensorboard_retrieve_event.to_csv", "events_df_list.append", "matplotlib.figure", "pathlib.Path", "pathlib.Path", "str", "pathlib.Path", "events_df_list[].keys", "k.endswith", "tag.endswith", "plt_dict[].add_subplot", "training_curve.plot_curve", "len", "float", "Path().expanduser.iterdir", "f.name.startswith", "str", "matplotlib.figure", "str", "pathlib.Path", "str", "tag.startswith", "tag.startswith", "pathlib.Path", "str", "pathlib.Path", "str", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.plot_curve", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.get_events_path_list", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.tensorboard_retrieve_event", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.plot_curve"], ["", "def", "run_plot_training_curves", "(", "input_folder", ",", "output_folder", ",", "multiple_training", "=", "False", ",", "learning_rate", "=", "False", ",", "\n", "y_lim_loss", "=", "None", ")", ":", "\n", "    ", "\"\"\"Utility function to plot the training curves and save data as .csv files.\n\n    This function uses the TensorFlow summary that is generated during a training to plot for each epoch:\n\n        - the training against the validation loss,\n        - the metrics computed on the validation sub-dataset,\n        - the learning rate if learning_rate is True.\n\n    It could consider one output path at a time, for example:\n\n    .. image:: https://raw.githubusercontent.com/ivadomed/doc-figures/main/scripts/plot_loss_single.png\n        :width: 600px\n        :align: center\n\n    ... or multiple (using ``multiple_training=True``). In that case, the hard line represents\n    the mean value across the trainings whereas the envelope represents the standard deviation:\n\n    .. image:: https://raw.githubusercontent.com/ivadomed/doc-figures/main/scripts/plot_loss_multiple.png\n        :width: 600px\n        :align: center\n\n    It is also possible to compare multiple trainings (or set of trainings) by listing them\n    in ``-i``, separated by commas:\n\n    .. image:: https://raw.githubusercontent.com/ivadomed/doc-figures/main/scripts/plot_loss_mosaic.png\n        :width: 600px\n        :align: center\n\n    Args:\n        input_folder (str): Input path name. Flag: ``--input``, ``-i``. If using ``--multiple``,\n            this parameter indicates the prefix path of all log directories of interest. To compare\n            trainings (not using ``--multiple``) or set of trainings (using ``--multiple``) with subplots,\n            please list the paths by separating them with commas, e.g. path_output1, path_output2\n        output_folder (str): Output folder. Flag: ``--output``, ``-o``.\n        multiple_training (bool): Indicates if multiple log directories are considered (``True``)\n            or not (``False``). Flag: ``--multiple``. All available folders with ``-i`` as prefix\n            are considered. The plot represents the mean value (hard line) surrounded by the\n            standard deviation (envelope).\n        learning_rate (bool): Indicates if the summary event file for learning rate is considered (``True``)\n            or not (``False``). Flag: ``--lr``. The limits on the y-axis plot are automatically defined.\n        y_lim_loss (list): List of the lower and upper limits of the y-axis of the loss plot, otherwise\n            these limits are automatically defined. Please separate the lower and the upper limit by a\n            comma, e.g. -1,0. Note: for the validation metrics: the y-limits are always 0.0 and 1.0 except\n            for the hausdorff score where the limits are automatically defined.\n    \"\"\"", "\n", "group_list", "=", "input_folder", ".", "split", "(", "\",\"", ")", "\n", "plt_dict", "=", "{", "}", "\n", "\n", "# Create output folder", "\n", "if", "Path", "(", "output_folder", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "f\"Output folder already exists: {output_folder}.\"", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Creating output folder: {output_folder}.\"", ")", "\n", "Path", "(", "output_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "\n", "# Config subplots", "\n", "", "if", "len", "(", "group_list", ")", ">", "1", ":", "\n", "        ", "n_cols", "=", "2", "\n", "n_rows", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "group_list", ")", "/", "float", "(", "n_cols", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "n_cols", ",", "n_rows", "=", "1", ",", "1", "\n", "\n", "", "for", "i_subplot", ",", "input_folder", "in", "enumerate", "(", "group_list", ")", ":", "\n", "        ", "input_folder", "=", "Path", "(", "input_folder", ")", ".", "expanduser", "(", ")", "\n", "# Find training folders:", "\n", "if", "multiple_training", ":", "\n", "            ", "prefix", "=", "input_folder", ".", "name", "\n", "input_folder", "=", "input_folder", ".", "parent", "\n", "input_folder_list", "=", "[", "f", "for", "f", "in", "input_folder", ".", "iterdir", "(", ")", "if", "\n", "f", ".", "name", ".", "startswith", "(", "prefix", ")", "]", "\n", "", "else", ":", "\n", "            ", "prefix", "=", "input_folder", ".", "name", "\n", "input_folder_list", "=", "[", "input_folder", "]", "\n", "\n", "", "events_df_list", "=", "[", "]", "\n", "for", "path_output", "in", "input_folder_list", ":", "\n", "# Find tf folders", "\n", "            ", "events_path_list", "=", "get_events_path_list", "(", "str", "(", "path_output", ")", ",", "learning_rate", ")", "\n", "\n", "# Get data as dataframe and save as .csv file", "\n", "events_vals_df", "=", "tensorboard_retrieve_event", "(", "events_path_list", ")", "\n", "events_vals_df", ".", "to_csv", "(", "Path", "(", "output_folder", ",", "str", "(", "path_output", ".", "name", ")", "+", "\"_training_values.csv\"", ")", ")", "\n", "\n", "# Store data", "\n", "events_df_list", ".", "append", "(", "events_vals_df", ")", "\n", "\n", "# Plot train and valid losses together", "\n", "", "loss_keys", "=", "[", "k", "for", "k", "in", "events_df_list", "[", "0", "]", ".", "keys", "(", ")", "if", "k", ".", "endswith", "(", "\"loss\"", ")", "]", "\n", "if", "i_subplot", "==", "0", ":", "# Init plot", "\n", "            ", "plt_dict", "[", "str", "(", "Path", "(", "output_folder", ",", "\"losses.png\"", ")", ")", "]", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "10", "*", "n_cols", ",", "5", "*", "n_rows", ")", ")", "\n", "", "ax", "=", "plt_dict", "[", "str", "(", "Path", "(", "output_folder", ",", "\"losses.png\"", ")", ")", "]", ".", "add_subplot", "(", "n_rows", ",", "n_cols", ",", "i_subplot", "+", "1", ")", "\n", "plot_curve", "(", "[", "df", "[", "loss_keys", "]", "for", "df", "in", "events_df_list", "]", ",", "\n", "y_label", "=", "\"loss\"", ",", "\n", "fig_ax", "=", "ax", ",", "\n", "subplot_title", "=", "prefix", ",", "\n", "y_lim", "=", "y_lim_loss", ")", "\n", "\n", "# Plot each validation metric and learning rate separately", "\n", "for", "tag", "in", "events_df_list", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "            ", "if", "not", "tag", ".", "endswith", "(", "\"loss\"", ")", ":", "\n", "                ", "if", "i_subplot", "==", "0", ":", "# Init plot", "\n", "                    ", "plt_dict", "[", "str", "(", "Path", "(", "output_folder", ",", "tag", "+", "\".png\"", ")", ")", "]", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "10", "*", "n_cols", ",", "5", "*", "n_rows", ")", ")", "\n", "", "ax", "=", "plt_dict", "[", "str", "(", "Path", "(", "output_folder", ",", "tag", "+", "\".png\"", ")", ")", "]", ".", "add_subplot", "(", "n_rows", ",", "n_cols", ",", "i_subplot", "+", "1", ")", "\n", "y_lim", "=", "None", "if", "(", "tag", ".", "startswith", "(", "\"hausdorff\"", ")", "or", "tag", ".", "startswith", "(", "\"learning_rate\"", ")", ")", "else", "[", "0", ",", "1", "]", "\n", "plot_curve", "(", "data_list", "=", "[", "df", "[", "[", "tag", "]", "]", "for", "df", "in", "events_df_list", "]", ",", "\n", "y_label", "=", "tag", ",", "\n", "fig_ax", "=", "ax", ",", "\n", "subplot_title", "=", "prefix", ",", "\n", "y_lim", "=", "y_lim", ")", "\n", "\n", "", "", "", "for", "fname_out", "in", "plt_dict", ":", "\n", "        ", "plt_dict", "[", "fname_out", "]", ".", "savefig", "(", "fname_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.tensorboard_retrieve_event": [[237, 297], ["collections.defaultdict", "range", "pandas.DataFrame.from_dict", "str().startswith", "tensorboard.backend.event_processing.event_accumulator.EventAccumulator().Reload", "len", "Exception", "str", "list_metrics.append", "str().startswith", "summary_iterators[].Scalars", "str", "str", "list_loss.append", "tensorboard.backend.event_processing.event_accumulator.EventAccumulator", "summary_iterators[].Tags", "summary_iterators[].Scalars", "events.name.split", "str", "str", "range", "summary_iterators[].Tags", "summary_iterators[].Scalars", "events.name.split", "len", "range", "summary_iterators[].Tags", "summary_iterators[].Scalars", "len", "range", "summary_iterators[].Scalars", "len", "summary_iterators[].Scalars"], "function", ["None"], ["", "", "def", "tensorboard_retrieve_event", "(", "events_path_list", ")", ":", "\n", "    ", "\"\"\"Retrieve data from tensorboard summary event.\n\n    Args:\n        events_path_list (list): list of events paths\n\n    Returns:\n        df: a panda dataframe where the columns are the metric or loss and the row are the epochs.\n\n    \"\"\"", "\n", "# Lists of metrics and losses in the same order as in events_path_list", "\n", "list_metrics", "=", "[", "]", "\n", "list_loss", "=", "[", "]", "\n", "for", "events", "in", "events_path_list", ":", "\n", "        ", "if", "str", "(", "events", ".", "name", ")", ".", "startswith", "(", "\"Validation_Metrics_\"", ")", ":", "\n", "            ", "metric_name", "=", "str", "(", "events", ".", "name", ".", "split", "(", "\"Validation_Metrics_\"", ")", "[", "1", "]", ")", "\n", "list_metrics", ".", "append", "(", "metric_name", ")", "\n", "", "elif", "str", "(", "events", ".", "name", ")", ".", "startswith", "(", "\"losses_\"", ")", ":", "\n", "            ", "loss_name", "=", "str", "(", "events", ".", "name", ".", "split", "(", "\"losses_\"", ")", "[", "1", "]", ")", "\n", "list_loss", ".", "append", "(", "loss_name", ")", "\n", "\n", "# Each element in the summary iterator represent an element (e.g., scalars, images..)", "\n", "# stored in the summary for all epochs in the form of event, in the same order as in events_path_list.", "\n", "", "", "summary_iterators", "=", "[", "EventAccumulator", "(", "str", "(", "events", ")", ")", ".", "Reload", "(", ")", "for", "events", "in", "events_path_list", "]", "\n", "\n", "metrics", "=", "defaultdict", "(", "list", ")", "\n", "num_metrics", "=", "0", "\n", "num_loss", "=", "0", "\n", "num_lr", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "summary_iterators", ")", ")", ":", "\n", "        ", "if", "summary_iterators", "[", "i", "]", ".", "Tags", "(", ")", "[", "'scalars'", "]", "==", "[", "'Validation/Metrics'", "]", ":", "\n", "# we create a empty list", "\n", "            ", "out", "=", "[", "0", "for", "i", "in", "range", "(", "len", "(", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"Validation/Metrics\"", ")", ")", ")", "]", "\n", "# we ensure that value are append in the right order by looking at the step value", "\n", "# (which represents the epoch)", "\n", "for", "events", "in", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"Validation/Metrics\"", ")", ":", "\n", "                ", "out", "[", "events", ".", "step", "-", "1", "]", "=", "events", ".", "value", "\n", "# keys are the defined metrics", "\n", "", "metrics", "[", "list_metrics", "[", "num_metrics", "]", "]", "=", "out", "\n", "num_metrics", "+=", "1", "\n", "", "elif", "summary_iterators", "[", "i", "]", ".", "Tags", "(", ")", "[", "'scalars'", "]", "==", "[", "'losses'", "]", ":", "\n", "            ", "out", "=", "[", "0", "for", "i", "in", "range", "(", "len", "(", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"losses\"", ")", ")", ")", "]", "\n", "# we ensure that value are append in the right order by looking at the step value", "\n", "# (which represents the epoch)", "\n", "for", "events", "in", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"losses\"", ")", ":", "\n", "                ", "out", "[", "events", ".", "step", "-", "1", "]", "=", "events", ".", "value", "\n", "", "metrics", "[", "list_loss", "[", "num_loss", "]", "]", "=", "out", "\n", "num_loss", "+=", "1", "\n", "", "elif", "summary_iterators", "[", "i", "]", ".", "Tags", "(", ")", "[", "'scalars'", "]", "==", "[", "'learning_rate'", "]", ":", "\n", "            ", "out", "=", "[", "0", "for", "i", "in", "range", "(", "len", "(", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"learning_rate\"", ")", ")", ")", "]", "\n", "for", "events", "in", "summary_iterators", "[", "i", "]", ".", "Scalars", "(", "\"learning_rate\"", ")", ":", "\n", "                ", "out", "[", "events", ".", "step", "-", "1", "]", "=", "events", ".", "value", "\n", "", "metrics", "[", "'learning_rate'", "]", "=", "out", "\n", "num_lr", "+=", "1", "\n", "\n", "", "", "if", "num_loss", "==", "0", "and", "num_metrics", "==", "0", "and", "num_lr", "==", "0", ":", "\n", "        ", "raise", "Exception", "(", "'No metrics, losses or learning rate found in the event'", ")", "\n", "", "metrics_df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "metrics", ")", "\n", "return", "metrics_df", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.main": [[299, 308], ["ivadomed.utils.init_ivadomed", "training_curve.get_parser", "ivadomed.utils.get_arguments", "training_curve.run_plot_training_curves", "int", "imed_utils.get_arguments.ylim_loss.split"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.training_curve.run_plot_training_curves"], ["", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "y_lim_loss", "=", "[", "int", "(", "y", ")", "for", "y", "in", "args", ".", "ylim_loss", ".", "split", "(", "','", ")", "]", "if", "args", ".", "ylim_loss", "else", "None", "\n", "\n", "run_plot_training_curves", "(", "input_folder", "=", "args", ".", "input", ",", "output_folder", "=", "args", ".", "output", ",", "\n", "multiple_training", "=", "args", ".", "multiple", ",", "learning_rate", "=", "args", ".", "learning_rate", ",", "\n", "y_lim_loss", "=", "y_lim_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.HyperparameterOption.__init__": [[332, 338], ["automate_training.HyperparameterOption.create_name_str"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.HyperparameterOption.create_name_str"], ["def", "__init__", "(", "self", ",", "base_key", "=", "None", ",", "option", "=", "None", ",", "base_option", "=", "None", ")", ":", "\n", "        ", "self", ".", "base_key", "=", "base_key", "\n", "self", ".", "option", "=", "option", "\n", "self", ".", "base_option", "=", "base_option", "\n", "self", ".", "name", "=", "None", "\n", "self", ".", "create_name_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.HyperparameterOption.__eq__": [[339, 341], ["None"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "base_key", "==", "other", ".", "base_key", "and", "self", ".", "option", "==", "other", ".", "option", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.HyperparameterOption.create_name_str": [[342, 344], ["str().replace", "str", "str"], "methods", ["None"], ["", "def", "create_name_str", "(", "self", ")", ":", "\n", "        ", "self", ".", "name", "=", "\"-\"", "+", "str", "(", "self", ".", "base_key", ")", "+", "\"=\"", "+", "str", "(", "self", ".", "base_option", ")", ".", "replace", "(", "\"/\"", ",", "\"_\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_parser": [[42, 74], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--config\"", ",", "required", "=", "True", ",", "help", "=", "\"Base config file path.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-ch\"", ",", "\"--config-hyper\"", ",", "dest", "=", "\"config_hyper\"", ",", "required", "=", "True", ",", "\n", "help", "=", "\"JSON file where hyperparameters to experiment are listed.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "parser", ".", "add_argument", "(", "\"-pd\"", ",", "\"--path-data\"", ",", "required", "=", "False", ",", "help", "=", "\"Path to BIDS data.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"-n\"", ",", "\"--n-iterations\"", ",", "dest", "=", "\"n_iterations\"", ",", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "help", "=", "\"Number of times to run each config.\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"--all-combin\"", ",", "dest", "=", "'all_combin'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"To run all combinations of config\"", ")", ",", "\n", "parser", ".", "add_argument", "(", "\"-m\"", ",", "\"--multi-params\"", ",", "dest", "=", "\"multi_params\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"To change multiple parameters at once.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--run-test\"", ",", "dest", "=", "'run_test'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Evaluate the trained model on the testing sub-set.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--fixed-split\"", ",", "dest", "=", "'fixed_split'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Keep a constant dataset split for all configs and iterations\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-l\"", ",", "\"--all-logs\"", ",", "dest", "=", "\"all_logs\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Keep all log directories for each iteration.\"", ")", "\n", "parser", ".", "add_argument", "(", "'-t'", ",", "'--thr-increment'", ",", "dest", "=", "\"thr_increment\"", ",", "required", "=", "False", ",", "type", "=", "float", ",", "\n", "help", "=", "\"\"\"A threshold analysis is performed at the end of the training using\n                                the trained model and the validation sub-dataset to find the optimal\n                                binarization threshold. The specified value indicates the increment\n                                between 0 and 1 used during the analysis (e.g. 0.1).\"\"\"", ",", "\n", "metavar", "=", "imed_utils", ".", "Metavar", ".", "float", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output_dir\"", ",", "required", "=", "False", ",", "\n", "help", "=", "\"Output Folder.\"", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.train_worker": [[76, 110], ["torch.current_process", "open", "json.dump", "int", "ivadomed.main.run_command", "loguru.logger.exception", "loguru.logger.info", "sys.exc_info"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_command"], ["", "def", "train_worker", "(", "config", ",", "thr_incr", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        config (dict): dictionary containing configuration details.\n        thr_incr (float): A threshold analysis is performed at the end of the training\n            using the trained model and the validation sub-dataset to find the optimal binarization\n            threshold. The specified value indicates the increment between 0 and 1 used during the\n            ROC analysis (e.g. 0.1). Flag: ``-t``, ``--thr-increment``\n    \"\"\"", "\n", "current", "=", "mp", ".", "current_process", "(", ")", "\n", "# ID of process used to assign a GPU", "\n", "ID", "=", "int", "(", "current", ".", "name", "[", "-", "1", "]", ")", "-", "1", "\n", "\n", "# Use GPU i from the array specified in the config file", "\n", "config", "[", "ConfigKW", ".", "GPU_IDS", "]", "=", "[", "config", "[", "ConfigKW", ".", "GPU_IDS", "]", "[", "ID", "]", "]", "\n", "\n", "# Call ivado cmd_train", "\n", "try", ":", "\n", "# Save best validation score", "\n", "        ", "config", "[", "ConfigKW", ".", "COMMAND", "]", "=", "\"train\"", "\n", "best_training_dice", ",", "best_training_loss", ",", "best_validation_dice", ",", "best_validation_loss", "=", "ivado", ".", "run_command", "(", "config", ",", "thr_increment", "=", "thr_incr", ")", "\n", "\n", "", "except", "Exception", ":", "\n", "        ", "logger", ".", "exception", "(", "'Got exception on main handler'", ")", "\n", "logger", ".", "info", "(", "\"Unexpected error:\"", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", "\n", "raise", "\n", "\n", "# Save config file in output path", "\n", "", "config_copy", "=", "open", "(", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "+", "\"/config_file.json\"", ",", "\"w\"", ")", "\n", "json", ".", "dump", "(", "config", ",", "config_copy", ",", "indent", "=", "4", ")", "\n", "\n", "return", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ",", "best_training_dice", ",", "best_training_loss", ",", "best_validation_dice", ",", "best_validation_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.test_worker": [[112, 133], ["torch.current_process", "int", "ivadomed.main.run_command", "loguru.logger.exception", "loguru.logger.info", "sys.exc_info"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.main.run_command"], ["", "def", "test_worker", "(", "config", ")", ":", "\n", "# Call ivado cmd_eval", "\n", "\n", "    ", "current", "=", "mp", ".", "current_process", "(", ")", "\n", "# ID of process used to assign a GPU", "\n", "ID", "=", "int", "(", "current", ".", "name", "[", "-", "1", "]", ")", "-", "1", "\n", "\n", "# Use GPU i from the array specified in the config file", "\n", "config", "[", "ConfigKW", ".", "GPU_IDS", "]", "=", "[", "config", "[", "ConfigKW", ".", "GPU_IDS", "]", "[", "ID", "]", "]", "\n", "\n", "try", ":", "\n", "# Save best test score", "\n", "        ", "config", "[", "ConfigKW", ".", "COMMAND", "]", "=", "\"test\"", "\n", "df_results", ",", "test_dice", "=", "ivado", ".", "run_command", "(", "config", ")", "\n", "\n", "", "except", "Exception", ":", "\n", "        ", "logger", ".", "exception", "(", "'Got exception on main handler'", ")", "\n", "logger", ".", "info", "(", "\"Unexpected error:\"", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", "\n", "raise", "\n", "\n", "", "return", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ",", "test_dice", ",", "df_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.split_dataset": [[135, 185], ["pathlib.Path", "ivadomed.loader.bids_dataframe.BidsDataframe", "ivadomed.loader.utils.get_new_subject_file_split", "joblib.dump", "pathlib.Path.is_dir", "loguru.logger.info", "pathlib.Path.mkdir", "loguru.logger.info", "str", "ivadomed.keywords.ConfigKW.SPLIT_PATH"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_new_subject_file_split"], ["", "def", "split_dataset", "(", "initial_config", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        initial_config (dict): The original config file, which we use as a basis from which\n            to modify our hyperparameters.\n\n            .. code-block:: JSON\n\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"DiceLoss\"}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/\"\n                }\n    \"\"\"", "\n", "loader_parameters", "=", "initial_config", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "\n", "path_output", "=", "Path", "(", "initial_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ")", "\n", "if", "not", "path_output", ".", "is_dir", "(", ")", ":", "\n", "        ", "logger", ".", "info", "(", "f'Creating output path: {path_output}'", ")", "\n", "path_output", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f'Output path already exists: {path_output}'", ")", "\n", "\n", "", "bids_df", "=", "BidsDataframe", "(", "loader_parameters", ",", "str", "(", "path_output", ")", ",", "derivatives", "=", "True", ")", "\n", "\n", "train_lst", ",", "valid_lst", ",", "test_lst", "=", "imed_loader_utils", ".", "get_new_subject_file_split", "(", "\n", "df", "=", "bids_df", ".", "df", ",", "\n", "data_testing", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "DATA_TESTING", "]", ",", "\n", "split_method", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "SPLIT_METHOD", "]", ",", "\n", "random_seed", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "RANDOM_SEED", "]", ",", "\n", "train_frac", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "TRAIN_FRACTION", "]", ",", "\n", "test_frac", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "TEST_FRACTION", "]", ",", "\n", "path_output", "=", "\"./\"", ",", "\n", "balance", "=", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "BALANCE", "]", "if", "SplitDatasetKW", ".", "BALANCE", "in", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "else", "None", "\n", ")", "\n", "\n", "# save the subject distribution", "\n", "split_dct", "=", "{", "'train'", ":", "train_lst", ",", "'valid'", ":", "valid_lst", ",", "'test'", ":", "test_lst", "}", "\n", "split_path", "=", "\"./\"", "+", "\"common_split_datasets.joblib\"", "\n", "joblib", ".", "dump", "(", "split_dct", ",", "split_path", ")", "\n", "initial_config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "FNAME_SPLIT", "]", "=", "split_path", "\n", "return", "initial_config", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.make_config_list": [[187, 294], ["set", "list", "itertools.combinations", "automate_training.keys_are_unique", "automate_training.get_base_keys", "numpy.min", "range", "len", "copy.deepcopy", "config_list.append", "base_key_dict[].append", "copy.deepcopy", "base_key_dict.keys", "config_list.append", "copy.deepcopy", "automate_training.update_dict", "folder_name_suffix.translate.translate", "folder_name_suffix.translate.translate", "config_list.append", "automate_training.update_dict", "folder_name_suffix.translate.translate", "folder_name_suffix.translate.translate", "len", "automate_training.update_dict", "folder_name_suffix.translate.translate", "folder_name_suffix.translate.translate", "base_key_dict.keys", "ord", "ord", "ord", "ord", "ord", "ord"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.keys_are_unique", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_base_keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.update_dict", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.update_dict", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.update_dict", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "make_config_list", "(", "param_list", ",", "initial_config", ",", "all_combin", ",", "multi_params", ")", ":", "\n", "    ", "\"\"\"Create a list of config dictionaries corresponding to different hyperparameters.\n\n    Args:\n        param_list (list)(HyperparameterOption): A list of the different hyperparameter options.\n        initial_config (dict): The original config file, which we use as a basis from which\n            to modify our hyperparameters.\n\n            .. code-block:: JSON\n\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"DiceLoss\"}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/\"\n                }\n        all_combin (bool): If true, combine the hyperparameters combinatorically.\n        multi_params (bool): If true, combine the hyperparameters by index in the list, i.e.\n            all the first elements, then all the second elements, etc.\n\n    Returns:\n        list, dict: A list of configuration dictionaries, modified by the hyperparameters.\n\n        .. code-block:: python\n\n            config_list = [\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"DiceLoss\"}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/-loss={'name': 'DiceLoss'}\"\n                },\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"FocalLoss\", \"gamma\": 0.2, \"alpha\": 0.5}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/-loss={'name': 'FocalLoss', 'gamma': 0.2, 'alpha': 0.5}\"\n                },\n                # etc...\n            ]\n\n    \"\"\"", "\n", "config_list", "=", "[", "]", "\n", "if", "all_combin", ":", "\n", "        ", "keys", "=", "set", "(", "[", "hyper_option", ".", "base_key", "for", "hyper_option", "in", "param_list", "]", ")", "\n", "for", "combination", "in", "list", "(", "itertools", ".", "combinations", "(", "param_list", ",", "len", "(", "keys", ")", ")", ")", ":", "\n", "            ", "if", "keys_are_unique", "(", "combination", ")", ":", "\n", "                ", "new_config", "=", "copy", ".", "deepcopy", "(", "initial_config", ")", "\n", "path_output", "=", "new_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "\n", "for", "hyper_option", "in", "combination", ":", "\n", "                    ", "new_config", "=", "update_dict", "(", "new_config", ",", "hyper_option", ".", "option", ",", "hyper_option", ".", "base_key", ")", "\n", "folder_name_suffix", "=", "hyper_option", ".", "name", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "None", "for", "i", "in", "'[]}{ \\''", "}", ")", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "'-'", "for", "i", "in", "':=,'", "}", ")", "\n", "path_output", "=", "path_output", "+", "folder_name_suffix", "\n", "", "new_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "=", "path_output", "\n", "config_list", ".", "append", "(", "new_config", ")", "\n", "", "", "", "elif", "multi_params", ":", "\n", "        ", "base_keys", "=", "get_base_keys", "(", "param_list", ")", "\n", "base_key_dict", "=", "{", "key", ":", "[", "]", "for", "key", "in", "base_keys", "}", "\n", "for", "hyper_option", "in", "param_list", ":", "\n", "            ", "base_key_dict", "[", "hyper_option", ".", "base_key", "]", ".", "append", "(", "hyper_option", ")", "\n", "", "max_length", "=", "np", ".", "min", "(", "[", "len", "(", "base_key_dict", "[", "base_key", "]", ")", "for", "base_key", "in", "base_key_dict", ".", "keys", "(", ")", "]", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "max_length", ")", ":", "\n", "            ", "new_config", "=", "copy", ".", "deepcopy", "(", "initial_config", ")", "\n", "path_output", "=", "new_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "\n", "for", "key", "in", "base_key_dict", ".", "keys", "(", ")", ":", "\n", "                ", "hyper_option", "=", "base_key_dict", "[", "key", "]", "[", "i", "]", "\n", "new_config", "=", "update_dict", "(", "new_config", ",", "hyper_option", ".", "option", ",", "hyper_option", ".", "base_key", ")", "\n", "folder_name_suffix", "=", "hyper_option", ".", "name", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "None", "for", "i", "in", "'[]}{ \\''", "}", ")", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "'-'", "for", "i", "in", "':=,'", "}", ")", "\n", "path_output", "=", "path_output", "+", "folder_name_suffix", "\n", "", "new_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "=", "path_output", "\n", "config_list", ".", "append", "(", "new_config", ")", "\n", "", "", "else", ":", "\n", "        ", "for", "hyper_option", "in", "param_list", ":", "\n", "            ", "new_config", "=", "copy", ".", "deepcopy", "(", "initial_config", ")", "\n", "update_dict", "(", "new_config", ",", "hyper_option", ".", "option", ",", "hyper_option", ".", "base_key", ")", "\n", "folder_name_suffix", "=", "hyper_option", ".", "name", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "None", "for", "i", "in", "'[]}{ \\''", "}", ")", "\n", "folder_name_suffix", "=", "folder_name_suffix", ".", "translate", "(", "{", "ord", "(", "i", ")", ":", "'-'", "for", "i", "in", "':=,'", "}", ")", "\n", "new_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "=", "initial_config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "+", "folder_name_suffix", "\n", "config_list", ".", "append", "(", "new_config", ")", "\n", "\n", "", "", "return", "config_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_param_list": [[346, 372], ["my_dict.items", "type", "automate_training.get_param_list", "reversed", "automate_training.HyperparameterOption", "get_param_list.append", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_param_list"], ["", "", "def", "get_param_list", "(", "my_dict", ",", "param_list", ",", "superkeys", ")", ":", "\n", "    ", "\"\"\"Recursively create the list of hyperparameter options.\n\n    Args:\n        my_dict (dict): A dictionary of parameters.\n        param_list (list)(HyperparameterOption): A list of HyperparameterOption objects.\n        superkeys (list)(str): TODO\n\n    Returns:\n        list, HyperparameterOption: A list of HyperparameterOption objects.\n    \"\"\"", "\n", "for", "key", ",", "value", "in", "my_dict", ".", "items", "(", ")", ":", "\n", "        ", "if", "type", "(", "value", ")", "is", "list", ":", "\n", "            ", "for", "element", "in", "value", ":", "\n", "                ", "dict_prev", "=", "{", "key", ":", "element", "}", "\n", "for", "superkey", "in", "reversed", "(", "superkeys", ")", ":", "\n", "                    ", "dict_new", "=", "{", "}", "\n", "dict_new", "[", "superkey", "]", "=", "dict_prev", "\n", "", "if", "len", "(", "superkeys", ")", "==", "0", ":", "\n", "                    ", "dict_new", "=", "dict_prev", "\n", "", "hyper_option", "=", "HyperparameterOption", "(", "base_key", "=", "key", ",", "option", "=", "dict_new", ",", "\n", "base_option", "=", "element", ")", "\n", "param_list", ".", "append", "(", "hyper_option", ")", "\n", "", "", "else", ":", "\n", "            ", "param_list", "=", "get_param_list", "(", "value", ",", "param_list", ",", "superkeys", "+", "[", "key", "]", ")", "\n", "", "", "return", "param_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.update_dict": [[374, 435], ["u.items", "isinstance", "automate_training.update_dict", "d.get"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.update_dict"], ["", "def", "update_dict", "(", "d", ",", "u", ",", "base_key", ")", ":", "\n", "    ", "\"\"\"Update a given dictionary recursively with a new sub-dictionary.\n\n    Example 1:\n\n    .. code-block:: python\n\n        d = {\n            'foo': {\n                'bar': 'some example text',\n                'baz': {'zag': 5}\n            }\n        }\n        u = {'foo': {'baz': {'zag': 7}}}\n        base_key = 'zag'\n\n    >>> print(update_dict(d, u, base_key))\n    {\n        'foo': {\n            'bar': 'some example text',\n            'baz': {'zag': 7}\n        }\n    }\n\n    Example 2:\n\n    .. code-block:: python\n\n        d = {\n            'foo': {\n                'bar': 'some example text',\n                'baz': {'zag': 5}\n            }\n        }\n        u = {'foo': {'baz': {'zag': 7}}}\n        base_key = 'foo'\n\n    >>> print(update_dict(d, u, base_key))\n    {\n        'foo': {\n            'baz': {'zag': 7}\n        }\n    }\n\n    Args:\n        d (dict): A dictionary to update.\n        u (dict): A subdictionary to update the original one with.\n        base_key (str): the string indicating which level to update.\n\n    Returns:\n        dict: An updated dictionary.\n\n    \"\"\"", "\n", "for", "k", ",", "v", "in", "u", ".", "items", "(", ")", ":", "\n", "        ", "if", "k", "==", "base_key", ":", "\n", "            ", "d", "[", "k", "]", "=", "v", "\n", "", "elif", "isinstance", "(", "v", ",", "collections", ".", "abc", ".", "Mapping", ")", ":", "\n", "            ", "d", "[", "k", "]", "=", "update_dict", "(", "d", ".", "get", "(", "k", ",", "{", "}", ")", ",", "v", ",", "base_key", ")", "\n", "", "else", ":", "\n", "            ", "d", "[", "k", "]", "=", "v", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.keys_are_unique": [[437, 450], ["set", "len", "len"], "function", ["None"], ["", "def", "keys_are_unique", "(", "hyperparam_list", ")", ":", "\n", "    ", "\"\"\"Check if the ``base_keys`` in a list of ``HyperparameterOption`` objects are unique.\n\n    Args:\n        hyperparam_list (list)(HyperparameterOption): a list of hyperparameter options.\n\n    Returns:\n        bool: True if all the ``base_keys`` are unique, otherwise False.\n\n    \"\"\"", "\n", "keys", "=", "[", "item", ".", "base_key", "for", "item", "in", "hyperparam_list", "]", "\n", "keys", "=", "set", "(", "keys", ")", "\n", "return", "len", "(", "keys", ")", "==", "len", "(", "hyperparam_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_base_keys": [[452, 468], ["base_keys.append"], "function", ["None"], ["", "def", "get_base_keys", "(", "hyperparam_list", ")", ":", "\n", "    ", "\"\"\"Get a list of base_keys from a param_list.\n\n    Args:\n        hyperparam_list (list)(HyperparameterOption): a list of hyperparameter options.\n\n    Returns:\n        base_keys (list)(str): a list of base_keys.\n\n    \"\"\"", "\n", "base_keys_all", "=", "[", "hyper_option", ".", "base_key", "for", "hyper_option", "in", "hyperparam_list", "]", "\n", "base_keys", "=", "[", "]", "\n", "for", "base_key", "in", "base_keys_all", ":", "\n", "        ", "if", "base_key", "not", "in", "base_keys", ":", "\n", "            ", "base_keys", ".", "append", "(", "base_key", ")", "\n", "", "", "return", "base_keys", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.format_results": [[470, 482], ["pandas.DataFrame.from_dict", "list", "list.append", "pd.DataFrame.from_dict.set_index().join", "results_df.sort_values.reset_index", "results_df.sort_values.sort_values", "set", "results_df.sort_values.set_index", "pd.DataFrame.from_dict.set_index", "list", "hyper_option.option.keys"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "format_results", "(", "results_df", ",", "config_list", ",", "param_list", ")", ":", "\n", "    ", "\"\"\"Merge config and results in a df.\"\"\"", "\n", "\n", "config_df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "config_list", ")", "\n", "keep", "=", "list", "(", "set", "(", "[", "list", "(", "hyper_option", ".", "option", ".", "keys", "(", ")", ")", "[", "0", "]", "for", "hyper_option", "in", "param_list", "]", ")", ")", "\n", "keep", ".", "append", "(", "ConfigKW", ".", "PATH_OUTPUT", ")", "\n", "config_df", "=", "config_df", "[", "keep", "]", "\n", "\n", "results_df", "=", "config_df", ".", "set_index", "(", "ConfigKW", ".", "PATH_OUTPUT", ")", ".", "join", "(", "results_df", ".", "set_index", "(", "ConfigKW", ".", "PATH_OUTPUT", ")", ")", "\n", "results_df", "=", "results_df", ".", "reset_index", "(", ")", "\n", "results_df", "=", "results_df", ".", "sort_values", "(", "by", "=", "[", "'best_validation_loss'", "]", ")", "\n", "return", "results_df", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.automate_training": [[484, 792], ["ivadomed.config_manager.ConfigurationManager().get_config", "automate_training.get_param_list", "automate_training.make_config_list", "torch.get_context", "loguru.logger.info", "pandas.DataFrame", "pandas.DataFrame", "pandas.DataFrame", "automate_training.format_results", "pd.concat.to_csv", "loguru.logger.info", "loguru.logger.info", "pathlib.Path().mkdir", "automate_training.split_dataset", "pathlib.Path().open", "json.load", "mp.get_context.Pool", "range", "str", "ivadomed.scripts.compare_models.compute_statistics", "ivadomed.visualize_and_compare_models", "pathlib.Path().exists", "ivadomed.config_manager.ConfigurationManager", "split_dataset.get", "pandas.DataFrame", "pandas.concat", "pd.concat.to_csv", "pd.concat.to_csv", "pathlib.Path", "pathlib.Path", "pathlib.Path", "len", "random.randint", "pool.map", "pool.map", "enumerate", "pandas.concat", "pandas.DataFrame", "pd.DataFrame.set_index().join", "combined_df.reset_index.reset_index", "str", "str", "range", "pathlib.Path", "functools.partial", "pathlib.Path", "pathlib.Path", "ivadomed.config_manager.ConfigurationManager().get_config", "new_config_list.append", "pd.concat.rename", "pd.concat.rename", "enumerate", "df_lst.append", "pd.DataFrame.set_index", "pathlib.Path", "pathlib.Path", "len", "pathlib.Path.is_dir", "df.mean", "df.std", "pandas.concat", "pandas.concat", "pd.concat.mean", "pd.concat.std", "pandas.concat", "result[].split", "pd.concat.rename", "pd.DataFrame.set_index", "config[].replace", "shutil.rmtree", "ivadomed.config_manager.ConfigurationManager", "str().zfill", "str", "loguru.logger.info", "str", "df.mean", "str().zfill", "str().zfill", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.get_param_list", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.make_config_list", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.format_results", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.split_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.compare_models.compute_statistics", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.visualize_and_compare_models", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.ConfigurationManager.get_config"], ["", "def", "automate_training", "(", "file_config", ",", "file_config_hyper", ",", "fixed_split", ",", "all_combin", ",", "path_data", "=", "None", ",", "\n", "n_iterations", "=", "1", ",", "run_test", "=", "False", ",", "all_logs", "=", "False", ",", "thr_increment", "=", "None", ",", "\n", "multi_params", "=", "False", ",", "output_dir", "=", "None", ",", "plot_comparison", "=", "False", ")", ":", "\n", "    ", "\"\"\"Automate multiple training processes on multiple GPUs.\n\n    Hyperparameter optimization of models is tedious and time-consuming. This function automatizes\n    this optimization across multiple GPUs. It runs trainings, on the same training and validation\n    datasets, by combining a given set of parameters and set of values for each of these parameters.\n    Results are collected for each combination and reported into a dataframe to allow their\n    comparison. The script efficiently allocates each training to one of the available GPUs.\n\n    Usage Example::\n\n        ivadomed_automate_training -c config.json -p config_hyper.json -n n_iterations\n\n    .. csv-table:: Example of dataframe\n       :file: ../../images/detailed_results.csv\n\n    Config File:\n\n        The config file is the standard config file used in ``ivadomed`` functions. We use this\n        as the basis. We call a key of this config file a ``category``. In the example below,\n        we would say that ``training_parameters``, ``default_model``, and ``path_output`` are\n        ``categories``.\n\n        .. code-block:: JSON\n\n            {\n                \"training_parameters\": {\n                    \"batch_size\": 18,\n                    \"loss\": {\"name\": \"DiceLoss\"}\n                },\n                \"default_model\":     {\n                    \"name\": \"Unet\",\n                    \"dropout_rate\": 0.3,\n                    \"depth\": 3\n                },\n                \"model_name\": \"seg_tumor_t2\",\n                \"path_output\": \"./tmp/\"\n            }\n\n    Hyperparameter Config File:\n\n        The hyperparameter config file should have the same layout as the config file. To select\n        a hyperparameter you would like to vary, just list the different options under the\n        appropriate key, which we call the ``base_key``. In the example below, we want to vary the\n        ``loss``, ``depth``, and ``model_name``; these are our 3 ``base_keys``. As you can see,\n        we have listed our different options for these keys. For ``depth``, we have listed\n        ``2``, ``3``, and ``4`` as our different options.\n        How we implement this depends on 3 settings: ``all_combin``, ``multi_param``,\n        or the default.\n\n        .. code-block:: JSON\n\n            {\n              \"training_parameters\": {\n                \"loss\": [\n                  {\"name\": \"DiceLoss\"},\n                  {\"name\": \"FocalLoss\", \"gamma\": 0.2, \"alpha\" : 0.5}\n                ],\n              },\n              \"default_model\": {\"depth\": [2, 3, 4]},\n              \"model_name\": [\"seg_sc_t2star\", \"find_disc_t1\"]\n            }\n\n    Default:\n\n        The default option is to change only one parameter at a time relative to the base\n        config file. We then create a list of config options, called ``config_list``.\n        Using the examples above, we would have ``2 + 2 + 3 = 7`` different config options:\n\n        .. code-block:: python\n\n            config_list = [\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"DiceLoss\"}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/-loss={'name': 'DiceLoss'}\"\n                },\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"FocalLoss\", \"gamma\": 0.2, \"alpha\": 0.5}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 3\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/-loss={'name': 'FocalLoss', 'gamma': 0.2, 'alpha': 0.5}\"\n                },\n                {\n                    \"training_parameters\": {\n                        \"batch_size\": 18,\n                        \"loss\": {\"name\": \"DiceLoss\"}\n                    },\n                    \"default_model\":     {\n                        \"name\": \"Unet\",\n                        \"dropout_rate\": 0.3,\n                        \"depth\": 2\n                    },\n                    \"model_name\": \"seg_tumor_t2\",\n                    \"path_output\": \"./tmp/-depth=2\"\n                },\n                # etc ...\n            ]\n\n\n    All Combinations:\n\n        If we select the ``all_combin`` option, we will create a list of configuration options\n        combinatorically. Using the config examples above, we would have ``2 * 3 * 2 = 12``\n        different config options. I'm not going to write out the whole ``config_list`` because it's\n        quite long, but here are the combinations:\n\n        .. code-block::\n\n            loss = DiceLoss, depth = 2, model_name = \"seg_sc_t2star\"\n            loss = FocalLoss, depth = 2, model_name = \"seg_sc_t2star\"\n            loss = DiceLoss, depth = 3, model_name = \"seg_sc_t2star\"\n            loss = FocalLoss, depth = 3, model_name = \"seg_sc_t2star\"\n            loss = DiceLoss, depth = 4, model_name = \"seg_sc_t2star\"\n            loss = FocalLoss, depth = 4, model_name = \"seg_sc_t2star\"\n            loss = DiceLoss, depth = 2, model_name = \"find_disc_t1\"\n            loss = FocalLoss, depth = 2, model_name = \"find_disc_t1\"\n            loss = DiceLoss, depth = 3, model_name = \"find_disc_t1\"\n            loss = FocalLoss, depth = 3, model_name = \"find_disc_t1\"\n            loss = DiceLoss, depth = 4, model_name = \"find_disc_t1\"\n            loss = FocalLoss, depth = 4, model_name = \"find_disc_t1\"\n\n    Multiple Parameters:\n\n        The ``multi_params`` option entails changing all the first elements from the list,\n        then all the second parameters from the list, etc. If the lists are different lengths,\n        we will just use the first ``n`` elements. In our example above, the lists are of length\n        2 or 3, so we will only use the first 2 elements:\n\n        .. code-block::\n\n            loss = DiceLoss, depth = 2, model_name = \"seg_sc_t2star\"\n            loss = FocalLoss, depth = 3, model_name = \"find_disc_t1\"\n\n\n    Args:\n        file_config (string): Configuration filename, which is used as skeleton to configure the\n            training. This is the standard config file used in ``ivadomed`` functions. In the\n            code, we call the keys from this config file ``categories``.\n            Flag: ``--config``, ``-c``\n        file_config_hyper (string): json file containing parameters configurations to compare.\n            Parameter \"keys\" of this file need to match the parameter \"keys\" of `config` file.\n            Parameter \"values\" are in a list. Flag: ``--config-hyper``, ``-ch``\n\n            Example::\n\n                {\"default_model\": {\"depth\": [2, 3, 4]}}\n\n        fixed_split (bool): If True, all the experiments are run on the same\n            training/validation/testing subdatasets. Flag: ``--fixed-split``\n        all_combin (bool): If True, all parameters combinations are run. Flag: ``--all-combin``\n        n_iterations (int): Controls the number of time that each experiment (ie set of parameter)\n            are run. Flag: ``--n-iteration``, ``-n``\n        run_test (bool): If True, the trained model is also run on the testing subdataset and violiplots are displayed\n            with the dicescores for each new output folder created.\n            Flag: ``--run-test``\n        all_logs (bool): If True, all the log directories are kept for every iteration.\n            Flag: ``--all-logs``, ``-l``\n        thr_increment (float): A threshold analysis is performed at the end of the training\n            using the trained model and the validation sub-dataset to find the optimal binarization\n            threshold. The specified value indicates the increment between 0 and 1 used during the\n            ROC analysis (e.g. 0.1). Flag: ``-t``, ``--thr-increment``\n        multi_params (bool): If True, more than one parameter will be change at the time from\n            the hyperparameters. All the first elements from the hyperparameters list will be\n            applied, then all the second, etc.\n        output_dir (str): Path to where the results will be saved.\n    \"\"\"", "\n", "if", "output_dir", "and", "not", "Path", "(", "output_dir", ")", ".", "exists", "(", ")", ":", "\n", "        ", "Path", "(", "output_dir", ")", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "if", "not", "output_dir", ":", "\n", "        ", "output_dir", "=", "\"\"", "\n", "\n", "# Load initial config", "\n", "", "initial_config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "file_config", ")", ".", "get_config", "(", ")", "\n", "\n", "if", "path_data", "is", "not", "None", ":", "\n", "        ", "initial_config", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "=", "path_data", "\n", "\n", "# Split dataset if not already done", "\n", "", "if", "fixed_split", "and", "(", "initial_config", ".", "get", "(", "ConfigKW", ".", "SPLIT_PATH", ")", "is", "None", ")", ":", "\n", "        ", "initial_config", "=", "split_dataset", "(", "initial_config", ")", "\n", "\n", "# Hyperparameters values to experiment", "\n", "", "with", "Path", "(", "file_config_hyper", ")", ".", "open", "(", "mode", "=", "\"r\"", ")", "as", "fhandle", ":", "\n", "        ", "config_hyper", "=", "json", ".", "load", "(", "fhandle", ")", "\n", "\n", "", "param_list", "=", "get_param_list", "(", "config_hyper", ",", "[", "]", ",", "[", "]", ")", "\n", "config_list", "=", "make_config_list", "(", "param_list", ",", "initial_config", ",", "all_combin", ",", "multi_params", ")", "\n", "\n", "# CUDA problem when forking process", "\n", "# https://github.com/pytorch/pytorch/issues/2517", "\n", "ctx", "=", "mp", ".", "get_context", "(", "\"spawn\"", ")", "\n", "\n", "# Run all configs on a separate process, with a maximum of n_gpus  processes at a given time", "\n", "logger", ".", "info", "(", "initial_config", "[", "ConfigKW", ".", "GPU_IDS", "]", ")", "\n", "\n", "results_df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "eval_df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "all_mean", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "with", "ctx", ".", "Pool", "(", "processes", "=", "len", "(", "initial_config", "[", "ConfigKW", ".", "GPU_IDS", "]", ")", ")", "as", "pool", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_iterations", ")", ":", "\n", "            ", "if", "not", "fixed_split", ":", "\n", "# Set seed for iteration", "\n", "                ", "seed", "=", "random", ".", "randint", "(", "1", ",", "10001", ")", "\n", "for", "config", "in", "config_list", ":", "\n", "                    ", "config", "[", "ConfigKW", ".", "SPLIT_DATASET", "]", "[", "SplitDatasetKW", ".", "RANDOM_SEED", "]", "=", "seed", "\n", "if", "all_logs", ":", "\n", "                        ", "if", "i", ":", "\n", "                            ", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "=", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ".", "replace", "(", "\"_n=\"", "+", "str", "(", "i", "-", "1", ")", ".", "zfill", "(", "2", ")", ",", "\n", "\"_n=\"", "+", "str", "(", "i", ")", ".", "zfill", "(", "2", ")", ")", "\n", "", "else", ":", "\n", "                            ", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "+=", "\"_n=\"", "+", "str", "(", "i", ")", ".", "zfill", "(", "2", ")", "\n", "\n", "", "", "", "validation_scores", "=", "pool", ".", "map", "(", "partial", "(", "train_worker", ",", "thr_incr", "=", "thr_increment", ")", ",", "config_list", ")", "\n", "\n", "", "val_df", "=", "pd", ".", "DataFrame", "(", "validation_scores", ",", "columns", "=", "[", "\n", "'path_output'", ",", "'best_training_dice'", ",", "'best_training_loss'", ",", "'best_validation_dice'", ",", "\n", "'best_validation_loss'", "]", ")", "\n", "\n", "if", "run_test", ":", "\n", "                ", "new_config_list", "=", "[", "]", "\n", "for", "config", "in", "config_list", ":", "\n", "# Delete path_pred", "\n", "                    ", "path_pred", "=", "Path", "(", "config", "[", "'path_output'", "]", ",", "'pred_masks'", ")", "\n", "if", "path_pred", ".", "is_dir", "(", ")", "and", "n_iterations", ">", "1", ":", "\n", "                        ", "try", ":", "\n", "                            ", "shutil", ".", "rmtree", "(", "str", "(", "path_pred", ")", ")", "\n", "", "except", "OSError", "as", "e", ":", "\n", "                            ", "logger", ".", "info", "(", "f\"Error: {e.filename} - {e.strerror}.\"", ")", "\n", "\n", "# Take the config file within the path_output because binarize_prediction may have been updated", "\n", "", "", "json_path", "=", "Path", "(", "config", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ",", "'config_file.json'", ")", "\n", "new_config", "=", "imed_config_manager", ".", "ConfigurationManager", "(", "str", "(", "json_path", ")", ")", ".", "get_config", "(", ")", "\n", "new_config", "[", "ConfigKW", ".", "GPU_IDS", "]", "=", "config", "[", "ConfigKW", ".", "GPU_IDS", "]", "\n", "new_config_list", ".", "append", "(", "new_config", ")", "\n", "\n", "", "test_results", "=", "pool", ".", "map", "(", "test_worker", ",", "new_config_list", ")", "\n", "\n", "df_lst", "=", "[", "]", "\n", "# Merge all eval df together to have a single excel file", "\n", "for", "j", ",", "result", "in", "enumerate", "(", "test_results", ")", ":", "\n", "                    ", "df", "=", "result", "[", "-", "1", "]", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                        ", "all_mean", "=", "df", ".", "mean", "(", "axis", "=", "0", ")", "\n", "std_metrics", "=", "df", ".", "std", "(", "axis", "=", "0", ")", "\n", "metrics", "=", "pd", ".", "concat", "(", "[", "all_mean", ",", "std_metrics", "]", ",", "sort", "=", "False", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "                        ", "all_mean", "=", "pd", ".", "concat", "(", "[", "all_mean", ",", "df", ".", "mean", "(", "axis", "=", "0", ")", "]", ",", "sort", "=", "False", ",", "axis", "=", "1", ")", "\n", "mean_metrics", "=", "all_mean", ".", "mean", "(", "axis", "=", "1", ")", "\n", "std_metrics", "=", "all_mean", ".", "std", "(", "axis", "=", "1", ")", "\n", "metrics", "=", "pd", ".", "concat", "(", "[", "mean_metrics", ",", "std_metrics", "]", ",", "sort", "=", "False", ",", "axis", "=", "1", ")", "\n", "\n", "", "metrics", ".", "rename", "(", "{", "0", ":", "\"mean\"", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "metrics", ".", "rename", "(", "{", "1", ":", "\"std\"", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "id", "=", "result", "[", "0", "]", ".", "split", "(", "\"_n=\"", ")", "[", "0", "]", "\n", "cols", "=", "metrics", ".", "columns", ".", "values", "\n", "for", "idx", ",", "col", "in", "enumerate", "(", "cols", ")", ":", "\n", "                        ", "metrics", ".", "rename", "(", "{", "col", ":", "col", "+", "\"_\"", "+", "id", "}", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "", "df_lst", ".", "append", "(", "metrics", ")", "\n", "test_results", "[", "j", "]", "=", "result", "[", ":", "2", "]", "\n", "\n", "# Init or add eval results to dataframe", "\n", "", "eval_df", "=", "pd", ".", "concat", "(", "df_lst", ",", "sort", "=", "False", ",", "axis", "=", "1", ")", "\n", "\n", "test_df", "=", "pd", ".", "DataFrame", "(", "test_results", ",", "columns", "=", "[", "'path_output'", ",", "'test_dice'", "]", ")", "\n", "combined_df", "=", "val_df", ".", "set_index", "(", "'path_output'", ")", ".", "join", "(", "test_df", ".", "set_index", "(", "'path_output'", ")", ")", "\n", "combined_df", "=", "combined_df", ".", "reset_index", "(", ")", "\n", "\n", "", "else", ":", "\n", "                ", "combined_df", "=", "val_df", "\n", "\n", "", "results_df", "=", "pd", ".", "concat", "(", "[", "results_df", ",", "combined_df", "]", ")", "\n", "results_df", ".", "to_csv", "(", "str", "(", "Path", "(", "output_dir", ",", "\"temporary_results.csv\"", ")", ")", ")", "\n", "eval_df", ".", "to_csv", "(", "str", "(", "Path", "(", "output_dir", ",", "\"average_eval.csv\"", ")", ")", ")", "\n", "\n", "", "", "results_df", "=", "format_results", "(", "results_df", ",", "config_list", ",", "param_list", ")", "\n", "results_df", ".", "to_csv", "(", "str", "(", "Path", "(", "output_dir", ",", "\"detailed_results.csv\"", ")", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"Detailed results\"", ")", "\n", "logger", ".", "info", "(", "results_df", ")", "\n", "\n", "# Compute avg, std, p-values", "\n", "if", "n_iterations", ">", "1", ":", "\n", "        ", "compute_statistics", "(", "results_df", ",", "n_iterations", ",", "run_test", ")", "\n", "\n", "# If the test is selected, also show the violin plots", "\n", "", "if", "plot_comparison", ":", "\n", "        ", "output_folders", "=", "[", "config_list", "[", "i", "]", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "for", "i", "in", "range", "(", "len", "(", "config_list", ")", ")", "]", "\n", "violin_plots", ".", "visualize_and_compare_models", "(", "ofolders", "=", "output_folders", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.main": [[794, 812], ["ivadomed.utils.init_ivadomed", "automate_training.get_parser", "ivadomed.utils.get_arguments", "automate_training.automate_training", "bool", "bool", "int", "bool", "bool"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.automate_training.automate_training"], ["", "", "def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "\n", "thr_increment", "=", "args", ".", "thr_increment", "if", "args", ".", "thr_increment", "else", "None", "\n", "\n", "automate_training", "(", "file_config", "=", "args", ".", "config", ",", "\n", "file_config_hyper", "=", "args", ".", "config_hyper", ",", "\n", "fixed_split", "=", "bool", "(", "args", ".", "fixed_split", ")", ",", "\n", "all_combin", "=", "bool", "(", "args", ".", "all_combin", ")", ",", "\n", "path_data", "=", "args", ".", "path_data", "if", "args", ".", "path_data", "is", "not", "None", "else", "None", ",", "\n", "n_iterations", "=", "int", "(", "args", ".", "n_iterations", ")", ",", "\n", "run_test", "=", "bool", "(", "args", ".", "run_test", ")", ",", "\n", "all_logs", "=", "args", ".", "all_logs", ",", "\n", "thr_increment", "=", "thr_increment", ",", "\n", "multi_params", "=", "bool", "(", "args", ".", "multi_params", ")", ",", "\n", "output_dir", "=", "args", ".", "output_dir", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.get_parser": [[63, 73], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "sorted"], "function", ["None"], ["def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "required", "=", "True", ",", "\n", "choices", "=", "(", "sorted", "(", "DICT_URL", ")", ")", ",", "\n", "help", "=", "\"Data to download\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "str", ")", "\n", "parser", ".", "add_argument", "(", "\"-k\"", ",", "\"--keep\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Keep existing data in destination directory\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-o\"", ",", "\"--output\"", ",", "required", "=", "False", ",", "\n", "help", "=", "\"Output Folder.\"", ",", "metavar", "=", "imed_utils", ".", "Metavar", ".", "file", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.download_data": [[79, 132], ["isinstance", "Exception", "logger.info", "requests.packages.urllib3.util.Retry", "requests.Session", "requests.Session.mount", "requests.Session.get", "session.get.raise_for_status", "pathlib.Path", "logger.info", "str", "requests.adapters.HTTPAdapter", "pathlib.Path", "cgi.parse_header", "pathlib.Path", "ValueError", "tempfile.mkdtemp", "pathlib.Path.open", "int", "session.get.iter_content", "logger.warning", "exceptions.append", "session.get.headers.get", "urllib.parse.urlparse", "tmp_file.write"], "function", ["None"], ["def", "download_data", "(", "urls", ")", ":", "\n", "    ", "\"\"\"\n    Function used to download the data form github or other mirrors\n    Args:\n        urls (list): List of urls to try.\n\n    Returns:\n        downloaded folder path\n    \"\"\"", "\n", "if", "isinstance", "(", "urls", ",", "str", ")", ":", "\n", "        ", "urls", "=", "[", "urls", "]", "\n", "\n", "", "exceptions", "=", "[", "]", "\n", "\n", "for", "url", "in", "urls", ":", "\n", "        ", "try", ":", "\n", "            ", "logger", ".", "info", "(", "'Trying URL: %s'", "%", "url", ")", "\n", "retry", "=", "Retry", "(", "total", "=", "3", ",", "backoff_factor", "=", "0.5", ",", "status_forcelist", "=", "[", "500", ",", "503", ",", "504", "]", ")", "\n", "session", "=", "requests", ".", "Session", "(", ")", "\n", "session", ".", "mount", "(", "'https://'", ",", "HTTPAdapter", "(", "max_retries", "=", "retry", ")", ")", "\n", "response", "=", "session", ".", "get", "(", "url", ",", "stream", "=", "True", ")", "\n", "response", ".", "raise_for_status", "(", ")", "\n", "\n", "filename", "=", "Path", "(", "urllib", ".", "parse", ".", "urlparse", "(", "url", ")", ".", "path", ")", ".", "name", "\n", "if", "\"Content-Disposition\"", "in", "response", ".", "headers", ":", "\n", "                ", "_", ",", "content", "=", "cgi", ".", "parse_header", "(", "response", ".", "headers", "[", "'Content-Disposition'", "]", ")", "\n", "filename", "=", "content", "[", "\"filename\"", "]", "\n", "\n", "# protect against directory traversal", "\n", "", "filename", "=", "Path", "(", "filename", ")", ".", "name", "\n", "if", "not", "filename", ":", "\n", "# this handles cases where you're loading something like an index page", "\n", "# instead of a specific file. e.g. https://osf.io/ugscu/?action=view.", "\n", "                ", "raise", "ValueError", "(", "\"Unable to determine target filename for URL: %s\"", "%", "(", "url", ",", ")", ")", "\n", "\n", "", "tmp_path", "=", "Path", "(", "tempfile", ".", "mkdtemp", "(", ")", ",", "filename", ")", "\n", "\n", "logger", ".", "info", "(", "'Downloading: %s'", "%", "filename", ")", "\n", "\n", "with", "tmp_path", ".", "open", "(", "mode", "=", "'wb'", ")", "as", "tmp_file", ":", "\n", "                ", "total", "=", "int", "(", "response", ".", "headers", ".", "get", "(", "'content-length'", ",", "1", ")", ")", "\n", "\n", "for", "chunk", "in", "response", ".", "iter_content", "(", "chunk_size", "=", "8192", ")", ":", "\n", "                    ", "if", "chunk", ":", "\n", "                        ", "tmp_file", ".", "write", "(", "chunk", ")", "\n", "\n", "", "", "", "return", "str", "(", "tmp_path", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "logger", ".", "warning", "(", "\"Link download error, trying next mirror (error was: %s)\"", "%", "e", ")", "\n", "exceptions", ".", "append", "(", "e", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Download error'", ",", "exceptions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.unzip": [[134, 154], ["logger.info", "formats.items", "compressed.lower().endswith", "TypeError", "open().extractall", "logger.error", "compressed.lower", "open"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items"], ["", "", "def", "unzip", "(", "compressed", ",", "dest_folder", ")", ":", "\n", "    ", "\"\"\"\n    Extract compressed file to the dest_folder. Can handle .zip, .tar.gz.\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Unzip data to: %s'", "%", "dest_folder", ")", "\n", "\n", "formats", "=", "{", "'.zip'", ":", "zipfile", ".", "ZipFile", ",", "\n", "'.tar.gz'", ":", "tarfile", ".", "open", ",", "\n", "'.tgz'", ":", "tarfile", ".", "open", "}", "\n", "for", "format", ",", "open", "in", "formats", ".", "items", "(", ")", ":", "\n", "        ", "if", "compressed", ".", "lower", "(", ")", ".", "endswith", "(", "format", ")", ":", "\n", "            ", "break", "\n", "", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'ERROR: The file %s is of wrong format'", "%", "(", "compressed", ",", ")", ")", "\n", "\n", "", "try", ":", "\n", "        ", "open", "(", "compressed", ")", ".", "extractall", "(", "dest_folder", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "logger", ".", "error", "(", "\"ERROR: ZIP package corrupted. Please try downloading again.\"", ")", "\n", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data._format_bundles": [[156, 160], ["str.join", "download_data._format_bundles.format_bundle"], "function", ["None"], ["", "", "def", "_format_bundles", "(", ")", ":", "\n", "    ", "def", "format_bundle", "(", "name", ",", "values", ")", ":", "\n", "        ", "return", "f'`{name} <{values[\"url\"]}>`_ : {values[\"description\"]}'", "\n", "", "return", "str", ".", "join", "(", "\"\\n\"", ",", "[", "\"* %s\"", "%", "format_bundle", "(", "name", ",", "values", ")", "for", "name", ",", "values", "in", "DICT_URL", ".", "items", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.install_data": [[162, 262], ["pathlib.Path().mkdir", "download_data.download_data", "tempfile.mkdtemp", "download_data.unzip", "pathlib.Path().iterdir", "bundle_folder.glob", "logger.info", "logger.info", "shutil.rmtree", "shutil.rmtree", "pathlib.Path().exists", "logger.warning", "shutil.rmtree", "path_object.is_dir", "pathlib.Path().iterdir", "pathlib.Path", "path_object.is_dir", "path_object.is_file", "str", "pathlib.Path", "pathlib.Path", "path_object.relative_to", "pathlib.Path", "pathlib.Path.exists", "shutil.copy", "pathlib.Path", "pathlib.Path", "path_object.relative_to", "pathlib.Path", "pathlib.Path.exists", "logger.debug", "logger.warning", "pathlib.Path.unlink", "logger.debug", "str", "str", "pathlib.Path", "logger.debug", "logger.debug", "pathlib.Path.mkdir", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.download_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.unzip"], ["", "def", "install_data", "(", "url", ",", "dest_folder", ",", "keep", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Download a data bundle from an URL and install it in the destination folder.\n\n    Usage example ::\n\n        ivadomed_download_data -d data_testing -o ivado_testing_data\n\n\n    Existing data bundles:\n\n{BUNDLES}\n\n    .. note::\n        The function tries to be smart about the data contents.\n        Examples:\n\n\n        a. If the archive only contains a `README.md`, and the destination folder is `${{dst}}`,\n        `${{dst}}/README.md` will be created.\n        Note: an archive not containing a single folder is commonly known as a \"bomb\" because\n        it puts files anywhere in the current working directory.( see `Tarbomb\n        <https://en.wikipedia.org/wiki/Tar_(computing)#Tarbomb>`_)\n\n\n        b. If the archive contains a `${{dir}}/README.md`, and the destination folder is `${{dst}}`,\n        `${{dst}}/README.md` will be created.\n        Note: typically the package will be called `${{basename}}-${{revision}}.zip` and contain\n        a root folder named `${{basename}}-${{revision}}/` under which all the other files will\n        be located.\n        The right thing to do in this case is to take the files from there and install them\n        in `${{dst}}`.\n        - Uses `download_data()` to retrieve the data.\n        - Uses `unzip()` to extract the bundle.\n\n    Args:\n        url (string): URL or sequence thereof (if mirrors). For this package there is a dictionnary\n            listing existing data bundle with their url. Type ivadomed_download_data -h to see possible value. Flag ``-d``\n        dest_folder (string): destination directory for the data (to be created). If not used the output folder\n            will be the name of the data bundle. Flag ``-o``, ``--output``\n        keep (bool): whether to keep existing data in the destination folder (if it exists). Flag ``-k``, ``--keep``\n    \"\"\"", "\n", "\n", "if", "not", "keep", "and", "Path", "(", "dest_folder", ")", ".", "exists", "(", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "\"Removing existing destination folder \u201c%s\u201d\"", ",", "dest_folder", ")", "\n", "shutil", ".", "rmtree", "(", "dest_folder", ")", "\n", "", "Path", "(", "dest_folder", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "tmp_file", "=", "download_data", "(", "url", ")", "\n", "\n", "extraction_folder", "=", "tempfile", ".", "mkdtemp", "(", ")", "\n", "\n", "unzip", "(", "tmp_file", ",", "extraction_folder", ")", "\n", "\n", "# Identify whether we have a proper archive or a tarbomb", "\n", "has_dir", "=", "False", "\n", "nb_entries", "=", "0", "\n", "for", "path_object", "in", "Path", "(", "extraction_folder", ")", ".", "iterdir", "(", ")", ":", "\n", "        ", "if", "path_object", ".", "name", "in", "(", "IgnoredFolderKW", ".", "MACOSX", ",", ")", ":", "\n", "            ", "continue", "\n", "", "nb_entries", "+=", "1", "\n", "if", "path_object", ".", "is_dir", "(", ")", ":", "\n", "            ", "has_dir", "=", "True", "\n", "\n", "", "", "if", "nb_entries", "==", "1", "and", "has_dir", ":", "\n", "# tarball with single-directory -> go under", "\n", "        ", "for", "path_object", "in", "Path", "(", "extraction_folder", ")", ".", "iterdir", "(", ")", ":", "\n", "            ", "if", "path_object", ".", "name", "in", "(", "IgnoredFolderKW", ".", "MACOSX", ",", ")", ":", "\n", "                ", "continue", "\n", "", "bundle_folder", "=", "path_object", "\n", "", "", "else", ":", "\n", "# bomb scenario -> stay here", "\n", "        ", "bundle_folder", ":", "Path", "=", "Path", "(", "extraction_folder", ")", "\n", "\n", "# Copy over", "\n", "", "for", "path_object", "in", "bundle_folder", ".", "glob", "(", "\"**/*\"", ")", ":", "\n", "        ", "if", "path_object", ".", "is_dir", "(", ")", ":", "\n", "            ", "if", "path_object", ".", "name", "not", "in", "(", "IgnoredFolderKW", ".", "MACOSX", ",", ")", ":", "\n", "                ", "relpath", "=", "path_object", ".", "relative_to", "(", "bundle_folder", ")", "\n", "dstpath", "=", "Path", "(", "dest_folder", ",", "relpath", ")", "\n", "if", "dstpath", ".", "exists", "(", ")", ":", "\n", "                    ", "logger", ".", "debug", "(", "\"- d- %s\"", ",", "str", "(", "relpath", ")", ")", "\n", "", "else", ":", "\n", "                    ", "logger", ".", "debug", "(", "\"- d+ %s\"", ",", "relpath", ")", "\n", "dstpath", ".", "mkdir", "(", "parents", "=", "True", ")", "\n", "", "", "", "if", "path_object", ".", "is_file", "(", ")", ":", "\n", "            ", "relpath", "=", "path_object", ".", "relative_to", "(", "bundle_folder", ")", "\n", "dstpath", "=", "Path", "(", "dest_folder", ",", "relpath", ")", "\n", "if", "dstpath", ".", "exists", "(", ")", ":", "\n", "                ", "logger", ".", "debug", "(", "\"- f! %s\"", ",", "relpath", ")", "\n", "logger", ".", "warning", "(", "\"Updating existing \u201c%s\u201d\"", ",", "dstpath", ")", "\n", "dstpath", ".", "unlink", "(", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "debug", "(", "\"- f+ %s\"", ",", "relpath", ")", "\n", "", "shutil", ".", "copy", "(", "str", "(", "path_object", ")", ",", "str", "(", "dstpath", ")", ")", "\n", "\n", "", "", "logger", ".", "info", "(", "\"Removing temporary folders...\"", ")", "\n", "logger", ".", "info", "(", "\"Folder Created: {}\"", ".", "format", "(", "dest_folder", ")", ")", "\n", "shutil", ".", "rmtree", "(", "str", "(", "Path", "(", "tmp_file", ")", ".", "parent", ")", ")", "\n", "shutil", ".", "rmtree", "(", "extraction_folder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.main": [[271, 291], ["ivadomed.utils.init_ivadomed", "download_data.get_parser", "ivadomed.utils.get_arguments", "download_data.install_data", "str", "pathlib.Path", "bool", "pathlib.Path.cwd().absolute", "pathlib.Path.cwd"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_arguments", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.download_data.install_data"], ["def", "main", "(", "args", "=", "None", ")", ":", "\n", "    ", "imed_utils", ".", "init_ivadomed", "(", ")", "\n", "\n", "# Dictionary containing list of URLs for data names.", "\n", "# Mirror servers are listed in order of decreasing priority.", "\n", "# If exists, favour release artifact straight from github", "\n", "\n", "parser", "=", "get_parser", "(", ")", "\n", "arguments", "=", "imed_utils", ".", "get_arguments", "(", "parser", ",", "args", ")", "\n", "\n", "data_name", "=", "arguments", ".", "d", "\n", "\n", "if", "arguments", ".", "output", "is", "None", ":", "\n", "        ", "dest_folder", "=", "str", "(", "Path", "(", "Path", ".", "cwd", "(", ")", ".", "absolute", "(", ")", ",", "data_name", ")", ")", "\n", "", "else", ":", "\n", "        ", "dest_folder", "=", "arguments", ".", "output", "\n", "\n", "", "url", "=", "DICT_URL", "[", "data_name", "]", "[", "\"url\"", "]", "\n", "install_data", "(", "url", ",", "dest_folder", ",", "keep", "=", "bool", "(", "arguments", ".", "keep", ")", ")", "\n", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser": [[34, 44], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--ofolders\"", ",", "required", "=", "True", ",", "nargs", "=", "\"*\"", ",", "dest", "=", "\"ofolders\"", ",", "\n", "help", "=", "\"List of log folders from different models.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--metric\"", ",", "default", "=", "'dice_class0'", ",", "nargs", "=", "1", ",", "type", "=", "str", ",", "dest", "=", "\"metric\"", ",", "\n", "help", "=", "\"Metric from evaluation_3Dmetrics.csv to base the plots on.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--metadata\"", ",", "required", "=", "False", ",", "nargs", "=", "2", ",", "type", "=", "str", ",", "dest", "=", "\"metadata\"", ",", "\n", "help", "=", "\"Selection based on metadata from participants.tsv:\"", "\n", "\"(1) Label from column (2) string to match\"", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.onclick": [[46, 81], ["matplotlib.pyplot.gca", "df[].unique", "len", "numpy.linspace", "numpy.where", "range", "matplotlib.pyplot.show", "len", "plt.gca.texts.pop", "len", "matplotlib.pyplot.text", "matplotlib.artist.Artist.set_visible", "len", "clicked_index.tolist", "numpy.math.factorial", "dict", "numpy.math.factorial", "numpy.math.factorial"], "function", ["None"], ["", "def", "onclick", "(", "event", ",", "df", ")", ":", "\n", "# Get the index of the selected violinplot datapoint", "\n", "# WARNING: More than one can be selected if they are very close to each other", "\n", "#          If that's the case, all will be displayed", "\n", "    ", "clicked_index", "=", "event", ".", "ind", "\n", "\n", "fig", "=", "plt", ".", "gca", "(", ")", "\n", "# clicking outside the plot area produces a coordinate of None, so we filter those out.", "\n", "if", "None", "not", "in", "clicked_index", ":", "\n", "        ", "output_folders", "=", "df", "[", "\"EvaluationModel\"", "]", ".", "unique", "(", ")", "\n", "nfolders", "=", "len", "(", "output_folders", ")", "\n", "\n", "# Remove the previously displayed subject(s)", "\n", "# This also takes care of the case where more than one subjects are displayed", "\n", "while", "len", "(", "fig", ".", "texts", ")", ">", "nfolders", "+", "np", ".", "math", ".", "factorial", "(", "nfolders", ")", "/", "(", "\n", "np", ".", "math", ".", "factorial", "(", "2", ")", "*", "np", ".", "math", ".", "factorial", "(", "nfolders", "-", "2", ")", ")", ":", "\n", "            ", "fig", ".", "texts", ".", "pop", "(", ")", "\n", "\n", "# This is a hack to find the index of the Violinplot - There should be another way to get this from the", "\n", "# figure object", "\n", "", "bins", "=", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "len", "(", "output_folders", ")", "+", "1", ")", "\n", "i_output_folder", "=", "np", ".", "where", "(", "bins", "<", "event", ".", "mouseevent", ".", "xdata", ")", "\n", "i_output_folder", "=", "i_output_folder", "[", "-", "1", "]", "[", "0", "]", "\n", "selected_output_folder", "=", "df", "[", "df", "[", "\"EvaluationModel\"", "]", "==", "output_folders", "[", "i_output_folder", "]", "]", "\n", "\n", "for", "iSubject", "in", "range", "(", "0", ",", "len", "(", "clicked_index", ".", "tolist", "(", ")", ")", ")", ":", "\n", "            ", "frame", "=", "plt", ".", "text", "(", "event", ".", "mouseevent", ".", "xdata", ",", "-", "0.08", "-", "0.08", "*", "iSubject", "+", "event", ".", "mouseevent", ".", "ydata", ",", "\n", "selected_output_folder", "[", "\"subject\"", "]", "[", "clicked_index", "[", "iSubject", "]", "]", ",", "size", "=", "10", ",", "\n", "ha", "=", "\"center\"", ",", "va", "=", "\"center\"", ",", "\n", "bbox", "=", "dict", "(", "facecolor", "=", "'red'", ",", "alpha", "=", "0.5", ")", "\n", ")", "\n", "# To show the artist", "\n", "matplotlib", ".", "artist", ".", "Artist", ".", "set_visible", "(", "frame", ",", "True", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.visualize_and_compare_models": [[83, 226], ["loguru.logger.debug", "loguru.logger.debug", "pandas.DataFrame", "len", "list", "list", "df[].astype", "loguru.logger.debug", "len", "Exception", "pandas.read_csv", "itertools.combinations", "itertools.combinations", "seaborn.violinplot", "seaborn.stripplot", "range", "matplotlib.pyplot.grid", "matplotlib.pyplot.text", "matplotlib.pyplot.gca().figure.canvas.mpl_connect", "matplotlib.pyplot.show", "loguru.logger.warning", "pathlib.Path().exists", "loguru.logger.error", "Exception", "pathlib.Path().exists", "loguru.logger.error", "Exception", "str", "pandas.read_table", "[].tolist", "df.append.append", "range", "len", "matplotlib.pyplot.text", "range", "matplotlib.pyplot.title", "matplotlib.pyplot.title", "pathlib.Path", "str", "i.replace", "loguru.logger.warning", "len", "numpy.column_stack", "pandas.DataFrame", "str", "len", "len", "len", "scipy.stats.ks_2samp", "matplotlib.pyplot.plot", "visualize_and_compare_testing_models.onclick", "pathlib.Path", "pathlib.Path", "pathlib.Path", "df[].max", "matplotlib.pyplot.text", "pathlib.Path", "pathlib.Path().resolve", "scores.astype", "matplotlib.pyplot.text", "matplotlib.pyplot.gca", "range", "pathlib.Path().resolve", "df[].min", "matplotlib.pyplot.text", "len", "pathlib.Path", "pathlib.Path().resolve", "pathlib.Path().resolve", "pathlib.Path", "temp.mean", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.onclick"], ["", "", "def", "visualize_and_compare_models", "(", "ofolders", ",", "metric", "=", "\"dice_class0\"", ",", "metadata", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This function allows violinplots visualization of multiple evaluation models simultaneously and performs a\n    Kolmogorov\u2013Smirnov significance test between each combination of models. The mean values of the datapoints for each\n    violinplot is superimposed on the top.\n\n    If only one model is selected as input, only the Violinplot will be presented (no test will be superimposed)\n\n    The datapoints within each violinplot are interactive. The subject_id and MRI sequence of each point are displayed\n    when clicked (as shown on the violinplot to the right of the example figure below).\n\n    .. note::\n        If more than 4 model outputs are selected to be compared, the significance tests are not displayed since the\n        figure becomes very busy\n\n    Usage example::\n\n        visualize_and_compare_testing_models.py --ofolders ~/logs/logs_T1w ~/logs/logs_T2w\n                                                --metric dice_class0 --metadata pathology ms\n\n    .. image:: ../../images/visualize_and_compare_models.png\n            :width: 600px\n            :align: center\n\n\n    Args:\n        ofolders (list): list of folders that contain the outputs of the models to be compared, Flag: ``--ofolders``\n        metric (str):      column of \"results_eval/evaluation_3Dmetrics.csv\" to be used on the plots\n                           (default: dice_class0), Flag: ``--metric``\n        metadata (list) - Optional:   Allows visualization of violinplots only from subjects that match the\n                           metadata criteria.\n                           2 elements - (1) column label of the dataframe.csv metadata so only subjects that belong to\n                           that category will be used and (2) string to be matched, Flag: ``--metadata``, Example: \"--metadata pathology ms\"\n    \"\"\"", "\n", "\n", "# access CLI options", "\n", "logger", ".", "debug", "(", "f\"ofolders: {ofolders}\"", ")", "\n", "logger", ".", "debug", "(", "f\"metric: {metric}\"", ")", "\n", "if", "metadata", "is", "None", ":", "\n", "        ", "metadata", "=", "[", "]", "\n", "", "if", "metadata", ":", "\n", "        ", "logger", ".", "debug", "(", "f\"metadata: {metadata}\"", ")", "\n", "\n", "# Do a quick check that all the required files are present", "\n", "", "for", "folder", "in", "ofolders", ":", "\n", "        ", "if", "not", "Path", "(", "folder", ",", "'results_eval'", ",", "'evaluation_3Dmetrics.csv'", ")", ".", "exists", "(", ")", ":", "\n", "            ", "logger", ".", "error", "(", "f\"evaluation_3Dmetrics.csv file is not present within {Path(folder, 'results_eval')}\"", ")", "\n", "raise", "Exception", "(", "'evaluation_3Dmetrics.csv missing'", ")", "\n", "", "if", "not", "Path", "(", "folder", ",", "'bids_dataframe.csv'", ")", ".", "exists", "(", ")", ":", "\n", "            ", "logger", ".", "error", "(", "f\"bids_dataframe.csv file is not present within {folder}\"", ")", "\n", "raise", "Exception", "(", "'bids_dataframe.csv missing'", ")", "\n", "\n", "", "", "if", "len", "(", "ofolders", ")", "<", "1", ":", "\n", "        ", "raise", "Exception", "(", "'No folders were selected - Nothing to show'", ")", "\n", "\n", "", "columnNames", "=", "[", "\"EvaluationModel\"", ",", "metric", ",", "'subject'", "]", "\n", "df", "=", "pd", ".", "DataFrame", "(", "[", "]", ",", "columns", "=", "columnNames", ")", "\n", "\n", "for", "folder", "in", "ofolders", ":", "\n", "        ", "result", "=", "pd", ".", "read_csv", "(", "str", "(", "Path", "(", "folder", ",", "'results_eval'", ",", "'evaluation_3Dmetrics.csv'", ")", ")", ")", "\n", "\n", "if", "metadata", ":", "\n", "            ", "participant_metadata", "=", "pd", ".", "read_table", "(", "str", "(", "Path", "(", "folder", ",", "'bids_dataframe.csv'", ")", ")", ",", "sep", "=", "','", ")", "\n", "# Select only the subjects that satisfy the --metadata input", "\n", "selected_subjects", "=", "participant_metadata", "[", "participant_metadata", "[", "metadata", "[", "0", "]", "]", "==", "metadata", "[", "1", "]", "]", "[", "\n", "\"filename\"", "]", ".", "tolist", "(", ")", "\n", "selected_subjects", "=", "[", "i", ".", "replace", "(", "\".nii.gz\"", ",", "\"\"", ")", "for", "i", "in", "selected_subjects", "]", "\n", "\n", "# Now select only the scores from these subjects", "\n", "result_subject_ids", "=", "result", "[", "\"image_id\"", "]", "\n", "result", "=", "result", ".", "iloc", "[", "\n", "[", "i", "for", "i", "in", "range", "(", "len", "(", "result_subject_ids", ")", ")", "if", "result_subject_ids", "[", "i", "]", "in", "selected_subjects", "]", "]", "\n", "\n", "if", "result", ".", "empty", ":", "\n", "                ", "logger", ".", "warning", "(", "f\"No subject meet the selected criteria - skipping plot for: {folder}\"", ")", "\n", "\n", "", "", "if", "not", "result", ".", "empty", ":", "\n", "            ", "scores", "=", "result", "[", "metric", "]", "\n", "\n", "folders", "=", "[", "Path", "(", "folder", ")", ".", "resolve", "(", ")", ".", "name", "]", "*", "len", "(", "scores", ")", "\n", "subject_id", "=", "result", "[", "\"image_id\"", "]", "\n", "combined", "=", "np", ".", "column_stack", "(", "(", "folders", ",", "scores", ".", "astype", "(", "np", ".", "object", ",", "folders", ")", ",", "subject_id", ")", ")", ".", "T", "\n", "singleFolderDF", "=", "pd", ".", "DataFrame", "(", "combined", ",", "columnNames", ")", ".", "T", "\n", "df", "=", "df", ".", "append", "(", "singleFolderDF", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "", "nFolders", "=", "len", "(", "ofolders", ")", "\n", "combinedNumbers", "=", "list", "(", "itertools", ".", "combinations", "(", "range", "(", "nFolders", ")", ",", "2", ")", ")", "\n", "combinedFolders", "=", "list", "(", "itertools", ".", "combinations", "(", "ofolders", ",", "2", ")", ")", "\n", "\n", "# Pandas annoying issues", "\n", "df", "[", "metric", "]", "=", "df", "[", "metric", "]", ".", "astype", "(", "'float64'", ")", "\n", "\n", "if", "not", "df", ".", "empty", ":", "\n", "\n", "# Plot all violinplots", "\n", "        ", "plt1", "=", "sns", ".", "violinplot", "(", "x", "=", "\"EvaluationModel\"", ",", "y", "=", "metric", ",", "data", "=", "df", ",", "palette", "=", "\"muted\"", ",", "saturation", "=", "0.3", ",", "\n", "inner", "=", "'quartile'", ",", "picker", "=", "True", ",", "pickradius", "=", "1", ")", "\n", "plt2", "=", "sns", ".", "stripplot", "(", "x", "=", "\"EvaluationModel\"", ",", "y", "=", "metric", ",", "data", "=", "df", ",", "linewidth", "=", "0.5", ",", "edgecolor", "=", "\"black\"", ",", "\n", "jitter", "=", "True", ",", "zorder", "=", "1", ",", "picker", "=", "True", ",", "pickradius", "=", "1", ")", "\n", "\n", "# Display the mean performance on top of every violinplot", "\n", "for", "i", "in", "range", "(", "len", "(", "ofolders", ")", ")", ":", "\n", "# This will be used to plot the mean value on top of each individual violinplot", "\n", "            ", "temp", "=", "df", "[", "metric", "]", "[", "df", "[", "'EvaluationModel'", "]", "==", "Path", "(", "ofolders", "[", "i", "]", ")", ".", "resolve", "(", ")", ".", "name", "]", "\n", "plt", ".", "text", "(", "i", ",", "df", "[", "metric", "]", ".", "max", "(", ")", "+", "0.07", ",", "str", "(", "(", "100", "*", "temp", ".", "mean", "(", ")", ")", ".", "round", "(", ")", "/", "100", ")", ",", "ha", "=", "'center'", ",", "va", "=", "'top'", ",", "\n", "color", "=", "'r'", ",", "picker", "=", "True", ")", "\n", "\n", "", "if", "len", "(", "ofolders", ")", ">", "1", "and", "len", "(", "ofolders", ")", "<", "5", ":", "\n", "# Perform a Kolmogorov\u2013Smirnov test for all combinations of results & connect the corresponding Violinplots", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "combinedNumbers", ")", ")", ":", "\n", "                ", "dataX", "=", "df", "[", "metric", "]", "[", "df", "[", "'EvaluationModel'", "]", "==", "Path", "(", "combinedFolders", "[", "i", "]", "[", "0", "]", ")", ".", "resolve", "(", ")", ".", "name", "]", "\n", "dataY", "=", "df", "[", "metric", "]", "[", "df", "[", "'EvaluationModel'", "]", "==", "Path", "(", "combinedFolders", "[", "i", "]", "[", "1", "]", ")", ".", "resolve", "(", ")", ".", "name", "]", "\n", "\n", "ks_test", "=", "ks_2samp", "(", "dataX", ",", "dataY", ")", "\n", "\n", "x1", ",", "x2", "=", "combinedNumbers", "[", "i", "]", "\n", "\n", "y", ",", "h", ",", "col", "=", "df", "[", "metric", "]", ".", "min", "(", ")", "-", "0.06", "-", "0.03", "*", "i", ",", "-", "0.01", ",", "'k'", "\n", "plt", ".", "plot", "(", "[", "x1", ",", "x1", ",", "x2", ",", "x2", "]", ",", "[", "y", ",", "y", "+", "h", ",", "y", "+", "h", ",", "y", "]", ",", "lw", "=", "1.5", ",", "c", "=", "col", ",", "picker", "=", "True", ")", "\n", "\n", "# Show if the differentiation of the distributions is :", "\n", "# Not significant: ns, significant: *, very significant: ***", "\n", "if", "ks_test", ".", "pvalue", ">=", "0.5", ":", "\n", "                    ", "plt", ".", "text", "(", "(", "x1", "+", "x2", ")", "*", ".5", ",", "y", "+", "h", ",", "\"ns\"", ",", "ha", "=", "'center'", ",", "va", "=", "'bottom'", ",", "color", "=", "col", ",", "picker", "=", "True", ")", "\n", "", "elif", "0.5", ">", "ks_test", ".", "pvalue", ">=", "0.01", ":", "\n", "                    ", "plt", ".", "text", "(", "(", "x1", "+", "x2", ")", "*", ".5", ",", "y", "+", "h", ",", "\"*\"", ",", "ha", "=", "'center'", ",", "va", "=", "'bottom'", ",", "color", "=", "'r'", ",", "picker", "=", "True", ")", "\n", "", "elif", "ks_test", ".", "pvalue", "<", "0.01", ":", "\n", "                    ", "plt", ".", "text", "(", "(", "x1", "+", "x2", ")", "*", ".5", ",", "y", "+", "h", ",", "\"***\"", ",", "ha", "=", "'center'", ",", "va", "=", "'bottom'", ",", "color", "=", "'r'", ",", "picker", "=", "True", ")", "\n", "\n", "", "", "", "if", "metadata", ":", "\n", "            ", "plt", ".", "title", "(", "\"Metric:  \"", "+", "metric", "+", "\"\\nMetadata:  \"", "+", "metadata", "[", "0", "]", "+", "\":\"", "+", "metadata", "[", "1", "]", ",", "picker", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "plt", ".", "title", "(", "\"Metric:  \"", "+", "metric", ",", "picker", "=", "True", ")", "\n", "\n", "", "plt", ".", "grid", "(", ")", "\n", "plt", ".", "text", "(", "0", ",", "0", ",", "\" \"", ")", "# One empty entry is introduced here so it is popped in the function", "\n", "plt", ".", "gca", "(", ")", ".", "figure", ".", "canvas", ".", "mpl_connect", "(", "'pick_event'", ",", "\n", "lambda", "event", ":", "onclick", "(", "event", ",", "df", ")", ")", "\n", "\n", "plt", ".", "show", "(", "block", "=", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "logger", ".", "warning", "(", "\"No subjects meet the criteria selected for any model. \"", "\n", "\"Probably you need to change the --metadata / --metric selection\"", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.main": [[229, 237], ["ivadomed.utils.init_ivadomed", "visualize_and_compare_testing_models.get_parser", "get_parser.parse_args", "visualize_and_compare_testing_models.visualize_and_compare_models"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.init_ivadomed", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.get_parser", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.scripts.visualize_and_compare_testing_models.visualize_and_compare_models"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "init_ivadomed", "(", ")", "\n", "\n", "parser", "=", "get_parser", "(", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Run automate training", "\n", "visualize_and_compare_models", "(", "args", ".", "ofolders", ",", "args", ".", "metric", ",", "args", ".", "metadata", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.__init__": [[47, 133], ["sorted", "sorted", "[].to_list", "ivadomed.object_detection.utils.load_bounding_boxes", "bids_df.get_deriv_fnames", "tqdm.tqdm.tqdm", "ivadomed.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.__init__", "sorted.append", "list", "len", "enumerate", "bids_dataset.BidsDataset.create_filename_pair", "bids_dataset.BidsDataset.values", "Exception", "bids_df.df[].isin", "df_subjects[].str.fullmatch().value_counts", "contrast_params[].keys", "contrast_params[].keys", "set", "bids_dataset.BidsDataset.fill_multichannel_dict", "bids_dataset.BidsDataset.filename_pairs.append", "[].split", "bids_dataset.BidsDataset.filename_pairs.append", "df_subjects[].str.fullmatch", "bids_df.df[].str.contains", "subject.split", "bids_df.get_subject_fnames"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.load_bounding_boxes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_deriv_fnames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.create_filename_pair", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.fill_multichannel_dict", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_subject_fnames"], ["def", "__init__", "(", "self", ",", "bids_df", ",", "subject_file_lst", ",", "target_suffix", ",", "contrast_params", ",", "model_params", ",", "slice_axis", "=", "2", ",", "\n", "nibabel_cache", "=", "True", ",", "transform", "=", "None", ",", "metadata_choice", "=", "False", ",", "slice_filter_fn", "=", "None", ",", "patch_filter_fn", "=", "None", ",", "\n", "roi_params", "=", "None", ",", "multichannel", "=", "False", ",", "object_detection_params", "=", "None", ",", "task", "=", "\"segmentation\"", ",", "\n", "soft_gt", "=", "False", ",", "is_input_dropout", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "roi_params", "=", "roi_params", "if", "roi_params", "is", "not", "None", "else", "{", "ROIParamsKW", ".", "SUFFIX", ":", "None", ",", "ROIParamsKW", ".", "SLICE_FILTER_ROI", ":", "None", "}", "\n", "self", ".", "soft_gt", "=", "soft_gt", "\n", "self", ".", "filename_pairs", "=", "[", "]", "\n", "if", "metadata_choice", "==", "MetadataKW", ".", "MRI_PARAMS", ":", "\n", "            ", "self", ".", "metadata", "=", "{", "\"FlipAngle\"", ":", "[", "]", ",", "\"RepetitionTime\"", ":", "[", "]", ",", "\n", "\"EchoTime\"", ":", "[", "]", ",", "\"Manufacturer\"", ":", "[", "]", "}", "\n", "\n", "# Sort subject_file_lst and create a sub-dataframe from bids_df containing only subjects from subject_file_lst", "\n", "", "subject_file_lst", "=", "sorted", "(", "subject_file_lst", ")", "\n", "df_subjects", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", ".", "isin", "(", "subject_file_lst", ")", "]", "\n", "\n", "# Create a dictionary with the number of subjects for each contrast of contrast_balance", "\n", "tot", "=", "{", "contrast", ":", "df_subjects", "[", "'suffix'", "]", ".", "str", ".", "fullmatch", "(", "contrast", ")", ".", "value_counts", "(", ")", "[", "True", "]", "\n", "for", "contrast", "in", "contrast_params", "[", "ContrastParamsKW", ".", "BALANCE", "]", ".", "keys", "(", ")", "}", "\n", "\n", "# Create a counter that helps to balance the contrasts", "\n", "c", "=", "{", "contrast", ":", "0", "for", "contrast", "in", "contrast_params", "[", "ContrastParamsKW", ".", "BALANCE", "]", ".", "keys", "(", ")", "}", "\n", "\n", "# Get a list of subject_ids for multichannel_subjects (prefix filename without modality suffix and extension)", "\n", "subject_ids", "=", "[", "]", "\n", "for", "subject", "in", "subject_file_lst", ":", "\n", "            ", "subject_ids", ".", "append", "(", "subject", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", ")", "\n", "", "subject_ids", "=", "sorted", "(", "list", "(", "set", "(", "subject_ids", ")", ")", ")", "\n", "\n", "# Create multichannel_subjects dictionary for each subject_id", "\n", "multichannel_subjects", "=", "{", "}", "\n", "idx_dict", "=", "{", "}", "\n", "if", "multichannel", ":", "\n", "            ", "num_contrast", "=", "len", "(", "contrast_params", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", ")", "\n", "for", "idx", ",", "contrast", "in", "enumerate", "(", "contrast_params", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", ")", ":", "\n", "                ", "idx_dict", "[", "contrast", "]", "=", "idx", "\n", "", "multichannel_subjects", "=", "{", "subject", ":", "{", "\"absolute_paths\"", ":", "[", "None", "]", "*", "num_contrast", ",", "\n", "\"deriv_path\"", ":", "None", ",", "\n", "\"roi_filename\"", ":", "None", ",", "\n", "SubjectDictKW", ".", "METADATA", ":", "[", "None", "]", "*", "num_contrast", "}", "for", "subject", "in", "subject_ids", "}", "\n", "\n", "# Get all subjects path from bids_df for bounding box", "\n", "", "get_all_subj_path", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "\n", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "bids_df", ".", "get_subject_fnames", "(", ")", ")", ")", "]", "[", "'path'", "]", ".", "to_list", "(", ")", "\n", "\n", "# Load bounding box from list of path", "\n", "bounding_box_dict", "=", "imed_obj_detect", ".", "load_bounding_boxes", "(", "object_detection_params", ",", "\n", "get_all_subj_path", ",", "\n", "slice_axis", ",", "\n", "contrast_params", "[", "ContrastParamsKW", ".", "CONTRAST_LST", "]", ")", "\n", "\n", "# Get all derivatives filenames from bids_df", "\n", "all_deriv", "=", "bids_df", ".", "get_deriv_fnames", "(", ")", "\n", "\n", "# Create filename_pairs", "\n", "for", "subject", "in", "tqdm", "(", "subject_file_lst", ",", "desc", "=", "\"Loading dataset\"", ")", ":", "\n", "            ", "df_sub", ",", "roi_filename", ",", "target_filename", ",", "metadata", "=", "self", ".", "create_filename_pair", "(", "multichannel_subjects", ",", "subject", ",", "\n", "c", ",", "tot", ",", "multichannel", ",", "df_subjects", ",", "\n", "contrast_params", ",", "target_suffix", ",", "\n", "all_deriv", ",", "bids_df", ",", "bounding_box_dict", ",", "\n", "idx_dict", ",", "metadata_choice", ")", "\n", "# Fill multichannel dictionary", "\n", "# subj_id is the filename without modality suffix and extension", "\n", "if", "multichannel", ":", "\n", "                ", "multichannel_subjects", "=", "self", ".", "fill_multichannel_dict", "(", "multichannel_subjects", ",", "subject", ",", "idx_dict", ",", "df_sub", ",", "\n", "roi_filename", ",", "target_filename", ",", "metadata", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "filename_pairs", ".", "append", "(", "(", "[", "df_sub", "[", "'path'", "]", ".", "values", "[", "0", "]", "]", ",", "\n", "target_filename", ",", "roi_filename", ",", "[", "metadata", "]", ")", ")", "\n", "\n", "", "", "if", "multichannel", ":", "\n", "            ", "for", "subject", "in", "multichannel_subjects", ".", "values", "(", ")", ":", "\n", "                ", "if", "None", "not", "in", "subject", "[", "\"absolute_paths\"", "]", ":", "\n", "                    ", "self", ".", "filename_pairs", ".", "append", "(", "(", "subject", "[", "\"absolute_paths\"", "]", ",", "subject", "[", "\"deriv_path\"", "]", ",", "\n", "subject", "[", "\"roi_filename\"", "]", ",", "subject", "[", "SubjectDictKW", ".", "METADATA", "]", ")", ")", "\n", "\n", "", "", "", "if", "not", "self", ".", "filename_pairs", ":", "\n", "            ", "raise", "Exception", "(", "'No subjects were selected - check selection of parameters on config.json (e.g. center '", "\n", "'selected + target_suffix)'", ")", "\n", "\n", "", "length", "=", "model_params", "[", "ModelParamsKW", ".", "LENGTH_2D", "]", "if", "ModelParamsKW", ".", "LENGTH_2D", "in", "model_params", "else", "[", "]", "\n", "stride", "=", "model_params", "[", "ModelParamsKW", ".", "STRIDE_2D", "]", "if", "ModelParamsKW", ".", "STRIDE_2D", "in", "model_params", "else", "[", "]", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "filename_pairs", ",", "length", ",", "stride", ",", "slice_axis", ",", "nibabel_cache", ",", "transform", ",", "slice_filter_fn", ",", "patch_filter_fn", ",", "\n", "task", ",", "self", ".", "roi_params", ",", "self", ".", "soft_gt", ",", "is_input_dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.get_target_filename": [[134, 144], ["enumerate", "isinstance", "target_filename[].append"], "methods", ["None"], ["", "def", "get_target_filename", "(", "self", ",", "target_suffix", ",", "target_filename", ",", "derivative", ")", ":", "\n", "        ", "for", "idx", ",", "suffix_list", "in", "enumerate", "(", "target_suffix", ")", ":", "\n", "# If suffix_list is a string, then only one rater annotation per class is available.", "\n", "# Otherwise, multiple raters segmented the same class.", "\n", "            ", "if", "isinstance", "(", "suffix_list", ",", "list", ")", ":", "\n", "                ", "for", "suffix", "in", "suffix_list", ":", "\n", "                    ", "if", "suffix", "in", "derivative", ":", "\n", "                        ", "target_filename", "[", "idx", "]", ".", "append", "(", "derivative", ")", "\n", "", "", "", "elif", "suffix_list", "in", "derivative", ":", "\n", "                ", "target_filename", "[", "idx", "]", "=", "derivative", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.create_metadata_dict": [[146, 158], ["sorted", "enumerate", "ValueError", "set", "bids_df.df[].dropna"], "methods", ["None"], ["", "", "", "def", "create_metadata_dict", "(", "self", ",", "metadata", ",", "metadata_choice", ",", "df_sub", ",", "bids_df", ")", ":", "\n", "# add custom data to metadata", "\n", "        ", "if", "metadata_choice", "not", "in", "df_sub", ".", "columns", ":", "\n", "            ", "raise", "ValueError", "(", "\"The following metadata cannot be found: {}. \"", "\n", "\"Invalid metadata choice.\"", ".", "format", "(", "metadata_choice", ")", ")", "\n", "", "metadata", "[", "metadata_choice", "]", "=", "df_sub", "[", "metadata_choice", "]", ".", "values", "[", "0", "]", "\n", "# Create metadata dict for OHE", "\n", "data_lst", "=", "sorted", "(", "set", "(", "bids_df", ".", "df", "[", "metadata_choice", "]", ".", "dropna", "(", ")", ".", "values", ")", ")", "\n", "metadata_dict", "=", "{", "}", "\n", "for", "idx", ",", "data", "in", "enumerate", "(", "data_lst", ")", ":", "\n", "            ", "metadata_dict", "[", "data", "]", "=", "idx", "\n", "", "metadata", "[", "MetadataKW", ".", "METADATA_DICT", "]", "=", "metadata_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.fill_multichannel_dict": [[159, 168], ["[].split", "subject.split"], "methods", ["None"], ["", "def", "fill_multichannel_dict", "(", "self", ",", "multichannel_subjects", ",", "subject", ",", "idx_dict", ",", "df_sub", ",", "roi_filename", ",", "target_filename", ",", "metadata", ")", ":", "\n", "        ", "idx", "=", "idx_dict", "[", "df_sub", "[", "'suffix'", "]", ".", "values", "[", "0", "]", "]", "\n", "subj_id", "=", "subject", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "multichannel_subjects", "[", "subj_id", "]", "[", "\"absolute_paths\"", "]", "[", "idx", "]", "=", "df_sub", "[", "'path'", "]", ".", "values", "[", "0", "]", "\n", "multichannel_subjects", "[", "subj_id", "]", "[", "\"deriv_path\"", "]", "=", "target_filename", "\n", "multichannel_subjects", "[", "subj_id", "]", "[", "SubjectDictKW", ".", "METADATA", "]", "[", "idx", "]", "=", "metadata", "\n", "if", "roi_filename", ":", "\n", "            ", "multichannel_subjects", "[", "subj_id", "]", "[", "\"roi_filename\"", "]", "=", "roi_filename", "\n", "", "return", "multichannel_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.create_filename_pair": [[170, 212], ["isinstance", "[].to_list", "len", "contrast_params[].keys", "bids_dataset.BidsDataset.get_target_filename", "df_sub.to_dict", "any", "all", "bids_dataset.BidsDataset.create_metadata_dict", "len", "range", "str", "ivadomed.loader.film.check_isMRIparam", "len", "bids_df.df[].str.contains", "bids_dataset.BidsDataset.metadata.keys", "bids_df.get_derivatives"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.get_target_filename", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataset.BidsDataset.create_metadata_dict", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.check_isMRIparam", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_derivatives"], ["", "def", "create_filename_pair", "(", "self", ",", "multichannel_subjects", ",", "subject", ",", "c", ",", "tot", ",", "multichannel", ",", "df_subjects", ",", "contrast_params", ",", "\n", "target_suffix", ",", "all_deriv", ",", "bids_df", ",", "bounding_box_dict", ",", "idx_dict", ",", "metadata_choice", ")", ":", "\n", "        ", "df_sub", "=", "df_subjects", ".", "loc", "[", "df_subjects", "[", "'filename'", "]", "==", "subject", "]", "\n", "\n", "# Training & Validation: do not consider the contrasts over the threshold contained in contrast_balance", "\n", "contrast", "=", "df_sub", "[", "'suffix'", "]", ".", "values", "[", "0", "]", "\n", "if", "contrast", "in", "(", "contrast_params", "[", "ContrastParamsKW", ".", "BALANCE", "]", ".", "keys", "(", ")", ")", ":", "\n", "            ", "c", "[", "contrast", "]", "=", "c", "[", "contrast", "]", "+", "1", "\n", "if", "c", "[", "contrast", "]", "/", "tot", "[", "contrast", "]", ">", "contrast_params", "[", "ContrastParamsKW", ".", "BALANCE", "]", "[", "contrast", "]", ":", "\n", "                ", "return", "\n", "", "", "if", "isinstance", "(", "target_suffix", "[", "0", "]", ",", "str", ")", ":", "\n", "            ", "target_filename", ",", "roi_filename", "=", "[", "None", "]", "*", "len", "(", "target_suffix", ")", ",", "None", "\n", "", "else", ":", "\n", "            ", "target_filename", ",", "roi_filename", "=", "[", "[", "]", "for", "_", "in", "range", "(", "len", "(", "target_suffix", ")", ")", "]", ",", "None", "\n", "\n", "", "derivatives", "=", "bids_df", ".", "df", "[", "bids_df", ".", "df", "[", "'filename'", "]", "\n", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "bids_df", ".", "get_derivatives", "(", "subject", ",", "all_deriv", ")", ")", ")", "]", "[", "'path'", "]", ".", "to_list", "(", ")", "\n", "\n", "for", "derivative", "in", "derivatives", ":", "\n", "            ", "self", ".", "get_target_filename", "(", "target_suffix", ",", "target_filename", ",", "derivative", ")", "\n", "if", "not", "(", "self", ".", "roi_params", "[", "ROIParamsKW", ".", "SUFFIX", "]", "is", "None", ")", "and", "self", ".", "roi_params", "[", "ROIParamsKW", ".", "SUFFIX", "]", "in", "derivative", ":", "\n", "                ", "roi_filename", "=", "[", "derivative", "]", "\n", "\n", "", "", "if", "(", "not", "any", "(", "target_filename", ")", ")", "or", "(", "not", "(", "self", ".", "roi_params", "[", "ROIParamsKW", ".", "SUFFIX", "]", "is", "None", ")", "and", "(", "roi_filename", "is", "None", ")", ")", ":", "\n", "            ", "return", "\n", "\n", "", "metadata", "=", "df_sub", ".", "to_dict", "(", "orient", "=", "'records'", ")", "[", "0", "]", "\n", "metadata", "[", "MetadataKW", ".", "CONTRAST", "]", "=", "contrast", "\n", "\n", "if", "len", "(", "bounding_box_dict", ")", ":", "\n", "# Take only one bounding box for cropping", "\n", "            ", "metadata", "[", "MetadataKW", ".", "BOUNDING_BOX", "]", "=", "bounding_box_dict", "[", "str", "(", "df_sub", "[", "'path'", "]", ".", "values", "[", "0", "]", ")", "]", "[", "0", "]", "\n", "\n", "", "if", "metadata_choice", "==", "MetadataKW", ".", "MRI_PARAMS", ":", "\n", "            ", "if", "not", "all", "(", "[", "imed_film", ".", "check_isMRIparam", "(", "m", ",", "metadata", ",", "subject", ",", "self", ".", "metadata", ")", "for", "m", "in", "\n", "self", ".", "metadata", ".", "keys", "(", ")", "]", ")", ":", "\n", "                ", "return", "\n", "\n", "", "", "elif", "metadata_choice", "and", "metadata_choice", "!=", "MetadataKW", ".", "CONTRASTS", "and", "metadata_choice", "is", "not", "None", ":", "\n", "            ", "self", ".", "create_metadata_dict", "(", "metadata", ",", "metadata_choice", ",", "df_sub", ",", "bids_df", ")", "\n", "\n", "", "return", "df_sub", ",", "roi_filename", ",", "target_filename", ",", "metadata", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids3d_dataset.Bids3DDataset.__init__": [[27, 48], ["ivadomed.loader.bids_dataset.BidsDataset", "ivadomed.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__"], ["def", "__init__", "(", "self", ",", "bids_df", ",", "subject_file_lst", ",", "target_suffix", ",", "model_params", ",", "contrast_params", ",", "slice_axis", "=", "2", ",", "\n", "cache", "=", "True", ",", "transform", "=", "None", ",", "metadata_choice", "=", "False", ",", "roi_params", "=", "None", ",", "\n", "multichannel", "=", "False", ",", "object_detection_params", "=", "None", ",", "task", "=", "\"segmentation\"", ",", "soft_gt", "=", "False", ",", "\n", "is_input_dropout", "=", "False", ")", ":", "\n", "        ", "dataset", "=", "BidsDataset", "(", "bids_df", "=", "bids_df", ",", "\n", "subject_file_lst", "=", "subject_file_lst", ",", "\n", "target_suffix", "=", "target_suffix", ",", "\n", "roi_params", "=", "roi_params", ",", "\n", "contrast_params", "=", "contrast_params", ",", "\n", "model_params", "=", "model_params", ",", "\n", "metadata_choice", "=", "metadata_choice", ",", "\n", "slice_axis", "=", "slice_axis", ",", "\n", "transform", "=", "transform", ",", "\n", "multichannel", "=", "multichannel", ",", "\n", "object_detection_params", "=", "object_detection_params", ",", "\n", "is_input_dropout", "=", "is_input_dropout", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "dataset", ".", "filename_pairs", ",", "length", "=", "model_params", "[", "ModelParamsKW", ".", "LENGTH_3D", "]", ",", "\n", "stride", "=", "model_params", "[", "ModelParamsKW", ".", "STRIDE_3D", "]", ",", "\n", "transform", "=", "transform", ",", "slice_axis", "=", "slice_axis", ",", "task", "=", "task", ",", "soft_gt", "=", "soft_gt", ",", "\n", "is_input_dropout", "=", "is_input_dropout", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.__init__": [[75, 103], ["len", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "filename_pairs", ",", "length", "=", "None", ",", "stride", "=", "None", ",", "slice_axis", "=", "2", ",", "nibabel_cache", "=", "True", ",", "transform", "=", "None", ",", "\n", "slice_filter_fn", "=", "None", ",", "patch_filter_fn", "=", "None", ",", "task", "=", "\"segmentation\"", ",", "roi_params", "=", "None", ",", "soft_gt", "=", "False", ",", "\n", "is_input_dropout", "=", "False", ",", "disk_cache", "=", "None", ")", ":", "\n", "        ", "if", "length", "is", "None", ":", "\n", "            ", "length", "=", "[", "]", "\n", "", "if", "stride", "is", "None", ":", "\n", "            ", "stride", "=", "[", "]", "\n", "", "self", ".", "indexes", ":", "list", "=", "[", "]", "\n", "self", ".", "handlers", ":", "list", "=", "[", "]", "\n", "self", ".", "filename_pairs", "=", "filename_pairs", "\n", "self", ".", "length", "=", "length", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "is_2d_patch", "=", "True", "if", "self", ".", "length", "else", "False", "\n", "self", ".", "prepro_transforms", ",", "self", ".", "transform", "=", "transform", "\n", "self", ".", "cache", "=", "nibabel_cache", "\n", "self", ".", "slice_axis", "=", "slice_axis", "\n", "self", ".", "slice_filter_fn", "=", "slice_filter_fn", "\n", "self", ".", "patch_filter_fn", "=", "patch_filter_fn", "\n", "self", ".", "n_contrasts", "=", "len", "(", "self", ".", "filename_pairs", "[", "0", "]", "[", "0", "]", ")", "\n", "if", "roi_params", "is", "None", ":", "\n", "            ", "roi_params", "=", "{", "ROIParamsKW", ".", "SUFFIX", ":", "None", ",", "ROIParamsKW", ".", "SLICE_FILTER_ROI", ":", "None", "}", "\n", "", "self", ".", "roi_thr", "=", "roi_params", "[", "ROIParamsKW", ".", "SLICE_FILTER_ROI", "]", "\n", "self", ".", "slice_filter_roi", "=", "roi_params", "[", "ROIParamsKW", ".", "SUFFIX", "]", "is", "not", "None", "and", "isinstance", "(", "self", ".", "roi_thr", ",", "int", ")", "\n", "self", ".", "soft_gt", "=", "soft_gt", "\n", "self", ".", "has_bounding_box", "=", "True", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "is_input_dropout", "=", "is_input_dropout", "\n", "self", ".", "disk_cache", ":", "bool", "=", "disk_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames": [[104, 166], ["ivadomed.loader.segmentation_pair.SegmentationPair", "ivadomed.loader.segmentation_pair.SegmentationPair", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_shapes", "pathlib.Path", "range", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.prepare_indices", "ivadomed.loader.utils.create_temp_directory", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_slice", "ivadomed.object_detection.utils.verify_metadata", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_slice", "ivadomed.transforms.apply_preprocessing_transforms", "ivadomed.object_detection.utils.adjust_transforms", "ivadomed.loader.utils.filter_roi", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.determine_cache_need", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.slice_filter_fn", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.handlers.append", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.handlers.append", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.indexes.append", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.indexes.append", "path_item.open", "pickle.dump", "path_item.open", "pickle.dump", "ivadomed.utils.get_timestamp", "ivadomed.utils.get_timestamp"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_shapes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.prepare_indices", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.create_temp_directory", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_slice", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.verify_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_slice", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.apply_preprocessing_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.filter_roi", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.determine_cache_need", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp"], ["", "def", "load_filenames", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load preprocessed pair data (input and gt) in handler.\"\"\"", "\n", "for", "input_filenames", ",", "gt_filenames", ",", "roi_filename", ",", "metadata", "in", "self", ".", "filename_pairs", ":", "\n", "            ", "roi_pair", "=", "SegmentationPair", "(", "input_filenames", ",", "roi_filename", ",", "metadata", "=", "metadata", ",", "slice_axis", "=", "self", ".", "slice_axis", ",", "\n", "cache", "=", "self", ".", "cache", ",", "prepro_transforms", "=", "self", ".", "prepro_transforms", ")", "\n", "\n", "seg_pair", "=", "SegmentationPair", "(", "input_filenames", ",", "gt_filenames", ",", "metadata", "=", "metadata", ",", "slice_axis", "=", "self", ".", "slice_axis", ",", "\n", "cache", "=", "self", ".", "cache", ",", "prepro_transforms", "=", "self", ".", "prepro_transforms", ",", "\n", "soft_gt", "=", "self", ".", "soft_gt", ")", "\n", "\n", "input_data_shape", ",", "_", "=", "seg_pair", ".", "get_pair_shapes", "(", ")", "\n", "\n", "path_temp", "=", "Path", "(", "create_temp_directory", "(", ")", ")", "\n", "\n", "for", "idx_pair_slice", "in", "range", "(", "input_data_shape", "[", "-", "1", "]", ")", ":", "\n", "                ", "slice_seg_pair", "=", "seg_pair", ".", "get_pair_slice", "(", "idx_pair_slice", ",", "gt_type", "=", "self", ".", "task", ")", "\n", "self", ".", "has_bounding_box", "=", "imed_obj_detect", ".", "verify_metadata", "(", "slice_seg_pair", ",", "self", ".", "has_bounding_box", ")", "\n", "\n", "if", "self", ".", "has_bounding_box", ":", "\n", "                    ", "self", ".", "prepro_transforms", "=", "imed_obj_detect", ".", "adjust_transforms", "(", "self", ".", "prepro_transforms", ",", "slice_seg_pair", ")", "\n", "\n", "", "if", "self", ".", "slice_filter_fn", "and", "not", "self", ".", "slice_filter_fn", "(", "slice_seg_pair", ")", ":", "\n", "                    ", "continue", "\n", "\n", "# Note: we force here gt_type=segmentation since ROI slice is needed to Crop the image", "\n", "", "slice_roi_pair", "=", "roi_pair", ".", "get_pair_slice", "(", "idx_pair_slice", ",", "gt_type", "=", "\"segmentation\"", ")", "\n", "\n", "if", "self", ".", "slice_filter_roi", "and", "imed_loader_utils", ".", "filter_roi", "(", "slice_roi_pair", "[", "'gt'", "]", ",", "self", ".", "roi_thr", ")", ":", "\n", "                    ", "continue", "\n", "\n", "", "item", ":", "Tuple", "[", "dict", ",", "dict", "]", "=", "imed_transforms", ".", "apply_preprocessing_transforms", "(", "self", ".", "prepro_transforms", ",", "\n", "slice_seg_pair", ",", "\n", "slice_roi_pair", ")", "\n", "# Run once code to keep track if disk cache is used", "\n", "if", "self", ".", "disk_cache", "is", "None", ":", "\n", "                    ", "self", ".", "determine_cache_need", "(", "item", ",", "input_data_shape", "[", "-", "1", "]", ")", "\n", "\n", "# If is_2d_patch, create handlers list for indexing patch", "\n", "", "if", "self", ".", "is_2d_patch", ":", "\n", "                    ", "for", "metadata", "in", "item", "[", "0", "]", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ":", "\n", "                        ", "metadata", "[", "MetadataKW", ".", "INDEX_SHAPE", "]", "=", "item", "[", "0", "]", "[", "'input'", "]", "[", "0", "]", ".", "shape", "\n", "", "if", "self", ".", "disk_cache", ":", "\n", "                        ", "path_item", "=", "path_temp", "/", "f\"item_{get_timestamp()}.pkl\"", "\n", "with", "path_item", ".", "open", "(", "mode", "=", "\"wb\"", ")", "as", "f", ":", "\n", "                            ", "pickle", ".", "dump", "(", "item", ",", "f", ")", "\n", "", "self", ".", "handlers", ".", "append", "(", "(", "path_item", ")", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "handlers", ".", "append", "(", "(", "item", ")", ")", "\n", "# else, append the whole slice to self.indexes", "\n", "", "", "else", ":", "\n", "\n", "                    ", "if", "self", ".", "disk_cache", ":", "\n", "                        ", "path_item", "=", "path_temp", "/", "f\"item_{get_timestamp()}.pkl\"", "\n", "with", "path_item", ".", "open", "(", "mode", "=", "\"wb\"", ")", "as", "f", ":", "\n", "                            ", "pickle", ".", "dump", "(", "item", ",", "f", ")", "\n", "", "self", ".", "indexes", ".", "append", "(", "path_item", ")", "\n", "", "else", ":", "\n", "                        ", "self", ".", "indexes", ".", "append", "(", "item", ")", "\n", "\n", "# If is_2d_patch, prepare indices of patches", "\n", "", "", "", "", "if", "self", ".", "is_2d_patch", ":", "\n", "            ", "self", ".", "prepare_indices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.prepare_indices": [[167, 217], ["range", "len", "primary_handle.get", "primary_handle.get", "primary_handle.get", "primary_handle.get", "zip", "range", "RuntimeError", "range", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.handlers[].open", "pickle.load", "len", "len", "RuntimeError", "RuntimeError", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.indexes.append", "list", "list", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.patch_filter_fn", "numpy.asarray", "numpy.asarray"], "methods", ["None"], ["", "", "def", "prepare_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stores coordinates of 2d patches for training.\"\"\"", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "handlers", ")", ")", ":", "\n", "\n", "            ", "if", "self", ".", "disk_cache", ":", "\n", "                ", "with", "self", ".", "handlers", "[", "i", "]", ".", "open", "(", "mode", "=", "\"rb\"", ")", "as", "f", ":", "\n", "                    ", "item", "=", "pickle", ".", "load", "(", "f", ")", "\n", "primary_handle", "=", "item", "[", "0", "]", "\n", "", "", "else", ":", "\n", "                ", "primary_handle", "=", "self", ".", "handlers", "[", "i", "]", "[", "0", "]", "\n", "\n", "", "input_img", "=", "primary_handle", ".", "get", "(", "'input'", ")", "\n", "gt_img", "=", "primary_handle", ".", "get", "(", "'gt'", ")", "\n", "input_metadata", "=", "primary_handle", ".", "get", "(", "'input_metadata'", ")", "\n", "gt_metadata", "=", "primary_handle", ".", "get", "(", "'gt_metadata'", ")", "\n", "\n", "shape", "=", "input_img", "[", "0", "]", ".", "shape", "\n", "\n", "if", "len", "(", "self", ".", "length", ")", "!=", "2", "or", "len", "(", "self", ".", "stride", ")", "!=", "2", ":", "\n", "                ", "raise", "RuntimeError", "(", "'\"length_2D\" and \"stride_2D\" must be of length 2.'", ")", "\n", "", "for", "length", ",", "stride", ",", "size", "in", "zip", "(", "self", ".", "length", ",", "self", ".", "stride", ",", "shape", ")", ":", "\n", "                ", "if", "stride", ">", "length", "or", "stride", "<=", "0", ":", "\n", "                    ", "raise", "RuntimeError", "(", "'\"stride_2D\" must be greater than 0 and smaller or equal to \"length_2D\".'", ")", "\n", "", "if", "length", ">", "size", ":", "\n", "                    ", "raise", "RuntimeError", "(", "'\"length_2D\" must be smaller or equal to image dimensions after resampling.'", ")", "\n", "\n", "", "", "for", "x_min", "in", "range", "(", "0", ",", "(", "shape", "[", "0", "]", "-", "self", ".", "length", "[", "0", "]", "+", "self", ".", "stride", "[", "0", "]", ")", ",", "self", ".", "stride", "[", "0", "]", ")", ":", "\n", "                ", "if", "x_min", "+", "self", ".", "length", "[", "0", "]", ">", "shape", "[", "0", "]", ":", "\n", "                    ", "x_min", "=", "(", "shape", "[", "0", "]", "-", "self", ".", "length", "[", "0", "]", ")", "\n", "", "x_max", "=", "x_min", "+", "self", ".", "length", "[", "0", "]", "\n", "for", "y_min", "in", "range", "(", "0", ",", "(", "shape", "[", "1", "]", "-", "self", ".", "length", "[", "1", "]", "+", "self", ".", "stride", "[", "1", "]", ")", ",", "self", ".", "stride", "[", "1", "]", ")", ":", "\n", "                    ", "if", "y_min", "+", "self", ".", "length", "[", "1", "]", ">", "shape", "[", "1", "]", ":", "\n", "                        ", "y_min", "=", "(", "shape", "[", "1", "]", "-", "self", ".", "length", "[", "1", "]", ")", "\n", "", "y_max", "=", "y_min", "+", "self", ".", "length", "[", "1", "]", "\n", "\n", "# Extract patch from handlers for patch filter", "\n", "patch", "=", "{", "'input'", ":", "list", "(", "np", ".", "asarray", "(", "input_img", ")", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", "]", ")", ",", "\n", "'gt'", ":", "list", "(", "np", ".", "asarray", "(", "gt_img", ")", "[", ":", ",", "x_min", ":", "x_max", ",", "y_min", ":", "y_max", "]", ")", "if", "gt_img", "else", "[", "]", ",", "\n", "'input_metadata'", ":", "input_metadata", ",", "\n", "'gt_metadata'", ":", "gt_metadata", "}", "\n", "if", "self", ".", "patch_filter_fn", "and", "not", "self", ".", "patch_filter_fn", "(", "patch", ")", ":", "\n", "                        ", "continue", "\n", "\n", "", "self", ".", "indexes", ".", "append", "(", "{", "\n", "'x_min'", ":", "x_min", ",", "\n", "'x_max'", ":", "x_max", ",", "\n", "'y_min'", ":", "y_min", ",", "\n", "'y_max'", ":", "y_max", ",", "\n", "'handler_index'", ":", "i", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.set_transform": [[218, 220], ["None"], "methods", ["None"], ["", "", "", "", "def", "set_transform", "(", "self", ",", "transform", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.__len__": [[221, 223], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "indexes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.__getitem__": [[224, 328], ["mri2d_segmentation_dataset.MRI2DSegmentationDataset.transform", "ivadomed.loader.utils.update_metadata", "isinstance", "random.randint", "range", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.transform", "ivadomed.loader.utils.update_metadata", "numpy.asarray", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.transform", "torch.from_numpy().expand", "ivadomed.loader.utils.dropout_input", "copy.deepcopy", "copy.deepcopy", "len", "numpy.asarray", "list", "ivadomed.postprocessing.threshold_predictions().astype", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.handlers[].open", "pickle.load", "mri2d_segmentation_dataset.MRI2DSegmentationDataset.indexes[].open", "pickle.load", "len", "list", "torch.from_numpy", "ivadomed.postprocessing.threshold_predictions"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.dropout_input", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Return the specific processed data corresponding to index (input, ground truth, roi and metadata).\n\n        Args:\n            index (int): Slice index.\n        \"\"\"", "\n", "\n", "# copy.deepcopy is used to have different coordinates for reconstruction for a given handler with patch,", "\n", "# to allow a different rater at each iteration of training, and to clean transforms params from previous", "\n", "# transforms i.e. remove params from previous iterations so that the coming transforms are different", "\n", "if", "self", ".", "is_2d_patch", ":", "\n", "            ", "coord", "=", "self", ".", "indexes", "[", "index", "]", "\n", "if", "self", ".", "disk_cache", ":", "\n", "                ", "with", "self", ".", "handlers", "[", "coord", "[", "'handler_index'", "]", "]", ".", "open", "(", "mode", "=", "\"rb\"", ")", "as", "f", ":", "\n", "                    ", "seg_pair_slice", ",", "roi_pair_slice", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "                ", "seg_pair_slice", ",", "roi_pair_slice", "=", "copy", ".", "deepcopy", "(", "self", ".", "handlers", "[", "coord", "[", "'handler_index'", "]", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "disk_cache", ":", "\n", "                ", "with", "self", ".", "indexes", "[", "index", "]", ".", "open", "(", "mode", "=", "\"rb\"", ")", "as", "f", ":", "\n", "                    ", "seg_pair_slice", ",", "roi_pair_slice", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "                ", "seg_pair_slice", ",", "roi_pair_slice", "=", "copy", ".", "deepcopy", "(", "self", ".", "indexes", "[", "index", "]", ")", "\n", "\n", "# In case multiple raters", "\n", "", "", "if", "seg_pair_slice", "[", "'gt'", "]", "and", "isinstance", "(", "seg_pair_slice", "[", "'gt'", "]", "[", "0", "]", ",", "list", ")", ":", "\n", "# Randomly pick a rater", "\n", "            ", "idx_rater", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "seg_pair_slice", "[", "'gt'", "]", "[", "0", "]", ")", "-", "1", ")", "\n", "# Use it as ground truth for this iteration", "\n", "# Note: in case of multi-class: the same rater is used across classes", "\n", "for", "idx_class", "in", "range", "(", "len", "(", "seg_pair_slice", "[", "'gt'", "]", ")", ")", ":", "\n", "                ", "seg_pair_slice", "[", "'gt'", "]", "[", "idx_class", "]", "=", "seg_pair_slice", "[", "'gt'", "]", "[", "idx_class", "]", "[", "idx_rater", "]", "\n", "seg_pair_slice", "[", "'gt_metadata'", "]", "[", "idx_class", "]", "=", "seg_pair_slice", "[", "'gt_metadata'", "]", "[", "idx_class", "]", "[", "idx_rater", "]", "\n", "\n", "", "", "metadata_input", "=", "seg_pair_slice", "[", "'input_metadata'", "]", "if", "seg_pair_slice", "[", "'input_metadata'", "]", "is", "not", "None", "else", "[", "]", "\n", "metadata_roi", "=", "roi_pair_slice", "[", "'gt_metadata'", "]", "if", "roi_pair_slice", "[", "'gt_metadata'", "]", "is", "not", "None", "else", "[", "]", "\n", "metadata_gt", "=", "seg_pair_slice", "[", "'gt_metadata'", "]", "if", "seg_pair_slice", "[", "'gt_metadata'", "]", "is", "not", "None", "else", "[", "]", "\n", "\n", "if", "self", ".", "is_2d_patch", ":", "\n", "            ", "stack_roi", ",", "metadata_roi", "=", "None", ",", "None", "\n", "", "else", ":", "\n", "# Set coordinates to the slices full size", "\n", "            ", "coord", "=", "{", "}", "\n", "coord", "[", "'x_min'", "]", ",", "coord", "[", "'x_max'", "]", "=", "0", ",", "seg_pair_slice", "[", "\"input\"", "]", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "coord", "[", "'y_min'", "]", ",", "coord", "[", "'y_max'", "]", "=", "0", ",", "seg_pair_slice", "[", "\"input\"", "]", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "\n", "# Run transforms on ROI", "\n", "# ROI goes first because params of ROICrop are needed for the followings", "\n", "stack_roi", ",", "metadata_roi", "=", "self", ".", "transform", "(", "sample", "=", "roi_pair_slice", "[", "\"gt\"", "]", ",", "\n", "metadata", "=", "metadata_roi", ",", "\n", "data_type", "=", "\"roi\"", ")", "\n", "# Update metadata_input with metadata_roi", "\n", "metadata_input", "=", "imed_loader_utils", ".", "update_metadata", "(", "metadata_roi", ",", "metadata_input", ")", "\n", "\n", "# Add coordinates of slices or patches to input metadata", "\n", "", "for", "metadata", "in", "metadata_input", ":", "\n", "            ", "metadata", "[", "'coord'", "]", "=", "[", "coord", "[", "\"x_min\"", "]", ",", "coord", "[", "\"x_max\"", "]", ",", "\n", "coord", "[", "\"y_min\"", "]", ",", "coord", "[", "\"y_max\"", "]", "]", "\n", "\n", "# Extract image and gt slices or patches from coordinates", "\n", "", "stack_input", "=", "np", ".", "asarray", "(", "seg_pair_slice", "[", "\"input\"", "]", ")", "[", ":", ",", "\n", "coord", "[", "'x_min'", "]", ":", "coord", "[", "'x_max'", "]", ",", "\n", "coord", "[", "'y_min'", "]", ":", "coord", "[", "'y_max'", "]", "]", "\n", "if", "seg_pair_slice", "[", "\"gt\"", "]", ":", "\n", "            ", "stack_gt", "=", "np", ".", "asarray", "(", "seg_pair_slice", "[", "\"gt\"", "]", ")", "[", ":", ",", "\n", "coord", "[", "'x_min'", "]", ":", "coord", "[", "'x_max'", "]", ",", "\n", "coord", "[", "'y_min'", "]", ":", "coord", "[", "'y_max'", "]", "]", "\n", "", "else", ":", "\n", "            ", "stack_gt", "=", "[", "]", "\n", "\n", "# Run transforms on image slices or patches", "\n", "", "stack_input", ",", "metadata_input", "=", "self", ".", "transform", "(", "sample", "=", "list", "(", "stack_input", ")", ",", "\n", "metadata", "=", "metadata_input", ",", "\n", "data_type", "=", "\"im\"", ")", "\n", "# Update metadata_gt with metadata_input", "\n", "metadata_gt", "=", "imed_loader_utils", ".", "update_metadata", "(", "metadata_input", ",", "metadata_gt", ")", "\n", "if", "self", ".", "task", "==", "\"segmentation\"", ":", "\n", "# Run transforms on gt slices or patches", "\n", "            ", "stack_gt", ",", "metadata_gt", "=", "self", ".", "transform", "(", "sample", "=", "list", "(", "stack_gt", ")", ",", "\n", "metadata", "=", "metadata_gt", ",", "\n", "data_type", "=", "\"gt\"", ")", "\n", "# Make sure stack_gt is binarized", "\n", "if", "stack_gt", "is", "not", "None", "and", "not", "self", ".", "soft_gt", ":", "\n", "                ", "stack_gt", "=", "imed_postpro", ".", "threshold_predictions", "(", "stack_gt", ",", "thr", "=", "0.5", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "", "else", ":", "\n", "# Force no transformation on labels for classification task", "\n", "# stack_gt is a tensor of size 1x1, values: 0 or 1", "\n", "# \"expand(1)\" is necessary to be compatible with segmentation convention: n_labelxhxwxd", "\n", "            ", "stack_gt", "=", "torch", ".", "from_numpy", "(", "seg_pair_slice", "[", "\"gt\"", "]", "[", "0", "]", ")", ".", "expand", "(", "1", ")", "\n", "\n", "", "data_dict", "=", "{", "\n", "'input'", ":", "stack_input", ",", "\n", "'gt'", ":", "stack_gt", ",", "\n", "'roi'", ":", "stack_roi", ",", "\n", "'input_metadata'", ":", "metadata_input", ",", "\n", "'gt_metadata'", ":", "metadata_gt", ",", "\n", "'roi_metadata'", ":", "metadata_roi", "\n", "}", "\n", "\n", "# Input-level dropout to train with missing modalities", "\n", "if", "self", ".", "is_input_dropout", ":", "\n", "            ", "data_dict", "=", "dropout_input", "(", "data_dict", ")", "\n", "\n", "", "return", "data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.determine_cache_need": [[329, 353], ["ivadomed.loader.utils.get_obj_size", "ivadomed.utils.get_system_memory", "loguru.logger.info", "loguru.logger.info", "len"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_obj_size", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_system_memory"], ["", "def", "determine_cache_need", "(", "self", ",", "item", ":", "tuple", ",", "n_slice", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        When Cache flag is not explicitly set, determine whether to cache the data or not\n        Args:\n            item: an EXAMPLE, typical Tuple structure contain the main data.\n            n_slice: number of slice in one file_name_pairs.\n\n        Returns:\n\n        \"\"\"", "\n", "size_item_in_bytes", "=", "get_obj_size", "(", "item", ")", "\n", "\n", "optimal_ram_limit", "=", "get_system_memory", "(", ")", "*", "0.5", "\n", "\n", "# Size limit: 4GB GPU RAM, keep in mind tranform etc might take MORE!", "\n", "size_estimated_dataset_GB", "=", "(", "size_item_in_bytes", ")", "*", "len", "(", "self", ".", "filename_pairs", ")", "*", "n_slice", "/", "1024", "**", "3", "\n", "if", "size_estimated_dataset_GB", ">", "optimal_ram_limit", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Estimated 2D dataset size is {size_estimated_dataset_GB} GB, which is larger than {optimal_ram_limit} GB. Auto \"", "\n", "f\"enabling disk cache.\"", ")", "\n", "self", ".", "disk_cache", "=", "True", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Estimated 2D dataset size is {size_estimated_dataset_GB} GB, which is smaller than {optimal_ram_limit} GB. File \"", "\n", "f\"cache will not be used\"", ")", "\n", "self", ".", "disk_cache", "=", "False", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.__init__": [[108, 111], ["sklearn.neighbors.KernelDensity"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "kde", "=", "KernelDensity", "(", ")", "\n", "self", ".", "minima", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train": [[112, 132], ["numpy.array().reshape", "sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit", "film.Kde_model.kde.fit", "film.Kde_model.kde.score_samples", "sklearn.neighbors.KernelDensity", "s.reshape", "numpy.array", "scipy.signal.argrelextrema"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "data", ",", "value_range", ",", "gridsearch_bandwidth_range", ")", ":", "\n", "# reshape data to fit sklearn", "\n", "        ", "data", "=", "np", ".", "array", "(", "data", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "# use grid search cross-validation to optimize the bandwidth", "\n", "params", "=", "{", "'bandwidth'", ":", "gridsearch_bandwidth_range", "}", "\n", "grid", "=", "GridSearchCV", "(", "KernelDensity", "(", ")", ",", "params", ",", "cv", "=", "5", ",", "iid", "=", "False", ")", "\n", "grid", ".", "fit", "(", "data", ")", "\n", "\n", "# use the best estimator to compute the kernel density estimate", "\n", "self", ".", "kde", "=", "grid", ".", "best_estimator_", "\n", "\n", "# fit kde with the best bandwidth", "\n", "self", ".", "kde", ".", "fit", "(", "data", ")", "\n", "\n", "s", "=", "value_range", "\n", "e", "=", "self", ".", "kde", ".", "score_samples", "(", "s", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# find local minima", "\n", "self", ".", "minima", "=", "s", "[", "argrelextrema", "(", "e", ",", "np", ".", "less", ")", "[", "0", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.predict": [[133, 137], ["len", "min", "len", "enumerate"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "data", ")", ":", "\n", "        ", "x", "=", "[", "i", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "minima", ")", "if", "data", "<", "m", "]", "\n", "pred", "=", "min", "(", "x", ")", "if", "len", "(", "x", ")", "else", "len", "(", "self", ".", "minima", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.normalize_metadata": [[22, 96], ["enumerate", "sklearn.preprocessing.OneHotEncoder", "copy.deepcopy", "enumerate", "numpy.vstack", "sklearn.preprocessing.OneHotEncoder.fit", "ds_out.append", "clustering_models[].predict", "loguru.logger.info", "enumerate", "enumerate", "np.vstack.append", "loguru.logger.info", "loguru.logger.info"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.predict"], ["def", "normalize_metadata", "(", "ds_in", ",", "clustering_models", ",", "debugging", ",", "metadata_type", ",", "train_set", "=", "False", ")", ":", "\n", "    ", "\"\"\"Categorize each metadata value using a KDE clustering method, then apply a one-hot-encoding.\n\n    Args:\n         ds_in (BidsDataset): Dataset with metadata.\n         clustering_models: Pre-trained clustering model that has been trained on metadata of the training set.\n         debugging (bool): If True, extended verbosity and intermediate outputs.\n         metadata_type (str): Choice between 'mri_params', 'constrasts' or the name of a column from the\n            participants.tsv file.\n         train_set (bool): Indicates if the input dataset is the training dataset (True) or the validation or testing\n            dataset (False).\n\n    Returns:\n        BidsDataset: Dataset with normalized metadata. If train_set is True, then the one-hot-encoder model is also\n            returned.\n    \"\"\"", "\n", "if", "train_set", ":", "\n", "# Initialise One Hot Encoder", "\n", "        ", "ohe", "=", "OneHotEncoder", "(", "sparse", "=", "False", ",", "handle_unknown", "=", "'ignore'", ")", "\n", "X_train_ohe", "=", "[", "]", "\n", "\n", "", "ds_out", "=", "[", "]", "\n", "for", "idx", ",", "subject", "in", "enumerate", "(", "ds_in", ")", ":", "\n", "        ", "s_out", "=", "deepcopy", "(", "subject", ")", "\n", "if", "metadata_type", "==", "MetadataKW", ".", "MRI_PARAMS", ":", "\n", "# categorize flip angle, repetition time and echo time values using KDE", "\n", "            ", "for", "m", "in", "[", "'FlipAngle'", ",", "'RepetitionTime'", ",", "'EchoTime'", "]", ":", "\n", "                ", "v", "=", "subject", "[", "\"input_metadata\"", "]", "[", "m", "]", "\n", "p", "=", "clustering_models", "[", "m", "]", ".", "predict", "(", "v", ")", "\n", "s_out", "[", "\"input_metadata\"", "]", "[", "m", "]", "=", "p", "\n", "if", "debugging", ":", "\n", "                    ", "logger", ".", "info", "(", "\"{}: {} --> {}\"", ".", "format", "(", "m", ",", "v", ",", "p", ")", ")", "\n", "\n", "# categorize manufacturer info based on the MANUFACTURER_CATEGORY dictionary", "\n", "", "", "manufacturer", "=", "subject", "[", "\"input_metadata\"", "]", "[", "\"Manufacturer\"", "]", "\n", "if", "manufacturer", "in", "MANUFACTURER_CATEGORY", ":", "\n", "                ", "s_out", "[", "\"input_metadata\"", "]", "[", "\"Manufacturer\"", "]", "=", "MANUFACTURER_CATEGORY", "[", "manufacturer", "]", "\n", "if", "debugging", ":", "\n", "                    ", "logger", ".", "info", "(", "\"Manufacturer: {} --> {}\"", ".", "format", "(", "manufacturer", ",", "\n", "MANUFACTURER_CATEGORY", "[", "manufacturer", "]", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "logger", ".", "info", "(", "\"{} with unknown manufacturer.\"", ".", "format", "(", "subject", ")", ")", "\n", "# if unknown manufacturer, then value set to -1", "\n", "s_out", "[", "\"input_metadata\"", "]", "[", "\"Manufacturer\"", "]", "=", "-", "1", "\n", "\n", "", "s_out", "[", "\"input_metadata\"", "]", "[", "\"film_input\"", "]", "=", "[", "s_out", "[", "\"input_metadata\"", "]", "[", "k", "]", "for", "k", "in", "\n", "[", "\"FlipAngle\"", ",", "\"RepetitionTime\"", ",", "\"EchoTime\"", ",", "\"Manufacturer\"", "]", "]", "\n", "", "elif", "metadata_type", "==", "MetadataKW", ".", "CONTRASTS", ":", "\n", "            ", "for", "i", ",", "input_metadata", "in", "enumerate", "(", "subject", "[", "\"input_metadata\"", "]", ")", ":", "\n", "                ", "generic_contrast", "=", "GENERIC_CONTRAST", "[", "input_metadata", "[", "\"contrast\"", "]", "]", "\n", "label_contrast", "=", "CONTRAST_CATEGORY", "[", "generic_contrast", "]", "\n", "s_out", "[", "\"input_metadata\"", "]", "[", "i", "]", "[", "\"film_input\"", "]", "=", "[", "label_contrast", "]", "\n", "", "", "else", ":", "\n", "            ", "for", "i", ",", "input_metadata", "in", "enumerate", "(", "subject", "[", "\"input_metadata\"", "]", ")", ":", "\n", "                ", "data", "=", "input_metadata", "[", "metadata_type", "]", "\n", "label_contrast", "=", "input_metadata", "[", "'metadata_dict'", "]", "[", "data", "]", "\n", "s_out", "[", "\"input_metadata\"", "]", "[", "i", "]", "[", "\"film_input\"", "]", "=", "[", "label_contrast", "]", "\n", "\n", "", "", "for", "i", ",", "input_metadata", "in", "enumerate", "(", "subject", "[", "\"input_metadata\"", "]", ")", ":", "\n", "            ", "if", "'contrast'", "in", "input_metadata", ":", "\n", "                ", "s_out", "[", "\"input_metadata\"", "]", "[", "i", "]", "[", "\"contrast\"", "]", "=", "input_metadata", "[", "\"contrast\"", "]", "\n", "\n", "", "if", "train_set", ":", "\n", "                ", "X_train_ohe", ".", "append", "(", "s_out", "[", "\"input_metadata\"", "]", "[", "i", "]", "[", "\"film_input\"", "]", ")", "\n", "", "ds_out", ".", "append", "(", "s_out", ")", "\n", "\n", "", "del", "s_out", ",", "subject", "\n", "\n", "", "if", "train_set", ":", "\n", "        ", "X_train_ohe", "=", "np", ".", "vstack", "(", "X_train_ohe", ")", "\n", "ohe", ".", "fit", "(", "X_train_ohe", ")", "\n", "return", "ds_out", ",", "ohe", "\n", "", "else", ":", "\n", "        ", "return", "ds_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.clustering_fit": [[139, 164], ["film.Kde_model", "film.Kde_model.train", "numpy.linspace", "numpy.logspace", "numpy.logspace", "numpy.logspace", "numpy.logspace", "numpy.logspace"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.Kde_model.train"], ["", "", "def", "clustering_fit", "(", "dataset", ",", "key_lst", ")", ":", "\n", "    ", "\"\"\"This function creates clustering models for each metadata type,\n    using Kernel Density Estimation algorithm.\n\n    Args:\n        datasets (list): data\n        key_lst (list of str): names of metadata to cluster\n\n    Returns:\n        dict: Clustering model for each metadata type in a dictionary where the keys are the metadata names.\n    \"\"\"", "\n", "KDE_PARAM", "=", "{", "'FlipAngle'", ":", "{", "'range'", ":", "np", ".", "linspace", "(", "0", ",", "360", ",", "1000", ")", ",", "'gridsearch'", ":", "np", ".", "logspace", "(", "-", "4", ",", "1", ",", "50", ")", "}", ",", "\n", "'RepetitionTime'", ":", "{", "'range'", ":", "np", ".", "logspace", "(", "-", "1", ",", "1", ",", "1000", ")", ",", "'gridsearch'", ":", "np", ".", "logspace", "(", "-", "4", ",", "1", ",", "50", ")", "}", ",", "\n", "'EchoTime'", ":", "{", "'range'", ":", "np", ".", "logspace", "(", "-", "3", ",", "1", ",", "1000", ")", ",", "'gridsearch'", ":", "np", ".", "logspace", "(", "-", "4", ",", "1", ",", "50", ")", "}", "}", "\n", "\n", "model_dct", "=", "{", "}", "\n", "for", "k", "in", "key_lst", ":", "\n", "        ", "k_data", "=", "[", "value", "for", "value", "in", "dataset", "[", "k", "]", "]", "\n", "\n", "kde", "=", "Kde_model", "(", ")", "\n", "kde", ".", "train", "(", "k_data", ",", "KDE_PARAM", "[", "k", "]", "[", "'range'", "]", ",", "KDE_PARAM", "[", "k", "]", "[", "'gridsearch'", "]", ")", "\n", "\n", "model_dct", "[", "k", "]", "=", "kde", "\n", "\n", "", "return", "model_dct", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.check_isMRIparam": [[166, 193], ["loguru.logger.info", "metadata[].append", "isinstance", "float", "numpy.mean", "float", "mri_param[].split"], "function", ["None"], ["", "def", "check_isMRIparam", "(", "mri_param_type", ":", "str", ",", "mri_param", ":", "dict", ",", "subject", ":", "str", ",", "metadata", ":", "dict", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Check if a given metadata belongs to the MRI parameters.\n\n    Args:\n        mri_param_type (str): Metadata type name.\n        mri_param (dict): List of MRI params names.\n        subject (str): Current subject name.\n        metadata (dict): Metadata.\n\n    Returns:\n        bool: True if `mri_param_type` is part of `mri_param`.\n    \"\"\"", "\n", "if", "mri_param_type", "not", "in", "mri_param", ":", "\n", "        ", "logger", ".", "info", "(", "\"{} without {}, skipping.\"", ".", "format", "(", "subject", ",", "mri_param_type", ")", ")", "\n", "return", "False", "\n", "", "else", ":", "\n", "        ", "if", "mri_param_type", "==", "\"Manufacturer\"", ":", "\n", "            ", "value", "=", "mri_param", "[", "mri_param_type", "]", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "mri_param", "[", "mri_param_type", "]", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "                ", "value", "=", "float", "(", "mri_param", "[", "mri_param_type", "]", ")", "\n", "", "else", ":", "# eg multi-echo data have 3 echo times", "\n", "                ", "value", "=", "np", ".", "mean", "(", "[", "float", "(", "v", ")", "\n", "for", "v", "in", "mri_param", "[", "mri_param_type", "]", ".", "split", "(", "','", ")", "]", ")", "\n", "\n", "", "", "metadata", "[", "mri_param_type", "]", ".", "append", "(", "value", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.get_film_metadata_models": [[195, 222], ["film.normalize_metadata", "film.clustering_fit"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.normalize_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.clustering_fit"], ["", "", "def", "get_film_metadata_models", "(", "ds_train", ",", "metadata_type", ",", "debugging", "=", "False", ")", ":", "\n", "    ", "\"\"\"Get FiLM models.\n\n    This function pulls the clustering and one-hot encoder models that are used by FiLMedUnet.\n    It also calls the normalization of metadata.\n\n    Args:\n        ds_train (MRI2DSegmentationDataset): training dataset\n        metadata_type (string): eg mri_params, contrasts\n        debugging (bool):\n\n    Returns:\n        MRI2DSegmentationDataset, OneHotEncoder, KernelDensity: dataset, one-hot encoder and KDE model\n    \"\"\"", "\n", "if", "metadata_type", "==", "MetadataKW", ".", "MRI_PARAMS", ":", "\n", "        ", "metadata_vector", "=", "[", "\"RepetitionTime\"", ",", "\"EchoTime\"", ",", "\"FlipAngle\"", "]", "\n", "metadata_clustering_models", "=", "clustering_fit", "(", "ds_train", ".", "metadata", ",", "metadata_vector", ")", "\n", "", "else", ":", "\n", "        ", "metadata_clustering_models", "=", "None", "\n", "\n", "", "ds_train", ",", "train_onehotencoder", "=", "normalize_metadata", "(", "ds_train", ",", "\n", "metadata_clustering_models", ",", "\n", "debugging", ",", "\n", "metadata_type", ",", "\n", "True", ")", "\n", "\n", "return", "ds_train", ",", "train_onehotencoder", ",", "metadata_clustering_models", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.store_film_params": [[224, 256], ["metadata_values.append", "gammas[].append", "betas[].append", "range", "enumerate", "layer_cur.gammas[].cpu().numpy", "layer_cur.betas[].cpu().numpy", "len", "layer_cur.gammas[].cpu", "layer_cur.betas[].cpu"], "function", ["None"], ["", "def", "store_film_params", "(", "gammas", ",", "betas", ",", "metadata_values", ",", "metadata", ",", "model", ",", "film_layers", ",", "depth", ",", "film_metadata", ")", ":", "\n", "    ", "\"\"\"Store FiLM params.\n\n    Args:\n        gammas (dict):\n        betas (dict):\n        metadata_values (list): list of the batch sample's metadata values (e.g., T2w, astrocytoma)\n        metadata (list):\n        model (nn.Module):\n        film_layers (list):\n        depth (int):\n        film_metadata (str): Metadata of interest used to modulate the network (e.g., contrast, tumor_type).\n\n    Returns:\n        dict, dict: gammas, betas\n    \"\"\"", "\n", "new_input", "=", "[", "metadata", "[", "k", "]", "[", "0", "]", "[", "film_metadata", "]", "for", "k", "in", "range", "(", "len", "(", "metadata", ")", ")", "]", "\n", "metadata_values", ".", "append", "(", "new_input", ")", "\n", "# Fill the lists of gammas and betas", "\n", "for", "idx", "in", "[", "i", "for", "i", ",", "x", "in", "enumerate", "(", "film_layers", ")", "if", "x", "]", ":", "\n", "        ", "if", "idx", "<", "depth", ":", "\n", "            ", "layer_cur", "=", "model", ".", "encoder", ".", "down_path", "[", "idx", "*", "3", "+", "1", "]", "\n", "", "elif", "idx", "==", "depth", ":", "\n", "            ", "layer_cur", "=", "model", ".", "encoder", ".", "film_bottom", "\n", "", "elif", "idx", "==", "depth", "*", "2", "+", "1", ":", "\n", "            ", "layer_cur", "=", "model", ".", "decoder", ".", "last_film", "\n", "", "else", ":", "\n", "            ", "layer_cur", "=", "model", ".", "decoder", ".", "up_path", "[", "(", "idx", "-", "depth", "-", "1", ")", "*", "2", "+", "1", "]", "\n", "\n", "", "gammas", "[", "idx", "+", "1", "]", ".", "append", "(", "layer_cur", ".", "gammas", "[", ":", ",", ":", ",", "0", ",", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "betas", "[", "idx", "+", "1", "]", ".", "append", "(", "layer_cur", ".", "betas", "[", ":", ",", ":", ",", "0", ",", "0", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "return", "gammas", ",", "betas", ",", "metadata_values", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.film.save_film_params": [[258, 287], ["range", "numpy.array", "pathlib.Path", "numpy.save", "numpy.array", "numpy.array", "pathlib.Path", "numpy.save", "pathlib.Path", "numpy.save", "str", "range", "range", "str", "str"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["", "def", "save_film_params", "(", "gammas", ",", "betas", ",", "metadata_values", ",", "depth", ",", "ofolder", ")", ":", "\n", "    ", "\"\"\"Save FiLM params as npy files.\n\n    These parameters can be further used for visualisation purposes. They are saved in the `ofolder` with `.npy` format.\n\n    Args:\n        gammas (dict):\n        betas (dict):\n        metadata_values (list): list of the batch sample's metadata values (eg T2w, T1w, if metadata type used is\n        contrast)\n        depth (int):\n        ofolder (str):\n\n    \"\"\"", "\n", "# Convert list of gammas/betas into numpy arrays", "\n", "gammas_dict", "=", "{", "i", ":", "np", ".", "array", "(", "gammas", "[", "i", "]", ")", "for", "i", "in", "range", "(", "1", ",", "2", "*", "depth", "+", "3", ")", "}", "\n", "betas_dict", "=", "{", "i", ":", "np", ".", "array", "(", "betas", "[", "i", "]", ")", "for", "i", "in", "range", "(", "1", ",", "2", "*", "depth", "+", "3", ")", "}", "\n", "\n", "# Save the numpy arrays for gammas/betas inside files.npy in log_directory", "\n", "for", "i", "in", "range", "(", "1", ",", "2", "*", "depth", "+", "3", ")", ":", "\n", "        ", "gamma_layer_path", "=", "Path", "(", "ofolder", ",", "f\"gamma_layer_{i}.npy\"", ")", "\n", "np", ".", "save", "(", "str", "(", "gamma_layer_path", ")", ",", "gammas_dict", "[", "i", "]", ")", "\n", "beta_layer_path", "=", "Path", "(", "ofolder", ",", "f\"beta_layer_{i}.npy\"", ")", "\n", "np", ".", "save", "(", "str", "(", "beta_layer_path", ")", ",", "betas_dict", "[", "i", "]", ")", "\n", "\n", "# Convert into numpy and save the metadata_values of all batch images", "\n", "", "metadata_values", "=", "np", ".", "array", "(", "metadata_values", ")", "\n", "contrast_path", "=", "Path", "(", "ofolder", ",", "\"metadata_values.npy\"", ")", "\n", "np", ".", "save", "(", "str", "(", "contrast_path", ")", ",", "metadata_values", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.slice_filter.SliceFilter.__init__": [[32, 49], ["torch.load", "torch.load"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "filter_empty_mask", ":", "bool", "=", "False", ",", "\n", "filter_absent_class", ":", "bool", "=", "False", ",", "\n", "filter_empty_input", ":", "bool", "=", "True", ",", "\n", "filter_classification", ":", "bool", "=", "False", ",", "\n", "classifier_path", "=", "None", ",", "device", "=", "None", ",", "cuda_available", "=", "None", ")", ":", "\n", "        ", "self", ".", "filter_empty_mask", "=", "filter_empty_mask", "\n", "self", ".", "filter_absent_class", "=", "filter_absent_class", "\n", "self", ".", "filter_empty_input", "=", "filter_empty_input", "\n", "self", ".", "filter_classification", "=", "filter_classification", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "cuda_available", "=", "cuda_available", "\n", "\n", "if", "self", ".", "filter_classification", ":", "\n", "            ", "if", "cuda_available", ":", "\n", "                ", "self", ".", "classifier", "=", "torch", ".", "load", "(", "classifier_path", ",", "map_location", "=", "device", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "classifier", "=", "torch", ".", "load", "(", "classifier_path", ",", "map_location", "=", "'cpu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.slice_filter.SliceFilter.__call__": [[50, 77], ["numpy.any", "numpy.any", "numpy.all", "numpy.all", "numpy.any", "img.std", "int", "slice_filter.SliceFilter.classifier", "ivadomed.utils.cuda", "torch.from_numpy().unsqueeze().unsqueeze", "torch.from_numpy().unsqueeze", "torch.from_numpy", "img.copy"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.cuda"], ["", "", "", "def", "__call__", "(", "self", ",", "sample", ":", "dict", ")", ":", "\n", "        ", "\"\"\"Extract input_data and gt_data lists from sample dict and discard them if they don't match certain\n        conditions.\n\n        \"\"\"", "\n", "input_data", ",", "gt_data", "=", "sample", "[", "'input'", "]", ",", "sample", "[", "'gt'", "]", "\n", "\n", "if", "self", ".", "filter_empty_mask", ":", "\n", "# Discard slices that do not have ANY ground truth (i.e. all masks are empty)", "\n", "            ", "if", "not", "np", ".", "any", "(", "gt_data", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "if", "self", ".", "filter_absent_class", ":", "\n", "# Discard slices that have absent classes (i.e. one or more masks are empty)", "\n", "            ", "if", "not", "np", ".", "all", "(", "[", "np", ".", "any", "(", "mask", ")", "for", "mask", "in", "gt_data", "]", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "if", "self", ".", "filter_empty_input", ":", "\n", "# Discard set of images if one of them is empty or filled with constant value (i.e. std == 0)", "\n", "            ", "if", "np", ".", "any", "(", "[", "img", ".", "std", "(", ")", "==", "0", "for", "img", "in", "input_data", "]", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "if", "self", ".", "filter_classification", ":", "\n", "            ", "if", "not", "np", ".", "all", "(", "[", "int", "(", "\n", "self", ".", "classifier", "(", "\n", "imed_utils", ".", "cuda", "(", "torch", ".", "from_numpy", "(", "img", ".", "copy", "(", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "cuda_available", ")", ")", ")", "for", "img", "in", "input_data", "]", ")", ":", "\n", "                ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler.__init__": [[22, 41], ["list", "len", "torch.DoubleTensor", "range", "balanced_sampler.BalancedSampler._get_label", "len", "balanced_sampler.BalancedSampler._get_label"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler._get_label", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler._get_label"], ["def", "__init__", "(", "self", ",", "dataset", ",", "metadata", "=", "'gt'", ")", ":", "\n", "        ", "self", ".", "indices", "=", "list", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "\n", "self", ".", "nb_samples", "=", "len", "(", "self", ".", "indices", ")", "\n", "self", ".", "metadata_dict", "=", "{", "}", "\n", "self", ".", "label_idx", "=", "0", "\n", "\n", "cmpt_label", "=", "{", "}", "\n", "for", "idx", "in", "self", ".", "indices", ":", "\n", "            ", "label", "=", "self", ".", "_get_label", "(", "dataset", ",", "idx", ",", "metadata", ")", "\n", "if", "label", "in", "cmpt_label", ":", "\n", "                ", "cmpt_label", "[", "label", "]", "+=", "1", "\n", "", "else", ":", "\n", "                ", "cmpt_label", "[", "label", "]", "=", "1", "\n", "\n", "", "", "weights", "=", "[", "1.0", "/", "cmpt_label", "[", "self", ".", "_get_label", "(", "dataset", ",", "idx", ",", "metadata", ")", "]", "\n", "for", "idx", "in", "self", ".", "indices", "]", "\n", "\n", "self", ".", "weights", "=", "torch", ".", "DoubleTensor", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler._get_label": [[42, 66], ["numpy.array", "numpy.any"], "methods", ["None"], ["", "def", "_get_label", "(", "self", ",", "dataset", ",", "idx", ",", "metadata", ")", ":", "\n", "        ", "\"\"\"Returns 1 if sample is not empty, 0 if it is empty (only zeros).\n\n        Args:\n            dataset (BidsDataset): Dataset containing input, gt and metadata.\n            idx (int): Element index.\n\n        Returns:\n            int: 0 or 1.\n        \"\"\"", "\n", "if", "metadata", "!=", "'gt'", ":", "\n", "            ", "label_str", "=", "dataset", "[", "idx", "]", "[", "'input_metadata'", "]", "[", "0", "]", "[", "metadata", "]", "\n", "if", "label_str", "not", "in", "self", ".", "metadata_dict", ":", "\n", "                ", "self", ".", "metadata_dict", "[", "label_str", "]", "=", "self", ".", "label_idx", "\n", "self", ".", "label_idx", "+=", "1", "\n", "", "return", "self", ".", "metadata_dict", "[", "label_str", "]", "\n", "\n", "", "else", ":", "\n", "# For now, only supported with single label", "\n", "            ", "sample_gt", "=", "np", ".", "array", "(", "dataset", "[", "idx", "]", "[", "'gt'", "]", "[", "0", "]", ")", "\n", "if", "np", ".", "any", "(", "sample_gt", ")", ":", "\n", "                ", "return", "1", "\n", "", "else", ":", "\n", "                ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler.__iter__": [[67, 70], ["torch.multinomial"], "methods", ["None"], ["", "", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "indices", "[", "i", "]", "for", "i", "in", "torch", ".", "multinomial", "(", "\n", "self", ".", "weights", ",", "self", ".", "nb_samples", ",", "replacement", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.balanced_sampler.BalancedSampler.__len__": [[71, 73], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.__init__": [[44, 65], ["mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._load_filenames", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._prepare_indices"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._load_filenames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._prepare_indices"], ["def", "__init__", "(", "self", ",", "filename_pairs", ",", "transform", "=", "None", ",", "length", "=", "(", "64", ",", "64", ",", "64", ")", ",", "stride", "=", "(", "0", ",", "0", ",", "0", ")", ",", "slice_axis", "=", "0", ",", "\n", "task", "=", "\"segmentation\"", ",", "soft_gt", "=", "False", ",", "is_input_dropout", "=", "False", ",", "disk_cache", "=", "True", ")", ":", "\n", "        ", "self", ".", "filename_pairs", "=", "filename_pairs", "\n", "\n", "# could be a list of tuple of objects OR path objects to the actual disk equivalent.", "\n", "# behaves differently depend on if self.cache is set to true or not.", "\n", "self", ".", "handlers", ":", "List", "[", "tuple", "]", "=", "[", "]", "\n", "\n", "self", ".", "indexes", ":", "list", "=", "[", "]", "\n", "self", ".", "length", "=", "length", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "prepro_transforms", ",", "self", ".", "transform", "=", "transform", "\n", "self", ".", "slice_axis", "=", "slice_axis", "\n", "self", ".", "has_bounding_box", ":", "bool", "=", "True", "\n", "self", ".", "task", "=", "task", "\n", "self", ".", "soft_gt", "=", "soft_gt", "\n", "self", ".", "is_input_dropout", "=", "is_input_dropout", "\n", "self", ".", "disk_cache", ":", "bool", "=", "disk_cache", "\n", "\n", "self", ".", "_load_filenames", "(", ")", "\n", "self", ".", "_prepare_indices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._load_filenames": [[66, 112], ["pathlib.Path", "ivadomed.loader.utils.create_temp_directory", "ivadomed.loader.segmentation_pair.SegmentationPair", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_data", "ivadomed.loader.segmentation_pair.SegmentationPair.get_pair_metadata", "ivadomed.object_detection.utils.verify_metadata", "ivadomed.transforms.apply_preprocessing_transforms", "ivadomed.object_detection.utils.adjust_transforms", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.determine_cache_need", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.handlers.append", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.handlers.append", "path_cache_seg_pair.open", "pickle.dump", "path_cache_roi_pair.open", "pickle.dump", "ivadomed.utils.get_timestamp", "ivadomed.utils.get_timestamp"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.create_temp_directory", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_data", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.verify_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.apply_preprocessing_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.object_detection.utils.adjust_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.determine_cache_need", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_timestamp"], ["", "def", "_load_filenames", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load preprocessed pair data (input and gt) in handler.\"\"\"", "\n", "path_temp", ":", "Path", "=", "Path", "(", "create_temp_directory", "(", ")", ")", "\n", "\n", "for", "input_filename", ",", "gt_filename", ",", "roi_filename", ",", "metadata", "in", "self", ".", "filename_pairs", ":", "\n", "            ", "segpair", "=", "SegmentationPair", "(", "input_filename", ",", "gt_filename", ",", "metadata", "=", "metadata", ",", "slice_axis", "=", "self", ".", "slice_axis", ",", "\n", "soft_gt", "=", "self", ".", "soft_gt", ")", "\n", "input_data", ",", "gt_data", "=", "segpair", ".", "get_pair_data", "(", ")", "\n", "metadata", "=", "segpair", ".", "get_pair_metadata", "(", ")", "\n", "seg_pair", "=", "{", "\n", "'input'", ":", "input_data", ",", "\n", "'gt'", ":", "gt_data", ",", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "metadata", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "metadata", "[", "MetadataKW", ".", "GT_METADATA", "]", "\n", "}", "\n", "\n", "self", ".", "has_bounding_box", "=", "imed_obj_detect", ".", "verify_metadata", "(", "seg_pair", ",", "self", ".", "has_bounding_box", ")", "\n", "if", "self", ".", "has_bounding_box", ":", "\n", "                ", "self", ".", "prepro_transforms", "=", "imed_obj_detect", ".", "adjust_transforms", "(", "self", ".", "prepro_transforms", ",", "seg_pair", ",", "\n", "length", "=", "self", ".", "length", ",", "\n", "stride", "=", "self", ".", "stride", ")", "\n", "", "seg_pair", ",", "roi_pair", "=", "imed_transforms", ".", "apply_preprocessing_transforms", "(", "self", ".", "prepro_transforms", ",", "\n", "seg_pair", "=", "seg_pair", ")", "\n", "\n", "for", "metadata", "in", "seg_pair", "[", "MetadataKW", ".", "INPUT_METADATA", "]", ":", "\n", "                ", "metadata", "[", "MetadataKW", ".", "INDEX_SHAPE", "]", "=", "seg_pair", "[", "'input'", "]", "[", "0", "]", ".", "shape", "\n", "\n", "# First time detemine cache automatically IF not specified. Otherwise, use the cache specified.", "\n", "", "if", "self", ".", "disk_cache", "is", "None", ":", "\n", "                ", "self", ".", "disk_cache", "=", "self", ".", "determine_cache_need", "(", "seg_pair", ",", "roi_pair", ")", "\n", "\n", "", "if", "self", ".", "disk_cache", ":", "\n", "# Write SegPair and ROIPair to disk cache with timestamp to avoid collisions", "\n", "                ", "path_cache_seg_pair", "=", "path_temp", "/", "f'seg_pair_{get_timestamp()}.pkl'", "\n", "with", "path_cache_seg_pair", ".", "open", "(", "mode", "=", "'wb'", ")", "as", "f", ":", "\n", "                    ", "pickle", ".", "dump", "(", "seg_pair", ",", "f", ")", "\n", "\n", "", "path_cache_roi_pair", "=", "path_temp", "/", "f'roi_pair_{get_timestamp()}.pkl'", "\n", "with", "path_cache_roi_pair", ".", "open", "(", "mode", "=", "'wb'", ")", "as", "f", ":", "\n", "                    ", "pickle", ".", "dump", "(", "roi_pair", ",", "f", ")", "\n", "", "self", ".", "handlers", ".", "append", "(", "(", "path_cache_seg_pair", ",", "path_cache_roi_pair", ")", ")", "\n", "\n", "", "else", ":", "\n", "# self.handler is now a list of a FILES instead of actual data to prevent this list from taking up too much", "\n", "# memory", "\n", "                ", "self", ".", "handlers", ".", "append", "(", "(", "seg_pair", ",", "roi_pair", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset._prepare_indices": [[113, 146], ["range", "len", "pickle.load.get", "range", "RuntimeError", "range", "[].open", "pickle.load", "range", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.indexes.append"], "methods", ["None"], ["", "", "", "def", "_prepare_indices", "(", "self", ")", ":", "\n", "        ", "\"\"\"Stores coordinates of subvolumes for training.\"\"\"", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "handlers", ")", ")", ":", "\n", "\n", "            ", "if", "self", ".", "disk_cache", ":", "\n", "                ", "with", "self", ".", "handlers", "[", "i", "]", "[", "0", "]", ".", "open", "(", "mode", "=", "'rb'", ")", "as", "f", ":", "\n", "                    ", "segpair", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "                ", "segpair", "=", "self", ".", "handlers", "[", "i", "]", "[", "0", "]", "\n", "\n", "", "input_img", "=", "segpair", ".", "get", "(", "'input'", ")", "\n", "shape", "=", "input_img", "[", "0", "]", ".", "shape", "\n", "\n", "if", "(", "(", "shape", "[", "0", "]", "-", "self", ".", "length", "[", "0", "]", ")", "%", "self", ".", "stride", "[", "0", "]", ")", "!=", "0", "or", "self", ".", "length", "[", "0", "]", "%", "16", "!=", "0", "or", "shape", "[", "0", "]", "<", "self", ".", "length", "[", "0", "]", "or", "(", "(", "shape", "[", "1", "]", "-", "self", ".", "length", "[", "1", "]", ")", "%", "self", ".", "stride", "[", "1", "]", ")", "!=", "0", "or", "self", ".", "length", "[", "1", "]", "%", "16", "!=", "0", "or", "shape", "[", "1", "]", "<", "self", ".", "length", "[", "1", "]", "or", "(", "(", "shape", "[", "2", "]", "-", "self", ".", "length", "[", "2", "]", ")", "%", "self", ".", "stride", "[", "2", "]", ")", "!=", "0", "or", "self", ".", "length", "[", "2", "]", "%", "16", "!=", "0", "or", "shape", "[", "2", "]", "<", "self", ".", "length", "[", "2", "]", ":", "\n", "                ", "raise", "RuntimeError", "(", "'Input shape of each dimension should be a \\\n                                    multiple of length plus 2 * padding and a multiple of 16.'", ")", "\n", "\n", "", "for", "x", "in", "range", "(", "0", ",", "(", "shape", "[", "0", "]", "-", "self", ".", "length", "[", "0", "]", ")", "+", "1", ",", "self", ".", "stride", "[", "0", "]", ")", ":", "\n", "                ", "for", "y", "in", "range", "(", "0", ",", "(", "shape", "[", "1", "]", "-", "self", ".", "length", "[", "1", "]", ")", "+", "1", ",", "self", ".", "stride", "[", "1", "]", ")", ":", "\n", "                    ", "for", "z", "in", "range", "(", "0", ",", "(", "shape", "[", "2", "]", "-", "self", ".", "length", "[", "2", "]", ")", "+", "1", ",", "self", ".", "stride", "[", "2", "]", ")", ":", "\n", "                        ", "self", ".", "indexes", ".", "append", "(", "{", "\n", "'x_min'", ":", "x", ",", "\n", "'x_max'", ":", "x", "+", "self", ".", "length", "[", "0", "]", ",", "\n", "'y_min'", ":", "y", ",", "\n", "'y_max'", ":", "y", "+", "self", ".", "length", "[", "1", "]", ",", "\n", "'z_min'", ":", "z", ",", "\n", "'z_max'", ":", "z", "+", "self", ".", "length", "[", "2", "]", ",", "\n", "'handler_index'", ":", "i", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.__len__": [[147, 150], ["len"], "methods", ["None"], ["", "", "", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the dataset size. The number of subvolumes.\"\"\"", "\n", "return", "len", "(", "self", ".", "indexes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.__getitem__": [[151, 258], ["coord.get", "coord.get", "coord.get", "coord.get", "coord.get", "coord.get", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.transform", "ivadomed.loader.utils.update_metadata", "mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.transform", "copy.deepcopy", "isinstance", "random.randint", "range", "numpy.asarray", "ivadomed.postprocessing.threshold_predictions().astype", "ivadomed.loader.utils.dropout_input", "coord.get", "tuple_seg_roi_pair[].open", "pickle.load", "len", "numpy.asarray", "len", "ivadomed.postprocessing.threshold_predictions"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.dropout_input", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "def", "__getitem__", "(", "self", ",", "subvolume_index", ":", "int", ")", ":", "\n", "        ", "\"\"\"Return the specific index pair subvolume (input, ground truth).\n\n        Args:\n            subvolume_index (int): Subvolume index.\n        \"\"\"", "\n", "\n", "# copy.deepcopy is used to have different coordinates for reconstruction for a given handler,", "\n", "# to allow a different rater at each iteration of training, and to clean transforms params from previous", "\n", "# transforms i.e. remove params from previous iterations so that the coming transforms are different", "\n", "\n", "# Get the tuple that defines the boundaries for the subsample", "\n", "coord", ":", "dict", "=", "self", ".", "indexes", "[", "subvolume_index", "]", "\n", "x_min", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "X_MIN", ")", "\n", "x_max", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "X_MAX", ")", "\n", "y_min", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "Y_MIN", ")", "\n", "y_max", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "Y_MAX", ")", "\n", "z_min", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "Z_MIN", ")", "\n", "z_max", "=", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "Z_MAX", ")", "\n", "\n", "# Obtain tuple reference to the pairs of file references", "\n", "tuple_seg_roi_pair", ":", "tuple", "=", "self", ".", "handlers", "[", "coord", ".", "get", "(", "SegmentationDatasetKW", ".", "HANDLER_INDEX", ")", "]", "\n", "\n", "# Disk Cache handling, either, load the seg_pair, not using ROI pair here.", "\n", "if", "self", ".", "disk_cache", ":", "\n", "            ", "with", "tuple_seg_roi_pair", "[", "0", "]", ".", "open", "(", "mode", "=", "'rb'", ")", "as", "f", ":", "\n", "                ", "seg_pair", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "            ", "seg_pair", ",", "_", "=", "copy", ".", "deepcopy", "(", "tuple_seg_roi_pair", ")", "\n", "\n", "# In case multiple raters", "\n", "", "if", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", "and", "isinstance", "(", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", "[", "0", "]", ",", "list", ")", ":", "\n", "# Randomly pick a rater", "\n", "            ", "idx_rater", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", "[", "0", "]", ")", "-", "1", ")", "\n", "# Use it as ground truth for this iteration", "\n", "# Note: in case of multi-class: the same rater is used across classes", "\n", "for", "idx_class", "in", "range", "(", "len", "(", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", ")", ")", ":", "\n", "                ", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", "[", "idx_class", "]", "=", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", "[", "idx_class", "]", "[", "idx_rater", "]", "\n", "seg_pair", "[", "SegmentationPairKW", ".", "GT_METADATA", "]", "[", "idx_class", "]", "=", "seg_pair", "[", "SegmentationPairKW", ".", "GT_METADATA", "]", "[", "idx_class", "]", "[", "idx_rater", "]", "\n", "\n", "", "", "if", "seg_pair", "[", "SegmentationPairKW", ".", "INPUT_METADATA", "]", ":", "\n", "            ", "metadata_input", "=", "seg_pair", "[", "SegmentationPairKW", ".", "INPUT_METADATA", "]", "\n", "", "else", ":", "\n", "            ", "metadata_input", "=", "[", "]", "\n", "\n", "", "if", "seg_pair", "[", "SegmentationPairKW", ".", "GT_METADATA", "]", ":", "\n", "            ", "metadata_gt", "=", "seg_pair", "[", "SegmentationPairKW", ".", "GT_METADATA", "]", "\n", "", "else", ":", "\n", "            ", "metadata_gt", "=", "[", "]", "\n", "\n", "# Extract image and gt slices or patches from coordinates", "\n", "", "stack_input", "=", "np", ".", "asarray", "(", "seg_pair", "[", "SegmentationPairKW", ".", "INPUT", "]", ")", "[", "\n", ":", ",", "\n", "x_min", ":", "x_max", ",", "\n", "y_min", ":", "y_max", ",", "\n", "z_min", ":", "z_max", "\n", "]", "\n", "\n", "if", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", ":", "\n", "            ", "stack_gt", "=", "np", ".", "asarray", "(", "seg_pair", "[", "SegmentationPairKW", ".", "GT", "]", ")", "[", "\n", ":", ",", "\n", "x_min", ":", "x_max", ",", "\n", "y_min", ":", "y_max", ",", "\n", "z_min", ":", "z_max", "\n", "]", "\n", "", "else", ":", "\n", "            ", "stack_gt", "=", "[", "]", "\n", "\n", "# Run transforms on image slices", "\n", "", "stack_input", ",", "metadata_input", "=", "self", ".", "transform", "(", "sample", "=", "stack_input", ",", "\n", "metadata", "=", "metadata_input", ",", "\n", "data_type", "=", "\"im\"", ")", "\n", "# Update metadata_gt with metadata_input", "\n", "metadata_gt", "=", "imed_loader_utils", ".", "update_metadata", "(", "metadata_input", ",", "metadata_gt", ")", "\n", "\n", "# Run transforms on gt slices", "\n", "stack_gt", ",", "metadata_gt", "=", "self", ".", "transform", "(", "sample", "=", "stack_gt", ",", "\n", "metadata", "=", "metadata_gt", ",", "\n", "data_type", "=", "\"gt\"", ")", "\n", "# Make sure stack_gt is binarized", "\n", "if", "stack_gt", "is", "not", "None", "and", "not", "self", ".", "soft_gt", ":", "\n", "            ", "stack_gt", "=", "imed_postpro", ".", "threshold_predictions", "(", "stack_gt", ",", "thr", "=", "0.5", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "", "shape_x", "=", "x_max", "-", "x_min", "\n", "shape_y", "=", "y_max", "-", "y_min", "\n", "shape_z", "=", "z_max", "-", "z_min", "\n", "\n", "# add coordinates to metadata to reconstruct volume", "\n", "for", "metadata", "in", "metadata_input", ":", "\n", "            ", "metadata", "[", "MetadataKW", ".", "COORD", "]", "=", "[", "\n", "x_min", ",", "x_max", ",", "\n", "y_min", ",", "y_max", ",", "\n", "z_min", ",", "z_max", ",", "\n", "]", "\n", "\n", "", "subvolumes", "=", "{", "\n", "SegmentationPairKW", ".", "INPUT", ":", "stack_input", ",", "\n", "SegmentationPairKW", ".", "GT", ":", "stack_gt", ",", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "metadata_input", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "metadata_gt", "\n", "}", "\n", "\n", "# Input-level dropout to train with missing modalities", "\n", "if", "self", ".", "is_input_dropout", ":", "\n", "            ", "subvolumes", "=", "dropout_input", "(", "subvolumes", ")", "\n", "\n", "", "return", "subvolumes", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri3d_subvolume_segmentation_dataset.MRI3DSubVolumeSegmentationDataset.determine_cache_need": [[259, 286], ["ivadomed.loader.utils.get_obj_size", "ivadomed.loader.utils.get_obj_size", "ivadomed.utils.get_system_memory", "loguru.logger.info", "loguru.logger.info", "len"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_obj_size", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_obj_size", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_system_memory"], ["", "def", "determine_cache_need", "(", "self", ",", "seg_pair", ":", "dict", ",", "roi_pair", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        When Cache flag is not explicitly set, determine whether to cache the data or not\n        Args:\n            seg_pair: an EXAMPLE, typical seg_pair object\n            roi_pair: an EXAMPLE, typical seg_pair object\n\n        Returns:\n\n        \"\"\"", "\n", "size_seg_pair_in_bytes", "=", "get_obj_size", "(", "seg_pair", ")", "\n", "size_roi_pair_in_bytes", "=", "get_obj_size", "(", "roi_pair", ")", "\n", "\n", "optimal_ram_limit", "=", "get_system_memory", "(", ")", "*", "0.5", "\n", "\n", "# Size limit: 4GB GPU RAM, keep in mind tranform etc might take MORE!", "\n", "size_estimated_dataset_GB", "=", "(", "size_seg_pair_in_bytes", "+", "size_roi_pair_in_bytes", ")", "*", "len", "(", "self", ".", "filename_pairs", ")", "/", "1024", "**", "3", "\n", "if", "size_estimated_dataset_GB", ">", "optimal_ram_limit", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Estimated 3D dataset size is {size_estimated_dataset_GB} GB, which is larger than {optimal_ram_limit} GB. Auto \"", "\n", "f\"enabling cache.\"", ")", "\n", "self", ".", "disk_cache", "=", "True", "\n", "return", "True", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "f\"Estimated 3D dataset size is {size_estimated_dataset_GB} GB, which is smaller than {optimal_ram_limit} GB. File \"", "\n", "f\"cache will not be used\"", ")", "\n", "self", ".", "disk_cache", "=", "False", "\n", "return", "False", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__init__": [[28, 36], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "filter_empty_mask", ":", "bool", "=", "False", ",", "\n", "filter_absent_class", ":", "bool", "=", "False", ",", "\n", "filter_empty_input", ":", "bool", "=", "False", ",", "\n", "is_train", ":", "bool", "=", "False", ")", ":", "\n", "        ", "self", ".", "filter_empty_mask", "=", "filter_empty_mask", "\n", "self", ".", "filter_absent_class", "=", "filter_absent_class", "\n", "self", ".", "filter_empty_input", "=", "filter_empty_input", "\n", "self", ".", "is_train", "=", "is_train", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.patch_filter.PatchFilter.__call__": [[37, 60], ["numpy.any", "numpy.any", "numpy.all", "numpy.any", "img.std"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ":", "dict", ")", ":", "\n", "        ", "\"\"\"Extract input_data and gt_data lists from sample dict and discard them if they don't match certain\n        conditions.\n\n        \"\"\"", "\n", "input_data", ",", "gt_data", "=", "sample", "[", "'input'", "]", ",", "sample", "[", "'gt'", "]", "\n", "\n", "if", "self", ".", "is_train", ":", "\n", "            ", "if", "self", ".", "filter_empty_mask", ":", "\n", "# Discard 2D patches that do not have ANY ground truth (i.e. all masks are empty) at training time", "\n", "                ", "if", "not", "np", ".", "any", "(", "gt_data", ")", ":", "\n", "                    ", "return", "False", "\n", "", "", "if", "self", ".", "filter_absent_class", ":", "\n", "# Discard 2D patches that have absent classes (i.e. one or more masks are empty) at training time", "\n", "                ", "if", "not", "np", ".", "all", "(", "[", "np", ".", "any", "(", "mask", ")", "for", "mask", "in", "gt_data", "]", ")", ":", "\n", "                    ", "return", "False", "\n", "", "", "if", "self", ".", "filter_empty_input", ":", "\n", "# Discard set of 2D patches if one of them is empty or filled with constant value", "\n", "# (i.e. std == 0) at training time", "\n", "                ", "if", "np", ".", "any", "(", "[", "img", ".", "std", "(", ")", "==", "0", "for", "img", "in", "input_data", "]", ")", ":", "\n", "                    ", "return", "False", "\n", "\n", "", "", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__init__": [[11, 13], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "d", "=", "None", ")", ":", "\n", "        ", "self", ".", "metadata", "=", "{", "}", "or", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__setitem__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "self", ".", "metadata", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__getitem__": [[17, 19], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "metadata", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.__contains__": [[20, 22], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "key", "in", "self", ".", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items": [[23, 25], ["sample_meta_data.SampleMetadata.metadata.items"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.items"], ["", "def", "items", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "metadata", ".", "items", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata._update": [[26, 39], ["ref.metadata.keys", "sample_meta_data.SampleMetadata.metadata.keys", "bool"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "def", "_update", "(", "self", ",", "ref", ",", "list_keys", ")", ":", "\n", "        ", "\"\"\"Update metadata keys with a reference metadata.\n\n        A given list of metadata keys will be changed and given the values of the reference\n        metadata.\n\n        Args:\n            ref (SampleMetadata): Reference metadata object.\n            list_keys (list): List of keys that need to be updated.\n        \"\"\"", "\n", "for", "k", "in", "list_keys", ":", "\n", "            ", "if", "(", "k", "not", "in", "self", ".", "metadata", ".", "keys", "(", ")", "or", "not", "bool", "(", "self", ".", "metadata", "[", "k", "]", ")", ")", "and", "k", "in", "ref", ".", "metadata", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "metadata", "[", "k", "]", "=", "ref", ".", "metadata", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys": [[40, 42], ["sample_meta_data.SampleMetadata.metadata.keys"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "", "", "def", "keys", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "metadata", ".", "keys", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.__init__": [[39, 102], ["segmentation_pair.SegmentationPair.get_pair_shapes", "enumerate", "segmentation_pair.SegmentationPair.read_file", "segmentation_pair.SegmentationPair.input_handle.append", "nibabel.as_closest_canonical", "enumerate", "zip", "len", "RuntimeError", "isinstance", "numpy.allclose", "RuntimeError", "segmentation_pair.SegmentationPair.metadata.append", "isinstance", "segmentation_pair.SegmentationPair.gt_handle.append", "segmentation_pair.SegmentationPair.gt_handle.append", "segmentation_pair.SegmentationPair.gt_handle.append", "isinstance", "nibabel.as_closest_canonical", "segmentation_pair.SegmentationPair.read_file", "nibabel.as_closest_canonical", "segmentation_pair.SegmentationPair.read_file"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_shapes", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.read_file", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.read_file", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.read_file"], ["def", "__init__", "(", "self", ",", "input_filenames", ",", "gt_filenames", ",", "metadata", "=", "None", ",", "slice_axis", "=", "2", ",", "cache", "=", "True", ",", "prepro_transforms", "=", "None", ",", "\n", "soft_gt", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "input_filenames", "=", "input_filenames", "\n", "self", ".", "gt_filenames", "=", "gt_filenames", "\n", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "cache", "=", "cache", "\n", "self", ".", "slice_axis", "=", "slice_axis", "\n", "self", ".", "soft_gt", "=", "soft_gt", "\n", "self", ".", "prepro_transforms", "=", "prepro_transforms", "\n", "# list of the images", "\n", "self", ".", "input_handle", "=", "[", "]", "\n", "\n", "# loop over the filenames (list)", "\n", "for", "input_file", "in", "self", ".", "input_filenames", ":", "\n", "            ", "input_img", "=", "self", ".", "read_file", "(", "input_file", ")", "\n", "self", ".", "input_handle", ".", "append", "(", "input_img", ")", "\n", "if", "len", "(", "input_img", ".", "shape", ")", ">", "3", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"4-dimensional volumes not supported.\"", ")", "\n", "\n", "# list of GT for multiclass segmentation", "\n", "", "", "self", ".", "gt_handle", "=", "[", "]", "\n", "\n", "# Labeled data (ie not inference time)", "\n", "if", "self", ".", "gt_filenames", "is", "not", "None", ":", "\n", "            ", "if", "not", "isinstance", "(", "self", ".", "gt_filenames", ",", "list", ")", ":", "\n", "                ", "self", ".", "gt_filenames", "=", "[", "self", ".", "gt_filenames", "]", "\n", "", "for", "gt", "in", "self", ".", "gt_filenames", ":", "\n", "                ", "if", "gt", "is", "not", "None", ":", "\n", "                    ", "if", "isinstance", "(", "gt", ",", "str", ")", ":", "# this tissue has annotation from only one rater", "\n", "                        ", "self", ".", "gt_handle", ".", "append", "(", "self", ".", "read_file", "(", "gt", ",", "is_gt", "=", "True", ")", ")", "\n", "", "else", ":", "# this tissue has annotation from several raters", "\n", "                        ", "self", ".", "gt_handle", ".", "append", "(", "[", "self", ".", "read_file", "(", "gt_rater", ",", "is_gt", "=", "True", ")", "for", "gt_rater", "in", "gt", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "self", ".", "gt_handle", ".", "append", "(", "None", ")", "\n", "\n", "# Sanity check for dimensions, should be the same", "\n", "", "", "", "input_shape", ",", "gt_shape", "=", "self", ".", "get_pair_shapes", "(", ")", "\n", "\n", "if", "self", ".", "gt_filenames", "is", "not", "None", "and", "self", ".", "gt_filenames", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "if", "not", "np", ".", "allclose", "(", "input_shape", ",", "gt_shape", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "'Input and ground truth with different dimensions.'", ")", "\n", "\n", "", "", "for", "idx", ",", "handle", "in", "enumerate", "(", "self", ".", "input_handle", ")", ":", "\n", "            ", "self", ".", "input_handle", "[", "idx", "]", "=", "nib", ".", "as_closest_canonical", "(", "handle", ")", "\n", "\n", "# Labeled data (ie not inference time)", "\n", "", "if", "self", ".", "gt_filenames", "is", "not", "None", ":", "\n", "            ", "for", "idx", ",", "gt", "in", "enumerate", "(", "self", ".", "gt_handle", ")", ":", "\n", "                ", "if", "gt", "is", "not", "None", ":", "\n", "                    ", "if", "not", "isinstance", "(", "gt", ",", "list", ")", ":", "# this tissue has annotation from only one rater", "\n", "                        ", "self", ".", "gt_handle", "[", "idx", "]", "=", "nib", ".", "as_closest_canonical", "(", "gt", ")", "\n", "", "else", ":", "# this tissue has annotation from several raters", "\n", "                        ", "self", ".", "gt_handle", "[", "idx", "]", "=", "[", "nib", ".", "as_closest_canonical", "(", "gt_rater", ")", "for", "gt_rater", "in", "gt", "]", "\n", "\n", "# If binary classification, then extract labels from GT mask", "\n", "\n", "", "", "", "", "if", "self", ".", "metadata", ":", "\n", "            ", "self", ".", "metadata", "=", "[", "]", "\n", "for", "data", ",", "input_filename", "in", "zip", "(", "metadata", ",", "input_filenames", ")", ":", "\n", "                ", "data", "[", "MetadataKW", ".", "INPUT_FILENAMES", "]", "=", "input_filename", "\n", "data", "[", "MetadataKW", ".", "GT_FILENAMES", "]", "=", "gt_filenames", "\n", "self", ".", "metadata", ".", "append", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_shapes": [[103, 127], ["ivadomed.loader.utils.orient_shapes_hwd", "input_shape.append", "handle.header.get_data_shape", "tuple", "len", "RuntimeError", "len", "set", "isinstance", "ivadomed.loader.utils.orient_shapes_hwd", "gt_shape.append", "len", "RuntimeError", "gt_rater.header.get_data_shape", "tuple", "set"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd"], ["", "", "", "def", "get_pair_shapes", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the tuple (input, ground truth) representing both the input and ground truth shapes.\"\"\"", "\n", "input_shape", "=", "[", "]", "\n", "for", "handle", "in", "self", ".", "input_handle", ":", "\n", "            ", "shape", "=", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "handle", ".", "header", ".", "get_data_shape", "(", ")", ",", "self", ".", "slice_axis", ")", "\n", "input_shape", ".", "append", "(", "tuple", "(", "shape", ")", ")", "\n", "\n", "if", "not", "len", "(", "set", "(", "input_shape", ")", ")", ":", "\n", "                ", "raise", "RuntimeError", "(", "'Inputs have different dimensions.'", ")", "\n", "\n", "", "", "gt_shape", "=", "[", "]", "\n", "\n", "for", "gt", "in", "self", ".", "gt_handle", ":", "\n", "            ", "if", "gt", "is", "not", "None", ":", "\n", "                ", "if", "not", "isinstance", "(", "gt", ",", "list", ")", ":", "# this tissue has annotation from only one rater", "\n", "                    ", "gt", "=", "[", "gt", "]", "\n", "", "for", "gt_rater", "in", "gt", ":", "\n", "                    ", "shape", "=", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "gt_rater", ".", "header", ".", "get_data_shape", "(", ")", ",", "self", ".", "slice_axis", ")", "\n", "gt_shape", ".", "append", "(", "tuple", "(", "shape", ")", ")", "\n", "\n", "", "if", "not", "len", "(", "set", "(", "gt_shape", ")", ")", ":", "\n", "                    ", "raise", "RuntimeError", "(", "'Labels have different dimensions.'", ")", "\n", "\n", "", "", "", "return", "input_shape", "[", "0", "]", ",", "gt_shape", "[", "0", "]", "if", "len", "(", "gt_shape", ")", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_data": [[128, 157], ["ivadomed.loader.utils.orient_img_hwd", "input_data.append", "handle.get_fdata", "gt_data.append", "isinstance", "ivadomed.loader.utils.orient_img_hwd", "gt_data.append", "gt_data.append", "numpy.zeros().astype", "gt.get_fdata", "ivadomed.loader.utils.orient_img_hwd", "gt_rater.get_fdata", "numpy.zeros", "ivadomed.loader.utils.orient_shapes_hwd"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd"], ["", "def", "get_pair_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the tuple (input, ground truth) with the data content in numpy array.\"\"\"", "\n", "cache_mode", "=", "'fill'", "if", "self", ".", "cache", "else", "'unchanged'", "\n", "\n", "input_data", "=", "[", "]", "\n", "for", "handle", "in", "self", ".", "input_handle", ":", "\n", "            ", "hwd_oriented", "=", "imed_loader_utils", ".", "orient_img_hwd", "(", "handle", ".", "get_fdata", "(", "cache_mode", ",", "dtype", "=", "np", ".", "float32", ")", ",", "self", ".", "slice_axis", ")", "\n", "input_data", ".", "append", "(", "hwd_oriented", ")", "\n", "\n", "", "gt_data", "=", "[", "]", "\n", "# Handle unlabeled data", "\n", "if", "self", ".", "gt_handle", "is", "None", ":", "\n", "            ", "gt_data", "=", "None", "\n", "", "for", "gt", "in", "self", ".", "gt_handle", ":", "\n", "            ", "if", "gt", "is", "not", "None", ":", "\n", "                ", "if", "not", "isinstance", "(", "gt", ",", "list", ")", ":", "# this tissue has annotation from only one rater", "\n", "                    ", "hwd_oriented", "=", "imed_loader_utils", ".", "orient_img_hwd", "(", "gt", ".", "get_fdata", "(", "cache_mode", ",", "dtype", "=", "np", ".", "float32", ")", ",", "self", ".", "slice_axis", ")", "\n", "gt_data", ".", "append", "(", "hwd_oriented", ")", "\n", "", "else", ":", "# this tissue has annotation from several raters", "\n", "                    ", "hwd_oriented_list", "=", "[", "\n", "imed_loader_utils", ".", "orient_img_hwd", "(", "gt_rater", ".", "get_fdata", "(", "cache_mode", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "self", ".", "slice_axis", ")", "for", "gt_rater", "in", "gt", "]", "\n", "gt_data", ".", "append", "(", "[", "hwd_oriented", "for", "hwd_oriented", "in", "hwd_oriented_list", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "gt_data", ".", "append", "(", "\n", "np", ".", "zeros", "(", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "self", ".", "input_handle", "[", "0", "]", ".", "shape", ",", "self", ".", "slice_axis", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "\n", "", "", "return", "input_data", ",", "gt_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_metadata": [[158, 221], ["enumerate", "enumerate", "enumerate", "input_meta_dict.append", "metadata.keys", "gt_meta_dict.append", "ivadomed.loader.sample_meta_data.SampleMetadata", "isinstance", "gt_meta_dict.append", "gt_meta_dict.append", "list", "ivadomed.loader.sample_meta_data.SampleMetadata", "filter", "ivadomed.loader.utils.orient_shapes_hwd", "ivadomed.loader.utils.orient_shapes_hwd", "ivadomed.loader.sample_meta_data.SampleMetadata", "handle.header.get_zooms", "handle.header.get_data_shape", "ivadomed.loader.utils.orient_shapes_hwd", "ivadomed.loader.utils.orient_shapes_hwd", "segmentation_pair.SegmentationPair.metadata[].get", "segmentation_pair.SegmentationPair.metadata[].get", "enumerate", "gt.header.get_zooms", "gt.header.get_data_shape", "ivadomed.loader.utils.orient_shapes_hwd", "ivadomed.loader.utils.orient_shapes_hwd", "segmentation_pair.SegmentationPair.metadata[].get", "gt_rater.header.get_zooms", "gt_rater.header.get_data_shape", "segmentation_pair.SegmentationPair.metadata[].get"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd"], ["", "def", "get_pair_metadata", "(", "self", ",", "slice_index", "=", "0", ",", "coord", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return dictionary containing input and gt metadata.\n\n        Args:\n            slice_index (int): Index of 2D slice if 2D model is used, else 0.\n            coord (tuple or list): Coordinates of subvolume in volume if 3D model is used, else None.\n\n        Returns:\n            dict: Input and gt metadata.\n        \"\"\"", "\n", "gt_meta_dict", "=", "[", "]", "\n", "for", "idx_class", ",", "gt", "in", "enumerate", "(", "self", ".", "gt_handle", ")", ":", "\n", "            ", "if", "gt", "is", "not", "None", ":", "\n", "                ", "if", "not", "isinstance", "(", "gt", ",", "list", ")", ":", "# this tissue has annotation from only one rater", "\n", "                    ", "gt_meta_dict", ".", "append", "(", "SampleMetadata", "(", "{", "\n", "MetadataKW", ".", "ZOOMS", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "gt", ".", "header", ".", "get_zooms", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "DATA_SHAPE", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "gt", ".", "header", ".", "get_data_shape", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "GT_FILENAMES", ":", "self", ".", "metadata", "[", "0", "]", ".", "get", "(", "MetadataKW", ".", "GT_FILENAMES", ")", ",", "\n", "MetadataKW", ".", "BOUNDING_BOX", ":", "self", ".", "metadata", "[", "0", "]", ".", "get", "(", "MetadataKW", ".", "BOUNDING_BOX", ")", ",", "\n", "MetadataKW", ".", "DATA_TYPE", ":", "'gt'", ",", "\n", "MetadataKW", ".", "CROP_PARAMS", ":", "{", "}", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "                    ", "gt_meta_dict", ".", "append", "(", "[", "SampleMetadata", "(", "{", "\n", "MetadataKW", ".", "ZOOMS", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "gt_rater", ".", "header", ".", "get_zooms", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "DATA_SHAPE", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "gt_rater", ".", "header", ".", "get_data_shape", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "GT_FILENAMES", ":", "self", ".", "metadata", "[", "0", "]", ".", "get", "(", "MetadataKW", ".", "GT_FILENAMES", ")", "[", "idx_class", "]", "[", "idx_rater", "]", ",", "\n", "MetadataKW", ".", "BOUNDING_BOX", ":", "self", ".", "metadata", "[", "0", "]", ".", "get", "(", "MetadataKW", ".", "BOUNDING_BOX", ")", ",", "\n", "MetadataKW", ".", "DATA_TYPE", ":", "'gt'", ",", "\n", "MetadataKW", ".", "CROP_PARAMS", ":", "{", "}", "\n", "}", ")", "for", "idx_rater", ",", "gt_rater", "in", "enumerate", "(", "gt", ")", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "# Temporarily append null metadata to null gt", "\n", "                ", "gt_meta_dict", ".", "append", "(", "None", ")", "\n", "\n", "# Replace null metadata with metadata from other existing classes of the same subject", "\n", "", "", "for", "idx", ",", "gt_metadata", "in", "enumerate", "(", "gt_meta_dict", ")", ":", "\n", "            ", "if", "gt_metadata", "is", "None", ":", "\n", "                ", "gt_meta_dict", "[", "idx", "]", "=", "list", "(", "filter", "(", "None", ",", "gt_meta_dict", ")", ")", "[", "0", "]", "\n", "\n", "", "", "input_meta_dict", "=", "[", "]", "\n", "for", "handle", "in", "self", ".", "input_handle", ":", "\n", "            ", "input_meta_dict", ".", "append", "(", "SampleMetadata", "(", "{", "\n", "MetadataKW", ".", "ZOOMS", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "handle", ".", "header", ".", "get_zooms", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "DATA_SHAPE", ":", "imed_loader_utils", ".", "orient_shapes_hwd", "(", "handle", ".", "header", ".", "get_data_shape", "(", ")", ",", "self", ".", "slice_axis", ")", ",", "\n", "MetadataKW", ".", "DATA_TYPE", ":", "'im'", ",", "\n", "MetadataKW", ".", "CROP_PARAMS", ":", "{", "}", "\n", "}", ")", ")", "\n", "\n", "", "dreturn", "=", "{", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "input_meta_dict", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "gt_meta_dict", ",", "\n", "}", "\n", "\n", "for", "idx", ",", "metadata", "in", "enumerate", "(", "self", ".", "metadata", ")", ":", "# loop across channels", "\n", "            ", "metadata", "[", "MetadataKW", ".", "SLICE_INDEX", "]", "=", "slice_index", "\n", "metadata", "[", "MetadataKW", ".", "COORD", "]", "=", "coord", "\n", "self", ".", "metadata", "[", "idx", "]", "=", "metadata", "\n", "for", "metadata_key", "in", "metadata", ".", "keys", "(", ")", ":", "# loop across input metadata", "\n", "                ", "dreturn", "[", "MetadataKW", ".", "INPUT_METADATA", "]", "[", "idx", "]", "[", "metadata_key", "]", "=", "metadata", "[", "metadata_key", "]", "\n", "\n", "", "", "return", "dreturn", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_slice": [[222, 270], ["segmentation_pair.SegmentationPair.get_pair_metadata", "segmentation_pair.SegmentationPair.get_pair_data", "RuntimeError", "input_slices.append", "segmentation_pair.SegmentationPair.get", "segmentation_pair.SegmentationPair.get", "numpy.asarray", "isinstance", "gt_slices.append", "gt_slices.append", "isinstance", "gt_slices.append", "gt_slices.append", "numpy.asarray", "numpy.asarray", "numpy.asarray", "int", "numpy.asarray", "numpy.any", "int", "numpy.any"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_pair_data"], ["", "def", "get_pair_slice", "(", "self", ",", "slice_index", ",", "gt_type", "=", "\"segmentation\"", ")", ":", "\n", "        ", "\"\"\"Return the specified slice from (input, ground truth).\n\n        Args:\n            slice_index (int): Slice number.\n            gt_type (str): Choice between segmentation or classification, returns mask (array) or label (int) resp.\n                for the ground truth.\n        \"\"\"", "\n", "\n", "metadata", "=", "self", ".", "get_pair_metadata", "(", "slice_index", ")", "\n", "input_dataobj", ",", "gt_dataobj", "=", "self", ".", "get_pair_data", "(", ")", "\n", "\n", "if", "self", ".", "slice_axis", "not", "in", "[", "0", ",", "1", ",", "2", "]", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Invalid axis, must be between 0 and 2.\"", ")", "\n", "\n", "", "input_slices", "=", "[", "]", "\n", "# Loop over contrasts", "\n", "for", "data_object", "in", "input_dataobj", ":", "\n", "            ", "input_slices", ".", "append", "(", "np", ".", "asarray", "(", "data_object", "[", "...", ",", "slice_index", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "\n", "# Handle the case for unlabeled data", "\n", "", "if", "self", ".", "gt_handle", "is", "None", ":", "\n", "            ", "gt_slices", "=", "None", "\n", "", "else", ":", "\n", "            ", "gt_slices", "=", "[", "]", "\n", "for", "gt_obj", "in", "gt_dataobj", ":", "\n", "                ", "if", "gt_type", "==", "\"segmentation\"", ":", "\n", "                    ", "if", "not", "isinstance", "(", "gt_obj", ",", "list", ")", ":", "# annotation from only one rater", "\n", "                        ", "gt_slices", ".", "append", "(", "np", ".", "asarray", "(", "gt_obj", "[", "...", ",", "slice_index", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "", "else", ":", "# annotations from several raters", "\n", "                        ", "gt_slices", ".", "append", "(", "[", "np", ".", "asarray", "(", "gt_obj_rater", "[", "...", ",", "slice_index", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "for", "gt_obj_rater", "in", "gt_obj", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "if", "not", "isinstance", "(", "gt_obj", ",", "list", ")", ":", "# annotation from only one rater", "\n", "                        ", "gt_slices", ".", "append", "(", "np", ".", "asarray", "(", "int", "(", "np", ".", "any", "(", "gt_obj", "[", "...", ",", "slice_index", "]", ")", ")", ")", ")", "\n", "", "else", ":", "# annotations from several raters", "\n", "                        ", "gt_slices", ".", "append", "(", "[", "np", ".", "asarray", "(", "int", "(", "np", ".", "any", "(", "gt_obj_rater", "[", "...", ",", "slice_index", "]", ")", ")", ")", "\n", "for", "gt_obj_rater", "in", "gt_obj", "]", ")", "\n", "", "", "", "", "dreturn", "=", "{", "\n", "\"input\"", ":", "input_slices", ",", "\n", "\"gt\"", ":", "gt_slices", ",", "\n", "MetadataKW", ".", "INPUT_METADATA", ":", "metadata", ".", "get", "(", "MetadataKW", ".", "INPUT_METADATA", ")", ",", "\n", "MetadataKW", ".", "GT_METADATA", ":", "metadata", ".", "get", "(", "MetadataKW", ".", "GT_METADATA", ")", ",", "\n", "}", "\n", "\n", "return", "dreturn", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.read_file": [[271, 294], ["ivadomed.loader.utils.get_file_extension", "RuntimeError", "nibabel.load", "segmentation_pair.SegmentationPair.convert_file_to_nifti", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.convert_file_to_nifti"], ["", "def", "read_file", "(", "self", ",", "filename", ",", "is_gt", "=", "False", ")", ":", "\n", "        ", "\"\"\"Read file according to file extension and returns 'nibabel.nifti1.Nifti1Image' object.\n\n        Args:\n            filename (str): Subject filename.\n            is_gt (bool): Indicate if the file is a ground-truth.\n\n        Returns:\n            'nibabel.nifti1.Nifti1Image' object\n        \"\"\"", "\n", "extension", "=", "imed_loader_utils", ".", "get_file_extension", "(", "filename", ")", "\n", "# TODO: remove \"ome\" from condition when implementing OMETIFF support (#739)", "\n", "if", "(", "not", "extension", ")", "or", "(", "\"ome\"", "in", "extension", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"The input file extension '{extension}' of '{Path(filename).stem}' is not \"", "\n", "f\"supported. ivadomed supports the following \"", "\n", "f\"file extensions: '.nii', '.nii.gz', '.png', '.tif', '.tiff', '.jpg' and '.jpeg'.\"", ")", "\n", "\n", "", "if", "\"nii\"", "in", "extension", ":", "\n", "# For '.nii' and '.nii.gz' extentions", "\n", "            ", "img", "=", "nib", ".", "load", "(", "filename", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "self", ".", "convert_file_to_nifti", "(", "filename", ",", "extension", ",", "is_gt", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.convert_file_to_nifti": [[295, 340], ["nibabel.Nifti1Image", "segmentation_pair.SegmentationPair.get_microscopy_pixelsize", "numpy.expand_dims().astype.header.set_zooms", "ivadomed.loader.utils.update_filename_to_nifti", "numpy.expand_dims().astype", "numpy.expand_dims().astype", "ivadomed.postprocessing.threshold_predictions().astype", "pathlib.Path().exists", "nibabel.save", "len", "numpy.expand_dims().astype", "numpy.eye", "numpy.expand_dims", "numpy.expand_dims", "ivadomed.postprocessing.threshold_predictions", "pathlib.Path", "imageio.imread", "numpy.expand_dims", "imageio.imread", "imageio.imread"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_microscopy_pixelsize", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.threshold_predictions"], ["", "def", "convert_file_to_nifti", "(", "self", ",", "filename", ",", "extension", ",", "is_gt", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Convert a non-NifTI image into a 'nibabel.nifti1.Nifti1Image' object and save to a file.\n        This method is especially relevant for making microscopy data compatible with NifTI-only\n        pipelines.\n\n        TODO: (#739) implement OMETIFF behavior (if \"ome\" in extension)\n\n        Args:\n            filename (str): Subject filename.\n            extension (str): File extension.\n            is_gt (bool): Indicate if the file is a ground-truth.\n\n        Returns:\n            'nibabel.nifti1.Nifti1Image' object\n        \"\"\"", "\n", "# For '.png', '.tif', '.tiff', '.jpg' and 'jpeg' extentions", "\n", "# Read image as 8 bit grayscale in numpy array (behavior TBD in ivadomed for RGB, RBGA or higher bit depth)", "\n", "if", "\"tif\"", "in", "extension", ":", "\n", "            ", "img", "=", "np", ".", "expand_dims", "(", "imageio", ".", "imread", "(", "filename", ",", "format", "=", "'tiff-pil'", ")", ",", "axis", "=", "-", "1", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "if", "len", "(", "img", ".", "shape", ")", ">", "3", ":", "\n", "                ", "img", "=", "np", ".", "expand_dims", "(", "imageio", ".", "imread", "(", "filename", ",", "format", "=", "'tiff-pil'", ",", "as_gray", "=", "True", ")", ",", "axis", "=", "-", "1", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "", "else", ":", "\n", "            ", "img", "=", "np", ".", "expand_dims", "(", "imageio", ".", "imread", "(", "filename", ",", "as_gray", "=", "True", ")", ",", "axis", "=", "-", "1", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "# Binarize ground-truth values (0-255) to 0 and 1 in uint8 with threshold 0.5", "\n", "", "if", "is_gt", ":", "\n", "            ", "img", "=", "imed_postpro", ".", "threshold_predictions", "(", "img", "/", "255", ",", "thr", "=", "0.5", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "# Convert numpy array to Nifti1Image object with 4x4 identity affine matrix", "\n", "", "img", "=", "nib", ".", "Nifti1Image", "(", "img", ",", "affine", "=", "np", ".", "eye", "(", "4", ")", ")", "\n", "\n", "# Get PixelSize in millimeters in order (PixelSizeY, PixelSizeX, PixelSizeZ), where X is the width,", "\n", "# Y the height and Z the depth of the image.", "\n", "ps_in_mm", "=", "self", ".", "get_microscopy_pixelsize", "(", "filename", ")", "\n", "\n", "# Set \"pixdim\" (zooms) in Nifti1Image object header", "\n", "img", ".", "header", ".", "set_zooms", "(", "ps_in_mm", ")", "\n", "\n", "# If it doesn't already exist, save NifTI file in path_data alongside PNG/TIF/JPG file", "\n", "fname_out", "=", "imed_loader_utils", ".", "update_filename_to_nifti", "(", "filename", ")", "\n", "if", "not", "Path", "(", "fname_out", ")", ".", "exists", "(", ")", ":", "\n", "            ", "nib", ".", "save", "(", "img", ",", "fname_out", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.segmentation_pair.SegmentationPair.get_microscopy_pixelsize": [[342, 406], ["RuntimeError", "tuple", "RuntimeError", "len", "numpy.asarray", "numpy.resize", "RuntimeError", "RuntimeError", "pathlib.Path"], "methods", ["None"], ["", "def", "get_microscopy_pixelsize", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\"\n        Get the microscopy pixel size from the metadata and convert to millimeters.\n\n        The implementation of this method is compliant with BIDS version 1.7.0:\n        * \"pixdim\" (zooms) for Nifti1Image object is extracted as follows:\n            * For train, test and segment commands, PixelSize is taken from the metadata in BIDS JSON sidecar file.\n            * For inference with the segment_volume function, PixelSize and PixelSizeUnits must be provided in the\n              'options' argument.\n        * The function supports the PixelSize definition of BIDS 1.7.0 as a list of 2-numbers\n          [PixelSizeX, PixelSizeY] or 3-numbers [PixelSizeX, PixelSizeY, PixelSizeZ] for 2D and 3D\n          respectively, where X is the width, Y the height and Z the depth of the image.\n        * The function supports the PixelSizeUnits definition of BIDS 1.7.0 as \"mm\", \"um\" or \"nm\".\n\n        Returns:\n            ndrray: Pixel size in millimeters (ps_in_mm) in order (PixelSizeY, PixelSizeX, PixelSizeZ),\n            where Y is the height, X the width and Z the depth of the image.\n        \"\"\"", "\n", "\n", "# Get pixel size units from json metadata and set conversion factor from pixel size units to mm", "\n", "if", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "in", "self", ".", "metadata", "[", "0", "]", ":", "\n", "            ", "pixel_size_units", "=", "self", ".", "metadata", "[", "0", "]", "[", "MetadataKW", ".", "PIXEL_SIZE_UNITS", "]", "\n", "if", "pixel_size_units", "==", "\"mm\"", ":", "\n", "                ", "conversion_factor", "=", "1", "# Conversion factor from mm to mm", "\n", "", "elif", "pixel_size_units", "==", "\"um\"", ":", "\n", "                ", "conversion_factor", "=", "0.001", "# Conversion factor from um to mm", "\n", "", "elif", "pixel_size_units", "==", "\"nm\"", ":", "\n", "                ", "conversion_factor", "=", "0.000001", "# Conversion factor from nm to mm", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "f\"The PixelSizeUnits '{pixel_size_units}' of '{Path(filename).stem}' is not \"", "\n", "f\"supported. ivadomed supports the following PixelSizeUnits: 'mm', 'um' and 'nm'.\"", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"'PixelSizeUnits' is missing from metadata\"", ")", "\n", "\n", "# Set accepted array length for 'PixelSize' metadata", "\n", "", "array_length", "=", "[", "2", ",", "3", "]", "\n", "\n", "# Get pixel size from json metadata and convert to mm", "\n", "if", "MetadataKW", ".", "PIXEL_SIZE", "in", "self", ".", "metadata", "[", "0", "]", ":", "\n", "            ", "pixel_size", "=", "self", ".", "metadata", "[", "0", "]", "[", "MetadataKW", ".", "PIXEL_SIZE", "]", "\n", "\n", "if", "len", "(", "pixel_size", ")", "in", "array_length", ":", "\n", "# PixelSize array in order [PixelSizeX, PixelSizeY] or [PixelSizeX, PixelSizeY, PixelSizeZ]", "\n", "                ", "pixel_size", "=", "np", ".", "asarray", "(", "pixel_size", ")", "\n", "\n", "# Note: pixdim[3] (PixelSizeZ) must be non-zero in Nifti objects even if there is only one slice.", "\n", "# When PixelSizeZ is not present or 0, we assign the same PixelSize as PixelSizeX", "\n", "pixel_size", "=", "np", ".", "resize", "(", "pixel_size", ",", "3", ")", "\n", "if", "pixel_size", "[", "2", "]", "==", "0", ":", "\n", "                    ", "pixel_size", "[", "2", "]", "=", "pixel_size", "[", "0", "]", "\n", "\n", "# Swap PixelSizeX and PixelSizeY resulting in an array in order [PixelSizeY, PixelSizeX, PixelSizeZ]", "\n", "# to match NIfTI pixdim[1,2,3] in [Height, Width, Depth] orientation with axial slice axis.", "\n", "", "pixel_size", "[", "[", "1", ",", "0", "]", "]", "=", "pixel_size", "[", "[", "0", ",", "1", "]", "]", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"'PixelSize' metadata type is not supported. Format must be a 2D\"", "\n", "\" [PixelSizeX, PixelSizeY] array or 3D [PixelSizeX, PixelSizeY, PixelSizeZ] array\"", "\n", "\" where X is the width, Y the height and Z the depth of the image.\"", ")", "\n", "", "ps_in_mm", "=", "tuple", "(", "pixel_size", "*", "conversion_factor", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"'PixelSize' is missing from metadata\"", ")", "\n", "\n", "", "return", "ps_in_mm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.__init__": [[34, 76], ["copy.deepcopy", "any", "loader_params.get", "pandas.DataFrame", "bids_dataframe.BidsDataframe.create_bids_dataframe", "bids_dataframe.BidsDataframe.save", "list", "bids_dataframe.BidsDataframe.target_suffix.append", "str", "isinstance", "itertools.chain.from_iterable", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.create_bids_dataframe", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save"], ["def", "__init__", "(", "self", ",", "loader_params", ":", "dict", ",", "path_output", ":", "str", ",", "derivatives", ":", "bool", ",", "split_method", ":", "str", "=", "None", ")", ":", "\n", "\n", "# paths_data from loader parameters", "\n", "        ", "self", ".", "paths_data", "=", "loader_params", "[", "'path_data'", "]", "\n", "\n", "# bids_config from loader parameters", "\n", "self", ".", "bids_config", "=", "None", "if", "'bids_config'", "not", "in", "loader_params", "else", "loader_params", "[", "'bids_config'", "]", "\n", "\n", "# target_suffix and roi_suffix from loader parameters", "\n", "self", ".", "target_suffix", "=", "copy", ".", "deepcopy", "(", "loader_params", "[", "'target_suffix'", "]", ")", "\n", "\n", "# If `target_suffix` is a list of lists convert to list", "\n", "if", "any", "(", "isinstance", "(", "t", ",", "list", ")", "for", "t", "in", "self", ".", "target_suffix", ")", ":", "\n", "            ", "self", ".", "target_suffix", "=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "self", ".", "target_suffix", ")", ")", "\n", "\n", "", "self", ".", "roi_suffix", "=", "loader_params", "[", "'roi_params'", "]", "[", "'suffix'", "]", "\n", "\n", "# If `roi_suffix` is not None, add to target_suffix", "\n", "if", "self", ".", "roi_suffix", "is", "not", "None", ":", "\n", "            ", "self", ".", "target_suffix", ".", "append", "(", "self", ".", "roi_suffix", ")", "\n", "\n", "", "self", ".", "bids_validate", "=", "loader_params", ".", "get", "(", "'bids_validate'", ",", "True", ")", "\n", "\n", "# extensions from loader parameters", "\n", "self", ".", "extensions", "=", "loader_params", "[", "'extensions'", "]", "if", "loader_params", "[", "'extensions'", "]", "else", "[", "\".nii\"", ",", "\".nii.gz\"", "]", "\n", "\n", "# contrast_lst from loader parameters", "\n", "self", ".", "contrast_lst", "=", "[", "]", "if", "'contrast_lst'", "not", "in", "loader_params", "[", "'contrast_params'", "]", "else", "loader_params", "[", "'contrast_params'", "]", "[", "'contrast_lst'", "]", "\n", "\n", "# split_method", "\n", "self", ".", "split_method", "=", "split_method", "\n", "\n", "# derivatives", "\n", "self", ".", "derivatives", "=", "derivatives", "\n", "\n", "# Create dataframe", "\n", "self", ".", "df", "=", "pd", ".", "DataFrame", "(", ")", "\n", "self", ".", "create_bids_dataframe", "(", ")", "\n", "\n", "# Save dataframe as csv file", "\n", "self", ".", "save", "(", "str", "(", "Path", "(", "path_output", ",", "\"bids_dataframe.csv\"", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.create_bids_dataframe": [[77, 196], ["bids_dataframe.BidsDataframe.df.columns.to_list", "bids_dataframe.BidsDataframe.remove", "bids_dataframe.BidsDataframe.df.reset_index", "bids_dataframe.BidsDataframe.df.dropna", "pathlib.Path", "pathlib.Path.glob", "bids.BIDSLayoutIndexer", "bids.BIDSLayout", "bids.BIDSLayout.to_df", "bids_dataframe.BidsDataframe.insert", "RuntimeError", "[].tolist", "bids_dataframe.BidsDataframe.get_subjects_with_derivatives", "path_object.is_file", "bids_dataframe.BidsDataframe.write_derivatives_dataset_description", "str", "df_next[].apply", "loguru.logger.warning", "bids_dataframe.BidsDataframe.add_tsv_metadata", "pandas.concat", "loguru.logger.warning", "RuntimeError", "len", "df_next[].str.endswith", "bids_dataframe.BidsDataframe.df.astype().duplicated", "force_index.append", "path_object.name.endswith", "subject_path.startswith", "force_index.append", "path_object.name.endswith", "[].endswith", "subject_path.startswith", "force_index.append", "df_next[].str.endswith", "tuple", "str", "str", "tuple", "df_next[].str.contains", "df_next[].str.contains", "df_next[].str.split().apply().str.endswith", "df_next[].str.contains", "bids_dataframe.BidsDataframe.df.astype", "bids_dataframe.BidsDataframe.df[].str.contains", "bids_dataframe.BidsDataframe.df[].str.contains", "bids_dataframe.BidsDataframe.df[].str.contains", "pathlib.Path", "pathlib.Path", "df_next[].str.contains", "tuple", "path_object.name.split", "bids_dataframe.BidsDataframe.df[].isnull", "df_next[].str.split().apply", "bids_dataframe.BidsDataframe.df[].str.contains", "df_next[].str.split"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_subjects_with_derivatives", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.write_derivatives_dataset_description", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.add_tsv_metadata", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply"], ["", "def", "create_bids_dataframe", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generate the dataframe.\"\"\"", "\n", "\n", "for", "path_data", "in", "self", ".", "paths_data", ":", "\n", "            ", "path_data", "=", "Path", "(", "path_data", ",", "''", ")", "\n", "\n", "# Initialize BIDSLayoutIndexer and BIDSLayout", "\n", "# validate=True by default for both indexer and layout, BIDS-validator is not skipped", "\n", "# Force index for samples tsv and json files, and for subject subfolders containing microscopy files based on extensions.", "\n", "# Force index of subject subfolders containing CT-scan files under \"anat\" or \"ct\" folder based on extensions and modality suffix.", "\n", "# TODO: remove force indexing of microscopy files after Microscopy-BIDS is integrated in pybids", "\n", "# TODO: remove force indexing of CT-scan files after BEP CT-scan is merged in BIDS", "\n", "ext_microscopy", "=", "(", "'.png'", ",", "'.tif'", ",", "'.ome.tif'", ",", "'.ome.btf'", ")", "\n", "ext_ct", "=", "(", "'.nii.gz'", ",", "'.nii'", ")", "\n", "suffix_ct", "=", "(", "'ct'", ",", "'CT'", ")", "\n", "force_index", "=", "[", "]", "\n", "for", "path_object", "in", "path_data", ".", "glob", "(", "'**/*'", ")", ":", "\n", "                ", "if", "path_object", ".", "is_file", "(", ")", ":", "\n", "# Microscopy", "\n", "                    ", "subject_path_index", "=", "len", "(", "path_data", ".", "parts", ")", "\n", "subject_path", "=", "path_object", ".", "parts", "[", "subject_path_index", "]", "\n", "if", "path_object", ".", "name", "==", "\"samples.tsv\"", "or", "path_object", ".", "name", "==", "\"samples.json\"", ":", "\n", "                        ", "force_index", ".", "append", "(", "path_object", ".", "name", ")", "\n", "", "if", "(", "path_object", ".", "name", ".", "endswith", "(", "ext_microscopy", ")", "and", "path_object", ".", "parent", ".", "name", "==", "\"micr\"", "and", "\n", "subject_path", ".", "startswith", "(", "'sub'", ")", ")", ":", "\n", "                        ", "force_index", ".", "append", "(", "str", "(", "Path", "(", "*", "path_object", ".", "parent", ".", "parts", "[", "subject_path_index", ":", "]", ")", ")", ")", "\n", "# CT-scan", "\n", "", "if", "(", "path_object", ".", "name", ".", "endswith", "(", "ext_ct", ")", "and", "path_object", ".", "name", ".", "split", "(", "'.'", ")", "[", "0", "]", ".", "endswith", "(", "suffix_ct", ")", "and", "\n", "(", "path_object", ".", "parent", ".", "name", "==", "\"anat\"", "or", "path_object", ".", "parent", ".", "name", "==", "\"ct\"", ")", "and", "\n", "subject_path", ".", "startswith", "(", "'sub'", ")", ")", ":", "\n", "                        ", "force_index", ".", "append", "(", "str", "(", "Path", "(", "*", "path_object", ".", "parent", ".", "parts", "[", "subject_path_index", ":", "]", ")", ")", ")", "\n", "", "", "", "indexer", "=", "pybids", ".", "BIDSLayoutIndexer", "(", "force_index", "=", "force_index", ",", "validate", "=", "self", ".", "bids_validate", ")", "\n", "\n", "if", "self", ".", "derivatives", ":", "\n", "                ", "self", ".", "write_derivatives_dataset_description", "(", "path_data", ")", "\n", "\n", "", "layout", "=", "pybids", ".", "BIDSLayout", "(", "str", "(", "path_data", ")", ",", "config", "=", "self", ".", "bids_config", ",", "indexer", "=", "indexer", ",", "\n", "derivatives", "=", "self", ".", "derivatives", ")", "\n", "\n", "# Transform layout to dataframe with all entities and json metadata", "\n", "# As per pybids, derivatives don't include parsed entities, only the \"path\" column", "\n", "df_next", "=", "layout", ".", "to_df", "(", "metadata", "=", "True", ")", "\n", "\n", "# Add filename column", "\n", "df_next", ".", "insert", "(", "1", ",", "'filename'", ",", "df_next", "[", "'path'", "]", ".", "apply", "(", "os", ".", "path", ".", "basename", ")", ")", "\n", "\n", "# Drop rows with json, tsv and LICENSE files in case no extensions are provided in config file for filtering", "\n", "df_next", "=", "df_next", "[", "~", "df_next", "[", "'filename'", "]", ".", "str", ".", "endswith", "(", "tuple", "(", "[", "'.json'", ",", "'.tsv'", ",", "'LICENSE'", "]", ")", ")", "]", "\n", "\n", "# The following command updates the dataframe by doing 2 things:", "\n", "# 1. Keep only subject files of chosen contrasts (for files that are not in the 'derivatives' folder)", "\n", "#    (ex: '<dataset_path>/sub-XX/anat/sub-XX_T1w.nii.gz' with contrast_lst:[\"T1w\"])", "\n", "# 2. Keep only derivatives files of chosen target_suffix (for files that are in the 'derivatives' folder)", "\n", "#    (ex: '<dataset_path>/derivatives/labels/sub-XX/anat/sub-XX_T1w_seg-manual.nii.gz' with target_suffix:[\"_seg-manual\"])", "\n", "df_next", "=", "df_next", "[", "(", "~", "df_next", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "\n", "&", "df_next", "[", "'suffix'", "]", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "self", ".", "contrast_lst", ")", ")", ")", "\n", "|", "(", "df_next", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "\n", "&", "(", "df_next", "[", "'filename'", "]", ".", "str", ".", "split", "(", "'.'", ")", ".", "apply", "(", "lambda", "x", ":", "x", "[", "0", "]", ")", ")", ".", "str", ".", "endswith", "(", "tuple", "(", "self", ".", "target_suffix", ")", ")", ")", "]", "\n", "\n", "# Update dataframe with files of chosen extensions", "\n", "df_next", "=", "df_next", "[", "df_next", "[", "'filename'", "]", ".", "str", ".", "endswith", "(", "tuple", "(", "self", ".", "extensions", ")", ")", "]", "\n", "\n", "# Warning if no subject files are found in path_data", "\n", "if", "df_next", "[", "~", "df_next", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "]", ".", "empty", ":", "\n", "                ", "logger", ".", "warning", "(", "f\"No subject files were found in '{path_data}' dataset. Skipping dataset.\"", ")", "\n", "", "else", ":", "\n", "# Add tsv files metadata to dataframe", "\n", "                ", "df_next", "=", "self", ".", "add_tsv_metadata", "(", "df_next", ",", "path_data", ",", "layout", ")", "\n", "\n", "# TODO: check if other files are needed for EEG and DWI", "\n", "\n", "# Merge dataframes", "\n", "self", ".", "df", "=", "pd", ".", "concat", "(", "[", "self", ".", "df", ",", "df_next", "]", ",", "join", "=", "'outer'", ",", "ignore_index", "=", "True", ")", "\n", "\n", "", "", "if", "self", ".", "df", ".", "empty", ":", "\n", "# Raise error and exit if no subject files are found in any path data", "\n", "            ", "raise", "RuntimeError", "(", "\"No subject files found. Check selection of parameters in config.json\"", "\n", "\" and datasets compliance with BIDS specification.\"", ")", "\n", "\n", "# Drop duplicated rows based on all columns except 'path'", "\n", "# Keep first occurence", "\n", "", "columns", "=", "self", ".", "df", ".", "columns", ".", "to_list", "(", ")", "\n", "columns", ".", "remove", "(", "'path'", ")", "\n", "self", ".", "df", "=", "self", ".", "df", "[", "~", "(", "self", ".", "df", ".", "astype", "(", "str", ")", ".", "duplicated", "(", "subset", "=", "columns", ",", "keep", "=", "'first'", ")", ")", "]", "\n", "\n", "# Remove subject files without the \"split_method\" metadata if specified and keep all derivatives", "\n", "if", "self", ".", "split_method", ":", "\n", "            ", "files_remove", "=", "(", "self", ".", "df", "[", "(", "\n", "# Path does not contain derivative string (i.e. we only target subject raw data files)", "\n", "~", "self", ".", "df", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "\n", "# and split method metadata is null (i.e. the subject must have the split_method metadata or will be excluded)", "\n", "&", "self", ".", "df", "[", "self", ".", "split_method", "]", ".", "isnull", "(", ")", ")", "]", "\n", "# Get these filesnames and convert to list.", "\n", "[", "'filename'", "]", ")", ".", "tolist", "(", ")", "\n", "if", "files_remove", ":", "\n", "                ", "logger", ".", "warning", "(", "f\"The following files don't have the '{self.split_method}' metadata indicated as the \"", "\n", "f\"split_method in the configuration JSON file. Skipping these files: {files_remove}\"", ")", "\n", "# Removing from dataframe all filenames which contain any of the file from files_remove field.", "\n", "self", ".", "df", "=", "self", ".", "df", "[", "~", "self", ".", "df", "[", "'filename'", "]", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "files_remove", ")", ")", "]", "\n", "\n", "# If indexing of derivatives is true", "\n", "", "", "if", "self", ".", "derivatives", ":", "\n", "\n", "# Get list of subject files with available derivatives", "\n", "            ", "has_deriv", ",", "deriv", "=", "self", ".", "get_subjects_with_derivatives", "(", ")", "\n", "\n", "# Filter dataframe to keep subjects files with available derivatives only", "\n", "if", "has_deriv", ":", "\n", "                ", "self", ".", "df", "=", "self", ".", "df", "[", "self", ".", "df", "[", "'filename'", "]", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "has_deriv", ")", ")", "\n", "|", "self", ".", "df", "[", "'filename'", "]", ".", "str", ".", "contains", "(", "'|'", ".", "join", "(", "deriv", ")", ")", "]", "\n", "", "else", ":", "\n", "# Raise error and exit if no derivatives are found for any subject files", "\n", "                ", "raise", "RuntimeError", "(", "\"Derivatives not found.\"", ")", "\n", "\n", "# Reset index", "\n", "", "", "self", ".", "df", ".", "reset_index", "(", "drop", "=", "True", ",", "inplace", "=", "True", ")", "\n", "\n", "# Drop columns with all null values", "\n", "self", ".", "df", ".", "dropna", "(", "axis", "=", "1", ",", "inplace", "=", "True", ",", "how", "=", "'all'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.add_tsv_metadata": [[197, 255], ["pandas.merge.dropna", "layout.get_collections", "pathlib.Path", "pathlib.Path.exists", "layout.get_collections", "pandas.DataFrame", "pathlib.Path().glob", "layout.get_collections().to_df", "layout.get_collections().to_df.insert", "layout.get_collections().to_df.drop", "pandas.merge", "pandas.read_csv", "df_samples[].str.split().apply", "df_samples[].str.split().apply", "pandas.read_csv.columns.tolist", "pandas.merge", "layout.get_collections().to_df", "layout.get_collections().to_df.drop", "pandas.merge", "path_object.is_file", "df_scans[].apply", "pandas.merge", "str", "pd.read_csv.columns.tolist.remove", "pathlib.Path", "path_object.name.endswith", "layout.get_collections", "df_samples[].str.split", "df_samples[].str.split", "layout.get_collections", "pandas.read_csv", "pandas.concat", "str"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.postprocessing.Postprocessing.apply"], ["", "def", "add_tsv_metadata", "(", "self", ",", "df", ":", "pd", ".", "DataFrame", ",", "path_data", ":", "str", ",", "layout", ":", "pybids", ".", "BIDSLayout", ")", ":", "\n", "        ", "\"\"\"Add tsv files metadata to dataframe.\n\n        Args:\n            df (pd.DataFrame): Dataframe containing dataset information\n            path_data (str): Path to the BIDS dataset\n            layout (pybids.BIDSLayout): pybids BIDSLayout of the indexed files of the path_data\n\n        Returns:\n            pd.DataFrame: Dataframe containing datasets information\n        \"\"\"", "\n", "\n", "# Drop columns with all null values before loading TSV metadata", "\n", "# Avoid conflicts with unused columns descriptions from TSV sidecar JSON files", "\n", "df", ".", "dropna", "(", "axis", "=", "1", ",", "inplace", "=", "True", ",", "how", "=", "'all'", ")", "\n", "\n", "# Add metadata from 'participants.tsv' file if present", "\n", "# Uses pybids function", "\n", "if", "layout", ".", "get_collections", "(", "level", "=", "'dataset'", ")", ":", "\n", "            ", "df_participants", "=", "layout", ".", "get_collections", "(", "level", "=", "'dataset'", ",", "merge", "=", "True", ")", ".", "to_df", "(", ")", "\n", "df_participants", ".", "insert", "(", "1", ",", "'participant_id'", ",", "\"sub-\"", "+", "df_participants", "[", "'subject'", "]", ")", "\n", "df_participants", ".", "drop", "(", "[", "'suffix'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df", "=", "pd", ".", "merge", "(", "df", ",", "df_participants", ",", "on", "=", "'subject'", ",", "suffixes", "=", "(", "\"_x\"", ",", "None", ")", ",", "how", "=", "'left'", ")", "\n", "\n", "# Add metadata from 'samples.tsv' file if present", "\n", "# The 'participant_id' column is added only if not already present from the 'participants.tsv' file.", "\n", "# TODO: use pybids function after Microscopy-BIDS is integrated in pybids", "\n", "", "fname_samples", "=", "Path", "(", "path_data", ",", "\"samples.tsv\"", ")", "\n", "if", "fname_samples", ".", "exists", "(", ")", ":", "\n", "            ", "df_samples", "=", "pd", ".", "read_csv", "(", "str", "(", "fname_samples", ")", ",", "sep", "=", "'\\t'", ")", "\n", "df_samples", "[", "'sample'", "]", "=", "df_samples", "[", "'sample_id'", "]", ".", "str", ".", "split", "(", "\"sample-\"", ")", ".", "apply", "(", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "df_samples", "[", "'subject'", "]", "=", "df_samples", "[", "'participant_id'", "]", ".", "str", ".", "split", "(", "\"sub-\"", ")", ".", "apply", "(", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "columns", "=", "df_samples", ".", "columns", ".", "tolist", "(", ")", "\n", "if", "'participant_id'", "in", "df", ".", "columns", ":", "\n", "                ", "columns", ".", "remove", "(", "'participant_id'", ")", "\n", "", "df", "=", "pd", ".", "merge", "(", "df", ",", "df_samples", "[", "columns", "]", ",", "on", "=", "[", "'subject'", ",", "'sample'", "]", ",", "suffixes", "=", "(", "\"_x\"", ",", "None", ")", ",", "how", "=", "'left'", ")", "\n", "\n", "# Add metadata from all _sessions.tsv files, if present", "\n", "# Uses pybids function", "\n", "", "if", "layout", ".", "get_collections", "(", "level", "=", "'subject'", ")", ":", "\n", "            ", "df_sessions", "=", "layout", ".", "get_collections", "(", "level", "=", "'subject'", ",", "merge", "=", "True", ")", ".", "to_df", "(", ")", "\n", "df_sessions", ".", "drop", "(", "[", "'suffix'", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "df", "=", "pd", ".", "merge", "(", "df", ",", "df_sessions", ",", "on", "=", "[", "'subject'", ",", "'session'", "]", ",", "suffixes", "=", "(", "\"_x\"", ",", "None", ")", ",", "how", "=", "'left'", ")", "\n", "\n", "# Add metadata from all _scans.tsv files, if present", "\n", "# TODO: use pybids function after Microscopy-BIDS is integrated in pybids", "\n", "# TODO: verify merge behavior with EEG and DWI scans files, tested with anat and microscopy only", "\n", "", "df_scans", "=", "pd", ".", "DataFrame", "(", ")", "\n", "for", "path_object", "in", "Path", "(", "path_data", ")", ".", "glob", "(", "\"**/*\"", ")", ":", "\n", "            ", "if", "path_object", ".", "is_file", "(", ")", ":", "\n", "                ", "if", "path_object", ".", "name", ".", "endswith", "(", "\"scans.tsv\"", ")", ":", "\n", "                    ", "df_temp", "=", "pd", ".", "read_csv", "(", "str", "(", "path_object", ")", ",", "sep", "=", "'\\t'", ")", "\n", "df_scans", "=", "pd", ".", "concat", "(", "[", "df_scans", ",", "df_temp", "]", ",", "ignore_index", "=", "True", ")", "\n", "", "", "", "if", "not", "df_scans", ".", "empty", ":", "\n", "            ", "df_scans", "[", "'filename'", "]", "=", "df_scans", "[", "'filename'", "]", ".", "apply", "(", "os", ".", "path", ".", "basename", ")", "\n", "df", "=", "pd", ".", "merge", "(", "df", ",", "df_scans", ",", "on", "=", "[", "'filename'", "]", ",", "suffixes", "=", "(", "\"_x\"", ",", "None", ")", ",", "how", "=", "'left'", ")", "\n", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_subjects_with_derivatives": [[256, 286], ["bids_dataframe.BidsDataframe.get_subject_fnames", "bids_dataframe.BidsDataframe.get_deriv_fnames", "bids_dataframe.BidsDataframe.get_derivatives", "loguru.logger.warning", "has_deriv.append", "deriv.extend", "has_deriv.append", "deriv.extend", "loguru.logger.warning", "loguru.logger.warning", "str"], "methods", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_subject_fnames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_deriv_fnames", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_derivatives"], ["", "def", "get_subjects_with_derivatives", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get lists of subject filenames with available derivatives.\n\n        Returns:\n            list, list: subject filenames having derivatives, available derivatives filenames.\n        \"\"\"", "\n", "subject_fnames", "=", "self", ".", "get_subject_fnames", "(", ")", "\n", "deriv_fnames", "=", "self", ".", "get_deriv_fnames", "(", ")", "\n", "has_deriv", "=", "[", "]", "\n", "deriv", "=", "[", "]", "\n", "\n", "for", "subject_fname", "in", "subject_fnames", ":", "\n", "            ", "available", "=", "self", ".", "get_derivatives", "(", "subject_fname", ",", "deriv_fnames", ")", "\n", "if", "available", ":", "\n", "                ", "if", "self", ".", "roi_suffix", "is", "not", "None", ":", "\n", "                    ", "if", "self", ".", "roi_suffix", "in", "(", "'|'", ".", "join", "(", "available", ")", ")", ":", "\n", "                        ", "has_deriv", ".", "append", "(", "subject_fname", ")", "\n", "deriv", ".", "extend", "(", "available", ")", "\n", "", "else", ":", "\n", "                        ", "logger", ".", "warning", "(", "f\"Missing roi_suffix {self.roi_suffix} for {subject_fname}. Skipping file.\"", ")", "\n", "", "", "else", ":", "\n", "                    ", "has_deriv", ".", "append", "(", "subject_fname", ")", "\n", "deriv", ".", "extend", "(", "available", ")", "\n", "", "for", "target", "in", "self", ".", "target_suffix", ":", "\n", "                    ", "if", "target", "not", "in", "str", "(", "available", ")", "and", "target", "!=", "self", ".", "roi_suffix", ":", "\n", "                        ", "logger", ".", "warning", "(", "f\"Missing target_suffix {target} for {subject_fname}\"", ")", "\n", "", "", "", "else", ":", "\n", "                ", "logger", ".", "warning", "(", "f\"Missing derivatives for {subject_fname}. Skipping file.\"", ")", "\n", "\n", "", "", "return", "has_deriv", ",", "deriv", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_subject_fnames": [[287, 294], ["[].to_list", "bids_dataframe.BidsDataframe.df[].str.contains"], "methods", ["None"], ["", "def", "get_subject_fnames", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the list of subject filenames in dataframe.\n\n        Returns:\n            list: subject filenames.\n        \"\"\"", "\n", "return", "self", ".", "df", "[", "~", "self", ".", "df", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "]", "[", "'filename'", "]", ".", "to_list", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_deriv_fnames": [[295, 302], ["[].tolist", "bids_dataframe.BidsDataframe.df[].str.contains"], "methods", ["None"], ["", "def", "get_deriv_fnames", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the list of derivative filenames in dataframe.\n\n        Returns:\n            list: derivative filenames.\n        \"\"\"", "\n", "return", "self", ".", "df", "[", "self", ".", "df", "[", "'path'", "]", ".", "str", ".", "contains", "(", "'derivatives'", ")", "]", "[", "'filename'", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.get_derivatives": [[303, 315], ["subject_fname.split"], "methods", ["None"], ["", "def", "get_derivatives", "(", "self", ",", "subject_fname", ":", "str", ",", "deriv_fnames", ":", "list", ")", ":", "\n", "        ", "\"\"\"Return list of available derivative filenames for a subject filename.\n\n        Args:\n            subject_fname (str): Subject filename.\n            deriv_fnames (list of str): List of derivative filenames.\n\n        Returns:\n            list: derivative filenames\n        \"\"\"", "\n", "prefix_fname", "=", "subject_fname", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "return", "[", "d", "for", "d", "in", "deriv_fnames", "if", "prefix_fname", "in", "d", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.save": [[316, 327], ["bids_dataframe.BidsDataframe.df.to_csv", "loguru.logger.info", "loguru.logger.error"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "path", ":", "str", ")", ":", "\n", "        ", "\"\"\"Save the dataframe into a csv file.\n\n        Args:\n            path (str): Path to csv file.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "self", ".", "df", ".", "to_csv", "(", "path", ",", "index", "=", "False", ")", "\n", "logger", ".", "info", "(", "f\"Dataframe has been saved in {path}.\"", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "            ", "logger", ".", "error", "(", "f\"Wrong path, bids_dataframe.csv could not be saved in {path}.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.bids_dataframe.BidsDataframe.write_derivatives_dataset_description": [[328, 347], ["pathlib.Path().absolute", "pathlib.Path", "pathlib.Path", "loguru.logger.warning", "pathlib.Path", "pathlib.Path.is_file", "pathlib.Path.is_file", "pathlib.Path.open", "f.write"], "methods", ["None"], ["", "", "def", "write_derivatives_dataset_description", "(", "self", ",", "path_data", ":", "str", ")", ":", "\n", "        ", "\"\"\"Writes default dataset_description.json file if not found in path_data/derivatives folder\n\n        Args:\n            path_data (str): Path to the BIDS dataset.\n        \"\"\"", "\n", "path_data", "=", "Path", "(", "path_data", ")", ".", "absolute", "(", ")", "\n", "\n", "filename", "=", "'dataset_description'", "\n", "path_deriv_desc_file", "=", "Path", "(", "f'{path_data}/derivatives/{filename}.json'", ")", "\n", "path_label_desc_file", "=", "Path", "(", "f'{path_data}/derivatives/labels/{filename}.json'", ")", "\n", "# need to write default dataset_description.json file if not found", "\n", "if", "not", "path_deriv_desc_file", ".", "is_file", "(", ")", "and", "not", "path_label_desc_file", ".", "is_file", "(", ")", ":", "\n", "\n", "            ", "logger", ".", "warning", "(", "f\"{path_deriv_desc_file} not found. Will attempt to create a place holder \"", "\n", "f\"description file for now at {path_deriv_desc_file}.\"", ")", "\n", "with", "path_deriv_desc_file", ".", "open", "(", "mode", "=", "'w'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "\n", "'{\"Name\": \"Example dataset\", '", "\n", "'\"BIDSVersion\": \"1.0.2\", '", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.split_dataset": [[43, 118], ["[].unique().tolist", "[].unique().tolist", "sorted", "sklearn.model_selection.train_test_split", "loguru.logger.warning", "[].unique().tolist", "[].unique().tolist", "list", "list", "KeyError", "loguru.logger.warning", "sorted", "sklearn.model_selection.train_test_split", "len", "df[].unique().tolist", "len", "RuntimeError", "len", "len", "len", "len", "df[].notna", "len", "df[].unique().tolist", "[].unique", "[].unique", "len", "round", "round", "round", "[].unique", "[].unique", "set", "set", "set", "set", "len", "loguru.logger.warning", "df[].unique", "len", "len", "len", "df[].unique", "len", "len", "df[].isin", "df[].isin", "df[].isin", "df[].isin"], "function", ["None"], ["", "except", "Exception", "as", "e", ":", "\n", "# log error mssg for unsuccessful wandb authentication", "\n", "        ", "if", "wandb_params", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "\"Incorrect WandB API Key! Please re-check the entered API key.\"", ")", "\n", "logger", ".", "info", "(", "\"Disabling WandB Tracking, continuing with Tensorboard Logging\"", ")", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "\"No WandB parameters found! Continuing with Tensorboard Logging\"", ")", "\n", "\n", "# set flag", "\n", "", "wandb_tracking", "=", "False", "\n", "\n", "", "else", ":", "\n", "# setting flag after successful authentication", "\n", "        ", "logger", ".", "info", "(", "\"WandB API Authentication Successful!\"", ")", "\n", "wandb_tracking", "=", "True", "\n", "\n", "", "return", "wandb_tracking", "\n", "\n", "\n", "", "def", "get_task", "(", "model_name", ")", ":", "\n", "    ", "return", "\"classification\"", "if", "model_name", "in", "CLASSIFIER_LIST", "else", "\"segmentation\"", "\n", "\n", "\n", "", "def", "cuda", "(", "input_var", ",", "cuda_available", "=", "True", ",", "non_blocking", "=", "False", ")", ":", "\n", "    ", "\"\"\"Passes input_var to GPU.\n\n    Args:\n        input_var (Tensor): either a tensor or a list of tensors.\n        cuda_available (bool): If False, then return identity\n        non_blocking (bool):\n\n    Returns:\n        Tensor\n    \"\"\"", "\n", "if", "cuda_available", ":", "\n", "        ", "if", "isinstance", "(", "input_var", ",", "list", ")", ":", "\n", "            ", "return", "[", "t", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "for", "t", "in", "input_var", "]", "\n", "", "else", ":", "\n", "            ", "return", "input_var", ".", "cuda", "(", "non_blocking", "=", "non_blocking", ")", "\n", "", "", "else", ":", "\n", "        ", "return", "input_var", "\n", "\n", "\n", "", "", "def", "unstack_tensors", "(", "sample", ")", ":", "\n", "    ", "\"\"\"Unstack tensors.\n\n    Args:\n        sample (Tensor):\n\n    Returns:\n        list: list of Tensors.\n    \"\"\"", "\n", "list_tensor", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "sample", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "list_tensor", ".", "append", "(", "sample", "[", ":", ",", "i", ",", "]", ".", "unsqueeze", "(", "1", ")", ")", "\n", "", "return", "list_tensor", "\n", "\n", "\n", "", "def", "generate_sha_256", "(", "context", ":", "dict", ",", "df", ",", "file_lst", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "    ", "\"\"\"generate sha256 for a training file\n\n    Args:\n        context (dict): configuration context.\n        df (pd.DataFrame): Dataframe containing all BIDS image files indexed and their metadata.\n        file_lst (List[str]): list of strings containing training files\n    \"\"\"", "\n", "from", "pandas", "import", "DataFrame", "\n", "assert", "isinstance", "(", "df", ",", "DataFrame", ")", "\n", "\n", "# generating sha256 for list of data", "\n", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "=", "{", "}", "\n", "# file_list is a list of filename strings", "\n", "for", "file", "in", "file_lst", ":", "\n", "# bids_df is a dataframe with column values path...filename...", "\n", "# so df_sub is the row with matching filename=file", "\n", "        ", "df_sub", "=", "df", ".", "loc", "[", "df", "[", "'filename'", "]", "==", "file", "]", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_new_subject_file_split": [[120, 188], ["pathlib.Path", "joblib.dump", "random.seed", "zip", "utils.split_dataset", "ValueError", "random.sample", "len", "pandas.concat", "pd.concat.keys", "loguru.logger.warning", "len", "len", "len", "[].unique().tolist", "sampled_dfs.append", "[].unique().tolist", "[].unique", "[].unique", "df[].notna"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.split_dataset", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["sha256_hash", "=", "hashlib", ".", "sha256", "(", ")", "\n", "with", "open", "(", "file_path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "for", "byte_block", "in", "iter", "(", "lambda", ":", "f", ".", "read", "(", "4096", ")", ",", "b\"\"", ")", ":", "\n", "                ", "sha256_hash", ".", "update", "(", "byte_block", ")", "\n", "", "context", "[", "ConfigKW", ".", "TRAINING_SHA256", "]", "[", "file", "]", "=", "sha256_hash", ".", "hexdigest", "(", ")", "\n", "\n", "\n", "", "", "", "def", "save_onnx_model", "(", "model", ",", "inputs", ",", "model_path", ")", ":", "\n", "    ", "\"\"\"Convert PyTorch model to ONNX model and save it as `model_path`.\n\n    Args:\n        model (nn.Module): PyTorch model.\n        inputs (Tensor): Tensor, used to inform shape and axes.\n        model_path (str): Output filename for the ONNX model.\n    \"\"\"", "\n", "import", "torch", "\n", "model", ".", "eval", "(", ")", "\n", "dynamic_axes", "=", "{", "0", ":", "'batch'", ",", "1", ":", "'num_channels'", ",", "2", ":", "'height'", ",", "3", ":", "'width'", ",", "4", ":", "'depth'", "}", "\n", "if", "len", "(", "inputs", ".", "shape", ")", "==", "4", ":", "\n", "        ", "del", "dynamic_axes", "[", "4", "]", "\n", "", "torch", ".", "onnx", ".", "export", "(", "model", ",", "inputs", ",", "model_path", ",", "\n", "opset_version", "=", "11", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "dynamic_axes", "=", "{", "'input'", ":", "dynamic_axes", ",", "'output'", ":", "dynamic_axes", "}", ")", "\n", "\n", "\n", "", "def", "define_device", "(", "gpu_id", ")", ":", "\n", "    ", "\"\"\"Define the device used for the process of interest.\n\n    Args:\n        gpu_id (int): GPU ID.\n\n    Returns:\n        Bool, device: True if cuda is available.\n    \"\"\"", "\n", "import", "torch", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:\"", "+", "str", "(", "gpu_id", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "cuda_available", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "if", "not", "cuda_available", ":", "\n", "        ", "logger", ".", "info", "(", "\"Cuda is not available.\"", ")", "\n", "logger", ".", "info", "(", "\"Working on {}.\"", ".", "format", "(", "device", ")", ")", "\n", "", "if", "cuda_available", ":", "\n", "# Set the GPU", "\n", "        ", "gpu_id", "=", "int", "(", "gpu_id", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "gpu_id", ")", "\n", "logger", ".", "info", "(", "f\"Using GPU ID {gpu_id}\"", ")", "\n", "", "return", "cuda_available", ",", "device", "\n", "\n", "\n", "", "def", "display_selected_model_spec", "(", "params", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected model and its parameters.\n\n    Args:\n        params (dict): Keys are param names and values are param values.\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Selected architecture: {}, with the following parameters:'", ".", "format", "(", "params", "[", "\"name\"", "]", ")", ")", "\n", "for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "if", "k", "!=", "\"name\"", ":", "\n", "            ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n", "\n", "", "", "", "def", "display_selected_transfoms", "(", "params", ",", "dataset_type", ")", ":", "\n", "    ", "\"\"\"Display in terminal the selected transforms for a given dataset.\n\n    Args:\n        params (dict):\n        dataset_type (list): e.g. ['testing'] or ['training', 'validation']\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_subdatasets_subject_files_list": [[190, 234], ["joblib.load", "utils.get_new_subject_file_split", "sorted", "sorted", "sorted", "df[].isin", "df_train[].to_list", "df[].isin", "df_valid[].to_list", "df[].isin", "df_test[].to_list", "df[].isin", "df[].isin", "df[].isin"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_new_subject_file_split"], ["for", "k", "in", "list", "(", "params", ".", "keys", "(", ")", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'\\t{}: {}'", ".", "format", "(", "k", ",", "params", "[", "k", "]", ")", ")", "\n", "\n", "\n", "", "", "def", "plot_transformed_sample", "(", "before", ",", "after", ",", "list_title", "=", "None", ",", "fname_out", "=", "\"\"", ",", "cmap", "=", "\"jet\"", ")", ":", "\n", "    ", "\"\"\"Utils tool to plot sample before and after transform, for debugging.\n\n    Args:\n        before (ndarray): Sample before transform.\n        after (ndarray): Sample after transform.\n        list_title (list of str): Sub titles of before and after, resp.\n        fname_out (str): Output filename where the plot is saved if provided.\n        cmap (str): Matplotlib colour map.\n    \"\"\"", "\n", "import", "matplotlib", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "if", "list_title", "is", "None", ":", "\n", "        ", "list_title", "=", "[", "]", "\n", "", "if", "len", "(", "list_title", ")", "==", "0", ":", "\n", "        ", "list_title", "=", "[", "'Sample before transform'", ",", "'Sample after transform'", "]", "\n", "\n", "", "plt", ".", "interactive", "(", "False", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'figure.max_open_warning'", ":", "0", "}", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "20", ",", "10", ")", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "1", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "before", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "0", "]", ",", "fontsize", "=", "20", ")", "\n", "\n", "plt", ".", "subplot", "(", "1", ",", "2", ",", "2", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "plt", ".", "imshow", "(", "after", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "plt", ".", "title", "(", "list_title", "[", "1", "]", ",", "fontsize", "=", "20", ")", "\n", "\n", "if", "fname_out", ":", "\n", "        ", "plt", ".", "savefig", "(", "fname_out", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "\n", "", "", "def", "_git_info", "(", "commit_env", "=", "'IVADOMED_COMMIT'", ",", "branch_env", "=", "'IVADOMED_BRANCH'", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.imed_collate": [[236, 273], ["type", "torch.is_tensor", "torch.stack", "isinstance", "torch.stack", "torch.LongTensor", "isinstance", "re.search", "TypeError", "elem.dtype.name.startswith", "list", "torch.DoubleTensor", "isinstance", "error_msg.format", "torch.from_numpy", "map", "isinstance", "isinstance", "utils.imed_collate", "utils.imed_collate"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.imed_collate", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.imed_collate"], ["\n", "ivadomed_commit", "=", "os", ".", "getenv", "(", "commit_env", ",", "\"unknown\"", ")", "\n", "ivadomed_branch", "=", "os", ".", "getenv", "(", "branch_env", ",", "\"unknown\"", ")", "\n", "if", "check_exe", "(", "\"git\"", ")", "and", "Path", "(", "__ivadomed_dir__", ",", "\".git\"", ")", ".", "is_dir", "(", ")", ":", "\n", "        ", "ivadomed_commit", "=", "__get_commit", "(", ")", "or", "ivadomed_commit", "\n", "ivadomed_branch", "=", "__get_branch", "(", ")", "or", "ivadomed_branch", "\n", "\n", "", "if", "ivadomed_commit", "!=", "'unknown'", ":", "\n", "        ", "install_type", "=", "'git'", "\n", "", "else", ":", "\n", "        ", "install_type", "=", "'package'", "\n", "\n", "", "path_version", "=", "Path", "(", "__ivadomed_dir__", ",", "'ivadomed'", ",", "'version.txt'", ")", "\n", "with", "path_version", ".", "open", "(", ")", "as", "f", ":", "\n", "        ", "version_ivadomed", "=", "f", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "\n", "", "return", "install_type", ",", "ivadomed_commit", ",", "ivadomed_branch", ",", "version_ivadomed", "\n", "\n", "\n", "", "def", "check_exe", "(", "name", ")", ":", "\n", "    ", "\"\"\"Ensure that a program exists.\n\n    Args:\n        name (str): Name or path to program.\n    Returns:\n        str or None: path of the program or None\n    \"\"\"", "\n", "\n", "def", "is_exe", "(", "fpath", ")", ":", "\n", "        ", "return", "Path", "(", "fpath", ")", ".", "is_file", "(", ")", "and", "os", ".", "access", "(", "fpath", ",", "os", ".", "X_OK", ")", "\n", "\n", "", "fpath", "=", "Path", "(", "name", ")", ".", "parent", "\n", "if", "fpath", "and", "is_exe", "(", "name", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.filter_roi": [[275, 291], ["numpy.any", "numpy.count_nonzero"], "function", ["None"], ["", "else", ":", "\n", "        ", "for", "path", "in", "os", ".", "environ", "[", "\"PATH\"", "]", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "            ", "path", "=", "path", ".", "strip", "(", "'\"'", ")", "\n", "exe_file", "=", "str", "(", "Path", "(", "path", ",", "name", ")", ")", "\n", "if", "is_exe", "(", "exe_file", ")", ":", "\n", "                ", "return", "exe_file", "\n", "\n", "", "", "", "return", "None", "\n", "\n", "\n", "", "class", "ArgParseException", "(", "Exception", ")", ":", "\n", "    ", "pass", "\n", "\n", "\n", "", "def", "get_arguments", "(", "parser", ",", "args", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_hwd": [[293, 310], ["data.transpose", "data.transpose"], "function", ["None"], ["\n", "try", ":", "\n", "        ", "args", "=", "parser", ".", "parse_args", "(", "args", ")", "\n", "", "except", "SystemExit", "as", "e", ":", "\n", "        ", "if", "e", ".", "code", "!=", "0", ":", "# Calling `--help` raises SystemExit with 0 exit code (i.e. not an ArgParseException)", "\n", "            ", "raise", "ArgParseException", "(", "'Error parsing args'", ")", "\n", "", "else", ":", "\n", "            ", "sys", ".", "exit", "(", "0", ")", "\n", "\n", "", "", "return", "args", "\n", "\n", "\n", "", "def", "__get_commit", "(", "path_to_git_folder", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_ras": [[312, 330], ["data.transpose", "data.transpose", "len", "data.transpose", "data.transpose", "len"], "function", ["None"], ["\n", "if", "path_to_git_folder", "is", "None", ":", "\n", "        ", "path_to_git_folder", "=", "__ivadomed_dir__", "\n", "", "else", ":", "\n", "        ", "path_to_git_folder", "=", "Path", "(", "path_to_git_folder", ")", ".", "expanduser", "(", ")", ".", "absolute", "(", ")", "\n", "\n", "", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"rev-parse\"", ",", "\"HEAD\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ",", "\n", "cwd", "=", "path_to_git_folder", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "if", "status", "==", "0", ":", "\n", "        ", "commit", "=", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", "\n", "", "else", ":", "\n", "        ", "commit", "=", "\"?!?\"", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_shapes_hwd": [[332, 350], ["numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["cwd", "=", "path_to_git_folder", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "if", "status", "==", "0", ":", "\n", "        ", "unclean", "=", "True", "\n", "for", "line", "in", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", ".", "splitlines", "(", ")", ":", "\n", "            ", "line", "=", "line", ".", "rstrip", "(", ")", "\n", "if", "line", ".", "startswith", "(", "\"??\"", ")", ":", "# ignore ignored files, they can't hurt", "\n", "                ", "continue", "\n", "", "break", "\n", "", "else", ":", "\n", "            ", "unclean", "=", "False", "\n", "", "if", "unclean", ":", "\n", "            ", "commit", "+=", "\"*\"", "\n", "\n", "", "", "return", "commit", "\n", "\n", "\n", "", "def", "__get_branch", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_metadata": [[352, 372], ["isinstance", "metadata_dest_lst[]._update", "enumerate", "[]._update"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata._update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata._update"], ["\n", "p", "=", "subprocess", ".", "Popen", "(", "[", "\"git\"", ",", "\"rev-parse\"", ",", "\"--abbrev-ref\"", ",", "\"HEAD\"", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "\n", "stderr", "=", "subprocess", ".", "PIPE", ",", "cwd", "=", "__ivadomed_dir__", ")", "\n", "output", ",", "_", "=", "p", ".", "communicate", "(", ")", "\n", "status", "=", "p", ".", "returncode", "\n", "\n", "if", "status", "==", "0", ":", "\n", "        ", "return", "output", ".", "decode", "(", ")", ".", "strip", "(", ")", "\n", "\n", "\n", "", "", "def", "_version_string", "(", ")", ":", "\n", "    ", "install_type", ",", "ivadomed_commit", ",", "ivadomed_branch", ",", "version_ivadomed", "=", "_git_info", "(", ")", "\n", "if", "install_type", "==", "\"package\"", ":", "\n", "        ", "return", "version_ivadomed", "\n", "", "else", ":", "\n", "        ", "return", "\"{install_type}-{ivadomed_branch}-{ivadomed_commit}\"", ".", "format", "(", "**", "locals", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.reorient_image": [[374, 397], ["utils.orient_img_ras", "nibabel.orientations.io_orientation", "nibabel.orientations.io_orientation", "nibabel.orientations.ornt_transform", "nibabel.orientations.apply_orientation"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.orient_img_ras"], ["\n", "", "", "__ivadomed_dir__", "=", "Path", "(", "__file__", ")", ".", "resolve", "(", ")", ".", "parent", ".", "parent", "\n", "__version__", "=", "_version_string", "(", ")", "\n", "\n", "\n", "def", "get_command", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "train", ":", "\n", "        ", "return", "\"train\"", "\n", "", "elif", "args", ".", "test", ":", "\n", "        ", "return", "\"test\"", "\n", "", "elif", "args", ".", "segment", ":", "\n", "        ", "return", "\"segment\"", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"No CLI argument given for command: ( --train | --test | --segment ). Will check config file for command...\"", ")", "\n", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "COMMAND", "]", "==", "\"train\"", "or", "context", "[", "ConfigKW", ".", "COMMAND", "]", "==", "\"test\"", "or", "context", "[", "\n", "ConfigKW", ".", "COMMAND", "]", "==", "\"segment\"", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "COMMAND", "]", "\n", "", "else", ":", "\n", "                ", "logger", ".", "error", "(", "\"Specified invalid command argument in config file.\"", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a command argument via CLI nor config file.\"", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension": [[399, 410], ["next", "filename.lower().endswith", "filename.lower"], "function", ["None"], ["\n", "", "", "", "def", "get_path_output", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "path_output", ":", "\n", "        ", "return", "args", ".", "path_output", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"CLI flag --path-output not used to specify output directory. Will check config file for directory...\"", ")", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "PATH_OUTPUT", "]", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a path-output argument via CLI nor config file.\"", ")", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.update_filename_to_nifti": [[412, 431], ["utils.get_file_extension", "filename.replace.replace"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_file_extension"], ["\n", "", "", "", "def", "get_path_data", "(", "args", ",", "context", ")", ":", "\n", "    ", "if", "args", ".", "path_data", ":", "\n", "        ", "return", "args", ".", "path_data", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\n", "\"CLI flag --path-data not used to specify BIDS data directory. Will check config file for directory...\"", ")", "\n", "try", ":", "\n", "            ", "if", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", ":", "\n", "                ", "return", "context", "[", "ConfigKW", ".", "LOADER_PARAMETERS", "]", "[", "LoaderParamsKW", ".", "PATH_DATA", "]", "\n", "", "", "except", "AttributeError", ":", "\n", "            ", "logger", ".", "error", "(", "\"Have not specified a path-data argument via CLI nor config file.\"", ")", "\n", "\n", "\n", "", "", "", "def", "format_path_data", "(", "path_data", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.dropout_input": [[433, 472], ["seg_pair[].size", "random.randint", "torch.zeros_like", "loguru.logger.warning", "numpy.where", "len", "len", "numpy.invert", "len", "len", "random.randint", "torch.unique", "idx_dropped.append"], "function", ["None"], ["\n", "assert", "isinstance", "(", "path_data", ",", "str", ")", "or", "isinstance", "(", "path_data", ",", "list", ")", "\n", "if", "isinstance", "(", "path_data", ",", "str", ")", ":", "\n", "        ", "path_data", "=", "[", "path_data", "]", "\n", "", "return", "path_data", "\n", "\n", "\n", "", "def", "similarity_score", "(", "a", ":", "str", ",", "b", ":", "str", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    use DiffLIb SequenceMatcher to resolve the similarity between text. Help make better choice in terms of derivatives.\n    Args:\n        a: a string\n        b: another string\n    Returns: a score indicative of the similarity between the sequence.\n    \"\"\"", "\n", "return", "SequenceMatcher", "(", "None", ",", "a", ",", "b", ")", ".", "ratio", "(", ")", "\n", "\n", "\n", "", "def", "init_ivadomed", "(", ")", ":", "\n", "    ", "\"\"\"Initialize the ivadomed for typical terminal usage.\"\"\"", "\n", "# Display ivadomed version", "\n", "logger", ".", "info", "(", "'\\nivadomed ({})\\n'", ".", "format", "(", "__version__", ")", ")", "\n", "\n", "\n", "", "def", "print_stats", "(", "arr", ")", ":", "\n", "    ", "logger", ".", "info", "(", "f\"\\tMean: {np.mean(arr)} %\"", ")", "\n", "logger", ".", "info", "(", "f\"\\tMedian: {np.median(arr)} %\"", ")", "\n", "logger", ".", "info", "(", "f\"\\tInter-quartile range: [{np.percentile(arr, 25)}, {np.percentile(arr, 75)}] %\"", ")", "\n", "\n", "\n", "", "def", "get_timestamp", "(", ")", "->", "str", ":", "\n", "    ", "\"\"\"\n    Return a datetime string in the format YYYY-MM-DDTHHMMSS.(sub-precision)\n    Returns:\n    \"\"\"", "\n", "timestamp", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "isoformat", "(", ")", ".", "replace", "(", "\":\"", ",", "\"\"", ")", "\n", "return", "timestamp", "\n", "\n", "\n", "", "def", "get_system_memory", "(", ")", "->", "float", ":", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.create_temp_directory": [[474, 485], ["datetime.datetime.now().isoformat().replace", "tempfile.mkdtemp", "datetime.datetime.now().isoformat", "datetime.datetime.now"], "function", ["None"], ["\n", "current_platform", "=", "platform", ".", "system", "(", ")", "\n", "if", "current_platform", "==", "\"Linux\"", ":", "\n", "        ", "return", "get_linux_system_memory", "(", ")", "\n", "", "elif", "current_platform", "==", "\"Windows\"", ":", "\n", "        ", "return", "get_win_system_memory", "(", ")", "\n", "", "elif", "current_platform", "==", "\"Darwin\"", ":", "\n", "        ", "return", "get_mac_system_memory", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.utils.get_obj_size": [[486, 520], ["id", "sum", "new_refr.values", "marked.update", "map", "new_refr.keys", "id", "gc.get_referents", "isinstance"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.config_manager.update", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.sample_meta_data.SampleMetadata.keys"], ["", "", "def", "get_win_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on Windows system.\n    Returns: memory in GB\n    Source: https://stackoverflow.com/a/21589439\n    \"\"\"", "\n", "process", "=", "os", ".", "popen", "(", "'wmic memorychip get capacity'", ")", "\n", "result", "=", "process", ".", "read", "(", ")", "\n", "process", ".", "close", "(", ")", "\n", "totalMem", "=", "0", "\n", "for", "m", "in", "result", ".", "split", "(", "\"  \\n\\n\"", ")", "[", "1", ":", "-", "1", "]", ":", "\n", "        ", "totalMem", "+=", "int", "(", "m", ")", "\n", "", "return", "totalMem", "/", "(", "1024", "**", "3", ")", "\n", "\n", "\n", "", "def", "get_linux_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on Linux system.\n    Returns: memory in GB\n    Source: https://stackoverflow.com/a/28161352\n    \"\"\"", "\n", "import", "os", "\n", "mem_bytes", "=", "os", ".", "sysconf", "(", "'SC_PAGE_SIZE'", ")", "*", "os", ".", "sysconf", "(", "'SC_PHYS_PAGES'", ")", "# e.g. 4015976448", "\n", "mem_gib", "=", "mem_bytes", "/", "(", "1024.", "**", "3", ")", "# e.g. 3.74", "\n", "return", "mem_gib", "\n", "\n", "\n", "", "def", "get_mac_system_memory", "(", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Obtain the amount of memory available on MacOS system.\n    Returns: memory in GB\n    Source: https://apple.stackexchange.com/a/4296\n    \"\"\"", "\n", "\n", "import", "subprocess", "\n"]], "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.loader.load_dataset": [[12, 119], ["ivadomed.transforms.prepare_transforms", "copy.deepcopy", "ivadomed.loader.bids3d_dataset.Bids3DDataset", "ivadomed.utils.get_task", "ivadomed.loader.bids_dataset.BidsDataset", "ivadomed.loader.bids_dataset.BidsDataset.load_filenames", "loguru.logger.info", "loguru.logger.info", "loguru.logger.info", "ivadomed.loader.slice_filter.SliceFilter", "ivadomed.loader.patch_filter.PatchFilter", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.transforms.prepare_transforms", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.ivadomed.utils.get_task", "home.repos.pwc.inspect_result.neuropoly_ivado-medical-imaging.loader.mri2d_segmentation_dataset.MRI2DSegmentationDataset.load_filenames"], ["def", "load_dataset", "(", "bids_df", ",", "data_list", ",", "transforms_params", ",", "model_params", ",", "target_suffix", ",", "roi_params", ",", "\n", "contrast_params", ",", "slice_filter_params", ",", "patch_filter_params", ",", "slice_axis", ",", "multichannel", ",", "\n", "dataset_type", "=", "\"training\"", ",", "requires_undo", "=", "False", ",", "metadata_type", "=", "None", ",", "\n", "object_detection_params", "=", "None", ",", "soft_gt", "=", "False", ",", "device", "=", "None", ",", "\n", "cuda_available", "=", "None", ",", "is_input_dropout", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Get loader appropriate loader according to model type. Available loaders are Bids3DDataset for 3D data,\n    BidsDataset for 2D data and HDF5Dataset for HeMIS.\n\n    Args:\n        bids_df (BidsDataframe): Object containing dataframe with all BIDS image files and their metadata.\n        data_list (list): Subject names list.\n        transforms_params (dict): Dictionary containing transformations for \"training\", \"validation\", \"testing\" (keys),\n            eg output of imed_transforms.get_subdatasets_transforms.\n        model_params (dict): Dictionary containing model parameters.\n        target_suffix (list of str): List of suffixes for target masks.\n        roi_params (dict): Contains ROI related parameters.\n        contrast_params (dict): Contains image contrasts related parameters.\n        slice_filter_params (dict): Contains slice_filter_params, see :doc:`configuration_file` for more details.\n        patch_filter_params (dict): Contains patch_filter_params, see :doc:`configuration_file` for more details.\n        slice_axis (string): Choice between \"axial\", \"sagittal\", \"coronal\" ; controls the axis used to extract the 2D\n            data from 3D NifTI files. 2D PNG/TIF/JPG files use default \"axial.\n        multichannel (bool): If True, the input contrasts are combined as input channels for the model. Otherwise, each\n            contrast is processed individually (ie different sample / tensor).\n        metadata_type (str): Choice between None, \"mri_params\", \"contrasts\".\n        dataset_type (str): Choice between \"training\", \"validation\" or \"testing\".\n        requires_undo (bool): If True, the transformations without undo_transform will be discarded.\n        object_detection_params (dict): Object dection parameters.\n        soft_gt (bool): If True, ground truths are not binarized before being fed to the network. Otherwise, ground\n        truths are thresholded (0.5) after the data augmentation operations.\n        is_input_dropout (bool): Return input with missing modalities.\n\n    Returns:\n        BidsDataset\n\n    Note: For more details on the parameters transform_params, target_suffix, roi_params, contrast_params,\n    slice_filter_params, patch_filter_params and object_detection_params see :doc:`configuration_file`.\n    \"\"\"", "\n", "\n", "# Compose transforms", "\n", "tranform_lst", ",", "_", "=", "imed_transforms", ".", "prepare_transforms", "(", "copy", ".", "deepcopy", "(", "transforms_params", ")", ",", "requires_undo", ")", "\n", "\n", "# If ROICrop is not part of the transforms, then enforce no slice filtering based on ROI data.", "\n", "if", "TransformationKW", ".", "ROICROP", "not", "in", "transforms_params", ":", "\n", "        ", "roi_params", "[", "ROIParamsKW", ".", "SLICE_FILTER_ROI", "]", "=", "None", "\n", "\n", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "MODIFIED_3D_UNET", "or", "(", "ModelParamsKW", ".", "IS_2D", "in", "model_params", "and", "not", "model_params", "[", "ModelParamsKW", ".", "IS_2D", "]", ")", ":", "\n", "        ", "dataset", "=", "Bids3DDataset", "(", "bids_df", "=", "bids_df", ",", "\n", "subject_file_lst", "=", "data_list", ",", "\n", "target_suffix", "=", "target_suffix", ",", "\n", "roi_params", "=", "roi_params", ",", "\n", "contrast_params", "=", "contrast_params", ",", "\n", "metadata_choice", "=", "metadata_type", ",", "\n", "slice_axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "slice_axis", "]", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "multichannel", "=", "multichannel", ",", "\n", "model_params", "=", "model_params", ",", "\n", "object_detection_params", "=", "object_detection_params", ",", "\n", "soft_gt", "=", "soft_gt", ",", "\n", "is_input_dropout", "=", "is_input_dropout", ")", "\n", "# elif model_params[ModelParamsKW.NAME] == ConfigKW.HEMIS_UNET:", "\n", "#     dataset = imed_adaptative.HDF5Dataset(bids_df=bids_df,", "\n", "#                                           subject_file_lst=data_list,", "\n", "#                                           model_params=model_params,", "\n", "#                                           contrast_params=contrast_params,", "\n", "#                                           target_suffix=target_suffix,", "\n", "#                                           slice_axis=imed_utils.AXIS_DCT[slice_axis],", "\n", "#                                           transform=tranform_lst,", "\n", "#                                           metadata_choice=metadata_type,", "\n", "#                                           slice_filter_fn=SliceFilter(**slice_filter_params,", "\n", "#                                                                                         device=device,", "\n", "#                                                                                         cuda_available=cuda_available),", "\n", "#                                           roi_params=roi_params,", "\n", "#                                           object_detection_params=object_detection_params,", "\n", "#                                           soft_gt=soft_gt)", "\n", "", "else", ":", "\n", "# Task selection", "\n", "        ", "task", "=", "imed_utils", ".", "get_task", "(", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", ")", "\n", "\n", "dataset", "=", "BidsDataset", "(", "bids_df", "=", "bids_df", ",", "\n", "subject_file_lst", "=", "data_list", ",", "\n", "target_suffix", "=", "target_suffix", ",", "\n", "roi_params", "=", "roi_params", ",", "\n", "contrast_params", "=", "contrast_params", ",", "\n", "model_params", "=", "model_params", ",", "\n", "metadata_choice", "=", "metadata_type", ",", "\n", "slice_axis", "=", "imed_utils", ".", "AXIS_DCT", "[", "slice_axis", "]", ",", "\n", "transform", "=", "tranform_lst", ",", "\n", "multichannel", "=", "multichannel", ",", "\n", "slice_filter_fn", "=", "SliceFilter", "(", "**", "slice_filter_params", ",", "device", "=", "device", ",", "\n", "cuda_available", "=", "cuda_available", ")", ",", "\n", "patch_filter_fn", "=", "PatchFilter", "(", "**", "patch_filter_params", ",", "\n", "is_train", "=", "False", "if", "dataset_type", "==", "\"testing\"", "else", "True", ")", ",", "\n", "soft_gt", "=", "soft_gt", ",", "\n", "object_detection_params", "=", "object_detection_params", ",", "\n", "task", "=", "task", ",", "\n", "is_input_dropout", "=", "is_input_dropout", ")", "\n", "dataset", ".", "load_filenames", "(", ")", "\n", "\n", "", "if", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "==", "ConfigKW", ".", "MODIFIED_3D_UNET", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Loaded {len(dataset)} volumes of shape {dataset.length} for the {dataset_type} set.\"", ")", "\n", "", "elif", "model_params", "[", "ModelParamsKW", ".", "NAME", "]", "!=", "ConfigKW", ".", "HEMIS_UNET", "and", "dataset", ".", "length", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Loaded {len(dataset)} {slice_axis} patches of shape {dataset.length} for the {dataset_type} set.\"", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "f\"Loaded {len(dataset)} {slice_axis} slices for the { dataset_type} set.\"", ")", "\n", "\n", "", "return", "dataset", "\n", "", ""]]}