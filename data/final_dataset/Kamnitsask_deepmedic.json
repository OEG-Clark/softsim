{"home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.setupArgParser": [[43, 52], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "setupArgParser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "prog", "=", "'plotTrainingProgress'", ",", "formatter_class", "=", "argparse", ".", "RawTextHelpFormatter", ",", "\n", "description", "=", "'''This script parses training logs and plots accuracy metrics (mean accuracy, sensitivity, specificity, DSC over samples, DSC of full segmentation of validation subjects).'''", ")", "\n", "parser", ".", "add_argument", "(", "\"log_files\"", ",", "nargs", "=", "'+'", ",", "type", "=", "str", ",", "help", "=", "\"Paths to training logs. More than one log can be given, to plot progress of multiple experiments. \\nFormat: python ./plotTrainingProgress.py log1.txt log2.txt logs3.txt ...\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-d\"", ",", "\"--detailed\"", ",", "dest", "=", "'detailed_plot'", ",", "action", "=", "'store_true'", ",", "help", "=", "\"By default, only \\\"overall\\\" mean empirical accuracy is plotted. Provide this option for a more detailed and \\\"class-specific\\\" plot.\\nMetrics plotted: mean accuracy, sensitivity, specificity, DSC on samples and DSC on fully-segmented validation subjects.\\n***IMPORTANT***\\n\\\"Class-specific\\\" metrics of the more detailed plot are computed in a \\\"One-Class Vs All-Others\\\" fashion!\\nIn *Multi-Class* problems, \\\"overall\\\" accuracy of the basic plot and \\\"class-specific\\\" accuracy of the detailed plot differ significantly because of this!\\nOverall accuracy of basic plot: Number of voxels predicted with correct class / number of all voxels.\\nClass-specific accuracy of detailed plot: (True Positives + True Negatives with respect to \\\"the specified class\\\") / number of all voxels.\\n\\t>> i.e. voxels predicted with any other class are all considered similar, eg as background.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-c\"", ",", "\"--classes\"", ",", "dest", "=", "'classes_to_plot'", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ",", "help", "=", "\"Use only when --detailed plot is activated.\\nSpecify for which class(es) to plot metrics.\\nFormat: -c 2 |OR| -c 0 0 2 ... (Default: class-0 will be plotted from each log.) \\n*NOTE* Plotted metrics for Class-0 correspond to \\\"whole\\\" Foreground, although Label-0 in the NIFTIs is supposed to be Background. We consider it more useful.\\nUsage cases:\\nA single class specified: All given log files will be parsed to plot corresponding training progress for this class. \\nMultiple classes and one log file: Log will be parsed for all given classes in order to plot their progress. \\nMultiple classes and multiple logs: They will be matched one-to-one for plotting. For this, same number of classes and logs should be given.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-m\"", ",", "\"--movingAv\"", ",", "dest", "=", "'moving_average'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "\"Plotted values are smoothed with a moving average. Specify over how many values (subepochs) it should extend. \\nFormat: -m 20 (Default: 1)\\n*NOTE* DSC from full-segmentation of validation images is not smoothed.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-s\"", ",", "\"--saveFigure\"", ",", "dest", "=", "'save_figure'", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Use to make the script save the figure at the current folder. Takes no arguments.\"", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getNameOfLogFileWithoutEnding": [[53, 57], ["os.path.basename", "os.path.splitext"], "function", ["None"], ["", "def", "getNameOfLogFileWithoutEnding", "(", "filePathToLog", ")", ":", "\n", "    ", "filenameOfLog", "=", "os", ".", "path", ".", "basename", "(", "filePathToLog", ")", "\n", "(", "filenameWithoutExt", ",", "extension1", ")", "=", "os", ".", "path", ".", "splitext", "(", "filenameOfLog", ")", "\n", "return", "filenameWithoutExt", "\n", "", "def", "getSubepochsPerEpoch", "(", "pathToLog", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getSubepochsPerEpoch": [[57, 61], ["plotTrainingProgress.getFirstLineInLogWithCertainPattern", "plotTrainingProgress.getIntFromStr", "getFirstLineInLogWithCertainPattern.find", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getFirstLineInLogWithCertainPattern", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getIntFromStr"], ["", "def", "getSubepochsPerEpoch", "(", "pathToLog", ")", ":", "\n", "    ", "lineWithPattern", "=", "getFirstLineInLogWithCertainPattern", "(", "pathToLog", ",", "SUBEPS_PER_EP_PATTERN", ")", "\n", "if", "lineWithPattern", "==", "None", ":", "return", "None", "\n", "return", "getIntFromStr", "(", "lineWithPattern", "[", "lineWithPattern", ".", "find", "(", "SUBEPS_PER_EP_PATTERN", ")", "+", "len", "(", "SUBEPS_PER_EP_PATTERN", ")", ":", "]", ")", "\n", "", "def", "getEpochsBetweenFullInf", "(", "pathToLog", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getEpochsBetweenFullInf": [[61, 65], ["plotTrainingProgress.getFirstLineInLogWithCertainPattern", "plotTrainingProgress.getIntFromStr", "getFirstLineInLogWithCertainPattern.find", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getFirstLineInLogWithCertainPattern", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getIntFromStr"], ["", "def", "getEpochsBetweenFullInf", "(", "pathToLog", ")", ":", "\n", "    ", "lineWithPattern", "=", "getFirstLineInLogWithCertainPattern", "(", "pathToLog", ",", "NUM_EPS_BETWEEN_FULLINF_PATTERN", ")", "\n", "if", "lineWithPattern", "==", "None", ":", "return", "None", "\n", "return", "getIntFromStr", "(", "lineWithPattern", "[", "lineWithPattern", ".", "find", "(", "NUM_EPS_BETWEEN_FULLINF_PATTERN", ")", "+", "len", "(", "NUM_EPS_BETWEEN_FULLINF_PATTERN", ")", ":", "]", ")", "\n", "", "def", "getNumberOfClasses", "(", "pathToLog", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getNumberOfClasses": [[65, 69], ["plotTrainingProgress.getFirstLineInLogWithCertainPattern", "plotTrainingProgress.getIntFromStr", "getFirstLineInLogWithCertainPattern.find", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getFirstLineInLogWithCertainPattern", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getIntFromStr"], ["", "def", "getNumberOfClasses", "(", "pathToLog", ")", ":", "\n", "    ", "lineWithPattern", "=", "getFirstLineInLogWithCertainPattern", "(", "pathToLog", ",", "NUM_OF_CLASSES_PATTERN", ")", "\n", "if", "lineWithPattern", "==", "None", ":", "return", "None", "\n", "return", "getIntFromStr", "(", "lineWithPattern", "[", "lineWithPattern", ".", "find", "(", "NUM_OF_CLASSES_PATTERN", ")", "+", "len", "(", "NUM_OF_CLASSES_PATTERN", ")", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getIntFromStr": [[70, 72], ["int", "string1.strip"], "function", ["None"], ["", "def", "getIntFromStr", "(", "string1", ")", ":", "#may be unstripped", "\n", "    ", "return", "int", "(", "string1", ".", "strip", "(", ")", ")", "\n", "", "def", "getFloatFromStr", "(", "string1", ")", ":", "#may be unstripped", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getFloatFromStr": [[72, 74], ["float", "string1.strip"], "function", ["None"], ["", "def", "getFloatFromStr", "(", "string1", ")", ":", "#may be unstripped", "\n", "    ", "return", "float", "(", "string1", ".", "strip", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseLogFileAndGetVariablesOfInterest": [[75, 81], ["plotTrainingProgress.getNameOfLogFileWithoutEnding", "plotTrainingProgress.getSubepochsPerEpoch", "plotTrainingProgress.getEpochsBetweenFullInf"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getNameOfLogFileWithoutEnding", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getSubepochsPerEpoch", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getEpochsBetweenFullInf"], ["", "def", "parseLogFileAndGetVariablesOfInterest", "(", "pathToLog", ")", ":", "\n", "    ", "experimentName", "=", "None", ";", "subepochsPerEpoch", "=", "None", ";", "epochsBetweenEachFullInfer", "=", "None", "\n", "experimentName", "=", "getNameOfLogFileWithoutEnding", "(", "pathToLog", ")", "\n", "subepochsPerEpoch", "=", "getSubepochsPerEpoch", "(", "pathToLog", ")", "\n", "epochsBetweenEachFullInfer", "=", "getEpochsBetweenFullInf", "(", "pathToLog", ")", "\n", "return", "(", "experimentName", ",", "subepochsPerEpoch", ",", "epochsBetweenEachFullInfer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseVariablesOfTrainingSessionsFromListOfLogs": [[82, 95], ["six.moves.xrange", "len", "plotTrainingProgress.parseLogFileAndGetVariablesOfInterest", "listOfExperimentsNames.append", "listOfSubepochsPerEpFromEachLog.append", "listOfEpochsPerFullInferFromEachLog.append", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseLogFileAndGetVariablesOfInterest"], ["", "def", "parseVariablesOfTrainingSessionsFromListOfLogs", "(", "inLogsList", ")", ":", "\n", "    ", "listOfExperimentsNames", "=", "[", "]", ";", "listOfSubepochsPerEpFromEachLog", "=", "[", "]", ";", "listOfEpochsPerFullInferFromEachLog", "=", "[", "]", "\n", "for", "log_i", "in", "xrange", "(", "len", "(", "inLogsList", ")", ")", ":", "\n", "#Get variables from the logfile.", "\n", "        ", "(", "experimentName", ",", "subepochsPerEpoch", ",", "epochsBetweenEachFullInfer", ")", "=", "parseLogFileAndGetVariablesOfInterest", "(", "inLogsList", "[", "log_i", "]", ")", "\n", "#In case the name was not found:", "\n", "if", "not", "experimentName", ":", "experimentName", "=", "\"TrainingSession-\"", "+", "str", "(", "log_i", ")", "\n", "if", "not", "subepochsPerEpoch", ":", "subepochsPerEpoch", "=", "20", "#default", "\n", "if", "not", "epochsBetweenEachFullInfer", ":", "epochsBetweenEachFullInfer", "=", "1", "#default", "\n", "listOfExperimentsNames", ".", "append", "(", "experimentName", ")", "\n", "listOfSubepochsPerEpFromEachLog", ".", "append", "(", "subepochsPerEpoch", ")", "\n", "listOfEpochsPerFullInferFromEachLog", ".", "append", "(", "epochsBetweenEachFullInfer", ")", "\n", "", "return", "(", "listOfExperimentsNames", ",", "listOfSubepochsPerEpFromEachLog", ",", "listOfEpochsPerFullInferFromEachLog", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.makeLegendList": [[96, 102], ["six.moves.xrange", "len", "legendList.append", "str"], "function", ["None"], ["", "def", "makeLegendList", "(", "listOfExperimentsNames", ",", "classesFromEachLogFile", ")", ":", "\n", "    ", "legendList", "=", "[", "]", "\n", "for", "exper_i", "in", "xrange", "(", "len", "(", "listOfExperimentsNames", ")", ")", ":", "\n", "        ", "for", "classFromExper", "in", "classesFromEachLogFile", "[", "exper_i", "]", ":", "\n", "            ", "legendList", ".", "append", "(", "listOfExperimentsNames", "[", "exper_i", "]", "+", "\"-Class\"", "+", "str", "(", "classFromExper", ")", ")", "\n", "", "", "return", "legendList", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.makeHelperVariablesPerExperiment": [[103, 111], ["six.moves.xrange", "len", "six.moves.xrange", "len", "subepochsPerEpOfExpers.append", "epochsPerFullInferOfExpers.append"], "function", ["None"], ["", "def", "makeHelperVariablesPerExperiment", "(", "logFiles", ",", "classesFromEachLogFile", ",", "subepochsPerEpFromEachLog", ",", "epochsPerFullInferFromEachLog", ")", ":", "\n", "    ", "subepochsPerEpOfExpers", "=", "[", "]", "\n", "epochsPerFullInferOfExpers", "=", "[", "]", "\n", "for", "logFile_i", "in", "xrange", "(", "len", "(", "logFiles", ")", ")", ":", "\n", "        ", "for", "classForLogFile_i", "in", "xrange", "(", "len", "(", "classesFromEachLogFile", "[", "logFile_i", "]", ")", ")", ":", "\n", "            ", "subepochsPerEpOfExpers", ".", "append", "(", "subepochsPerEpFromEachLog", "[", "logFile_i", "]", ")", "# Essentially just doublicating the same entry again and again for all classes of same logfile/experiment.", "\n", "epochsPerFullInferOfExpers", ".", "append", "(", "epochsPerFullInferFromEachLog", "[", "logFile_i", "]", ")", "\n", "", "", "return", "(", "subepochsPerEpOfExpers", ",", "epochsPerFullInferOfExpers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother": [[112, 137], ["restOfTheLineAfterTheEndOfTheWantedPattern.find", "restOfTheLineAfterTheEndOfTheWantedPattern.find", "theListInString.strip.strip", "f.readline", "f.readline.find"], "function", ["None"], ["", "def", "getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "(", "restOfTheLineAfterTheEndOfTheWantedPattern", ",", "f", ")", ":", "\n", "#A list starts in the currently already-read line  = restOfTheLineAfterTheEndOfTheWantedPattern. But it may be ending ] in this same line, or one of the next ones.", "\n", "#If it does not end in this one, keep reading lilnes from file f, until you find its end. Put the whole list, including [] into the returned resulting string.", "\n", "#The file will be read UP UNTIL the line where the list ] ends. This may be the already read line (ie, dont read any more).", "\n", "    ", "indexWhereListStartsInThisLine", "=", "restOfTheLineAfterTheEndOfTheWantedPattern", ".", "find", "(", "\"[\"", ")", "\n", "indexWhereListEndsInThisLine", "=", "restOfTheLineAfterTheEndOfTheWantedPattern", ".", "find", "(", "\"]\"", ")", "\n", "if", "indexWhereListEndsInThisLine", ">", "-", "1", ":", "\n", "        ", "theListInString", "=", "restOfTheLineAfterTheEndOfTheWantedPattern", "[", "indexWhereListStartsInThisLine", ":", "indexWhereListEndsInThisLine", "+", "1", "]", "\n", "endOfListFound", "=", "True", "\n", "", "else", ":", "\n", "        ", "theListInString", "=", "restOfTheLineAfterTheEndOfTheWantedPattern", "[", "indexWhereListStartsInThisLine", ":", "]", "\n", "endOfListFound", "=", "False", "\n", "\n", "", "while", "endOfListFound", "==", "False", ":", "\n", "        ", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "if", "newLine", ":", "\n", "            ", "indexWhereListEndsInThisLine", "=", "newLine", ".", "find", "(", "\"]\"", ")", "\n", "if", "indexWhereListEndsInThisLine", ">", "-", "1", ":", "\n", "                ", "theListInString", "+=", "newLine", "[", ":", "indexWhereListEndsInThisLine", "+", "1", "]", "\n", "endOfListFound", "=", "True", "\n", "", "else", ":", "\n", "                ", "theListInString", "+=", "newLine", "[", ":", "]", "\n", "\n", "", "", "", "theListInString", "=", "theListInString", ".", "strip", "(", ")", "#to get trailing whitespace off.", "\n", "return", "theListInString", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers": [[139, 153], ["theListInString.strip", "numbersOfListInString.rstrip.lstrip", "numbersOfListInString.rstrip.rstrip", "numbersOfListInString.rstrip.split", "numbersOfListInString.rstrip.split"], "function", ["None"], ["", "def", "getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "(", "theListInString", ",", "splittingChar", ")", ":", "\n", "#gets a string that is a STRING LIST with inside STRING-NUMBERS. It returns an actual list, where the elements are the string-numbers.", "\n", "    ", "numbersOfListInString", "=", "theListInString", ".", "strip", "(", ")", "\n", "numbersOfListInString", "=", "numbersOfListInString", ".", "lstrip", "(", "'['", ")", "\n", "numbersOfListInString", "=", "numbersOfListInString", ".", "rstrip", "(", "']'", ")", "\n", "#print \"numbersOfListInString=\",numbersOfListInString", "\n", "\n", "#parse the numbers and put them in a list to return.", "\n", "if", "splittingChar", "==", "\"\"", ":", "\n", "        ", "listOfstringNumbersSplitted", "=", "numbersOfListInString", ".", "split", "(", ")", "\n", "", "else", ":", "\n", "        ", "listOfstringNumbersSplitted", "=", "numbersOfListInString", ".", "split", "(", "splittingChar", ")", "\n", "\n", "", "return", "listOfstringNumbersSplitted", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getFirstLineInLogWithCertainPattern": [[155, 166], ["open", "open.readline", "open.close", "open.readline", "f.readline.find"], "function", ["None"], ["", "def", "getFirstLineInLogWithCertainPattern", "(", "filePathToLog", ",", "pattern", ")", ":", "\n", "    ", "foundLine", "=", "None", "\n", "f", "=", "open", "(", "filePathToLog", ",", "'r'", ")", "\n", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "while", "newLine", ":", "\n", "        ", "if", "newLine", ".", "find", "(", "pattern", ")", ">", "-", "1", ":", "\n", "            ", "foundLine", "=", "newLine", "\n", "break", "\n", "", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "return", "foundLine", "# Returns None if not found.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getRegExprForParsingMetric": [[168, 191], ["str"], "function", ["None"], ["", "def", "getRegExprForParsingMetric", "(", "validation0orTraining1", ",", "basic0detailed1", ",", "class_i", ",", "intSpecifyingMetric", ")", ":", "\n", "# intSpecifyingMetric: an int in [0,1,2,3,4]", "\n", "    ", "validationOrTrainingString", "=", "VALIDATION_PATT", "if", "validation0orTraining1", "==", "0", "else", "TRAINING_PATT", "\n", "if", "basic0detailed1", "==", "0", ":", "# basic plotting", "\n", "        ", "classPrefixString", "=", "OVERALLCLASS_PATT", "\n", "if", "intSpecifyingMetric", "==", "0", ":", "#looking for mean accuracy", "\n", "            ", "sentenceToLookFor", "=", "MEANACC_OVERALL_SENTENCE", "\n", "", "elif", "intSpecifyingMetric", "==", "1", ":", "#looking for cost", "\n", "            ", "sentenceToLookFor", "=", "COST_OVERALL_SENTENCE", "\n", "", "", "else", ":", "#detailed plotting", "\n", "        ", "classPrefixString", "=", "CLASS_PREFIX_PATT", "+", "str", "(", "class_i", ")", "\n", "if", "intSpecifyingMetric", "==", "0", ":", "#looking for mean accuracy", "\n", "            ", "sentenceToLookFor", "=", "MEANACC_SENTENCE", "\n", "", "elif", "intSpecifyingMetric", "==", "1", ":", "#looking for pos accuracy", "\n", "            ", "sentenceToLookFor", "=", "SENS_SENTENCE", "\n", "", "elif", "intSpecifyingMetric", "==", "2", ":", "#looking for precision", "\n", "            ", "sentenceToLookFor", "=", "PREC_SENTENCE", "\n", "", "elif", "intSpecifyingMetric", "==", "3", ":", "#looking for neg accuracy", "\n", "            ", "sentenceToLookFor", "=", "SPEC_SENTENCE", "\n", "", "elif", "intSpecifyingMetric", "==", "4", ":", "#looking for dice on samples", "\n", "            ", "sentenceToLookFor", "=", "DSC_SAMPLES_SENTENCE", "\n", "", "", "regExp1", "=", "\".*\"", "+", "validationOrTrainingString", "+", "\".*\"", "+", "classPrefixString", "+", "\":.*\"", "+", "sentenceToLookFor", "\n", "return", "(", "regExp1", ",", "sentenceToLookFor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl": [[193, 201], ["stringNumber.strip", "listOfAccNumbers.append", "float"], "function", ["None"], ["", "def", "getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "(", "listOfstringNumbers", ",", "previousValueOfTheVariableInTheTimeSerie", ")", ":", "\n", "    ", "listOfAccNumbers", "=", "[", "]", "\n", "for", "stringNumber", "in", "listOfstringNumbers", ":", "\n", "        ", "stringNumberStrippedOfWhiteSpace", "=", "stringNumber", ".", "strip", "(", ")", "\n", "parseFloatNumber", "=", "float", "(", "stringNumberStrippedOfWhiteSpace", ")", "if", "stringNumberStrippedOfWhiteSpace", "!=", "NA_PATTERN", "else", "previousValueOfTheVariableInTheTimeSerie", "\n", "previousValueOfTheVariableInTheTimeSerie", "=", "parseFloatNumber", "\n", "listOfAccNumbers", ".", "append", "(", "parseFloatNumber", ")", "\n", "", "return", "listOfAccNumbers", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.movingAverage": [[202, 211], ["numpy.cumsum", "range", "numpy.concatenate", "len"], "function", ["None"], ["", "def", "movingAverage", "(", "a", ",", "n", "=", "1", ")", ":", "\n", "    ", "cumsum", "=", "np", ".", "cumsum", "(", "a", ",", "dtype", "=", "float", ")", "\n", "tempRetComplete", "=", "cumsum", "[", "n", ":", "]", "-", "cumsum", "[", ":", "-", "n", "]", "\n", "retCompletePart", "=", "tempRetComplete", "/", "n", "\n", "# Also calculate the rollAverage for the first n-1 elements, even if it's calculated with less than n elements", "\n", "retIncompletePart", "=", "cumsum", "[", ":", "n", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "retIncompletePart", ")", ")", ":", "\n", "        ", "retIncompletePart", "[", "i", "]", "=", "retIncompletePart", "[", "i", "]", "/", "(", "i", "+", "1", ")", "\n", "", "return", "np", ".", "concatenate", "(", "(", "retIncompletePart", ",", "retCompletePart", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.movingAverageConv": [[213, 223], ["numpy.ones", "min", "int", "numpy.convolve", "len", "float", "numpy.asarray", "len", "range"], "function", ["None"], ["", "def", "movingAverageConv", "(", "a", ",", "window_size", "=", "1", ")", ":", "\n", "    ", "if", "not", "a", ":", "return", "a", "\n", "window", "=", "np", ".", "ones", "(", "int", "(", "window_size", ")", ")", "\n", "result", "=", "np", ".", "convolve", "(", "a", ",", "window", ",", "'full'", ")", "[", ":", "len", "(", "a", ")", "]", "# Convolve full returns array of shape ( M + N - 1 ).", "\n", "slotsWithIncompleteConvolution", "=", "min", "(", "len", "(", "a", ")", ",", "window_size", "-", "1", ")", "\n", "result", "[", "slotsWithIncompleteConvolution", ":", "]", "=", "result", "[", "slotsWithIncompleteConvolution", ":", "]", "/", "float", "(", "window_size", ")", "\n", "if", "slotsWithIncompleteConvolution", ">", "1", ":", "\n", "        ", "divisorArr", "=", "np", ".", "asarray", "(", "range", "(", "1", ",", "slotsWithIncompleteConvolution", "+", "1", ",", "1", ")", ",", "dtype", "=", "float", ")", "\n", "result", "[", ":", "slotsWithIncompleteConvolution", "]", "=", "result", "[", ":", "slotsWithIncompleteConvolution", "]", "/", "divisorArr", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.applyMovingAverageToAllButDscFullSeg": [[228, 236], ["six.moves.xrange", "len", "plotTrainingProgress.movingAverageConv"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.movingAverageConv"], ["", "def", "applyMovingAverageToAllButDscFullSeg", "(", "detailedPlotBool", ",", "measuredMetricsFromAllExperiments", ",", "movingAverSubeps", ")", ":", "\n", "    ", "for", "valOrTrainExperiments", "in", "measuredMetricsFromAllExperiments", ":", "\n", "        ", "for", "experimentToPlot", "in", "valOrTrainExperiments", ":", "# Number of logs X Classes", "\n", "            ", "for", "metric_i", "in", "xrange", "(", "len", "(", "experimentToPlot", ")", ")", ":", "\n", "                ", "if", "detailedPlotBool", "and", "metric_i", "==", "4", ":", "# We are plotting detailed metrics and this is the DSC-Full-Seg, which we do not smooth with movingAverage", "\n", "                    ", "continue", "\n", "", "experimentToPlot", "[", "metric_i", "]", "=", "movingAverageConv", "(", "experimentToPlot", "[", "metric_i", "]", ",", "movingAverSubeps", ")", "\n", "", "", "", "return", "measuredMetricsFromAllExperiments", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.checkIfLineMatchesAnyRegExpr": [[238, 247], ["six.moves.xrange", "len", "six.moves.xrange", "len", "six.moves.xrange", "len", "re.match"], "function", ["None"], ["", "def", "checkIfLineMatchesAnyRegExpr", "(", "string", ",", "regExprForEachClassAndMetric", ")", ":", "\n", "    ", "for", "val0orTrain1", "in", "xrange", "(", "len", "(", "regExprForEachClassAndMetric", ")", ")", ":", "#[0,1]", "\n", "        ", "for", "class_i", "in", "xrange", "(", "len", "(", "regExprForEachClassAndMetric", "[", "val0orTrain1", "]", ")", ")", ":", "\n", "            ", "for", "metric_i", "in", "xrange", "(", "len", "(", "regExprForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "class_i", "]", ")", ")", ":", "\n", "                ", "regExp1", "=", "regExprForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "class_i", "]", "[", "metric_i", "]", "\n", "matchObj", "=", "re", ".", "match", "(", "regExp1", ",", "string", ",", "re", ".", "M", "|", "re", ".", "I", ")", "\n", "if", "matchObj", ":", "\n", "                    ", "return", "matchObj", ",", "val0orTrain1", ",", "class_i", ",", "metric_i", "\n", "", "", "", "", "return", "None", ",", "None", ",", "None", ",", "None", "# No regular expression matches this string.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseBasicMetricsFromThisLog": [[250, 295], ["open", "open.readline", "open.close", "plotTrainingProgress.getRegExprForParsingMetric", "[].append", "[].append", "six.moves.xrange", "plotTrainingProgress.checkIfLineMatchesAnyRegExpr", "open.readline", "[].append", "[].append", "plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "f.readline.find", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getRegExprForParsingMetric", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.checkIfLineMatchesAnyRegExpr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl"], ["", "def", "parseBasicMetricsFromThisLog", "(", "logFile", ",", "movingAverSubeps", ")", ":", "\n", "### Initially just form a data structure with the regular expressions for each val/train, class and metric. ###", "\n", "# [0] val, [1] train", "\n", "# Each has one sublist, because I only have 1 class in the basic-plotting! ( Extra dimension kept just so that this function is consistent with the \"detailed\" version. For future merging.)", "\n", "# Each class-sublist has 1 entry, one for Acc", "\n", "    ", "regExprForEachClassAndMetric", "=", "[", "[", "[", "]", "]", ",", "[", "[", "]", "]", "]", "#[0] val, [1] train", "\n", "sentencesToLookForEachClassAndMetric", "=", "[", "[", "[", "]", "]", ",", "[", "[", "]", "]", "]", "#[0] val, [1] train", "\n", "\n", "for", "val0orTrain1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "(", "regExprForMeanAcc", ",", "sentenceForMeanAcc", ")", "=", "getRegExprForParsingMetric", "(", "val0orTrain1", ",", "0", ",", "None", ",", "0", ")", "\n", "regExprForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "0", "]", ".", "append", "(", "regExprForMeanAcc", ")", "\n", "sentencesToLookForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "0", "]", ".", "append", "(", "sentenceForMeanAcc", ")", "\n", "\n", "### Form the data structure where we ll put all the measurements from this logfile for each val/train, class and metric. ###", "\n", "#[0] val, [1] train. Each has one sublist, because in basic I have only 1 class to be plotted. The class-sublist has 1 sublist, because here I have only 1 plotted metric.", "\n", "", "measurementsForEachClassAndMetric", "=", "[", "[", "[", "]", "]", ",", "[", "[", "]", "]", "]", "\n", "previousMeasurementForEachClassAndMetric", "=", "[", "[", "[", "]", "]", ",", "[", "[", "]", "]", "]", "#This is useful in the case I get a not-valid number, to just use the previous one.", "\n", "for", "val0orTrain1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "for", "metric_i", "in", "xrange", "(", "1", ")", ":", "\n", "            ", "measurementsForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "0", "]", ".", "append", "(", "[", "]", ")", "# Add a sublist in the class, per metric.", "\n", "previousMeasurementForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "0", "]", ".", "append", "(", "0", ")", "\n", "\n", "### Read the file and start parsing each line.", "\n", "", "", "f", "=", "open", "(", "logFile", ",", "'r'", ")", "\n", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "while", "newLine", ":", "\n", "        ", "matchObj", ",", "matchVal0Train1", ",", "matchClass_i", ",", "matchMetric_i", "=", "checkIfLineMatchesAnyRegExpr", "(", "newLine", ",", "regExprForEachClassAndMetric", ")", "\n", "\n", "if", "matchObj", ":", "#matched the reg-expression for Acc", "\n", "            ", "sentenceToLookFor", "=", "sentencesToLookForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "\n", "restOfLineAfterPattern", "=", "newLine", "[", "newLine", ".", "find", "(", "sentenceToLookFor", ")", "+", "len", "(", "sentenceToLookFor", ")", ":", "]", "\n", "theListInString", "=", "getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "(", "restOfLineAfterPattern", ",", "f", ")", "\n", "listOfstringNumbersSplitted", "=", "getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "(", "theListInString", ",", "\"\"", ")", "\n", "\n", "previousMeasurementForClassAndMetric", "=", "previousMeasurementForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "\n", "listOfMeasurements", "=", "getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "(", "listOfstringNumbersSplitted", ",", "previousMeasurementForClassAndMetric", ")", "\n", "\n", "previousMeasurementForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "=", "listOfMeasurements", "[", "-", "1", "]", "# LHS use the list itself, not an intermediate immutable int-variable!", "\n", "measurementsForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "+=", "listOfMeasurements", "\n", "\n", "", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "\n", "return", "(", "measurementsForEachClassAndMetric", "[", "0", "]", ",", "measurementsForEachClassAndMetric", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseDetailedMetricsFromThisLog": [[298, 372], ["open", "open.readline", "open.close", "six.moves.xrange", "plotTrainingProgress.checkIfLineMatchesAnyRegExpr", "open.readline", "regExprForEachClassAndMetric[].append", "sentencesToLookForEachClassAndMetric[].append", "len", "measurementsForEachClassAndMetric[].append", "previousMeasurementForEachClassAndMetric[].append", "six.moves.xrange", "plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "re.match", "plotTrainingProgress.getRegExprForParsingMetric", "regExprForClassAllMetrics.append", "sentencesForClassAllMetrics.append", "[].append", "[].append", "plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "six.moves.xrange", "[].append", "len", "plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "f.readline.find", "len", "f.readline.find", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.checkIfLineMatchesAnyRegExpr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getRegExprForParsingMetric", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl"], ["", "def", "parseDetailedMetricsFromThisLog", "(", "logFile", ",", "classesFromThisLog", ",", "movingAverSubeps", ")", ":", "\n", "### Initially just form a data structure with the regular expressions for each val/train, class and metric. ###", "\n", "# [0] val, [1] train", "\n", "# Each has one sublist per class to be plotted", "\n", "# Each class-sublist has 4 entries, one for each of the plotted metrics Acc,Sens,Spec,DSC-samples. NOT FOR DSC-Full-Seg cause it's not reported per class/subepoch.", "\n", "    ", "regExprForEachClassAndMetric", "=", "[", "[", "]", ",", "[", "]", "]", "#[0] val, [1] train", "\n", "sentencesToLookForEachClassAndMetric", "=", "[", "[", "]", ",", "[", "]", "]", "#[0] val, [1] train", "\n", "regExprForDscFullSeg", "=", "\".*ACCURACY:.*Validation.*The Per-Class average DICE Coefficients over all subjects are:.*DICE2=\"", "# Special case, because it's not reported per class.", "\n", "sentenceForDscFullSeg", "=", "\"DICE2=\"", "\n", "\n", "for", "val0orTrain1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "for", "classInt", "in", "classesFromThisLog", ":", "\n", "# mean acc, sens, spec, dsc samples, dsc full.", "\n", "            ", "regExprForClassAllMetrics", "=", "[", "]", "\n", "sentencesForClassAllMetrics", "=", "[", "]", "\n", "for", "metric_i", "in", "[", "0", ",", "1", ",", "2", ",", "4", "]", ":", "# Integers specify which metrics.", "\n", "                ", "reg_expr", ",", "metric", "=", "getRegExprForParsingMetric", "(", "val0orTrain1", ",", "1", ",", "classInt", ",", "metric_i", ")", "\n", "regExprForClassAllMetrics", ".", "append", "(", "reg_expr", ")", "\n", "sentencesForClassAllMetrics", ".", "append", "(", "metric", ")", "\n", "", "regExprForEachClassAndMetric", "[", "val0orTrain1", "]", ".", "append", "(", "regExprForClassAllMetrics", ")", "\n", "sentencesToLookForEachClassAndMetric", "[", "val0orTrain1", "]", ".", "append", "(", "sentencesForClassAllMetrics", ")", "\n", "\n", "### Form the data structure where we ll put all the measurements from this logfile for each val/train, class and metric. ###", "\n", "#[0] val, [1] train. Each has one sublist per class to be plotted. Each class-sublist has 5 sublists, one for each of the plotted metrics.", "\n", "", "", "measurementsForEachClassAndMetric", "=", "[", "[", "]", ",", "[", "]", "]", "\n", "previousMeasurementForEachClassAndMetric", "=", "[", "[", "]", ",", "[", "]", "]", "#This is useful in the case I get a not-valid number, to just use the previous one.", "\n", "for", "val0orTrain1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "for", "class_i", "in", "xrange", "(", "len", "(", "classesFromThisLog", ")", ")", ":", "\n", "            ", "measurementsForEachClassAndMetric", "[", "val0orTrain1", "]", ".", "append", "(", "[", "]", ")", "# add a sublist in the val/train for each class", "\n", "previousMeasurementForEachClassAndMetric", "[", "val0orTrain1", "]", ".", "append", "(", "[", "]", ")", "\n", "for", "metric_i", "in", "xrange", "(", "0", ",", "5", ")", ":", "# CAREFUL WITH THIS >> 5 <<", "\n", "                ", "measurementsForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "class_i", "]", ".", "append", "(", "[", "]", ")", "# Add a sublist in the class, per metric.", "\n", "if", "metric_i", "==", "4", ":", "# If it's the DSC-full-segm, add an initial 0 measurement!", "\n", "                    ", "measurementsForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "class_i", "]", "[", "-", "1", "]", ".", "append", "(", "0", ")", "\n", "", "previousMeasurementForEachClassAndMetric", "[", "val0orTrain1", "]", "[", "class_i", "]", ".", "append", "(", "0", ")", "\n", "\n", "### Read the file and start parsing each line.", "\n", "", "", "", "f", "=", "open", "(", "logFile", ",", "'r'", ")", "\n", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "while", "newLine", ":", "\n", "        ", "matchObj", ",", "matchVal0Train1", ",", "matchClass_i", ",", "matchMetric_i", "=", "checkIfLineMatchesAnyRegExpr", "(", "newLine", ",", "regExprForEachClassAndMetric", ")", "\n", "\n", "if", "matchObj", ":", "#matched one of the reg-expressions for Acc/Sens/Spec/Dsc-Samples.", "\n", "            ", "sentenceToLookFor", "=", "sentencesToLookForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "\n", "restOfLineAfterPattern", "=", "newLine", "[", "newLine", ".", "find", "(", "sentenceToLookFor", ")", "+", "len", "(", "sentenceToLookFor", ")", ":", "]", "\n", "theListInString", "=", "getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "(", "restOfLineAfterPattern", ",", "f", ")", "\n", "listOfstringNumbersSplitted", "=", "getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "(", "theListInString", ",", "\"\"", ")", "\n", "\n", "previousMeasurementForClassAndMetric", "=", "previousMeasurementForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "\n", "listOfMeasurements", "=", "getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "(", "listOfstringNumbersSplitted", ",", "previousMeasurementForClassAndMetric", ")", "\n", "\n", "previousMeasurementForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "=", "listOfMeasurements", "[", "-", "1", "]", "# LHS use the list itself, not an intermediate immutable int-variable!", "\n", "measurementsForEachClassAndMetric", "[", "matchVal0Train1", "]", "[", "matchClass_i", "]", "[", "matchMetric_i", "]", "+=", "listOfMeasurements", "\n", "\n", "", "elif", "re", ".", "match", "(", "regExprForDscFullSeg", ",", "newLine", ",", "re", ".", "M", "|", "re", ".", "I", ")", ":", "# Did not match the reg-expressions for Acc/Sens/Spec/Dsc-Samples. But matches DSC-Full-Inf!", "\n", "            ", "sentenceToLookFor", "=", "sentenceForDscFullSeg", "\n", "restOfLineAfterPattern", "=", "newLine", "[", "newLine", ".", "find", "(", "sentenceToLookFor", ")", "+", "len", "(", "sentenceToLookFor", ")", ":", "]", "\n", "theListInString", "=", "getStringOfTheListThatForSureStartsInThisLineButMayEndInAnother", "(", "restOfLineAfterPattern", ",", "f", ")", "\n", "listOfstringNumbersSplitted", "=", "getAListOfStringNumbersAfterSplittingThemFromAStringListWithStringNumbers", "(", "theListInString", ",", "\"\"", ")", "\n", "\n", "for", "class_i", "in", "xrange", "(", "len", "(", "classesFromThisLog", ")", ")", ":", "\n", "                ", "previousMeasurement", "=", "previousMeasurementForEachClassAndMetric", "[", "0", "]", "[", "class_i", "]", "[", "4", "]", "# get last value found for DSC of this class.", "\n", "dscForTheWantedClassInString", "=", "listOfstringNumbersSplitted", "[", "classesFromThisLog", "[", "class_i", "]", "]", "# Reported list with DICE is different than others and has a float per class.", "\n", "# listOfMeasurements = [float], just a list with one float in this case of DSC-full-seg.", "\n", "listOfMeasurements", "=", "getListOfAccNumbersFromListOfStrNumbersAvoidingNotAppl", "(", "[", "dscForTheWantedClassInString", "]", ",", "previousMeasurement", ")", "# just returns the str number as float here.", "\n", "\n", "previousMeasurementForEachClassAndMetric", "[", "0", "]", "[", "class_i", "]", "[", "4", "]", "=", "listOfMeasurements", "[", "-", "1", "]", "# DONT replace LHS with any intermediate Int immutable variable!", "\n", "measurementsForEachClassAndMetric", "[", "0", "]", "[", "class_i", "]", "[", "4", "]", "+=", "listOfMeasurements", "\n", "\n", "", "", "newLine", "=", "f", ".", "readline", "(", ")", "\n", "\n", "", "f", ".", "close", "(", ")", "\n", "\n", "return", "(", "measurementsForEachClassAndMetric", "[", "0", "]", ",", "measurementsForEachClassAndMetric", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.optimizedParseMetricsFromLogs": [[374, 391], ["six.moves.xrange", "plotTrainingProgress.applyMovingAverageToAllButDscFullSeg", "len", "plotTrainingProgress.parseBasicMetricsFromThisLog", "plotTrainingProgress.parseDetailedMetricsFromThisLog"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.applyMovingAverageToAllButDscFullSeg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseBasicMetricsFromThisLog", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.parseDetailedMetricsFromThisLog"], ["", "def", "optimizedParseMetricsFromLogs", "(", "logFiles", ",", "detailedPlotBool", ",", "classesFromEachLogFile", ",", "movingAverSubeps", ")", ":", "\n", "# Two rows, Validation and Accuracy", "\n", "# Each of these has as many sublists as the number of experiments (logFiles) X Classes!", "\n", "# Each of these sublists has a 5/4-entries sublist. Mean Accuracy/Sens/Spec/DSC-on-samples/DSC-from-full-segm-of-volumes (val only). OR just 1, if basic.", "\n", "    ", "measuredMetricsFromAllExperiments", "=", "[", "[", "]", ",", "[", "]", "]", "#[0] validation, [1] training measurements.", "\n", "for", "logFile_i", "in", "xrange", "(", "0", ",", "len", "(", "logFiles", ")", ")", ":", "\n", "        ", "if", "not", "detailedPlotBool", ":", "\n", "            ", "(", "measuredMetricsFromThisLogValidation", ",", "\n", "measuredMetricsFromThisLogTraining", ")", "=", "parseBasicMetricsFromThisLog", "(", "logFiles", "[", "logFile_i", "]", ",", "movingAverSubeps", ")", "\n", "", "else", ":", "\n", "            ", "(", "measuredMetricsFromThisLogValidation", ",", "\n", "measuredMetricsFromThisLogTraining", ")", "=", "parseDetailedMetricsFromThisLog", "(", "logFiles", "[", "logFile_i", "]", ",", "classesFromEachLogFile", "[", "logFile_i", "]", ",", "movingAverSubeps", ")", "\n", "\n", "", "measuredMetricsFromAllExperiments", "[", "0", "]", "+=", "measuredMetricsFromThisLogValidation", "\n", "measuredMetricsFromAllExperiments", "[", "1", "]", "+=", "measuredMetricsFromThisLogTraining", "\n", "", "measuredMetricsFromAllExperiments", "=", "applyMovingAverageToAllButDscFullSeg", "(", "detailedPlotBool", ",", "measuredMetricsFromAllExperiments", ",", "movingAverSubeps", ")", "\n", "return", "measuredMetricsFromAllExperiments", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.plotProgressBasic": [[399, 470], ["len", "matplotlib.subplots", "fig.set_size_inches", "fig.set_dpi", "fig.subplots_adjust", "fig.canvas.set_window_title", "fig.suptitle", "six.moves.xrange", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylabel", "axes[].set_ylabel", "axes[].legend", "matplotlib.show", "os.path.basename", "len", "six.moves.xrange", "axis.yaxis.grid", "axis.tick_params", "legobj.set_linewidth", "matplotlib.savefig", "str", "len", "six.moves.xrange", "len", "len", "numpy.linspace", "axis.plot", "axis.set_title", "axis.yaxis.grid", "axis.set_xlim", "axis.set_xlabel", "str", "os.path.basename", "len", "len"], "function", ["None"], ["", "def", "plotProgressBasic", "(", "measuredMetricsFromAllExperiments", ",", "legendList", ",", "movingAverSubeps", ",", "subepochsPerEpOfExpers", ",", "saveFigureBool", ")", ":", "\n", "    ", "colors", "=", "[", "\"r\"", ",", "\"g\"", ",", "\"b\"", ",", "\"c\"", ",", "\"m\"", ",", "\"k\"", "]", "\n", "linestyles", "=", "[", "'-'", ",", "'--'", ",", "':'", ",", "'_'", ",", "'-.'", "]", "\n", "\n", "subplotTitles", "=", "[", "[", "\"Mean Accuracy\"", "]", ",", "# Validation", "\n", "[", "\"Mean Accuracy\"", "]", "# Training", "\n", "]", "\n", "\n", "fontSizeSubplotTitles", "=", "14", ";", "fontSizeXTickLabel", "=", "12", ";", "fontSizeYTickLabel", "=", "12", ";", "fontSizeXAxisLabel", "=", "12", ";", "fontSizeYAxisLabel", "=", "14", ";", "linewidthInPlots", "=", "1.5", ";", "\n", "legendFontSize", "=", "12", ";", "legendNumberOfColumns", "=", "4", ";", "\n", "#plt.close('all')", "\n", "#plt.subplots(rows,columns): returns: (figure, axes), where axes is an array, one element for each subplot, of rows and columns as I specify!", "\n", "numberOfMetricsPlotted", "=", "len", "(", "measuredMetricsFromAllExperiments", "[", "0", "]", "[", "0", "]", ")", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "2", ",", "numberOfMetricsPlotted", ",", "sharex", "=", "False", ",", "sharey", "=", "False", ")", "\n", "inchesForMainPlotPart", "=", "7", ";", "inchesForLegend", "=", "0.6", ";", "percForMain", "=", "inchesForMainPlotPart", "*", "1.0", "/", "(", "inchesForMainPlotPart", "+", "inchesForLegend", ")", ";", "percForLegend", "=", "1.", "-", "percForMain", "\n", "fig", ".", "set_size_inches", "(", "15", ",", "inchesForMainPlotPart", "+", "inchesForLegend", ")", ";", "#changes width/height of the figure. VERY IMPORTANT", "\n", "fig", ".", "set_dpi", "(", "100", ")", ";", "#changes width/height of the figure.", "\n", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "0.05", ",", "bottom", "=", "0.1", "*", "percForMain", "+", "percForLegend", ",", "right", "=", "0.98", ",", "top", "=", "0.92", "*", "percForMain", "+", "percForLegend", ",", "wspace", "=", "0.25", ",", "hspace", "=", "0.4", "*", "percForMain", ")", "\n", "fig", ".", "canvas", ".", "set_window_title", "(", "os", ".", "path", ".", "basename", "(", "__file__", ")", ")", "\n", "fig", ".", "suptitle", "(", "os", ".", "path", ".", "basename", "(", "__file__", ")", "+", "\": Moving Average over [\"", "+", "str", "(", "movingAverSubeps", ")", "+", "\"] value. For each plotted experiment, Subepochs per Epoch: \"", "+", "str", "(", "subepochsPerEpOfExpers", ")", ",", "fontsize", "=", "8", ")", "#, fontweight='bold')", "\n", "\n", "maxNumOfEpsDurationOfExps", "=", "0", "# The number of epochs that the longest experiment lasted.", "\n", "\n", "for", "valOrTrain_i", "in", "xrange", "(", "0", ",", "len", "(", "measuredMetricsFromAllExperiments", ")", ")", ":", "\n", "        ", "for", "valOrTrainExperiment_i", "in", "xrange", "(", "0", ",", "len", "(", "measuredMetricsFromAllExperiments", "[", "valOrTrain_i", "]", ")", ")", ":", "\n", "            ", "valOrTrainExperiment", "=", "measuredMetricsFromAllExperiments", "[", "valOrTrain_i", "]", "[", "valOrTrainExperiment_i", "]", "\n", "for", "metric_i", "in", "xrange", "(", "0", ",", "len", "(", "valOrTrainExperiment", ")", ")", ":", "\n", "                ", "numberOfSubsPerEpoch", "=", "subepochsPerEpOfExpers", "[", "valOrTrainExperiment_i", "]", "\n", "\n", "numberOfSubepochsRan", "=", "len", "(", "valOrTrainExperiment", "[", "metric_i", "]", ")", "\n", "numberOfEpochsRan", "=", "numberOfSubepochsRan", "*", "1.0", "/", "numberOfSubsPerEpoch", "\n", "maxNumOfEpsDurationOfExps", "=", "maxNumOfEpsDurationOfExps", "if", "maxNumOfEpsDurationOfExps", ">=", "numberOfEpochsRan", "else", "numberOfEpochsRan", "\n", "xIter", "=", "np", ".", "linspace", "(", "0", ",", "numberOfEpochsRan", ",", "numberOfSubepochsRan", ",", "endpoint", "=", "True", ")", "#endpoint=True includes it as the final point.", "\n", "\n", "axis", "=", "axes", "[", "valOrTrain_i", "]", "if", "numberOfMetricsPlotted", "==", "1", "else", "axes", "[", "valOrTrain_i", ",", "metric_i", "]", "# No 2nd index when subplot(X, 1, ...)", "\n", "axis", ".", "plot", "(", "xIter", ",", "valOrTrainExperiment", "[", "metric_i", "]", ",", "color", "=", "colors", "[", "valOrTrainExperiment_i", "%", "len", "(", "colors", ")", "]", ",", "linestyle", "=", "linestyles", "[", "valOrTrainExperiment_i", "//", "len", "(", "colors", ")", "]", ",", "label", "=", "legendList", "[", "valOrTrainExperiment_i", "]", ",", "linewidth", "=", "linewidthInPlots", ")", "\n", "axis", ".", "set_title", "(", "subplotTitles", "[", "valOrTrain_i", "]", "[", "metric_i", "]", ",", "fontsize", "=", "fontSizeSubplotTitles", ",", "y", "=", "1.022", ")", "\n", "axis", ".", "yaxis", ".", "grid", "(", "True", ",", "zorder", "=", "0", ")", "\n", "axis", ".", "set_xlim", "(", "[", "0", ",", "maxNumOfEpsDurationOfExps", "]", ")", "\n", "axis", ".", "set_xlabel", "(", "'Epoch'", ",", "fontsize", "=", "fontSizeXAxisLabel", ")", "\n", "\n", "", "", "", "for", "train0AndValidation1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "axis", "=", "axes", "[", "train0AndValidation1", "]", "if", "numberOfMetricsPlotted", "==", "1", "else", "axes", "[", "train0AndValidation1", "]", "[", "axis_i", "]", "\n", "axis", ".", "yaxis", ".", "grid", "(", "True", ",", "linestyle", "=", "'--'", ",", "which", "=", "'major'", ",", "color", "=", "'black'", ",", "alpha", "=", "1.0", ")", "\n", "axis", ".", "tick_params", "(", "axis", "=", "'y'", ",", "labelsize", "=", "fontSizeYTickLabel", ")", "\n", "\n", "", "axes", "[", "0", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "\n", "axes", "[", "1", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "\n", "\n", "axes", "[", "0", "]", ".", "set_ylabel", "(", "'Validation'", ",", "fontsize", "=", "fontSizeYAxisLabel", ")", "\n", "axes", "[", "1", "]", ".", "set_ylabel", "(", "'Training'", ",", "fontsize", "=", "fontSizeYAxisLabel", ")", "\n", "\n", "\"\"\"\n    Moving the legend-box:\n    - You grab a subplot. (depending on the axis that you ll use at: axis.legend(...))\n    - Then, you specify with loc=, the anchor of the LEGENDBOX that you will move in relation to the BOTTOM-LEFT corner of the above axis..\n        loc = 'upper right' (1), 'upper left' (2), 'lower left' (3), 'lower right' (4)\n    - bbox_to_anchor=(x-from-left, y-from-bottom, width, height). x and y can be negatives. Specify how much to move legend's loc from the bottom left corner of the axis.\n        x, y, width and height are floats, giving the percentage of the AXIS's size. Eg x=0.5, y=0.5 moves it at the middle of the subplot.\n    \"\"\"", "\n", "leg", "=", "axes", "[", "1", "]", ".", "legend", "(", "loc", "=", "'upper left'", ",", "bbox_to_anchor", "=", "(", "0.", ",", "-", ".25", ",", "0.", ",", "0.", ")", ",", "#(0., -1.3, 1., 1.),", "\n", "ncol", "=", "legendNumberOfColumns", ",", "borderaxespad", "=", "0.", ",", "fontsize", "=", "legendFontSize", ",", "labelspacing", "=", "0.", ",", "columnspacing", "=", "1.0", ")", "#mode=\"expand\",", "\n", "#Make the lines in the legend wider.", "\n", "for", "legobj", "in", "leg", ".", "legendHandles", ":", "\n", "        ", "legobj", ".", "set_linewidth", "(", "6.0", ")", "\n", "\n", "", "if", "saveFigureBool", ":", "\n", "        ", "plt", ".", "savefig", "(", "'./trainingProgress.pdf'", ",", "dpi", "=", "fig", ".", "dpi", ")", "#, bbox_inches='tight')", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.plotTrainingProgress.plotProgressDetailed": [[471, 556], ["matplotlib.subplots", "fig.set_size_inches", "fig.set_dpi", "fig.subplots_adjust", "fig.canvas.set_window_title", "fig.suptitle", "six.moves.xrange", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylim", "axes[].set_ylabel", "axes[].set_ylabel", "axes[].legend", "matplotlib.show", "os.path.basename", "len", "six.moves.xrange", "legobj.set_linewidth", "matplotlib.savefig", "str", "len", "six.moves.xrange", "axis.yaxis.grid", "axis.tick_params", "len", "axes[].plot", "axes[].set_title", "axes[].yaxis.grid", "axes[].set_xlim", "axes[].set_xlabel", "str", "len", "numpy.linspace", "len", "numpy.linspace", "str", "os.path.basename", "len", "len"], "function", ["None"], ["", "def", "plotProgressDetailed", "(", "measuredMetricsFromAllExperiments", ",", "legendList", ",", "movingAverSubeps", ",", "subepochsPerEpOfExpers", ",", "epochsPerFullInferOfExpers", ",", "saveFigureBool", ")", ":", "\n", "    ", "colors", "=", "[", "\"r\"", ",", "\"g\"", ",", "\"b\"", ",", "\"c\"", ",", "\"m\"", ",", "\"k\"", "]", "\n", "linestyles", "=", "[", "'-'", ",", "'--'", ",", "':'", ",", "'_'", ",", "'-.'", "]", "\n", "\n", "subplotTitles", "=", "[", "[", "\"Mean Accuracy\"", ",", "\"Sensitivity\"", ",", "\"Precision\"", ",", "\"DSC (samples)\"", ",", "\"DSC (full-segm)\"", "]", ",", "# Validation", "\n", "[", "\"Mean Accuracy\"", ",", "\"Sensitivity\"", ",", "\"Precision\"", ",", "\"DSC (samples)\"", ",", "\"DSC (full-segm)\"", "]", "# Training", "\n", "]", "\n", "\n", "fontSizeSubplotTitles", "=", "14", ";", "fontSizeXTickLabel", "=", "12", ";", "fontSizeYTickLabel", "=", "12", ";", "fontSizeXAxisLabel", "=", "12", ";", "fontSizeYAxisLabel", "=", "14", ";", "linewidthInPlots", "=", "1.5", ";", "\n", "legendFontSize", "=", "12", ";", "legendNumberOfColumns", "=", "4", ";", "\n", "#plt.close('all')", "\n", "#plt.subplots(rows,columns): returns: (figure, axes), where axes is an array, one element for each subplot, of rows and columns as I specify!", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "2", ",", "5", ",", "sharex", "=", "False", ",", "sharey", "=", "False", ")", "\n", "inchesForMainPlotPart", "=", "7", ";", "inchesForLegend", "=", "0.6", ";", "percForMain", "=", "inchesForMainPlotPart", "*", "1.0", "/", "(", "inchesForMainPlotPart", "+", "inchesForLegend", ")", ";", "percForLegend", "=", "1.", "-", "percForMain", "\n", "fig", ".", "set_size_inches", "(", "15", ",", "inchesForMainPlotPart", "+", "inchesForLegend", ")", ";", "#changes width/height of the figure. VERY IMPORTANT", "\n", "fig", ".", "set_dpi", "(", "100", ")", ";", "#changes width/height of the figure.", "\n", "\n", "fig", ".", "subplots_adjust", "(", "left", "=", "0.05", ",", "bottom", "=", "0.1", "*", "percForMain", "+", "percForLegend", ",", "right", "=", "0.98", ",", "top", "=", "0.92", "*", "percForMain", "+", "percForLegend", ",", "wspace", "=", "0.25", ",", "hspace", "=", "0.4", "*", "percForMain", ")", "\n", "fig", ".", "canvas", ".", "set_window_title", "(", "os", ".", "path", ".", "basename", "(", "__file__", ")", ")", "\n", "fig", ".", "suptitle", "(", "os", ".", "path", ".", "basename", "(", "__file__", ")", "+", "\": Moving Average over [\"", "+", "str", "(", "movingAverSubeps", ")", "+", "\"] value. For each plotted experiment, Subepochs per Epoch: \"", "+", "str", "(", "subepochsPerEpOfExpers", ")", "+", "\", Epochs between Full-Segmentations: \"", "+", "str", "(", "epochsPerFullInferOfExpers", ")", ",", "fontsize", "=", "8", ")", "#, fontweight='bold')", "\n", "\n", "maxNumOfEpsDurationOfExps", "=", "0", "# The number of epochs that the longest experiment lasted.", "\n", "\n", "for", "valOrTrain_i", "in", "xrange", "(", "0", ",", "len", "(", "measuredMetricsFromAllExperiments", ")", ")", ":", "\n", "        ", "for", "valOrTrainExperiment_i", "in", "xrange", "(", "0", ",", "len", "(", "measuredMetricsFromAllExperiments", "[", "valOrTrain_i", "]", ")", ")", ":", "\n", "            ", "valOrTrainExperiment", "=", "measuredMetricsFromAllExperiments", "[", "valOrTrain_i", "]", "[", "valOrTrainExperiment_i", "]", "\n", "for", "meanPosNegDice1_i", "in", "xrange", "(", "0", ",", "len", "(", "valOrTrainExperiment", ")", ")", ":", "\n", "                ", "numberOfSubsPerEpoch", "=", "subepochsPerEpOfExpers", "[", "valOrTrainExperiment_i", "]", "\n", "numberOfEpsBetweenFullInf", "=", "epochsPerFullInferOfExpers", "[", "valOrTrainExperiment_i", "]", "\n", "\n", "if", "meanPosNegDice1_i", "!=", "4", ":", "#Not for DSC full inference.", "\n", "                    ", "numberOfSubepochsRan", "=", "len", "(", "valOrTrainExperiment", "[", "meanPosNegDice1_i", "]", ")", "\n", "numberOfEpochsRan", "=", "numberOfSubepochsRan", "*", "1.0", "/", "numberOfSubsPerEpoch", "\n", "maxNumOfEpsDurationOfExps", "=", "maxNumOfEpsDurationOfExps", "if", "maxNumOfEpsDurationOfExps", ">=", "numberOfEpochsRan", "else", "numberOfEpochsRan", "\n", "xIter", "=", "np", ".", "linspace", "(", "0", ",", "numberOfEpochsRan", ",", "numberOfSubepochsRan", ",", "endpoint", "=", "True", ")", "#endpoint=True includes it as the final point.", "\n", "", "else", ":", "#DSC Full inference.", "\n", "#The -1 here is because for the DSC I previously prepended a 0 element (at 0th iteration).", "\n", "                    ", "numberOfFullInfRanPlusOneAt0", "=", "len", "(", "valOrTrainExperiment", "[", "meanPosNegDice1_i", "]", ")", "\n", "numberOfEpochsRan", "=", "(", "numberOfFullInfRanPlusOneAt0", "-", "1", ")", "*", "numberOfEpsBetweenFullInf", "\n", "maxNumOfEpsDurationOfExps", "=", "maxNumOfEpsDurationOfExps", "if", "maxNumOfEpsDurationOfExps", ">=", "numberOfEpochsRan", "else", "numberOfEpochsRan", "\n", "xIter", "=", "np", ".", "linspace", "(", "0", ",", "numberOfEpochsRan", ",", "numberOfFullInfRanPlusOneAt0", ",", "endpoint", "=", "True", ")", "\n", "\n", "", "axes", "[", "valOrTrain_i", ",", "meanPosNegDice1_i", "]", ".", "plot", "(", "xIter", ",", "valOrTrainExperiment", "[", "meanPosNegDice1_i", "]", ",", "color", "=", "colors", "[", "valOrTrainExperiment_i", "%", "len", "(", "colors", ")", "]", ",", "linestyle", "=", "linestyles", "[", "valOrTrainExperiment_i", "//", "len", "(", "colors", ")", "]", ",", "label", "=", "legendList", "[", "valOrTrainExperiment_i", "]", ",", "linewidth", "=", "linewidthInPlots", ")", "\n", "axes", "[", "valOrTrain_i", ",", "meanPosNegDice1_i", "]", ".", "set_title", "(", "subplotTitles", "[", "valOrTrain_i", "]", "[", "meanPosNegDice1_i", "]", ",", "fontsize", "=", "fontSizeSubplotTitles", ",", "y", "=", "1.022", ")", "\n", "axes", "[", "valOrTrain_i", ",", "meanPosNegDice1_i", "]", ".", "yaxis", ".", "grid", "(", "True", ",", "zorder", "=", "0", ")", "\n", "axes", "[", "valOrTrain_i", ",", "meanPosNegDice1_i", "]", ".", "set_xlim", "(", "[", "0", ",", "maxNumOfEpsDurationOfExps", "]", ")", "\n", "axes", "[", "valOrTrain_i", ",", "meanPosNegDice1_i", "]", ".", "set_xlabel", "(", "'Epoch'", ",", "fontsize", "=", "fontSizeXAxisLabel", ")", "\n", "\n", "", "", "", "for", "train0AndValidation1", "in", "[", "0", ",", "1", "]", ":", "\n", "        ", "for", "axis", "in", "axes", "[", "train0AndValidation1", "]", ":", "\n", "#plt.setp(axis.get_xticklabels(), rotation='horizontal', fontsize=fontSizeXTickLabel) #In case I want something vertical, this is how I change it.", "\n", "#plt.setp(axis.get_yticklabels(), rotation='horizontal', fontsize=fontSizeYTickLabel)", "\n", "\n", "#axis.xticks(xCustomTicksEpochs, labels, rotation='vertical') If I d like to also give labels, this is how I do it.", "\n", "\n", "#In case I want to manually define where to have xticks.", "\n", "#axis.set_xticks(xCustomTicksSubepochs)", "\n", "#axis.set_xticklabels(xCustomTicksLabelsEpochs, fontsize = fontSizeXTickLabel)", "\n", "            ", "axis", ".", "yaxis", ".", "grid", "(", "True", ",", "linestyle", "=", "'--'", ",", "which", "=", "'major'", ",", "color", "=", "'black'", ",", "alpha", "=", "1.0", ")", "\n", "axis", ".", "tick_params", "(", "axis", "=", "'y'", ",", "labelsize", "=", "fontSizeYTickLabel", ")", "\n", "\n", "", "", "axes", "[", "0", ",", "0", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "0", ",", "1", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "0", ",", "2", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "0", ",", "3", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "0", ",", "4", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", "\n", "axes", "[", "1", ",", "0", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "1", ",", "1", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "1", ",", "2", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "1", ",", "3", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", ";", "axes", "[", "1", ",", "4", "]", ".", "set_ylim", "(", "0.", ",", "1.", ")", "\n", "\n", "axes", "[", "0", ",", "0", "]", ".", "set_ylabel", "(", "'Validation'", ",", "fontsize", "=", "fontSizeYAxisLabel", ")", "\n", "axes", "[", "1", ",", "0", "]", ".", "set_ylabel", "(", "'Training'", ",", "fontsize", "=", "fontSizeYAxisLabel", ")", "\n", "\n", "\"\"\"\n    Moving the legend-box:\n    - You grab a subplot. (depending on the axis that you ll use at: axis.legend(...))\n    - Then, you specify with loc=, the anchor of the LEGENDBOX that you will move in relation to the BOTTOM-LEFT corner of the above axis..\n        loc = 'upper right' (1), 'upper left' (2), 'lower left' (3), 'lower right' (4)\n    - bbox_to_anchor=(x-from-left, y-from-bottom, width, height). x and y can be negatives. Specify how much to move legend's loc from the bottom left corner of the axis.\n        x, y, width and height are floats, giving the percentage of the AXIS's size. Eg x=0.5, y=0.5 moves it at the middle of the subplot.\n    \"\"\"", "\n", "leg", "=", "axes", "[", "1", ",", "0", "]", ".", "legend", "(", "loc", "=", "'upper left'", ",", "bbox_to_anchor", "=", "(", "0.", ",", "-", ".25", ",", "0.", ",", "0.", ")", ",", "#(0., -1.3, 1., 1.),", "\n", "ncol", "=", "legendNumberOfColumns", ",", "borderaxespad", "=", "0.", ",", "fontsize", "=", "legendFontSize", ",", "labelspacing", "=", "0.", ",", "columnspacing", "=", "1.0", ")", "#mode=\"expand\",", "\n", "#Make the lines in the legend wider.", "\n", "for", "legobj", "in", "leg", ".", "legendHandles", ":", "\n", "        ", "legobj", ".", "set_linewidth", "(", "6.0", ")", "\n", "\n", "", "if", "saveFigureBool", ":", "\n", "        ", "plt", ".", "savefig", "(", "'./trainingProgress.pdf'", ",", "dpi", "=", "fig", ".", "dpi", ")", "#, bbox_inches='tight')", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.setup.read": [[8, 10], ["open().read", "open", "os.path.join", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.setup.read"], ["def", "read", "(", "fname", ")", ":", "\n", "    ", "return", "open", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "fname", ")", ")", ".", "read", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_num_fms_to_save": [[26, 40], ["range", "pathway.pType", "len", "pathway.get_blocks", "pathway.get_block().get_n_fms_out", "min", "pathway.get_block"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_out", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_block"], ["def", "calc_num_fms_to_save", "(", "cnn_pathways", ",", "fm_idxs", ")", ":", "\n", "    ", "fm_num", "=", "0", "\n", "for", "pathway", "in", "cnn_pathways", ":", "\n", "        ", "fm_idxs_pathway", "=", "fm_idxs", "[", "pathway", ".", "pType", "(", ")", "]", "\n", "if", "fm_idxs_pathway", ":", "\n", "            ", "for", "layer_i", "in", "range", "(", "len", "(", "pathway", ".", "get_blocks", "(", ")", ")", ")", ":", "\n", "                ", "fm_idxs_layer_pathway", "=", "fm_idxs_pathway", "[", "layer_i", "]", "\n", "if", "fm_idxs_layer_pathway", ":", "\n", "# If the user specifies to grab more feature maps than exist (eg 9999),", "\n", "# correct it, replacing it with the number of FMs in the layer.", "\n", "                    ", "fm_this_layer_num", "=", "pathway", ".", "get_block", "(", "layer_i", ")", ".", "get_n_fms_out", "(", ")", "\n", "fm_idxs_layer_pathway", "[", "1", "]", "=", "min", "(", "fm_idxs_layer_pathway", "[", "1", "]", ",", "fm_this_layer_num", ")", "\n", "fm_num", "+=", "fm_idxs_layer_pathway", "[", "1", "]", "-", "fm_idxs_layer_pathway", "[", "0", "]", "\n", "", "", "", "", "return", "fm_num", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.stitch_predicted_to_prob_maps": [[42, 61], ["range"], "function", ["None"], ["", "def", "stitch_predicted_to_prob_maps", "(", "prob_maps_per_class", ",", "idx_next_tile_in_pred_vols", ",", "\n", "prob_maps_batch", ",", "batch_size", ",", "slice_coords", ",", "unpred_margin", ",", "stride", ")", ":", "\n", "# prob_maps_per_class: The whole volume that is going to be the final output of the system.", "\n", "# prob_maps_batch: the predictions of the cnn for tiles/segments in a batch. Must be stitched together.", "\n", "\n", "    ", "for", "tile_i", "in", "range", "(", "batch_size", ")", ":", "\n", "# Now put the label-cube in the new-label-segmentation-image, at the correct position.", "\n", "# The very first label goes not in index 0,0,0 but half-patch further away!", "\n", "# At the position of the central voxel of the top-left patch!", "\n", "        ", "slice_coords_tile", "=", "slice_coords", "[", "idx_next_tile_in_pred_vols", "]", "\n", "top_left", "=", "[", "slice_coords_tile", "[", "0", "]", "[", "0", "]", ",", "slice_coords_tile", "[", "1", "]", "[", "0", "]", ",", "slice_coords_tile", "[", "2", "]", "[", "0", "]", "]", "\n", "prob_maps_per_class", "[", ":", ",", "\n", "top_left", "[", "0", "]", "+", "unpred_margin", "[", "0", "]", "[", "0", "]", ":", "top_left", "[", "0", "]", "+", "unpred_margin", "[", "0", "]", "[", "0", "]", "+", "stride", "[", "0", "]", ",", "\n", "top_left", "[", "1", "]", "+", "unpred_margin", "[", "1", "]", "[", "0", "]", ":", "top_left", "[", "1", "]", "+", "unpred_margin", "[", "1", "]", "[", "0", "]", "+", "stride", "[", "1", "]", ",", "\n", "top_left", "[", "2", "]", "+", "unpred_margin", "[", "2", "]", "[", "0", "]", ":", "top_left", "[", "2", "]", "+", "unpred_margin", "[", "2", "]", "[", "0", "]", "+", "stride", "[", "2", "]", "\n", "]", "=", "prob_maps_batch", "[", "tile_i", "]", "\n", "idx_next_tile_in_pred_vols", "+=", "1", "\n", "\n", "", "return", "idx_next_tile_in_pred_vols", ",", "prob_maps_per_class", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_num_voxels_sub": [[63, 70], ["numpy.zeros", "range", "int", "int", "pathway.pType", "math.ceil", "pathway.subs_factor"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor"], ["", "def", "calculate_num_voxels_sub", "(", "num_central_voxels", ",", "pathway", ")", ":", "\n", "    ", "num_voxels_sub", "=", "np", ".", "zeros", "(", "3", ")", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "num_voxels_sub", "[", "i", "]", "=", "num_central_voxels", "[", "i", "]", "-", "1", "if", "pathway", ".", "pType", "(", ")", "!=", "pt", ".", "SUBS", "else", "int", "(", "math", ".", "ceil", "(", "(", "num_central_voxels", "[", "i", "]", "*", "1.0", ")", "/", "pathway", ".", "subs_factor", "(", ")", "[", "i", "]", ")", "-", "1", ")", "\n", "\n", "", "return", "[", "int", "(", "a", ")", "for", "a", "in", "num_voxels_sub", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_num_central_voxels_dir": [[72, 82], ["numpy.zeros", "range", "int", "int", "int", "pathway.pType", "math.ceil", "pathway.subs_factor"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor"], ["", "def", "calculate_num_central_voxels_dir", "(", "num_central_voxels", ",", "pathway", ")", ":", "\n", "    ", "num_voxels_dir", "=", "np", ".", "zeros", "(", "3", ")", "\n", "# the math.ceil / subsamplingFactor is a trick to make it work for even subsamplingFactor too.", "\n", "# Eg 9/2=4.5 => Get 5. Combined with the trick at repeat,", "\n", "# I get my correct number of central voxels hopefully.", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "num_voxels_dir", "[", "i", "]", "=", "int", "(", "math", ".", "ceil", "(", "(", "num_central_voxels", "[", "i", "]", "*", "1.0", ")", "/", "pathway", ".", "subs_factor", "(", ")", "[", "i", "]", ")", ")", "if", "pathway", ".", "pType", "(", ")", "==", "pt", ".", "SUBS", "else", "int", "(", "num_central_voxels", "[", "i", "]", ")", "\n", "\n", "", "return", "[", "int", "(", "a", ")", "for", "a", "in", "num_voxels_dir", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.stitch_predicted_to_fms": [[84, 202], ["range", "len", "testing.calculate_num_voxels_sub", "int", "int", "int", "testing.calculate_num_central_voxels_dir", "range", "pathway.get_blocks", "pathway.pType", "numpy.repeat", "numpy.repeat", "numpy.repeat", "pathway.pType", "pathway.subs_factor", "pathway.subs_factor", "pathway.subs_factor", "pathway.pType", "pathway.pType"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_num_voxels_sub", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_num_central_voxels_dir", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType"], ["", "def", "stitch_predicted_to_fms", "(", "array_fms_to_save", ",", "idx_next_tile_in_fm_vols", ",", "\n", "fms_per_layer_and_path_for_batch", ",", "batch_size", ",", "slice_coords", ",", "unpred_margin", ",", "stride", ",", "\n", "outp_pred_dims", ",", "cnn_pathways", ",", "idxs_fms_to_save", ")", ":", "\n", "# array_fms_to_save: The whole feature maps that are going to be the final output of the system.", "\n", "# fms_per_layer_and_path_for_batch: FM activations in CNN for tiles/segments in a batch. Must be stitched.", "\n", "# idx_curr is the index in the multidimensional array that holds all the to-be-visualised-fms.", "\n", "# ... It is the one that corresponds to the next to-be-visualised layer_idx.", "\n", "    ", "idx_curr", "=", "0", "\n", "# layer_idx is the index over all the layers in the returned list.", "\n", "# ... I will work only with the ones specified to visualise.", "\n", "layer_idx", "=", "0", "\n", "\n", "for", "pathway", "in", "cnn_pathways", ":", "\n", "        ", "for", "layer_i", "in", "range", "(", "len", "(", "pathway", ".", "get_blocks", "(", ")", ")", ")", ":", "\n", "            ", "if", "idxs_fms_to_save", "[", "pathway", ".", "pType", "(", ")", "]", "==", "[", "]", "or", "idxs_fms_to_save", "[", "pathway", ".", "pType", "(", ")", "]", "[", "layer_i", "]", "==", "[", "]", ":", "\n", "                ", "continue", "\n", "", "fms_to_extract_idxs", "=", "idxs_fms_to_save", "[", "pathway", ".", "pType", "(", ")", "]", "[", "layer_i", "]", "\n", "fms_layer", "=", "fms_per_layer_and_path_for_batch", "[", "layer_idx", "]", "\n", "# We specify a range of fms to visualise from a layer.", "\n", "# curr_idx : fms_to_fill_high_idx defines were to put them in the multidimensional-image-array.", "\n", "fms_to_fill_high_idx", "=", "idx_curr", "+", "fms_to_extract_idxs", "[", "1", "]", "-", "fms_to_extract_idxs", "[", "0", "]", "\n", "\n", "fm_to_reconstruct", "=", "array_fms_to_save", "[", "idx_curr", ":", "fms_to_fill_high_idx", "]", "\n", "\n", "# ========================================================================================", "\n", "# ====the following calculations could be move OUTSIDE THE FOR LOOPS, by using the kernel-size", "\n", "# parameter (from the cnn instance) instead of the shape of the returned value.", "\n", "# ====fmsReturnedForATestBatchForCertainLayer.shape[2] - (outp_pred_dims[0]-1)", "\n", "# is essentially the width of the patch left after the convolutions.", "\n", "# ====These calculations are pathway and layer-specific. So they could be done once, prior to", "\n", "# image processing, and results cached in a list to be accessed during the loop.", "\n", "\n", "(", "num_voxels_sub_r", ",", "\n", "num_voxels_sub_c", ",", "\n", "num_voxels_sub_z", ")", "=", "calculate_num_voxels_sub", "(", "outp_pred_dims", ",", "pathway", ")", "\n", "\n", "r_patch_dim", "=", "fms_layer", ".", "shape", "[", "2", "]", "-", "num_voxels_sub_r", "\n", "c_patch_dim", "=", "fms_layer", ".", "shape", "[", "3", "]", "-", "num_voxels_sub_c", "\n", "z_patch_dim", "=", "fms_layer", ".", "shape", "[", "4", "]", "-", "num_voxels_sub_z", "\n", "\n", "# the -1 so that if width is even, I'll get the left voxel from the centre as 1st,", "\n", "# which I THINK is how I am getting the patches from the original image.", "\n", "r_top_left_central_voxel", "=", "int", "(", "(", "r_patch_dim", "-", "1", ")", "//", "2", ")", "\n", "c_top_left_central_voxel", "=", "int", "(", "(", "c_patch_dim", "-", "1", ")", "//", "2", ")", "\n", "z_top_left_central_voxel", "=", "int", "(", "(", "z_patch_dim", "-", "1", ")", "//", "2", ")", "\n", "\n", "(", "num_central_voxels_r", ",", "\n", "num_central_voxels_c", ",", "\n", "num_central_voxels_z", ")", "=", "calculate_num_central_voxels_dir", "(", "outp_pred_dims", ",", "pathway", ")", "\n", "\n", "# ============================================================================================", "\n", "\n", "# Grab the central voxels of the predicted fms from the cnn in this batch.", "\n", "central_voxels_all_fms", "=", "fms_layer", "[", ":", ",", "# batchsize", "\n", ":", ",", "# number of featuremaps", "\n", "r_top_left_central_voxel", ":", "r_top_left_central_voxel", "+", "num_central_voxels_r", ",", "\n", "c_top_left_central_voxel", ":", "c_top_left_central_voxel", "+", "num_central_voxels_c", ",", "\n", "z_top_left_central_voxel", ":", "z_top_left_central_voxel", "+", "num_central_voxels_z", "]", "\n", "\n", "# If the pathway that is visualised currently is the subsampled,", "\n", "# I need to upsample the central voxels to the normal resolution,", "\n", "# before reconstructing the image-fm.", "\n", "\n", "# subsampled layer. Remember that this returns smaller dimension outputs,", "\n", "# because it works in the subsampled space.", "\n", "# I need to repeat it, to bring it to the dimensions of the normal-voxel-space.", "\n", "if", "pathway", ".", "pType", "(", ")", "==", "pt", ".", "SUBS", ":", "\n", "                ", "expanded_output_r", "=", "np", ".", "repeat", "(", "central_voxels_all_fms", ",", "pathway", ".", "subs_factor", "(", ")", "[", "0", "]", ",", "axis", "=", "2", ")", "\n", "expanded_output_rc", "=", "np", ".", "repeat", "(", "expanded_output_r", ",", "pathway", ".", "subs_factor", "(", ")", "[", "1", "]", ",", "axis", "=", "3", ")", "\n", "expanded_output_rcz", "=", "np", ".", "repeat", "(", "expanded_output_rc", ",", "pathway", ".", "subs_factor", "(", ")", "[", "2", "]", ",", "axis", "=", "4", ")", "\n", "# The below is a trick to get correct number of voxels even when subsampling factor is", "\n", "# even or not exact divisor of the number of central voxels.", "\n", "# ...This trick is coupled with the ceil() when getting the", "\n", "# numberOfCentralVoxelsToGetInDirectionR above.", "\n", "central_voxels_all_fms_batch", "=", "expanded_output_rcz", "[", ":", ",", "\n", ":", ",", "\n", "0", ":", "outp_pred_dims", "[", "0", "]", ",", "\n", "0", ":", "outp_pred_dims", "[", "1", "]", ",", "\n", "0", ":", "outp_pred_dims", "[", "2", "]", "\n", "]", "\n", "", "else", ":", "\n", "                ", "central_voxels_all_fms_batch", "=", "central_voxels_all_fms", "\n", "\n", "# ----For every image part within this batch, reconstruct the corresponding part of the feature", "\n", "# maps of the layer we are currently visualising in this loop.", "\n", "", "for", "tile_batch_idx", "in", "range", "(", "batch_size", ")", ":", "\n", "# Now put the label-cube in the new-label-segmentation-image, at the correct position.", "\n", "# The very first label goes not in index 0,0,0 but half-patch further away! At the position", "\n", "# of the central voxel of the top-left patch!", "\n", "                ", "slice_coords_tile", "=", "slice_coords", "[", "idx_next_tile_in_fm_vols", "+", "tile_batch_idx", "]", "\n", "coords_top_left_voxel", "=", "[", "slice_coords_tile", "[", "0", "]", "[", "0", "]", ",", "\n", "slice_coords_tile", "[", "1", "]", "[", "0", "]", ",", "\n", "slice_coords_tile", "[", "2", "]", "[", "0", "]", "]", "\n", "\n", "# I put the central-predicted-voxels of all FMs to the corresponding,", "\n", "# newly created images all at once.", "\n", "fm_to_reconstruct", "[", ":", ",", "# last dimension is the number-of-Fms, I create an image for each.", "\n", "\n", "coords_top_left_voxel", "[", "0", "]", "+", "unpred_margin", "[", "0", "]", "[", "0", "]", ":", "\n", "coords_top_left_voxel", "[", "0", "]", "+", "unpred_margin", "[", "0", "]", "[", "0", "]", "+", "stride", "[", "0", "]", ",", "\n", "\n", "coords_top_left_voxel", "[", "1", "]", "+", "unpred_margin", "[", "1", "]", "[", "0", "]", ":", "\n", "coords_top_left_voxel", "[", "1", "]", "+", "unpred_margin", "[", "1", "]", "[", "0", "]", "+", "stride", "[", "1", "]", ",", "\n", "\n", "coords_top_left_voxel", "[", "2", "]", "+", "unpred_margin", "[", "2", "]", "[", "0", "]", ":", "\n", "coords_top_left_voxel", "[", "2", "]", "+", "unpred_margin", "[", "2", "]", "[", "0", "]", "+", "stride", "[", "2", "]", "\n", "\n", "]", "=", "central_voxels_all_fms_batch", "[", "tile_batch_idx", "]", "\n", "\n", "", "idx_curr", "=", "fms_to_fill_high_idx", "\n", "\n", "layer_idx", "+=", "1", "\n", "\n", "# all the image parts before this were reconstructed for all layers and feature maps.", "\n", "# Next batch-iteration should start from this", "\n", "", "", "idx_next_tile_in_fm_vols", "+=", "batch_size", "\n", "\n", "return", "idx_next_tile_in_fm_vols", ",", "array_fms_to_save", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.prepare_feeds_dict": [[204, 212], ["range", "numpy.asarray", "len", "feeds_dict.update", "numpy.asarray", "str"], "function", ["None"], ["", "def", "prepare_feeds_dict", "(", "feeds", ",", "channs_of_tiles_per_path", ")", ":", "\n", "# TODO: Can we rename the input feeds so that they are easier to deal with?", "\n", "    ", "feeds_dict", "=", "{", "feeds", "[", "'x'", "]", ":", "np", ".", "asarray", "(", "channs_of_tiles_per_path", "[", "0", "]", ",", "dtype", "=", "'float32'", ")", "}", "\n", "for", "path_i", "in", "range", "(", "len", "(", "channs_of_tiles_per_path", "[", "1", ":", "]", ")", ")", ":", "\n", "        ", "feeds_dict", ".", "update", "(", "\n", "{", "feeds", "[", "'x_sub_'", "+", "str", "(", "path_i", ")", "]", ":", "np", ".", "asarray", "(", "channs_of_tiles_per_path", "[", "1", "+", "path_i", "]", ",", "dtype", "=", "'float32'", ")", "}", ")", "\n", "\n", "", "return", "feeds_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.predict_whole_volume_by_tiling": [[214, 308], ["cnn3d.calc_outp_dims_given_inp", "list", "numpy.zeros", "deepmedic.dataManagement.sampling.get_slice_coords_of_all_img_tiles", "len", "log.print3", "log.print3", "deepmedic.logging.utils.print_progress_step_test", "range", "log.print3", "testing.calc_num_fms_to_save", "numpy.zeros", "deepmedic.dataManagement.sampling.extractSegmentsGivenSliceCoords", "time.time", "cnn3d.get_main_ops", "testing.prepare_feeds_dict", "sessionTf.run", "testing.stitch_predicted_to_prob_maps", "deepmedic.logging.utils.print_progress_step_test", "str", "cnn3d.get_main_feeds", "time.time", "testing.stitch_predicted_to_fms"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_slice_coords_of_all_img_tiles", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_test", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_num_fms_to_save", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.extractSegmentsGivenSliceCoords", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_ops", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.prepare_feeds_dict", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.stitch_predicted_to_prob_maps", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_test", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_feeds", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.stitch_predicted_to_fms"], ["", "def", "predict_whole_volume_by_tiling", "(", "log", ",", "sessionTf", ",", "cnn3d", ",", "\n", "channels", ",", "roi_mask", ",", "inp_shapes_per_path", ",", "unpred_margin", ",", "\n", "batchsize", ",", "save_fms_flag", ",", "idxs_fms_to_save", ")", ":", "\n", "# One of the main routines. Segment whole volume tile-by-tile.", "\n", "\n", "# For tiling the volume: Stride is how much I move in each dimension to get the next tile.", "\n", "# I stride exactly the number of voxels that are predicted per forward pass.", "\n", "    ", "outp_pred_dims", "=", "cnn3d", ".", "calc_outp_dims_given_inp", "(", "inp_shapes_per_path", "[", "0", "]", ")", "\n", "stride_of_tiling", "=", "outp_pred_dims", "# [str-x, str-y, str-z]", "\n", "# Find the total number of feature maps that will be created:", "\n", "# NOTE: save_fms_flag should contain an entry per pathwayType, even if just [].", "\n", "# If not [], the list should contain one entry per layer of the pathway, even if just [].", "\n", "# The layer entries, if not [], they should have to integers, lower and upper FM to visualise.", "\n", "n_fms_to_save", "=", "calc_num_fms_to_save", "(", "cnn3d", ".", "pathways", ",", "idxs_fms_to_save", ")", "if", "save_fms_flag", "else", "0", "\n", "\n", "# Arrays that will be returned.", "\n", "inp_chan_dims", "=", "list", "(", "channels", ".", "shape", "[", "1", ":", "]", ")", "# Dimensions of (padded) input channels.", "\n", "# The main output. Predicted probability-maps for the whole volume, one per class.", "\n", "# Will be constructed by stitching together the predictions from each tile.", "\n", "prob_maps_vols", "=", "np", ".", "zeros", "(", "[", "cnn3d", ".", "num_classes", "]", "+", "inp_chan_dims", ",", "dtype", "=", "\"float32\"", ")", "\n", "# create the big array that will hold all the fms (for feature extraction).", "\n", "array_fms_to_save", "=", "np", ".", "zeros", "(", "[", "n_fms_to_save", "]", "+", "inp_chan_dims", ",", "dtype", "=", "\"float32\"", ")", "if", "save_fms_flag", "else", "None", "\n", "\n", "# Tile the image and get all slices of the tiles that it fully breaks down to.", "\n", "slice_coords_all_tiles", "=", "get_slice_coords_of_all_img_tiles", "(", "log", ",", "\n", "inp_shapes_per_path", "[", "0", "]", ",", "\n", "stride_of_tiling", ",", "\n", "batchsize", ",", "\n", "inp_chan_dims", ",", "\n", "roi_mask", ")", "\n", "\n", "n_tiles_for_subj", "=", "len", "(", "slice_coords_all_tiles", ")", "\n", "log", ".", "print3", "(", "\"Ready to make predictions for all image segments (parts).\"", ")", "\n", "log", ".", "print3", "(", "\"Total number of Segments to process:\"", "+", "str", "(", "n_tiles_for_subj", ")", ")", "\n", "\n", "idx_next_tile_in_pred_vols", "=", "0", "\n", "idx_next_tile_in_fm_vols", "=", "0", "\n", "n_batches", "=", "n_tiles_for_subj", "//", "batchsize", "\n", "t_fwd_pass_subj", "=", "0", "# time it took for forward pass over all tiles of subject.", "\n", "print_progress_step_test", "(", "log", ",", "n_batches", ",", "0", ",", "batchsize", ",", "n_tiles_for_subj", ")", "\n", "for", "batch_i", "in", "range", "(", "n_batches", ")", ":", "\n", "\n", "# Extract data for the segments of this batch.", "\n", "# ( I could modularize extractDataOfASegmentFromImagesUsingSampledSliceCoords()", "\n", "# of training and use it here as well. )", "\n", "        ", "slice_coords_of_tiles_batch", "=", "slice_coords_all_tiles", "[", "batch_i", "*", "batchsize", ":", "(", "batch_i", "+", "1", ")", "*", "batchsize", "]", "\n", "channs_of_tiles_per_path", "=", "extractSegmentsGivenSliceCoords", "(", "cnn3d", ",", "\n", "slice_coords_of_tiles_batch", ",", "\n", "channels", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ")", "\n", "\n", "# ============================== Perform forward pass ====================================", "\n", "t_fwd_start", "=", "time", ".", "time", "(", ")", "\n", "ops_to_fetch", "=", "cnn3d", ".", "get_main_ops", "(", "'test'", ")", "\n", "list_of_ops", "=", "[", "ops_to_fetch", "[", "'pred_probs'", "]", "]", "+", "ops_to_fetch", "[", "'list_of_fms_per_layer'", "]", "\n", "feeds_dict", "=", "prepare_feeds_dict", "(", "cnn3d", ".", "get_main_feeds", "(", "'test'", ")", ",", "channs_of_tiles_per_path", ")", "\n", "# Forward pass", "\n", "out_val_of_ops", "=", "sessionTf", ".", "run", "(", "fetches", "=", "list_of_ops", ",", "feed_dict", "=", "feeds_dict", ")", "\n", "prob_maps_batch", "=", "out_val_of_ops", "[", "0", "]", "\n", "fms_per_layer_and_path_for_batch", "=", "out_val_of_ops", "[", "1", ":", "]", "# [] if no FMs specified.", "\n", "t_fwd_pass_subj", "+=", "time", ".", "time", "(", ")", "-", "t_fwd_start", "\n", "\n", "# ================ Construct probability maps (volumes) by Stitching  ====================", "\n", "# Stitch predictions for tiles of this batch, to create the probability maps for whole volume.", "\n", "# Each prediction for a tile needs to be placed in the correct location in the volume.", "\n", "(", "idx_next_tile_in_pred_vols", ",", "\n", "prob_maps_vols", ")", "=", "stitch_predicted_to_prob_maps", "(", "prob_maps_vols", ",", "\n", "idx_next_tile_in_pred_vols", ",", "\n", "prob_maps_batch", ",", "\n", "batchsize", ",", "\n", "slice_coords_all_tiles", ",", "\n", "unpred_margin", ",", "\n", "stride_of_tiling", ")", "\n", "\n", "# ============== Construct feature maps (volumes) by Stitching =====================", "\n", "if", "save_fms_flag", ":", "\n", "            ", "(", "idx_next_tile_in_fm_vols", ",", "\n", "array_fms_to_save", ")", "=", "stitch_predicted_to_fms", "(", "array_fms_to_save", ",", "\n", "idx_next_tile_in_fm_vols", ",", "\n", "fms_per_layer_and_path_for_batch", ",", "\n", "batchsize", ",", "\n", "slice_coords_all_tiles", ",", "\n", "unpred_margin", ",", "\n", "stride_of_tiling", ",", "\n", "outp_pred_dims", ",", "\n", "cnn3d", ".", "pathways", ",", "\n", "idxs_fms_to_save", ")", "\n", "", "print_progress_step_test", "(", "log", ",", "n_batches", ",", "batch_i", "+", "1", ",", "batchsize", ",", "n_tiles_for_subj", ")", "\n", "# Done with batch", "\n", "\n", "", "log", ".", "print3", "(", "\"TIMING: Segmentation of subject: [Forward Pass:] {0:.2f}\"", ".", "format", "(", "t_fwd_pass_subj", ")", "+", "\" secs.\"", ")", "\n", "\n", "return", "prob_maps_vols", ",", "array_fms_to_save", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_img": [[310, 318], ["deepmedic.dataManagement.preprocessing.unpad_3d_img"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.unpad_3d_img"], ["", "def", "unpad_img", "(", "img", ",", "unpad_input", ",", "pad_left_right_per_axis", ")", ":", "\n", "# unpad_input: If True, pad_left_right_per_axis == ((0,0), (0,0), (0,0)).", "\n", "#              unpad_3d_img deals with no padding. So, this check is not required.", "\n", "    ", "if", "not", "unpad_input", ":", "\n", "        ", "return", "img", "\n", "", "if", "img", "is", "None", ":", "# Deals with the case something has not been given. E.g. roi_mask or gt_lbls.", "\n", "        ", "return", "None", "\n", "", "return", "unpad_3d_img", "(", "img", ",", "pad_left_right_per_axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_list_of_imgs": [[320, 328], ["list_unpadded_imgs.append", "testing.unpad_img"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_img"], ["", "def", "unpad_list_of_imgs", "(", "list_imgs", ",", "unpad_input", ",", "pad_left_right_per_axis", ")", ":", "\n", "    ", "if", "not", "unpad_input", "or", "list_imgs", "is", "None", ":", "\n", "        ", "return", "list_imgs", "\n", "\n", "", "list_unpadded_imgs", "=", "[", "]", "\n", "for", "img", "in", "list_imgs", ":", "\n", "        ", "list_unpadded_imgs", ".", "append", "(", "unpad_img", "(", "img", ",", "unpad_input", ",", "pad_left_right_per_axis", ")", ")", "# Deals with None.", "\n", "", "return", "list_unpadded_imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_pred_seg": [[330, 341], ["deepmedic.dataManagement.io.savePredImgToNiiWithOriginalHdr", "numpy.dtype"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.savePredImgToNiiWithOriginalHdr"], ["", "def", "save_pred_seg", "(", "pred_seg", ",", "save_pred_seg_bool", ",", "suffix_seg", ",", "seg_names", ",", "filepaths", ",", "subj_i", ",", "log", ")", ":", "\n", "# filepaths: list of all filepaths to each channel image of each subject. To get header.", "\n", "# Save the image. Pass the filename paths of the normal image to duplicate the header info.", "\n", "    ", "if", "save_pred_seg_bool", ":", "\n", "        ", "savePredImgToNiiWithOriginalHdr", "(", "pred_seg", ",", "\n", "seg_names", ",", "\n", "filepaths", ",", "\n", "subj_i", ",", "\n", "suffix_seg", ",", "\n", "np", ".", "dtype", "(", "np", ".", "int16", ")", ",", "\n", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_prob_maps": [[343, 357], ["range", "len", "deepmedic.dataManagement.io.savePredImgToNiiWithOriginalHdr", "len", "str", "numpy.dtype"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.savePredImgToNiiWithOriginalHdr"], ["", "", "def", "save_prob_maps", "(", "prob_maps", ",", "save_prob_maps_bool", ",", "suffix_prob_map", ",", "prob_names", ",", "filepaths", ",", "subj_i", ",", "log", ")", ":", "\n", "# filepaths: list of all filepaths to each channel img of each subject. To get header.", "\n", "# Save the image. Pass the filename paths of the normal image to duplicate the header info.", "\n", "    ", "for", "class_i", "in", "range", "(", "len", "(", "prob_maps", ")", ")", ":", "\n", "        ", "if", "(", "len", "(", "save_prob_maps_bool", ")", ">=", "class_i", "+", "1", ")", "and", "save_prob_maps_bool", "[", "class_i", "]", ":", "\n", "            ", "suffix", "=", "suffix_prob_map", "+", "str", "(", "class_i", ")", "\n", "prob_map", "=", "prob_maps", "[", "class_i", "]", "\n", "savePredImgToNiiWithOriginalHdr", "(", "prob_map", ",", "\n", "prob_names", ",", "\n", "filepaths", ",", "\n", "subj_i", ",", "\n", "suffix", ",", "\n", "np", ".", "dtype", "(", "np", ".", "float32", ")", ",", "\n", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_fms_individual": [[359, 383], ["range", "len", "range", "pathway.pType", "len", "pathway.get_blocks", "range", "deepmedic.dataManagement.io.saveFmImgToNiiWithOriginalHdr"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveFmImgToNiiWithOriginalHdr"], ["", "", "", "def", "save_fms_individual", "(", "save_flag", ",", "multidim_fm_array", ",", "cnn_pathways", ",", "fm_idxs", ",", "fms_names", ",", "filepaths", ",", "subj_i", ",", "log", ")", ":", "\n", "    ", "if", "not", "save_flag", ":", "\n", "        ", "return", "\n", "\n", "", "idx_curr", "=", "0", "\n", "for", "pathway_i", "in", "range", "(", "len", "(", "cnn_pathways", ")", ")", ":", "\n", "        ", "pathway", "=", "cnn_pathways", "[", "pathway_i", "]", "\n", "fms_idx_pathway", "=", "fm_idxs", "[", "pathway", ".", "pType", "(", ")", "]", "\n", "if", "fms_idx_pathway", ":", "\n", "            ", "for", "layer_i", "in", "range", "(", "len", "(", "pathway", ".", "get_blocks", "(", ")", ")", ")", ":", "\n", "                ", "fms_idx_layer_pathway", "=", "fms_idx_pathway", "[", "layer_i", "]", "\n", "if", "fms_idx_layer_pathway", ":", "\n", "                    ", "for", "fmActualNumber", "in", "range", "(", "fms_idx_layer_pathway", "[", "0", "]", ",", "fms_idx_layer_pathway", "[", "1", "]", ")", ":", "\n", "                        ", "fm_to_save", "=", "multidim_fm_array", "[", "idx_curr", "]", "\n", "\n", "saveFmImgToNiiWithOriginalHdr", "(", "fm_to_save", ",", "\n", "fms_names", ",", "\n", "filepaths", ",", "\n", "subj_i", ",", "\n", "pathway_i", ",", "\n", "layer_i", ",", "\n", "fmActualNumber", ",", "\n", "log", ")", "\n", "idx_curr", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_dice": [[385, 391], ["numpy.sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "", "", "", "", "", "def", "calculate_dice", "(", "pred_seg", ",", "gt_lbl", ")", ":", "\n", "    ", "union_correct", "=", "pred_seg", "*", "gt_lbl", "\n", "tp_num", "=", "np", ".", "sum", "(", "union_correct", ")", "\n", "gt_pos_num", "=", "np", ".", "sum", "(", "gt_lbl", ")", "\n", "dice", "=", "(", "2.0", "*", "tp_num", ")", "/", "(", "np", ".", "sum", "(", "pred_seg", ")", "+", "gt_pos_num", ")", "if", "gt_pos_num", "!=", "0", "else", "-", "1", "\n", "return", "dice", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_metrics_for_subject": [[393, 427], ["range", "testing.calculate_dice", "testing.calculate_dice", "testing.calculate_dice", "numpy.rint", "numpy.rint", "numpy.rint", "numpy.rint"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_dice", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_dice", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calculate_dice"], ["", "def", "calc_metrics_for_subject", "(", "metrics_per_subj_per_c", ",", "subj_i", ",", "pred_seg", ",", "pred_seg_in_roi", ",", "\n", "gt_lbl", ",", "gt_lbl_in_roi", ",", "n_classes", ",", "na_pattern", ")", ":", "\n", "# Calculate DSC per class.", "\n", "    ", "for", "c", "in", "range", "(", "n_classes", ")", ":", "\n", "        ", "if", "c", "==", "0", ":", "# do the eval for WHOLE FOREGROUND segmentation (all classes merged except background)", "\n", "# Merge every class except the background (assumed to be label == 0 )", "\n", "            ", "pred_seg_bin_c", "=", "pred_seg", ">", "0", "# Now it's binary", "\n", "pred_seg_bin_c_in_roi", "=", "pred_seg_in_roi", ">", "0", "\n", "gt_lbl_bin_c", "=", "gt_lbl", ">", "0", "\n", "gt_lbl_bin_c_in_roi", "=", "gt_lbl_in_roi", ">", "0", "\n", "", "else", ":", "\n", "            ", "pred_seg_bin_c", "=", "np", ".", "rint", "(", "pred_seg", ")", "==", "c", "# randint for valid comparison, in case array is float)", "\n", "pred_seg_bin_c_in_roi", "=", "np", ".", "rint", "(", "pred_seg_in_roi", ")", "==", "c", "\n", "gt_lbl_bin_c", "=", "np", ".", "rint", "(", "gt_lbl", ")", "==", "c", "\n", "gt_lbl_bin_c_in_roi", "=", "np", ".", "rint", "(", "gt_lbl_in_roi", ")", "==", "c", "\n", "\n", "# Calculate the 3 Dices.", "\n", "# Dice1 = Allpredicted/allLesions,", "\n", "# Dice2 = PredictedWithinRoiMask / AllLesions ,", "\n", "# Dice3 = PredictedWithinRoiMask / LesionsInsideRoiMask.", "\n", "\n", "# Dice1 = Allpredicted/allLesions", "\n", "", "dice_1", "=", "calculate_dice", "(", "pred_seg_bin_c", ",", "gt_lbl_bin_c", ")", "\n", "metrics_per_subj_per_c", "[", "'dice1'", "]", "[", "subj_i", "]", "[", "c", "]", "=", "dice_1", "if", "dice_1", "!=", "-", "1", "else", "na_pattern", "\n", "\n", "# Dice2 = PredictedWithinRoiMask / AllLesions", "\n", "dice_2", "=", "calculate_dice", "(", "pred_seg_bin_c_in_roi", ",", "gt_lbl_bin_c", ")", "\n", "metrics_per_subj_per_c", "[", "'dice2'", "]", "[", "subj_i", "]", "[", "c", "]", "=", "dice_2", "if", "dice_2", "!=", "-", "1", "else", "na_pattern", "\n", "\n", "# Dice3 = PredictedWithinRoiMask / LesionsInsideRoiMask", "\n", "dice_3", "=", "calculate_dice", "(", "pred_seg_bin_c_in_roi", ",", "gt_lbl_bin_c_in_roi", ")", "\n", "metrics_per_subj_per_c", "[", "'dice3'", "]", "[", "subj_i", "]", "[", "c", "]", "=", "dice_3", "if", "dice_3", "!=", "-", "1", "else", "na_pattern", "\n", "\n", "", "return", "metrics_per_subj_per_c", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.report_metrics_for_subject": [[429, 437], ["log.print3", "log.print3", "testing.print_dice_explanations", "deepmedic.logging.utils.strListFl4fNA", "str", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.print_dice_explanations", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA"], ["", "def", "report_metrics_for_subject", "(", "log", ",", "metrics_per_subj_per_c", ",", "subj_i", ",", "na_pattern", ",", "val_test_print", ")", ":", "\n", "    ", "log", ".", "print3", "(", "\"+++++++++++ Reporting Segmentation Metrics for Subject #\"", "+", "str", "(", "subj_i", ")", "+", "\" +++++++++++\"", ")", "\n", "log", ".", "print3", "(", "\"ACCURACY: (\"", "+", "str", "(", "val_test_print", ")", "+", "\")\"", "+", "\n", "\" The Per-Class DICE Coefficients for subject with index #\"", "+", "str", "(", "subj_i", ")", "+", "\" equal:\"", "+", "\n", "\" DICE1=\"", "+", "strListFl4fNA", "(", "metrics_per_subj_per_c", "[", "'dice1'", "]", "[", "subj_i", "]", ",", "na_pattern", ")", "+", "\n", "\" DICE2=\"", "+", "strListFl4fNA", "(", "metrics_per_subj_per_c", "[", "'dice2'", "]", "[", "subj_i", "]", ",", "na_pattern", ")", "+", "\n", "\" DICE3=\"", "+", "strListFl4fNA", "(", "metrics_per_subj_per_c", "[", "'dice3'", "]", "[", "subj_i", "]", ",", "na_pattern", ")", ")", "\n", "print_dice_explanations", "(", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.print_dice_explanations": [[439, 447], ["log.print3", "log.print3", "log.print3"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "print_dice_explanations", "(", "log", ")", ":", "\n", "    ", "log", ".", "print3", "(", "\"EXPLANATION: DICE1/2/3 are lists with the DICE per class.\"", "\n", "\"\\n\\t For Class-0, we calculate DICE for whole foreground: all labels merged except background, label=0.\"", "\n", "\"\\n\\t Useful for multi-class problems.\"", ")", "\n", "log", ".", "print3", "(", "\"EXPLANATION: DICE1 is calculated as segmentation over whole volume VS whole Ground Truth (GT).\"", "\n", "\"\\n\\t DICE2 is the segmentation within the ROI vs GT.\"", "\n", "\"\\n\\t DICE3 is segmentation within the ROI vs the GT within the ROI.\"", ")", "\n", "log", ".", "print3", "(", "\"EXPLANATION: If an ROI mask has been provided, you should be consulting DICE2 or DICE3.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_stats_of_metrics": [[449, 457], ["metrics_per_subj_per_c.keys", "deepmedic.logging.utils.getMeanPerColOf2dListExclNA"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanPerColOf2dListExclNA"], ["", "def", "calc_stats_of_metrics", "(", "metrics_per_subj_per_c", ",", "na_pattern", ")", ":", "\n", "# mean_metrics: a dictionary. Key is the name of the metric. ", "\n", "#               Value is a list [list_subj_1, ..., list_subj_s]", "\n", "#               each list_subj_i is a list with the dice for each class, [dsc_class_1, ..., dsc_class_c]", "\n", "    ", "mean_metrics", "=", "{", "}", "\n", "for", "k", "in", "metrics_per_subj_per_c", ".", "keys", "(", ")", ":", "\n", "        ", "mean_metrics", "[", "k", "]", "=", "getMeanPerColOf2dListExclNA", "(", "metrics_per_subj_per_c", "[", "k", "]", ",", "na_pattern", ")", "\n", "", "return", "mean_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.report_mean_metrics": [[459, 476], ["log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "testing.print_dice_explanations", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.print_dice_explanations", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA"], ["", "def", "report_mean_metrics", "(", "log", ",", "mean_metrics", ",", "na_pattern", ",", "val_test_print", ")", ":", "\n", "# dices_1/2/3: A list with NUMBER_OF_SUBJECTS sublists.", "\n", "#              Each sublist has one dice-score per class.", "\n", "    ", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\"", ")", "\n", "log", ".", "print3", "(", "\"++++++++++++++++++++++++ Segmentation of all subjects finished ++++++++++++++++++++++++++++\"", ")", "\n", "log", ".", "print3", "(", "\"++++++++++++++ Reporting Average Segmentation Metrics over all subjects +++++++++++++++++++\"", ")", "\n", "\n", "log", ".", "print3", "(", "\"ACCURACY: (\"", "+", "str", "(", "val_test_print", ")", "+", "\")\"", "+", "\n", "\" The Per-Class average DICE Coefficients over all subjects are:\"", "+", "\n", "\" DICE1=\"", "+", "strListFl4fNA", "(", "mean_metrics", "[", "'dice1'", "]", ",", "na_pattern", ")", "+", "\n", "\" DICE2=\"", "+", "strListFl4fNA", "(", "mean_metrics", "[", "'dice2'", "]", ",", "na_pattern", ")", "+", "\n", "\" DICE3=\"", "+", "strListFl4fNA", "(", "mean_metrics", "[", "'dice3'", "]", ",", "na_pattern", ")", ")", "\n", "\n", "print_dice_explanations", "(", "log", ")", "\n", "\n", "return", "mean_metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.inference_on_whole_volumes": [[479, 620], ["log.print3", "log.print3", "log.print3", "log.print3", "time.time", "len", "cnn3d.calc_unpredicted_margin", "range", "log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "deepmedic.dataManagement.sampling.load_imgs_of_subject", "deepmedic.dataManagement.sampling.preproc_imgs_of_subj", "testing.predict_whole_volume_by_tiling", "numpy.argmax", "testing.unpad_img", "testing.unpad_img", "testing.unpad_img", "testing.unpad_list_of_imgs", "testing.unpad_list_of_imgs", "range", "testing.save_pred_seg", "testing.save_prob_maps", "testing.save_fms_individual", "testing.calc_stats_of_metrics", "testing.report_mean_metrics", "testing.calc_metrics_for_subject", "testing.report_metrics_for_subject", "str", "range", "range", "range", "str", "str", "time.time"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_unpredicted_margin", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.load_imgs_of_subject", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.preproc_imgs_of_subj", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.predict_whole_volume_by_tiling", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_list_of_imgs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.unpad_list_of_imgs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_pred_seg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_prob_maps", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.save_fms_individual", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_stats_of_metrics", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.report_mean_metrics", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.calc_metrics_for_subject", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.report_metrics_for_subject"], ["", "def", "inference_on_whole_volumes", "(", "sessionTf", ",", "\n", "cnn3d", ",", "\n", "log", ",", "\n", "val_or_test", ",", "\n", "savePredictedSegmAndProbsDict", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_masks_per_subj", ",", "\n", "namesForSavingSegmAndProbs", ",", "\n", "suffixForSegmAndProbsDict", ",", "\n", "# Hyper parameters", "\n", "batchsize", ",", "\n", "# Data compatibility checks", "\n", "run_input_checks", ",", "\n", "# Pre-Processing", "\n", "pad_input", ",", "\n", "norm_prms", ",", "\n", "# Saving feature maps", "\n", "save_fms_flag", ",", "\n", "idxs_fms_to_save", ",", "\n", "namesForSavingFms", ",", "\n", "# Sampling", "\n", "inp_shapes_per_path", ")", ":", "\n", "# save_fms_flag: should contain an entry per pathwayType, even if just []...", "\n", "#       ... If not [], the list should contain one entry per layer of the pathway, even if just [].", "\n", "#       ... The layer entries, if not [], they should have to integers, lower and upper FM to visualise.", "\n", "#       ... Excluding the highest index.", "\n", "\n", "    ", "val_test_print", "=", "\"Validation\"", "if", "val_or_test", "==", "\"val\"", "else", "\"Testing\"", "\n", "\n", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"##########################################################################################\"", ")", "\n", "log", ".", "print3", "(", "\"#\\t\\t  Starting full Segmentation of \"", "+", "str", "(", "val_test_print", ")", "+", "\" subjects   \\t\\t\\t#\"", ")", "\n", "log", ".", "print3", "(", "\"##########################################################################################\"", ")", "\n", "\n", "t_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "NA_PATTERN", "=", "AccuracyMonitorForEpSegm", ".", "NA_PATTERN", "\n", "n_classes", "=", "cnn3d", ".", "num_classes", "\n", "n_subjects", "=", "len", "(", "paths_per_chan_per_subj", ")", "\n", "unpred_margin", "=", "cnn3d", ".", "calc_unpredicted_margin", "(", "inp_shapes_per_path", "[", "0", "]", ")", "\n", "# One dice score for whole foreground (0) AND one for each actual class", "\n", "# Dice1 - AllpredictedLes/AllLesions", "\n", "# Dice2 - predictedInsideRoiMask/AllLesions", "\n", "# Dice3 - predictedInsideRoiMask/ LesionsInsideRoiMask (for comparisons)", "\n", "# Each is a list of dimensions: n_subjects X n_classes", "\n", "# initialization of the lists (values will be replaced)", "\n", "metrics_per_subj_per_c", "=", "{", "\"dice1\"", ":", "[", "[", "-", "1", "]", "*", "n_classes", "for", "_", "in", "range", "(", "n_subjects", ")", "]", ",", "\n", "\"dice2\"", ":", "[", "[", "-", "1", "]", "*", "n_classes", "for", "_", "in", "range", "(", "n_subjects", ")", "]", ",", "\n", "\"dice3\"", ":", "[", "[", "-", "1", "]", "*", "n_classes", "for", "_", "in", "range", "(", "n_subjects", ")", "]", "}", "\n", "\n", "for", "subj_i", "in", "range", "(", "n_subjects", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~\\t Segmenting subject with index #\"", "+", "str", "(", "subj_i", ")", "+", "\" \\t~~~~~~~~\"", ")", "\n", "\n", "(", "channels", ",", "# nparray [channels,dim0,dim1,dim2]", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "_", ")", "=", "load_imgs_of_subject", "(", "log", ",", "\"\"", ",", "\n", "subj_i", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "None", ",", "# weightmaps, not for test", "\n", "paths_to_masks_per_subj", ")", "\n", "(", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "_", ",", "\n", "pad_left_right_per_axis", ")", "=", "preproc_imgs_of_subj", "(", "log", ",", "\"\"", ",", "\n", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "None", ",", "\n", "run_input_checks", ",", "n_classes", ",", "# checks", "\n", "pad_input", ",", "unpred_margin", ",", "\n", "norm_prms", ")", "\n", "\n", "# ============== Augmentation ==================", "\n", "# TODO: Add augmentation here. And aggregate results after prediction of the whole volumes", "\n", "\n", "# ============== Predict whole volume ==================", "\n", "# array_fms_to_save will be None if not saving them.", "\n", "(", "prob_maps_vols", ",", "\n", "array_fms_to_save", ")", "=", "predict_whole_volume_by_tiling", "(", "log", ",", "sessionTf", ",", "cnn3d", ",", "\n", "channels", ",", "roi_mask", ",", "inp_shapes_per_path", ",", "unpred_margin", ",", "\n", "batchsize", ",", "save_fms_flag", ",", "idxs_fms_to_save", ")", "\n", "\n", "# ========================== Post-Processing =========================", "\n", "pred_seg", "=", "np", ".", "argmax", "(", "prob_maps_vols", ",", "axis", "=", "0", ")", "# The segmentation.", "\n", "\n", "# Unpad all images.        ", "\n", "pred_seg_u", "=", "unpad_img", "(", "pred_seg", ",", "pad_input", ",", "pad_left_right_per_axis", ")", "\n", "gt_lbl_u", "=", "unpad_img", "(", "gt_lbl_img", ",", "pad_input", ",", "pad_left_right_per_axis", ")", "\n", "roi_mask_u", "=", "unpad_img", "(", "roi_mask", ",", "pad_input", ",", "pad_left_right_per_axis", ")", "\n", "prob_maps_vols_u", "=", "unpad_list_of_imgs", "(", "prob_maps_vols", ",", "pad_input", ",", "pad_left_right_per_axis", ")", "\n", "array_fms_to_save_u", "=", "unpad_list_of_imgs", "(", "array_fms_to_save", ",", "pad_input", ",", "pad_left_right_per_axis", ")", "\n", "\n", "# Poster-process outside the ROI, e.g. by deleting any predictions outside it.", "\n", "pred_seg_u_in_roi", "=", "pred_seg_u", "if", "roi_mask_u", "is", "None", "else", "pred_seg_u", "*", "roi_mask_u", "\n", "gt_lbl_u_in_roi", "=", "gt_lbl_u", "if", "(", "gt_lbl_u", "is", "None", "or", "roi_mask_u", "is", "None", ")", "else", "gt_lbl_u", "*", "roi_mask_u", "\n", "for", "c", "in", "range", "(", "n_classes", ")", ":", "\n", "            ", "prob_map", "=", "prob_maps_vols_u", "[", "c", "]", "\n", "prob_maps_vols_u", "[", "c", "]", "=", "prob_map", "if", "roi_mask_u", "is", "None", "else", "prob_map", "*", "roi_mask_u", "\n", "", "prob_maps_vols_u_in_roi", "=", "prob_maps_vols_u", "# Just to follow naming convention for clarity.", "\n", "\n", "# ======================= Save Output Volumes ========================", "\n", "# Save predicted segmentations", "\n", "save_pred_seg", "(", "pred_seg_u_in_roi", ",", "\n", "savePredictedSegmAndProbsDict", "[", "\"segm\"", "]", ",", "suffixForSegmAndProbsDict", "[", "\"segm\"", "]", ",", "\n", "namesForSavingSegmAndProbs", ",", "paths_per_chan_per_subj", ",", "subj_i", ",", "log", ")", "\n", "\n", "# Save probability maps", "\n", "save_prob_maps", "(", "prob_maps_vols_u_in_roi", ",", "\n", "savePredictedSegmAndProbsDict", "[", "\"prob\"", "]", ",", "suffixForSegmAndProbsDict", "[", "\"prob\"", "]", ",", "\n", "namesForSavingSegmAndProbs", ",", "paths_per_chan_per_subj", ",", "subj_i", ",", "log", ")", "\n", "\n", "# Save feature maps", "\n", "save_fms_individual", "(", "save_fms_flag", ",", "array_fms_to_save_u", ",", "cnn3d", ".", "pathways", ",", "idxs_fms_to_save", ",", "\n", "namesForSavingFms", ",", "paths_per_chan_per_subj", ",", "subj_i", ",", "log", ")", "\n", "\n", "\n", "# ================= Evaluate DSC for this subject ========================", "\n", "if", "paths_to_lbls_per_subj", "is", "not", "None", ":", "# GT was provided.", "\n", "            ", "metrics_per_subj_per_c", "=", "calc_metrics_for_subject", "(", "metrics_per_subj_per_c", ",", "subj_i", ",", "\n", "pred_seg_u", ",", "pred_seg_u_in_roi", ",", "\n", "gt_lbl_u", ",", "gt_lbl_u_in_roi", ",", "\n", "n_classes", ",", "NA_PATTERN", ")", "\n", "report_metrics_for_subject", "(", "log", ",", "metrics_per_subj_per_c", ",", "subj_i", ",", "NA_PATTERN", ",", "val_test_print", ")", "\n", "\n", "# Done with subject.", "\n", "\n", "# ==================== Report average Dice Coefficient over all subjects ==================", "\n", "", "", "mean_metrics", "=", "None", "# To return something even if ground truth has not been given (in testing)", "\n", "if", "paths_to_lbls_per_subj", "is", "not", "None", "and", "n_subjects", ">", "0", ":", "# GT was given. Calculate.", "\n", "        ", "mean_metrics", "=", "calc_stats_of_metrics", "(", "metrics_per_subj_per_c", ",", "NA_PATTERN", ")", "\n", "report_mean_metrics", "(", "log", ",", "mean_metrics", ",", "NA_PATTERN", ",", "val_test_print", ")", "\n", "\n", "", "log", ".", "print3", "(", "\"TIMING: \"", "+", "val_test_print", "+", "\" process lasted: {0:.2f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "t_start", ")", "+", "\" secs.\"", ")", "\n", "log", ".", "print3", "(", "\"##########################################################################################\"", ")", "\n", "log", ".", "print3", "(", "\"#\\t\\t  Finished full Segmentation of \"", "+", "str", "(", "val_test_print", ")", "+", "\" subjects   \\t\\t\\t#\"", ")", "\n", "log", ".", "print3", "(", "\"##########################################################################################\"", ")", "\n", "\n", "return", "mean_metrics", "\n", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.training.process_in_batches": [[26, 106], ["numpy.zeros", "deepmedic.logging.utils.print_progress_step_tr_val", "range", "acc_monitor_ep.update_metrics_after_subep", "acc_monitor_ep.log_acc_subep_to_txt", "acc_monitor_ep.log_acc_subep_to_tensorboard", "numpy.asarray", "arr_RpRnTpTn_per_class.reshape.reshape", "costs_of_batches.append", "deepmedic.logging.utils.print_progress_step_tr_val", "numpy.mean", "cnn3d.get_main_ops", "cnn3d.get_main_feeds", "range", "feeds_dict.update", "sessionTf.run", "cnn3d.update_arrays_of_bn_moving_avg", "cnn3d.get_main_ops", "cnn3d.get_main_feeds", "range", "feeds_dict.update", "sessionTf.run", "feeds_dict.update", "feeds_dict.update", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_tr_val", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.update_metrics_after_subep", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_acc_subep_to_txt", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_acc_subep_to_tensorboard", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_tr_val", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_ops", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_feeds", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.update_arrays_of_bn_moving_avg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_ops", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_feeds"], ["def", "process_in_batches", "(", "log", ",", "\n", "sessionTf", ",", "\n", "train_or_val", ",", "\n", "n_batches", ",", "\n", "batchsize", ",", "\n", "cnn3d", ",", "\n", "acc_monitor_ep", ",", "\n", "channs_samples_per_path", ",", "\n", "lbls_samples_per_path", ")", ":", "\n", "# Processes batches of subepoch. Performs training or validation. Collects performance metrics.", "\n", "\n", "    ", "costs_of_batches", "=", "[", "]", "\n", "# Each row of array below holds number of:", "\n", "#     Real Positives, Real Neg, True Predicted Pos, True Predicted Neg in subepoch, in this order.", "\n", "arr_RpRnTpTn_per_class_in_subep", "=", "np", ".", "zeros", "(", "[", "cnn3d", ".", "num_classes", ",", "4", "]", ",", "dtype", "=", "\"int32\"", ")", "\n", "\n", "prefix_progress_str", "=", "'[TRAINING]'", "if", "train_or_val", "==", "'train'", "else", "'[VALIDATION]'", "\n", "print_progress_step_tr_val", "(", "log", ",", "n_batches", ",", "0", ",", "batchsize", ",", "prefix_progress_str", ")", "\n", "for", "batch_i", "in", "range", "(", "n_batches", ")", ":", "\n", "\n", "        ", "if", "train_or_val", "==", "\"train\"", ":", "\n", "            ", "ops_to_fetch", "=", "cnn3d", ".", "get_main_ops", "(", "'train'", ")", "\n", "list_of_ops", "=", "[", "ops_to_fetch", "[", "'cost'", "]", "]", "+", "ops_to_fetch", "[", "'list_rp_rn_tp_tn'", "]", "+", "[", "ops_to_fetch", "[", "'updates_grouped_op'", "]", "]", "\n", "\n", "min_idx_batch", "=", "batch_i", "*", "batchsize", "\n", "max_idx_batch", "=", "(", "batch_i", "+", "1", ")", "*", "batchsize", "\n", "\n", "feeds", "=", "cnn3d", ".", "get_main_feeds", "(", "'train'", ")", "\n", "feeds_dict", "=", "{", "feeds", "[", "'x'", "]", ":", "channs_samples_per_path", "[", "0", "]", "[", "min_idx_batch", ":", "max_idx_batch", "]", "}", "\n", "for", "subs_path_i", "in", "range", "(", "cnn3d", ".", "numSubsPaths", ")", ":", "\n", "                ", "x_batch_sub_path", "=", "channs_samples_per_path", "[", "subs_path_i", "+", "1", "]", "[", "min_idx_batch", ":", "max_idx_batch", "]", "\n", "feeds_dict", ".", "update", "(", "{", "feeds", "[", "'x_sub_'", "+", "str", "(", "subs_path_i", ")", "]", ":", "x_batch_sub_path", "}", ")", "\n", "", "feeds_dict", ".", "update", "(", "{", "feeds", "[", "'y_gt'", "]", ":", "lbls_samples_per_path", "[", "min_idx_batch", ":", "max_idx_batch", "]", "}", ")", "\n", "# Training step. Returns a list containing the results of fetched ops.", "\n", "results_of_run", "=", "sessionTf", ".", "run", "(", "fetches", "=", "list_of_ops", ",", "feed_dict", "=", "feeds_dict", ")", "\n", "\n", "cnn3d", ".", "update_arrays_of_bn_moving_avg", "(", "sessionTf", ")", "# I should put this inside the model.", "\n", "\n", "cost_this_batch", "=", "results_of_run", "[", "0", "]", "\n", "list_RpRnPpPn_per_class", "=", "results_of_run", "[", "1", ":", "-", "1", "]", "# [-1] is from updates_grouped_op, returns nothing", "\n", "\n", "", "else", ":", "# validation", "\n", "            ", "ops_to_fetch", "=", "cnn3d", ".", "get_main_ops", "(", "'val'", ")", "\n", "list_of_ops", "=", "ops_to_fetch", "[", "'list_rp_rn_tp_tn'", "]", "\n", "\n", "min_idx_batch", "=", "batch_i", "*", "batchsize", "\n", "max_idx_batch", "=", "(", "batch_i", "+", "1", ")", "*", "batchsize", "\n", "\n", "feeds", "=", "cnn3d", ".", "get_main_feeds", "(", "'val'", ")", "\n", "feeds_dict", "=", "{", "feeds", "[", "'x'", "]", ":", "channs_samples_per_path", "[", "0", "]", "[", "min_idx_batch", ":", "max_idx_batch", "]", "}", "\n", "for", "subs_path_i", "in", "range", "(", "cnn3d", ".", "numSubsPaths", ")", ":", "\n", "                ", "x_batch_sub_path", "=", "channs_samples_per_path", "[", "subs_path_i", "+", "1", "]", "[", "min_idx_batch", ":", "max_idx_batch", "]", "\n", "feeds_dict", ".", "update", "(", "{", "feeds", "[", "'x_sub_'", "+", "str", "(", "subs_path_i", ")", "]", ":", "x_batch_sub_path", "}", ")", "\n", "", "feeds_dict", ".", "update", "(", "{", "feeds", "[", "'y_gt'", "]", ":", "lbls_samples_per_path", "[", "min_idx_batch", ":", "max_idx_batch", "]", "}", ")", "\n", "# Validation step. Returns a list containing the results of fetched ops.", "\n", "results_of_run", "=", "sessionTf", ".", "run", "(", "fetches", "=", "list_of_ops", ",", "feed_dict", "=", "feeds_dict", ")", "\n", "\n", "cost_this_batch", "=", "999", "# placeholder in case of validation.", "\n", "list_RpRnPpPn_per_class", "=", "results_of_run", "\n", "\n", "# list_RpRnPpPn_per_class holds Real Pos, Real Neg, True Pred Pos, True Pred Neg ...", "\n", "# ... for all classes, in this order, flattened. First RpRnTpTn are for 'WHOLE' class.", "\n", "", "arr_RpRnTpTn_per_class", "=", "np", ".", "asarray", "(", "list_RpRnPpPn_per_class", ",", "dtype", "=", "\"int32\"", ")", "\n", "arr_RpRnTpTn_per_class", "=", "arr_RpRnTpTn_per_class", ".", "reshape", "(", "arr_RpRnTpTn_per_class_in_subep", ".", "shape", ",", "order", "=", "'C'", ")", "\n", "\n", "# To later calculate the mean error and cost over the subepoch", "\n", "costs_of_batches", ".", "append", "(", "cost_this_batch", ")", "# only really used in training.", "\n", "arr_RpRnTpTn_per_class_in_subep", "+=", "arr_RpRnTpTn_per_class", "\n", "\n", "print_progress_step_tr_val", "(", "log", ",", "n_batches", ",", "batch_i", "+", "1", ",", "batchsize", ",", "prefix_progress_str", ")", "\n", "\n", "# ======== Calculate and Report accuracy over subepoch", "\n", "# In case of validation, mean_cost_subep is just a placeholder.", "\n", "# Cause this does not get calculated and reported in this case.", "\n", "", "mean_cost_subep", "=", "acc_monitor_ep", ".", "NA_PATTERN", "if", "(", "train_or_val", "==", "\"val\"", ")", "else", "np", ".", "mean", "(", "costs_of_batches", ")", "\n", "# This function does NOT flip the class-0 background to foreground!", "\n", "acc_monitor_ep", ".", "update_metrics_after_subep", "(", "mean_cost_subep", ",", "arr_RpRnTpTn_per_class_in_subep", ")", "\n", "acc_monitor_ep", ".", "log_acc_subep_to_txt", "(", ")", "\n", "acc_monitor_ep", ".", "log_acc_subep_to_tensorboard", "(", ")", "\n", "# Done", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.training.do_training": [[110, 434], ["time.time", "deepmedic.neuralnet.wrappers.CnnWrapperForSampling", "log.print3", "saver_all.save", "log.print3", "cnn3d.calc_outp_dims_given_inp", "cnn3d.calc_unpredicted_margin", "cnn3d.calc_outp_dims_given_inp", "cnn3d.calc_unpredicted_margin", "multiprocessing.pool.ThreadPool", "trainer.get_num_epochs_trained_tfv().eval", "log.print3", "deepmedic.logging.utils.datetime_now_str", "str", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm", "log.print3", "log.print3", "log.print3", "log.print3", "time.time", "range", "log.print3", "log.print3", "log.print3", "log.print3", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_samples_ep", "trainer.run_updates_end_of_ep", "trainer.get_num_epochs_trained_tfv().eval", "log.print3", "saver_all.save", "log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "multiprocessing.pool.ThreadPool.close", "multiprocessing.pool.ThreadPool.join", "str", "os.getpid", "trainer.get_num_epochs_trained_tfv", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm", "log.print3", "log.print3", "log.print3", "log.print3", "log.print3", "time.time", "training.process_in_batches", "log.print3", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_samples_ep", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.get_avg_accuracy_ep", "deepmedic.logging.utils.datetime_now_str", "log.print3", "deepmedic.routines.testing.inference_on_whole_volumes", "deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_whole_vols", "traceback.format_exc", "log.print3", "multiprocessing.pool.ThreadPool.terminate", "multiprocessing.pool.ThreadPool.join", "log.print3", "time.time", "training.process_in_batches", "log.print3", "log.print3", "deepmedic.dataManagement.sampling.get_samples_for_subepoch", "len", "trainer.get_num_epochs_trained_tfv", "str", "log.print3", "deepmedic.dataManagement.sampling.get_samples_for_subepoch", "log.print3", "multiprocessing.pool.ThreadPool.apply_async", "len", "mp_pool.apply_async.get", "log.print3", "multiprocessing.pool.ThreadPool.apply_async", "mp_pool.apply_async.get", "log.print3", "multiprocessing.pool.ThreadPool.apply_async", "log.print3", "multiprocessing.pool.ThreadPool.apply_async", "str", "str", "time.time", "str", "str", "mp_pool.apply_async.get", "log.print3", "multiprocessing.pool.ThreadPool.apply_async", "mp_pool.apply_async.get", "str", "str", "str", "str", "str", "time.time", "str", "str", "str", "str", "str", "str", "str", "time.time", "str", "time.time"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_unpredicted_margin", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_unpredicted_margin", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.datetime_now_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_samples_ep", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.run_updates_end_of_ep", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_num_epochs_trained_tfv", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.training.process_in_batches", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_samples_ep", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.get_avg_accuracy_ep", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.datetime_now_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.inference_on_whole_volumes", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_whole_vols", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.training.process_in_batches", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_samples_for_subepoch", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_num_epochs_trained_tfv", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_samples_for_subepoch", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get"], ["", "def", "do_training", "(", "sessionTf", ",", "\n", "saver_all", ",", "\n", "cnn3d", ",", "\n", "trainer", ",", "\n", "tensorboard_loggers", ",", "\n", "\n", "log", ",", "\n", "fileToSaveTrainedCnnModelTo", ",", "\n", "\n", "val_on_samples", ",", "\n", "savePredictedSegmAndProbsDict", ",", "\n", "\n", "namesForSavingSegmAndProbs", ",", "\n", "suffixForSegmAndProbsDict", ",", "\n", "\n", "paths_per_chan_per_subj_train", ",", "\n", "paths_per_chan_per_subj_val", ",", "\n", "\n", "paths_to_lbls_per_subj_train", ",", "\n", "paths_to_lbls_per_subj_val", ",", "\n", "\n", "paths_to_wmaps_per_sampl_cat_per_subj_train", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj_val", ",", "\n", "\n", "paths_to_masks_per_subj_train", ",", "\n", "paths_to_masks_per_subj_val", ",", "\n", "\n", "n_epochs", ",", "# Every epoch the CNN model is saved.", "\n", "n_subepochs", ",", "# per epoch. Every subepoch Accuracy is reported", "\n", "max_n_cases_per_subep_train", ",", "# Max num of subjects loaded every subep for sampling", "\n", "n_samples_per_subep_train", ",", "\n", "n_samples_per_subep_val", ",", "\n", "num_parallel_proc_sampling", ",", "# -1: seq. 0: thread for sampling. >0: multiprocess sampling", "\n", "\n", "# -------Sampling Type---------", "\n", "sampling_type_inst_tr", ",", "\n", "# Instance of the deepmedic/samplingType.SamplingType class for training and validation", "\n", "sampling_type_inst_val", ",", "\n", "batchsize_train", ",", "\n", "batchsize_val_samples", ",", "\n", "batchsize_val_whole", ",", "\n", "\n", "# -------Data Augmentation-------", "\n", "augm_img_prms", ",", "\n", "augm_sample_prms", ",", "\n", "\n", "# Validation", "\n", "val_on_whole_volumes", ",", "\n", "n_epochs_between_val_on_whole_vols", ",", "\n", "\n", "# --------For FM visualisation---------", "\n", "save_fms_flag", ",", "\n", "idxs_fms_to_save", ",", "\n", "namesForSavingFms", ",", "\n", "\n", "# --- Data Compatibility Checks ---", "\n", "run_input_checks", ",", "\n", "\n", "# -------- Pre-processing ------", "\n", "pad_input", ",", "\n", "norm_prms", ",", "\n", "#--------- Sampling Hyperparamas -----", "\n", "inp_shapes_per_path_train", ",", "\n", "inp_shapes_per_path_val", ",", "\n", "inp_shapes_per_path_test", ")", ":", "\n", "    ", "id_str", "=", "\"[MAIN|PID:\"", "+", "str", "(", "os", ".", "getpid", "(", ")", ")", "+", "\"]\"", "\n", "start_time_train", "=", "time", ".", "time", "(", ")", "\n", "\n", "# I cannot pass cnn3d to the sampling function, because the pp module used to reload theano. ", "\n", "# This created problems in the GPU when cnmem is used. Not sure this is needed with Tensorflow. Probably.", "\n", "cnn3dWrapper", "=", "CnnWrapperForSampling", "(", "cnn3d", ")", "\n", "\n", "args_for_sampling_tr", "=", "(", "log", ",", "\n", "\"train\"", ",", "\n", "num_parallel_proc_sampling", ",", "\n", "run_input_checks", ",", "\n", "cnn3dWrapper", ",", "\n", "max_n_cases_per_subep_train", ",", "\n", "n_samples_per_subep_train", ",", "\n", "sampling_type_inst_tr", ",", "\n", "inp_shapes_per_path_train", ",", "\n", "cnn3d", ".", "calc_outp_dims_given_inp", "(", "inp_shapes_per_path_train", "[", "0", "]", ")", ",", "\n", "cnn3d", ".", "calc_unpredicted_margin", "(", "inp_shapes_per_path_train", "[", "0", "]", ")", ",", "\n", "paths_per_chan_per_subj_train", ",", "\n", "paths_to_lbls_per_subj_train", ",", "\n", "paths_to_masks_per_subj_train", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj_train", ",", "\n", "pad_input", ",", "\n", "norm_prms", ",", "\n", "augm_img_prms", ",", "\n", "augm_sample_prms", "\n", ")", "\n", "args_for_sampling_val", "=", "(", "log", ",", "\n", "\"val\"", ",", "\n", "num_parallel_proc_sampling", ",", "\n", "run_input_checks", ",", "\n", "cnn3dWrapper", ",", "\n", "max_n_cases_per_subep_train", ",", "\n", "n_samples_per_subep_val", ",", "\n", "sampling_type_inst_val", ",", "\n", "inp_shapes_per_path_val", ",", "\n", "cnn3d", ".", "calc_outp_dims_given_inp", "(", "inp_shapes_per_path_val", "[", "0", "]", ")", ",", "\n", "cnn3d", ".", "calc_unpredicted_margin", "(", "inp_shapes_per_path_val", "[", "0", "]", ")", ",", "\n", "paths_per_chan_per_subj_val", ",", "\n", "paths_to_lbls_per_subj_val", ",", "\n", "paths_to_masks_per_subj_val", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj_val", ",", "\n", "pad_input", ",", "\n", "norm_prms", ",", "\n", "None", ",", "# no augmentation in val.", "\n", "None", "# no augmentation in val.", "\n", ")", "\n", "\n", "sampling_job_submitted_train", "=", "False", "\n", "sampling_job_submitted_val", "=", "False", "\n", "# For parallel extraction of samples for next train/val while processing previous iteration.", "\n", "mp_pool", "=", "None", "\n", "if", "num_parallel_proc_sampling", ">", "-", "1", ":", "# Use multiprocessing.", "\n", "        ", "mp_pool", "=", "ThreadPool", "(", "processes", "=", "1", ")", "# Or multiprocessing.Pool(...), same API.", "\n", "\n", "", "try", ":", "\n", "        ", "n_eps_trained_model", "=", "trainer", ".", "get_num_epochs_trained_tfv", "(", ")", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "while", "n_eps_trained_model", "<", "n_epochs", ":", "\n", "            ", "epoch", "=", "n_eps_trained_model", "\n", "\n", "acc_monitor_ep_tr", "=", "AccuracyMonitorForEpSegm", "(", "log", ",", "0", ",", "\n", "n_eps_trained_model", ",", "\n", "cnn3d", ".", "num_classes", ",", "\n", "n_subepochs", ",", "\n", "tensorboard_loggers", "[", "'train'", "]", ")", "\n", "\n", "acc_monitor_ep_val", "=", "None", "\n", "if", "val_on_samples", "or", "val_on_whole_volumes", ":", "\n", "                ", "acc_monitor_ep_val", "=", "AccuracyMonitorForEpSegm", "(", "log", ",", "1", ",", "\n", "n_eps_trained_model", ",", "\n", "cnn3d", ".", "num_classes", ",", "\n", "n_subepochs", ",", "\n", "tensorboard_loggers", "[", "'val'", "]", ")", "\n", "\n", "", "val_on_whole_vols_after_this_ep", "=", "False", "\n", "if", "val_on_whole_volumes", "and", "(", "n_eps_trained_model", "+", "1", ")", "%", "n_epochs_between_val_on_whole_vols", "==", "0", ":", "\n", "                ", "val_on_whole_vols_after_this_ep", "=", "True", "\n", "\n", "", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "log", ".", "print3", "(", "\"~~\\t\\t\\t Starting new Epoch! Epoch #\"", "+", "str", "(", "epoch", ")", "+", "\"/\"", "+", "str", "(", "n_epochs", ")", "+", "\"  \\t\\t\\t~~\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "start_time_ep", "=", "time", ".", "time", "(", ")", "\n", "\n", "for", "subep", "in", "range", "(", "n_subepochs", ")", ":", "\n", "                ", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"***********************************************************************************\"", ")", "\n", "log", ".", "print3", "(", "\"*\\t\\t\\t Starting new Subepoch: #\"", "+", "str", "(", "subep", ")", "+", "\"/\"", "+", "str", "(", "n_subepochs", ")", "+", "\" \\t\\t\\t*\"", ")", "\n", "log", ".", "print3", "(", "\"***********************************************************************************\"", ")", "\n", "\n", "# -------------------- GET DATA FOR THIS SUBEPOCH's VALIDATION -----------------------", "\n", "if", "val_on_samples", ":", "\n", "                    ", "if", "mp_pool", "is", "None", ":", "# Sequential processing.", "\n", "                        ", "log", ".", "print3", "(", "id_str", "+", "\" NO MULTIPROC: Sampling for subepoch #\"", "+", "str", "(", "subep", ")", "+", "\" [VALIDATION] will be done by main thread.\"", ")", "\n", "(", "channs_samples_per_path_val", ",", "\n", "lbls_samples_per_path_val", ")", "=", "get_samples_for_subepoch", "(", "*", "args_for_sampling_val", ")", "\n", "", "elif", "sampling_job_submitted_val", ":", "# done parallel with training of previous epoch.", "\n", "                        ", "(", "channs_samples_per_path_val", ",", "\n", "lbls_samples_per_path_val", ")", "=", "sampling_job_val", ".", "get", "(", ")", "\n", "sampling_job_submitted_val", "=", "False", "\n", "", "else", ":", "# Not previously submitted in case of first epoch or after a full-volumes validation.", "\n", "                        ", "assert", "subep", "==", "0", "\n", "log", ".", "print3", "(", "id_str", "+", "\" MULTIPROC: Before Validation in subepoch #\"", "+", "str", "(", "subep", ")", "+", "\", submitting sampling job for next [VALIDATION].\"", ")", "\n", "sampling_job_val", "=", "mp_pool", ".", "apply_async", "(", "get_samples_for_subepoch", ",", "args_for_sampling_val", ")", "\n", "(", "channs_samples_per_path_val", ",", "\n", "lbls_samples_per_path_val", ")", "=", "sampling_job_val", ".", "get", "(", ")", "\n", "sampling_job_submitted_val", "=", "False", "\n", "\n", "# ----------- SUBMIT PARALLEL JOB TO GET TRAINING DATA FOR NEXT TRAINING -----------------", "\n", "", "if", "mp_pool", "is", "not", "None", ":", "\n", "                        ", "log", ".", "print3", "(", "id_str", "+", "\" MULTIPROC: Before Validation in subepoch #\"", "+", "str", "(", "subep", ")", "+", "\", submitting sampling job for next [TRAINING].\"", ")", "\n", "sampling_job_tr", "=", "mp_pool", ".", "apply_async", "(", "get_samples_for_subepoch", ",", "args_for_sampling_tr", ")", "\n", "sampling_job_submitted_train", "=", "True", "\n", "\n", "# ------------------------------------DO VALIDATION--------------------------------", "\n", "", "log", ".", "print3", "(", "\"V-V-V-V- Validating for subepoch before starting training iterations -V-V-V-V\"", ")", "\n", "start_time_val_subep", "=", "time", ".", "time", "(", ")", "\n", "# Calc num of batches from extracted samples, in case not extracted as much as requested.", "\n", "n_batches_val", "=", "len", "(", "channs_samples_per_path_val", "[", "0", "]", ")", "//", "batchsize_val_samples", "\n", "process_in_batches", "(", "log", ",", "\n", "sessionTf", ",", "\n", "\"val\"", ",", "\n", "n_batches_val", ",", "\n", "batchsize_val_samples", ",", "\n", "cnn3d", ",", "\n", "acc_monitor_ep_val", ",", "\n", "channs_samples_per_path_val", ",", "\n", "lbls_samples_per_path_val", ")", "\n", "log", ".", "print3", "(", "\"TIMING: Validation on batches of subepoch #\"", "+", "str", "(", "subep", ")", "+", "\" lasted: {0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time_val_subep", ")", "+", "\" secs.\"", ")", "\n", "\n", "# ----------------------- GET DATA FOR THIS SUBEPOCH's TRAINING ------------------------------", "\n", "", "if", "mp_pool", "is", "None", ":", "# Sequential processing.", "\n", "                    ", "log", ".", "print3", "(", "id_str", "+", "\" NO MULTIPROC: Sampling for subepoch #\"", "+", "str", "(", "subep", ")", "+", "\" [TRAINING] will be done by main thread.\"", ")", "\n", "(", "channs_samples_per_path_tr", ",", "\n", "lbls_samples_per_path_tr", ")", "=", "get_samples_for_subepoch", "(", "*", "args_for_sampling_tr", ")", "\n", "", "elif", "sampling_job_submitted_train", ":", "# done parallel with train/val of previous epoch.", "\n", "                    ", "(", "channs_samples_per_path_tr", ",", "\n", "lbls_samples_per_path_tr", ")", "=", "sampling_job_tr", ".", "get", "(", ")", "\n", "sampling_job_submitted_train", "=", "False", "\n", "", "else", ":", "# Not previously submitted in case of first epoch or after a full-volumes validation.", "\n", "                    ", "assert", "subep", "==", "0", "\n", "log", ".", "print3", "(", "id_str", "+", "\" MULTIPROC: Before Training in subepoch #\"", "+", "str", "(", "subep", ")", "+", "\", submitting sampling job for next [TRAINING].\"", ")", "\n", "sampling_job_tr", "=", "mp_pool", ".", "apply_async", "(", "get_samples_for_subepoch", ",", "args_for_sampling_tr", ")", "\n", "(", "channs_samples_per_path_tr", ",", "\n", "lbls_samples_per_path_tr", ")", "=", "sampling_job_tr", ".", "get", "(", ")", "\n", "sampling_job_submitted_train", "=", "False", "\n", "\n", "# ----- SUBMIT PARALLEL JOB TO GET VAL / TRAIN (if no val) DATA FOR NEXT SUBEPOCH -----", "\n", "", "if", "mp_pool", "is", "not", "None", "and", "not", "(", "val_on_whole_vols_after_this_ep", "and", "(", "subep", "==", "n_subepochs", "-", "1", ")", ")", ":", "\n", "                    ", "if", "val_on_samples", ":", "\n", "                        ", "log", ".", "print3", "(", "id_str", "+", "\" MULTIPROC: Before Training in subepoch #\"", "+", "str", "(", "subep", ")", "+", "\", submitting sampling job for next [VALIDATION].\"", ")", "\n", "sampling_job_val", "=", "mp_pool", ".", "apply_async", "(", "get_samples_for_subepoch", ",", "args_for_sampling_val", ")", "\n", "sampling_job_submitted_val", "=", "True", "\n", "", "else", ":", "\n", "                        ", "log", ".", "print3", "(", "id_str", "+", "\" MULTIPROC: Before Training in subepoch #\"", "+", "str", "(", "subep", ")", "+", "\", submitting sampling job for next [TRAINING].\"", ")", "\n", "sampling_job_tr", "=", "mp_pool", ".", "apply_async", "(", "get_samples_for_subepoch", ",", "args_for_sampling_tr", ")", "\n", "sampling_job_submitted_train", "=", "True", "\n", "\n", "# ------------------------------ START TRAINING IN BATCHES -----------------------------", "\n", "", "", "log", ".", "print3", "(", "\"-T-T-T-T- Training for this subepoch... May take a few minutes... -T-T-T-T-\"", ")", "\n", "start_time_train_subep", "=", "time", ".", "time", "(", ")", "\n", "# Calc num of batches from extracted samples, in case not extracted as much as requested.", "\n", "n_batches_train", "=", "len", "(", "channs_samples_per_path_tr", "[", "0", "]", ")", "//", "batchsize_train", "\n", "process_in_batches", "(", "log", ",", "\n", "sessionTf", ",", "\n", "\"train\"", ",", "\n", "n_batches_train", ",", "\n", "batchsize_train", ",", "\n", "cnn3d", ",", "\n", "acc_monitor_ep_tr", ",", "\n", "channs_samples_per_path_tr", ",", "\n", "lbls_samples_per_path_tr", ")", "\n", "log", ".", "print3", "(", "\"TIMING: Training on batches of this subepoch #\"", "+", "str", "(", "subep", ")", "+", "\" lasted: {0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time_train_subep", ")", "+", "\" secs.\"", ")", "\n", "\n", "", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~ Epoch #\"", "+", "str", "(", "epoch", ")", "+", "\" finished. Reporting Accuracy over whole epoch. ~~~~~~~\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "\n", "if", "val_on_samples", ":", "\n", "                ", "acc_monitor_ep_val", ".", "report_metrics_samples_ep", "(", ")", "\n", "", "acc_monitor_ep_tr", ".", "report_metrics_samples_ep", "(", ")", "\n", "\n", "mean_val_acc_of_ep", "=", "acc_monitor_ep_val", ".", "get_avg_accuracy_ep", "(", ")", "if", "val_on_samples", "else", "None", "\n", "# Updates LR schedule if needed, and increases number of epochs trained.", "\n", "trainer", ".", "run_updates_end_of_ep", "(", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", "\n", "n_eps_trained_model", "=", "trainer", ".", "get_num_epochs_trained_tfv", "(", ")", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "\n", "log", ".", "print3", "(", "\"SAVING: Epoch #\"", "+", "str", "(", "epoch", ")", "+", "\" finished. Saving CNN model.\"", ")", "\n", "filename_to_save_with", "=", "fileToSaveTrainedCnnModelTo", "+", "\".\"", "+", "datetime_now_str", "(", ")", "\n", "saver_all", ".", "save", "(", "sessionTf", ",", "filename_to_save_with", "+", "\".model.ckpt\"", ",", "write_meta_graph", "=", "False", ")", "\n", "\n", "log", ".", "print3", "(", "\"TIMING: Whole Epoch #\"", "+", "str", "(", "epoch", ")", "+", "\" lasted: {0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time_ep", ")", "+", "\" secs.\"", ")", "\n", "log", ".", "print3", "(", "\"~~~~~~~~~~~~~~~~~~~ End of Training Epoch. Model was Saved. ~~~~~~~~~~~~~~~~~~~~~~~~\"", ")", "\n", "\n", "if", "val_on_whole_vols_after_this_ep", ":", "\n", "                ", "log", ".", "print3", "(", "\"***Start validation by segmenting whole subjects for Epoch #\"", "+", "str", "(", "epoch", ")", "+", "\"***\"", ")", "\n", "\n", "mean_metrics_val_whole_vols", "=", "inference_on_whole_volumes", "(", "sessionTf", ",", "\n", "cnn3d", ",", "\n", "log", ",", "\n", "\"val\"", ",", "\n", "savePredictedSegmAndProbsDict", ",", "\n", "paths_per_chan_per_subj_val", ",", "\n", "paths_to_lbls_per_subj_val", ",", "\n", "paths_to_masks_per_subj_val", ",", "\n", "namesForSavingSegmAndProbs", ",", "\n", "suffixForSegmAndProbsDict", ",", "\n", "# Hyper parameters", "\n", "batchsize_val_whole", ",", "\n", "# Data compatibility checks", "\n", "run_input_checks", ",", "\n", "# Pre-Processing", "\n", "pad_input", ",", "\n", "norm_prms", ",", "\n", "# Saving feature maps", "\n", "save_fms_flag", ",", "\n", "idxs_fms_to_save", ",", "\n", "namesForSavingFms", ",", "\n", "inp_shapes_per_path_test", ")", "\n", "\n", "acc_monitor_ep_val", ".", "report_metrics_whole_vols", "(", "mean_metrics_val_whole_vols", ")", "\n", "\n", "", "del", "acc_monitor_ep_tr", "\n", "del", "acc_monitor_ep_val", "\n", "\n", "", "log", ".", "print3", "(", "\"TIMING: Training process lasted: {0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time_train", ")", "+", "\" secs.\"", ")", "\n", "\n", "", "except", "(", "Exception", ",", "KeyboardInterrupt", ")", "as", "e", ":", "\n", "        ", "log", ".", "print3", "(", "\"\\n\\n ERROR: Caught exception in do_training(): \"", "+", "str", "(", "e", ")", "+", "\"\\n\"", ")", "\n", "log", ".", "print3", "(", "traceback", ".", "format_exc", "(", ")", ")", "\n", "if", "mp_pool", "is", "not", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"Terminating worker pool.\"", ")", "\n", "mp_pool", ".", "terminate", "(", ")", "\n", "mp_pool", ".", "join", "(", ")", "# Will wait. A KeybInt will kill this (py3)", "\n", "", "return", "1", "\n", "", "else", ":", "\n", "        ", "if", "mp_pool", "is", "not", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"Closing worker pool.\"", ")", "\n", "mp_pool", ".", "close", "(", ")", "\n", "mp_pool", ".", "join", "(", ")", "\n", "\n", "# Save the final trained model.", "\n", "", "", "filename_to_save_with", "=", "fileToSaveTrainedCnnModelTo", "+", "\".final.\"", "+", "datetime_now_str", "(", ")", "\n", "log", ".", "print3", "(", "\"Saving the final model at:\"", "+", "str", "(", "filename_to_save_with", ")", ")", "\n", "saver_all", ".", "save", "(", "sessionTf", ",", "filename_to_save_with", "+", "\".model.ckpt\"", ",", "write_meta_graph", "=", "False", ")", "\n", "\n", "log", ".", "print3", "(", "\"The whole do_training() function has finished.\"", ")", "\n", "return", "0", "\n", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.__init__": [[29, 36], ["deepmedic.frontEnd.session.Session.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "_out_folder_models", "=", "None", "\n", "self", ".", "_out_folder_preds", "=", "None", "\n", "self", ".", "_out_folder_fms", "=", "None", "\n", "self", ".", "_out_folder_tensorboard", "=", "None", "\n", "self", ".", "_params", "=", "None", "# Compiled from cfg. Required for run()", "\n", "Session", ".", "__init__", "(", "self", ",", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession._make_session_name": [[37, 40], ["deepmedic.frontEnd.configParsing.trainSessionParams.TrainSessionParameters.get_session_name"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_session_name"], ["", "def", "_make_session_name", "(", "self", ")", ":", "\n", "        ", "session_name", "=", "TrainSessionParameters", ".", "get_session_name", "(", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "SESSION_NAME", "]", ")", "\n", "return", "session_name", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.make_output_folders": [[41, 48], ["deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.sessHelpers.make_folders_for_train_session", "trainSession.TrainSession.get_abs_path_to_cfg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.make_folders_for_train_session", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg"], ["", "def", "make_output_folders", "(", "self", ")", ":", "\n", "        ", "self", ".", "_main_out_folder_abs", "=", "abs_from_rel_path", "(", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "FOLDER_OUTP", "]", ",", "self", ".", "get_abs_path_to_cfg", "(", ")", ")", "\n", "[", "self", ".", "_out_folder_logs", ",", "\n", "self", ".", "_out_folder_models", ",", "\n", "self", ".", "_out_folder_preds", ",", "\n", "self", ".", "_out_folder_fms", ",", "\n", "self", ".", "_out_folder_tensorboard", "]", "=", "make_folders_for_train_session", "(", "self", ".", "_main_out_folder_abs", ",", "self", ".", "_session_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.create_tensorboard_loggers": [[49, 67], ["trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "os.path.join", "deepmedic.logging.tensorboard_logger.TensorboardLogger", "os.path.exists", "os.mkdir"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "create_tensorboard_loggers", "(", "self", ",", "logger_types", ",", "tf_graph", ",", "create_log", "=", "False", ")", ":", "\n", "        ", "tensorboard_loggers", "=", "{", "}", "\n", "self", ".", "_log", ".", "print3", "(", "\"----------- Creating Tensorboard Loggers -----------\"", ")", "\n", "if", "create_log", ":", "\n", "            ", "for", "logger_type", "in", "logger_types", ":", "\n", "                ", "tb_log_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "_out_folder_tensorboard", ",", "logger_type", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "tb_log_path", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "tb_log_path", ")", "# Separate folders for train / val metrics.", "\n", "", "tensorboard_loggers", "[", "logger_type", "]", "=", "TensorboardLogger", "(", "tb_log_path", ",", "tf_graph", ")", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"Loggers created successfully\"", ")", "\n", "", "else", ":", "\n", "            ", "for", "logger_type", "in", "logger_types", ":", "\n", "                ", "tensorboard_loggers", "[", "logger_type", "]", "=", "None", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"Config flag to log to tensorboard not present.\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"Skipping...\"", ")", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"-----------=============================-----------\"", ")", "\n", "\n", "return", "tensorboard_loggers", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.print_vars_in_collection": [[68, 74], ["trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "print_vars_in_collection", "(", "self", ",", "collection", ",", "coll_name", "=", "\"no_name\"", ")", ":", "\n", "        ", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"==== Printing variables of collection [\"", "+", "str", "(", "coll_name", ")", "+", "\"] ====\"", ")", "\n", "for", "entry", "in", "collection", ":", "\n", "            ", "self", ".", "_log", ".", "print3", "(", "str", "(", "entry", ")", ")", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"==== Done printing variables of collection. ====\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.compile_session_params_from_cfg": [[75, 93], ["deepmedic.frontEnd.configParsing.trainSessionParams.TrainSessionParameters", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._params.print_params", "trainSession.TrainSession._log.print3", "model_params.get_n_classes", "model_params.get_model_name"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.print_params", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_n_classes", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_model_name"], ["", "def", "compile_session_params_from_cfg", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "(", "model_params", ",", ")", "=", "args", "\n", "\n", "self", ".", "_params", "=", "TrainSessionParameters", "(", "self", ".", "_log", ",", "\n", "self", ".", "_main_out_folder_abs", ",", "\n", "self", ".", "_out_folder_models", ",", "\n", "self", ".", "_out_folder_preds", ",", "\n", "self", ".", "_out_folder_fms", ",", "\n", "model_params", ".", "get_n_classes", "(", ")", ",", "\n", "model_params", ".", "get_model_name", "(", ")", ",", "\n", "self", ".", "_cfg", ")", "\n", "\n", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=============    NEW TRAINING SESSION    ==============\\n\"", ")", "\n", "self", ".", "_params", ".", "print_params", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\\n\"", ")", "\n", "\n", "return", "self", ".", "_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.run_session": [[94, 228], ["tensorflow.Graph", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "tensorflow.Graph.as_default", "trainSession.TrainSession.create_tensorboard_loggers", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_train", "trainSession.TrainSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_val", "trainSession.TrainSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_test", "tensorflow.compat.v1.train.Saver", "tensorflow.compat.v1.get_collection", "tensorflow.compat.v1.train.Saver", "tensorflow.compat.v1.get_collection", "tensorflow.compat.v1.train.Saver", "tensorflow.compat.v1.Session", "trainSession.TrainSession._params.get_path_to_load_model_from", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "deepmedic.routines.training.do_training", "tensorflow.device", "trainSession.TrainSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d", "tensorflow.compat.v1.variable_scope", "trainSession.TrainSession._log.print3", "deepmedic.neuralnet.trainer.Trainer", "deepmedic.neuralnet.trainer.Trainer.compute_costs", "deepmedic.neuralnet.trainer.Trainer.create_optimizer", "deepmedic.neuralnet.trainer.Trainer.get_total_cost", "deepmedic.neuralnet.trainer.Trainer.get_param_updates_wrt_total_cost", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "tensorflow.compat.v1.variables_initializer().run", "tensorflow.compat.v1.variables_initializer().run", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "tensorflow.compat.v1.train.Saver.save", "tensorflow.compat.v1.variable_scope", "deepmedic.neuralnet.cnn3d.Cnn3d.make_cnn_model", "deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "deepmedic.neuralnet.cnn3d.Cnn3d.apply", "deepmedic.neuralnet.cnn3d.Cnn3d.apply", "deepmedic.neuralnet.cnn3d.Cnn3d.apply", "trainSession.TrainSession._params.get_tensorboard_bool", "tensorflow.compat.v1.ConfigProto", "os.path.isdir", "tensorflow.train.latest_checkpoint", "tensorflow.compat.v1.train.Saver.restore", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "tensorflow.compat.v1.train.Saver.restore", "trainSession.TrainSession._log.print3", "trainSession.TrainSession._log.print3", "tensorflow.compat.v1.variables_initializer().run", "trainSession.TrainSession._log.print3", "deepmedic.logging.utils.datetime_now_str", "model_params.get_inp_dims_hr_path", "model_params.get_inp_dims_hr_path", "model_params.get_inp_dims_hr_path", "trainSession.TrainSession._params.get_args_for_optimizer", "str", "deepmedic.frontEnd.sessHelpers.handle_exception_tf_restore", "tensorflow.compat.v1.variables_initializer", "tensorflow.compat.v1.variables_initializer", "str", "model_params.get_args_for_arch", "trainSession.TrainSession._params.get_args_for_trainer", "tensorflow.compat.v1.variables_initializer", "trainSession.TrainSession._params.get_args_for_train_routine"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.trainSession.TrainSession.create_tensorboard_loggers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_train", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_val", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_test", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_path_to_load_model_from", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.training.do_training", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.compute_costs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.create_optimizer", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_total_cost", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_param_updates_wrt_total_cost", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.make_cnn_model", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_tensorboard_bool", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.datetime_now_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_inp_dims_hr_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_inp_dims_hr_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_inp_dims_hr_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_optimizer", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.handle_exception_tf_restore", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_args_for_arch", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_trainer", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_train_routine"], ["", "def", "run_session", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "(", "sess_device", ",", "\n", "model_params", ",", "\n", "reset_trainer", ")", "=", "args", "\n", "\n", "graphTf", "=", "tf", ".", "Graph", "(", ")", "\n", "\n", "with", "graphTf", ".", "as_default", "(", ")", ":", "\n", "# Explicit device assignment, throws an error if GPU is specified but not available.", "\n", "            ", "with", "tf", ".", "device", "(", "sess_device", ")", ":", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Making the CNN graph... ===============\"", ")", "\n", "cnn3d", "=", "Cnn3d", "(", ")", "\n", "with", "tf", ".", "compat", ".", "v1", ".", "variable_scope", "(", "\"net\"", ")", ":", "\n", "                    ", "cnn3d", ".", "make_cnn_model", "(", "*", "model_params", ".", "get_args_for_arch", "(", ")", ")", "\n", "# I have now created the CNN graph. But not yet the Optimizer's graph.", "\n", "inp_plchldrs_train", ",", "inp_shapes_per_path_train", "=", "cnn3d", ".", "create_inp_plchldrs", "(", "model_params", ".", "get_inp_dims_hr_path", "(", "'train'", ")", ",", "'train'", ")", "\n", "inp_plchldrs_val", ",", "inp_shapes_per_path_val", "=", "cnn3d", ".", "create_inp_plchldrs", "(", "model_params", ".", "get_inp_dims_hr_path", "(", "'val'", ")", ",", "'val'", ")", "\n", "inp_plchldrs_test", ",", "inp_shapes_per_path_test", "=", "cnn3d", ".", "create_inp_plchldrs", "(", "model_params", ".", "get_inp_dims_hr_path", "(", "'test'", ")", ",", "'test'", ")", "\n", "p_y_given_x_train", "=", "cnn3d", ".", "apply", "(", "inp_plchldrs_train", ",", "'train'", ",", "'train'", ",", "verbose", "=", "True", ",", "log", "=", "self", ".", "_log", ")", "\n", "p_y_given_x_val", "=", "cnn3d", ".", "apply", "(", "inp_plchldrs_val", ",", "'infer'", ",", "'val'", ",", "verbose", "=", "True", ",", "log", "=", "self", ".", "_log", ")", "\n", "p_y_given_x_test", "=", "cnn3d", ".", "apply", "(", "inp_plchldrs_test", ",", "'infer'", ",", "'test'", ",", "verbose", "=", "True", ",", "log", "=", "self", ".", "_log", ")", "\n", "\n", "# No explicit device assignment for the rest.", "\n", "# Because trained has piecewise_constant that is only on cpu, and so is saver.", "\n", "", "", "with", "tf", ".", "compat", ".", "v1", ".", "variable_scope", "(", "\"trainer\"", ")", ":", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Building Trainer ===========\\n\"", ")", "\n", "trainer", "=", "Trainer", "(", "*", "(", "self", ".", "_params", ".", "get_args_for_trainer", "(", ")", "+", "[", "cnn3d", "]", ")", ")", "\n", "trainer", ".", "compute_costs", "(", "self", ".", "_log", ",", "p_y_given_x_train", ")", "\n", "trainer", ".", "create_optimizer", "(", "*", "self", ".", "_params", ".", "get_args_for_optimizer", "(", ")", ")", "# Trainer and net connect here.", "\n", "\n", "", "tensorboard_loggers", "=", "self", ".", "create_tensorboard_loggers", "(", "[", "'train'", ",", "'val'", "]", ",", "\n", "graphTf", ",", "\n", "create_log", "=", "self", ".", "_params", ".", "get_tensorboard_bool", "(", ")", ")", "\n", "\n", "# The below should not create any new tf.variables.", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Compiling the Training Function ===========\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\\n\"", ")", "\n", "cnn3d", ".", "setup_ops_n_feeds_to_train", "(", "self", ".", "_log", ",", "\n", "inp_plchldrs_train", ",", "\n", "p_y_given_x_train", ",", "\n", "trainer", ".", "get_total_cost", "(", ")", ",", "\n", "trainer", ".", "get_param_updates_wrt_total_cost", "(", ")", "# list of ops", "\n", ")", "\n", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Compiling the Validation Function =========\"", ")", "\n", "cnn3d", ".", "setup_ops_n_feeds_to_val", "(", "self", ".", "_log", ",", "inp_plchldrs_val", ",", "p_y_given_x_val", ")", "\n", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Compiling the Testing Function ============\"", ")", "\n", "# For validation with full segmentation", "\n", "cnn3d", ".", "setup_ops_n_feeds_to_test", "(", "self", ".", "_log", ",", "inp_plchldrs_test", ",", "p_y_given_x_test", ",", "self", ".", "_params", ".", "inds_fms_per_pathtype_per_layer_to_save", ")", "\n", "\n", "# Create the savers", "\n", "saver_all", "=", "tf", ".", "compat", ".", "v1", ".", "train", ".", "Saver", "(", ")", "# Will be used during training for saving everything.", "\n", "# Alternative: tf.train.Saver([v for v in tf.all_variables() if v.name.startswith(\"net\"])", "\n", "coll_vars_net", "=", "tf", ".", "compat", ".", "v1", ".", "get_collection", "(", "tf", ".", "compat", ".", "v1", ".", "GraphKeys", ".", "GLOBAL_VARIABLES", ",", "scope", "=", "\"net\"", ")", "\n", "saver_net", "=", "tf", ".", "compat", ".", "v1", ".", "train", ".", "Saver", "(", "var_list", "=", "coll_vars_net", ")", "# Used to load the net's parameters.", "\n", "coll_vars_trainer", "=", "tf", ".", "compat", ".", "v1", ".", "get_collection", "(", "tf", ".", "compat", ".", "v1", ".", "GraphKeys", ".", "GLOBAL_VARIABLES", ",", "scope", "=", "\"trainer\"", ")", "\n", "saver_trainer", "=", "tf", ".", "compat", ".", "v1", ".", "train", ".", "Saver", "(", "var_list", "=", "coll_vars_trainer", ")", "# to load the trainer's params", "\n", "\n", "# TF2: dict_vars_net = {'net_var'+str(i): v for i, v in enumerate(coll_vars_net)}", "\n", "# TF2: dict_vars_trainer = {'trainer_var'+str(i): v for i, v in enumerate(coll_vars_trainer)}", "\n", "# TF2: dict_vars_all = dict_vars_net.copy()", "\n", "# TF2: for key in dict_vars_trainer:", "\n", "# TF2:     dict_vars_all[key] = dict_vars_trainer[key]", "\n", "# TF2: ckpt_all = tf.train.Checkpoint(**dict_vars_all)", "\n", "# TF2: ckpt_net = tf.train.Checkpoint(**dict_vars_net)", "\n", "# TF2: ckpt_trainer = tf.train.Checkpoint(**dict_vars_trainer)", "\n", "\n", "# self._print_vars_in_collection(coll_vars_net, \"net\")", "\n", "# self._print_vars_in_collection(coll_vars_trainer, \"trainer\")", "\n", "\n", "", "with", "tf", ".", "compat", ".", "v1", ".", "Session", "(", "graph", "=", "graphTf", ",", "\n", "config", "=", "tf", ".", "compat", ".", "v1", ".", "ConfigProto", "(", "log_device_placement", "=", "False", ",", "\n", "device_count", "=", "{", "'CPU'", ":", "999", ",", "'GPU'", ":", "99", "}", ")", ")", "as", "sessionTf", ":", "\n", "# Load or initialize parameters", "\n", "            ", "file_to_load_params_from", "=", "self", ".", "_params", ".", "get_path_to_load_model_from", "(", ")", "\n", "if", "file_to_load_params_from", "is", "not", "None", ":", "# Load params", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Loading parameters from specified saved model ===============\"", ")", "\n", "chkpt_fname", "=", "tf", ".", "train", ".", "latest_checkpoint", "(", "file_to_load_params_from", ")", "if", "os", ".", "path", ".", "isdir", "(", "file_to_load_params_from", ")", "else", "file_to_load_params_from", "\n", "self", ".", "_log", ".", "print3", "(", "\"Loading checkpoint file:\"", "+", "str", "(", "chkpt_fname", ")", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"Loading network parameters...\"", ")", "\n", "try", ":", "\n", "                    ", "saver_net", ".", "restore", "(", "sessionTf", ",", "chkpt_fname", ")", "\n", "# TF2: status = ckpt_net.restore(chkpt_fname); #status.assert_consumed() # Passes if ckpt and program vars match exactly.", "\n", "\n", "self", ".", "_log", ".", "print3", "(", "\"Network parameters were loaded.\"", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "handle_exception_tf_restore", "(", "self", ".", "_log", ",", "e", ")", "\n", "\n", "", "if", "not", "reset_trainer", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"Loading trainer parameters...\"", ")", "\n", "saver_trainer", ".", "restore", "(", "sessionTf", ",", "chkpt_fname", ")", "\n", "# TF2: status = ckpt_trainer.restore(chkpt_fname); #status.assert_consumed() # Passes if ckpt and program vars match exactly.", "\n", "self", ".", "_log", ".", "print3", "(", "\"Trainer parameters were loaded.\"", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"Reset of trainer parameters was requested. Re-initializing them...\"", ")", "\n", "tf", ".", "compat", ".", "v1", ".", "variables_initializer", "(", "var_list", "=", "coll_vars_trainer", ")", ".", "run", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"Trainer parameters re-initialized.\"", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Initializing network and trainer variables  ===============\"", ")", "\n", "# Initializes all.", "\n", "# tf.variables_initializer(var_list = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES) ).run()", "\n", "# Initialize separate as below, so that in case I miss a variable, I will get an error and I will know.", "\n", "tf", ".", "compat", ".", "v1", ".", "variables_initializer", "(", "var_list", "=", "coll_vars_net", ")", ".", "run", "(", ")", "\n", "tf", ".", "compat", ".", "v1", ".", "variables_initializer", "(", "var_list", "=", "coll_vars_trainer", ")", ".", "run", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"All variables were initialized.\"", ")", "\n", "\n", "filename_to_save_with", "=", "self", ".", "_params", ".", "filepath_to_save_models", "+", "\".initial.\"", "+", "datetime_now_str", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"Saving the initial model at:\"", "+", "str", "(", "filename_to_save_with", ")", ")", "\n", "saver_all", ".", "save", "(", "sessionTf", ",", "filename_to_save_with", "+", "\".model.ckpt\"", ",", "write_meta_graph", "=", "False", ")", "\n", "# TF2: ckpt_all.save(file_prefix = filename_to_save_with+\".all.ckpt2\")", "\n", "# TF2: ckpt_net.save(file_prefix = filename_to_save_with+\".net.ckpt2\")", "\n", "# TF2: ckpt_trainer.save(file_prefix = filename_to_save_with+\".trainer.ckpt2\")", "\n", "\n", "# tf.train.write_graph(graph_or_graph_def=sessionTf.graph.as_graph_def(),", "\n", "#                      logdir=\"\", name=filename_to_save_with+\".graph.pb\", as_text=False)", "\n", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"============== Training the CNN model =================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\"", ")", "\n", "\n", "do_training", "(", "*", "(", "[", "sessionTf", ",", "saver_all", ",", "cnn3d", ",", "trainer", ",", "tensorboard_loggers", "]", "+", "\n", "self", ".", "_params", ".", "get_args_for_train_routine", "(", ")", "+", "\n", "[", "inp_shapes_per_path_train", ",", "inp_shapes_per_path_val", ",", "inp_shapes_per_path_test", "]", ")", ")", "\n", "\n", "# TF2: ckpt_all.save(file_prefix = filename_to_save_with+\".all.FINAL.ckpt2\")", "\n", "# TF2: ckpt_net.save(file_prefix = filename_to_save_with+\".net.FINAL.ckpt2\")", "\n", "# TF2: ckpt_trainer.save(file_prefix = filename_to_save_with+\".trainer.FINAL.ckpt2\")", "\n", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"\\n=======================================================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Training session finished =================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createMainOutputFolder": [[12, 16], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["def", "createMainOutputFolder", "(", "absMainOutputFolder", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "absMainOutputFolder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "absMainOutputFolder", ")", "\n", "print", "(", "\"\\t>>Created main output folder: \"", ",", "absMainOutputFolder", ")", "\n", "", "", "def", "createLogsFolder", "(", "folderForLogs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createLogsFolder": [[16, 20], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createLogsFolder", "(", "folderForLogs", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForLogs", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForLogs", ")", "\n", "print", "(", "\"\\t>>Created folder for logs: \"", ",", "folderForLogs", ")", "\n", "", "", "def", "createFolderForPredictions", "(", "folderForPredictions", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForPredictions": [[20, 24], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForPredictions", "(", "folderForPredictions", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForPredictions", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForPredictions", ")", "\n", "print", "(", "\"\\t>>Created folder for predictions: \"", ",", "folderForPredictions", ")", "\n", "", "", "def", "createFolderForSessionResults", "(", "folderForSessionResults", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionResults": [[24, 28], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForSessionResults", "(", "folderForSessionResults", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForSessionResults", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForSessionResults", ")", "\n", "print", "(", "\"\\t>>Created folder for session: \"", ",", "folderForSessionResults", ")", "\n", "", "", "def", "createFolderForSegmAndProbMaps", "(", "folderForSegmAndProbMaps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSegmAndProbMaps": [[28, 32], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForSegmAndProbMaps", "(", "folderForSegmAndProbMaps", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForSegmAndProbMaps", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForSegmAndProbMaps", ")", "\n", "print", "(", "\"\\t>>Created folder for segmentations and probability maps: \"", ",", "folderForSegmAndProbMaps", ")", "\n", "", "", "def", "createFolderForFeatures", "(", "folderForFeatures", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForFeatures": [[32, 36], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForFeatures", "(", "folderForFeatures", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForFeatures", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForFeatures", ")", "\n", "print", "(", "\"\\t>>Created folder for features: \"", ",", "folderForFeatures", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.make_folders_for_test_session": [[37, 60], ["print", "sessHelpers.createMainOutputFolder", "sessHelpers.createLogsFolder", "sessHelpers.createFolderForPredictions", "sessHelpers.createFolderForSessionResults", "sessHelpers.createFolderForSegmAndProbMaps", "sessHelpers.createFolderForFeatures"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createMainOutputFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createLogsFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForPredictions", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionResults", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSegmAndProbMaps", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForFeatures"], ["", "", "def", "make_folders_for_test_session", "(", "absMainOutputFolder", ",", "sessionName", ")", ":", "\n", "#Create folders for saving the prediction images:", "\n", "    ", "print", "(", "\"Creating necessary folders for testing session...\"", ")", "\n", "createMainOutputFolder", "(", "absMainOutputFolder", ")", "\n", "\n", "folderForLogs", "=", "absMainOutputFolder", "+", "\"/logs/\"", "\n", "createLogsFolder", "(", "folderForLogs", ")", "\n", "\n", "folderForPredictions", "=", "absMainOutputFolder", "+", "\"/predictions\"", "\n", "createFolderForPredictions", "(", "folderForPredictions", ")", "\n", "\n", "folderForSessionResults", "=", "folderForPredictions", "+", "\"/\"", "+", "sessionName", "\n", "createFolderForSessionResults", "(", "folderForSessionResults", ")", "\n", "\n", "folderForSegmAndProbMaps", "=", "folderForSessionResults", "+", "\"/predictions/\"", "\n", "createFolderForSegmAndProbMaps", "(", "folderForSegmAndProbMaps", ")", "\n", "\n", "folderForFeatures", "=", "folderForSessionResults", "+", "\"/features/\"", "\n", "createFolderForFeatures", "(", "folderForFeatures", ")", "\n", "\n", "return", "[", "folderForLogs", ",", "\n", "folderForSegmAndProbMaps", ",", "\n", "folderForFeatures", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForCnnModels": [[61, 65], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "def", "createFolderForCnnModels", "(", "folderForCnnModels", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForCnnModels", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForCnnModels", ")", "\n", "print", "(", "\"\\t>>Created folder to save cnn-models as they get trained: \"", ",", "folderForCnnModels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionCnnModels": [[66, 70], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForSessionCnnModels", "(", "folderForSessionCnnModels", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForSessionCnnModels", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForSessionCnnModels", ")", "\n", "print", "(", "\"\\t>>Created folder to save session's cnn-models as they get trained: \"", ",", "folderForSessionCnnModels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForTensorboard": [[71, 75], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForTensorboard", "(", "folderForTensorboard", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForTensorboard", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForTensorboard", ")", "\n", "print", "(", "\"\\t>>Created folder to log tensorboard metrics/events: \"", ",", "folderForTensorboard", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionTensorboard": [[76, 80], ["os.path.exists", "os.mkdir", "print"], "function", ["None"], ["", "", "def", "createFolderForSessionTensorboard", "(", "folderForSessionTensorboard", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "folderForSessionTensorboard", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "folderForSessionTensorboard", ")", "\n", "print", "(", "\"\\t>>Created folder to log session's tensorboard metrics/events: \"", ",", "folderForSessionTensorboard", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.make_folders_for_train_session": [[81, 113], ["print", "sessHelpers.createMainOutputFolder", "sessHelpers.createLogsFolder", "sessHelpers.createFolderForCnnModels", "sessHelpers.createFolderForSessionCnnModels", "sessHelpers.createFolderForPredictions", "sessHelpers.createFolderForSessionResults", "sessHelpers.createFolderForSegmAndProbMaps", "sessHelpers.createFolderForFeatures", "sessHelpers.createFolderForTensorboard", "sessHelpers.createFolderForSessionTensorboard"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createMainOutputFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createLogsFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForCnnModels", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionCnnModels", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForPredictions", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionResults", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSegmAndProbMaps", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForFeatures", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForTensorboard", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionTensorboard"], ["", "", "def", "make_folders_for_train_session", "(", "absMainOutputFolder", ",", "sessionName", ")", ":", "\n", "#Create folders for saving the prediction images:", "\n", "    ", "print", "(", "\"Creating necessary folders for training session...\"", ")", "\n", "createMainOutputFolder", "(", "absMainOutputFolder", ")", "\n", "\n", "folderForLogs", "=", "absMainOutputFolder", "+", "\"/logs/\"", "\n", "createLogsFolder", "(", "folderForLogs", ")", "\n", "\n", "folderForCnnModels", "=", "absMainOutputFolder", "+", "\"/saved_models/\"", "\n", "createFolderForCnnModels", "(", "folderForCnnModels", ")", "\n", "folderForSessionCnnModels", "=", "folderForCnnModels", "+", "\"/\"", "+", "sessionName", "+", "\"/\"", "\n", "createFolderForSessionCnnModels", "(", "folderForSessionCnnModels", ")", "\n", "\n", "folderForPredictions", "=", "absMainOutputFolder", "+", "\"/predictions\"", "\n", "createFolderForPredictions", "(", "folderForPredictions", ")", "\n", "folderForSessionResults", "=", "folderForPredictions", "+", "\"/\"", "+", "sessionName", "\n", "createFolderForSessionResults", "(", "folderForSessionResults", ")", "\n", "folderForSegmAndProbMaps", "=", "folderForSessionResults", "+", "\"/predictions/\"", "\n", "createFolderForSegmAndProbMaps", "(", "folderForSegmAndProbMaps", ")", "\n", "folderForFeatures", "=", "folderForSessionResults", "+", "\"/features/\"", "\n", "createFolderForFeatures", "(", "folderForFeatures", ")", "\n", "\n", "folderForTensorboard", "=", "absMainOutputFolder", "+", "\"/tensorboard/\"", "\n", "createFolderForTensorboard", "(", "folderForTensorboard", ")", "\n", "folderForSessionTensorboard", "=", "folderForTensorboard", "+", "\"/\"", "+", "sessionName", "+", "\"/\"", "\n", "createFolderForSessionTensorboard", "(", "folderForSessionTensorboard", ")", "\n", "\n", "return", "[", "folderForLogs", ",", "\n", "folderForSessionCnnModels", ",", "\n", "folderForSegmAndProbMaps", ",", "\n", "folderForFeatures", ",", "\n", "folderForSessionTensorboard", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.makeFoldersNeededForCreateModelSession": [[115, 131], ["print", "sessHelpers.createMainOutputFolder", "sessHelpers.createLogsFolder", "sessHelpers.createFolderForCnnModels", "sessHelpers.createFolderForSessionCnnModels"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createMainOutputFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createLogsFolder", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForCnnModels", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.createFolderForSessionCnnModels"], ["", "def", "makeFoldersNeededForCreateModelSession", "(", "absMainOutputFolder", ",", "modelName", ")", ":", "\n", "#Create folders for saving the prediction images:", "\n", "    ", "print", "(", "\"Creating necessary folders for create-new-model session...\"", ")", "\n", "createMainOutputFolder", "(", "absMainOutputFolder", ")", "\n", "\n", "folderForLogs", "=", "absMainOutputFolder", "+", "\"/logs/\"", "\n", "createLogsFolder", "(", "folderForLogs", ")", "\n", "\n", "folderForCnnModels", "=", "absMainOutputFolder", "+", "\"/saved_models/\"", "\n", "createFolderForCnnModels", "(", "folderForCnnModels", ")", "\n", "\n", "folderForSessionCnnModels", "=", "folderForCnnModels", "+", "\"/\"", "+", "modelName", "+", "\"/\"", "\n", "createFolderForSessionCnnModels", "(", "folderForSessionCnnModels", ")", "\n", "\n", "return", "[", "folderForLogs", ",", "\n", "folderForSessionCnnModels", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.handle_exception_tf_restore": [[133, 156], ["log.print3", "log.print3", "log.print3", "sys.exit", "traceback.format_exc"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "handle_exception_tf_restore", "(", "log", ",", "exc", ")", ":", "\n", "    ", "import", "sys", ",", "traceback", "\n", "log", ".", "print3", "(", "\"\"", ")", "\n", "log", ".", "print3", "(", "\"ERROR: DeepMedic caught exception when trying to load parameters from the given path of a previously saved model.\\n\"", "+", "\"Two reasons are very likely:\\n\"", "+", "\"a) Most probably you passed the wrong path. You need to provide the path to the Tensorflow checkpoint, as expected by Tensorflow.\\n\"", "+", "\"\\t In the traceback further below, Tensorflow may report this error of type [NotFoundError].\\n\"", "+", "\"\\t DeepMedic uses tensorflow checkpoints to save the models. For this, it stores different types of files for every saved timepoint.\\n\"", "+", "\"\\t Those files will be by default in ./examples/output/saved_models, and of the form:\\n\"", "+", "\"\\t filename.datetime.model.ckpt.data-0000-of-0001 \\n\"", "+", "\"\\t filename.datetime.model.ckpt.index \\n\"", "+", "\"\\t filename.datetime.model.ckpt.meta (Maybe this is missing. That's ok.) \\n\"", "+", "\"\\t To load this checkpoint, you have to provide the path, OMMITING the part after the [.ckpt]. I.e., your command should look like:\\n\"", "+", "\"\\t python ./deepMedicRun.py -model path/to/model/config -train path/to/train/config -load filename.datetime.model.ckpt \\n\"", "+", "\"b) You have created a network of different architecture than the one that is being loaded and Tensorflow fails to match their variables.\\n\"", "+", "\"\\t If this is the case, Tensorflow may report it below as error of type [DataLossError]. \\n\"", "+", "\"\\t If you did not mean to change architectures, ensure that you point to the same modelConfig.cfg as used when the saved model was made.\\n\"", "+", "\"\\t If you meant to change architectures, then you will have to create your own script to load the parameters from the saved checkpoint,\"", "+", "\" where the script must describe which variables of the new model match the ones from the saved model.\\n\"", "+", "\"c) The above are \\\"most likely\\\" reasons, but others are possible.\"", "+", "\" Please read the following Tensorflow stacktrace and error report carefully, and debug accordingly...\\n\"", ")", "\n", "log", ".", "print3", "(", "traceback", ".", "format_exc", "(", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.__init__": [[14, 21], ["session.Session._make_session_name"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession._make_session_name"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "\n", "        ", "self", ".", "_cfg", "=", "cfg", "\n", "self", ".", "_session_name", "=", "self", ".", "_make_session_name", "(", ")", "\n", "self", ".", "_main_out_folder_abs", "=", "None", "# Filled by make_output_folders(self)", "\n", "self", ".", "_out_folder_logs", "=", "None", "\n", "self", ".", "_log", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session._make_session_name": [[25, 28], ["None"], "methods", ["None"], ["", "def", "_make_session_name", "(", "self", ")", ":", "\n", "        ", "session_name", "=", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "SESSION_NAME", "]", "if", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "SESSION_NAME", "]", "is", "not", "None", "else", "\"Session\"", "\n", "return", "session_name", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.make_output_folders": [[30, 33], ["NotImplementedError"], "methods", ["None"], ["", "def", "make_output_folders", "(", "self", ")", ":", "\n", "# Overrides must set: self._main_out_folder_abs", "\n", "        ", "raise", "NotImplementedError", "(", "\"Not implemented virtual function.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.setup_logger": [[35, 39], ["deepmedic.logging.loggers.Logger"], "methods", ["None"], ["", "def", "setup_logger", "(", "self", ")", ":", "\n", "        ", "log_filepath", "=", "self", ".", "_out_folder_logs", "+", "\"/\"", "+", "self", ".", "_session_name", "+", "\".txt\"", "\n", "# Create logger.", "\n", "self", ".", "_log", "=", "loggers", ".", "Logger", "(", "log_filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.get_logger": [[40, 42], ["None"], "methods", ["None"], ["", "def", "get_logger", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_log", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.override_file_cfg_with_cmd_line_cfg": [[43, 45], ["session.Session._cfg.override_file_cfg_with_cmd_line_cfg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testConfig.TestConfig.override_file_cfg_with_cmd_line_cfg"], ["", "def", "override_file_cfg_with_cmd_line_cfg", "(", "self", ",", "args", ")", ":", "\n", "        ", "self", ".", "_cfg", ".", "override_file_cfg_with_cmd_line_cfg", "(", "self", ".", "_log", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.compile_session_params_from_cfg": [[46, 48], ["NotImplementedError"], "methods", ["None"], ["", "def", "compile_session_params_from_cfg", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Not implemented virtual function.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.get_abs_path_to_cfg": [[52, 54], ["session.Session._cfg.get_abs_path_to_cfg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg"], ["", "def", "get_abs_path_to_cfg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_cfg", ".", "get_abs_path_to_cfg", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.session.Session.run_session": [[55, 57], ["NotImplementedError"], "methods", ["None"], ["", "def", "run_session", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Not implemented virtual function.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession.__init__": [[23, 28], ["deepmedic.frontEnd.session.Session.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "_out_folder_preds", "=", "None", "\n", "self", ".", "_out_folder_fms", "=", "None", "\n", "\n", "Session", ".", "__init__", "(", "self", ",", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession._make_session_name": [[29, 32], ["deepmedic.frontEnd.configParsing.testSessionParams.TestSessionParameters.get_session_name"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_session_name"], ["", "def", "_make_session_name", "(", "self", ")", ":", "\n", "        ", "session_name", "=", "TestSessionParameters", ".", "get_session_name", "(", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "SESSION_NAME", "]", ")", "\n", "return", "session_name", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession.make_output_folders": [[33, 38], ["deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.sessHelpers.make_folders_for_test_session", "testSession.TestSession.get_abs_path_to_cfg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.make_folders_for_test_session", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg"], ["", "def", "make_output_folders", "(", "self", ")", ":", "\n", "        ", "self", ".", "_main_out_folder_abs", "=", "abs_from_rel_path", "(", "self", ".", "_cfg", "[", "self", ".", "_cfg", ".", "FOLDER_OUTP", "]", ",", "self", ".", "get_abs_path_to_cfg", "(", ")", ")", "\n", "[", "self", ".", "_out_folder_logs", ",", "\n", "self", ".", "_out_folder_preds", ",", "\n", "self", ".", "_out_folder_fms", "]", "=", "make_folders_for_test_session", "(", "self", ".", "_main_out_folder_abs", ",", "self", ".", "_session_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession.compile_session_params_from_cfg": [[40, 56], ["deepmedic.frontEnd.configParsing.testSessionParams.TestSessionParameters", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._params.print_params", "testSession.TestSession._log.print3", "model_params.get_n_classes"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.print_params", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_n_classes"], ["", "def", "compile_session_params_from_cfg", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "(", "model_params", ",", ")", "=", "args", "\n", "\n", "self", ".", "_params", "=", "TestSessionParameters", "(", "self", ".", "_log", ",", "\n", "self", ".", "_main_out_folder_abs", ",", "\n", "self", ".", "_out_folder_preds", ",", "\n", "self", ".", "_out_folder_fms", ",", "\n", "model_params", ".", "get_n_classes", "(", ")", ",", "\n", "self", ".", "_cfg", ")", "\n", "\n", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"============     NEW TESTING SESSION    ===============\"", ")", "\n", "self", ".", "_params", ".", "print_params", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\\n\"", ")", "\n", "\n", "return", "self", ".", "_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession._ask_user_if_test_with_random": [[58, 77], ["six.moves.input", "print", "exit", "six.moves.input", "print", "exit"], "methods", ["None"], ["", "def", "_ask_user_if_test_with_random", "(", "self", ")", ":", "\n", "        ", "user_input", "=", "None", "\n", "try", ":", "\n", "            ", "user_input", "=", "input", "(", "\"WARN:\\t Testing was requested, but without specifying a pretrained, saved model to load.\\n\"", "+", "\"\\t A saved model can be specified via the command line or the test-config file.\\n\"", "+", "\"\\t Please see documentation or run ./deepMedicRun -h for help on how to load a model.\\n\"", "+", "\"\\t Do you wish to continue and test inference with a randomly initialized model? [y/n] : \"", ")", "\n", "while", "user_input", "not", "in", "[", "'y'", ",", "'n'", "]", ":", "\n", "                ", "user_input", "=", "input", "(", "\"Please specify 'y' or 'n': \"", ")", "\n", "", "", "except", ":", "\n", "            ", "print", "(", "\"\\nERROR:\\tTesting was requested, but without specifying a pretrained, saved model to load.\"", "+", "\"\\n\\tTried to ask for user input whether to continue testing with a randomly initialized model, but failed.\"", "+", "\"\\n\\tReason unknown (nohup? remote?).\"", "+", "\"\\n\\tPlease see documentation or run ./deepMedicRun -h for help on how to load a model.\"", "+", "\"\\n\\tExiting.\"", ")", ";", "exit", "(", "1", ")", "\n", "", "if", "user_input", "==", "'y'", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Exiting as requested.\"", ")", ";", "exit", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession.run_session": [[79, 137], ["tensorflow.Graph", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "tensorflow.Graph.as_default", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_test", "tensorflow.compat.v1.get_collection", "tensorflow.compat.v1.train.Saver", "tensorflow.compat.v1.Session", "testSession.TestSession._params.get_path_to_load_model_from", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "deepmedic.routines.testing.inference_on_whole_volumes", "tensorflow.Graph.device", "testSession.TestSession._log.print3", "deepmedic.neuralnet.cnn3d.Cnn3d", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "testSession.TestSession._ask_user_if_test_with_random", "testSession.TestSession._log.print3", "testSession.TestSession._log.print3", "tensorflow.compat.v1.variables_initializer().run", "testSession.TestSession._log.print3", "tensorflow.compat.v1.variable_scope", "deepmedic.neuralnet.cnn3d.Cnn3d.make_cnn_model", "deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "deepmedic.neuralnet.cnn3d.Cnn3d.apply", "tensorflow.compat.v1.ConfigProto", "os.path.isdir", "tensorflow.train.latest_checkpoint", "tensorflow.compat.v1.train.Saver.restore", "testSession.TestSession._log.print3", "model_params.get_inp_dims_hr_path", "str", "deepmedic.frontEnd.sessHelpers.handle_exception_tf_restore", "tensorflow.compat.v1.variables_initializer", "model_params.get_args_for_arch", "testSession.TestSession._params.get_args_for_testing"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_test", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_path_to_load_model_from", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.routines.testing.inference_on_whole_volumes", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.testSession.TestSession._ask_user_if_test_with_random", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.make_cnn_model", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_inp_dims_hr_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.frontEnd.sessHelpers.handle_exception_tf_restore", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_args_for_arch", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_args_for_testing"], ["", "", "def", "run_session", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "(", "sess_device", ",", "\n", "model_params", ",", ")", "=", "args", "\n", "\n", "graphTf", "=", "tf", ".", "Graph", "(", ")", "\n", "\n", "with", "graphTf", ".", "as_default", "(", ")", ":", "\n", "            ", "with", "graphTf", ".", "device", "(", "sess_device", ")", ":", "# Throws an error if GPU is specified but not available.", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Making the CNN graph... ===============\"", ")", "\n", "cnn3d", "=", "Cnn3d", "(", ")", "\n", "with", "tf", ".", "compat", ".", "v1", ".", "variable_scope", "(", "\"net\"", ")", ":", "\n", "                    ", "cnn3d", ".", "make_cnn_model", "(", "*", "model_params", ".", "get_args_for_arch", "(", ")", ")", "# Creates network's graph (no optimizer)", "\n", "inp_plchldrs", ",", "inp_shapes_per_path", "=", "cnn3d", ".", "create_inp_plchldrs", "(", "model_params", ".", "get_inp_dims_hr_path", "(", "'test'", ")", ",", "'test'", ")", "\n", "p_y_given_x", "=", "cnn3d", ".", "apply", "(", "inp_plchldrs", ",", "'infer'", ",", "'test'", ",", "verbose", "=", "True", ",", "log", "=", "self", ".", "_log", ")", "\n", "\n", "", "", "self", ".", "_log", ".", "print3", "(", "\"=========== Compiling the Testing Function ============\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=======================================================\\n\"", ")", "\n", "\n", "cnn3d", ".", "setup_ops_n_feeds_to_test", "(", "self", ".", "_log", ",", "inp_plchldrs", ",", "p_y_given_x", ",", "self", ".", "_params", ".", "inds_fms_per_pathtype_per_layer_to_save", ")", "\n", "# Create the saver", "\n", "coll_vars_net", "=", "tf", ".", "compat", ".", "v1", ".", "get_collection", "(", "tf", ".", "compat", ".", "v1", ".", "GraphKeys", ".", "GLOBAL_VARIABLES", ",", "scope", "=", "\"net\"", ")", "\n", "saver_net", "=", "tf", ".", "compat", ".", "v1", ".", "train", ".", "Saver", "(", "var_list", "=", "coll_vars_net", ")", "# saver_net would suffice", "\n", "# TF2: dict_vars_net = {'net_var'+str(i): v for i, v in enumerate(coll_vars_net)}", "\n", "# TF2: ckpt_net = tf.train.Checkpoint(**dict_vars_net)", "\n", "\n", "", "with", "tf", ".", "compat", ".", "v1", ".", "Session", "(", "graph", "=", "graphTf", ",", "config", "=", "tf", ".", "compat", ".", "v1", ".", "ConfigProto", "(", "log_device_placement", "=", "False", ",", "device_count", "=", "{", "'CPU'", ":", "999", ",", "'GPU'", ":", "99", "}", ")", ")", "as", "sessionTf", ":", "\n", "            ", "file_to_load_params_from", "=", "self", ".", "_params", ".", "get_path_to_load_model_from", "(", ")", "\n", "if", "file_to_load_params_from", "is", "not", "None", ":", "# Load params", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"=========== Loading parameters from specified saved model ===============\"", ")", "\n", "chkpt_fname", "=", "tf", ".", "train", ".", "latest_checkpoint", "(", "file_to_load_params_from", ")", "if", "os", ".", "path", ".", "isdir", "(", "file_to_load_params_from", ")", "else", "file_to_load_params_from", "\n", "self", ".", "_log", ".", "print3", "(", "\"Loading parameters from:\"", "+", "str", "(", "chkpt_fname", ")", ")", "\n", "try", ":", "\n", "                    ", "saver_net", ".", "restore", "(", "sessionTf", ",", "chkpt_fname", ")", "\n", "# TF2: ckpt_net.restore(chkpt_fname)", "\n", "self", ".", "_log", ".", "print3", "(", "\"Parameters were loaded.\"", ")", "\n", "", "except", "Exception", "as", "e", ":", "handle_exception_tf_restore", "(", "self", ".", "_log", ",", "e", ")", "\n", "\n", "", "else", ":", "\n", "                ", "self", ".", "_ask_user_if_test_with_random", "(", ")", "# Asks user whether to continue with randomly initialized model.", "\n", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Initializing network variables  ===============\"", ")", "\n", "tf", ".", "compat", ".", "v1", ".", "variables_initializer", "(", "var_list", "=", "coll_vars_net", ")", ".", "run", "(", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"Model variables were initialized.\"", ")", "\n", "\n", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"======================================================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Testing with the CNN model ===============\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"======================================================\"", ")", "\n", "\n", "res_code", "=", "inference_on_whole_volumes", "(", "*", "(", "[", "sessionTf", ",", "cnn3d", "]", "+", "\n", "self", ".", "_params", ".", "get_args_for_testing", "(", ")", "+", "\n", "[", "inp_shapes_per_path", "]", ")", ")", "\n", "\n", "", "self", ".", "_log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"======================================================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"=========== Testing session finished =================\"", ")", "\n", "self", ".", "_log", ".", "print3", "(", "\"======================================================\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_session_name": [[36, 39], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get_session_name", "(", "sessionName", ")", ":", "\n", "        ", "return", "sessionName", "if", "sessionName", "is", "not", "None", "else", "\"trainSession\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireChannelsTraining": [[42, 53], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireChannelsTraining", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"channelsTraining\\\" needed but not provided in config file. \"", "\n", "\"This parameter should provide paths to files, as many as the channels (modalities) of the task. \"", "\n", "\"Each of the files should contain a list of paths, one for each case to train on. \"", "\n", "\"These paths in a file should point to the .nii(.gz) files that are the corresponding channel for a \"", "\n", "\"patient. Please provide it in the format: channelsTraining = [\\\"path-to-file-for-channel1\\\", ..., \"", "\n", "\"\\\"path-to-file-for-channelN\\\"]. The paths should be given in quotes, separated by commas \"", "\n", "\"(list of strings, python-style). Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireGtLabelsTraining": [[56, 66], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequireGtLabelsTraining", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"gtLabelsTraining\\\" needed but not provided in config file. \"", "\n", "\"This parameter should provide the path to a file. That file should contain a list of paths, \"", "\n", "\"one for each case to train on. These paths should point to the .nii(.gz) files that contain the c\"", "\n", "\"orresponding Ground-Truth labels for a case. Please provide it in the format: \"", "\n", "\"gtLabelsTraining = \\\"path-to-file\\\". The path should be given in quotes (a string, python-style). \"", "\n", "\"Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireBatchsizeTrain": [[69, 73], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequireBatchsizeTrain", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Please provide size of batch size in train-config. See parameter \\'batchsize\\'. Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequirePredefinedLrSched": [[76, 84], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequirePredefinedLrSched", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"typeOfLearningRateSchedule\\\" was set to \\\"predefined\\\", but no predefined schedule \"", "\n", "\"was given. Please specify at which epochs to lower the Learning Rate, by providing the corresponding \"", "\n", "\"parameter in the format: predefinedSchedule = [epoch-for-1st-decrease, ..., epoch-for-last-decrease], \"", "\n", "\"where the epochs are specified by an integer > 0. Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorAutoRequiresValSamples": [[87, 102], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorAutoRequiresValSamples", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"typeOfLearningRateSchedule\\\" was set to \\\"auto\\\". This requires performing validation \"", "\n", "\"on samples throughout training, because this schedule lowers the Learning Rate when validation-accuracy \"", "\n", "\"plateaus. However the parameter \\\"performValidationOnSamplesThroughoutTraining\\\" was set to False in the \"", "\n", "\"configuration file, or was ommitted, which triggers the default value, False! Please set the parameter \"", "\n", "\"performValidationOnSamplesThroughoutTraining = True. You will then need to provide the path to the \"", "\n", "\"channels of the validation cases in the format: channelsValidation = \"", "\n", "\"[\\\"path-to-file-that-lists-paths-to-channel-1-for-every-case\\\", ..., \"", "\n", "\"\\\"path-to-file-that-lists-paths-to-channel-N-for-every-case\\\"] (python style list-of-strings).\"", "\n", "\"\\t Also, you will need to provide the Ground-Truth for the validation cases, in the format:  \"", "\n", "\"gtLabelsValidation = \\\"path-to-file\\\", where the file lists the paths to the GT labels of each validation \"", "\n", "\"case. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireChannelsVal": [[103, 114], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireChannelsVal", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"channelsValidation\\\" was not provided, although it is required to perform validation, \"", "\n", "\"although validation was requested (parameters \\\"performValidationOnSamplesThroughoutTraining\\\" or \"", "\n", "\"\\\"performFullInferenceOnValidationImagesEveryFewEpochs\\\" was set to True). You will need to provide a \"", "\n", "\"list with path to files that list where the channels for each validation case can be found. \"", "\n", "\"The corresponding parameter must be provided in the format: channelsValidation = \"", "\n", "\"[\\\"path-to-file-that-lists-paths-to-channel-1-for-every-case\\\", ..., \"", "\n", "\"\\\"path-to-file-that-lists-paths-to-channel-N-for-every-case\\\"] (python style list-of-strings). Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorReqGtLabelsVal": [[117, 128], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorReqGtLabelsVal", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: Parameter \\\"gtLabelsValidation\\\" was not provided, although it is required to perform validation \"", "\n", "\"on training-samples, which was requested (parameter \\\"performValidationOnSamplesThroughoutTraining\\\" \"", "\n", "\"was set to True). It is also useful so that the DSC score is reported if full-inference on the \"", "\n", "\"validation samples is performed (when parameter \\\"performFullInferenceOnValidationImagesEveryFewEpochs\\\" \"", "\n", "\"is set to True)! You will need to provide the path to a file that lists where the GT labels for each \"", "\n", "\"validation case can be found. The corresponding parameter must be provided in the format: \"", "\n", "\"gtLabelsValidation = \\\"path-to-file-that-lists-GT-labels-for-every-case\\\" (python style string). Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorIntNormZScoreTwoAppliesGiven": [[129, 136], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorIntNormZScoreTwoAppliesGiven", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: In training-config, for the variable (dictionary) norm_zscore_prms,\"", "\n", "\"\\n\\tif ['apply_to_all_channels': True] then it must ['apply_per_channel': None]\"", "\n", "\"\\n\\tOtherwise, requires ['apply_to_all_channels': False] if ['apply_per_channel': [..list..] ]\"", "\n", "\"\\n\\tExiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorReqn_epochsBetweenFullValInfGreaterThan0": [[138, 147], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorReqn_epochsBetweenFullValInfGreaterThan0", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: It was requested to perform full-inference on validation images by setting parameter \"", "\n", "\"\\\"performFullInferenceOnValidationImagesEveryFewEpochs\\\" to True. For this, it is required to specify \"", "\n", "\"the number of epochs between two full-inference procedures. This number was given equal to 0. \"", "\n", "\"Please specify a number greater than 0, in the format: n_epochsBetweenFullInferenceOnValImages = 1 \"", "\n", "\"(Any integer. Default is 1). Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireNamesOfPredictionsVal": [[148, 159], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireNamesOfPredictionsVal", "(", ")", ":", "\n", "        ", "print", "(", "\n", "\"ERROR: It was requested to perform full-inference on validation images by setting parameter \"", "\n", "\"\\\"performFullInferenceOnValidationImagesEveryFewEpochs\\\" to True and then save some of the results \"", "\n", "\"(segmentation maps, probability maps or feature maps), either manually or by default. For this, it is \"", "\n", "\"required to specify the path to a file, which should contain names to give to the results. \"", "\n", "\"Please specify the path to such a file in the format: namesForPredictionsPerCaseVal = \"", "\n", "\"\\\"./validation/validationNamesOfPredictionsSimple.cfg\\\" (python-style string), \"", "\n", "\"or in the column 'pred' of the input csv, if that's the chosen option. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireOptimizer012": [[160, 164], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireOptimizer012", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"sgd0orAdam1orRms2\\\" must be given 0,1 or 2. Omit for default. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomentumClass0Nestov1": [[165, 169], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireMomentumClass0Nestov1", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"classicMom0OrNesterov1\\\" must be given 0 or 1. Omit for default. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomValueBetween01": [[170, 174], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireMomValueBetween01", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"momentumValue\\\" must be given between 0.0 and 1.0 Omit for default. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomNonNorm0Norm1": [[175, 179], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireMomNonNorm0Norm1", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"momNonNorm0orNormalized1\\\" must be given 0 or 1. Omit for default. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.__init__": [[180, 515], ["trainSessionParams.TrainSessionParameters.get_session_name", "cfg.get_abs_path_to_cfg", "deepmedic.dataManagement.samplingType.SamplingType", "deepmedic.dataManagement.samplingType.SamplingType", "len", "len", "trainSessionParams.TrainSessionParameters._make_fpaths_for_preds_and_fms", "trainSessionParams.TrainSessionParameters._backwards_compat_with_deprecated_cfg", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.check_and_adjust_path_to_ckpt", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.get_paths_from_df", "deepmedic.frontEnd.configParsing.utils.parse_fpaths_of_channs_from_filelists", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.set_perc_of_samples_per_cat", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.get_n_sampling_cats", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.set_perc_of_samples_per_cat", "trainSessionParams.TrainSessionParameters.errReqBatchSizeTr", "trainSessionParams.TrainSessionParameters.errReqPredLrSch", "deepmedic.dataManagement.augmentImage.AugmenterAffineParams", "trainSessionParams.TrainSessionParameters.errorAutoRequiresValSamples", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.set_perc_of_samples_per_cat", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.get_n_sampling_cats", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.set_perc_of_samples_per_cat", "trainSessionParams.TrainSessionParameters.errorReqn_epochsBetweenFullValInfGreaterThan0", "trainSessionParams.TrainSessionParameters.errorRequireNamesOfPredictionsVal", "trainSessionParams.TrainSessionParameters.errorIntNormZScoreTwoAppliesGiven", "trainSessionParams.TrainSessionParameters.errorRequireMomentumClass0Nestov1", "trainSessionParams.TrainSessionParameters.errorRequireMomNonNorm0Norm1", "trainSessionParams.TrainSessionParameters.errorRequireMomValueBetween01", "pandas.read_csv", "os.path.dirname", "trainSessionParams.TrainSessionParameters.errReqChansTr", "trainSessionParams.TrainSessionParameters.errReqGtTr", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.get_paths_from_df", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "len", "len", "len", "OSError", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "pandas.read_csv", "os.path.dirname", "deepmedic.frontEnd.configParsing.utils.parse_fpaths_of_channs_from_filelists", "trainSessionParams.TrainSessionParameters.errReqChannsVal", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "trainSessionParams.TrainSessionParameters.errorReqGtLabelsVal", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "trainSessionParams.TrainSessionParameters.errorRequireOptimizer012", "OSError", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_session_name", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters._make_fpaths_for_preds_and_fms", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters._backwards_compat_with_deprecated_cfg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.check_and_adjust_path_to_ckpt", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.get_paths_from_df", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_fpaths_of_channs_from_filelists", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.set_perc_of_samples_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.set_perc_of_samples_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorAutoRequiresValSamples", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.set_perc_of_samples_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.set_perc_of_samples_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorReqn_epochsBetweenFullValInfGreaterThan0", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireNamesOfPredictionsVal", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.errorIntNormZScoreTwoAppliesGiven", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomentumClass0Nestov1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomNonNorm0Norm1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireMomValueBetween01", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.get_paths_from_df", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_fpaths_of_channs_from_filelists", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorReqGtLabelsVal", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.errorRequireOptimizer012", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path"], ["", "def", "__init__", "(", "self", ",", "\n", "log", ",", "\n", "main_outp_folder", ",", "\n", "out_folder_models", ",", "\n", "out_folder_preds", ",", "\n", "out_folder_fms", ",", "\n", "n_classes", ",", "\n", "model_name", ",", "\n", "cfg", ")", ":", "\n", "\n", "# Importants for running session.", "\n", "# From Session:", "\n", "        ", "self", ".", "log", "=", "log", "\n", "self", ".", "main_outp_folder", "=", "main_outp_folder", "# absolute", "\n", "\n", "# From Config:", "\n", "self", ".", "_session_name", "=", "self", ".", "get_session_name", "(", "cfg", "[", "cfg", ".", "SESSION_NAME", "]", ")", "\n", "\n", "abs_path_cfg", "=", "cfg", ".", "get_abs_path_to_cfg", "(", ")", "\n", "path_model", "=", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "SAVED_MODEL", "]", ",", "abs_path_cfg", ")", "if", "cfg", "[", "cfg", ".", "SAVED_MODEL", "]", "is", "not", "None", "else", "None", "\n", "self", ".", "model_ckpt_path", "=", "check_and_adjust_path_to_ckpt", "(", "self", ".", "log", ",", "path_model", ")", "if", "path_model", "is", "not", "None", "else", "None", "\n", "\n", "self", ".", "tensorboardLog", "=", "cfg", "[", "cfg", ".", "TENSORBOARD_LOG", "]", "if", "cfg", "[", "cfg", ".", "TENSORBOARD_LOG", "]", "is", "not", "None", "else", "False", "\n", "\n", "# ====================TRAINING==========================", "\n", "self", ".", "filepath_to_save_models", "=", "out_folder_models", "+", "\"/\"", "+", "model_name", "+", "\".\"", "+", "self", ".", "_session_name", "\n", "\n", "if", "cfg", "[", "cfg", ".", "DATAFRAME_TR", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "csv_fname_train", "=", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "DATAFRAME_TR", "]", ",", "abs_path_cfg", ")", "\n", "try", ":", "\n", "                ", "self", ".", "dataframe_tr", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_fname_train", ",", "skipinitialspace", "=", "True", ")", "\n", "", "except", "OSError", ":", "# FileNotFoundError exception only in Py3, which is child of OSError.", "\n", "                ", "raise", "OSError", "(", "\"File given for dataframe (train) does not exist: \"", "+", "self", ".", "csv_fname_train", ")", "\n", "", "(", "self", ".", "channels_fpaths_tr", ",", "\n", "self", ".", "gt_fpaths_tr", ",", "\n", "self", ".", "roi_fpaths_tr", ",", "\n", "_", ")", "=", "get_paths_from_df", "(", "self", ".", "log", ",", "self", ".", "dataframe_tr", ",", "os", ".", "path", ".", "dirname", "(", "self", ".", "csv_fname_train", ")", ",", "req_gt", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "csv_fname_train", "=", "None", "\n", "self", ".", "dataframe_tr", "=", "None", "\n", "if", "cfg", "[", "cfg", ".", "CHANNELS_TR", "]", "is", "None", ":", "\n", "                ", "self", ".", "errReqChansTr", "(", ")", "\n", "", "if", "cfg", "[", "cfg", ".", "GT_LBLS_TR", "]", "is", "None", ":", "\n", "                ", "self", ".", "errReqGtTr", "(", ")", "\n", "\n", "", "self", ".", "channels_fpaths_tr", "=", "parse_fpaths_of_channs_from_filelists", "(", "cfg", "[", "cfg", ".", "CHANNELS_TR", "]", ",", "abs_path_cfg", ")", "\n", "self", ".", "gt_fpaths_tr", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "GT_LBLS_TR", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "\n", "self", ".", "roi_fpaths_tr", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "ROIS_TR", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "if", "cfg", "[", "cfg", ".", "ROIS_TR", "]", "is", "not", "None", "else", "None", "\n", "\n", "# [Optionals]", "\n", "# ~~~~~~~~~Sampling~~~~~~~", "\n", "", "sampling_type_flag_tr", "=", "cfg", "[", "cfg", ".", "TYPE_OF_SAMPLING_TR", "]", "if", "cfg", "[", "cfg", ".", "TYPE_OF_SAMPLING_TR", "]", "is", "not", "None", "else", "3", "\n", "self", ".", "sampling_type_inst_tr", "=", "samplingType", ".", "SamplingType", "(", "self", ".", "log", ",", "sampling_type_flag_tr", ",", "n_classes", ")", "\n", "if", "sampling_type_flag_tr", "in", "[", "0", ",", "3", "]", "and", "cfg", "[", "cfg", ".", "PROP_OF_SAMPLES_PER_CAT_TR", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "sampling_type_inst_tr", ".", "set_perc_of_samples_per_cat", "(", "cfg", "[", "cfg", ".", "PROP_OF_SAMPLES_PER_CAT_TR", "]", ")", "\n", "", "else", ":", "\n", "            ", "n_sampl_cats_tr", "=", "self", ".", "sampling_type_inst_tr", ".", "get_n_sampling_cats", "(", ")", "\n", "self", ".", "sampling_type_inst_tr", ".", "set_perc_of_samples_per_cat", "(", "\n", "[", "1.0", "/", "n_sampl_cats_tr", "]", "*", "n_sampl_cats_tr", ")", "\n", "\n", "", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_train", "=", "None", "\n", "if", "cfg", "[", "cfg", ".", "WEIGHT_MAPS_PER_CAT_FILEPATHS_TR", "]", "is", "not", "None", ":", "\n", "# [[case1-weightMap1, ..., caseN-weightMap1], [case1-weightMap2,...,caseN-weightMap2]]", "\n", "            ", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_train", "=", "[", "\n", "parse_filelist", "(", "abs_from_rel_path", "(", "weightMapConfPath", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "\n", "for", "weightMapConfPath", "in", "cfg", "[", "cfg", ".", "WEIGHT_MAPS_PER_CAT_FILEPATHS_TR", "]", "\n", "]", "\n", "\n", "# ~~~~~~~~ Training Cycle ~~~~~~~~~~~", "\n", "", "self", ".", "n_epochs", "=", "cfg", "[", "cfg", ".", "NUM_EPOCHS", "]", "if", "cfg", "[", "cfg", ".", "NUM_EPOCHS", "]", "is", "not", "None", "else", "35", "\n", "self", ".", "n_subepochs", "=", "cfg", "[", "cfg", ".", "NUM_SUBEP", "]", "if", "cfg", "[", "cfg", ".", "NUM_SUBEP", "]", "is", "not", "None", "else", "20", "\n", "self", ".", "max_n_cases_per_subep_train", "=", "cfg", "[", "cfg", ".", "NUM_CASES_LOADED_PERSUB", "]", "if", "cfg", "[", "cfg", ".", "NUM_CASES_LOADED_PERSUB", "]", "is", "not", "None", "else", "50", "\n", "self", ".", "n_samples_per_subep_train", "=", "cfg", "[", "cfg", ".", "NUM_TR_SEGMS_LOADED_PERSUB", "]", "if", "cfg", "[", "cfg", ".", "NUM_TR_SEGMS_LOADED_PERSUB", "]", "is", "not", "None", "else", "1000", "\n", "self", ".", "batchsize_train", "=", "cfg", "[", "cfg", ".", "BATCHSIZE_TR", "]", "if", "cfg", "[", "cfg", ".", "BATCHSIZE_TR", "]", "is", "not", "None", "else", "self", ".", "errReqBatchSizeTr", "(", ")", "\n", "self", ".", "num_parallel_proc_sampling", "=", "cfg", "[", "cfg", ".", "NUM_OF_PROC_SAMPL", "]", "if", "cfg", "[", "cfg", ".", "NUM_OF_PROC_SAMPL", "]", "is", "not", "None", "else", "0", "\n", "\n", "# ~~~~~~~ Learning Rate Schedule ~~~~~~~~", "\n", "\n", "assert", "cfg", "[", "cfg", ".", "LR_SCH_TYPE", "]", "in", "[", "'stable'", ",", "'predef'", ",", "'poly'", ",", "'auto'", ",", "'expon'", "]", "\n", "self", ".", "lr_sched_params", "=", "{", "\n", "'type'", ":", "cfg", "[", "cfg", ".", "LR_SCH_TYPE", "]", "if", "cfg", "[", "cfg", ".", "LR_SCH_TYPE", "]", "is", "not", "None", "else", "'poly'", ",", "\n", "'predef'", ":", "{", "'epochs'", ":", "cfg", "[", "cfg", ".", "PREDEF_SCH", "]", ",", "\n", "'div_lr_by'", ":", "cfg", "[", "cfg", ".", "DIV_LR_BY", "]", "if", "cfg", "[", "cfg", ".", "DIV_LR_BY", "]", "is", "not", "None", "else", "2.0", "\n", "}", ",", "\n", "'auto'", ":", "{", "'min_incr_of_val_acc_considered'", ":", "\n", "cfg", "[", "cfg", ".", "AUTO_MIN_INCR_VAL_ACC", "]", "if", "cfg", "[", "cfg", ".", "AUTO_MIN_INCR_VAL_ACC", "]", "is", "not", "None", "else", "0.0", ",", "\n", "'epochs_wait_before_decr'", ":", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "if", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "is", "not", "None", "else", "5", ",", "\n", "'div_lr_by'", ":", "cfg", "[", "cfg", ".", "DIV_LR_BY", "]", "if", "cfg", "[", "cfg", ".", "DIV_LR_BY", "]", "is", "not", "None", "else", "2.0", "\n", "}", ",", "\n", "'poly'", ":", "{", "'epochs_wait_before_decr'", ":", "\n", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "if", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "is", "not", "None", "else", "self", ".", "n_epochs", "/", "3", ",", "\n", "'final_ep_for_sch'", ":", "self", ".", "n_epochs", "\n", "}", ",", "\n", "'expon'", ":", "{", "'epochs_wait_before_decr'", ":", "\n", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "if", "cfg", "[", "cfg", ".", "NUM_EPOCHS_WAIT", "]", "is", "not", "None", "else", "self", ".", "n_epochs", "/", "3", ",", "\n", "'final_ep_for_sch'", ":", "self", ".", "n_epochs", ",", "\n", "'lr_to_reach_at_last_ep'", ":", "\n", "cfg", "[", "cfg", ".", "EXPON_SCH", "]", "[", "0", "]", "if", "cfg", "[", "cfg", ".", "EXPON_SCH", "]", "is", "not", "None", "else", "1.0", "/", "(", "2", "**", "8", ")", ",", "\n", "'mom_to_reach_at_last_ep'", ":", "cfg", "[", "cfg", ".", "EXPON_SCH", "]", "[", "1", "]", "if", "cfg", "[", "cfg", ".", "EXPON_SCH", "]", "is", "not", "None", "else", "0.9", "\n", "}", "\n", "}", "\n", "# Predefined.", "\n", "if", "self", ".", "lr_sched_params", "[", "'type'", "]", "==", "'predef'", "and", "self", ".", "lr_sched_params", "[", "'predef'", "]", "[", "'epochs'", "]", "is", "None", ":", "\n", "            ", "self", ".", "errReqPredLrSch", "(", ")", "\n", "\n", "# ~~~~~~~~~~~~~~ Augmentation~~~~~~~~~~~~~~", "\n", "# Image level", "\n", "", "self", ".", "augm_img_prms_tr", "=", "{", "'affine'", ":", "None", "}", "# If var is None, no augm at all.", "\n", "if", "cfg", "[", "cfg", ".", "AUGM_IMG_PRMS_TR", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "augm_img_prms_tr", "[", "'affine'", "]", "=", "AugmenterAffineParams", "(", "cfg", "[", "cfg", ".", "AUGM_IMG_PRMS_TR", "]", "[", "'affine'", "]", ")", "\n", "\n", "# Patch/Segment level", "\n", "", "self", ".", "augm_sample_prms_tr", "=", "{", "'hist_dist'", ":", "None", ",", "'reflect'", ":", "None", ",", "'rotate90'", ":", "None", "}", "\n", "if", "cfg", "[", "cfg", ".", "AUGM_SAMPLE_PRMS_TR", "]", "is", "not", "None", ":", "\n", "            ", "for", "key", "in", "cfg", "[", "cfg", ".", "AUGM_SAMPLE_PRMS_TR", "]", ":", "\n", "# For exact form of parameters, see ./deepmedic/dataManagement/augmentation.py", "\n", "                ", "self", ".", "augm_sample_prms_tr", "[", "key", "]", "=", "cfg", "[", "cfg", ".", "AUGM_SAMPLE_PRMS_TR", "]", "[", "key", "]", "\n", "\n", "# ===================VALIDATION========================", "\n", "", "", "self", ".", "val_on_samples_during_train", "=", "cfg", "[", "cfg", ".", "PERFORM_VAL_SAMPLES", "]", "if", "cfg", "[", "cfg", ".", "PERFORM_VAL_SAMPLES", "]", "is", "not", "None", "else", "False", "\n", "if", "self", ".", "lr_sched_params", "[", "'type'", "]", "==", "'auto'", "and", "not", "self", ".", "val_on_samples_during_train", ":", "\n", "            ", "self", ".", "errorAutoRequiresValSamples", "(", ")", "\n", "", "self", ".", "val_on_whole_volumes", "=", "cfg", "[", "cfg", ".", "PERFORM_VAL_INFERENCE", "]", "if", "cfg", "[", "cfg", ".", "PERFORM_VAL_INFERENCE", "]", "is", "not", "None", "else", "False", "\n", "\n", "# Input:", "\n", "if", "(", "not", "self", ".", "val_on_samples_during_train", ")", "and", "(", "not", "self", ".", "val_on_whole_volumes", ")", ":", "\n", "            ", "self", ".", "csv_fname_val", "=", "None", "\n", "self", ".", "dataframe_val", "=", "None", "\n", "self", ".", "channels_fpaths_val", "=", "[", "]", "\n", "self", ".", "gt_fpaths_val", "=", "None", "\n", "self", ".", "roi_fpaths_val", "=", "None", "\n", "self", ".", "out_preds_fnames_val", "=", "None", "\n", "", "elif", "cfg", "[", "cfg", ".", "DATAFRAME_VAL", "]", "is", "not", "None", ":", "# doing one of validations, and given dataframe.", "\n", "            ", "self", ".", "csv_fname_val", "=", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "DATAFRAME_VAL", "]", ",", "abs_path_cfg", ")", "\n", "try", ":", "\n", "                ", "self", ".", "dataframe_val", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_fname_val", ",", "skipinitialspace", "=", "True", ")", "\n", "", "except", "OSError", ":", "# FileNotFoundError exception only in Py3, which is child of OSError.", "\n", "                ", "raise", "OSError", "(", "\"File given for dataframe (validation) does not exist: \"", "+", "self", ".", "csv_fname_val", ")", "\n", "", "(", "self", ".", "channels_fpaths_val", ",", "\n", "self", ".", "gt_fpaths_val", ",", "\n", "self", ".", "roi_fpaths_val", ",", "\n", "self", ".", "out_preds_fnames_val", ")", "=", "get_paths_from_df", "(", "self", ".", "log", ",", "\n", "self", ".", "dataframe_val", ",", "\n", "os", ".", "path", ".", "dirname", "(", "self", ".", "csv_fname_val", ")", ",", "\n", "req_gt", "=", "True", ")", "\n", "", "else", ":", "# Doing one of validations, and not given dataframe.", "\n", "            ", "self", ".", "csv_fname_val", "=", "None", "\n", "self", ".", "dataframe_val", "=", "None", "\n", "if", "cfg", "[", "cfg", ".", "CHANNELS_VAL", "]", ":", "\n", "                ", "self", ".", "channels_fpaths_val", "=", "parse_fpaths_of_channs_from_filelists", "(", "cfg", "[", "cfg", ".", "CHANNELS_VAL", "]", ",", "abs_path_cfg", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "errReqChannsVal", "(", ")", "\n", "\n", "", "self", ".", "gt_fpaths_val", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "GT_LBLS_VAL", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "if", "cfg", "[", "cfg", ".", "GT_LBLS_VAL", "]", "is", "not", "None", "else", "self", ".", "errorReqGtLabelsVal", "(", ")", "\n", "self", ".", "roi_fpaths_val", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "ROIS_VAL", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "if", "cfg", "[", "cfg", ".", "ROIS_VAL", "]", "is", "not", "None", "else", "None", "\n", "self", ".", "out_preds_fnames_val", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "FNAMES_PREDS_VAL", "]", ",", "abs_path_cfg", ")", ")", "if", "cfg", "[", "cfg", ".", "FNAMES_PREDS_VAL", "]", "else", "None", "\n", "\n", "# ~~~~~Validation on Samples~~~~~~~~", "\n", "", "self", ".", "n_samples_per_subep_val", "=", "cfg", "[", "cfg", ".", "NUM_VAL_SEGMS_LOADED_PERSUB", "]", "if", "cfg", "[", "cfg", ".", "NUM_VAL_SEGMS_LOADED_PERSUB", "]", "is", "not", "None", "else", "3000", "\n", "self", ".", "batchsize_val_samples", "=", "cfg", "[", "cfg", ".", "BATCHSIZE_VAL_SAMPL", "]", "if", "cfg", "[", "cfg", ".", "BATCHSIZE_VAL_SAMPL", "]", "is", "not", "None", "else", "50", "\n", "\n", "# ~~~~~~~~~ Sampling (Validation) ~~~~~~~~~~~", "\n", "sampling_type_flag_val", "=", "cfg", "[", "cfg", ".", "TYPE_OF_SAMPLING_VAL", "]", "if", "cfg", "[", "cfg", ".", "TYPE_OF_SAMPLING_VAL", "]", "is", "not", "None", "else", "1", "\n", "self", ".", "sampling_type_inst_val", "=", "samplingType", ".", "SamplingType", "(", "self", ".", "log", ",", "sampling_type_flag_val", ",", "n_classes", ")", "\n", "if", "sampling_type_flag_val", "in", "[", "0", ",", "3", "]", "and", "cfg", "[", "cfg", ".", "PROP_OF_SAMPLES_PER_CAT_VAL", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "sampling_type_inst_val", ".", "set_perc_of_samples_per_cat", "(", "cfg", "[", "cfg", ".", "PROP_OF_SAMPLES_PER_CAT_VAL", "]", ")", "\n", "", "else", ":", "\n", "            ", "n_sampl_cats_val", "=", "self", ".", "sampling_type_inst_val", ".", "get_n_sampling_cats", "(", ")", "\n", "self", ".", "sampling_type_inst_val", ".", "set_perc_of_samples_per_cat", "(", "[", "1.0", "/", "n_sampl_cats_val", "]", "*", "n_sampl_cats_val", ")", "\n", "\n", "", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_val", "=", "None", "\n", "if", "cfg", "[", "cfg", ".", "WEIGHT_MAPS_PER_CAT_FILEPATHS_VAL", "]", "is", "not", "None", ":", "\n", "# [[case1-weightMap1, ..., caseN-weightMap1], [case1-weightMap2,...,caseN-weightMap2]]", "\n", "            ", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_val", "=", "[", "\n", "parse_filelist", "(", "abs_from_rel_path", "(", "wmap_conf_path", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "\n", "for", "wmap_conf_path", "in", "cfg", "[", "cfg", ".", "WEIGHT_MAPS_PER_CAT_FILEPATHS_VAL", "]", "\n", "]", "\n", "\n", "# ~~~~~~Full inference on validation image~~~~~~", "\n", "", "self", ".", "num_epochs_between_val_on_whole_volumes", "=", "cfg", "[", "cfg", ".", "NUM_EPOCHS_BETWEEN_VAL_INF", "]", "if", "cfg", "[", "cfg", ".", "NUM_EPOCHS_BETWEEN_VAL_INF", "]", "is", "not", "None", "else", "1", "\n", "if", "self", ".", "num_epochs_between_val_on_whole_volumes", "==", "0", "and", "self", ".", "val_on_whole_volumes", ":", "\n", "            ", "self", ".", "errorReqn_epochsBetweenFullValInfGreaterThan0", "(", ")", "\n", "\n", "", "self", ".", "batchsize_val_whole", "=", "cfg", "[", "cfg", ".", "BATCHSIZE_VAL_WHOLE", "]", "if", "cfg", "[", "cfg", ".", "BATCHSIZE_VAL_WHOLE", "]", "is", "not", "None", "else", "10", "\n", "\n", "# predictions", "\n", "self", ".", "save_segms_val", "=", "cfg", "[", "cfg", ".", "SAVE_SEGM_VAL", "]", "if", "cfg", "[", "cfg", ".", "SAVE_SEGM_VAL", "]", "is", "not", "None", "else", "True", "\n", "self", ".", "save_probs_per_cl_val", "=", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS_VAL", "]", "if", "(", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS_VAL", "]", "is", "not", "None", "and", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS_VAL", "]", "!=", "[", "]", ")", "else", "[", "True", "]", "*", "n_classes", "\n", "self", ".", "suffixes_for_outp_val", "=", "cfg", "[", "cfg", ".", "SUFFIX_SEGM_PROB_VAL", "]", "if", "cfg", "[", "cfg", ".", "SUFFIX_SEGM_PROB_VAL", "]", "is", "not", "None", "else", "{", "\"segm\"", ":", "\"Segm\"", ",", "\"prob\"", ":", "\"ProbMapClass\"", "}", "\n", "# features:", "\n", "self", ".", "save_fms_flag_val", "=", "cfg", "[", "cfg", ".", "SAVE_INDIV_FMS_VAL", "]", "if", "cfg", "[", "cfg", ".", "SAVE_INDIV_FMS_VAL", "]", "is", "not", "None", "else", "False", "\n", "if", "self", ".", "save_fms_flag_val", "is", "True", ":", "\n", "            ", "inds_fms", "=", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_NORMAL_VAL", "]", "]", "+", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_SUBSAMPLED_VAL", "]", "]", "+", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_FC_VAL", "]", "]", "\n", "# By default, save none.", "\n", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", "=", "[", "item", "if", "item", "is", "not", "None", "else", "[", "]", "for", "item", "in", "inds_fms", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", "=", "None", "\n", "\n", "# Output:", "\n", "# Filled by call to self.makeFilepathsForPredictionsAndFeatures()", "\n", "", "self", ".", "out_preds_fpaths_val", "=", "None", "\n", "self", ".", "out_fms_fpaths_val", "=", "None", "\n", "# Checks on output params:", "\n", "if", "not", "self", ".", "out_preds_fnames_val", "and", "self", ".", "val_on_whole_volumes", "and", "(", "self", ".", "save_segms_val", "or", "True", "in", "self", ".", "save_probs_per_cl_val", "\n", "or", "self", ".", "save_fms_flag_val", ")", ":", "\n", "            ", "self", ".", "errorRequireNamesOfPredictionsVal", "(", ")", "\n", "\n", "# ===================== PRE-PROCESSING ======================", "\n", "# === Data compatibility checks ===", "\n", "", "self", ".", "run_input_checks", "=", "cfg", "[", "cfg", ".", "RUN_INP_CHECKS", "]", "if", "cfg", "[", "cfg", ".", "RUN_INP_CHECKS", "]", "is", "not", "None", "else", "True", "\n", "# == Padding ==", "\n", "self", ".", "pad_input", "=", "cfg", "[", "cfg", ".", "PAD_INPUT", "]", "if", "cfg", "[", "cfg", ".", "PAD_INPUT", "]", "is", "not", "None", "else", "True", "\n", "# == Normalization ==", "\n", "norm_zscore_prms", "=", "{", "'apply_to_all_channels'", ":", "False", ",", "# True/False", "\n", "'apply_per_channel'", ":", "None", ",", "# Must be None if above True. Else, List Bool per channel", "\n", "'cutoff_percents'", ":", "None", ",", "# None or [low, high], each from 0.0 to 100. Eg [5.,95.]", "\n", "'cutoff_times_std'", ":", "None", ",", "# None or [low, high], each positive Float. Eg [3.,3.]", "\n", "'cutoff_below_mean'", ":", "False", "}", "\n", "if", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", "is", "not", "None", ":", "\n", "            ", "for", "key", "in", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", ":", "\n", "                ", "norm_zscore_prms", "[", "key", "]", "=", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", "[", "key", "]", "\n", "", "", "if", "norm_zscore_prms", "[", "'apply_to_all_channels'", "]", "and", "norm_zscore_prms", "[", "'apply_per_channel'", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "errorIntNormZScoreTwoAppliesGiven", "(", ")", "\n", "", "if", "norm_zscore_prms", "[", "'apply_per_channel'", "]", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "norm_zscore_prms", "[", "'apply_per_channel'", "]", ")", "==", "len", "(", "cfg", "[", "cfg", ".", "CHANNELS_TR", "]", ")", "# num channels", "\n", "# Aggregate params from all types of normalization:", "\n", "# norm_prms = None : No int normalization will be performed.", "\n", "# norm_prms['verbose_lvl']: 0: No logging, 1: Type of cutoffs and timing 2: Stats.", "\n", "", "self", ".", "norm_prms", "=", "{", "'verbose_lvl'", ":", "cfg", "[", "cfg", ".", "NORM_VERB_LVL", "]", "if", "cfg", "[", "cfg", ".", "NORM_VERB_LVL", "]", "is", "not", "None", "else", "0", ",", "\n", "'zscore'", ":", "norm_zscore_prms", "}", "\n", "\n", "# ============= OTHERS ==========", "\n", "# Others useful internally or for reporting:", "\n", "self", ".", "n_cases_tr", "=", "len", "(", "self", ".", "channels_fpaths_tr", ")", "\n", "self", ".", "n_cases_val", "=", "len", "(", "self", ".", "channels_fpaths_val", ")", "\n", "\n", "# ========= HIDDENS =============", "\n", "# no config allowed for these at the moment:", "\n", "\n", "# Re-weight samples in the cost function *on a per-class basis*: Type of re-weighting and training schedule.", "\n", "# E.g. to exclude a class, or counter class imbalance.", "\n", "# \"type\": string/None, \"prms\": any/None, \"schedule\": [ min_epoch, max_epoch ]", "\n", "# Type, prms combinations: \"freq\", None || \"per_c\", [0., 2., 1., ...] (as many as classes)", "\n", "# \"schedule\": Constant before epoch [0], linear change towards equal weight (=1) until epoch [1],", "\n", "# constant equal weights (=1) afterwards.", "\n", "self", ".", "reweight_classes_in_cost", "=", "cfg", "[", "cfg", ".", "W_C_IN_COST", "]", "if", "cfg", "[", "cfg", ".", "W_C_IN_COST", "]", "is", "not", "None", "else", "{", "\"type\"", ":", "None", ",", "\"prms\"", ":", "None", ",", "\"schedule\"", ":", "[", "0", ",", "self", ".", "n_epochs", "]", "}", "\n", "if", "self", ".", "reweight_classes_in_cost", "[", "\"type\"", "]", "==", "\"per_c\"", ":", "\n", "            ", "assert", "len", "(", "self", ".", "reweight_classes_in_cost", "[", "\"prms\"", "]", ")", "==", "n_classes", "\n", "\n", "", "self", ".", "_make_fpaths_for_preds_and_fms", "(", "out_folder_preds", ",", "out_folder_fms", ")", "\n", "\n", "# ====Optimization=====", "\n", "self", ".", "learningRate", "=", "cfg", "[", "cfg", ".", "LRATE", "]", "if", "cfg", "[", "cfg", ".", "LRATE", "]", "is", "not", "None", "else", "0.001", "\n", "self", ".", "optimizerSgd0Adam1Rms2", "=", "cfg", "[", "cfg", ".", "OPTIMIZER", "]", "if", "cfg", "[", "cfg", ".", "OPTIMIZER", "]", "is", "not", "None", "else", "2", "\n", "if", "self", ".", "optimizerSgd0Adam1Rms2", "==", "0", ":", "\n", "            ", "self", ".", "b1Adam", "=", "\"placeholder\"", "\n", "self", ".", "b2Adam", "=", "\"placeholder\"", "\n", "self", ".", "eAdam", "=", "\"placeholder\"", "\n", "self", ".", "rhoRms", "=", "\"placeholder\"", "\n", "self", ".", "eRms", "=", "\"placeholder\"", "\n", "", "elif", "self", ".", "optimizerSgd0Adam1Rms2", "==", "1", ":", "\n", "            ", "self", ".", "b1Adam", "=", "cfg", "[", "cfg", ".", "B1_ADAM", "]", "if", "cfg", "[", "cfg", ".", "B1_ADAM", "]", "is", "not", "None", "else", "0.9", "# default in paper and seems good", "\n", "self", ".", "b2Adam", "=", "cfg", "[", "cfg", ".", "B2_ADAM", "]", "if", "cfg", "[", "cfg", ".", "B2_ADAM", "]", "is", "not", "None", "else", "0.999", "# default in paper and seems good", "\n", "self", ".", "eAdam", "=", "cfg", "[", "cfg", ".", "EPS_ADAM", "]", "if", "cfg", "[", "cfg", ".", "EPS_ADAM", "]", "is", "not", "None", "else", "10", "**", "(", "-", "8", ")", "\n", "self", ".", "rhoRms", "=", "\"placeholder\"", "\n", "self", ".", "eRms", "=", "\"placeholder\"", "\n", "", "elif", "self", ".", "optimizerSgd0Adam1Rms2", "==", "2", ":", "\n", "            ", "self", ".", "b1Adam", "=", "\"placeholder\"", "\n", "self", ".", "b2Adam", "=", "\"placeholder\"", "\n", "self", ".", "eAdam", "=", "\"placeholder\"", "\n", "self", ".", "rhoRms", "=", "cfg", "[", "cfg", ".", "RHO_RMS", "]", "if", "cfg", "[", "cfg", ".", "RHO_RMS", "]", "is", "not", "None", "else", "0.9", "# default in paper and seems good", "\n", "# 1e-6 was the default in the paper, but blew up the gradients in first try. Never tried 1e-5 yet.", "\n", "self", ".", "eRms", "=", "cfg", "[", "cfg", ".", "EPS_RMS", "]", "if", "cfg", "[", "cfg", ".", "EPS_RMS", "]", "is", "not", "None", "else", "10", "**", "(", "-", "4", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "errorRequireOptimizer012", "(", ")", "\n", "\n", "", "self", ".", "classicMom0Nesterov1", "=", "cfg", "[", "cfg", ".", "MOM_TYPE", "]", "if", "cfg", "[", "cfg", ".", "MOM_TYPE", "]", "is", "not", "None", "else", "1", "\n", "if", "self", ".", "classicMom0Nesterov1", "not", "in", "[", "0", ",", "1", "]", ":", "\n", "            ", "self", ".", "errorRequireMomentumClass0Nestov1", "(", ")", "\n", "", "self", ".", "momNonNormalized0Normalized1", "=", "cfg", "[", "cfg", ".", "MOM_NORM_NONNORM", "]", "if", "cfg", "[", "cfg", ".", "MOM_NORM_NONNORM", "]", "is", "not", "None", "else", "1", "\n", "if", "self", ".", "momNonNormalized0Normalized1", "not", "in", "[", "0", ",", "1", "]", ":", "\n", "            ", "self", ".", "errorRequireMomNonNorm0Norm1", "(", ")", "\n", "", "self", ".", "momentumValue", "=", "cfg", "[", "cfg", ".", "MOM", "]", "if", "cfg", "[", "cfg", ".", "MOM", "]", "is", "not", "None", "else", "0.6", "\n", "if", "self", ".", "momentumValue", "<", "0.", "or", "self", ".", "momentumValue", ">", "1", ":", "\n", "            ", "self", ".", "errorRequireMomValueBetween01", "(", ")", "\n", "\n", "# ==Regularization==", "\n", "", "self", ".", "L1_reg_weight", "=", "cfg", "[", "cfg", ".", "L1_REG", "]", "if", "cfg", "[", "cfg", ".", "L1_REG", "]", "is", "not", "None", "else", "0.000001", "\n", "self", ".", "L2_reg_weight", "=", "cfg", "[", "cfg", ".", "L2_REG", "]", "if", "cfg", "[", "cfg", ".", "L2_REG", "]", "is", "not", "None", "else", "0.0001", "\n", "\n", "# ============= HIDDENS ==============", "\n", "# Indices of layers that should not be trained (kept fixed).", "\n", "layers_to_freeze_per_pathtype", "=", "[", "cfg", "[", "cfg", ".", "LAYERS_TO_FREEZE_NORM", "]", ",", "\n", "cfg", "[", "cfg", ".", "LAYERS_TO_FREEZE_SUBS", "]", ",", "\n", "cfg", "[", "cfg", ".", "LAYERS_TO_FREEZE_FC", "]", "]", "\n", "inds_layers_freeze_norm", "=", "[", "l", "-", "1", "for", "l", "in", "layers_to_freeze_per_pathtype", "[", "0", "]", "]", "if", "layers_to_freeze_per_pathtype", "[", "0", "]", "is", "not", "None", "else", "[", "]", "\n", "inds_layers_freeze_subs", "=", "[", "l", "-", "1", "for", "l", "in", "layers_to_freeze_per_pathtype", "[", "1", "]", "]", "if", "layers_to_freeze_per_pathtype", "[", "1", "]", "is", "not", "None", "else", "inds_layers_freeze_norm", "\n", "inds_layers_freeze_fc", "=", "[", "l", "-", "1", "for", "l", "in", "layers_to_freeze_per_pathtype", "[", "2", "]", "]", "if", "layers_to_freeze_per_pathtype", "[", "2", "]", "is", "not", "None", "else", "[", "]", "\n", "# Three sublists, one per pathway type: Normal, Subsampled, FC. eg: [[0,1,2],[0,1,2],[]", "\n", "self", ".", "inds_layers_per_pathtype_freeze", "=", "[", "inds_layers_freeze_norm", ",", "inds_layers_freeze_subs", ",", "inds_layers_freeze_fc", "]", "\n", "\n", "self", ".", "losses_and_weights", "=", "cfg", "[", "cfg", ".", "LOSSES_WEIGHTS", "]", "if", "cfg", "[", "cfg", ".", "LOSSES_WEIGHTS", "]", "is", "not", "None", "else", "{", "\"xentr\"", ":", "1.0", ",", "\n", "\"iou\"", ":", "None", ",", "\n", "\"dsc\"", ":", "None", "}", "\n", "assert", "True", "in", "[", "self", ".", "losses_and_weights", "[", "k", "]", "is", "not", "None", "for", "k", "in", "[", "\"xentr\"", ",", "\"iou\"", ",", "\"dsc\"", "]", "]", "\n", "\n", "self", ".", "_backwards_compat_with_deprecated_cfg", "(", "cfg", ")", "\n", "\n", "\"\"\"\n        #NOTES: variables that have to do with number of pathways: \n                self.inds_layers_per_pathtype_freeze (=\"all\" always currently. Hardcoded)\n                inds_fms_per_pathtype_per_layer_to_save (Repeat subsampled!)\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters._backwards_compat_with_deprecated_cfg": [[516, 527], ["trainSessionParams.TrainSessionParameters.log.print3"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "_backwards_compat_with_deprecated_cfg", "(", "self", ",", "cfg", ")", ":", "\n", "# Augmentation", "\n", "        ", "if", "cfg", "[", "cfg", ".", "REFL_AUGM_PER_AXIS", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "augm_sample_prms_tr", "[", "'reflect'", "]", "=", "[", "0.5", "if", "bool", "else", "0.", "for", "bool", "in", "cfg", "[", "cfg", ".", "REFL_AUGM_PER_AXIS", "]", "]", "\n", "", "if", "cfg", "[", "cfg", ".", "PERF_INT_AUGM_BOOL", "]", "is", "True", ":", "\n", "            ", "self", ".", "augm_sample_prms_tr", "[", "'hist_dist'", "]", "=", "{", "\n", "'shift'", ":", "{", "'mu'", ":", "cfg", "[", "cfg", ".", "INT_AUGM_SHIF_MUSTD", "]", "[", "0", "]", ",", "'std'", ":", "cfg", "[", "cfg", ".", "INT_AUGM_SHIF_MUSTD", "]", "[", "1", "]", "}", ",", "\n", "'scale'", ":", "{", "'mu'", ":", "cfg", "[", "cfg", ".", "INT_AUGM_MULT_MUSTD", "]", "[", "0", "]", ",", "'std'", ":", "cfg", "[", "cfg", ".", "INT_AUGM_MULT_MUSTD", "]", "[", "1", "]", "}", "}", "\n", "", "if", "cfg", "[", "cfg", ".", "OLD_AUGM_SAMPLE_PRMS_TR", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "log", ".", "print3", "(", "\n", "\"ERROR: In training's config, variable \\'augm_params_tr\\' is deprecated. \"", "\n", "\"Replace it with \\'augm_sample_prms_tr\\'.\"", ")", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters._make_fpaths_for_preds_and_fms": [[529, 547], ["range", "trainSessionParams.TrainSessionParameters.out_preds_fpaths_val.append", "trainSessionParams.TrainSessionParameters.out_fms_fpaths_val.append", "range", "trainSessionParams.TrainSessionParameters.out_preds_fpaths_val.append", "trainSessionParams.TrainSessionParameters.out_fms_fpaths_val.append", "trainSessionParams.TrainSessionParameters.out_preds_fpaths_val.append", "trainSessionParams.TrainSessionParameters.out_fms_fpaths_val.append", "str", "str"], "methods", ["None"], ["", "", "def", "_make_fpaths_for_preds_and_fms", "(", "self", ",", "out_folder_preds", ",", "out_folder_fms", ")", ":", "\n", "# TODO: Merge with same in testSessionParams", "\n", "        ", "self", ".", "out_preds_fpaths_val", "=", "[", "]", "\n", "self", ".", "out_fms_fpaths_val", "=", "[", "]", "\n", "if", "self", ".", "out_preds_fnames_val", "is", "not", "None", ":", "# standard behavior", "\n", "            ", "for", "case_i", "in", "range", "(", "self", ".", "n_cases_val", ")", ":", "\n", "                ", "fpaths_for_case_pred", "=", "out_folder_preds", "+", "\"/\"", "+", "self", ".", "out_preds_fnames_val", "[", "case_i", "]", "\n", "self", ".", "out_preds_fpaths_val", ".", "append", "(", "fpaths_for_case_pred", ")", "\n", "fpaths_for_case_fms", "=", "out_folder_fms", "+", "\"/\"", "+", "self", ".", "out_preds_fnames_val", "[", "case_i", "]", "\n", "self", ".", "out_fms_fpaths_val", ".", "append", "(", "fpaths_for_case_fms", ")", "\n", "", "", "else", ":", "# Names for predictions not given. Special handling...", "\n", "            ", "if", "self", ".", "n_cases_val", ">", "1", ":", "# Many cases, create corresponding namings for files.", "\n", "                ", "for", "case_i", "in", "range", "(", "self", ".", "n_cases_val", ")", ":", "\n", "                    ", "self", ".", "out_preds_fpaths_val", ".", "append", "(", "out_folder_preds", "+", "\"/pred_case\"", "+", "str", "(", "case_i", ")", "+", "\".nii.gz\"", ")", "\n", "self", ".", "out_fms_fpaths_val", ".", "append", "(", "out_folder_preds", "+", "\"/pred_case\"", "+", "str", "(", "case_i", ")", "+", "\".nii.gz\"", ")", "\n", "", "", "else", ":", "# Only one case. Just give the output prediction folder, the io.py will save output accordingly.", "\n", "                ", "self", ".", "out_preds_fpaths_val", ".", "append", "(", "out_folder_preds", ")", "\n", "self", ".", "out_fms_fpaths_val", ".", "append", "(", "out_folder_preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_path_to_load_model_from": [[548, 550], ["None"], "methods", ["None"], ["", "", "", "def", "get_path_to_load_model_from", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "model_ckpt_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_tensorboard_bool": [[551, 553], ["None"], "methods", ["None"], ["", "def", "get_tensorboard_bool", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tensorboardLog", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.print_params": [[554, 692], ["logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.get_sampling_cats_as_str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.get_perc_to_sample_per_cat", "str", "str", "str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.get_sampling_cats_as_str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.get_perc_to_sample_per_cat", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.get_type_as_int", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.get_type_as_int", "str", "str", "str", "str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_tr.get_type_as_str", "trainSessionParams.TrainSessionParameters.sampling_type_inst_val.get_type_as_str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_sampling_cats_as_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_perc_to_sample_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_sampling_cats_as_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_perc_to_sample_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_int", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_int", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_str"], ["", "def", "print_params", "(", "self", ")", ":", "\n", "        ", "logPrint", "=", "self", ".", "log", ".", "print3", "\n", "logPrint", "(", "\"\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"========= PARAMETERS FOR THIS TRAINING SESSION ==============\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"Session's name = \"", "+", "str", "(", "self", ".", "_session_name", ")", ")", "\n", "logPrint", "(", "\"Model will be loaded from save = \"", "+", "str", "(", "self", ".", "model_ckpt_path", ")", ")", "\n", "logPrint", "(", "\"~~Output~~\"", ")", "\n", "logPrint", "(", "\"Main output folder = \"", "+", "str", "(", "self", ".", "main_outp_folder", ")", ")", "\n", "logPrint", "(", "\"Log performance metrics for tensorboard = \"", "+", "str", "(", "self", ".", "tensorboardLog", ")", ")", "\n", "logPrint", "(", "\"Path and filename to save trained models = \"", "+", "str", "(", "self", ".", "filepath_to_save_models", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~Generic Information~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Number of Cases for Training = \"", "+", "str", "(", "self", ".", "n_cases_tr", ")", ")", "\n", "logPrint", "(", "\"Number of Cases for Validation = \"", "+", "str", "(", "self", ".", "n_cases_val", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~Training parameters~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Dataframe (csv) filename = \"", "+", "str", "(", "self", ".", "csv_fname_train", ")", ")", "\n", "logPrint", "(", "\"Filepaths to Channels of the Training Cases = \"", "+", "str", "(", "self", ".", "channels_fpaths_tr", ")", ")", "\n", "logPrint", "(", "\"Filepaths to Ground-Truth labels of the Training Cases = \"", "+", "str", "(", "self", ".", "gt_fpaths_tr", ")", ")", "\n", "logPrint", "(", "\"Filepaths to ROI Masks of the Training Cases = \"", "+", "str", "(", "self", ".", "roi_fpaths_tr", ")", ")", "\n", "\n", "logPrint", "(", "\"~~ Sampling (train) ~~\"", ")", "\n", "logPrint", "(", "\"Type of Sampling = \"", "+", "str", "(", "self", ".", "sampling_type_inst_tr", ".", "get_type_as_str", "(", ")", ")", "+", "\n", "\" (\"", "+", "str", "(", "self", ".", "sampling_type_inst_tr", ".", "get_type_as_int", "(", ")", ")", "+", "\")\"", ")", "\n", "logPrint", "(", "\"Sampling Categories = \"", "+", "str", "(", "self", ".", "sampling_type_inst_tr", ".", "get_sampling_cats_as_str", "(", ")", ")", ")", "\n", "logPrint", "(", "\"Percent of Samples to extract per Sampling Category = \"", "+", "\n", "str", "(", "self", ".", "sampling_type_inst_tr", ".", "get_perc_to_sample_per_cat", "(", ")", ")", ")", "\n", "logPrint", "(", "\"Paths to weight-Maps for sampling of each category = \"", "+", "\n", "str", "(", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_train", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Training Cycle~~\"", ")", "\n", "logPrint", "(", "\"Number of Epochs = \"", "+", "str", "(", "self", ".", "n_epochs", ")", ")", "\n", "logPrint", "(", "\"Number of Subepochs per epoch = \"", "+", "str", "(", "self", ".", "n_subepochs", ")", ")", "\n", "logPrint", "(", "\"Number of cases to load per Subepoch (for extracting the samples for this subepoch) = \"", "+", "\n", "str", "(", "self", ".", "max_n_cases_per_subep_train", ")", ")", "\n", "logPrint", "(", "\"Number of Segments loaded per subepoch for Training = \"", "+", "str", "(", "self", ".", "n_samples_per_subep_train", ")", "+", "\n", "\". NOTE: This number of segments divided by the batch-size defines the number of \"", "\n", "\"optimization-iterations that will be performed every subepoch!\"", ")", "\n", "logPrint", "(", "\"Batch size (train) = \"", "+", "str", "(", "self", ".", "batchsize_train", ")", ")", "\n", "logPrint", "(", "\"Number of parallel processes for sampling = \"", "+", "str", "(", "self", ".", "num_parallel_proc_sampling", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Learning Rate Schedule~~\"", ")", "\n", "logPrint", "(", "\"Type of schedule = \"", "+", "str", "(", "self", ".", "lr_sched_params", "[", "'type'", "]", ")", ")", "\n", "logPrint", "(", "\"[Predef] Predefined schedule of epochs when the LR will be lowered = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'predef'", "]", "[", "'epochs'", "]", ")", ")", "\n", "logPrint", "(", "\"[Predef] When decreasing Learning Rate, divide LR by = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'predef'", "]", "[", "'div_lr_by'", "]", ")", ")", "\n", "logPrint", "(", "\"[Poly] Initial epochs to wait before lowering LR = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'poly'", "]", "[", "'epochs_wait_before_decr'", "]", ")", ")", "\n", "logPrint", "(", "\"[Poly] Final epoch for the schedule = \"", "+", "str", "(", "self", ".", "lr_sched_params", "[", "'poly'", "]", "[", "'final_ep_for_sch'", "]", ")", ")", "\n", "logPrint", "(", "\"[Auto] Initial epochs to wait before lowering LR = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'auto'", "]", "[", "'epochs_wait_before_decr'", "]", ")", ")", "\n", "logPrint", "(", "\"[Auto] When decreasing Learning Rate, divide LR by = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'auto'", "]", "[", "'div_lr_by'", "]", ")", ")", "\n", "logPrint", "(", "\"[Auto] Minimum increase in validation accuracy (0. to 1.) that resets the waiting counter = \"", "+", "\n", "str", "(", "self", ".", "lr_sched_params", "[", "'auto'", "]", "[", "'min_incr_of_val_acc_considered'", "]", ")", ")", "\n", "logPrint", "(", "\"[Expon] (Deprecated) parameters = \"", "+", "str", "(", "self", ".", "lr_sched_params", "[", "'expon'", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Data Augmentation During Training~~\"", ")", "\n", "logPrint", "(", "\"Image level augmentation:\"", ")", "\n", "logPrint", "(", "\"Parameters for image-level augmentation: \"", "+", "str", "(", "self", ".", "augm_img_prms_tr", ")", ")", "\n", "if", "self", ".", "augm_img_prms_tr", "is", "not", "None", ":", "\n", "            ", "logPrint", "(", "\"\\t affine: \"", "+", "str", "(", "self", ".", "augm_img_prms_tr", "[", "'affine'", "]", ")", ")", "\n", "", "logPrint", "(", "\"Patch level augmentation:\"", ")", "\n", "logPrint", "(", "\"Mu and std for shift and scale of histograms = \"", "+", "str", "(", "self", ".", "augm_sample_prms_tr", "[", "'hist_dist'", "]", ")", ")", "\n", "logPrint", "(", "\"Probabilities of reflecting each axis = \"", "+", "str", "(", "self", ".", "augm_sample_prms_tr", "[", "'reflect'", "]", ")", ")", "\n", "logPrint", "(", "\"Probabilities of rotating planes 0/90/180/270 degrees = \"", "+", "str", "(", "self", ".", "augm_sample_prms_tr", "[", "'rotate90'", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~Validation parameters~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Perform Validation on Samples throughout training? = \"", "+", "str", "(", "self", ".", "val_on_samples_during_train", ")", ")", "\n", "logPrint", "(", "\"Perform Full Inference on validation cases every few epochs? = \"", "+", "str", "(", "self", ".", "val_on_whole_volumes", ")", ")", "\n", "logPrint", "(", "\"Dataframe (csv) filename = \"", "+", "str", "(", "self", ".", "csv_fname_val", ")", ")", "\n", "logPrint", "(", "\"Filepaths to Channels of Validation Cases = \"", "+", "str", "(", "self", ".", "channels_fpaths_val", ")", ")", "\n", "logPrint", "(", "\"Filepaths to Ground-Truth labels of the Validation Cases = \"", "+", "str", "(", "self", ".", "gt_fpaths_val", ")", ")", "\n", "logPrint", "(", "\"Filepaths to ROI masks for Validation Cases = \"", "+", "str", "(", "self", ".", "roi_fpaths_val", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~Validation on Samples throughout Training~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Number of Segments loaded per subepoch for Validation = \"", "+", "str", "(", "self", ".", "n_samples_per_subep_val", ")", ")", "\n", "logPrint", "(", "\"Batch size (val on samples) = \"", "+", "str", "(", "self", ".", "batchsize_val_samples", ")", ")", "\n", "\n", "logPrint", "(", "\"~~ Sampling (val) ~~\"", ")", "\n", "logPrint", "(", "\"Type of Sampling = \"", "+", "str", "(", "self", ".", "sampling_type_inst_val", ".", "get_type_as_str", "(", ")", ")", "+", "\" (\"", "+", "\n", "str", "(", "self", ".", "sampling_type_inst_val", ".", "get_type_as_int", "(", ")", ")", "+", "\")\"", ")", "\n", "logPrint", "(", "\"Sampling Categories = \"", "+", "str", "(", "self", ".", "sampling_type_inst_val", ".", "get_sampling_cats_as_str", "(", ")", ")", ")", "\n", "logPrint", "(", "\"Percent of Samples to extract per Sampling Category = \"", "+", "\n", "str", "(", "self", ".", "sampling_type_inst_val", ".", "get_perc_to_sample_per_cat", "(", ")", ")", ")", "\n", "logPrint", "(", "\"Paths to weight-maps for sampling of each category = \"", "+", "\n", "str", "(", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_val", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~Validation with Full Inference on Validation Cases~~~~~\"", ")", "\n", "logPrint", "(", "\"Perform Full-Inference on Val. cases every that many epochs = \"", "+", "\n", "str", "(", "self", ".", "num_epochs_between_val_on_whole_volumes", ")", ")", "\n", "logPrint", "(", "\"Batch size (val on whole volumes) = \"", "+", "str", "(", "self", ".", "batchsize_val_whole", ")", ")", "\n", "logPrint", "(", "\"~~Predictions (segmentations and prob maps on val. cases)~~\"", ")", "\n", "logPrint", "(", "\"Save Segmentations = \"", "+", "str", "(", "self", ".", "save_segms_val", ")", ")", "\n", "logPrint", "(", "\"Save Probability Maps for each class = \"", "+", "str", "(", "self", ".", "save_probs_per_cl_val", ")", ")", "\n", "logPrint", "(", "\"Filepaths to save results per case = \"", "+", "str", "(", "self", ".", "out_preds_fpaths_val", ")", ")", "\n", "logPrint", "(", "\"Suffixes with which to save segmentations and probability maps = \"", "+", "\n", "str", "(", "self", ".", "suffixes_for_outp_val", ")", ")", "\n", "logPrint", "(", "\"~~Feature Maps~~\"", ")", "\n", "logPrint", "(", "\"Save Feature Maps = \"", "+", "str", "(", "self", ".", "save_fms_flag_val", ")", ")", "\n", "logPrint", "(", "\"Min/Max Indices of FMs to visualise per pathway-type and per layer = \"", "+", "\n", "str", "(", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", ")", ")", "\n", "logPrint", "(", "\"Filepaths to save FMs per case = \"", "+", "str", "(", "self", ".", "out_fms_fpaths_val", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Optimization~~\"", ")", "\n", "logPrint", "(", "\"Initial Learning rate = \"", "+", "str", "(", "self", ".", "learningRate", ")", ")", "\n", "logPrint", "(", "\"Optimizer to use: SGD(0), Adam(1), RmsProp(2) = \"", "+", "str", "(", "self", ".", "optimizerSgd0Adam1Rms2", ")", ")", "\n", "logPrint", "(", "\n", "\"Parameters for Adam: b1= \"", "+", "str", "(", "self", ".", "b1Adam", ")", "+", "\", b2=\"", "+", "str", "(", "self", ".", "b2Adam", ")", "+", "\", e= \"", "+", "str", "(", "self", ".", "eAdam", ")", ")", "\n", "logPrint", "(", "\"Parameters for RmsProp: rho= \"", "+", "str", "(", "self", ".", "rhoRms", ")", "+", "\", e= \"", "+", "str", "(", "self", ".", "eRms", ")", ")", "\n", "logPrint", "(", "\"Momentum Type: Classic (0) or Nesterov (1) = \"", "+", "str", "(", "self", ".", "classicMom0Nesterov1", ")", ")", "\n", "logPrint", "(", "\"Momentum Non-Normalized (0) or Normalized (1) = \"", "+", "str", "(", "self", ".", "momNonNormalized0Normalized1", ")", ")", "\n", "logPrint", "(", "\"Momentum Value = \"", "+", "str", "(", "self", ".", "momentumValue", ")", ")", "\n", "logPrint", "(", "\"~~Costs~~\"", ")", "\n", "logPrint", "(", "\"Loss functions and their weights = \"", "+", "str", "(", "self", ".", "losses_and_weights", ")", ")", "\n", "logPrint", "(", "\"Reweight samples in cost on a per-class basis = \"", "+", "str", "(", "self", ".", "reweight_classes_in_cost", ")", ")", "\n", "logPrint", "(", "\"L1 Regularization term = \"", "+", "str", "(", "self", ".", "L1_reg_weight", ")", ")", "\n", "logPrint", "(", "\"L2 Regularization term = \"", "+", "str", "(", "self", ".", "L2_reg_weight", ")", ")", "\n", "logPrint", "(", "\"~~Freeze Weights of Certain Layers~~\"", ")", "\n", "logPrint", "(", "\"Indices of layers from each type of pathway that will be kept fixed (first layer is 0):\"", ")", "\n", "logPrint", "(", "\"Normal pathway's layers to freeze = \"", "+", "str", "(", "self", ".", "inds_layers_per_pathtype_freeze", "[", "0", "]", ")", ")", "\n", "logPrint", "(", "\"Subsampled pathway's layers to freeze = \"", "+", "str", "(", "self", ".", "inds_layers_per_pathtype_freeze", "[", "1", "]", ")", ")", "\n", "logPrint", "(", "\"FC pathway's layers to freeze = \"", "+", "str", "(", "self", ".", "inds_layers_per_pathtype_freeze", "[", "2", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~ PRE-PROCESSING ~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"~~Data Compabitibility Checks~~\"", ")", "\n", "logPrint", "(", "\"Check whether input data has correct format (can slow down process) = \"", "+", "str", "(", "self", ".", "run_input_checks", ")", ")", "\n", "logPrint", "(", "\"~~Padding~~\"", ")", "\n", "logPrint", "(", "\"Pad Input Images = \"", "+", "str", "(", "self", ".", "pad_input", ")", ")", "\n", "logPrint", "(", "\"~~Intensity Normalization~~\"", ")", "\n", "logPrint", "(", "\"Verbosity level = \"", "+", "str", "(", "self", ".", "norm_prms", "[", "'verbose_lvl'", "]", ")", ")", "\n", "logPrint", "(", "\"Z-Score parameters = \"", "+", "str", "(", "self", ".", "norm_prms", "[", "'zscore'", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"========== Done with printing session's parameters ==========\"", ")", "\n", "logPrint", "(", "\"=============================================================\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_train_routine": [[693, 751], ["None"], "methods", ["None"], ["", "def", "get_args_for_train_routine", "(", "self", ")", ":", "\n", "\n", "        ", "args", "=", "[", "self", ".", "log", ",", "\n", "self", ".", "filepath_to_save_models", ",", "\n", "\n", "self", ".", "val_on_samples_during_train", ",", "\n", "{", "\"segm\"", ":", "self", ".", "save_segms_val", ",", "\"prob\"", ":", "self", ".", "save_probs_per_cl_val", "}", ",", "\n", "\n", "self", ".", "out_preds_fpaths_val", ",", "\n", "self", ".", "suffixes_for_outp_val", ",", "\n", "\n", "self", ".", "channels_fpaths_tr", ",", "\n", "self", ".", "channels_fpaths_val", ",", "\n", "\n", "self", ".", "gt_fpaths_tr", ",", "\n", "self", ".", "gt_fpaths_val", ",", "\n", "\n", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_train", ",", "\n", "self", ".", "paths_to_wmaps_per_sampl_cat_per_subj_val", ",", "\n", "\n", "self", ".", "roi_fpaths_tr", ",", "\n", "self", ".", "roi_fpaths_val", ",", "\n", "\n", "self", ".", "n_epochs", ",", "\n", "self", ".", "n_subepochs", ",", "\n", "self", ".", "max_n_cases_per_subep_train", ",", "\n", "self", ".", "n_samples_per_subep_train", ",", "\n", "self", ".", "n_samples_per_subep_val", ",", "\n", "self", ".", "num_parallel_proc_sampling", ",", "\n", "\n", "# -------Sampling Type---------", "\n", "self", ".", "sampling_type_inst_tr", ",", "\n", "self", ".", "sampling_type_inst_val", ",", "\n", "self", ".", "batchsize_train", ",", "\n", "self", ".", "batchsize_val_samples", ",", "\n", "self", ".", "batchsize_val_whole", ",", "\n", "\n", "# -------Data Augmentation-------", "\n", "self", ".", "augm_img_prms_tr", ",", "\n", "self", ".", "augm_sample_prms_tr", ",", "\n", "\n", "# --- Validation on whole volumes ---", "\n", "self", ".", "val_on_whole_volumes", ",", "\n", "self", ".", "num_epochs_between_val_on_whole_volumes", ",", "\n", "\n", "# --------For FM visualisation---------", "\n", "self", ".", "save_fms_flag_val", ",", "\n", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", ",", "\n", "self", ".", "out_fms_fpaths_val", ",", "\n", "\n", "# --- Data compatibility checks ---", "\n", "self", ".", "run_input_checks", ",", "\n", "\n", "# -------- Pre-Processing ------", "\n", "self", ".", "pad_input", ",", "\n", "self", ".", "norm_prms", "\n", "]", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_trainer": [[752, 764], ["None"], "methods", ["None"], ["", "def", "get_args_for_trainer", "(", "self", ")", ":", "\n", "        ", "args", "=", "[", "self", ".", "log", ",", "\n", "self", ".", "inds_layers_per_pathtype_freeze", ",", "\n", "self", ".", "losses_and_weights", ",", "\n", "# Regularisation", "\n", "self", ".", "L1_reg_weight", ",", "\n", "self", ".", "L2_reg_weight", ",", "\n", "# Cost Schedules", "\n", "# Weighting Classes differently in the CNN's cost function during training:", "\n", "self", ".", "reweight_classes_in_cost", "\n", "]", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.TrainSessionParameters.get_args_for_optimizer": [[765, 782], ["None"], "methods", ["None"], ["", "def", "get_args_for_optimizer", "(", "self", ")", ":", "\n", "        ", "args", "=", "[", "self", ".", "log", ",", "\n", "self", ".", "optimizerSgd0Adam1Rms2", ",", "\n", "\n", "self", ".", "lr_sched_params", ",", "\n", "\n", "self", ".", "learningRate", ",", "\n", "self", ".", "momentumValue", ",", "\n", "self", ".", "classicMom0Nesterov1", ",", "\n", "self", ".", "momNonNormalized0Normalized1", ",", "\n", "self", ".", "b1Adam", ",", "\n", "self", ".", "b2Adam", ",", "\n", "self", ".", "eAdam", ",", "\n", "self", ".", "rhoRms", ",", "\n", "self", ".", "eRms", "\n", "]", "\n", "return", "args", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.get_default": [[19, 27], ["Exception"], "function", ["None"], ["def", "get_default", "(", "value", ",", "default", ",", "required", "=", "False", ")", ":", "\n", "    ", "if", "value", "is", "not", "None", ":", "\n", "        ", "return", "value", "\n", "", "else", ":", "\n", "        ", "if", "default", "is", "not", "None", "or", "not", "required", ":", "\n", "            ", "return", "default", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'Required Element'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.get_config_value": [[29, 31], ["trainSessionParams.get_default"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainSessionParams.get_default"], ["", "", "", "def", "get_config_value", "(", "cfg", ",", "elem", ")", ":", "\n", "    ", "return", "get_default", "(", "cfg", "[", "elem", ".", "name", "]", ",", "elem", ".", "default", ",", "elem", ".", "required", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.__init__": [[13, 19], ["print", "exec", "config.Config._check_for_deprecated_cfg", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelConfig.ModelConfig._check_for_deprecated_cfg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.None.setup.read"], ["    ", "def", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", ":", "\n", "        ", "self", ".", "_configStruct", "=", "{", "}", "\n", "self", ".", "_abs_path_to_cfg", "=", "abs_path_to_cfg", "# for printing later.", "\n", "print", "(", "\"Given configuration file: \"", ",", "self", ".", "_abs_path_to_cfg", ")", "\n", "exec", "(", "open", "(", "self", ".", "_abs_path_to_cfg", ")", ".", "read", "(", ")", ",", "self", ".", "_configStruct", ")", "\n", "self", ".", "_check_for_deprecated_cfg", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.__getitem__": [[20, 22], ["config.Config.get"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "# overriding the [] operator.", "\n", "        ", "return", "self", ".", "get", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get": [[23, 25], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "string1", ")", ":", "\n", "        ", "return", "self", ".", "_configStruct", "[", "string1", "]", "if", "string1", "in", "self", ".", "_configStruct", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg": [[26, 28], ["None"], "methods", ["None"], ["", "def", "get_abs_path_to_cfg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_abs_path_to_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config._check_for_deprecated_cfg": [[29, 31], ["None"], "methods", ["None"], ["", "def", "_check_for_deprecated_cfg", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.override_file_cfg_with_cmd_line_cfg": [[32, 34], ["None"], "methods", ["None"], ["", "def", "override_file_cfg_with_cmd_line_cfg", "(", "self", ",", "log", ",", "args", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelConfig.ModelConfig.__init__": [[65, 67], ["deepmedic.frontEnd.configParsing.config.Config.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", ":", "\n", "        ", "Config", ".", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelConfig.ModelConfig._check_for_deprecated_cfg": [[69, 79], ["modelConfig.ModelConfig.get", "print", "exit", "modelConfig.ModelConfig.get", "print", "exit"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get"], ["", "def", "_check_for_deprecated_cfg", "(", "self", ")", ":", "\n", "        ", "msg_part1", "=", "\"ERROR: Deprecated input to the config: [\"", "\n", "msg_part2", "=", "\"]. Please update config and use the new corresponding variable \"", "\n", "msg_part3", "=", "\"]. Exiting.\"", "\n", "if", "self", ".", "get", "(", "\"initializeClassic0orDelving1\"", ")", "is", "not", "None", ":", "\n", "            ", "print", "(", "msg_part1", "+", "\"initializeClassic0orDelving1\"", "+", "msg_part2", "+", "\"convWeightsInit\"", "+", "msg_part3", ")", "\n", "exit", "(", "1", ")", "\n", "", "if", "self", ".", "get", "(", "\"relu0orPrelu1\"", ")", "is", "not", "None", ":", "\n", "            ", "print", "(", "msg_part1", "+", "\"relu0orPrelu1\"", "+", "msg_part2", "+", "\"activationFunction\"", "+", "msg_part3", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainConfig.TrainConfig.__init__": [[126, 128], ["deepmedic.frontEnd.configParsing.config.Config.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", ":", "\n", "        ", "Config", ".", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.trainConfig.TrainConfig.override_file_cfg_with_cmd_line_cfg": [[130, 138], ["deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "os.getcwd", "trainConfig.TrainConfig.get", "log.print3", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "override_file_cfg_with_cmd_line_cfg", "(", "self", ",", "log", ",", "args", ")", ":", "\n", "        ", "if", "args", ".", "saved_model", "is", "not", "None", ":", "\n", "            ", "abs_path_model_cmd_line", "=", "abs_from_rel_path", "(", "args", ".", "saved_model", ",", "os", ".", "getcwd", "(", ")", ")", "\n", "if", "self", ".", "get", "(", "self", ".", "SAVED_MODEL", ")", "is", "not", "None", ":", "\n", "                ", "log", ".", "print3", "(", "\"WARN: A model to load was specified both in the command line and in the train-config file!\"", "\n", "\"\\n\\t The input by the command line will be used: \"", "+", "str", "(", "abs_path_model_cmd_line", ")", ")", "\n", "\n", "", "self", ".", "_configStruct", "[", "self", ".", "SAVED_MODEL", "]", "=", "abs_path_model_cmd_line", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_session_name": [[19, 22], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get_session_name", "(", "sessionName", ")", ":", "\n", "        ", "return", "sessionName", "if", "sessionName", "is", "not", "None", "else", "\"testSession\"", "\n", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.errorIntNormZScoreTwoAppliesGiven": [[22, 29], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorIntNormZScoreTwoAppliesGiven", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: In testing-config, for the variable (dictionary) norm_zscore_prms,\"", "\n", "\"\\n\\tif ['apply_to_all_channels': True] then it must ['apply_per_channel': None]\"", "\n", "\"\\n\\tOtherwise, requires ['apply_to_all_channels': False] if ['apply_per_channel': [..list..] ]\"", "\n", "\"\\n\\tExiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.__init__": [[31, 126], ["testSessionParams.TestSessionParameters.get_session_name", "cfg.get_abs_path_to_cfg", "len", "testSessionParams.TestSessionParameters._make_fpaths_for_preds_and_fms", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.check_and_adjust_path_to_ckpt", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.get_paths_from_df", "deepmedic.frontEnd.configParsing.utils.parse_fpaths_of_channs_from_filelists", "testSessionParams.TestSessionParameters.errorIntNormZScoreTwoAppliesGiven", "pandas.read_csv", "os.path.dirname", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "deepmedic.frontEnd.configParsing.utils.parse_filelist", "len", "len", "OSError", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "deepmedic.frontEnd.configParsing.utils.abs_from_rel_path"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_session_name", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get_abs_path_to_cfg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters._make_fpaths_for_preds_and_fms", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.check_and_adjust_path_to_ckpt", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.get_paths_from_df", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_fpaths_of_channs_from_filelists", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.errorIntNormZScoreTwoAppliesGiven", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path"], ["", "def", "__init__", "(", "self", ",", "\n", "log", ",", "\n", "main_outp_folder", ",", "\n", "out_folder_preds", ",", "\n", "out_folder_fms", ",", "\n", "n_classes", ",", "\n", "cfg", ")", ":", "\n", "# Importants for running session.", "\n", "# From Session:", "\n", "        ", "self", ".", "log", "=", "log", "\n", "self", ".", "main_outp_folder", "=", "main_outp_folder", "\n", "\n", "# From test config:", "\n", "self", ".", "_session_name", "=", "self", ".", "get_session_name", "(", "cfg", "[", "cfg", ".", "SESSION_NAME", "]", ")", "\n", "\n", "abs_path_cfg", "=", "cfg", ".", "get_abs_path_to_cfg", "(", ")", "\n", "path_model", "=", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "SAVED_MODEL", "]", ",", "abs_path_cfg", ")", "if", "cfg", "[", "cfg", ".", "SAVED_MODEL", "]", "is", "not", "None", "else", "None", "\n", "self", ".", "model_ckpt_path", "=", "check_and_adjust_path_to_ckpt", "(", "self", ".", "log", ",", "path_model", ")", "if", "path_model", "is", "not", "None", "else", "None", "\n", "\n", "# Input:", "\n", "if", "cfg", "[", "cfg", ".", "DATAFRAME", "]", "is", "not", "None", ":", "# get data from csv/dataframe", "\n", "            ", "self", ".", "csv_fname", "=", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "DATAFRAME", "]", ",", "abs_path_cfg", ")", "\n", "try", ":", "\n", "                ", "self", ".", "dataframe", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_fname", ",", "skipinitialspace", "=", "True", ")", "\n", "", "except", "OSError", ":", "# FileNotFoundError exception only in Py3, which is child of OSError.", "\n", "                ", "raise", "OSError", "(", "\"File given for dataframe does not exist: \"", "+", "self", ".", "csv_fname", ")", "\n", "", "(", "self", ".", "channels_fpaths", ",", "\n", "self", ".", "gt_fpaths", ",", "\n", "self", ".", "roi_fpaths", ",", "\n", "self", ".", "out_preds_fnames", ")", "=", "get_paths_from_df", "(", "self", ".", "log", ",", "\n", "self", ".", "dataframe", ",", "\n", "os", ".", "path", ".", "dirname", "(", "self", ".", "csv_fname", ")", ",", "\n", "req_gt", "=", "False", ")", "\n", "", "else", ":", "# Get data input data from old variables.", "\n", "            ", "self", ".", "csv_fname", "=", "None", "\n", "self", ".", "dataframe", "=", "None", "\n", "self", ".", "channels_fpaths", "=", "parse_fpaths_of_channs_from_filelists", "(", "cfg", "[", "cfg", ".", "CHANNELS", "]", ",", "abs_path_cfg", ")", "\n", "self", ".", "gt_fpaths", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "GT_LBLS", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "if", "cfg", "[", "cfg", ".", "GT_LBLS", "]", "is", "not", "None", "else", "None", "\n", "self", ".", "roi_fpaths", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "ROIS", "]", ",", "abs_path_cfg", ")", ",", "make_abs", "=", "True", ")", "if", "cfg", "[", "cfg", ".", "ROIS", "]", "is", "not", "None", "else", "None", "\n", "self", ".", "out_preds_fnames", "=", "parse_filelist", "(", "abs_from_rel_path", "(", "cfg", "[", "cfg", ".", "FNAMES_PREDS", "]", ",", "abs_path_cfg", ")", ")", "if", "cfg", "[", "cfg", ".", "FNAMES_PREDS", "]", "is", "not", "None", "else", "None", "\n", "\n", "#predictions", "\n", "", "self", ".", "save_segms", "=", "cfg", "[", "cfg", ".", "SAVE_SEGM", "]", "if", "cfg", "[", "cfg", ".", "SAVE_SEGM", "]", "is", "not", "None", "else", "True", "\n", "self", ".", "save_probs_per_cl", "=", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS", "]", "if", "(", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS", "]", "is", "not", "None", "and", "cfg", "[", "cfg", ".", "SAVE_PROBMAPS_PER_CLASS", "]", "!=", "[", "]", ")", "else", "[", "True", "]", "*", "n_classes", "\n", "self", ".", "out_preds_fpaths", "=", "None", "# Filled by call to self._make_fpaths_for_preds_and_fms()", "\n", "self", ".", "suffixes_for_outp", "=", "cfg", "[", "cfg", ".", "SUFFIX_SEGM_PROB", "]", "if", "cfg", "[", "cfg", ".", "SUFFIX_SEGM_PROB", "]", "is", "not", "None", "else", "{", "\"segm\"", ":", "\"Segm\"", ",", "\"prob\"", ":", "\"ProbMapClass\"", "}", "\n", "self", ".", "batchsize", "=", "cfg", "[", "cfg", ".", "BATCHSIZE", "]", "if", "cfg", "[", "cfg", ".", "BATCHSIZE", "]", "is", "not", "None", "else", "10", "\n", "# features:", "\n", "self", ".", "save_fms_flag", "=", "cfg", "[", "cfg", ".", "SAVE_INDIV_FMS", "]", "if", "cfg", "[", "cfg", ".", "SAVE_INDIV_FMS", "]", "is", "not", "None", "else", "False", "\n", "if", "self", ".", "save_fms_flag", ":", "\n", "            ", "inds_fms", "=", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_NORMAL", "]", "]", "+", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_SUBSAMPLED", "]", "]", "+", "[", "cfg", "[", "cfg", ".", "INDICES_OF_FMS_TO_SAVE_FC", "]", "]", "\n", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", "=", "[", "item", "if", "item", "is", "not", "None", "else", "[", "]", "for", "item", "in", "inds_fms", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", "=", "None", "\n", "", "self", ".", "out_fms_fpaths", "=", "None", "#Filled by call to self._make_fpaths_for_preds_and_fms()", "\n", "\n", "# ===================== PRE-PROCESSING ======================", "\n", "# === Data compatibility checks ===", "\n", "self", ".", "run_input_checks", "=", "cfg", "[", "cfg", ".", "RUN_INP_CHECKS", "]", "if", "cfg", "[", "cfg", ".", "RUN_INP_CHECKS", "]", "is", "not", "None", "else", "True", "\n", "# == Padding ==", "\n", "self", ".", "pad_input", "=", "cfg", "[", "cfg", ".", "PAD_INPUT", "]", "if", "cfg", "[", "cfg", ".", "PAD_INPUT", "]", "is", "not", "None", "else", "True", "\n", "# == Normalization ==", "\n", "norm_zscore_prms", "=", "{", "'apply_to_all_channels'", ":", "False", ",", "# True/False", "\n", "'apply_per_channel'", ":", "None", ",", "# Must be None if above True. Else, List Bool per channel", "\n", "'cutoff_percents'", ":", "None", ",", "# None or [low, high], each from 0.0 to 100. Eg [5.,95.]", "\n", "'cutoff_times_std'", ":", "None", ",", "# None or [low, high], each positive Float. Eg [3.,3.]", "\n", "'cutoff_below_mean'", ":", "False", "}", "\n", "if", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", "is", "not", "None", ":", "\n", "            ", "for", "key", "in", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", ":", "\n", "                ", "norm_zscore_prms", "[", "key", "]", "=", "cfg", "[", "cfg", ".", "NORM_ZSCORE_PRMS", "]", "[", "key", "]", "\n", "", "", "if", "norm_zscore_prms", "[", "'apply_to_all_channels'", "]", "and", "norm_zscore_prms", "[", "'apply_per_channel'", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "errorIntNormZScoreTwoAppliesGiven", "(", ")", "\n", "", "if", "norm_zscore_prms", "[", "'apply_per_channel'", "]", "is", "not", "None", ":", "\n", "            ", "assert", "len", "(", "norm_zscore_prms", "[", "'apply_per_channel'", "]", ")", "==", "len", "(", "cfg", "[", "cfg", ".", "CHANNELS", "]", ")", "# num channels", "\n", "# Aggregate params from all types of normalization:", "\n", "# norm_prms = None : No int normalization will be performed.", "\n", "# norm_prms['verbose_lvl']: 0: No logging, 1: Type of cutoffs and timing 2: Stats.", "\n", "", "self", ".", "norm_prms", "=", "{", "'verbose_lvl'", ":", "cfg", "[", "cfg", ".", "NORM_VERB_LVL", "]", "if", "cfg", "[", "cfg", ".", "NORM_VERB_LVL", "]", "is", "not", "None", "else", "0", ",", "\n", "'zscore'", ":", "norm_zscore_prms", "}", "\n", "\n", "# ============= OTHERS =============", "\n", "# Others useful internally or for reporting:", "\n", "self", ".", "n_cases", "=", "len", "(", "self", ".", "channels_fpaths", ")", "\n", "\n", "# ============= HIDDENS =============", "\n", "# no config allowed for these at the moment:", "\n", "self", ".", "_make_fpaths_for_preds_and_fms", "(", "out_folder_preds", ",", "out_folder_fms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters._make_fpaths_for_preds_and_fms": [[127, 145], ["range", "testSessionParams.TestSessionParameters.out_preds_fpaths.append", "testSessionParams.TestSessionParameters.out_fms_fpaths.append", "range", "testSessionParams.TestSessionParameters.out_preds_fpaths.append", "testSessionParams.TestSessionParameters.out_fms_fpaths.append", "testSessionParams.TestSessionParameters.out_preds_fpaths.append", "testSessionParams.TestSessionParameters.out_fms_fpaths.append", "str", "str"], "methods", ["None"], ["", "def", "_make_fpaths_for_preds_and_fms", "(", "self", ",", "out_folder_preds", ",", "out_folder_fms", ")", ":", "\n", "# TODO: Merge with same in trainSessionParams", "\n", "        ", "self", ".", "out_preds_fpaths", "=", "[", "]", "\n", "self", ".", "out_fms_fpaths", "=", "[", "]", "\n", "if", "self", ".", "out_preds_fnames", "is", "not", "None", ":", "# standard behavior", "\n", "            ", "for", "case_i", "in", "range", "(", "self", ".", "n_cases", ")", ":", "\n", "                ", "fpaths_for_case_pred", "=", "out_folder_preds", "+", "\"/\"", "+", "self", ".", "out_preds_fnames", "[", "case_i", "]", "\n", "self", ".", "out_preds_fpaths", ".", "append", "(", "fpaths_for_case_pred", ")", "\n", "fpaths_for_case_fms", "=", "out_folder_fms", "+", "\"/\"", "+", "self", ".", "out_preds_fnames", "[", "case_i", "]", "\n", "self", ".", "out_fms_fpaths", ".", "append", "(", "fpaths_for_case_fms", ")", "\n", "", "", "else", ":", "# Names for predictions not given. Special handling...", "\n", "            ", "if", "self", ".", "n_cases", ">", "1", ":", "# Many cases, create corresponding namings for files.", "\n", "                ", "for", "case_i", "in", "range", "(", "self", ".", "n_cases", ")", ":", "\n", "                    ", "self", ".", "out_preds_fpaths", ".", "append", "(", "out_folder_preds", "+", "\"/pred_case\"", "+", "str", "(", "case_i", ")", "+", "\".nii.gz\"", ")", "\n", "self", ".", "out_fms_fpaths", ".", "append", "(", "out_folder_preds", "+", "\"/pred_case\"", "+", "str", "(", "case_i", ")", "+", "\".nii.gz\"", ")", "\n", "", "", "else", ":", "# Only one case. Just give the output prediction folder, the io.py will save output accordingly.", "\n", "                ", "self", ".", "out_preds_fpaths", ".", "append", "(", "out_folder_preds", ")", "\n", "self", ".", "out_fms_fpaths", ".", "append", "(", "out_folder_preds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_path_to_load_model_from": [[147, 149], ["None"], "methods", ["None"], ["", "", "", "def", "get_path_to_load_model_from", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "model_ckpt_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.print_params": [[151, 198], ["logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "def", "print_params", "(", "self", ")", ":", "\n", "        ", "logPrint", "=", "self", ".", "log", ".", "print3", "\n", "logPrint", "(", "\"\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"=========== PARAMETERS OF THIS TESTING SESSION ==============\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"sessionName = \"", "+", "str", "(", "self", ".", "_session_name", ")", ")", "\n", "logPrint", "(", "\"Model will be loaded from save = \"", "+", "str", "(", "self", ".", "model_ckpt_path", ")", ")", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~~~INPUT~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Dataframe (csv) filename = \"", "+", "str", "(", "self", ".", "csv_fname", ")", ")", "\n", "logPrint", "(", "\"Number of cases to perform inference on = \"", "+", "str", "(", "self", ".", "n_cases", ")", ")", "\n", "logPrint", "(", "\"Paths to the channels of each case = \"", "+", "str", "(", "self", ".", "channels_fpaths", ")", ")", "\n", "logPrint", "(", "\"Paths to provided GT labels per case = \"", "+", "str", "(", "self", ".", "gt_fpaths", ")", ")", "\n", "logPrint", "(", "\"Filepaths of the ROI Masks provided per case = \"", "+", "str", "(", "self", ".", "roi_fpaths", ")", ")", "\n", "logPrint", "(", "\"Batch size = \"", "+", "str", "(", "self", ".", "batchsize", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~~OUTPUT~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Path to the main output-folder = \"", "+", "str", "(", "self", ".", "main_outp_folder", ")", ")", "\n", "logPrint", "(", "\"Provided names to use to save results for each case = \"", "+", "str", "(", "self", ".", "out_preds_fnames", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~Ouput-parameters for Predictions (segmentation and probability maps)~~~~\"", ")", "\n", "logPrint", "(", "\"Save the predicted segmentation = \"", "+", "str", "(", "self", ".", "save_segms", ")", ")", "\n", "logPrint", "(", "\"Save the probability maps = \"", "+", "str", "(", "self", ".", "save_probs_per_cl", ")", ")", "\n", "logPrint", "(", "\"Paths where to save predictions per case = \"", "+", "str", "(", "self", ".", "out_preds_fpaths", ")", ")", "\n", "logPrint", "(", "\"Suffixes with which to save segmentations and probability maps = \"", "+", "str", "(", "self", ".", "suffixes_for_outp", ")", ")", "\n", "if", "not", "(", "self", ".", "save_segms", "or", "self", ".", "save_probs_per_cl", ")", ":", "\n", "            ", "logPrint", "(", "\">>> WARN: Segmentation and Probability Maps won't be saved. I guess you only wanted the feature maps?\"", ")", "\n", "\n", "", "logPrint", "(", "\"~~~~~~~Ouput-parameters for Feature Maps (FMs)~~~~~~\"", ")", "\n", "logPrint", "(", "\"Save FMs in individual images = \"", "+", "str", "(", "self", ".", "save_fms_flag", ")", ")", "\n", "logPrint", "(", "\"Indices of min/max FMs to save, per type of pathway (normal/subsampled/FC) and per layer = \"", "+", "str", "(", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", ")", ")", "\n", "logPrint", "(", "\"Save Feature Maps at = \"", "+", "str", "(", "self", ".", "out_fms_fpaths", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~ PRE-PROCESSING ~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"~~Data Compabitibility Checks~~\"", ")", "\n", "logPrint", "(", "\"Check whether input data has correct format (can slow down process) = \"", "+", "str", "(", "self", ".", "run_input_checks", ")", ")", "\n", "logPrint", "(", "\"~~Padding~~\"", ")", "\n", "logPrint", "(", "\"Pad Input Images = \"", "+", "str", "(", "self", ".", "pad_input", ")", ")", "\n", "if", "not", "self", ".", "pad_input", ":", "\n", "            ", "logPrint", "(", "\">>> WARN: Inference near the borders of the image might be incomplete if not padded!\"", "+", "\"Although some speed is gained if no padding is used. It is task-specific. Your choice.\"", ")", "\n", "", "logPrint", "(", "\"~~Intensity Normalization~~\"", ")", "\n", "logPrint", "(", "\"Verbosity level = \"", "+", "str", "(", "self", ".", "norm_prms", "[", "'verbose_lvl'", "]", ")", ")", "\n", "logPrint", "(", "\"Z-Score parameters = \"", "+", "str", "(", "self", ".", "norm_prms", "[", "'zscore'", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"========== Done with printing session's parameters ==========\"", ")", "\n", "logPrint", "(", "\"=============================================================\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testSessionParams.TestSessionParameters.get_args_for_testing": [[199, 226], ["None"], "methods", ["None"], ["", "def", "get_args_for_testing", "(", "self", ")", ":", "\n", "\n", "        ", "validation0orTesting1", "=", "1", "\n", "\n", "args", "=", "[", "self", ".", "log", ",", "\n", "validation0orTesting1", ",", "\n", "{", "\"segm\"", ":", "self", ".", "save_segms", ",", "\"prob\"", ":", "self", ".", "save_probs_per_cl", "}", ",", "\n", "\n", "self", ".", "channels_fpaths", ",", "\n", "self", ".", "gt_fpaths", ",", "\n", "self", ".", "roi_fpaths", ",", "\n", "self", ".", "out_preds_fpaths", ",", "\n", "self", ".", "suffixes_for_outp", ",", "\n", "# Hyper parameters", "\n", "self", ".", "batchsize", ",", "\n", "# Data compatibility checks", "\n", "self", ".", "run_input_checks", ",", "\n", "# Pre-Processing", "\n", "self", ".", "pad_input", ",", "\n", "self", ".", "norm_prms", ",", "\n", "# For FM visualisation", "\n", "self", ".", "save_fms_flag", ",", "\n", "self", ".", "inds_fms_per_pathtype_per_layer_to_save", ",", "\n", "self", ".", "out_fms_fpaths", "\n", "]", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_default_model_name": [[17, 20], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get_default_model_name", "(", ")", ":", "\n", "        ", "return", "\"deepmedic\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorSegmDimensionsSmallerThanReceptiveF": [[22, 30], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorSegmDimensionsSmallerThanReceptiveF", "(", "rec_field_norm", ",", "inp_dims", ",", "train_val_test", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The segment-size (input) should be at least as big as the receptive field of the model! \"", "\n", "\"The network was made with a receptive field of dimensions: \"", ",", "rec_field_norm", ",", "\". \"", "\n", "\"But in the case of: [\"", ",", "train_val_test", ",", "\"] the dimensions of the input segment \"", "\n", "\"were specified smaller: \"", ",", "inp_dims", ",", "\". \"", "\n", "\"Please fix this by adjusting number of layer and kernel dimensions! Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireNumberOfClasses": [[30, 36], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireNumberOfClasses", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Number of classses not specified in the config file, which is required. \"", "\n", "\"Please specify in the format: numberOfOutputClasses = 3 (any integer). This number should be including \"", "\n", "\"the background class! For instance if the class is binary, set this to 2! Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "errReqNumClasses", "=", "errorRequireNumberOfClasses", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireNumberOfChannels": [[39, 45], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequireNumberOfChannels", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Parameter \\\"numberOfInputChannels\\\" not specified or specified smaller than 1. \"", "\n", "\"Please specify the number of input channels that will be used as input to the CNN, \"", "\n", "\"in the format: numberOfInputChannels = number (an integer > 0). Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "errReqNumChannels", "=", "errorRequireNumberOfChannels", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireFMsNormalPathwayGreaterThanNothing": [[46, 56], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequireFMsNormalPathwayGreaterThanNothing", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The required parameter \\\"numberFMsPerLayerNormal\\\" was either not given, or given an empty list. \"", "\n", "\"This parameter should be given in the format: \"", "\n", "\"numberFMsPerLayerNormal = [number-of-FMs-layer1, ..., number-of-FMs-layer-N], \"", "\n", "\"where each number is an integer greater than zero. \"", "\n", "\"It specifies the number of layers (specified by the number of entries in the list) \"", "\n", "\"and the number of Feature Maps at each layer of the normal-scale pathway. \"", "\n", "\"Please provide and retry. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "errReqFMsNormal", "=", "errorRequireFMsNormalPathwayGreaterThanNothing", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireKernelDimensionsPerLayerNormal": [[57, 71], ["print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorRequireKernelDimensionsPerLayerNormal", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The required parameter \\\"kernelDimPerLayerNormal\\\" was not provided, or provided incorrectly. \"", "\n", "\"It should be provided in the format: \"", "\n", "\"kernelDimPerLayerNormal = [ [dim1-kernels-layer-1, dim2-kernels-layer-1, dim3-kernels-layer-1], ..., \"", "\n", "\" ... [dim1-of-kernels-in-layer-N, dim2-of-kernels-in-layer-N, dim3-of-kernels-in-layer-N] ]. \"", "\n", "\"It is a list of sublists. One sublist should be provided per layer of the Normal pathway. \"", "\n", "\"Thus it should have as many entries as the entries in parameter \\\"numberFMsPerLayerNormal\\\". \"", "\n", "\"Each sublist should contain 3 integer ODD numbers greater than zero, which should specify the \"", "\n", "\"dimensions of the 3-dimensional kernels. For instace: kernelDimPerLayerNormal = [[5,5,5],[3,3,3]] for \"", "\n", "\"a pathway with 2 layers, the first of which has 5x5x5 kernels and the second 3x3x3 kernels. \"", "\n", "\"Please fix and retry \\n WARN: The kernel dimensions should be ODD-NUMBERS. \"", "\n", "\"System was not thoroughly tested for kernels of even dimensions! Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "errReqKernDimNormal", "=", "errorRequireKernelDimensionsPerLayerNormal", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireKernelDimensionsSubsampled": [[72, 89], ["print", "ArchitectureParameters.warnForSameReceptiveField", "print", "exit", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnForSameReceptiveField"], ["@", "staticmethod", "\n", "def", "errorRequireKernelDimensionsSubsampled", "(", "n_fms_per_l_norm", ",", "n_fms_per_l_subs", ")", ":", "\n", "        ", "print", "(", "\"ERROR: It was requested to use the 2-scale architecture, with a subsampled pathway. \"", "\n", "\"Because of limitations in current version, the two pathways must have the save size of receptive field. \"", "\n", "\"By default, if \\\"useSubsampledPathway\\\" = True, \"", "\n", "\"and parameters \\\"numberFMsPerLayerSubsampled\\\" and \\\"kernelDimPerLayerSubsampled\\\" are not specified, \"", "\n", "\"the second pathway will be constructed symmetrical to the first. \"", "\n", "\"However, in this case, \\\"numberFMsPerLayerSubsampled\\\" was specified. \"", "\n", "\"It was found to have \"", ",", "len", "(", "n_fms_per_l_subs", ")", ",", "\" entries, which specified this amount of layers in \"", "\n", "\"the subsampled pathway. This is different than the number of layers in the Normal pathway, \"", "\n", "\"specified to be: \"", ",", "len", "(", "n_fms_per_l_norm", ")", ",", "\". \"", "\n", "\"In this case, we require you to also provide the parameter \\\"numberFMsPerLayerSubsampled\\\", \"", "\n", "\"specifying kernel dimensions in the subsampled pathway, in a fashion that results in same size \"", "\n", "\"of receptive field as the normal pathway.\"", ")", "\n", "ArchitectureParameters", ".", "warnForSameReceptiveField", "(", ")", "\n", "print", "(", "\"Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireKernelDimensionsPerLayerSubsampledCorrect": [[89, 106], ["print", "ArchitectureParameters.warnForSameReceptiveField", "print", "exit"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnForSameReceptiveField"], ["", "@", "staticmethod", "\n", "def", "errorRequireKernelDimensionsPerLayerSubsampledCorrect", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"kernelDimPerLayerSubsampled\\\" was not provided, or provided incorrectly. \"", "\n", "\"It should be provided in the format: \"", "\n", "\"kernelDimPerLayerSubsampled = [ [dim1-kernels-layer-1, dim2-kernels-layer-1, dim3-kernels-layer-1], ... \"", "\n", "\"... [dim1-kernels-layer-N, dim2-kernels-layer-N, dim3-kernels-layer-N] ]. \"", "\n", "\"It is a list of sublists. One sublist should be provided per layer of the SUBSAMPLED pathway. \"", "\n", "\"Thus it should have as many entries as the entries in parameter \\\"numberFMsPerLayerSubsampled\\\". \"", "\n", "\"(WARN: if the latter is not provided, it is by default taken equal to \"", "\n", "\"what specified for \\\"numberFMsPerLayerNormal\\\", in order to make the pathways symmetrical). \"", "\n", "\"Each sublist should contain 3 integer ODD numbers greater than zero, which should specify the \"", "\n", "\"dimensions of the 3-dimensional kernels. For instace: kernelDimPerLayerNormal = [[5,5,5],[3,3,3]] for \"", "\n", "\"a pathway with 2 layers, the first of which has 5x5x5 kernels and the second 3x3x3 kernels. \"", "\n", "\"Please fix and retry. (WARN: The kernel dimensions should be ODD-NUMBERS. \"", "\n", "\"System was not thoroughly tested for kernels of even dimensions!)\"", ")", "\n", "ArchitectureParameters", ".", "warnForSameReceptiveField", "(", ")", "\n", "print", "(", "\"Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "errReqKernDimNormalCorr", "=", "errorRequireKernelDimensionsPerLayerSubsampledCorrect", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReceptiveFieldsOfNormalAndSubsampledDifferent": [[107, 121], ["print", "exit", "len", "len"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorReceptiveFieldsOfNormalAndSubsampledDifferent", "(", "kern_dims_per_l_norm", ",", "rec_field_subs", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The receptive field of the normal pathway was calculated = \"", ",", "len", "(", "kern_dims_per_l_norm", ")", ",", "\n", "\" while the receptive field of the subsampled pathway was calculated=\"", ",", "len", "(", "rec_field_subs", ")", ",", "\". \"", "\n", "\"Because of limitations in current version, the two pathways must have the save size of receptive field. \"", "\n", "\"Please provide a combination of \\\"numberFMsPerLayerSubsampled\\\" and \\\"kernelDimPerLayerSubsampled\\\" \"", "\n", "\"that gives the same size of field as the normal pathway. If unsure of how to proceed, \"", "\n", "\"please ommit specifying \\\"numberFMsPerLayerSubsampled\\\" and \\\"kernelDimPerLayerSubsampled\\\" in \"", "\n", "\"the config file, and the second subsampled pathway will be automatically created to mirror the normal. \"", "\n", "\"Else, if you want to just specify the number of Feature Maps in the subsampled, \"", "\n", "\"provide \\\"numberFMsPerLayerSubsampled\\\" = [num-FMs-layer1, ..., num-FMs-layerN], with N the \"", "\n", "\"same number as the normal pathway, and we will then use the same kernel-sizes as the normal pathway. \"", "\n", "\"Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReqInitializationMethod": [[121, 124], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorReqInitializationMethod", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Parameter \\\"convWeightsInit\\\" has been given invalid value. Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "@", "staticmethod", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReqActivFunction": [[124, 127], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorReqActivFunction", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Parameter \\\"activ_function\\\" has been given invalid value. Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errReqSameNumOfLayersPerSubPathway": [[128, 137], ["print", "print", "print", "print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errReqSameNumOfLayersPerSubPathway", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: Parameter \\\"numberFMsPerLayerSubsampled\\\" has been given as a list of sublists of integers. \"", "\n", "\"This triggers the construction of multiple low-scale pathways.\"", ")", "\n", "print", "(", "\"\\tHowever currently this functionality requires that same number of layers is used in both pathways.\"", ")", "\n", "print", "(", "\"\\tUser specified in \\\"numberFMsPerLayerSubsampled\\\" sublists of different length. \"", "\n", "\"Each list should have the same lenght, as many as the wanted number of layers. Please adress this.\"", ")", "\n", "print", "(", "\"Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorSubFactor3d": [[138, 146], ["print", "ArchitectureParameters.warnSubFactorOdd", "print", "exit"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnSubFactorOdd"], ["", "@", "staticmethod", "\n", "def", "errorSubFactor3d", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"subsample_factors\\\" must have 3 entries, one for each of the 3 dimensions. \"", "\n", "\"Please provide it in the format: subsample_factors = [subFactor-dim1, subFactor-dim2, subFactor-dim3]. \"", "\n", "\"Each of the entries should be an integer, eg [3, 3, 3].\"", ")", "\n", "ArchitectureParameters", ".", "warnSubFactorOdd", "(", ")", "\n", "print", "(", "\"Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireSegmentDimensionsTrain": [[147, 154], ["print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "errorRequireSegmentDimensionsTrain", "(", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"segmentsDimTrain\\\" was is required but not given. \"", "\n", "\"It specifies the size of the 3D segment that is given as input to the network. \"", "\n", "\"It should be at least as large as the receptive field of the network in each dimension. \"", "\n", "\"Please specify it in the format: segmentsDimTrain = [dim-1, dim-2, dim-3]. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "errReqSegmDimTrain", "=", "errorRequireSegmentDimensionsTrain", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorResLayer1": [[156, 165], ["print", "print", "print", "exit"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "errorResLayer1", "(", "strPathwayType", ")", ":", "\n", "        ", "print", "(", "\"ERROR: The parameter \\\"layersWithResidualConn\\\" for the [\"", ",", "strPathwayType", ",", "\"] pathway was \"", "\n", "\"specified to include the number 1, ie the 1st layer.\"", ")", "\n", "print", "(", "\"\\t This is not an acceptable value, as a residual connection is made between the output of \"", "\n", "\"the specified layer and the input of the previous layer. There is no layer before the 1st!\"", ")", "\n", "print", "(", "\"\\t Provide a list that does not iinclude the first layer, eg layersWithResidualConnNormal = [4,6,8], \"", "\n", "\"or an empty list [] for no such connections. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnForSameReceptiveField": [[166, 169], ["print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "warnForSameReceptiveField", "(", ")", ":", "\n", "        ", "print", "(", "\"WARN: Because of limitations in the current version, the two pathways must have the same \"", "\n", "\"size of receptive field. If unsure of how to proceed, \"", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnSubFactorOdd": [[176, 179], ["print"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "warnSubFactorOdd", "(", ")", ":", "\n", "        ", "print", "(", "\"WARN: The system was only thoroughly tested for odd subsampling factor! Eg subsample_factors = [3,3,3].\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._to_list_of_lists_if_needed": [[181, 207], ["isinstance", "print", "exit", "isinstance", "print", "exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_to_list_of_lists_if_needed", "(", "structure_from_cfg", ")", ":", "\n", "# structure_from_cfg: whatever given in the config by the user (except None).", "\n", "        ", "if", "not", "isinstance", "(", "structure_from_cfg", ",", "list", ")", ":", "\n", "            ", "print", "(", "\"ERROR: variable \\\"\"", ",", "structure_from_cfg", ",", "\"\\\" given in modelConfig.cfg should be either a list of \"", "\n", "\"integers, or a list of lists of integers, in case multiple lower-scale pathways are wanted. \"", "\n", "\"Please correct it. Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "all_elements_are_lists", "=", "True", "\n", "no_element_is_list", "=", "True", "\n", "for", "element", "in", "structure_from_cfg", ":", "\n", "            ", "if", "isinstance", "(", "element", ",", "list", ")", ":", "\n", "                ", "no_element_is_list", "=", "False", "\n", "", "else", ":", "\n", "                ", "all_elements_are_lists", "=", "False", "\n", "", "", "if", "not", "(", "all_elements_are_lists", "or", "no_element_is_list", ")", ":", "# some are lists and some are not", "\n", "            ", "print", "(", "\"ERROR: variable \\\"\"", ",", "structure_from_cfg", ",", "\"\\\" given in modelConfig.cfg should be either a list of \"", "\n", "\"integers, or a list of lists of integers, in case multiple lower-scale pathways are wanted. \"", "\n", "\"Please correct it. Exiting.\"", ")", "\n", "exit", "(", "1", ")", "\n", "", "elif", "no_element_is_list", ":", "\n", "# Seems ok, but structure is not a list of lists, but probably the old type, eg [3,3,3].", "\n", "# Change to list of lists.", "\n", "            ", "return", "[", "structure_from_cfg", "]", "\n", "", "else", ":", "\n", "            ", "return", "structure_from_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._check_sublists_have_same_length": [[208, 216], ["len", "range", "len", "len", "len"], "methods", ["None"], ["", "", "def", "_check_sublists_have_same_length", "(", "self", ",", "list_of_lists", ")", ":", "\n", "        ", "if", "len", "(", "list_of_lists", ")", "==", "0", ":", "\n", "            ", "return", "True", "\n", "", "len_of_first", "=", "len", "(", "list_of_lists", "[", "0", "]", ")", "\n", "for", "subList_i", "in", "range", "(", "len", "(", "list_of_lists", ")", ")", ":", "\n", "            ", "if", "len_of_first", "!=", "len", "(", "list_of_lists", "[", "subList_i", "]", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._check_no_res_conn_at_1st_layer": [[217, 224], ["modelParams.ModelParameters.errorResLayer1", "modelParams.ModelParameters.errorResLayer1", "modelParams.ModelParameters.errorResLayer1"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorResLayer1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorResLayer1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorResLayer1"], ["", "def", "_check_no_res_conn_at_1st_layer", "(", "self", ",", "res_conn_at_layers_norm", ",", "res_conn_at_layers_subs", ",", "res_conn_at_layers_fc", ")", ":", "\n", "        ", "if", "1", "in", "res_conn_at_layers_norm", ":", "\n", "            ", "self", ".", "errorResLayer1", "(", "\"Normal\"", ")", "\n", "", "if", "1", "in", "res_conn_at_layers_subs", ":", "\n", "            ", "self", ".", "errorResLayer1", "(", "\"Subsampled\"", ")", "\n", "", "if", "1", "in", "res_conn_at_layers_fc", ":", "\n", "            ", "self", ".", "errorResLayer1", "(", "\"Fully Connected\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._default_drop_fc": [[226, 234], ["len"], "methods", ["None"], ["", "", "def", "_default_drop_fc", "(", "self", ",", "n_fms_in_extra_fcs", ")", ":", "\n", "# n_fms_in_extra_fcs: List of integers, 1 per layer in the final classification path, except final classif layer", "\n", "        ", "n_extra_fcs", "=", "len", "(", "n_fms_in_extra_fcs", ")", "\n", "if", "n_extra_fcs", ">", "0", ":", "\n", "            ", "dropout_for_each_l_including_classifier", "=", "[", "0.0", "]", "+", "[", "0.5", "]", "*", "(", "n_extra_fcs", "-", "1", ")", "+", "[", "0.5", "]", "\n", "", "else", ":", "\n", "            ", "dropout_for_each_l_including_classifier", "=", "[", "0.5", "]", "\n", "", "return", "dropout_for_each_l_including_classifier", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.__init__": [[236, 399], ["len", "deepmedic.neuralnet.utils.calc_rec_field_of_path_assuming_strides_1", "modelParams.ModelParameters._check_no_res_conn_at_1st_layer", "modelParams.ModelParameters.get_default_model_name", "modelParams.ModelParameters.errReqNumClasses", "modelParams.ModelParameters.errReqNumChannels", "modelParams.ModelParameters.errReqFMsNormal", "deepmedic.neuralnet.utils.check_kern_dims_per_l_correct_3d_and_n_layers", "modelParams.ModelParameters.errReqKernDimNormal", "modelParams.ModelParameters._to_list_of_lists_if_needed", "len", "modelParams.ModelParameters._to_list_of_lists_if_needed", "len", "range", "range", "len", "len", "modelParams.ModelParameters.errReqSegmDimTrain", "modelParams.ModelParameters._default_drop_fc", "modelParams.ModelParameters.errorReqInitializationMethod", "modelParams.ModelParameters.errorReqActivFunction", "modelParams.ModelParameters._check_sublists_have_same_length", "modelParams.ModelParameters.errReqSameNumOfLayersPerSubPathway", "modelParams.ModelParameters._n_fms_per_l_subs.append", "deepmedic.neuralnet.utils.check_rec_field_vs_inp_dims", "modelParams.ModelParameters.errorSegmDimensionsSmallerThanReceptiveF", "range", "range", "len", "modelParams.ModelParameters.errorRequireKernelDimensionsSubsampled", "len", "modelParams.ModelParameters.errorSubFactor3d", "deepmedic.neuralnet.utils.subsample_factor_is_even", "modelParams.ModelParameters.warnSubFactorOdd", "len", "range", "len", "range", "deepmedic.neuralnet.utils.check_kern_dims_per_l_correct_3d_and_n_layers", "modelParams.ModelParameters.errReqKernDimNormalCorr", "deepmedic.neuralnet.utils.calc_rec_field_of_path_assuming_strides_1", "max", "len", "len", "modelParams.ModelParameters.errorReceptiveFieldsOfNormalAndSubsampledDifferent", "int"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.calc_rec_field_of_path_assuming_strides_1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._check_no_res_conn_at_1st_layer", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_default_model_name", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.check_kern_dims_per_l_correct_3d_and_n_layers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._to_list_of_lists_if_needed", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._to_list_of_lists_if_needed", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._default_drop_fc", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReqInitializationMethod", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReqActivFunction", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters._check_sublists_have_same_length", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errReqSameNumOfLayersPerSubPathway", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.check_rec_field_vs_inp_dims", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorSegmDimensionsSmallerThanReceptiveF", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorRequireKernelDimensionsSubsampled", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorSubFactor3d", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.subsample_factor_is_even", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.warnSubFactorOdd", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.check_kern_dims_per_l_correct_3d_and_n_layers", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.calc_rec_field_of_path_assuming_strides_1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.errorReceptiveFieldsOfNormalAndSubsampledDifferent"], ["", "def", "__init__", "(", "self", ",", "log", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "_log", "=", "log", "\n", "self", ".", "_model_name", "=", "cfg", "[", "cfg", ".", "MODEL_NAME", "]", "if", "cfg", "[", "cfg", ".", "MODEL_NAME", "]", "is", "not", "None", "else", "self", ".", "get_default_model_name", "(", ")", "\n", "\n", "# =========== MODEL PARAMETERS ==========", "\n", "self", ".", "_n_classes", "=", "cfg", "[", "cfg", ".", "N_CLASSES", "]", "if", "cfg", "[", "cfg", ".", "N_CLASSES", "]", "is", "not", "None", "else", "self", ".", "errReqNumClasses", "(", ")", "\n", "self", ".", "_n_in_chans", "=", "cfg", "[", "cfg", ".", "N_INP_CHANS", "]", "if", "cfg", "[", "cfg", ".", "N_INP_CHANS", "]", "is", "not", "None", "else", "self", ".", "errReqNumChannels", "(", ")", "\n", "assert", "self", ".", "_n_in_chans", ">", "0", ",", "\"Number of input channels should be greater than 0.\"", "\n", "# === Normal pathway ===", "\n", "self", ".", "_n_fms_per_l_norm", "=", "cfg", "[", "cfg", ".", "N_FM_NORM", "]", "if", "cfg", "[", "cfg", ".", "N_FM_NORM", "]", "is", "not", "None", "and", "len", "(", "cfg", "[", "cfg", ".", "N_FM_NORM", "]", ")", ">", "0", "else", "self", ".", "errReqFMsNormal", "(", ")", "\n", "n_layers_norm", "=", "len", "(", "self", ".", "_n_fms_per_l_norm", ")", "\n", "self", ".", "_kern_dims_per_l_norm", "=", "cfg", "[", "cfg", ".", "KERN_DIM_NORM", "]", "if", "check_kern_dims_per_l_correct_3d_and_n_layers", "(", "cfg", "[", "cfg", ".", "KERN_DIM_NORM", "]", ",", "n_layers_norm", ")", "else", "self", ".", "errReqKernDimNormal", "(", ")", "\n", "# The below rec_field is ONLY for checking correctness of the passed parameters. TODO: Remove", "\n", "rec_field_norm", "=", "calc_rec_field_of_path_assuming_strides_1", "(", "self", ".", "_kern_dims_per_l_norm", ")", "\n", "self", ".", "_pad_mode_per_l_norm", "=", "cfg", "[", "cfg", ".", "PAD_MODE_NORM", "]", "if", "cfg", "[", "cfg", ".", "PAD_MODE_NORM", "]", "is", "not", "None", "else", "[", "'VALID'", "]", "*", "n_layers_norm", "\n", "# The below are layer numbers, starting from 1 for 1st layer. NOT indices starting from 0.", "\n", "res_conn_at_layers_norm", "=", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_NORM", "]", "if", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_NORM", "]", "is", "not", "None", "else", "[", "]", "\n", "lower_rank_layers_norm", "=", "cfg", "[", "cfg", ".", "LOWER_RANK_LAYERS_NORM", "]", "if", "cfg", "[", "cfg", ".", "LOWER_RANK_LAYERS_NORM", "]", "is", "not", "None", "else", "[", "]", "\n", "\n", "# == Subsampled pathway ==", "\n", "self", ".", "_use_subs_paths", "=", "cfg", "[", "cfg", ".", "USE_SUBSAMPLED", "]", "if", "cfg", "[", "cfg", ".", "USE_SUBSAMPLED", "]", "is", "not", "None", "else", "False", "\n", "if", "not", "self", ".", "_use_subs_paths", ":", "\n", "            ", "self", ".", "_n_fms_per_l_subs", "=", "[", "]", "\n", "self", ".", "_kern_dims_per_l_subs", "=", "[", "]", "\n", "self", ".", "_subsample_factors", "=", "[", "]", "# Per pathway, per dimension. E.g.: [[3,3,3], [5,5,5]]", "\n", "self", ".", "_pad_mode_per_l_subs", "=", "[", "]", "\n", "res_conn_at_layers_subs", "=", "[", "]", "\n", "lower_rank_layers_subs", "=", "[", "]", "\n", "rec_field_subs", "=", "[", "]", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "_n_fms_per_l_subs", "=", "cfg", "[", "cfg", ".", "N_FM_SUBS", "]", "if", "cfg", "[", "cfg", ".", "N_FM_SUBS", "]", "is", "not", "None", "else", "self", ".", "_n_fms_per_l_norm", "\n", "self", ".", "_n_fms_per_l_subs", "=", "self", ".", "_to_list_of_lists_if_needed", "(", "self", ".", "_n_fms_per_l_subs", ")", "\n", "# Check that all subsampled pathways have the same number of layers.", "\n", "# Limitation in the code currently, because I use kern_dims_per_l_subs for all of them.", "\n", "if", "not", "self", ".", "_check_sublists_have_same_length", "(", "self", ".", "_n_fms_per_l_subs", ")", ":", "\n", "                ", "self", ".", "errReqSameNumOfLayersPerSubPathway", "(", ")", "\n", "\n", "", "n_layers_subs", "=", "len", "(", "self", ".", "_n_fms_per_l_subs", "[", "0", "]", ")", "\n", "if", "cfg", "[", "cfg", ".", "KERN_DIM_SUBS", "]", "is", "None", "and", "n_layers_subs", "==", "n_layers_norm", ":", "\n", "                ", "self", ".", "_kern_dims_per_l_subs", "=", "self", ".", "_kern_dims_per_l_norm", "\n", "rec_field_subs", "=", "rec_field_norm", "\n", "", "elif", "cfg", "[", "cfg", ".", "KERN_DIM_SUBS", "]", "is", "None", "and", "n_layers_subs", "!=", "n_layers_norm", ":", "\n", "                ", "self", ".", "errorRequireKernelDimensionsSubsampled", "(", "self", ".", "_kern_dims_per_l_norm", ",", "cfg", "[", "cfg", ".", "N_FM_SUBS", "]", ")", "\n", "# KERN_DIM_SUBS was specified. Now it's going to be tricky to make sure everything alright.", "\n", "", "elif", "not", "check_kern_dims_per_l_correct_3d_and_n_layers", "(", "cfg", "[", "cfg", ".", "KERN_DIM_SUBS", "]", ",", "n_layers_subs", ")", ":", "\n", "                ", "self", ".", "errReqKernDimNormalCorr", "(", ")", "\n", "", "else", ":", "# kernel dimensions specified and are correct. Check the two receptive fields and ensure correctness.", "\n", "                ", "self", ".", "_kern_dims_per_l_subs", "=", "cfg", "[", "cfg", ".", "KERN_DIM_SUBS", "]", "\n", "rec_field_subs", "=", "calc_rec_field_of_path_assuming_strides_1", "(", "self", ".", "_kern_dims_per_l_subs", ")", "\n", "if", "rec_field_norm", "!=", "rec_field_subs", ":", "\n", "                    ", "self", ".", "errorReceptiveFieldsOfNormalAndSubsampledDifferent", "(", "rec_field_norm", ",", "rec_field_subs", ")", "\n", "# Everything alright, finally. Proceed safely...", "\n", "", "", "self", ".", "_pad_mode_per_l_subs", "=", "cfg", "[", "cfg", ".", "PAD_MODE_SUBS", "]", "if", "cfg", "[", "cfg", ".", "PAD_MODE_SUBS", "]", "is", "not", "None", "else", "[", "'VALID'", "]", "*", "n_layers_subs", "\n", "self", ".", "_subsample_factors", "=", "cfg", "[", "cfg", ".", "SUBS_FACTOR", "]", "if", "cfg", "[", "cfg", ".", "SUBS_FACTOR", "]", "is", "not", "None", "else", "[", "3", ",", "3", ",", "3", "]", "\n", "self", ".", "_subsample_factors", "=", "self", ".", "_to_list_of_lists_if_needed", "(", "self", ".", "_subsample_factors", ")", "\n", "# self._subsample_factors: Should now be a list of lists, one per subsmpled pathway. Defines number of paths.", "\n", "n_subs_paths", "=", "len", "(", "self", ".", "_subsample_factors", ")", "\n", "for", "subs_path_i", "in", "range", "(", "n_subs_paths", ")", ":", "\n", "                ", "if", "len", "(", "self", ".", "_subsample_factors", "[", "subs_path_i", "]", ")", "!=", "3", ":", "\n", "                    ", "self", ".", "errorSubFactor3d", "(", ")", "\n", "", "if", "not", "subsample_factor_is_even", "(", "self", ".", "_subsample_factors", "[", "subs_path_i", "]", ")", ":", "\n", "                    ", "self", ".", "warnSubFactorOdd", "(", ")", "\n", "# Default behaviour:", "\n", "# If less sublists in n_fms_per_l_subs were given than n_subs_paths, add one for each subsampled pathway.", "\n", "", "", "for", "_", "in", "range", "(", "n_subs_paths", "-", "len", "(", "self", ".", "_n_fms_per_l_subs", ")", ")", ":", "\n", "                ", "n_fms_per_l_in_prev_path", "=", "self", ".", "_n_fms_per_l_subs", "[", "-", "1", "]", "\n", "self", ".", "_n_fms_per_l_subs", ".", "append", "(", "[", "max", "(", "1", ",", "int", "(", "n_fms_in_l_i", ")", ")", "for", "n_fms_in_l_i", "in", "n_fms_per_l_in_prev_path", "]", ")", "\n", "\n", "# Residuals and lower ranks.", "\n", "", "res_conn_at_layers_subs", "=", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_SUBS", "]", "if", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_SUBS", "]", "is", "not", "None", "else", "res_conn_at_layers_norm", "\n", "lower_rank_layers_subs", "=", "cfg", "[", "cfg", ".", "LOWER_RANK_LAYERS_SUBS", "]", "if", "cfg", "[", "cfg", ".", "LOWER_RANK_LAYERS_SUBS", "]", "is", "not", "None", "else", "lower_rank_layers_norm", "\n", "\n", "# == FC Layers ==", "\n", "", "self", ".", "_n_fms_in_extra_fcs", "=", "cfg", "[", "cfg", ".", "N_FM_FC", "]", "if", "cfg", "[", "cfg", ".", "N_FM_FC", "]", "is", "not", "None", "else", "[", "]", "\n", "n_layers_fc", "=", "len", "(", "self", ".", "_n_fms_in_extra_fcs", ")", "+", "1", "\n", "self", ".", "_kern_dims_fc", "=", "cfg", "[", "cfg", ".", "KERN_DIM_FC", "]", "if", "cfg", "[", "cfg", ".", "KERN_DIM_FC", "]", "is", "not", "None", "else", "[", "[", "1", ",", "1", ",", "1", "]", "for", "l", "in", "range", "(", "n_layers_fc", ")", "]", "\n", "assert", "len", "(", "self", ".", "_kern_dims_fc", ")", "==", "n_layers_fc", ",", "'Need one Kernel-Dimensions per layer of FC path, '", "'equal to length of number-of-FMs-in-FC +1 (for classif layer)'", "\n", "self", ".", "_pad_mode_per_l_fc", "=", "cfg", "[", "cfg", ".", "PAD_MODE_FC", "]", "if", "cfg", "[", "cfg", ".", "PAD_MODE_FC", "]", "is", "not", "None", "else", "[", "'VALID'", "]", "*", "n_layers_fc", "\n", "res_conn_at_layers_fc", "=", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_FC", "]", "if", "cfg", "[", "cfg", ".", "RESID_CONN_LAYERS_FC", "]", "is", "not", "None", "else", "[", "]", "\n", "\n", "# == Size of Image Segments ==", "\n", "self", ".", "_inp_dims_hr_path", "=", "{", "'train'", ":", "None", ",", "'val'", ":", "None", ",", "'test'", ":", "None", "}", "\n", "self", ".", "_inp_dims_hr_path", "[", "'train'", "]", "=", "cfg", "[", "cfg", ".", "SEG_DIM_TRAIN", "]", "if", "cfg", "[", "cfg", ".", "SEG_DIM_TRAIN", "]", "is", "not", "None", "else", "self", ".", "errReqSegmDimTrain", "(", ")", "\n", "self", ".", "_inp_dims_hr_path", "[", "'val'", "]", "=", "cfg", "[", "cfg", ".", "SEG_DIM_VAL", "]", "if", "cfg", "[", "cfg", ".", "SEG_DIM_VAL", "]", "is", "not", "None", "else", "rec_field_norm", "\n", "self", ".", "_inp_dims_hr_path", "[", "'test'", "]", "=", "cfg", "[", "cfg", ".", "SEG_DIM_INFER", "]", "if", "cfg", "[", "cfg", ".", "SEG_DIM_INFER", "]", "is", "not", "None", "else", "self", ".", "_inp_dims_hr_path", "[", "'train'", "]", "\n", "for", "train_val_test", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "            ", "if", "not", "check_rec_field_vs_inp_dims", "(", "rec_field_norm", ",", "self", ".", "_inp_dims_hr_path", "[", "train_val_test", "]", ")", ":", "\n", "                ", "self", ".", "errorSegmDimensionsSmallerThanReceptiveF", "(", "rec_field_norm", ",", "self", ".", "_inp_dims_hr_path", ",", "train_val_test", ")", "\n", "\n", "\n", "# === Dropout rates ===", "\n", "", "", "drop_norm", "=", "cfg", "[", "cfg", ".", "DROP_NORM", "]", "if", "cfg", "[", "cfg", ".", "DROP_NORM", "]", "is", "not", "None", "else", "[", "]", "\n", "drop_subs", "=", "cfg", "[", "cfg", ".", "DROP_SUBS", "]", "if", "cfg", "[", "cfg", ".", "DROP_SUBS", "]", "is", "not", "None", "else", "[", "]", "\n", "drop_fc", "=", "cfg", "[", "cfg", ".", "DROP_FC", "]", "if", "cfg", "[", "cfg", ".", "DROP_FC", "]", "is", "not", "None", "else", "self", ".", "_default_drop_fc", "(", "self", ".", "_n_fms_in_extra_fcs", ")", "\n", "self", ".", "_dropout_per_pathtype", "=", "[", "drop_norm", ",", "drop_subs", ",", "drop_fc", "]", "\n", "\n", "# == Weight Initialization ==", "\n", "self", ".", "_conv_w_init_type", "=", "cfg", "[", "cfg", ".", "CONV_W_INIT", "]", "if", "cfg", "[", "cfg", ".", "CONV_W_INIT", "]", "is", "not", "None", "else", "[", "\"fanIn\"", ",", "2", "]", "\n", "if", "not", "self", ".", "_conv_w_init_type", "[", "0", "]", "in", "[", "\"normal\"", ",", "\"fanIn\"", "]", ":", "\n", "            ", "self", ".", "errorReqInitializationMethod", "(", ")", "\n", "# == Activation Function ==", "\n", "", "self", ".", "_activ_func", "=", "cfg", "[", "cfg", ".", "ACTIV_FUNC", "]", "if", "cfg", "[", "cfg", ".", "ACTIV_FUNC", "]", "is", "not", "None", "else", "\"prelu\"", "\n", "if", "not", "self", ".", "_activ_func", "in", "[", "\"linear\"", ",", "\"relu\"", ",", "\"prelu\"", ",", "\"elu\"", ",", "\"selu\"", "]", ":", "\n", "            ", "self", ".", "errorReqActivFunction", "(", ")", "\n", "\n", "# == BATCH NORMALIZATION ==", "\n", "", "self", ".", "_apply_bn_to_inp_of_paths", "=", "[", "False", ",", "False", ",", "True", "]", "# Per pathway type. 3rd entry for FC must always be True", "\n", "self", ".", "_n_batches_for_bn_mov_avg", "=", "cfg", "[", "cfg", ".", "BN_ROLL_AV_BATCHES", "]", "if", "cfg", "[", "cfg", ".", "BN_ROLL_AV_BATCHES", "]", "is", "not", "None", "else", "60", "\n", "\n", "# ============== CALCULATED =====================", "\n", "# Residual Connections backwards, per pathway type :", "\n", "self", ".", "_check_no_res_conn_at_1st_layer", "(", "res_conn_at_layers_norm", ",", "res_conn_at_layers_subs", ",", "res_conn_at_layers_fc", ")", "\n", "# The following variable passed to the system takes indices, ie number starts from 0. User specifies from 1.", "\n", "self", ".", "_inds_layers_for_res_conn_at_outp", "=", "[", "[", "layer_num", "-", "1", "for", "layer_num", "in", "res_conn_at_layers_norm", "]", ",", "\n", "[", "layer_num", "-", "1", "for", "layer_num", "in", "res_conn_at_layers_subs", "]", ",", "\n", "[", "layer_num", "-", "1", "for", "layer_num", "in", "res_conn_at_layers_fc", "]", ",", "\n", "[", "]", "\n", "]", "\n", "\n", "self", ".", "_inds_layers_low_rank_per_pathtype", "=", "[", "[", "layer_num", "-", "1", "for", "layer_num", "in", "lower_rank_layers_norm", "]", ",", "\n", "[", "layer_num", "-", "1", "for", "layer_num", "in", "lower_rank_layers_subs", "]", ",", "\n", "[", "]", ",", "#FC doesn't make sense to be lower rank. It's 1x1x1 anyway.", "\n", "[", "]", "\n", "]", "\n", "self", ".", "_ranks_of_low_rank_l_per_pathtype", "=", "[", "[", "2", "for", "layer_i", "in", "self", ".", "_inds_layers_low_rank_per_pathtype", "[", "0", "]", "]", ",", "\n", "[", "2", "for", "layer_i", "in", "self", ".", "_inds_layers_low_rank_per_pathtype", "[", "1", "]", "]", ",", "\n", "[", "]", ",", "\n", "[", "]", "\n", "]", "\n", "# ============= HIDDENS ===============", "\n", "\n", "# ------- POOLING ---------- (not fully supported currently)", "\n", "# One entry per pathway-type. leave [] if the pathway does not exist or there is no mp there AT ALL.", "\n", "# Inside each entry, put a list FOR EACH LAYER. It should be [] for the layer if no mp there.", "\n", "# MP is applied >> AT INPUT of the layer <<.", "\n", "# To use mp to a layer, put a list of [[dsr,dsc,dsz], [strr,strc,strz], [mirrorPad-r,-c,-z], mode] ...", "\n", "# ... which give the dimensions of the mp window, the stride, how many times to mirror the last slot at each...", "\n", "# ... dimension for padding (give 0 for none), the mode (usually 'max' pool).", "\n", "# Eg [[2,2,2],[1,1,1]] or [[2,2,2],[2,2,2]] usually.", "\n", "# If a pathway is not used (eg subsampled), put an empty list in the first dimension entry.", "\n", "\n", "# [[[2,2,2], [1,1,1], 'MIRROR', 'MAX'], [],[],[],[],[],[], []], # first pathway", "\n", "mp_prms_norm", "=", "[", "[", "]", "for", "layer_i", "in", "range", "(", "len", "(", "self", ".", "_n_fms_per_l_norm", ")", ")", "]", "\n", "# CAREFUL about the [0]. Only here till this structure is made different per pathway and not pathwayType.", "\n", "mp_prms_subs", "=", "[", "[", "]", "for", "layer_i", "in", "range", "(", "len", "(", "self", ".", "_n_fms_per_l_subs", "[", "0", "]", ")", ")", "]", "if", "self", ".", "_use_subs_paths", "else", "[", "]", "\n", "# FC. This should NEVER be used for segmentation. Possible for classification though.", "\n", "mp_prms_fc", "=", "[", "[", "]", "for", "layer_i", "in", "range", "(", "len", "(", "self", ".", "_n_fms_in_extra_fcs", ")", "+", "1", ")", "]", "\n", "self", ".", "_max_pool_prms_per_pathtype", "=", "[", "mp_prms_norm", ",", "mp_prms_subs", ",", "mp_prms_fc", "]", "\n", "\n", "self", ".", "_softmax_temperature", "=", "1.0", "# Higher temperatures make the probabilities LESS distinctable.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.print_params": [[401, 462], ["logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "logPrint", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "print_params", "(", "self", ")", ":", "\n", "        ", "logPrint", "=", "self", ".", "_log", ".", "print3", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"========== PARAMETERS FOR MAKING THE ARCHITECTURE ===========\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "logPrint", "(", "\"CNN model's name = \"", "+", "str", "(", "self", ".", "_model_name", ")", ")", "\n", "\n", "logPrint", "(", "\"~~~~~~~~~~~~~~~~~~Model parameters~~~~~~~~~~~~~~~~\"", ")", "\n", "logPrint", "(", "\"Number of Classes (including background) = \"", "+", "str", "(", "self", ".", "_n_classes", ")", ")", "\n", "logPrint", "(", "\"~~Normal Pathway~~\"", ")", "\n", "logPrint", "(", "\"Number of Input Channels = \"", "+", "str", "(", "self", ".", "_n_in_chans", ")", ")", "\n", "logPrint", "(", "\"Number of Layers = \"", "+", "str", "(", "len", "(", "self", ".", "_n_fms_per_l_norm", ")", ")", ")", "\n", "logPrint", "(", "\"Number of Feature Maps per layer = \"", "+", "str", "(", "self", ".", "_n_fms_per_l_norm", ")", ")", "\n", "logPrint", "(", "\"Kernel Dimensions per layer = \"", "+", "str", "(", "self", ".", "_kern_dims_per_l_norm", ")", ")", "\n", "logPrint", "(", "\"Padding mode of convs per layer = \"", "+", "str", "(", "self", ".", "_pad_mode_per_l_norm", ")", ")", "\n", "logPrint", "(", "\"Residual connections added at the output of layers (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_for_res_conn_at_outp", "[", "0", "]", ")", ")", "\n", "logPrint", "(", "\"Layers that will be made of Lower Rank (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_low_rank_per_pathtype", "[", "0", "]", ")", ")", "\n", "logPrint", "(", "\"Lower Rank layers will be made of rank = \"", "+", "str", "(", "self", ".", "_ranks_of_low_rank_l_per_pathtype", "[", "0", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Subsampled Pathway~~\"", ")", "\n", "logPrint", "(", "\"Use subsampled Pathway = \"", "+", "str", "(", "self", ".", "_use_subs_paths", ")", ")", "\n", "logPrint", "(", "\"Number of subsampled pathways that will be built = \"", "+", "str", "(", "len", "(", "self", ".", "_subsample_factors", ")", ")", ")", "\n", "logPrint", "(", "\"Number of Layers (per sub-pathway) = \"", "+", "str", "(", "[", "len", "(", "N_FM_SUBS_i", ")", "for", "N_FM_SUBS_i", "in", "self", ".", "_n_fms_per_l_subs", "]", ")", ")", "\n", "logPrint", "(", "\"Number of Feature Maps per layer (per sub-pathway) = \"", "+", "str", "(", "self", ".", "_n_fms_per_l_subs", ")", ")", "\n", "logPrint", "(", "\"Kernel Dimensions per layer = \"", "+", "str", "(", "self", ".", "_kern_dims_per_l_subs", ")", ")", "\n", "logPrint", "(", "\"Padding mode of convs per layer = \"", "+", "str", "(", "self", ".", "_pad_mode_per_l_subs", ")", ")", "\n", "logPrint", "(", "\"Subsampling Factor per dimension (per sub-pathway) = \"", "+", "str", "(", "self", ".", "_subsample_factors", ")", ")", "\n", "logPrint", "(", "\"Residual connections added at the output of layers (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_for_res_conn_at_outp", "[", "1", "]", ")", ")", "\n", "logPrint", "(", "\"Layers that will be made of Lower Rank (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_low_rank_per_pathtype", "[", "1", "]", ")", ")", "\n", "logPrint", "(", "\"Lower Rank layers will be made of rank = \"", "+", "str", "(", "self", ".", "_ranks_of_low_rank_l_per_pathtype", "[", "1", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Fully Connected Pathway~~\"", ")", "\n", "logPrint", "(", "\"Number of additional FC layers (Excluding the Classif. Layer) = \"", "+", "str", "(", "len", "(", "self", ".", "_n_fms_in_extra_fcs", ")", ")", ")", "\n", "logPrint", "(", "\"Number of Feature Maps in the additional FC layers = \"", "+", "str", "(", "self", ".", "_n_fms_in_extra_fcs", ")", ")", "\n", "logPrint", "(", "\"Padding mode of convs per layer = \"", "+", "str", "(", "self", ".", "_pad_mode_per_l_fc", ")", ")", "\n", "logPrint", "(", "\"Residual connections added at the output of layers (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_for_res_conn_at_outp", "[", "2", "]", ")", ")", "\n", "logPrint", "(", "\"Layers that will be made of Lower Rank (indices from 0) = \"", "+", "str", "(", "self", ".", "_inds_layers_low_rank_per_pathtype", "[", "2", "]", ")", ")", "\n", "logPrint", "(", "\"Dimensions of Kernels in final FC path before classification = \"", "+", "str", "(", "self", ".", "_kern_dims_fc", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Size Of Image Segments~~\"", ")", "\n", "logPrint", "(", "\"Size of Segments for Training = \"", "+", "str", "(", "self", ".", "_inp_dims_hr_path", "[", "'train'", "]", ")", ")", "\n", "logPrint", "(", "\"Size of Segments for Validation = \"", "+", "str", "(", "self", ".", "_inp_dims_hr_path", "[", "'val'", "]", ")", ")", "\n", "logPrint", "(", "\"Size of Segments for Testing = \"", "+", "str", "(", "self", ".", "_inp_dims_hr_path", "[", "'test'", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Dropout Rates~~\"", ")", "\n", "logPrint", "(", "\"Drop.R. for each layer in Normal Pathway = \"", "+", "str", "(", "self", ".", "_dropout_per_pathtype", "[", "0", "]", ")", ")", "\n", "logPrint", "(", "\"Drop.R. for each layer in Subsampled Pathway = \"", "+", "str", "(", "self", ".", "_dropout_per_pathtype", "[", "1", "]", ")", ")", "\n", "logPrint", "(", "\"Drop.R. for each layer in FC Pathway (additional FC layers + Classific.Layer at end) = \"", "+", "str", "(", "self", ".", "_dropout_per_pathtype", "[", "2", "]", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Weight Initialization~~\"", ")", "\n", "logPrint", "(", "\"Initialization method and params for the conv kernel weights = \"", "+", "str", "(", "self", ".", "_conv_w_init_type", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Activation Function~~\"", ")", "\n", "logPrint", "(", "\"Activation function to use = \"", "+", "str", "(", "self", ".", "_activ_func", ")", ")", "\n", "\n", "logPrint", "(", "\"~~Batch Normalization~~\"", ")", "\n", "logPrint", "(", "\"Apply BN straight on pathways' inputs (eg straight on segments) = \"", "+", "str", "(", "self", ".", "_apply_bn_to_inp_of_paths", ")", ")", "\n", "logPrint", "(", "\"Batch Normalization uses a rolling average for inference, over this many batches = \"", "+", "str", "(", "self", ".", "_n_batches_for_bn_mov_avg", ")", ")", "\n", "\n", "logPrint", "(", "\"========== Done with printing session's parameters ==========\"", ")", "\n", "logPrint", "(", "\"=============================================================\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_args_for_arch": [[463, 507], ["None"], "methods", ["None"], ["", "def", "get_args_for_arch", "(", "self", ")", ":", "\n", "\n", "        ", "args", "=", "[", "self", ".", "_log", ",", "\n", "self", ".", "_model_name", ",", "\n", "#=== Model Parameters ===", "\n", "self", ".", "_n_classes", ",", "\n", "self", ".", "_n_in_chans", ",", "\n", "#=== Normal Pathway ===", "\n", "self", ".", "_n_fms_per_l_norm", ",", "#ONLY for the convolutional layers, NOT the final convFCSoftmaxLayer!", "\n", "self", ".", "_kern_dims_per_l_norm", ",", "\n", "self", ".", "_pad_mode_per_l_norm", ",", "\n", "#=== Subsampled Pathway ===", "\n", "self", ".", "_n_fms_per_l_subs", ",", "\n", "self", ".", "_kern_dims_per_l_subs", ",", "\n", "self", ".", "_pad_mode_per_l_subs", ",", "\n", "self", ".", "_subsample_factors", ",", "\n", "\n", "#=== FC Layers ===", "\n", "self", ".", "_n_fms_in_extra_fcs", ",", "\n", "self", ".", "_kern_dims_fc", ",", "\n", "self", ".", "_pad_mode_per_l_fc", ",", "\n", "self", ".", "_softmax_temperature", ",", "\n", "\n", "#=== Other Architectural params ===", "\n", "self", ".", "_activ_func", ",", "\n", "#---Residual Connections----", "\n", "self", ".", "_inds_layers_for_res_conn_at_outp", ",", "\n", "#--Lower Rank Layer Per Pathway---", "\n", "self", ".", "_inds_layers_low_rank_per_pathtype", ",", "\n", "self", ".", "_ranks_of_low_rank_l_per_pathtype", ",", "\n", "#---Pooling---", "\n", "self", ".", "_max_pool_prms_per_pathtype", ",", "\n", "\n", "#=== Others ====", "\n", "#Dropout", "\n", "self", ".", "_dropout_per_pathtype", ",", "\n", "#Initialization", "\n", "self", ".", "_conv_w_init_type", ",", "\n", "#Batch Normalization", "\n", "self", ".", "_apply_bn_to_inp_of_paths", ",", "\n", "self", ".", "_n_batches_for_bn_mov_avg", "\n", "]", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_inp_dims_hr_path": [[509, 513], ["None"], "methods", ["None"], ["", "def", "get_inp_dims_hr_path", "(", "self", ",", "train_val_test", ")", ":", "# TODO: Move config in train/test cfg.", "\n", "# == Size of Image Segments ==", "\n", "        ", "assert", "train_val_test", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "return", "self", ".", "_inp_dims_hr_path", "[", "train_val_test", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_n_classes": [[514, 516], ["None"], "methods", ["None"], ["", "def", "get_n_classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.modelParams.ModelParameters.get_model_name": [[517, 519], ["None"], "methods", ["None"], ["", "def", "get_model_name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_model_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testConfig.TestConfig.__init__": [[52, 54], ["deepmedic.frontEnd.configParsing.config.Config.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", ":", "\n", "        ", "Config", ".", "__init__", "(", "self", ",", "abs_path_to_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.testConfig.TestConfig.override_file_cfg_with_cmd_line_cfg": [[56, 65], ["deepmedic.frontEnd.configParsing.utils.abs_from_rel_path", "os.getcwd", "testConfig.TestConfig.get", "log.print3", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "override_file_cfg_with_cmd_line_cfg", "(", "self", ",", "log", ",", "args", ")", ":", "\n", "        ", "if", "args", ".", "saved_model", ":", "\n", "            ", "abs_path_model_cmd_line", "=", "abs_from_rel_path", "(", "args", ".", "saved_model", ",", "os", ".", "getcwd", "(", ")", ")", "\n", "\n", "if", "self", ".", "get", "(", "self", ".", "SAVED_MODEL", ")", "is", "not", "None", ":", "\n", "                ", "log", ".", "print3", "(", "\"WARN: A model to load was specified both in command line and in the test-config file!\\n\"", "+", "\n", "\"\\t The input by the command line will be used: \"", "+", "str", "(", "abs_path_model_cmd_line", ")", ")", "\n", "\n", "", "self", ".", "_configStruct", "[", "self", ".", "SAVED_MODEL", "]", "=", "abs_path_model_cmd_line", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path": [[13, 25], ["os.path.isabs", "os.path.normpath", "os.path.isdir", "os.path.normpath", "os.path.isfile", "os.path.dirname", "print", "exit"], "function", ["None"], ["def", "abs_from_rel_path", "(", "pathGiven", ",", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "#os.path.normpath \"cleans\" Additional ../.// etc.", "\n", "    ", "if", "os", ".", "path", ".", "isabs", "(", "pathGiven", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "normpath", "(", "pathGiven", ")", "\n", "", "else", ":", "#relative path given. Need to make absolute path", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "absolutePathToWhereRelativePathRelatesTo", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "os", ".", "path", ".", "dirname", "(", "absolutePathToWhereRelativePathRelatesTo", ")", "\n", "", "else", ":", "#not file, not dir, exit.", "\n", "            ", "print", "(", "\"ERROR: in [func:returnAbsolutePathEvenIfRelativePathIsGiven()] Given path :\"", ",", "absolutePathToWhereRelativePathRelatesTo", ",", "\" does not correspond to neither an existing file nor a directory. Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "return", "os", ".", "path", ".", "normpath", "(", "relativePathToWhatGiven", "+", "\"/\"", "+", "pathGiven", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.checkIfAllElementsOfAListAreFilesAndExitIfNot": [[27, 32], ["os.path.isfile", "print", "exit"], "function", ["None"], ["", "", "def", "checkIfAllElementsOfAListAreFilesAndExitIfNot", "(", "pathToTheListingFile", ",", "list1", ")", ":", "\n", "    ", "for", "filepath", "in", "list1", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "print", "(", "\"ERROR: in [checkIfAllElementsOfAListExistAndExitIfNot()] path:\"", ",", "filepath", ",", "\" given in :\"", ",", "pathToTheListingFile", ",", "\" does not correspond to a file. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist": [[34, 50], ["os.path.dirname", "open", "line.strip", "list1.append", "line.strip", "line.startswith", "line.strip", "os.path.isabs", "list1.append", "list1.append", "os.path.normpath", "os.path.normpath"], "function", ["None"], ["", "", "", "def", "parse_filelist", "(", "filelist_path", ",", "make_abs", "=", "False", ")", ":", "\n", "# os.path.normpath below is to \"clean\" the paths from ./..//...", "\n", "    ", "path_to_folder_w_filelist", "=", "os", ".", "path", ".", "dirname", "(", "filelist_path", ")", "\n", "list1", "=", "[", "]", "\n", "with", "open", "(", "filelist_path", ",", "\"r\"", ")", "as", "inp", ":", "\n", "        ", "for", "line", "in", "inp", ":", "\n", "            ", "if", "line", ".", "strip", "(", ")", "==", "\"-\"", ":", "# Special char. E.g. indicating the non existence of channel, to be zero-filled.", "\n", "                ", "list1", ".", "append", "(", "\"-\"", ")", "\n", "", "elif", "not", "line", ".", "startswith", "(", "\"#\"", ")", "and", "line", ".", "strip", "(", ")", "!=", "\"\"", ":", "\n", "                ", "path_to_file", "=", "line", ".", "strip", "(", ")", "\n", "\n", "if", "(", "not", "make_abs", ")", "or", "os", ".", "path", ".", "isabs", "(", "path_to_file", ")", ":", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_file", ")", ")", "\n", "", "else", ":", "# relative path to this listing-file.", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_folder_w_filelist", "+", "\"/\"", "+", "path_to_file", ")", ")", "\n", "", "", "", "", "return", "list1", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.checkListContainsCorrectNumberOfCasesOtherwiseExitWithError": [[52, 58], ["len", "IOError"], "function", ["None"], ["", "def", "checkListContainsCorrectNumberOfCasesOtherwiseExitWithError", "(", "numberOfCasesPreviously", ",", "pathToGivenListFile", ",", "listOfFilepathsToChannelIForEachCase", ")", ":", "\n", "    ", "numberOfContainedCasesInList", "=", "len", "(", "listOfFilepathsToChannelIForEachCase", ")", "\n", "if", "numberOfCasesPreviously", "!=", "numberOfContainedCasesInList", ":", "\n", "        ", "raise", "IOError", "(", "\"ERROR: Given file:\"", ",", "pathToGivenListFile", "+", "\"\\n\\t contains #\"", ",", "numberOfContainedCasesInList", ",", "\" entries, whereas previously checked files contained #\"", ",", "numberOfCasesPreviously", ",", "\".\"", "+", "\"\\n\\t All listing-files for channels, masks, etc, should contain the same number of entries, one for each case.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.checkThatAllEntriesOfAListFollowNameConventions": [[60, 65], ["entry.startswith", "IOError", "entry.find"], "function", ["None"], ["", "", "def", "checkThatAllEntriesOfAListFollowNameConventions", "(", "listOfPredictionNamesForEachCaseInListingFile", ")", ":", "\n", "    ", "for", "entry", "in", "listOfPredictionNamesForEachCaseInListingFile", ":", "\n", "        ", "if", "entry", ".", "find", "(", "\"/\"", ")", ">", "-", "1", "or", "entry", ".", "startswith", "(", "\".\"", ")", ":", "\n", "            ", "raise", "IOError", "(", "\"ERROR: Check that all entries follow name-conventions failed.\"", "+", "\"\\n\\t Entry \\\"\"", ",", "entry", ",", "\"\\\" was found to begin with \\'.\\' or contain \\'/\\'. Please correct this.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.check_and_adjust_path_to_ckpt": [[67, 93], ["filepath_to_ckpt.rfind", "len", "str", "six.moves.input", "log.print3", "log.print3", "len", "len", "six.moves.input", "log.print3", "str", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "", "def", "check_and_adjust_path_to_ckpt", "(", "log", ",", "filepath_to_ckpt", ")", ":", "\n", "    ", "STR_DM_CKPT", "=", "\".model.ckpt\"", "\n", "index_of_str", "=", "filepath_to_ckpt", ".", "rfind", "(", "STR_DM_CKPT", ")", "\n", "if", "index_of_str", ">", "-", "1", "and", "len", "(", "filepath_to_ckpt", ")", ">", "len", "(", "filepath_to_ckpt", "[", ":", "index_of_str", "]", ")", "+", "len", "(", "STR_DM_CKPT", ")", ":", "# found.", "\n", "\n", "        ", "user_input", "=", "None", "\n", "string_warn", "=", "\"It seems that the path to the model to load paramters from, a tensorflow checkpoint, was given wrong.\"", "+", "\"\\n\\t The path to checkpoint should be of the form: [...name...date...model.ckpt] (finishing with .ckpt)\"", "+", "\"\\n\\t Note that you should not point to the .data, .index or .meta files that are saved. Rather, shorten their names till the .ckpt\"", "+", "\"\\n\\t Given path seemed longer: \"", "+", "str", "(", "filepath_to_ckpt", ")", "\n", "try", ":", "\n", "            ", "user_input", "=", "input", "(", "\">>\\t \"", "+", "string_warn", "+", "\"\\n\\t Do you wish that we shorten the path to end with [.ckpt] as expected? [y/n] : \"", ")", "\n", "while", "user_input", "not", "in", "[", "'y'", ",", "'n'", "]", ":", "\n", "                ", "user_input", "=", "input", "(", "\"Please specify 'y' or 'n': \"", ")", "\n", "", "", "except", ":", "\n", "            ", "log", ".", "print3", "(", "\"\\nWARN:\\t \"", "+", "string_warn", "+", "\"\\n\\t We tried to request command line input from user whether to shorten it after [.ckpt] but failed (remote use? nohup?\"", "+", "\"\\n\\t Continuing without doing anything. If this fails, try to give the correct path, ending with [.ckpt]\"", ")", "\n", "", "if", "user_input", "==", "'y'", ":", "\n", "            ", "filepath_to_ckpt", "=", "filepath_to_ckpt", "[", ":", "index_of_str", "+", "len", "(", "STR_DM_CKPT", ")", "]", "\n", "log", ".", "print3", "(", "\"Changed path to load parameters from: \"", "+", "str", "(", "filepath_to_ckpt", ")", ")", "\n", "", "else", ":", "\n", "            ", "log", ".", "print3", "(", "\"Continuing without doing anything.\"", ")", "\n", "\n", "", "", "return", "filepath_to_ckpt", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.normfullpath": [[95, 100], ["os.path.isabs", "os.path.normpath", "os.path.join"], "function", ["None"], ["", "def", "normfullpath", "(", "abspath", ",", "relpath", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "isabs", "(", "relpath", ")", ":", "\n", "        ", "return", "relpath", "\n", "", "else", ":", "\n", "        ", "return", "os", ".", "path", ".", "normpath", "(", "os", ".", "path", ".", "join", "(", "abspath", ",", "relpath", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.get_paths_from_df": [[102, 131], ["sorted", "len", "log.print3", "exit", "utils.normfullpath", "df.iterrows", "utils.normfullpath", "utils.normfullpath", "log.print3", "list", "c.startswith", "list", "list", "Exception", "list", "list"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.normfullpath", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.normfullpath", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.normfullpath", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "get_paths_from_df", "(", "log", ",", "df", ",", "abs_path", ",", "req_gt", "=", "True", ")", ":", "\n", "# df: Pandas dataframe, or one with same API.", "\n", "# channels are sorted alphabetically to ensure consistency", "\n", "    ", "c_names", "=", "sorted", "(", "[", "c", "for", "c", "in", "list", "(", "df", ".", "columns", ")", "if", "c", ".", "startswith", "(", "'channel_'", ")", "]", ")", "\n", "if", "len", "(", "c_names", ")", "==", "0", ":", "\n", "# no channels error raise - move to function later", "\n", "        ", "log", ".", "print3", "(", "'No channel columns in dataframe. Columns should be named \"channel_[channel_name]\". Exiting'", ")", "\n", "exit", "(", "1", ")", "\n", "# [[case1-ch1, case1-ch2], ..., [caseN-ch1, caseN-ch2]]", "\n", "", "channels", "=", "[", "[", "normfullpath", "(", "abs_path", ",", "c", ")", "for", "c", "in", "list", "(", "item", "[", "c_names", "]", ")", "]", "for", "_", ",", "item", "in", "df", ".", "iterrows", "(", ")", "]", "\n", "\n", "try", ":", "\n", "        ", "gt", "=", "[", "normfullpath", "(", "abs_path", ",", "g", ")", "for", "g", "in", "list", "(", "df", "[", "'ground_truth'", "]", ")", "]", "\n", "", "except", "KeyError", ":", "\n", "        ", "gt", "=", "None", "\n", "if", "req_gt", ":", "\n", "            ", "raise", "Exception", "(", "'No ground truth column in dataframe, as required. Column should be named \"ground_truth\".'", ")", "\n", "", "", "try", ":", "\n", "        ", "roi", "=", "[", "normfullpath", "(", "abs_path", ",", "r", ")", "for", "r", "in", "list", "(", "df", "[", "'roi_mask'", "]", ")", "]", "\n", "", "except", "KeyError", ":", "\n", "        ", "roi", "=", "None", "\n", "log", ".", "print3", "(", "'No roi masks column in dataframe. Column should be named \"roi_mask\".'", ")", "\n", "\n", "", "try", ":", "\n", "        ", "pred", "=", "[", "p", "for", "p", "in", "list", "(", "df", "[", "'prediction_filename'", "]", ")", "]", "\n", "", "except", "KeyError", ":", "\n", "        ", "pred", "=", "None", "\n", "\n", "", "return", "channels", ",", "gt", ",", "roi", ",", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_fpaths_of_channs_from_filelists": [[133, 148], ["utils.abs_from_rel_path", "chan_fpaths_per_chan_per_case.append", "list", "utils.parse_filelist", "zip", "tuple"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.abs_from_rel_path", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.utils.parse_filelist"], ["", "def", "parse_fpaths_of_channs_from_filelists", "(", "list_of_filelists", ",", "abs_path_root", ")", ":", "\n", "    ", "\"\"\"\n    list_of_filelists: list with one filepath per channel. Each path points to the file-list for the channel.\n                       The file-list is a list with 1 row per case. Each row is the path to the corresponding\n                       image of the case for the specific channel.\n    abs_path_root: list_of_filelists may contain relative paths. This is the absolute path that they relate to.\n    \"\"\"", "\n", "chan_fpaths_per_chan_per_case", "=", "[", "]", "\n", "for", "path_to_filelist_for_chan", "in", "list_of_filelists", ":", "\n", "# The below: [[case1-ch1, ..., caseN-ch1], [case1-ch2,...,caseN-ch2]]", "\n", "        ", "abs_path_to_filelist_for_chan", "=", "abs_from_rel_path", "(", "path_to_filelist_for_chan", ",", "abs_path_root", ")", "\n", "chan_fpaths_per_chan_per_case", ".", "append", "(", "parse_filelist", "(", "abs_path_to_filelist_for_chan", ",", "make_abs", "=", "True", ")", ")", "\n", "# The below [[case1-ch1, case1-ch2], ..., [caseN-ch1, caseN-ch2]]", "\n", "", "channels_fpaths", "=", "[", "list", "(", "item", ")", "for", "item", "in", "zip", "(", "*", "tuple", "(", "chan_fpaths_per_chan_per_case", ")", ")", "]", "\n", "return", "channels_fpaths", "\n", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.tensorboard_logger.TensorboardLogger.__init__": [[8, 10], ["tensorflow.compat.v1.summary.FileWriter"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "log_path", ",", "tf_graph", ")", ":", "\n", "        ", "self", ".", "logger", "=", "tf", ".", "compat", ".", "v1", ".", "summary", ".", "FileWriter", "(", "log_path", ",", "tf_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.tensorboard_logger.TensorboardLogger.add_summary": [[11, 15], ["tensorboard_logger.TensorboardLogger.logger.add_summary", "tensorboard_logger.TensorboardLogger.logger.flush", "tensorflow.compat.v1.Summary", "tensorflow.compat.v1.Summary.Value"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.tensorboard_logger.TensorboardLogger.add_summary"], ["", "def", "add_summary", "(", "self", ",", "value", ",", "name", ",", "step_num", ")", ":", "\n", "        ", "self", ".", "logger", ".", "add_summary", "(", "tf", ".", "compat", ".", "v1", ".", "Summary", "(", "value", "=", "[", "tf", ".", "compat", ".", "v1", ".", "Summary", ".", "Value", "(", "tag", "=", "name", ",", "simple_value", "=", "value", ")", "]", ")", ",", "\n", "global_step", "=", "step_num", ")", "\n", "self", ".", "logger", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.__init__": [[18, 56], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "log", ",", "\n", "training0orValidation1", ",", "\n", "epoch", ",", "# number Of epochs trained prior to this", "\n", "numberOfClasses", ",", "\n", "numberOfSubepochsPerEpoch", ",", "\n", "tensorboard_logger", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        tensorboard_logger: None if no tb logging, otherwise instance of deepmedic.logging.tensorboard_logger.TensorboardLogger\n        \"\"\"", "\n", "self", ".", "tensorboard_logger", "=", "tensorboard_logger", "\n", "\n", "self", ".", "log", "=", "log", "\n", "self", ".", "training0orValidation1", "=", "training0orValidation1", "\n", "self", ".", "trainOrValString", "=", "\"TRAINING\"", "if", "self", ".", "training0orValidation1", "==", "0", "else", "\"VALIDATION\"", "\n", "self", ".", "epoch", "=", "epoch", "\n", "self", ".", "numberOfClasses", "=", "numberOfClasses", "\n", "self", ".", "numberOfSubepochsPerEpoch", "=", "numberOfSubepochsPerEpoch", "\n", "\n", "self", ".", "numberOfSubepochsForWhichUpdated", "=", "0", "\n", "\n", "# === Collecting accuracy metrics over the whole epoch: ===", "\n", "# --- mean Empirical Accuracy: number of Corr Classified voxels and all voxels, wrt to all the classes, in multiclass problems.---", "\n", "if", "self", ".", "training0orValidation1", "==", "0", ":", "\n", "            ", "self", ".", "meanCostOfEachSubep", "=", "[", "]", "# mean value of the cost function (training only)", "\n", "", "self", ".", "correctlyPredVoxelsInEachSubep", "=", "[", "]", "\n", "self", ".", "numberOfAllSamplesOfEachSubep", "=", "[", "]", "\n", "self", ".", "meanEmpiricalAccuracyOfEachSubep", "=", "[", "]", "# mean (multiclass) accuracy. correctlyPredVoxelsInEachSubep / numberOfAllSamplesOfEachSubep # NOTE: Cannot contain N0T-APPLICABLE", "\n", "\n", "# --- Per Class Accuracies and Real/True Pos/Neg (in a One-Vs-All fashion)", "\n", "# These do not have the class-0 background flipped to foreground!", "\n", "\n", "self", ".", "listPerSubepPerClassRpRnTpTn", "=", "[", "]", "# subepochs X Classes X 4. 4 = RP, RN, TP, TN", "\n", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "=", "[", "]", "# NOTE: May contain N0T-APPLICABLE=self.NA_PATTERN elements, eg when class not present!", "\n", "\n", "# For the merged-foreground, which is reported instead of class-0:", "\n", "self", ".", "listPerSubepForegrRpRnTpTn", "=", "[", "]", "\n", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "=", "[", "]", "# NOTE: May contain N0T-APPLICABLE=self.NA_PATTERN elements, eg when class not present!", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.get_avg_accuracy_ep": [[58, 60], ["numpy.mean"], "methods", ["None"], ["", "def", "get_avg_accuracy_ep", "(", "self", ")", ":", "# Multiclass mean accuracy. As in: Number-of-Voxels-Correctly-Classified / All-voxels", "\n", "        ", "return", "np", ".", "mean", "(", "self", ".", "meanEmpiricalAccuracyOfEachSubep", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.update_metrics_after_subep": [[63, 118], ["range", "accuracyMonitor.AccuracyMonitorForEpSegm.correctlyPredVoxelsInEachSubep.append", "accuracyMonitor.AccuracyMonitorForEpSegm.numberOfAllSamplesOfEachSubep.append", "accuracyMonitor.AccuracyMonitorForEpSegm.meanEmpiricalAccuracyOfEachSubep.append", "accuracyMonitor.AccuracyMonitorForEpSegm.listPerSubepPerClassRpRnTpTn.append", "range", "accuracyMonitor.AccuracyMonitorForEpSegm.listPerSubepPerClassMeanAccSensSpecDsc.append", "accuracyMonitor.AccuracyMonitorForEpSegm.listPerSubepForegrRpRnTpTn.append", "accuracyMonitor.AccuracyMonitorForEpSegm.listPerSubepForegrMeanAccSensSpecDsc.append", "accuracyMonitor.AccuracyMonitorForEpSegm.meanCostOfEachSubep.append", "listWithPerClassMeanAccSensSpecDscInSubep.append", "float", "float"], "methods", ["None"], ["", "def", "update_metrics_after_subep", "(", "self", ",", "meanCostOfSubepoch", ",", "perClassRpRnTpTnInSubep", ")", ":", "\n", "# perClassRpRnTpTnInSubep # Class X 4. The Real Pos, Real Neg, True Pos (pred), True Neg (pred).", "\n", "#---------- This first part takes care of the overall, multi-class mean accuracy: meanAccuracy = Num-Voxels-Predicted-Correct-Class / All-Voxels. ", "\n", "        ", "if", "self", ".", "training0orValidation1", "==", "0", ":", "\n", "            ", "self", ".", "meanCostOfEachSubep", ".", "append", "(", "meanCostOfSubepoch", ")", "\n", "\n", "", "correctlyPredVoxelsInSubep", "=", "0", ";", "# Predicted with the correct class.", "\n", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "            ", "correctlyPredVoxelsInSubep", "+=", "perClassRpRnTpTnInSubep", "[", "class_i", "]", "[", "2", "]", "# Add up the true positives per class (which are one vs all).", "\n", "", "self", ".", "correctlyPredVoxelsInEachSubep", ".", "append", "(", "correctlyPredVoxelsInSubep", ")", "\n", "numberOfAllSamples", "=", "perClassRpRnTpTnInSubep", "[", "0", ",", "0", "]", "+", "perClassRpRnTpTnInSubep", "[", "0", ",", "1", "]", "#RealPos + RealNeg wrt any class (eg backgr)", "\n", "self", ".", "numberOfAllSamplesOfEachSubep", ".", "append", "(", "numberOfAllSamples", ")", "\n", "meanAccuracyOfSubepoch", "=", "self", ".", "NA_PATTERN", "if", "numberOfAllSamples", "==", "0", "else", "correctlyPredVoxelsInSubep", "*", "1.0", "/", "numberOfAllSamples", "\n", "self", ".", "meanEmpiricalAccuracyOfEachSubep", ".", "append", "(", "meanAccuracyOfSubepoch", ")", "\n", "\n", "#----------- Calculate accuracy over subepoch for each class_i, in a One-Vs-All fashion ------", "\n", "\n", "self", ".", "listPerSubepPerClassRpRnTpTn", ".", "append", "(", "perClassRpRnTpTnInSubep", ")", "\n", "\n", "listWithPerClassMeanAccSensSpecDscInSubep", "=", "[", "]", "# Classes x 4 . 4=Mean Acc, sens, spec, dsc.", "\n", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "            ", "numOfRealPosInSubep", "=", "perClassRpRnTpTnInSubep", "[", "class_i", ",", "0", "]", "\n", "numOfRealNegInSubep", "=", "perClassRpRnTpTnInSubep", "[", "class_i", ",", "1", "]", "\n", "numOfTruePosInSubep", "=", "perClassRpRnTpTnInSubep", "[", "class_i", ",", "2", "]", "\n", "numOfTrueNegInSubep", "=", "perClassRpRnTpTnInSubep", "[", "class_i", ",", "3", "]", "\n", "\n", "numOfFalsePosInSubep", "=", "numOfRealNegInSubep", "-", "numOfTrueNegInSubep", "\n", "\n", "meanAccuracyClassVsAllOfSubep", "=", "(", "numOfTruePosInSubep", "+", "numOfTrueNegInSubep", ")", "/", "float", "(", "numOfRealPosInSubep", "+", "numOfRealNegInSubep", ")", "\n", "meanAccuracyOnPosOfSubep", "=", "self", ".", "NA_PATTERN", "if", "numOfRealPosInSubep", "==", "0", "else", "numOfTruePosInSubep", "*", "1.0", "/", "numOfRealPosInSubep", "\n", "meanPrecOfSubep", "=", "self", ".", "NA_PATTERN", "if", "(", "numOfTruePosInSubep", "+", "numOfFalsePosInSubep", ")", "==", "0", "else", "numOfTruePosInSubep", "*", "1.0", "/", "(", "numOfTruePosInSubep", "+", "numOfFalsePosInSubep", ")", "\n", "meanAccuracyOnNegOfSubep", "=", "self", ".", "NA_PATTERN", "if", "numOfRealNegInSubep", "==", "0", "else", "numOfTrueNegInSubep", "*", "1.0", "/", "numOfRealNegInSubep", "\n", "# Compute dice for the subepoch training/validation batches!", "\n", "numOfPredPosInSubep", "=", "numOfRealNegInSubep", "-", "numOfTrueNegInSubep", "+", "numOfTruePosInSubep", "\n", "meanDiceOfSubep", "=", "self", ".", "NA_PATTERN", "if", "numOfRealPosInSubep", "==", "0", "else", "(", "2.0", "*", "numOfTruePosInSubep", ")", "/", "(", "numOfPredPosInSubep", "+", "numOfRealPosInSubep", ")", "\n", "\n", "listWithPerClassMeanAccSensSpecDscInSubep", ".", "append", "(", "[", "meanAccuracyClassVsAllOfSubep", ",", "meanAccuracyOnPosOfSubep", ",", "meanPrecOfSubep", ",", "meanAccuracyOnNegOfSubep", ",", "meanDiceOfSubep", "]", ")", "\n", "", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ".", "append", "(", "listWithPerClassMeanAccSensSpecDscInSubep", ")", "\n", "\n", "# ===============UPDATE THE MERGED FOREGROUND CLASS. (used in multi-class problems instead of class-0 background).================", "\n", "# RealNeg/Pos of background is the RealPos/Neg of the foreground. TrueNeg/Pos of background is the TruePos/Neg of the foreground.", "\n", "foregrTp", "=", "perClassRpRnTpTnInSubep", "[", "0", "]", "[", "3", "]", ";", "foregrTn", "=", "perClassRpRnTpTnInSubep", "[", "0", "]", "[", "2", "]", ";", "foregrRp", "=", "perClassRpRnTpTnInSubep", "[", "0", "]", "[", "1", "]", ";", "foregrRn", "=", "perClassRpRnTpTnInSubep", "[", "0", "]", "[", "0", "]", "\n", "foregrFp", "=", "foregrRn", "-", "foregrTn", "\n", "self", ".", "listPerSubepForegrRpRnTpTn", ".", "append", "(", "[", "foregrRp", ",", "foregrRn", ",", "foregrTp", ",", "foregrTn", "]", ")", "\n", "\n", "foregrMeanAccOfSubep", "=", "(", "foregrTp", "+", "foregrTn", ")", "/", "float", "(", "foregrRp", "+", "foregrRn", ")", "\n", "foregrMeanAccOnPosOfSubep", "=", "self", ".", "NA_PATTERN", "if", "foregrRp", "==", "0", "else", "foregrTp", "*", "1.0", "/", "foregrRp", "\n", "foregrMeanPrecOfSubep", "=", "self", ".", "NA_PATTERN", "if", "(", "foregrTp", "+", "foregrFp", ")", "==", "0", "else", "foregrTp", "*", "1.0", "/", "(", "foregrTp", "+", "foregrFp", ")", "\n", "foregrMeanAccOnNegOfSubep", "=", "self", ".", "NA_PATTERN", "if", "foregrRn", "==", "0", "else", "foregrTn", "*", "1.0", "/", "foregrRn", "\n", "foregrPredPosInSubep", "=", "foregrRn", "-", "foregrTn", "+", "foregrTp", "\n", "foregrMeanDiceOfSubep", "=", "self", ".", "NA_PATTERN", "if", "foregrRp", "==", "0", "else", "(", "2.0", "*", "foregrTp", ")", "/", "(", "foregrPredPosInSubep", "+", "foregrRp", ")", "\n", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ".", "append", "(", "[", "foregrMeanAccOfSubep", ",", "foregrMeanAccOnPosOfSubep", ",", "foregrMeanPrecOfSubep", ",", "foregrMeanAccOnNegOfSubep", ",", "foregrMeanDiceOfSubep", "]", ")", "\n", "\n", "# Done!", "\n", "self", ".", "numberOfSubepochsForWhichUpdated", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_acc_subep_to_txt": [[119, 160], ["accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "range", "str", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "str", "str", "str", "deepmedic.logging.utils.strFl5fNA", "str", "str", "str", "str", "deepmedic.logging.utils.strFl4fNA", "str", "str", "str", "str", "str", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl5fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA"], ["", "def", "log_acc_subep_to_txt", "(", "self", ")", ":", "\n", "        ", "currSubep", "=", "self", ".", "numberOfSubepochsForWhichUpdated", "-", "1", "\n", "logStr", "=", "self", ".", "trainOrValString", "+", "\": Epoch #\"", "+", "str", "(", "self", ".", "epoch", ")", "+", "\", Subepoch #\"", "+", "str", "(", "currSubep", ")", "\n", "self", ".", "log", ".", "print3", "(", "\"\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "\"+++++++++++++++++++++++ Reporting Accuracy over whole subepoch +++++++++++++++++++++++\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean accuracy:   \\t\"", "+", "strFl4fNA", "(", "self", ".", "meanEmpiricalAccuracyOfEachSubep", "[", "currSubep", "]", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> Correctly-Classified-Voxels/All-Predicted-Voxels = \"", "+", "str", "(", "self", ".", "correctlyPredVoxelsInEachSubep", "[", "currSubep", "]", ")", "+", "\"/\"", "+", "str", "(", "self", ".", "numberOfAllSamplesOfEachSubep", "[", "currSubep", "]", ")", ")", "\n", "if", "self", ".", "training0orValidation1", "==", "0", ":", "# During training, also report the mean value of the Cost Function:", "\n", "            ", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean cost:      \\t\"", "+", "strFl5fNA", "(", "self", ".", "meanCostOfEachSubep", "[", "currSubep", "]", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n", "# Report accuracy over subepoch for each class_i:", "\n", "", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "            ", "class_string", "=", "\"Class-\"", "+", "str", "(", "class_i", ")", "\n", "extraDescription", "=", "\"[Whole Foreground (Pos) Vs Background (Neg)]\"", "if", "class_i", "==", "0", "else", "\"[This Class (Pos) Vs All Others (Neg)]\"", "\n", "\n", "self", ".", "log", ".", "print3", "(", "\"+++++++++++++++ Reporting Accuracy over whole subepoch for \"", "+", "class_string", "+", "\" ++++++++ \"", "+", "extraDescription", "+", "\" ++++++++++++++++\"", ")", "\n", "\n", "[", "meanAccClassOfSubep", ",", "\n", "meanAccOnPosOfSubep", ",", "\n", "meanPrecOfSubep", ",", "\n", "meanAccOnNegOfSubep", ",", "\n", "meanDiceOfSubep", "]", "=", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "currSubep", "]", "[", "class_i", "]", "if", "class_i", "!=", "0", "else", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "currSubep", "]", "# If class-0, report foreground.", "\n", "[", "numOfRpInSubep", ",", "\n", "numOfRnInSubep", ",", "\n", "numOfTpInSubep", ",", "\n", "numOfTnInSubep", "]", "=", "self", ".", "listPerSubepPerClassRpRnTpTn", "[", "currSubep", "]", "[", "class_i", "]", "if", "class_i", "!=", "0", "else", "self", ".", "listPerSubepForegrRpRnTpTn", "[", "currSubep", "]", "# If class-0, report foreground.", "\n", "\n", "numOfFpInSubep", "=", "numOfRnInSubep", "-", "numOfTnInSubep", "\n", "\n", "logStrClass", "=", "logStr", "+", "\", \"", "+", "class_string", "+", "\":\"", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean accuracy:   \\t\"", "+", "\n", "strFl4fNA", "(", "meanAccClassOfSubep", ",", "self", ".", "NA_PATTERN", ")", "+", "\n", "\"\\t=> (TruePos+TrueNeg)/All-Predicted-Voxels = \"", "+", "\n", "str", "(", "numOfTpInSubep", "+", "numOfTnInSubep", ")", "+", "\"/\"", "+", "\n", "str", "(", "numOfRpInSubep", "+", "numOfRnInSubep", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean sensitivity:\\t\"", "+", "strFl4fNA", "(", "meanAccOnPosOfSubep", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TruePos/RealPos = \"", "+", "str", "(", "numOfTpInSubep", ")", "+", "\"/\"", "+", "str", "(", "numOfRpInSubep", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean precision:\\t\"", "+", "strFl4fNA", "(", "meanPrecOfSubep", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TruePos/(TruePos+FalsePos) = \"", "+", "str", "(", "numOfTpInSubep", ")", "+", "\"/\"", "+", "str", "(", "numOfTpInSubep", "+", "numOfFpInSubep", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean specificity:\\t\"", "+", "strFl4fNA", "(", "meanAccOnNegOfSubep", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TrueNeg/RealNeg = \"", "+", "str", "(", "numOfTnInSubep", ")", "+", "\"/\"", "+", "str", "(", "numOfRnInSubep", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean Dice:       \\t\"", "+", "strFl4fNA", "(", "meanDiceOfSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard": [[161, 167], ["metrics_dict.items", "accuracyMonitor.AccuracyMonitorForEpSegm.tensorboard_logger.add_summary"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.tensorboard_logger.TensorboardLogger.add_summary"], ["", "", "def", "log_to_tensorboard", "(", "self", ",", "metrics_dict", ",", "class_string", ",", "step_num", ")", ":", "\n", "        ", "if", "self", ".", "tensorboard_logger", "is", "not", "None", ":", "\n", "            ", "for", "metric", ",", "value", "in", "metrics_dict", ".", "items", "(", ")", ":", "\n", "                ", "if", "value", "==", "self", ".", "NA_PATTERN", ":", "\n", "                    ", "value", "=", "np", ".", "nan", "\n", "", "self", ".", "tensorboard_logger", ".", "add_summary", "(", "value", ",", "metric", "+", "'/'", "+", "class_string", ",", "step_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_acc_subep_to_tensorboard": [[168, 218], ["accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "range", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard", "str", "str", "str", "str", "str", "list", "str", "list", "metrics_dict.keys", "metrics_dict.keys"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard"], ["", "", "", "def", "log_acc_subep_to_tensorboard", "(", "self", ")", ":", "\n", "        ", "currSubep", "=", "self", ".", "numberOfSubepochsForWhichUpdated", "-", "1", "\n", "\n", "self", ".", "log", ".", "print3", "(", "'=============== LOGGING TO TENSORBOARD ==============='", ")", "\n", "# check if user included tensorboard logging in the config", "\n", "if", "self", ".", "tensorboard_logger", "is", "None", ":", "\n", "            ", "self", ".", "log", ".", "print3", "(", "'Tensorboard logging not activated. Skipping...'", ")", "\n", "self", ".", "log", ".", "print3", "(", "'======================================================'", ")", "\n", "return", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "'Logging '", "+", "self", ".", "trainOrValString", "+", "' metrics'", ")", "\n", "self", ".", "log", ".", "print3", "(", "'Epoch: '", "+", "str", "(", "self", ".", "epoch", ")", "+", "\n", "' | Subepoch '", "+", "str", "(", "currSubep", ")", ")", "\n", "step_num", "=", "currSubep", "+", "(", "self", ".", "epoch", "*", "(", "self", ".", "numberOfSubepochsPerEpoch", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "'Step number (index of subepoch since start): '", "+", "str", "(", "step_num", ")", ")", "\n", "\n", "# During training, also report the mean value of the Cost Function:", "\n", "if", "self", ".", "training0orValidation1", "==", "0", "and", "self", ".", "tensorboard_logger", "is", "not", "None", ":", "\n", "            ", "self", ".", "log", ".", "print3", "(", "'--- Logging average metrics for all classes ---'", ")", "\n", "\n", "# create metrics dictionary", "\n", "metrics_dict", "=", "{", "'samples: accuracy'", ":", "self", ".", "meanEmpiricalAccuracyOfEachSubep", "[", "currSubep", "]", ",", "\n", "'samples: cost'", ":", "self", ".", "meanCostOfEachSubep", "[", "currSubep", "]", "}", "\n", "class_string", "=", "'Class-all'", "\n", "self", ".", "log_to_tensorboard", "(", "metrics_dict", ",", "class_string", ",", "step_num", ")", "\n", "\n", "self", ".", "log", ".", "print3", "(", "'Logged metrics: '", "+", "str", "(", "list", "(", "metrics_dict", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "# Report accuracy over subepoch for each class_i:", "\n", "", "self", ".", "log", ".", "print3", "(", "'--- Logging per class metrics ---'", ")", "\n", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "            ", "class_string", "=", "\"Class-\"", "+", "str", "(", "class_i", ")", "\n", "\n", "[", "meanAccClassOfSubep", ",", "\n", "meanAccOnPosOfSubep", ",", "\n", "meanPrecOfSubep", ",", "\n", "meanAccOnNegOfSubep", ",", "\n", "meanDiceOfSubep", "]", "=", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "currSubep", "]", "[", "class_i", "]", "if", "class_i", "!=", "0", "else", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "currSubep", "]", "# If class-0, report foreground.", "\n", "\n", "# create metrics dictionary", "\n", "metrics_dict", "=", "{", "'samples: accuracy'", ":", "meanAccClassOfSubep", ",", "\n", "'samples: sensitivity'", ":", "meanAccOnPosOfSubep", ",", "\n", "'samples: precision'", ":", "meanPrecOfSubep", ",", "\n", "'samples: specificity'", ":", "meanAccOnNegOfSubep", ",", "\n", "'samples: Dice'", ":", "meanDiceOfSubep", "}", "\n", "self", ".", "log_to_tensorboard", "(", "metrics_dict", ",", "class_string", ",", "step_num", ")", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "'Logged metrics: '", "+", "str", "(", "list", "(", "metrics_dict", ".", "keys", "(", ")", ")", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "'======================================================'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_whole_vols": [[220, 248], ["accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "range", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard", "str", "str", "str", "str", "list", "metrics_dict.keys"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.log_to_tensorboard"], ["", "def", "report_metrics_whole_vols", "(", "self", ",", "mean_metrics", ")", ":", "\n", "# mean_metrics: ", "\n", "# metrics_dict_list: list that holds one element per class, [ elem-class0, elem-class1, .... ]", "\n", "#                    Each element is a dictionary of metrics for the class.", "\n", "#                    E.g. elem-class0 = {'dice1': value, 'dice2': value, dice3': value}", "\n", "        ", "self", ".", "log", ".", "print3", "(", "'=============== LOGGING TO TENSORBOARD ==============='", ")", "\n", "if", "self", ".", "tensorboard_logger", "is", "None", ":", "\n", "            ", "self", ".", "log", ".", "print3", "(", "'Tensorboard logging not activated. Skipping...'", ")", "\n", "self", ".", "log", ".", "print3", "(", "'======================================================'", ")", "\n", "return", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "'Logging validation metrics from segmentation of whole validation volumes.'", ")", "\n", "self", ".", "log", ".", "print3", "(", "'Epoch: '", "+", "str", "(", "self", ".", "epoch", ")", ")", "\n", "step_num", "=", "self", ".", "numberOfSubepochsPerEpoch", "-", "1", "+", "(", "self", ".", "epoch", "*", "self", ".", "numberOfSubepochsPerEpoch", ")", "\n", "self", ".", "log", ".", "print3", "(", "'Step number (index of subepoch since start): '", "+", "str", "(", "step_num", ")", ")", "\n", "\n", "# Report mean metrics for each class_i:", "\n", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "# the keys for the below are defined in testing.py routine.", "\n", "            ", "metrics_dict", "=", "{", "'whole scans: Dice1 (Prediction VS Truth)'", ":", "mean_metrics", "[", "'dice1'", "]", "[", "class_i", "]", ",", "\n", "'whole scans: Dice2 (Prediction within ROI mask VS Truth)'", ":", "mean_metrics", "[", "'dice2'", "]", "[", "class_i", "]", ",", "\n", "'whole scans: Dice3 (Prediction VS Truth, both within ROI mask)'", ":", "mean_metrics", "[", "'dice3'", "]", "[", "class_i", "]", "\n", "}", "\n", "class_string", "=", "'Class-'", "+", "str", "(", "class_i", ")", "\n", "self", ".", "log_to_tensorboard", "(", "metrics_dict", ",", "class_string", ",", "step_num", ")", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "'Logged metrics: '", "+", "str", "(", "list", "(", "metrics_dict", ".", "keys", "(", ")", ")", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "'======================================================'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.accuracyMonitor.AccuracyMonitorForEpSegm.report_metrics_samples_ep": [[250, 307], ["accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "deepmedic.logging.utils.getMeanOfListExclNA", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "range", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "str", "deepmedic.logging.utils.getMeanOfListExclNA", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "deepmedic.logging.utils.getMeanOfListExclNA", "deepmedic.logging.utils.getMeanOfListExclNA", "deepmedic.logging.utils.getMeanOfListExclNA", "deepmedic.logging.utils.getMeanOfListExclNA", "deepmedic.logging.utils.getMeanOfListExclNA", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "accuracyMonitor.AccuracyMonitorForEpSegm.log.print3", "deepmedic.logging.utils.strListFl4fNA", "str", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl5fNA", "deepmedic.logging.utils.strListFl5fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "deepmedic.logging.utils.strListFl4fNA", "range", "range", "range", "range", "range", "range", "range", "range", "range", "range", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "deepmedic.logging.utils.strFl4fNA", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl5fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl5fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA"], ["", "def", "report_metrics_samples_ep", "(", "self", ")", ":", "\n", "        ", "logStr", "=", "self", ".", "trainOrValString", "+", "\": Epoch #\"", "+", "str", "(", "self", ".", "epoch", ")", "\n", "\n", "# Report the multi-class accuracy first.", "\n", "self", ".", "log", ".", "print3", "(", "\"( >>>>>>>>>>>>>>>>>>>> Reporting Accuracy over whole epoch <<<<<<<<<<<<<<<<<<<<<<<<<<<<\"", ")", "\n", "meanEmpiricalAccOfEp", "=", "getMeanOfListExclNA", "(", "self", ".", "meanEmpiricalAccuracyOfEachSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean accuracy of epoch:\\t\"", "+", "strFl4fNA", "(", "meanEmpiricalAccOfEp", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> Correctly-Classified-Voxels/All-Predicted-Voxels\"", ")", "\n", "if", "self", ".", "training0orValidation1", "==", "0", ":", "# During training, also report the mean value of the Cost Function:", "\n", "            ", "meanCostOfEp", "=", "getMeanOfListExclNA", "(", "self", ".", "meanCostOfEachSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean cost of epoch:    \\t\"", "+", "strFl5fNA", "(", "meanCostOfEp", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean accuracy of each subepoch:\\t\"", "+", "strListFl4fNA", "(", "self", ".", "meanEmpiricalAccuracyOfEachSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "if", "self", ".", "training0orValidation1", "==", "0", ":", "\n", "            ", "self", ".", "log", ".", "print3", "(", "logStr", "+", "\", Overall:\\t mean cost of each subepoch:    \\t\"", "+", "strListFl5fNA", "(", "self", ".", "meanCostOfEachSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n", "# Report for each class.", "\n", "", "for", "class_i", "in", "range", "(", "self", ".", "numberOfClasses", ")", ":", "\n", "            ", "class_string", "=", "\"Class-\"", "+", "str", "(", "class_i", ")", "\n", "extraDescription", "=", "\"[Whole Foreground (Pos) Vs Background (Neg)]\"", "if", "class_i", "==", "0", "else", "\"[This Class (Pos) Vs All Others (Neg)]\"", "\n", "\n", "self", ".", "log", ".", "print3", "(", "\">>>>>>>>>>>> Reporting Accuracy over whole epoch for \"", "+", "class_string", "+", "\" >>>>>>>>> \"", "+", "extraDescription", "+", "\" <<<<<<<<<<<<<\"", ")", "\n", "\n", "if", "class_i", "!=", "0", ":", "\n", "                ", "meanAccPerSubep", "=", "[", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "class_i", "]", "[", "0", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanSensPerSubep", "=", "[", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "class_i", "]", "[", "1", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanPrecPerSubep", "=", "[", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "class_i", "]", "[", "2", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanSpecPerSubep", "=", "[", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "class_i", "]", "[", "3", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanDscPerSubep", "=", "[", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "class_i", "]", "[", "4", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepPerClassMeanAccSensSpecDsc", ")", ")", "]", "\n", "", "else", ":", "# Foreground Vs Background", "\n", "                ", "meanAccPerSubep", "=", "[", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "0", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanSensPerSubep", "=", "[", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "1", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanPrecPerSubep", "=", "[", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "2", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanSpecPerSubep", "=", "[", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "3", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ")", ")", "]", "\n", "meanDscPerSubep", "=", "[", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", "[", "subep_i", "]", "[", "4", "]", "for", "subep_i", "in", "range", "(", "len", "(", "self", ".", "listPerSubepForegrMeanAccSensSpecDsc", ")", ")", "]", "\n", "\n", "", "meanAccOfEp", "=", "getMeanOfListExclNA", "(", "meanAccPerSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "meanSensOfEp", "=", "getMeanOfListExclNA", "(", "meanSensPerSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "meanPrecOfEp", "=", "getMeanOfListExclNA", "(", "meanPrecPerSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "meanSpecOfEp", "=", "getMeanOfListExclNA", "(", "meanSpecPerSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "meanDscOfEp", "=", "getMeanOfListExclNA", "(", "meanDscPerSubep", ",", "self", ".", "NA_PATTERN", ")", "\n", "\n", "logStrClass", "=", "logStr", "+", "\", \"", "+", "class_string", "+", "\":\"", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean accuracy of epoch:\\t\"", "+", "strFl4fNA", "(", "meanAccOfEp", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> (TruePos+TrueNeg)/All-Predicted-Voxels\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean sensitivity of epoch:\\t\"", "+", "strFl4fNA", "(", "meanSensOfEp", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TruePos/RealPos\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean precision of epoch:\\t\"", "+", "strFl4fNA", "(", "meanPrecOfEp", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TruePos/(TruePos+FalsePos)\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean specificity of epoch:\\t\"", "+", "strFl4fNA", "(", "meanSpecOfEp", ",", "self", ".", "NA_PATTERN", ")", "+", "\"\\t=> TrueNeg/RealNeg\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean Dice of epoch:    \\t\"", "+", "strFl4fNA", "(", "meanDscOfEp", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n", "#Visualised in my scripts:", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean accuracy of each subepoch:\\t\"", "+", "strListFl4fNA", "(", "meanAccPerSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean sensitivity of each subepoch:\\t\"", "+", "strListFl4fNA", "(", "meanSensPerSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean precision of each subepoch:\\t\"", "+", "strListFl4fNA", "(", "meanPrecPerSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean specificity of each subepoch:\\t\"", "+", "strListFl4fNA", "(", "meanSpecPerSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "self", ".", "log", ".", "print3", "(", "logStrClass", "+", "\"\\t mean Dice of each subepoch:    \\t\"", "+", "strListFl4fNA", "(", "meanDscPerSubep", ",", "self", ".", "NA_PATTERN", ")", ")", "\n", "\n", "", "self", ".", "log", ".", "print3", "(", "\">>>>>>>>>>>>>>>>>>>>>>>>> End Of Accuracy Report at the end of Epoch <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"", ")", "\n", "self", ".", "log", ".", "print3", "(", "\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3": [[28, 36], ["print", "open", "datetime.datetime.now", "open.write", "open.close"], "methods", ["None"], ["def", "print3", "(", "self", ",", "string", ")", ":", "\n", "        ", "print", "(", "string", ")", "\n", "f", "=", "open", "(", "self", ".", "loggerFileName", ",", "'a'", ")", "\n", "now", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "now_str", "=", "\"{0}-{1}-{2} {3}:{4}:{5:.2f}\"", ".", "format", "(", "now", ".", "year", ",", "now", ".", "month", ",", "now", ".", "day", ",", "now", ".", "hour", ",", "now", ".", "minute", ",", "\n", "(", "now", ".", "second", "+", "now", ".", "microsecond", "/", "10", "**", "6", ")", ")", "\n", "f", ".", "write", "(", "now_str", "+", "\": \"", "+", "string", "+", "\"\\n\"", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print_pattern_line": [[37, 39], ["loggers.Logger.print3", "loggers.get_pattern_string"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string"], ["", "def", "print_pattern_line", "(", "self", ",", "pattern", "=", "'#'", ",", "line_width", "=", "80", ")", ":", "\n", "        ", "self", ".", "print3", "(", "get_pattern_string", "(", "pattern", "=", "pattern", ",", "width", "=", "line_width", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print_block": [[40, 109], ["text.split", "loggers.Logger.print_pattern_line", "len", "loggers.get_pattern_string", "loggers.Logger.print3", "loggers.Logger.print_pattern_line", "len", "paragraph.split", "len", "loggers.get_pattern_string", "len", "loggers.get_pattern_string", "max", "loggers.Logger.print3", "len", "len", "paragraph.split.insert", "loggers.get_pattern_string", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print_pattern_line", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print_pattern_line", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string"], ["", "def", "print_block", "(", "self", ",", "text", ",", "pattern", "=", "'#'", ",", "line_width", "=", "80", ",", "block", "=", "True", ",", "margin", "=", "5", ")", ":", "\n", "        ", "\"\"\"\n        Prints a block of text with a character pattern surrounding it.\n        :str text: the text to be written\n        :str pattern: the character pattern to surround the text with (default '#')\n        :int line_width: the total width of the line to be written (default 80)\n        :bool block: whether to add a line of pattern only below and above the text block (default True)\n        :int margin: the length of the margin (default 5)\n        \"\"\"", "\n", "\n", "if", "block", ":", "\n", "            ", "self", ".", "print_pattern_line", "(", "pattern", ",", "line_width", ")", "\n", "\n", "", "text_width", "=", "line_width", "-", "margin", "*", "2", "-", "2", "\n", "\n", "if", "len", "(", "text", ")", ">", "text_width", ":", "\n", "            ", "long_block", "=", "True", "\n", "", "else", ":", "\n", "            ", "long_block", "=", "False", "\n", "\n", "# get paragraphs", "\n", "", "paragraphs", "=", "text", ".", "split", "(", "'\\n'", ")", "\n", "\n", "if", "long_block", "or", "len", "(", "paragraphs", ")", ">", "1", ":", "# left aligned", "\n", "            ", "for", "paragraph", "in", "paragraphs", ":", "\n", "# get words", "\n", "                ", "text_split", "=", "paragraph", ".", "split", "(", ")", "\n", "# while there is still text to write", "\n", "while", "len", "(", "text_split", ")", ">", "0", ":", "\n", "# left margin", "\n", "                    ", "string", "=", "get_pattern_string", "(", "pattern", "=", "pattern", ",", "width", "=", "margin", ")", "\n", "text_len", "=", "0", "\n", "i", "=", "0", "\n", "while", "i", "<", "len", "(", "text_split", ")", "and", "text_len", "+", "len", "(", "text_split", "[", "i", "]", ")", "+", "i", "<", "text_width", ":", "\n", "                        ", "text_len", "+=", "len", "(", "text_split", "[", "i", "]", ")", "\n", "i", "+=", "1", "\n", "\n", "", "text_len", "+=", "max", "(", "i", "-", "1", ",", "0", ")", "\n", "\n", "if", "i", "==", "0", ":", "# word is longer than the available text width. Must split", "\n", "                        ", "text_split", ".", "insert", "(", "1", ",", "text_split", "[", "0", "]", "[", "text_width", "-", "1", ":", "]", ")", "\n", "text_split", "[", "0", "]", "=", "text_split", "[", "0", "]", "[", ":", "text_width", "-", "1", "]", "+", "'-'", "\n", "text_len", "=", "text_width", "\n", "i", "=", "1", "\n", "\n", "# add text", "\n", "", "string", "+=", "' '", "+", "' '", ".", "join", "(", "text_split", "[", ":", "i", "]", ")", "\n", "# add whitespace", "\n", "string", "+=", "' '", "*", "(", "text_width", "-", "text_len", "+", "1", ")", "\n", "# add right margin", "\n", "string", "+=", "get_pattern_string", "(", "pattern", ",", "width", "=", "line_width", ")", "[", "-", "margin", ":", "]", "\n", "\n", "self", ".", "print3", "(", "string", ")", "\n", "\n", "if", "i", ">=", "len", "(", "text_split", ")", ":", "\n", "                        ", "break", "\n", "", "else", ":", "\n", "                        ", "text_split", "=", "text_split", "[", "i", ":", "]", "\n", "", "", "", "", "else", ":", "# centre align", "\n", "            ", "left_space", "=", "(", "text_width", "-", "len", "(", "text", ")", ")", "//", "2", "\n", "right_space", "=", "text_width", "-", "left_space", "-", "len", "(", "text", ")", "\n", "string", "=", "get_pattern_string", "(", "pattern", "=", "pattern", ",", "width", "=", "margin", "+", "left_space", ")", "\n", "string", "+=", "' '", "+", "text", "+", "' '", "\n", "string", "+=", "get_pattern_string", "(", "pattern", "=", "pattern", ",", "width", "=", "line_width", ")", "[", "-", "(", "margin", "+", "right_space", ")", ":", "]", "\n", "\n", "self", ".", "print3", "(", "string", ")", "\n", "\n", "", "if", "block", ":", "\n", "            ", "self", ".", "print_pattern_line", "(", "pattern", ",", "line_width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.__init__": [[110, 113], ["loggers.Logger.print3"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "__init__", "(", "self", ",", "log_path", "=", "\"logs/defaultLogFile.txt\"", ")", ":", "\n", "        ", "self", ".", "loggerFileName", "=", "log_path", "\n", "self", ".", "print3", "(", "\"=============================== logger created =======================================\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.get_pattern_string": [[12, 23], ["len", "len"], "function", ["None"], ["def", "get_pattern_string", "(", "pattern", "=", "'#'", ",", "width", "=", "80", ")", ":", "\n", "    ", "if", "width", "==", "0", ":", "\n", "        ", "return", "''", "\n", "\n", "", "string", "=", "pattern", "*", "(", "width", "//", "len", "(", "pattern", ")", ")", "\n", "leftover", "=", "width", "%", "len", "(", "pattern", ")", "\n", "\n", "if", "leftover", "!=", "0", ":", "\n", "        ", "string", "+=", "pattern", "[", ":", "leftover", "]", "\n", "\n", "", "return", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXDec": [[13, 17], ["stringThatSaysHowManyDecimals.format", "str"], "function", ["None"], ["def", "abs_from_rel_path", "(", "pathGiven", ",", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "#os.path.normpath \"cleans\" Additional ../.// etc.", "\n", "    ", "if", "os", ".", "path", ".", "isabs", "(", "pathGiven", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "normpath", "(", "pathGiven", ")", "\n", "", "else", ":", "#relative path given. Need to make absolute path", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4Dec": [[17, 19], ["utils.strFlXDec"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXDec"], ["", "else", ":", "#relative path given. Need to make absolute path", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "absolutePathToWhereRelativePathRelatesTo", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl5Dec": [[19, 21], ["utils.strFlXDec"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXDec"], ["            ", "relativePathToWhatGiven", "=", "absolutePathToWhereRelativePathRelatesTo", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "os", ".", "path", ".", "dirname", "(", "absolutePathToWhereRelativePathRelatesTo", ")", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlListXDec": [[22, 30], ["str"], "function", ["None"], ["", "else", ":", "#not file, not dir, exit.", "\n", "            ", "print", "(", "\"ERROR: in [func:returnAbsolutePathEvenIfRelativePathIsGiven()] Given path :\"", ",", "absolutePathToWhereRelativePathRelatesTo", ",", "\" does not correspond to neither an existing file nor a directory. Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "return", "os", ".", "path", ".", "normpath", "(", "relativePathToWhatGiven", "+", "\"/\"", "+", "pathGiven", ")", "\n", "\n", "\n", "", "", "def", "checkIfAllElementsOfAListAreFilesAndExitIfNot", "(", "pathToTheListingFile", ",", "list1", ")", ":", "\n", "    ", "for", "filepath", "in", "list1", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "print", "(", "\"ERROR: in [checkIfAllElementsOfAListExistAndExitIfNot()] path:\"", ",", "filepath", ",", "\" given in :\"", ",", "pathToTheListingFile", ",", "\" does not correspond to a file. Exiting!\"", ")", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlList4Dec": [[30, 32], ["utils.strFlListXDec"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlListXDec"], ["            ", "print", "(", "\"ERROR: in [checkIfAllElementsOfAListExistAndExitIfNot()] path:\"", ",", "filepath", ",", "\" given in :\"", ",", "pathToTheListingFile", ",", "\" does not correspond to a file. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXfNA": [[35, 38], ["stringThatSaysHowManyDecimals.format", "str"], "function", ["None"], ["# os.path.normpath below is to \"clean\" the paths from ./..//...", "\n", "    ", "path_to_folder_w_filelist", "=", "os", ".", "path", ".", "dirname", "(", "filelist_path", ")", "\n", "list1", "=", "[", "]", "\n", "with", "open", "(", "filelist_path", ",", "\"r\"", ")", "as", "inp", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl4fNA": [[38, 40], ["utils.strFlXfNA"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXfNA"], ["with", "open", "(", "filelist_path", ",", "\"r\"", ")", "as", "inp", ":", "\n", "        ", "for", "line", "in", "inp", ":", "\n", "            ", "if", "line", ".", "strip", "(", ")", "==", "\"-\"", ":", "# Special char. E.g. indicating the non existence of channel, to be zero-filled.", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFl5fNA": [[40, 42], ["utils.strFlXfNA"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strFlXfNA"], ["            ", "if", "line", ".", "strip", "(", ")", "==", "\"-\"", ":", "# Special char. E.g. indicating the non existence of channel, to be zero-filled.", "\n", "                ", "list1", ".", "append", "(", "\"-\"", ")", "\n", "", "elif", "not", "line", ".", "startswith", "(", "\"#\"", ")", "and", "line", ".", "strip", "(", ")", "!=", "\"\"", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFlXfNA": [[43, 50], ["str"], "function", ["None"], ["                ", "path_to_file", "=", "line", ".", "strip", "(", ")", "\n", "\n", "if", "(", "not", "make_abs", ")", "or", "os", ".", "path", ".", "isabs", "(", "path_to_file", ")", ":", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_file", ")", ")", "\n", "", "else", ":", "# relative path to this listing-file.", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_folder_w_filelist", "+", "\"/\"", "+", "path_to_file", ")", ")", "\n", "", "", "", "", "return", "list1", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl4fNA": [[51, 53], ["utils.strListFlXfNA"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFlXfNA"], ["\n", "", "def", "checkListContainsCorrectNumberOfCasesOtherwiseExitWithError", "(", "numberOfCasesPreviously", ",", "pathToGivenListFile", ",", "listOfFilepathsToChannelIForEachCase", ")", ":", "\n", "    ", "numberOfContainedCasesInList", "=", "len", "(", "listOfFilepathsToChannelIForEachCase", ")", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFl5fNA": [[53, 55], ["utils.strListFlXfNA"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.strListFlXfNA"], ["    ", "numberOfContainedCasesInList", "=", "len", "(", "listOfFilepathsToChannelIForEachCase", ")", "\n", "if", "numberOfCasesPreviously", "!=", "numberOfContainedCasesInList", ":", "\n", "        ", "raise", "IOError", "(", "\"ERROR: Given file:\"", ",", "pathToGivenListFile", "+"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA": [[58, 68], ["range", "len", "float"], "function", ["None"], ["\n", "\n", "", "", "def", "checkThatAllEntriesOfAListFollowNameConventions", "(", "listOfPredictionNamesForEachCaseInListingFile", ")", ":", "\n", "    ", "for", "entry", "in", "listOfPredictionNamesForEachCaseInListingFile", ":", "\n", "        ", "if", "entry", ".", "find", "(", "\"/\"", ")", ">", "-", "1", "or", "entry", ".", "startswith", "(", "\".\"", ")", ":", "\n", "            ", "raise", "IOError", "(", "\"ERROR: Check that all entries follow name-conventions failed.\"", "+", "\"\\n\\t Entry \\\"\"", ",", "entry", ",", "\"\\\" was found to begin with \\'.\\' or contain \\'/\\'. Please correct this.\"", ")", "\n", "\n", "\n", "", "", "", "def", "check_and_adjust_path_to_ckpt", "(", "log", ",", "filepath_to_ckpt", ")", ":", "\n", "    ", "STR_DM_CKPT", "=", "\".model.ckpt\"", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanPerColOf2dListExclNA": [[69, 78], ["range", "len", "utils.getMeanOfListExclNA", "listWithMeanPerColumn.append", "range", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.getMeanOfListExclNA"], ["index_of_str", "=", "filepath_to_ckpt", ".", "rfind", "(", "STR_DM_CKPT", ")", "\n", "if", "index_of_str", ">", "-", "1", "and", "len", "(", "filepath_to_ckpt", ")", ">", "len", "(", "filepath_to_ckpt", "[", ":", "index_of_str", "]", ")", "+", "len", "(", "STR_DM_CKPT", ")", ":", "# found.", "\n", "\n", "        ", "user_input", "=", "None", "\n", "string_warn", "=", "\"It seems that the path to the model to load paramters from, a tensorflow checkpoint, was given wrong.\"", "+", "\"\\n\\t The path to checkpoint should be of the form: [...name...date...model.ckpt] (finishing with .ckpt)\"", "+", "\"\\n\\t Note that you should not point to the .data, .index or .meta files that are saved. Rather, shorten their names till the .ckpt\"", "+", "\"\\n\\t Given path seemed longer: \"", "+", "str", "(", "filepath_to_ckpt", ")", "\n", "try", ":", "\n", "            ", "user_input", "=", "input", "(", "\">>\\t \"", "+", "string_warn", "+"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.datetime_now_str": [[80, 86], ["str", "dateTimeNowStr.replace.replace", "dateTimeNowStr.replace.replace", "datetime.datetime.now"], "function", ["None"], ["while", "user_input", "not", "in", "[", "'y'", ",", "'n'", "]", ":", "\n", "                ", "user_input", "=", "input", "(", "\"Please specify 'y' or 'n': \"", ")", "\n", "", "", "except", ":", "\n", "            ", "log", ".", "print3", "(", "\"\\nWARN:\\t \"", "+", "string_warn", "+", "\"\\n\\t We tried to request command line input from user whether to shorten it after [.ckpt] but failed (remote use? nohup?\"", "+", "\"\\n\\t Continuing without doing anything. If this fails, try to give the correct path, ending with [.ckpt]\"", ")", "\n", "", "if", "user_input", "==", "'y'", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_tr_val": [[88, 92], ["max", "log.print3", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["log", ".", "print3", "(", "\"Changed path to load parameters from: \"", "+", "str", "(", "filepath_to_ckpt", ")", ")", "\n", "", "else", ":", "\n", "            ", "log", ".", "print3", "(", "\"Continuing without doing anything.\"", ")", "\n", "\n", "", "", "return", "filepath_to_ckpt", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.utils.print_progress_step_test": [[93, 97], ["max", "log.print3", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["\n", "\n", "", "def", "normfullpath", "(", "abspath", ",", "relpath", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "isabs", "(", "relpath", ")", ":", "\n", "        ", "return", "relpath", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.augment_sample": [[12, 22], ["augmentSample.random_histogram_distortion", "augmentSample.random_flip", "augmentSample.random_rotation_90"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_histogram_distortion", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_flip", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_rotation_90"], ["def", "augment_sample", "(", "channels", ",", "gt_lbls", ",", "prms", ")", ":", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# gt_lbls: np array of shape [x,y,z]", "\n", "# prms: None or Dictionary, with parameters of each augmentation type. }", "\n", "    ", "if", "prms", "is", "not", "None", ":", "\n", "        ", "channels", "=", "random_histogram_distortion", "(", "channels", ",", "prms", "[", "'hist_dist'", "]", ")", "\n", "channels", ",", "gt_lbls", "=", "random_flip", "(", "channels", ",", "gt_lbls", ",", "prms", "[", "'reflect'", "]", ")", "\n", "channels", ",", "gt_lbls", "=", "random_rotation_90", "(", "channels", ",", "gt_lbls", ",", "prms", "[", "'rotate90'", "]", ")", "\n", "\n", "", "return", "channels", ",", "gt_lbls", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_histogram_distortion": [[23, 50], ["range", "len", "numpy.random.normal", "numpy.random.normal", "numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "random_histogram_distortion", "(", "channels", ",", "prms", ")", ":", "\n", "# Shift and scale the histogram of each channel.", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# prms: { 'shift': {'mu': 0.0, 'std':0.}, 'scale':{'mu': 1.0, 'std': '0.'} }", "\n", "    ", "if", "prms", "is", "None", ":", "\n", "        ", "return", "channels", "\n", "\n", "", "n_channs", "=", "channels", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "if", "prms", "[", "'shift'", "]", "is", "None", ":", "\n", "        ", "shift_per_chan", "=", "0.", "\n", "", "elif", "prms", "[", "'shift'", "]", "[", "'std'", "]", "!=", "0", ":", "# np.random.normal does not work for an std==0.", "\n", "        ", "shift_per_chan", "=", "np", ".", "random", ".", "normal", "(", "prms", "[", "'shift'", "]", "[", "'mu'", "]", ",", "prms", "[", "'shift'", "]", "[", "'std'", "]", ",", "[", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "shift_per_chan", "=", "np", ".", "ones", "(", "[", "n_channs", ",", "1", ",", "1", ",", "1", "]", ",", "dtype", "=", "\"float32\"", ")", "*", "prms", "[", "'shift'", "]", "[", "'mu'", "]", "\n", "\n", "", "if", "prms", "[", "'scale'", "]", "is", "None", ":", "\n", "        ", "scale_per_chan", "=", "1.", "\n", "", "elif", "prms", "[", "'scale'", "]", "[", "'std'", "]", "!=", "0", ":", "\n", "        ", "scale_per_chan", "=", "np", ".", "random", ".", "normal", "(", "prms", "[", "'scale'", "]", "[", "'mu'", "]", ",", "prms", "[", "'scale'", "]", "[", "'std'", "]", ",", "[", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "scale_per_chan", "=", "np", ".", "ones", "(", "[", "n_channs", ",", "1", ",", "1", ",", "1", "]", ",", "dtype", "=", "\"float32\"", ")", "*", "prms", "[", "'scale'", "]", "[", "'mu'", "]", "\n", "\n", "# Intensity augmentation", "\n", "", "for", "path_idx", "in", "range", "(", "len", "(", "channels", ")", ")", ":", "\n", "        ", "channels", "[", "path_idx", "]", "=", "(", "channels", "[", "path_idx", "]", "+", "shift_per_chan", ")", "*", "scale_per_chan", "\n", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_flip": [[52, 68], ["range", "len", "numpy.random.choice", "range", "numpy.flip", "len", "numpy.flip"], "function", ["None"], ["", "def", "random_flip", "(", "channels", ",", "gt_lbls", ",", "probs_flip_axes", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", ":", "\n", "# Flip (reflect) along each axis.", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# gt_lbls: np array of shape [x,y,z]", "\n", "# probs_flip_axes: list of probabilities, one per axis.", "\n", "    ", "if", "probs_flip_axes", "is", "None", ":", "\n", "        ", "return", "channels", ",", "gt_lbls", "\n", "\n", "", "for", "axis_idx", "in", "range", "(", "len", "(", "gt_lbls", ".", "shape", ")", ")", ":", "# 3 dims", "\n", "        ", "flip", "=", "np", ".", "random", ".", "choice", "(", "a", "=", "(", "True", ",", "False", ")", ",", "size", "=", "1", ",", "p", "=", "(", "probs_flip_axes", "[", "axis_idx", "]", ",", "1.", "-", "probs_flip_axes", "[", "axis_idx", "]", ")", ")", "\n", "if", "flip", ":", "\n", "            ", "for", "path_idx", "in", "range", "(", "len", "(", "channels", ")", ")", ":", "\n", "                ", "channels", "[", "path_idx", "]", "=", "np", ".", "flip", "(", "channels", "[", "path_idx", "]", ",", "axis", "=", "axis_idx", "+", "1", ")", "# + 1 because dim [0] is channels.", "\n", "", "gt_lbls", "=", "np", ".", "flip", "(", "gt_lbls", ",", "axis", "=", "axis_idx", ")", "\n", "\n", "", "", "return", "channels", ",", "gt_lbls", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.random_rotation_90": [[70, 103], ["zip", "numpy.random.choice", "range", "numpy.rot90", "len", "len", "numpy.rot90"], "function", ["None"], ["", "def", "random_rotation_90", "(", "channels", ",", "gt_lbls", ",", "probs_rot_90", "=", "None", ")", ":", "\n", "# Rotate by 0/90/180/270 degrees.", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# gt_lbls: np array of shape [x,y,z]", "\n", "# probs_rot_90: {'xy': {'0': fl, '90': fl, '180': fl, '270': fl},", "\n", "#                'yz': {'0': fl, '90': fl, '180': fl, '270': fl},", "\n", "#                'xz': {'0': fl, '90': fl, '180': fl, '270': fl} }", "\n", "    ", "if", "probs_rot_90", "is", "None", ":", "\n", "        ", "return", "channels", ",", "gt_lbls", "\n", "\n", "", "for", "key", ",", "plane_axes", "in", "zip", "(", "[", "'xy'", ",", "'yz'", ",", "'xz'", "]", ",", "[", "(", "0", ",", "1", ")", ",", "(", "1", ",", "2", ")", ",", "(", "0", ",", "2", ")", "]", ")", ":", "\n", "        ", "probs_plane", "=", "probs_rot_90", "[", "key", "]", "\n", "\n", "if", "probs_plane", "is", "None", ":", "\n", "            ", "continue", "\n", "\n", "", "assert", "len", "(", "probs_plane", ")", "==", "4", "# rotation 0, rotation 90 degrees, 180, 270.", "\n", "assert", "channels", "[", "0", "]", ".", "shape", "[", "1", "+", "plane_axes", "[", "0", "]", "]", "==", "channels", "[", "0", "]", ".", "shape", "[", "1", "+", "plane_axes", "[", "1", "]", "]", "# +1 cause [0] is channel. Image/patch must be isotropic.", "\n", "\n", "# Normalize probs", "\n", "sum_p", "=", "probs_plane", "[", "'0'", "]", "+", "probs_plane", "[", "'90'", "]", "+", "probs_plane", "[", "'180'", "]", "+", "probs_plane", "[", "'270'", "]", "\n", "if", "sum_p", "==", "0", ":", "\n", "            ", "continue", "\n", "", "for", "rot_k", "in", "probs_plane", ":", "\n", "            ", "probs_plane", "[", "rot_k", "]", "/=", "sum_p", "# normalize p to 1.", "\n", "\n", "", "p_rot_90_x0123", "=", "(", "probs_plane", "[", "'0'", "]", ",", "probs_plane", "[", "'90'", "]", ",", "probs_plane", "[", "'180'", "]", ",", "probs_plane", "[", "'270'", "]", ")", "\n", "rot_90_xtimes", "=", "np", ".", "random", ".", "choice", "(", "a", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ",", "size", "=", "1", ",", "p", "=", "p_rot_90_x0123", ")", "\n", "for", "path_idx", "in", "range", "(", "len", "(", "channels", ")", ")", ":", "\n", "            ", "channels", "[", "path_idx", "]", "=", "np", ".", "rot90", "(", "channels", "[", "path_idx", "]", ",", "k", "=", "rot_90_xtimes", ",", "axes", "=", "[", "axis", "+", "1", "for", "axis", "in", "plane_axes", "]", ")", "# + 1 cause [0] is channels.", "\n", "", "gt_lbls", "=", "np", ".", "rot90", "(", "gt_lbls", ",", "k", "=", "rot_90_xtimes", ",", "axes", "=", "plane_axes", ")", "\n", "\n", "", "return", "channels", ",", "gt_lbls", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.load_volume": [[15, 34], ["nibabel.load", "nib.load.get_data", "nib.load.uncache", "len", "numpy.expand_dims", "len"], "function", ["None"], ["def", "load_volume", "(", "filepath", ")", ":", "\n", "# Loads the image specified by filepath.", "\n", "# Returns a 3D np array.", "\n", "# The image can be 2D, but will be returned as 3D, with dimensions =[x, y, 1]", "\n", "# It can also be 4D, of shape [x,y,z,1], and will be returned as 3D.", "\n", "# If it's 4D with 4th dimension > 1, assertion will be raised.", "\n", "    ", "proxy", "=", "nib", ".", "load", "(", "filepath", ")", "\n", "img", "=", "proxy", ".", "get_data", "(", ")", "\n", "proxy", ".", "uncache", "(", ")", "\n", "\n", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "# 2D image could have been given.", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "", "elif", "len", "(", "img", ".", "shape", ")", ">", "3", ":", "\n", "# 4D volumes could have been given. Often 3Ds are stored as 4Ds with 4th dim == 1.", "\n", "        ", "assert", "img", ".", "shape", "[", "3", "]", "==", "1", "\n", "img", "=", "img", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveImgToNiiWithOriginalHdr": [[37, 72], ["numpy.dtype", "nibabel.load", "nib.load.uncache", "nibabel.Nifti1Image", "nib.Nifti1Image.set_data_dtype", "len", "list", "nib.Nifti1Image.header.set_zooms", "os.path.abspath", "nibabel.save", "len", "os.path.abspath.endswith", "os.path.exists", "os.makedirs", "log.print3", "print", "hdr_origin.get_zooms", "os.path.dirname", "os.path.dirname", "str", "str", "len"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "saveImgToNiiWithOriginalHdr", "(", "imgToSave", ",", "\n", "filepathTarget", ",", "\n", "filepathOriginToCopyHeader", ",", "\n", "npDtype", "=", "np", ".", "dtype", "(", "np", ".", "float32", ")", ",", "\n", "log", "=", "None", ")", ":", "\n", "# imgToSave: 3d np array.", "\n", "# filepathTarget: filepath where to save.", "\n", "# filepathOriginToCopyHeader: original image, where to copy the header over to the target image.", "\n", "\n", "# Load original image.", "\n", "    ", "proxy_origin", "=", "nib", ".", "load", "(", "filepathOriginToCopyHeader", ")", "\n", "hdr_origin", "=", "proxy_origin", ".", "header", "\n", "affine_origin", "=", "proxy_origin", ".", "affine", "\n", "proxy_origin", ".", "uncache", "(", ")", "\n", "\n", "newLabelImg", "=", "nib", ".", "Nifti1Image", "(", "imgToSave", ",", "affine_origin", ")", "\n", "newLabelImg", ".", "set_data_dtype", "(", "npDtype", ")", "\n", "\n", "dimsImgToSave", "=", "len", "(", "imgToSave", ".", "shape", ")", "\n", "newZooms", "=", "list", "(", "hdr_origin", ".", "get_zooms", "(", ")", "[", ":", "dimsImgToSave", "]", ")", "\n", "if", "len", "(", "newZooms", ")", "<", "dimsImgToSave", ":", "#Eg if original image was 3D, but I need to save a multi-channel image.", "\n", "        ", "newZooms", "=", "newZooms", "+", "[", "1.0", "]", "*", "(", "dimsImgToSave", "-", "len", "(", "newZooms", ")", ")", "\n", "", "newLabelImg", ".", "header", ".", "set_zooms", "(", "newZooms", ")", "\n", "\n", "filepathTarget", "=", "os", ".", "path", ".", "abspath", "(", "filepathTarget", ")", "\n", "if", "not", "filepathTarget", ".", "endswith", "(", "\".nii.gz\"", ")", ":", "\n", "        ", "filepathTarget", "=", "filepathTarget", "+", "\".nii.gz\"", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "dirname", "(", "filepathTarget", ")", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filepathTarget", ")", ")", "\n", "", "nib", ".", "save", "(", "newLabelImg", ",", "filepathTarget", ")", "\n", "\n", "if", "log", "!=", "None", ":", "\n", "        ", "log", ".", "print3", "(", "\"Image saved at: \"", "+", "str", "(", "filepathTarget", ")", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Image saved at: \"", "+", "str", "(", "filepathTarget", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.savePredImgToNiiWithOriginalHdr": [[75, 108], ["numpy.dtype", "os.path.isdir", "io.saveImgToNiiWithOriginalHdr", "log.print3", "print", "nameForSavingPred.endswith", "nameForSavingPred.endswith", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveImgToNiiWithOriginalHdr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "savePredImgToNiiWithOriginalHdr", "(", "labelImageCreatedByPredictions", ",", "\n", "namesForSavingPreds", ",", "\n", "listOfFilepathsToEachChannelOfEachPatient", ",", "\n", "case_i", ",", "\n", "suffixToAdd", "=", "\"\"", ",", "\n", "npDtype", "=", "np", ".", "dtype", "(", "np", ".", "float32", ")", ",", "\n", "log", "=", "None", ")", ":", "\n", "# case_i: # the index (in the list of filepathnames) of the current image segmented.", "\n", "# Needs as argument the cases' filepaths and index of the currently segmented case, so that ...", "\n", "# ... I can get the header, affine RAS trans etc from it and copy it for the new image.", "\n", "    ", "if", "log", "is", "not", "None", ":", "\n", "        ", "log", ".", "print3", "(", "\"Saving the new label (segmentation) image for the subject #\"", "+", "str", "(", "case_i", ")", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Saving the new label (segmentation) image for the subject #\"", "+", "str", "(", "case_i", ")", ")", "\n", "\n", "", "filepathOriginToCopyHeader", "=", "listOfFilepathsToEachChannelOfEachPatient", "[", "case_i", "]", "[", "0", "]", "\n", "\n", "filepathTarget", "=", "\"PLACEHOLDER\"", "\n", "nameForSavingPred", "=", "namesForSavingPreds", "[", "case_i", "]", "\n", "if", "os", ".", "path", ".", "isdir", "(", "nameForSavingPred", ")", ":", "# Only if names not given and it's only 1 case (see testSessionParams)", "\n", "        ", "filepathTarget", "=", "nameForSavingPred", "+", "\"/\"", "+", "suffixToAdd", "+", "\".nii.gz\"", "\n", "", "elif", "nameForSavingPred", ".", "endswith", "(", "\".nii.gz\"", ")", ":", "\n", "        ", "filepathTarget", "=", "nameForSavingPred", "[", ":", "-", "7", "]", "+", "\"_\"", "+", "suffixToAdd", "+", "\".nii.gz\"", "\n", "", "elif", "nameForSavingPred", ".", "endswith", "(", "\".nii\"", ")", ":", "\n", "        ", "filepathTarget", "=", "nameForSavingPred", "[", ":", "-", "4", "]", "+", "\"_\"", "+", "suffixToAdd", "+", "\".nii.gz\"", "\n", "", "else", ":", "\n", "        ", "filepathTarget", "=", "nameForSavingPred", "+", "\"_\"", "+", "suffixToAdd", "+", "\".nii.gz\"", "\n", "\n", "", "saveImgToNiiWithOriginalHdr", "(", "labelImageCreatedByPredictions", ",", "\n", "filepathTarget", ",", "\n", "filepathOriginToCopyHeader", ",", "\n", "npDtype", ",", "\n", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveFmImgToNiiWithOriginalHdr": [[111, 147], ["namesForSavingPreds[].endswith", "io.saveImgToNiiWithOriginalHdr", "str", "log.print3", "print", "namesForSavingPreds[].endswith", "numpy.dtype", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveImgToNiiWithOriginalHdr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "saveFmImgToNiiWithOriginalHdr", "(", "fmImageCreatedByVisualisation", ",", "\n", "namesForSavingPreds", ",", "\n", "listOfFilepathsToEachChannelOfEachPatient", ",", "\n", "image_i", ",", "\n", "index_of_typeOfPathway_to_visualize", ",", "\n", "index_of_layer_in_pathway_to_visualize", ",", "\n", "index_of_FM_in_pathway_to_visualize", ",", "\n", "log", "=", "None", ")", ":", "\n", "# case_i: # the index (in the list of filepathnames) of the current image segmented.", "\n", "# Needs as argument the cases' filepaths and index of the currently segmented case, so that ...", "\n", "# ... I can get the header, affine RAS trans etc from it and copy it for the new image.", "\n", "\n", "    ", "stringToPrint", "=", "\"Saving the new FM-activation image for the subject #\"", "+", "str", "(", "image_i", ")", "+", "\", pathway:\"", "+", "str", "(", "index_of_typeOfPathway_to_visualize", ")", "+", "\", layer: \"", "+", "str", "(", "index_of_layer_in_pathway_to_visualize", ")", "+", "\" FM: \"", "+", "str", "(", "index_of_FM_in_pathway_to_visualize", ")", "\n", "if", "log", "!=", "None", ":", "\n", "        ", "log", ".", "print3", "(", "stringToPrint", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "stringToPrint", ")", "\n", "\n", "", "filepathOriginToCopyHeader", "=", "listOfFilepathsToEachChannelOfEachPatient", "[", "image_i", "]", "[", "0", "]", "\n", "filepathTarget", "=", "\"PLACEHOLDER\"", "\n", "if", "namesForSavingPreds", "[", "image_i", "]", ".", "endswith", "(", "\".nii.gz\"", ")", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingPreds", "[", "image_i", "]", "[", ":", "-", "7", "]", "+", "\"_pathway\"", "+", "str", "(", "index_of_typeOfPathway_to_visualize", ")", "+", "\"_layer\"", "+", "str", "(", "index_of_layer_in_pathway_to_visualize", ")", "+", "\"_fm\"", "+", "str", "(", "index_of_FM_in_pathway_to_visualize", ")", "+", "\".nii.gz\"", "\n", "", "elif", "namesForSavingPreds", "[", "image_i", "]", ".", "endswith", "(", "\".nii\"", ")", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingPreds", "[", "image_i", "]", "[", ":", "-", "4", "]", "+", "\"_pathway\"", "+", "str", "(", "index_of_typeOfPathway_to_visualize", ")", "+", "\"_layer\"", "+", "str", "(", "index_of_layer_in_pathway_to_visualize", ")", "+", "\"_fm\"", "+", "str", "(", "index_of_FM_in_pathway_to_visualize", ")", "+", "\".nii.gz\"", "\n", "", "else", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingPreds", "[", "image_i", "]", "+", "\"_pathway\"", "+", "str", "(", "index_of_typeOfPathway_to_visualize", ")", "+", "\"_layer\"", "+", "str", "(", "index_of_layer_in_pathway_to_visualize", ")", "+", "\"_fm\"", "+", "str", "(", "index_of_FM_in_pathway_to_visualize", ")", "+", "\".nii.gz\"", "\n", "\n", "", "saveImgToNiiWithOriginalHdr", "(", "fmImageCreatedByVisualisation", ",", "\n", "filepathTarget", ",", "\n", "filepathOriginToCopyHeader", ",", "\n", "np", ".", "dtype", "(", "np", ".", "float32", ")", ",", "\n", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.save4DImgWithAllFmsToNiiWithOriginalHdr": [[150, 176], ["namesForSavingFms[].endswith", "io.saveImgToNiiWithOriginalHdr", "str", "log.print3", "print", "namesForSavingFms[].endswith", "numpy.dtype"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.saveImgToNiiWithOriginalHdr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "save4DImgWithAllFmsToNiiWithOriginalHdr", "(", "multidimImageWithAllVisualisedFms", ",", "\n", "namesForSavingFms", ",", "\n", "listOfFilepathsToEachChannelOfEachPatient", ",", "\n", "image_i", ",", "\n", "log", "=", "None", ")", ":", "\n", "    ", "stringToPrint", "=", "\"Saving multi-dimensional image, with all FMs as 4th dimension, \"", "+", "\"for subject #\"", "+", "str", "(", "image_i", ")", "\n", "if", "log", "!=", "None", ":", "\n", "        ", "log", ".", "print3", "(", "stringToPrint", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "stringToPrint", ")", "\n", "\n", "", "filepathOriginToCopyHeader", "=", "listOfFilepathsToEachChannelOfEachPatient", "[", "image_i", "]", "[", "0", "]", "\n", "filepathTarget", "=", "\"PLACEHOLDER\"", "\n", "if", "namesForSavingFms", "[", "image_i", "]", ".", "endswith", "(", "\".nii.gz\"", ")", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingFms", "[", "image_i", "]", "[", ":", "-", "7", "]", "+", "\"_allFmsMultiDim.nii.gz\"", "\n", "", "elif", "namesForSavingFms", "[", "image_i", "]", ".", "endswith", "(", "\".nii\"", ")", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingFms", "[", "image_i", "]", "[", ":", "-", "4", "]", "+", "\"_allFmsMultiDim.nii.gz\"", "\n", "", "else", ":", "\n", "        ", "filepathTarget", "=", "namesForSavingFms", "[", "image_i", "]", "+", "\"_allFmsMultiDim.nii.gz\"", "\n", "\n", "", "saveImgToNiiWithOriginalHdr", "(", "multidimImageWithAllVisualisedFms", ",", "\n", "filepathTarget", ",", "\n", "filepathOriginToCopyHeader", ",", "\n", "np", ".", "dtype", "(", "np", ".", "float32", ")", ",", "\n", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams.__init__": [[65, 69], ["collections.OrderedDict", "augmentImage.AugmenterParams._set_from_dict"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams._set_from_dict"], ["    ", "def", "__init__", "(", "self", ",", "prms", ")", ":", "\n", "# prms: dictionary", "\n", "        ", "self", ".", "_prms", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "self", ".", "_set_from_dict", "(", "prms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams.__str__": [[70, 72], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "_prms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams.__getitem__": [[73, 76], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "# overriding the [] operator.", "\n", "# key: string.", "\n", "        ", "return", "self", ".", "_prms", "[", "key", "]", "if", "key", "in", "self", ".", "_prms", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams.__setitem__": [[77, 79], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "key", ",", "item", ")", ":", "# For instance[key] = item assignment", "\n", "        ", "self", ".", "_prms", "[", "key", "]", "=", "item", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams._set_from_dict": [[80, 84], ["prms.keys"], "methods", ["None"], ["", "def", "_set_from_dict", "(", "self", ",", "prms", ")", ":", "\n", "        ", "if", "prms", "is", "not", "None", ":", "\n", "            ", "for", "key", "in", "prms", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "_prms", "[", "key", "]", "=", "prms", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffineParams.__init__": [[87, 102], ["collections.OrderedDict", "augmentImage.AugmenterAffineParams._set_from_dict"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterParams._set_from_dict"], ["    ", "def", "__init__", "(", "self", ",", "prms", ")", ":", "\n", "# Default values.", "\n", "        ", "self", ".", "_prms", "=", "collections", ".", "OrderedDict", "(", "[", "(", "'prob'", ",", "0.0", ")", ",", "\n", "(", "'max_rot_xyz'", ",", "(", "45.", ",", "45.", ",", "45.", ")", ")", ",", "\n", "(", "'max_scaling'", ",", ".1", ")", ",", "\n", "(", "'seed'", ",", "None", ")", ",", "\n", "# For calls.", "\n", "(", "'interp_order_imgs'", ",", "1", ")", ",", "\n", "(", "'interp_order_lbls'", ",", "0", ")", ",", "\n", "(", "'interp_order_roi'", ",", "0", ")", ",", "\n", "(", "'interp_order_wmaps'", ",", "1", ")", ",", "\n", "(", "'boundary_mode'", ",", "'nearest'", ")", ",", "\n", "(", "'cval'", ",", "0.", ")", "]", ")", "\n", "# Overwrite defaults with given.", "\n", "self", ".", "_set_from_dict", "(", "prms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffineParams.__str__": [[103, 105], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "_prms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine.__init__": [[108, 113], ["numpy.random.RandomState"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "prob", ",", "max_rot_xyz", ",", "max_scaling", ",", "seed", "=", "None", ")", ":", "\n", "        ", "self", ".", "prob", "=", "prob", "# Probability of applying the transformation.", "\n", "self", ".", "max_rot_xyz", "=", "max_rot_xyz", "\n", "self", ".", "max_scaling", "=", "max_scaling", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine.roll_dice_and_get_random_transformation": [[114, 119], ["augmentImage.AugmenterAffine.rng.random_sample", "augmentImage.AugmenterAffine._get_random_transformation"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine._get_random_transformation"], ["", "def", "roll_dice_and_get_random_transformation", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "rng", ".", "random_sample", "(", ")", ">", "self", ".", "prob", ":", "\n", "            ", "return", "-", "1", "# No augmentation", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_get_random_transformation", "(", ")", "#transformation for augmentation", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine._get_random_transformation": [[120, 144], ["numpy.array", "numpy.array", "numpy.array", "numpy.dot", "numpy.eye", "augmentImage.AugmenterAffine.rng.uniform", "numpy.dot", "augmentImage.AugmenterAffine.rng.uniform", "augmentImage.AugmenterAffine.rng.uniform", "augmentImage.AugmenterAffine.rng.uniform", "numpy.dot", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.sin", "numpy.sin"], "methods", ["None"], ["", "", "def", "_get_random_transformation", "(", "self", ")", ":", "\n", "        ", "theta_x", "=", "self", ".", "rng", ".", "uniform", "(", "-", "self", ".", "max_rot_xyz", "[", "0", "]", ",", "self", ".", "max_rot_xyz", "[", "0", "]", ")", "*", "np", ".", "pi", "/", "180.", "\n", "rot_x", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta_x", ")", ",", "-", "np", ".", "sin", "(", "theta_x", ")", ",", "0.", "]", ",", "\n", "[", "np", ".", "sin", "(", "theta_x", ")", ",", "np", ".", "cos", "(", "theta_x", ")", ",", "0.", "]", ",", "\n", "[", "0.", ",", "0.", ",", "1.", "]", "]", ")", "\n", "\n", "theta_y", "=", "self", ".", "rng", ".", "uniform", "(", "-", "self", ".", "max_rot_xyz", "[", "1", "]", ",", "self", ".", "max_rot_xyz", "[", "1", "]", ")", "*", "np", ".", "pi", "/", "180.", "\n", "rot_y", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta_y", ")", ",", "0.", ",", "np", ".", "sin", "(", "theta_y", ")", "]", ",", "\n", "[", "0.", ",", "1.", ",", "0.", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "theta_y", ")", ",", "0.", ",", "np", ".", "cos", "(", "theta_y", ")", "]", "]", ")", "\n", "\n", "theta_z", "=", "self", ".", "rng", ".", "uniform", "(", "-", "self", ".", "max_rot_xyz", "[", "2", "]", ",", "self", ".", "max_rot_xyz", "[", "2", "]", ")", "*", "np", ".", "pi", "/", "180.", "\n", "rot_z", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", ",", "0.", "]", ",", "\n", "[", "0.", ",", "np", ".", "cos", "(", "theta_z", ")", ",", "-", "np", ".", "sin", "(", "theta_z", ")", "]", ",", "\n", "[", "0.", ",", "np", ".", "sin", "(", "theta_z", ")", ",", "np", ".", "cos", "(", "theta_z", ")", "]", "]", ")", "\n", "\n", "# Sample the scale (zoom in/out)", "\n", "# TODO: Non isotropic?", "\n", "scale", "=", "np", ".", "eye", "(", "3", ",", "3", ")", "*", "self", ".", "rng", ".", "uniform", "(", "1", "-", "self", ".", "max_scaling", ",", "1", "+", "self", ".", "max_scaling", ")", "\n", "\n", "# Affine transformation matrix.", "\n", "transformation_mtx", "=", "np", ".", "dot", "(", "scale", ",", "np", ".", "dot", "(", "rot_z", ",", "np", ".", "dot", "(", "rot_x", ",", "rot_y", ")", ")", ")", "\n", "\n", "return", "transformation_mtx", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine._apply_transformation": [[145, 168], ["numpy.floor", "scipy.ndimage.affine_transform", "numpy.min", "numpy.floor.dot", "numpy.asarray"], "methods", ["None"], ["", "def", "_apply_transformation", "(", "self", ",", "image", ",", "transf_mtx", ",", "interp_order", "=", "2.", ",", "boundary_mode", "=", "'nearest'", ",", "cval", "=", "0.", ")", ":", "\n", "# image should be 3 dimensional (Height, Width, Depth). Not multi-channel.", "\n", "# interp_order: Integer. 1,2,3 for images, 0 for nearest neighbour on masks (GT & brainmasks)", "\n", "# boundary_mode = 'constant', 'min', 'nearest', 'mirror...", "\n", "# cval: float. value given to boundaries if mode is constant.", "\n", "        ", "assert", "interp_order", "in", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "\n", "mode", "=", "boundary_mode", "\n", "if", "mode", "==", "'min'", ":", "\n", "            ", "cval", "=", "np", ".", "min", "(", "image", ")", "\n", "mode", "=", "'constant'", "\n", "\n", "# For recentering", "\n", "", "centre_coords", "=", "np", ".", "floor", "(", "0.5", "*", "np", ".", "asarray", "(", "image", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "c_offset", "=", "centre_coords", "-", "centre_coords", ".", "dot", "(", "transf_mtx", ")", "\n", "\n", "new_image", "=", "scipy", ".", "ndimage", ".", "affine_transform", "(", "image", ",", "\n", "transf_mtx", ".", "T", ",", "\n", "c_offset", ",", "\n", "order", "=", "interp_order", ",", "\n", "mode", "=", "mode", ",", "\n", "cval", "=", "cval", ")", "\n", "return", "new_image", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine.__call__": [[169, 203], ["isinstance", "isinstance", "zip", "augmentImage.AugmenterAffine.roll_dice_and_get_random_transformation", "range", "isinstance", "len", "len", "len", "augmentImage.AugmenterAffine._apply_transformation"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine.roll_dice_and_get_random_transformation", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine._apply_transformation"], ["", "def", "__call__", "(", "self", ",", "images_l", ",", "transf_mtx", ",", "interp_orders", ",", "boundary_modes", ",", "cval", "=", "0.", ")", ":", "\n", "# images_l : List of images, or an array where first dimension is over images (eg channels).", "\n", "#            An image (element of the var) can be None, and it will be returned unchanged.", "\n", "#            If images_l is None, then returns None.", "\n", "# transf_mtx: Given (from get_random_transformation), -1, or None.", "\n", "#             If -1, no augmentation/transformation will be done.", "\n", "#             If None, new random will be made.", "\n", "# intrp_orders : Int or List of integers. Orders of bsplines for interpolation, one per image in images_l.", "\n", "#                Suggested: 3 for images. 1 is like linear. 0 for masks/labels, like NN.", "\n", "# boundary_mode = String or list of strings. 'constant', 'min', 'nearest', 'mirror...", "\n", "# cval: single float value. Value given to boundaries if mode is 'constant'.", "\n", "        ", "if", "images_l", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "transf_mtx", "is", "None", ":", "# Get random transformation.", "\n", "            ", "transf_mtx", "=", "self", ".", "roll_dice_and_get_random_transformation", "(", ")", "\n", "", "if", "not", "isinstance", "(", "transf_mtx", ",", "np", ".", "ndarray", ")", "and", "transf_mtx", "==", "-", "1", ":", "# Do not augment", "\n", "            ", "return", "images_l", "\n", "# If scalars/string was given, change it to list of scalars/strings, per image.", "\n", "", "if", "isinstance", "(", "interp_orders", ",", "int", ")", ":", "\n", "            ", "interp_orders", "=", "[", "interp_orders", "]", "*", "len", "(", "images_l", ")", "\n", "", "if", "isinstance", "(", "boundary_modes", ",", "str", ")", ":", "\n", "            ", "boundary_modes", "=", "[", "boundary_modes", "]", "*", "len", "(", "images_l", ")", "\n", "\n", "# Deform images.", "\n", "", "for", "img_i", ",", "int_order", ",", "b_mode", "in", "zip", "(", "range", "(", "len", "(", "images_l", ")", ")", ",", "interp_orders", ",", "boundary_modes", ")", ":", "\n", "            ", "if", "images_l", "[", "img_i", "]", "is", "None", ":", "\n", "                ", "pass", "# Dont do anything. Let it be None.", "\n", "", "else", ":", "\n", "                ", "images_l", "[", "img_i", "]", "=", "self", ".", "_apply_transformation", "(", "images_l", "[", "img_i", "]", ",", "\n", "transf_mtx", ",", "\n", "int_order", ",", "\n", "b_mode", ",", "\n", "cval", ")", "\n", "", "", "return", "images_l", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.augment_imgs_of_case": [[16, 32], ["augmentImage.random_affine_deformation"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.random_affine_deformation"], ["def", "augment_imgs_of_case", "(", "channels", ",", "gt_lbls", ",", "roi_mask", ",", "wmaps_per_cat", ",", "prms", ")", ":", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# gt_lbls: np array of shape [x,y,z]. Can be None.", "\n", "# roi_mask: np array of shape [x,y,z]. Can be None.", "\n", "# wmaps_per_cat: List of np.arrays (floats or ints), weightmaps for sampling. Can be None.", "\n", "# prms: None (for no augmentation) or Dictionary with parameters of each augmentation type. }", "\n", "    ", "if", "prms", "is", "not", "None", ":", "\n", "        ", "(", "channels", ",", "\n", "gt_lbls", ",", "\n", "roi_mask", ",", "\n", "wmaps_per_cat", ")", "=", "random_affine_deformation", "(", "channels", ",", "\n", "gt_lbls", ",", "\n", "roi_mask", ",", "\n", "wmaps_per_cat", ",", "\n", "prms", "[", "'affine'", "]", ")", "\n", "", "return", "channels", ",", "gt_lbls", ",", "roi_mask", ",", "wmaps_per_cat", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.random_affine_deformation": [[34, 60], ["augmentImage.AugmenterAffine", "augmentImage.AugmenterAffine.roll_dice_and_get_random_transformation", "AugmenterAffine.", "AugmenterAffine.", "AugmenterAffine."], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.AugmenterAffine.roll_dice_and_get_random_transformation"], ["", "def", "random_affine_deformation", "(", "channels", ",", "gt_lbls", ",", "roi_mask", ",", "wmaps_l", ",", "prms", ")", ":", "\n", "    ", "if", "prms", "is", "None", ":", "\n", "        ", "return", "channels", ",", "gt_lbls", ",", "roi_mask", ",", "wmaps_l", "\n", "\n", "", "augm", "=", "AugmenterAffine", "(", "prob", "=", "prms", "[", "'prob'", "]", ",", "\n", "max_rot_xyz", "=", "prms", "[", "'max_rot_xyz'", "]", ",", "\n", "max_scaling", "=", "prms", "[", "'max_scaling'", "]", ",", "\n", "seed", "=", "prms", "[", "'seed'", "]", ")", "\n", "transf_mtx", "=", "augm", ".", "roll_dice_and_get_random_transformation", "(", ")", "\n", "assert", "transf_mtx", "is", "not", "None", "\n", "\n", "channels", "=", "augm", "(", "images_l", "=", "channels", ",", "\n", "transf_mtx", "=", "transf_mtx", ",", "\n", "interp_orders", "=", "prms", "[", "'interp_order_imgs'", "]", ",", "\n", "boundary_modes", "=", "prms", "[", "'boundary_mode'", "]", ")", "\n", "(", "gt_lbls", ",", "\n", "roi_mask", ")", "=", "augm", "(", "images_l", "=", "[", "gt_lbls", ",", "roi_mask", "]", ",", "\n", "transf_mtx", "=", "transf_mtx", ",", "\n", "interp_orders", "=", "[", "prms", "[", "'interp_order_lbls'", "]", ",", "prms", "[", "'interp_order_roi'", "]", "]", ",", "\n", "boundary_modes", "=", "prms", "[", "'boundary_mode'", "]", ")", "\n", "wmaps_l", "=", "augm", "(", "images_l", "=", "wmaps_l", ",", "\n", "transf_mtx", "=", "transf_mtx", ",", "\n", "interp_orders", "=", "prms", "[", "'interp_order_wmaps'", "]", ",", "\n", "boundary_modes", "=", "prms", "[", "'boundary_mode'", "]", ")", "\n", "\n", "return", "channels", ",", "gt_lbls", ",", "roi_mask", ",", "wmaps_l", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.random_gamma_correction": [[209, 223], ["numpy.random.normal", "range", "len", "numpy.power", "numpy.min"], "function", ["None"], ["", "", "def", "random_gamma_correction", "(", "channels", ",", "gamma_std", "=", "0.05", ")", ":", "\n", "# Gamma correction: I' = I^gamma", "\n", "# channels: list (x pathways) of np arrays [channels, x, y, z]. Whole volumes, channels of a case.", "\n", "# IMPORTANT: Does not work if intensities go to negatives.", "\n", "    ", "if", "gamma_std", "is", "None", "or", "gamma_std", "==", "0.", ":", "\n", "        ", "return", "channels", "\n", "\n", "", "n_channs", "=", "channels", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "gamma", "=", "np", ".", "random", ".", "normal", "(", "1", ",", "gamma_std", ",", "[", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "for", "path_idx", "in", "range", "(", "len", "(", "channels", ")", ")", ":", "\n", "        ", "assert", "np", ".", "min", "(", "channels", "[", "path_idx", "]", ")", ">=", "0.", "\n", "channels", "[", "path_idx", "]", "=", "np", ".", "power", "(", "channels", "[", "path_idx", "]", ",", "1.5", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.__init__": [[12, 33], ["ValueError", "str", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "log", ",", "sampling_type", ",", "n_classes_incl_bgr", ")", ":", "\n", "        ", "self", ".", "_log", "=", "log", "\n", "# foreBackgr=0 , uniform=1, fullImage=2, targettedPerClass=3", "\n", "self", ".", "_sampling_type", "=", "sampling_type", "\n", "self", ".", "_perc_to_sample_per_cat", "=", "None", "\n", "\n", "assert", "self", ".", "_sampling_type", "in", "[", "0", ",", "1", ",", "2", ",", "3", "]", "\n", "if", "self", ".", "_sampling_type", "==", "0", ":", "\n", "            ", "self", ".", "_sampling_type_str", "=", "\"Fore/Background\"", "\n", "self", ".", "_array_w_str_per_sampling_category", "=", "[", "\"Foreground\"", ",", "\"Background\"", "]", "\n", "", "elif", "self", ".", "_sampling_type", "==", "1", ":", "\n", "            ", "self", ".", "_sampling_type_str", "=", "\"Uniform\"", "\n", "self", ".", "_array_w_str_per_sampling_category", "=", "[", "\"Uniform\"", "]", "\n", "", "elif", "self", ".", "_sampling_type", "==", "2", ":", "\n", "            ", "self", ".", "_sampling_type_str", "=", "\"Whole-Image\"", "\n", "self", ".", "_array_w_str_per_sampling_category", "=", "[", "\"WholeImage\"", "]", "\n", "", "elif", "self", ".", "_sampling_type", "==", "3", ":", "\n", "            ", "self", ".", "_sampling_type_str", "=", "\"Per-Class\"", "\n", "self", ".", "_array_w_str_per_sampling_category", "=", "[", "\"Class-\"", "+", "str", "(", "i", ")", "for", "i", "in", "range", "(", "n_classes_incl_bgr", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid value for sampling type.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.set_perc_of_samples_per_cat": [[35, 52], ["samplingType.SamplingType._log.print3", "exit", "samplingType.SamplingType._normalize_percentages", "len", "samplingType.SamplingType.get_n_sampling_cats", "str", "samplingType.SamplingType._normalize_percentages", "ValueError", "samplingType.SamplingType.get_n_sampling_cats", "str", "len"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType._normalize_percentages", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType._normalize_percentages", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats"], ["", "", "def", "set_perc_of_samples_per_cat", "(", "self", ",", "perc_of_samples_per_cat", ")", ":", "\n", "# For each category to sample, set the percent of the samples that should be taken from this category.", "\n", "# Categories to sample are different for each sampling-type.", "\n", "        ", "if", "self", ".", "_sampling_type", "in", "[", "0", ",", "3", "]", "and", "len", "(", "perc_of_samples_per_cat", ")", "!=", "self", ".", "get_n_sampling_cats", "(", ")", ":", "\n", "            ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: The list perc_of_samples_per_cat had [\"", "+", "str", "(", "len", "(", "perc_of_samples_per_cat", ")", ")", "+", "\"] elements.\"", "+", "\" For type [\"", "+", "self", ".", "_sampling_type_str", "+", "\"], it requires [\"", "+", "str", "(", "self", ".", "get_n_sampling_cats", "(", ")", ")", "+", "\"]! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "\n", "", "if", "self", ".", "_sampling_type", "==", "0", ":", "\n", "            ", "self", ".", "_perc_to_sample_per_cat", "=", "self", ".", "_normalize_percentages", "(", "perc_of_samples_per_cat", ")", "\n", "", "elif", "self", ".", "_sampling_type", "==", "1", ":", "\n", "            ", "self", ".", "_perc_to_sample_per_cat", "=", "[", "1.0", "]", "\n", "", "elif", "self", ".", "_sampling_type", "==", "2", ":", "\n", "            ", "self", ".", "_perc_to_sample_per_cat", "=", "[", "1.0", "]", "\n", "", "elif", "self", ".", "_sampling_type", "==", "3", ":", "\n", "            ", "self", ".", "_perc_to_sample_per_cat", "=", "self", ".", "_normalize_percentages", "(", "perc_of_samples_per_cat", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid value for sampling type.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType._normalize_percentages": [[53, 56], ["numpy.asarray", "numpy.sum"], "methods", ["None"], ["", "", "def", "_normalize_percentages", "(", "self", ",", "list_of_weights", ")", ":", "\n", "        ", "array_of_weights", "=", "np", ".", "asarray", "(", "list_of_weights", ",", "dtype", "=", "\"float32\"", ")", "\n", "return", "array_of_weights", "/", "(", "1.0", "*", "np", ".", "sum", "(", "array_of_weights", ")", ")", "\n", "# API", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_int": [[57, 59], ["None"], "methods", ["None"], ["", "def", "get_type_as_int", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_sampling_type", "\n", "", "def", "get_type_as_str", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_type_as_str": [[59, 61], ["None"], "methods", ["None"], ["", "def", "get_type_as_str", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_sampling_type_str", "\n", "", "def", "get_sampling_cats_as_str", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_sampling_cats_as_str": [[61, 63], ["None"], "methods", ["None"], ["", "def", "get_sampling_cats_as_str", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_array_w_str_per_sampling_category", "\n", "", "def", "get_perc_to_sample_per_cat", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_perc_to_sample_per_cat": [[63, 65], ["None"], "methods", ["None"], ["", "def", "get_perc_to_sample_per_cat", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_perc_to_sample_per_cat", "\n", "", "def", "get_n_sampling_cats", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats": [[65, 67], ["len"], "methods", ["None"], ["", "def", "get_n_sampling_cats", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_array_w_str_per_sampling_category", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.derive_sampling_maps_per_cat": [[69, 137], ["len", "samplingType.SamplingType.get_n_sampling_cats", "samplingType.SamplingType._log.print3", "exit", "samplingType.SamplingType._log.print3", "exit", "samplingType.SamplingType._log.print3", "exit", "ValueError", "numpy.ones", "numpy.ones", "samplingType.SamplingType._log.print3", "exit", "numpy.ones", "samplingType.SamplingType.get_n_sampling_cats", "samplingType.SamplingType._log.print3", "exit", "samplingType.SamplingType._log.print3", "exit", "str", "range", "range", "str", "samplingType.SamplingType.get_n_sampling_cats", "sampling_maps_per_cat.append", "samplingType.SamplingType.get_n_sampling_cats", "sampling_maps_per_cat.append", "str", "str", "samplingType.SamplingType.get_n_sampling_cats", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats"], ["", "def", "derive_sampling_maps_per_cat", "(", "self", ",", "wmaps_to_sample_per_cat", ",", "gt_lbl_img", ",", "roi_mask", ",", "dims_of_scan", ")", ":", "\n", "# wmaps_to_sample_per_cat: If weight-maps are provided (not None), they should be provided for *every* class of the sampling-type.", "\n", "# a) Check if weighted maps are given. In that case, use them.", "\n", "# b) If no weightMaps, and ROI/GT given, use them.", "\n", "# c) Otherwise, whole image.", "\n", "# Depending on the sampling_type, different behaviour as in how many categories.", "\n", "# dims_of_scan: [H, W, D]", "\n", "\n", "        ", "n_wmaps", "=", "0", "if", "wmaps_to_sample_per_cat", "is", "None", "else", "len", "(", "wmaps_to_sample_per_cat", ")", "\n", "\n", "if", "self", ".", "_sampling_type", "==", "0", ":", "# fore/background", "\n", "            ", "if", "n_wmaps", ">", "0", ":", "#Both weight maps should be provided currently.", "\n", "                ", "if", "n_wmaps", "!=", "self", ".", "get_n_sampling_cats", "(", ")", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: For sampling_type = Fore/Background(0), [\"", "+", "str", "(", "n_wmaps", ")", "+", "\"] weight maps were provided! \"", "+", "\"Two (fore/back) were expected! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "sampling_maps_per_cat", "=", "wmaps_to_sample_per_cat", "\n", "", "elif", "gt_lbl_img", "is", "None", ":", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: For sampling_type=[\"", "+", "self", ".", "_sampling_type_str", "+", "\"], if weighted-maps are not provided, \"", "+", "\"at least Ground Truth labels should be given to extract foreground! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "elif", "roi_mask", "is", "not", "None", ":", "# and provided GT", "\n", "                ", "mask_to_sample_foregr", "=", "(", "(", "gt_lbl_img", ">", "0", ")", "*", "(", "roi_mask", ">", "0", ")", ")", ".", "astype", "(", "\"int8\"", ")", "\n", "mask_to_sample_backgr", "=", "(", "(", "mask_to_sample_foregr", "==", "0", ")", "*", "(", "roi_mask", ">", "0", ")", ")", ".", "astype", "(", "\"int8\"", ")", "# ROI minus foregr.", "\n", "sampling_maps_per_cat", "=", "[", "mask_to_sample_foregr", ",", "mask_to_sample_backgr", "]", "#Foreground / Background (in sequence)", "\n", "", "else", ":", "# no weightmaps, gt provided and roi is not provided.", "\n", "                ", "mask_to_sample_foregr", "=", "(", "gt_lbl_img", ">", "0", ")", ".", "astype", "(", "\"int8\"", ")", "\n", "mask_to_sample_backgr", "=", "np", ".", "ones", "(", "dims_of_scan", ",", "dtype", "=", "\"int8\"", ")", "*", "(", "mask_to_sample_foregr", "==", "0", ")", "\n", "sampling_maps_per_cat", "=", "[", "mask_to_sample_foregr", ",", "mask_to_sample_backgr", "]", "#Foreground / Background (in sequence)", "\n", "", "", "elif", "self", ".", "_sampling_type", "==", "1", ":", "# uniform", "\n", "            ", "if", "n_wmaps", ">", "0", ":", "\n", "                ", "if", "n_wmaps", "!=", "1", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: For sampling_type=[\"", "+", "self", ".", "_sampling_type_str", "+", "\"], [\"", "+", "str", "(", "n_wmaps", ")", "+", "\"] weight maps were provided! \"", "+", "\"One was expected! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "sampling_maps_per_cat", "=", "wmaps_to_sample_per_cat", "#Should be an array with dim1==1 already.", "\n", "", "elif", "roi_mask", "is", "not", "None", ":", "\n", "                ", "sampling_maps_per_cat", "=", "[", "roi_mask", "]", "#Be careful to not change either of the two arrays later or there'll be a problem.", "\n", "", "else", ":", "\n", "                ", "sampling_maps_per_cat", "=", "[", "np", ".", "ones", "(", "dims_of_scan", ",", "dtype", "=", "\"int8\"", ")", "]", "\n", "", "", "elif", "self", ".", "_sampling_type", "==", "2", ":", "# full image. SAME AS UNIFORM?", "\n", "            ", "if", "n_wmaps", ">", "0", ":", "\n", "                ", "if", "n_wmaps", "!=", "1", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: For sampling_type=[\"", "+", "self", ".", "_sampling_type_str", "+", "\"], [\"", "+", "str", "(", "n_wmaps", ")", "+", "\"] weight maps were provided! \"", "+", "\"One was expected! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "sampling_maps_per_cat", "=", "wmaps_to_sample_per_cat", "#Should be an array with dim1==1 already.", "\n", "", "elif", "roi_mask", "is", "not", "None", ":", "\n", "                ", "sampling_maps_per_cat", "=", "[", "roi_mask", "]", "#Be careful to not change either of the two arrays later or there'll be a problem.", "\n", "", "else", ":", "\n", "                ", "sampling_maps_per_cat", "=", "[", "np", ".", "ones", "(", "dims_of_scan", ",", "dtype", "=", "\"int8\"", ")", "]", "\n", "", "", "elif", "self", ".", "_sampling_type", "==", "3", ":", "# Targeted per class.", "\n", "            ", "if", "n_wmaps", ">", "0", ":", "\n", "                ", "if", "n_wmaps", "!=", "self", ".", "get_n_sampling_cats", "(", ")", ":", "\n", "                    ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: Sampling-Type [\"", "+", "self", ".", "_sampling_type_str", "+", "\"], [\"", "+", "str", "(", "n_wmaps", ")", "+", "\"] weight maps were provided! \"", "+", "\"As many as classes [\"", "+", "str", "(", "self", ".", "get_n_sampling_cats", "(", ")", ")", "+", "\"] (incl Background) were expected! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "sampling_maps_per_cat", "=", "wmaps_to_sample_per_cat", "#Should have as many entries as classes (incl backgr).", "\n", "", "elif", "gt_lbl_img", "is", "None", ":", "\n", "                ", "self", ".", "_log", ".", "print3", "(", "\"ERROR: Sampling type [3, per-class] requires weight-maps or manual labels for each class! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "", "elif", "roi_mask", "is", "not", "None", ":", "# and provided GT", "\n", "                ", "sampling_maps_per_cat", "=", "[", "]", "\n", "for", "cat_i", "in", "range", "(", "self", ".", "get_n_sampling_cats", "(", ")", ")", ":", "# Should be same number as actual classes, including background.", "\n", "                    ", "sampling_maps_per_cat", ".", "append", "(", "(", "(", "gt_lbl_img", "==", "cat_i", ")", "*", "(", "roi_mask", ">", "0", ")", ")", ".", "astype", "(", "\"int8\"", ")", ")", "\n", "", "", "else", ":", "# no weightmaps, gt provided and roi is not provided.", "\n", "                ", "sampling_maps_per_cat", "=", "[", "]", "\n", "for", "cat_i", "in", "range", "(", "self", ".", "get_n_sampling_cats", "(", ")", ")", ":", "# Should be same number as actual classes, including background.", "\n", "                    ", "sampling_maps_per_cat", ".", "append", "(", "(", "gt_lbl_img", "==", "cat_i", ")", ".", "astype", "(", "\"int8\"", ")", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid value for sampling type.\"", ")", "\n", "\n", "", "return", "sampling_maps_per_cat", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.distribute_n_samples_to_categs": [[139, 164], ["samplingType.SamplingType._normalize_percentages", "len", "numpy.zeros", "range", "numpy.random.choice", "int", "numpy.sum", "numpy.sum", "zip"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType._normalize_percentages"], ["", "def", "distribute_n_samples_to_categs", "(", "self", ",", "n_samples", ",", "sampling_maps_per_cat", ")", ":", "\n", "# sampling_maps_per_cat: returned by self.derive_sampling_maps_per_cat(...)", "\n", "# The below is a list of booleans, where False if a sampling_map is all 0.", "\n", "        ", "valid_cats", "=", "[", "np", ".", "sum", "(", "s_map", ")", ">", "0", "for", "s_map", "in", "sampling_maps_per_cat", "]", "\n", "\n", "# Set weight for sampling a category to 0 if it's not valid.", "\n", "perc_samples_per_valid_cat", "=", "[", "p", "if", "v", "else", "0.", "for", "p", ",", "v", "in", "zip", "(", "self", ".", "_perc_to_sample_per_cat", ",", "valid_cats", ")", "]", "\n", "# Renormalize probabilities.", "\n", "perc_samples_per_valid_cat", "=", "self", ".", "_normalize_percentages", "(", "perc_samples_per_valid_cat", ")", "\n", "\n", "# First, distribute n_samples to the categories:", "\n", "n_sampl_cats", "=", "len", "(", "perc_samples_per_valid_cat", ")", "\n", "n_samples_per_cat", "=", "np", ".", "zeros", "(", "n_sampl_cats", ",", "dtype", "=", "\"int32\"", ")", "\n", "for", "cat_i", "in", "range", "(", "n_sampl_cats", ")", ":", "\n", "            ", "n_samples_per_cat", "[", "cat_i", "]", "+=", "int", "(", "n_samples", "*", "perc_samples_per_valid_cat", "[", "cat_i", "]", ")", "\n", "# Distribute samples that were left if perc dont exactly add to 1.", "\n", "", "n_undistributed_samples", "=", "n_samples", "-", "np", ".", "sum", "(", "n_samples_per_cat", ")", "\n", "cats_to_distribute_samples", "=", "np", ".", "random", ".", "choice", "(", "n_sampl_cats", ",", "\n", "size", "=", "n_undistributed_samples", ",", "\n", "replace", "=", "True", ",", "\n", "p", "=", "perc_samples_per_valid_cat", ")", "\n", "for", "cat_i", "in", "cats_to_distribute_samples", ":", "\n", "            ", "n_samples_per_cat", "[", "cat_i", "]", "+=", "1", "\n", "\n", "", "return", "n_samples_per_cat", ",", "valid_cats", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.calc_border_int_of_3d_img": [[14, 25], ["numpy.mean"], "function", ["None"], ["def", "calc_border_int_of_3d_img", "(", "img_3d", ")", ":", "\n", "    ", "border_int", "=", "np", ".", "mean", "(", "[", "img_3d", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "img_3d", "[", "-", "1", ",", "0", ",", "0", "]", ",", "\n", "img_3d", "[", "0", ",", "-", "1", ",", "0", "]", ",", "\n", "img_3d", "[", "-", "1", ",", "-", "1", ",", "0", "]", ",", "\n", "img_3d", "[", "0", ",", "0", ",", "-", "1", "]", ",", "\n", "img_3d", "[", "-", "1", ",", "0", ",", "-", "1", "]", ",", "\n", "img_3d", "[", "0", ",", "-", "1", ",", "-", "1", "]", ",", "\n", "img_3d", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "]", ")", "\n", "return", "border_int", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.calc_pad_per_axis": [[28, 53], ["numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.maximum"], "function", ["None"], ["", "def", "calc_pad_per_axis", "(", "pad_input_imgs", ",", "dims_img", ",", "dims_rec_field", ",", "dims_highres_segment", ")", ":", "\n", "# dims_rec_field: size of CNN's receptive field. [x,y,z]", "\n", "# dims_highres_segment: The size of image segments that the cnn gets.", "\n", "#     So that we calculate the pad that will go to the side of the volume.", "\n", "    ", "if", "not", "pad_input_imgs", ":", "\n", "        ", "return", "(", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ",", "(", "0", ",", "0", ")", ")", "\n", "\n", "", "rec_field_array", "=", "np", ".", "asarray", "(", "dims_rec_field", ",", "dtype", "=", "\"int16\"", ")", "\n", "dims_img_arr", "=", "np", ".", "asarray", "(", "dims_img", ",", "dtype", "=", "\"int16\"", ")", "\n", "dims_segm_arr", "=", "np", ".", "asarray", "(", "dims_highres_segment", ",", "dtype", "=", "\"int16\"", ")", "\n", "# paddingValue = (img[0, 0, 0] + img[-1, 0, 0] + img[0, -1, 0] + img[-1, -1, 0] + img[0, 0, -1]", "\n", "#                 + img[-1, 0, -1] + img[0, -1, -1] + img[-1, -1, -1]) / 8.0", "\n", "# Calculate how much padding needed to fully infer the original img, taking only the receptive field in account.", "\n", "pad_left", "=", "(", "rec_field_array", "-", "1", ")", "//", "2", "\n", "pad_right", "=", "rec_field_array", "-", "1", "-", "pad_left", "\n", "# Now, to cover the case that the specified size for sampled image-segment is larger than the image", "\n", "# (eg full-image inference and current image is smaller), pad further to right.", "\n", "extra_pad_right", "=", "np", ".", "maximum", "(", "0", ",", "dims_segm_arr", "-", "(", "dims_img_arr", "+", "pad_left", "+", "pad_right", ")", ")", "\n", "pad_right", "+=", "extra_pad_right", "\n", "\n", "pad_left_right_per_axis", "=", "(", "(", "pad_left", "[", "0", "]", ",", "pad_right", "[", "0", "]", ")", ",", "\n", "(", "pad_left", "[", "1", "]", ",", "pad_right", "[", "1", "]", ")", ",", "\n", "(", "pad_left", "[", "2", "]", ",", "pad_right", "[", "2", "]", ")", ")", "\n", "\n", "return", "pad_left_right_per_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_imgs_of_case": [[57, 86], ["preprocessing.pad_4d_arr", "preprocessing.pad_3d_img", "preprocessing.pad_3d_img", "preprocessing.pad_4d_arr"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_4d_arr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_3d_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_3d_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_4d_arr"], ["", "def", "pad_imgs_of_case", "(", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "\n", "pad_input_imgs", ",", "unpred_margin", ")", ":", "\n", "# channels: np.array of dimensions [n_channels, x-dim, y-dim, z-dim]", "\n", "# gt_lbl_img: np.array", "\n", "# roi_mask: np.array", "\n", "# wmaps_to_sample_per_cat: np.array of dimensions [num_categories, x-dim, y-dim, z-dim]", "\n", "# pad_input_imgs: Boolean, do padding or not.", "\n", "# unpred_margin: [[pre-x, post-x], [pre-y, post-y], [pre-z, post-z]], number voxels not predicted", "\n", "# Returns:", "\n", "# pad_left_right_axes: Padding added before and after each axis. All 0s if no padding.", "\n", "    ", "if", "not", "pad_input_imgs", ":", "\n", "        ", "pad_left_right_axis", "=", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "return", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "pad_left_right_axis", "\n", "\n", "# Padding added before and after each axis.", "\n", "", "pad_left_right_per_axis", "=", "unpred_margin", "\n", "\n", "channels", "=", "pad_4d_arr", "(", "channels", ",", "pad_left_right_per_axis", ")", "\n", "\n", "if", "gt_lbl_img", "is", "not", "None", ":", "\n", "        ", "gt_lbl_img", "=", "pad_3d_img", "(", "gt_lbl_img", ",", "pad_left_right_per_axis", ")", "\n", "\n", "", "if", "roi_mask", "is", "not", "None", ":", "\n", "        ", "roi_mask", "=", "pad_3d_img", "(", "roi_mask", ",", "pad_left_right_per_axis", ")", "\n", "\n", "", "if", "wmaps_to_sample_per_cat", "is", "not", "None", ":", "\n", "        ", "wmaps_to_sample_per_cat", "=", "pad_4d_arr", "(", "wmaps_to_sample_per_cat", ",", "pad_left_right_per_axis", ")", "\n", "\n", "", "return", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "pad_left_right_per_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_4d_arr": [[87, 91], ["numpy.lib.pad"], "function", ["None"], ["", "def", "pad_4d_arr", "(", "arr_4d", ",", "pad_left_right_per_axis_3d", ")", ":", "\n", "# Do not pad first dimension. E.g. for channels or weightmaps, [n_chans,x,y,z]", "\n", "    ", "pad_left_right_per_axis_4d", "=", "[", "[", "0", ",", "0", "]", ",", "]", "+", "pad_left_right_per_axis_3d", "\n", "return", "np", ".", "lib", ".", "pad", "(", "arr_4d", ",", "pad_left_right_per_axis_4d", ",", "'reflect'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_3d_img": [[92, 96], ["numpy.lib.pad"], "function", ["None"], ["", "def", "pad_3d_img", "(", "img", ",", "pad_left_right_per_axis", ")", ":", "\n", "# img: 3D array.", "\n", "# pad_left_right_per_axis is returned in order for unpadding to know how much to remove.", "\n", "    ", "return", "np", ".", "lib", ".", "pad", "(", "img", ",", "pad_left_right_per_axis", ",", "'reflect'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.unpad_3d_img": [[98, 113], ["None"], "function", ["None"], ["", "def", "unpad_3d_img", "(", "img", ",", "padding_left_right_per_axis", ")", ":", "\n", "# img: 3d array", "\n", "# padding_left_right_per_axis: ((pad-l-x,pad-r-x), (pad-l-y,pad-r-y), (pad-l-z,pad-r-z))", "\n", "    ", "unpadded_img", "=", "img", "[", "padding_left_right_per_axis", "[", "0", "]", "[", "0", "]", ":", ",", "\n", "padding_left_right_per_axis", "[", "1", "]", "[", "0", "]", ":", ",", "\n", "padding_left_right_per_axis", "[", "2", "]", "[", "0", "]", ":", "]", "\n", "# The checks below are to make it work if padding == 0, which may happen for 2D on the 3rd axis.", "\n", "unpadded_img", "=", "unpadded_img", "[", ":", "-", "padding_left_right_per_axis", "[", "0", "]", "[", "1", "]", ",", ":", ",", ":", "]", "if", "padding_left_right_per_axis", "[", "0", "]", "[", "1", "]", ">", "0", "else", "unpadded_img", "\n", "unpadded_img", "=", "unpadded_img", "[", ":", ",", ":", "-", "padding_left_right_per_axis", "[", "1", "]", "[", "1", "]", ",", ":", "]", "if", "padding_left_right_per_axis", "[", "1", "]", "[", "1", "]", ">", "0", "else", "unpadded_img", "\n", "unpadded_img", "=", "unpadded_img", "[", ":", ",", ":", ",", ":", "-", "padding_left_right_per_axis", "[", "2", "]", "[", "1", "]", "]", "if", "padding_left_right_per_axis", "[", "2", "]", "[", "1", "]", ">", "0", "else", "unpadded_img", "\n", "\n", "return", "unpadded_img", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_int_of_subj": [[119, 143], ["time.time", "preprocessing.normalize_zscore_subj", "log.print3", "norms_applied.append", "str", "time.time"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_zscore_subj", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "normalize_int_of_subj", "(", "log", ",", "channels", ",", "roi_mask", ",", "prms", ",", "job_id", ")", ":", "\n", "# prms = {'verbose_lvl': 0/1/2", "\n", "#         'zscore': None or dictionary with parameters", "\n", "#        }", "\n", "\n", "    ", "if", "prms", "is", "None", ":", "\n", "        ", "return", "channels", "\n", "\n", "", "verbose_lvl", "=", "prms", "[", "'verbose_lvl'", "]", "if", "'verbose_lvl'", "in", "prms", "else", "0", "\n", "norms_applied", "=", "[", "]", "\n", "\n", "time_0", "=", "time", ".", "time", "(", ")", "\n", "# TODO: window_ints(min, max)", "\n", "# TODO: linear_rescale_to(new_min, new_max)", "\n", "if", "'zscore'", "in", "prms", ":", "\n", "        ", "channels", ",", "applied", "=", "normalize_zscore_subj", "(", "log", ",", "channels", ",", "roi_mask", ",", "prms", "[", "'zscore'", "]", ",", "verbose_lvl", ",", "job_id", ")", "\n", "if", "applied", ":", "\n", "            ", "norms_applied", ".", "append", "(", "'zscore'", ")", "\n", "\n", "", "", "if", "verbose_lvl", ">=", "1", ":", "\n", "        ", "log", ".", "print3", "(", "job_id", "+", "\" Normalized subject's images with \"", "+", "str", "(", "norms_applied", ")", "+", "\". \"", "+", "\"Took [{0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "time_0", ")", "+", "\"] secs\"", ")", "\n", "\n", "", "return", "channels", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_img_stats": [[146, 151], ["numpy.mean", "numpy.std", "numpy.max"], "function", ["None"], ["", "def", "get_img_stats", "(", "img", ",", "calc_mean", "=", "True", ",", "calc_std", "=", "True", ",", "calc_max", "=", "True", ")", ":", "\n", "    ", "mean", "=", "np", ".", "mean", "(", "img", ")", "if", "calc_mean", "else", "None", "\n", "std", "=", "np", ".", "std", "(", "img", ")", "if", "calc_std", "else", "None", "\n", "max", "=", "np", ".", "max", "(", "img", ")", "if", "calc_max", "else", "None", "\n", "return", "mean", ",", "std", ",", "max", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_cutoff_mask": [[153, 157], ["None"], "function", ["None"], ["", "def", "get_cutoff_mask", "(", "img", ",", "low", ",", "high", ")", ":", "\n", "    ", "low_mask", "=", "img", ">", "low", "\n", "high_mask", "=", "img", "<", "high", "\n", "return", "low_mask", "*", "high_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_zscore_img": [[159, 220], ["roi_mask_bool.copy", "preprocessing.get_img_stats", "numpy.percentile", "numpy.percentile", "preprocessing.get_cutoff_mask", "preprocessing.get_img_stats", "preprocessing.get_cutoff_mask", "preprocessing.get_img_stats", "preprocessing.get_cutoff_mask", "preprocessing.get_img_stats", "numpy.mean", "numpy.std", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_img_stats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_cutoff_mask", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_img_stats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_cutoff_mask", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_img_stats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_cutoff_mask", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.get_img_stats"], ["", "def", "normalize_zscore_img", "(", "img", ",", "roi_mask_bool", ",", "\n", "cutoff_percents", ",", "cutoff_times_std", ",", "cutoff_below_mean", ",", "\n", "get_stats_info", "=", "False", ")", ":", "\n", "#     cutoff_percents  : Percentile cutoff (floats: [low_percentile, high_percentile], values in [0-100])", "\n", "#     cutoff_times_std : Cutoff in terms of standard deviation (floats: [low_multiple, high_multiple])", "\n", "#     cutoff_below_mean: Low cutoff of whole image mean (True or False)", "\n", "# Returns: Normalized image and a string that can be logged/printed with info on cutoffs used.", "\n", "# get_stats_info: If True, also computes and returns info on statistics. Extra compute.", "\n", "\n", "    ", "old_mean", "=", "None", "\n", "old_std", "=", "None", "\n", "log_info", "=", "\"For computing mean/std for normalizing, disregarded voxels according to following rules:\"", "\n", "img_roi", "=", "img", "[", "roi_mask_bool", "]", "# This gets flattened automatically. It's a vector array.", "\n", "mask_bool_norm", "=", "roi_mask_bool", ".", "copy", "(", ")", "# Needed, so that below do not change it for other channels", "\n", "log_info", "+=", "\"\\n\\t Cutoff outside ROI.\"", "\n", "\n", "if", "cutoff_percents", "is", "not", "None", ":", "\n", "        ", "cutoff_low", "=", "np", ".", "percentile", "(", "img_roi", ",", "cutoff_percents", "[", "0", "]", ")", "\n", "cutoff_high", "=", "np", ".", "percentile", "(", "img_roi", ",", "cutoff_percents", "[", "1", "]", ")", "\n", "mask_bool_norm", "*=", "get_cutoff_mask", "(", "img", ",", "cutoff_low", ",", "cutoff_high", ")", "\n", "log_info", "+=", "\"\\n\\t Cutoff ints outside \"", "+", "str", "(", "cutoff_percents", ")", "+", "\" 'percentiles' (within ROI).\"", "+", "\" Cutoffs: Low={0:.2f}\"", ".", "format", "(", "cutoff_low", ")", "+", "\", Max={0:.2f}\"", ".", "format", "(", "cutoff_high", ")", "\n", "\n", "", "if", "cutoff_times_std", "is", "not", "None", ":", "\n", "        ", "img_roi_mean", ",", "img_roi_std", ",", "_", "=", "get_img_stats", "(", "img_roi", ",", "calc_max", "=", "False", ")", "\n", "old_mean", "=", "img_roi_mean", "\n", "old_std", "=", "img_roi_std", "\n", "cutoff_low", "=", "img_roi_mean", "-", "cutoff_times_std", "[", "0", "]", "*", "img_roi_std", "\n", "cutoff_high", "=", "img_roi_mean", "+", "cutoff_times_std", "[", "1", "]", "*", "img_roi_std", "\n", "mask_bool_norm", "*=", "get_cutoff_mask", "(", "img", ",", "cutoff_low", ",", "cutoff_high", ")", "\n", "log_info", "+=", "\"\\n\\t Cutoff ints below/above \"", "+", "str", "(", "cutoff_times_std", ")", "+", "\" times the 'std' from the 'mean' (within ROI).\"", "+", "\" Cutoffs: Low={0:.2f}\"", ".", "format", "(", "cutoff_low", ")", "+", "\", High={0:.2f}\"", ".", "format", "(", "cutoff_high", ")", "\n", "\n", "", "if", "cutoff_below_mean", ":", "# Avoid if not asked, to save compute.", "\n", "        ", "img_mean", ",", "_", ",", "img_max", "=", "get_img_stats", "(", "img", ",", "calc_std", "=", "False", ")", "\n", "cutoff_low", "=", "img_mean", "\n", "cutoff_high", "=", "img_max", "\n", "mask_bool_norm", "*=", "get_cutoff_mask", "(", "img", ",", "cutoff_low", ",", "cutoff_high", ")", "# no high cutoff", "\n", "log_info", "+=", "\"\\n\\t Cutoff ints below mean of *original* img (cuts air in brain MRI).\"", "+", "\" Cutoff: Low={0:.2f}\"", ".", "format", "(", "cutoff_low", ")", "\n", "\n", "", "norm_mean", ",", "norm_std", ",", "_", "=", "get_img_stats", "(", "img", "[", "mask_bool_norm", "]", ",", "calc_max", "=", "False", ")", "\n", "\n", "# Normalize", "\n", "normalized_img", "=", "(", "img", "-", "norm_mean", ")", "/", "(", "1.0", "*", "norm_std", ")", "\n", "\n", "# Report", "\n", "if", "get_stats_info", ":", "\n", "        ", "if", "old_mean", "is", "None", ":", "# May have been computed as part of above calc.", "\n", "            ", "old_mean", "=", "np", ".", "mean", "(", "img_roi", ")", "\n", "", "if", "old_std", "is", "None", ":", "\n", "            ", "old_std", "=", "np", ".", "std", "(", "img_roi", ")", "\n", "", "new_mean", ",", "new_std", ",", "_", "=", "get_img_stats", "(", "normalized_img", "[", "roi_mask_bool", "]", ",", "calc_max", "=", "False", ")", "\n", "\n", "log_info", "+=", "\"\\n\\t Stats (mean/std within ROI): \"", "+", "\"Original [{0:.2f}\"", ".", "format", "(", "old_mean", ")", "+", "\"/{0:.2f}\"", ".", "format", "(", "old_std", ")", "+", "\"], \"", "+", "\"Normalized using [{0:.2f}\"", ".", "format", "(", "norm_mean", ")", "+", "\"/{0:.2f}\"", ".", "format", "(", "norm_std", ")", "+", "\"], \"", "+", "\"Final [{0:.2f}\"", ".", "format", "(", "new_mean", ")", "+", "\"/{0:.2f}\"", ".", "format", "(", "new_std", ")", "+", "\"]\"", "\n", "\n", "", "return", "normalized_img", ",", "log_info", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_zscore_subj": [[223, 270], ["enumerate", "isinstance", "numpy.zeros", "preprocessing.normalize_zscore_img", "numpy.ones", "log.print3", "len", "isinstance", "ValueError", "len", "len", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_zscore_img", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "normalize_zscore_subj", "(", "log", ",", "channels", ",", "roi_mask", ",", "prms", ",", "verbose_lvl", "=", "0", ",", "job_id", "=", "''", ",", "in_place", "=", "True", ")", ":", "\n", "# channels: array [n_channels, x, y, z]", "\n", "# roi_mask: array [x,y,z]", "\n", "# norm_params: dictionary with following key:value entries", "\n", "#     'apply_to_all_channels': True/False -> Whether to perform z-score normalization.", "\n", "#     'apply_per_channel': [Booleans] -> List of len(channels) booleans, whether to normalize each channel.", "\n", "#     'cutoff_percents', 'cutoff_times_std', 'cutoff_below_mean': see called func normalize_zscore_img()", "\n", "#     NOTE: If apply_to_all_channels: True, then REQUIRES that apply_per_channel: None", "\n", "#     E.g. BRATS: cutoff_perc: [5., 95.], cutoff_times_std: [2., 2.], cutoff_below_mean: True", "\n", "# verbose_lvl: 0: no logging, 1: Timing, 2: Stats per channel", "\n", "# job_id: string for logging, specifying job number and pid. In testing, \"\".", "\n", "    ", "assert", "not", "(", "prms", "[", "'apply_to_all_channels'", "]", "and", "prms", "[", "'apply_per_channel'", "]", "is", "not", "None", ")", "\n", "assert", "(", "prms", "[", "'apply_per_channel'", "]", "is", "None", "or", "isinstance", "(", "prms", "[", "'apply_per_channel'", "]", ",", "list", ")", ")", "\n", "\n", "list_bools_apply_per_c", "=", "None", "\n", "\n", "if", "prms", "is", "None", ":", "\n", "        ", "return", "channels", ",", "False", "\n", "", "elif", "prms", "[", "'apply_to_all_channels'", "]", ":", "\n", "        ", "list_bools_apply_per_c", "=", "[", "True", "]", "*", "len", "(", "channels", ")", "\n", "", "elif", "prms", "[", "'apply_per_channel'", "]", "is", "None", ":", "\n", "        ", "return", "channels", ",", "False", "\n", "", "elif", "isinstance", "(", "prms", "[", "'apply_per_channel'", "]", ",", "list", ")", ":", "\n", "        ", "assert", "len", "(", "prms", "[", "'apply_per_channel'", "]", ")", "==", "len", "(", "channels", ")", "\n", "list_bools_apply_per_c", "=", "prms", "[", "'apply_per_channel'", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unexpected value for parameter in normalize_zscore_subj()\"", ")", "\n", "\n", "", "channels_norm", "=", "channels", "if", "in_place", "else", "np", ".", "zeros", "(", "channels", ".", "shape", ")", "\n", "roi_mask_bool", "=", "roi_mask", ">", "0", "if", "roi_mask", "is", "not", "None", "else", "np", ".", "ones", "(", "channels", "[", "0", "]", ".", "shape", ")", ">", "0", "\n", "applied", "=", "False", "\n", "\n", "for", "idx", ",", "channel", "in", "enumerate", "(", "channels", ")", ":", "\n", "        ", "if", "not", "list_bools_apply_per_c", "[", "idx", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "channels_norm", "[", "idx", "]", ",", "log_info", "=", "normalize_zscore_img", "(", "channel", ",", "roi_mask_bool", ",", "\n", "prms", "[", "'cutoff_percents'", "]", ",", "\n", "prms", "[", "'cutoff_times_std'", "]", ",", "\n", "prms", "[", "'cutoff_below_mean'", "]", ",", "\n", "verbose_lvl", ">=", "2", ")", "\n", "applied", "=", "True", "\n", "\n", "if", "verbose_lvl", ">=", "2", ":", "\n", "            ", "log", ".", "print3", "(", "job_id", "+", "\" Z-Score Normalization of Channel-\"", "+", "str", "(", "idx", ")", "+", "\":\\n\\t\"", "+", "log_info", ")", "\n", "\n", "", "", "return", "channels_norm", ",", "applied", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.reflect_array_if_needed": [[275, 284], ["None"], "function", ["None"], ["", "def", "reflect_array_if_needed", "(", "reflect_flags", ",", "arr", ")", ":", "\n", "    ", "strides_for_refl_per_dim", "=", "[", "-", "1", "if", "reflect_flags", "[", "0", "]", "else", "1", ",", "\n", "-", "1", "if", "reflect_flags", "[", "1", "]", "else", "1", ",", "\n", "-", "1", "if", "reflect_flags", "[", "2", "]", "else", "1", "]", "\n", "\n", "refl_arr", "=", "arr", "[", ":", ":", "strides_for_refl_per_dim", "[", "0", "]", ",", "\n", ":", ":", "strides_for_refl_per_dim", "[", "1", "]", ",", "\n", ":", ":", "strides_for_refl_per_dim", "[", "2", "]", "]", "\n", "return", "refl_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_samples_for_subepoch": [[43, 201], ["time.time", "log.print3", "len", "sampling.choose_random_subjects", "log.print3", "log.print3", "len", "sampling.get_n_samples_per_subj", "log.print3", "list", "sampling.shuffle_samples", "log.print3", "log.print3", "numpy.asarray", "range", "numpy.asarray", "str", "range", "sampling.load_subj_and_sample", "range", "len", "collections.OrderedDict", "log.print3", "log.print3", "min", "log.print3", "multiprocessing.Pool", "str", "str", "str", "cnn3d.getNumPathwaysThatRequireInput", "cnn3d.getNumPathwaysThatRequireInput", "multiprocessing.cpu_count", "list", "multiprocessing.Pool.terminate", "multiprocessing.Pool.join", "os.getpid", "os.getpid", "multiprocessing.Pool.apply_async", "log.print3", "log.print3", "multiprocessing.Pool.terminate", "multiprocessing.Pool.join", "log.print3", "multiprocessing.Pool.terminate", "multiprocessing.Pool.join", "Exception", "str", "str", "str", "str", "jobs[].get", "range", "list.remove", "traceback.format_exc", "time.time", "len", "cnn3d.getNumPathwaysThatRequireInput", "log.print3", "log.print3", "sys.exc_info", "str", "str", "str", "multiprocessing.cpu_count", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.choose_random_subjects", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_n_samples_per_subj", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.shuffle_samples", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.load_subj_and_sample", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.configParsing.config.Config.get", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["def", "get_samples_for_subepoch", "(", "log", ",", "\n", "train_val_or_test", ",", "\n", "num_parallel_proc", ",", "\n", "run_input_checks", ",", "\n", "cnn3d", ",", "\n", "max_n_cases_per_subep", ",", "\n", "n_samples_per_subep", ",", "\n", "sampling_type", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ",", "\n", "unpred_margin", ",", "\n", "# Paths to input files", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_masks_per_subj", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj", ",", "\n", "# Preprocessing & Augmentation", "\n", "pad_input_imgs", ",", "\n", "norm_prms", ",", "\n", "augm_img_prms", ",", "\n", "augm_sample_prms", ")", ":", "\n", "# train_val_or_test: 'train', 'val' or 'test'", "\n", "# Returns: channs_of_samples_arr_per_path - List of arrays [N_samples, Channs, R,C,Z], one per pathway.", "\n", "#          lbls_predicted_part_of_samples_arr - Array of shape: [N_samples, R_out, C_out, Z_out)", "\n", "\n", "    ", "sampler_id", "=", "\"[TRA|SAMPLER|PID:\"", "+", "str", "(", "os", ".", "getpid", "(", ")", ")", "+", "\"]\"", "if", "train_val_or_test", "==", "\"train\"", "else", "\"[VAL|SAMPLER|PID:\"", "+", "str", "(", "os", ".", "getpid", "(", ")", ")", "+", "\"]\"", "\n", "start_time_sampling", "=", "time", ".", "time", "(", ")", "\n", "tr_or_val_str_log", "=", "\"Training\"", "if", "train_val_or_test", "==", "\"train\"", "else", "\"Validation\"", "\n", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\n", "\" :=:=:=:=:=:=: Starting to sample for next [\"", "+", "tr_or_val_str_log", "+", "\"]... :=:=:=:=:=:=:\"", ")", "\n", "\n", "n_total_subjects", "=", "len", "(", "paths_per_chan_per_subj", ")", "\n", "idxs_of_subjs_for_subep", "=", "choose_random_subjects", "(", "n_total_subjects", ",", "max_n_cases_per_subep", ")", "\n", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" Out of [\"", "+", "str", "(", "n_total_subjects", ")", "+", "\"] subjects given for [\"", "+", "\n", "tr_or_val_str_log", "+", "\"], we will sample from maximum [\"", "+", "str", "(", "max_n_cases_per_subep", ")", "+", "\n", "\"] per subepoch.\"", ")", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" Shuffled indices of subjects that were randomly chosen: \"", "+", "str", "(", "idxs_of_subjs_for_subep", ")", ")", "\n", "\n", "# List, with [numberOfPathwaysThatTakeInput] sublists.", "\n", "# Each sublist is list of [partImagesLoadedPerSubepoch] arrays [channels, R,C,Z].", "\n", "channs_of_samples_per_path", "=", "[", "[", "]", "for", "i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", "]", "\n", "lbls_predicted_part_of_samples", "=", "[", "]", "# Labels only for the central/predicted part of segments.", "\n", "# Can be different than max_n_cases_per_subep, because of available images number.", "\n", "n_subjs_for_subep", "=", "len", "(", "idxs_of_subjs_for_subep", ")", "\n", "\n", "# Get how many samples I should get from each subject.", "\n", "n_samples_per_subj", "=", "get_n_samples_per_subj", "(", "n_samples_per_subep", ",", "n_subjs_for_subep", ")", "\n", "\n", "args_sampling_job", "=", "[", "log", ",", "\n", "train_val_or_test", ",", "\n", "run_input_checks", ",", "\n", "cnn3d", ",", "\n", "sampling_type", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_masks_per_subj", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj", ",", "\n", "# Pre-processing:", "\n", "pad_input_imgs", ",", "\n", "norm_prms", ",", "\n", "augm_img_prms", ",", "\n", "augm_sample_prms", ",", "\n", "\n", "n_subjs_for_subep", ",", "\n", "idxs_of_subjs_for_subep", ",", "\n", "n_samples_per_subj", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ",", "\n", "unpred_margin", "\n", "]", "\n", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" Will sample from [\"", "+", "str", "(", "n_subjs_for_subep", ")", "+", "\n", "\"] subjects for next \"", "+", "tr_or_val_str_log", "+", "\"...\"", ")", "\n", "\n", "jobs_idxs_to_do", "=", "list", "(", "range", "(", "n_subjs_for_subep", ")", ")", "# One job per subject.", "\n", "\n", "if", "num_parallel_proc", "<=", "0", ":", "# Sequentially", "\n", "        ", "for", "job_idx", "in", "jobs_idxs_to_do", ":", "\n", "            ", "(", "channs_samples_from_job_per_path", ",", "\n", "lbls_predicted_part_samples_from_job", ")", "=", "load_subj_and_sample", "(", "*", "(", "[", "job_idx", "]", "+", "args_sampling_job", ")", ")", "\n", "for", "pathway_i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", ":", "\n", "# concat does not copy.", "\n", "                ", "channs_of_samples_per_path", "[", "pathway_i", "]", "+=", "channs_samples_from_job_per_path", "[", "pathway_i", "]", "\n", "", "lbls_predicted_part_of_samples", "+=", "lbls_predicted_part_samples_from_job", "# concat does not copy.", "\n", "\n", "", "", "else", ":", "# Parallelize sampling from each subject", "\n", "        ", "while", "len", "(", "jobs_idxs_to_do", ")", ">", "0", ":", "# While jobs remain.", "\n", "            ", "jobs", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" ******* Spawning children processes to sample from [\"", "+", "\n", "str", "(", "len", "(", "jobs_idxs_to_do", ")", ")", "+", "\"] subjects*******\"", ")", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" MULTIPR: Number of CPUs detected: \"", "+", "str", "(", "multiprocessing", ".", "cpu_count", "(", ")", ")", "+", "\n", "\". Requested to use max: [\"", "+", "str", "(", "num_parallel_proc", ")", "+", "\"]\"", ")", "\n", "n_workers", "=", "min", "(", "num_parallel_proc", ",", "multiprocessing", ".", "cpu_count", "(", ")", ")", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" MULTIPR: Spawning [\"", "+", "str", "(", "n_workers", ")", "+", "\"] processes to load and sample.\"", ")", "\n", "mp_pool", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "n_workers", ",", "initializer", "=", "init_sampling_proc", ")", "\n", "\n", "try", ":", "# Stacktrace in MULTIPR: https://jichu4n.com/posts/python-multiprocessing-and-exceptions/", "\n", "                ", "for", "job_idx", "in", "jobs_idxs_to_do", ":", "# submit jobs", "\n", "                    ", "jobs", "[", "job_idx", "]", "=", "mp_pool", ".", "apply_async", "(", "load_subj_and_sample", ",", "(", "[", "job_idx", "]", "+", "args_sampling_job", ")", ")", "\n", "\n", "# copy with list(...), so that this loops normally even if something is removed from list.", "\n", "", "for", "job_idx", "in", "list", "(", "jobs_idxs_to_do", ")", ":", "\n", "                    ", "try", ":", "\n", "# timeout in case process for some reason never started (happens in py3)", "\n", "                        ", "(", "channs_samples_from_job_per_path", ",", "\n", "lbls_predicted_part_samples_from_job", ")", "=", "jobs", "[", "job_idx", "]", ".", "get", "(", "timeout", "=", "60", ")", "\n", "for", "pathway_i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", ":", "\n", "# concat does not copy.", "\n", "                            ", "channs_of_samples_per_path", "[", "pathway_i", "]", "+=", "channs_samples_from_job_per_path", "[", "pathway_i", "]", "\n", "# concat does not copy.", "\n", "", "lbls_predicted_part_of_samples", "+=", "lbls_predicted_part_samples_from_job", "\n", "jobs_idxs_to_do", ".", "remove", "(", "job_idx", ")", "\n", "", "except", "multiprocessing", ".", "TimeoutError", ":", "\n", "                        ", "log", ".", "print3", "(", "sampler_id", "+", "\"\\n\\n WARN: MULTIPR: Caught TimeoutError when getting results of job [\"", "+", "\n", "str", "(", "job_idx", ")", "+", "\"].\\n WARN: MULTIPR: Will resubmit job [\"", "+", "str", "(", "job_idx", ")", "+", "\"].\\n\"", ")", "\n", "if", "n_workers", "==", "1", ":", "\n", "                            ", "break", "# If this worker got stuck, every job will wait timeout. Slow. Recreate pool.", "\n", "", "", "except", "Exception", "as", "e", ":", "\n", "                        ", "log", ".", "print3", "(", "sampler_id", "+", "\"\\n\\n ERROR: Caught exception from job [\"", "+", "str", "(", "job_idx", ")", "+", "\"].\"", ")", "\n", "raise", "e", "\n", "\n", "", "", "", "except", "(", "Exception", ",", "KeyboardInterrupt", ")", "as", "e", ":", "\n", "                ", "log", ".", "print3", "(", "\n", "sampler_id", "+", "\"\\n\\n ERROR: Caught exception in get_samples_for_subepoch(): \"", "+", "str", "(", "e", ")", "+", "\"\\n\"", ")", "\n", "log", ".", "print3", "(", "traceback", ".", "format_exc", "(", ")", ")", "\n", "mp_pool", ".", "terminate", "(", ")", "\n", "mp_pool", ".", "join", "(", ")", "# Will wait. A KeybInt will kill this (py3)", "\n", "raise", "e", "\n", "", "except", ":", "# Catches everything, even a sys.exit(1) exception.", "\n", "                ", "log", ".", "print3", "(", "sampler_id", "+", "\"\\n\\n ERROR: Unexpected error in get_samples_for_subepoch(). \"", "+", "\"System info: \"", ",", "sys", ".", "exc_info", "(", ")", "[", "0", "]", ")", "\n", "mp_pool", ".", "terminate", "(", ")", "\n", "mp_pool", ".", "join", "(", ")", "\n", "raise", "Exception", "(", "\"Unexpected error.\"", ")", "\n", "", "else", ":", "# Nothing went wrong", "\n", "# Needed in case any processes are hanging. mp_pool.close() does not solve this.", "\n", "                ", "mp_pool", ".", "terminate", "(", ")", "\n", "mp_pool", ".", "join", "(", ")", "\n", "\n", "# Got all samples for subepoch. Now shuffle them, together segments and their labels.", "\n", "", "", "", "(", "channs_of_samples_per_path", ",", "\n", "lbls_predicted_part_of_samples", ")", "=", "shuffle_samples", "(", "channs_of_samples_per_path", ",", "lbls_predicted_part_of_samples", ")", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" TIMING: Sampling for next [\"", "+", "tr_or_val_str_log", "+", "\n", "\"] lasted: {0:.1f}\"", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start_time_sampling", ")", "+", "\" secs.\"", ")", "\n", "\n", "log", ".", "print3", "(", "sampler_id", "+", "\" :=:=:=:=:=:= Finished sampling for next [\"", "+", "tr_or_val_str_log", "+", "\"] =:=:=:=:=:=:\"", ")", "\n", "\n", "channs_of_samples_arr_per_path", "=", "[", "np", ".", "asarray", "(", "channs_of_samples_for_path", ",", "dtype", "=", "\"float32\"", ")", "for", "\n", "channs_of_samples_for_path", "in", "channs_of_samples_per_path", "]", "\n", "\n", "lbls_predicted_part_of_samples_arr", "=", "np", ".", "asarray", "(", "lbls_predicted_part_of_samples", ",", "dtype", "=", "\"int32\"", ")", "\n", "\n", "return", "channs_of_samples_arr_per_path", ",", "lbls_predicted_part_of_samples_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.init_sampling_proc": [[203, 207], ["signal.signal"], "function", ["None"], ["", "def", "init_sampling_proc", "(", ")", ":", "\n", "# This will make child-processes ignore the KeyboardInterupt (sigInt). Parent will handle it.", "\n", "# See: http://stackoverflow.com/questions/11312525/catch-ctrlc-sigint-and-exit-multiprocesses-gracefully-in-python/35134329#35134329", "\n", "    ", "signal", ".", "signal", "(", "signal", ".", "SIGINT", ",", "signal", ".", "SIG_IGN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.choose_random_subjects": [[209, 233], ["list", "random.shuffle", "range", "len", "random.shuffle", "min", "len", "len"], "function", ["None"], ["", "def", "choose_random_subjects", "(", "n_total_subjects", ",", "\n", "max_subjects_on_gpu_for_subepoch", ",", "\n", "get_max_subjects_for_gpu_even_if_total_less", "=", "False", ")", ":", "\n", "# Returns: list of indices", "\n", "    ", "subjects_indices", "=", "list", "(", "range", "(", "n_total_subjects", ")", ")", "# list() for python3, cause shuffle() cant get range", "\n", "random_order_chosen_subjects", "=", "[", "]", "\n", "random", ".", "shuffle", "(", "subjects_indices", ")", "# does it in place. Now they are shuffled", "\n", "\n", "if", "max_subjects_on_gpu_for_subepoch", ">=", "n_total_subjects", ":", "\n", "        ", "random_order_chosen_subjects", "+=", "subjects_indices", "\n", "\n", "# This is if I want to have a certain amount on GPU, even if total subjects are less.", "\n", "if", "get_max_subjects_for_gpu_even_if_total_less", ":", "\n", "            ", "while", "len", "(", "random_order_chosen_subjects", ")", "<", "max_subjects_on_gpu_for_subepoch", ":", "\n", "                ", "random", ".", "shuffle", "(", "subjects_indices", ")", "\n", "number_of_extra_subjects_to_get_to_fill_gpu", "=", "min", "(", "\n", "max_subjects_on_gpu_for_subepoch", "-", "len", "(", "random_order_chosen_subjects", ")", ",", "n_total_subjects", ")", "\n", "random_order_chosen_subjects", "+=", "(", "subjects_indices", "[", ":", "number_of_extra_subjects_to_get_to_fill_gpu", "]", ")", "\n", "", "assert", "len", "(", "random_order_chosen_subjects", ")", "==", "max_subjects_on_gpu_for_subepoch", "\n", "\n", "", "", "else", ":", "\n", "        ", "random_order_chosen_subjects", "+=", "subjects_indices", "[", ":", "max_subjects_on_gpu_for_subepoch", "]", "\n", "\n", "", "return", "random_order_chosen_subjects", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_n_samples_per_subj": [[235, 243], ["range", "numpy.ones", "random.randint"], "function", ["None"], ["", "def", "get_n_samples_per_subj", "(", "n_samples", ",", "n_subjects", ")", ":", "\n", "# Distribute samples of each cat to subjects.", "\n", "    ", "n_samples_per_subj", "=", "np", ".", "ones", "(", "[", "n_subjects", "]", ",", "dtype", "=", "'int32'", ")", "*", "(", "n_samples", "//", "n_subjects", ")", "\n", "n_undistributed_samples", "=", "n_samples", "%", "n_subjects", "\n", "# Distribute samples that were left by inexact division.", "\n", "for", "idx", "in", "range", "(", "n_undistributed_samples", ")", ":", "\n", "        ", "n_samples_per_subj", "[", "random", ".", "randint", "(", "0", ",", "n_subjects", "-", "1", ")", "]", "+=", "1", "\n", "", "return", "n_samples_per_subj", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.constrain_sampling_maps_near_edges": [[245, 256], ["sampling.comp_valid_sampling_mask_excluding_edges", "range", "len", "numpy.multiply", "constrained_maps.append"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.comp_valid_sampling_mask_excluding_edges"], ["", "def", "constrain_sampling_maps_near_edges", "(", "sample_maps_per_cat", ",", "dims_sample", ")", ":", "\n", "# We wish to sample pixels around which the samples we will extract will be centered.", "\n", "# But we need to be CAREFUL and get only pixels that are NOT closer to the image boundaries than the dimensions of the", "\n", "# samples we wish to extract permit.", "\n", "    ", "constrained_maps", "=", "[", "]", "\n", "mask_excl_edges", "=", "comp_valid_sampling_mask_excluding_edges", "(", "dims_sample", ",", "sample_maps_per_cat", "[", "0", "]", ".", "shape", ")", "\n", "for", "cat_i", "in", "range", "(", "len", "(", "sample_maps_per_cat", ")", ")", ":", "\n", "        ", "sampling_map", "=", "sample_maps_per_cat", "[", "cat_i", "]", "\n", "sampling_map_excl_near_edges", "=", "np", ".", "multiply", "(", "sampling_map", ",", "mask_excl_edges", ",", "dtype", "=", "sampling_map", ".", "dtype", ")", "\n", "constrained_maps", ".", "append", "(", "sampling_map_excl_near_edges", ")", "\n", "", "return", "constrained_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.load_subj_and_sample": [[258, 406], ["log.print3", "time.time", "sampling.load_imgs_of_subject", "time.time", "sampling.preproc_imgs_of_subj", "time.time", "deepmedic.dataManagement.augmentImage.augment_imgs_of_case", "sampling_type.derive_sampling_maps_per_cat", "sampling.constrain_sampling_maps_near_edges", "sampling_type.distribute_n_samples_to_categs", "range", "log.print3", "log.print3", "time.time", "time.time", "time.time", "sampling_type.get_n_sampling_cats", "time.time", "sampling.sample_idxs_of_segments", "range", "str", "range", "sampling_type.get_sampling_cats_as_str", "log.print3", "time.time", "len", "time.time", "sampling.extractSegmentGivenSliceCoords", "time.time", "deepmedic.dataManagement.augmentSample.augment_sample", "range", "lbls_predicted_part_of_samples.append", "str", "str", "cnn3d.getNumPathwaysThatRequireInput", "str", "time.time", "time.time", "cnn3d.getNumPathwaysThatRequireInput", "channs_of_samples_per_path[].append", "os.getpid", "os.getpid", "str", "str", "str", "str", "len", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.load_imgs_of_subject", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.preproc_imgs_of_subj", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentImage.augment_imgs_of_case", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.derive_sampling_maps_per_cat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.constrain_sampling_maps_near_edges", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.distribute_n_samples_to_categs", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_n_sampling_cats", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.sample_idxs_of_segments", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.samplingType.SamplingType.get_sampling_cats_as_str", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.extractSegmentGivenSliceCoords", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.augmentSample.augment_sample", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput"], ["", "def", "load_subj_and_sample", "(", "job_idx", ",", "\n", "log", ",", "\n", "train_val_or_test", ",", "\n", "run_input_checks", ",", "\n", "cnn3d", ",", "\n", "sampling_type", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_masks_per_subj", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj", ",", "\n", "# Pre-processing:", "\n", "pad_input_imgs", ",", "\n", "norm_prms", ",", "\n", "augm_img_prms", ",", "\n", "augm_sample_prms", ",", "\n", "n_subjs_for_subep", ",", "\n", "idxs_of_subjs_for_subep", ",", "\n", "n_samples_per_subj", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ",", "\n", "unpred_margin", ")", ":", "\n", "# train_val_or_test: 'train', 'val' or 'test'", "\n", "# paths_per_chan_per_subj: [[ for chan-0 [ one path per subj ]], ..., [for chan-n  [ one path per subj ] ]]", "\n", "# n_samples_per_cat_per_subj: np arr, shape [num sampling categories, num subjects in subepoch]", "\n", "# returns: ( channs_of_samples_per_path, lbls_predicted_part_of_samples )", "\n", "    ", "job_id", "=", "\"[TRA|JOB:\"", "+", "str", "(", "job_idx", ")", "+", "\"|PID:\"", "+", "str", "(", "os", ".", "getpid", "(", ")", ")", "+", "\"]\"", "if", "train_val_or_test", "==", "'train'", "else", "\"[VAL|JOB:\"", "+", "str", "(", "job_idx", ")", "+", "\"|PID:\"", "+", "str", "(", "os", ".", "getpid", "(", ")", ")", "+", "\"]\"", "\n", "\n", "log", ".", "print3", "(", "job_id", "+", "\" Started. (#\"", "+", "str", "(", "job_idx", ")", "+", "\"/\"", "+", "str", "(", "n_subjs_for_subep", ")", "+", "\") sampling job. \"", "+", "\n", "\"Load & sample from subject of index (in user's list): \"", "+", "str", "(", "idxs_of_subjs_for_subep", "[", "job_idx", "]", ")", ")", "\n", "\n", "# List, with [numberOfPathwaysThatTakeInput] sublists.", "\n", "# Each sublist is list of [partImagesLoadedPerSubepoch] arrays [channels, R,C,Z].", "\n", "channs_of_samples_per_path", "=", "[", "[", "]", "for", "i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", "]", "\n", "lbls_predicted_part_of_samples", "=", "[", "]", "# Labels only for the central/predicted part of segments.", "\n", "\n", "dims_hres_segment", "=", "inp_shapes_per_path", "[", "0", "]", "\n", "\n", "# Load images of subject", "\n", "time_load_0", "=", "time", ".", "time", "(", ")", "\n", "(", "channels", ",", "# nparray [channels,dim0,dim1,dim2]", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "wmaps_to_sample_per_cat", ")", "=", "load_imgs_of_subject", "(", "log", ",", "job_id", ",", "\n", "idxs_of_subjs_for_subep", "[", "job_idx", "]", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj", ",", "\n", "paths_to_masks_per_subj", ")", "\n", "\n", "# Pre-process images of subject", "\n", "time_load", "=", "time", ".", "time", "(", ")", "-", "time_load_0", "\n", "time_prep_0", "=", "time", ".", "time", "(", ")", "\n", "(", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "wmaps_to_sample_per_cat", ",", "\n", "pad_left_right_per_axis", ")", "=", "preproc_imgs_of_subj", "(", "log", ",", "job_id", ",", "\n", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "\n", "run_input_checks", ",", "cnn3d", ".", "num_classes", ",", "# checks", "\n", "pad_input_imgs", ",", "unpred_margin", ",", "\n", "norm_prms", ")", "\n", "time_prep", "=", "time", ".", "time", "(", ")", "-", "time_prep_0", "\n", "\n", "# Augment at image level:", "\n", "time_augm_0", "=", "time", ".", "time", "(", ")", "\n", "(", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "wmaps_to_sample_per_cat", ")", "=", "augment_imgs_of_case", "(", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "wmaps_to_sample_per_cat", ",", "\n", "augm_img_prms", ")", "\n", "time_augm_img", "=", "time", ".", "time", "(", ")", "-", "time_augm_0", "\n", "\n", "# Sampling of segments (sub-volumes) from an image.", "\n", "dims_of_scan", "=", "channels", "[", "0", "]", ".", "shape", "\n", "sampling_maps_per_cat", "=", "sampling_type", ".", "derive_sampling_maps_per_cat", "(", "wmaps_to_sample_per_cat", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "dims_of_scan", ")", "\n", "sampling_maps_per_cat", "=", "constrain_sampling_maps_near_edges", "(", "sampling_maps_per_cat", ",", "dims_hres_segment", ")", "\n", "\n", "\n", "# Get number of samples per sampling-category for the specific subject (class, foregr/backgr, etc)", "\n", "(", "n_samples_per_cat", ",", "valid_cats", ")", "=", "sampling_type", ".", "distribute_n_samples_to_categs", "(", "n_samples_per_subj", "[", "job_idx", "]", ",", "\n", "sampling_maps_per_cat", ")", "\n", "time_sample_idxs", "=", "0", "\n", "time_extr_samples", "=", "0", "\n", "time_augm_samples", "=", "0", "\n", "str_samples_per_cat", "=", "\" Done. Samples per category: \"", "\n", "for", "cat_i", "in", "range", "(", "sampling_type", ".", "get_n_sampling_cats", "(", ")", ")", ":", "\n", "        ", "cat_str", "=", "sampling_type", ".", "get_sampling_cats_as_str", "(", ")", "[", "cat_i", "]", "\n", "n_samples_for_cat", "=", "n_samples_per_cat", "[", "cat_i", "]", "\n", "sampling_map", "=", "sampling_maps_per_cat", "[", "cat_i", "]", "\n", "# Check if the class is valid for sampling.", "\n", "# Invalid if eg there is no such class in the subject's manual segmentation.", "\n", "if", "not", "valid_cats", "[", "cat_i", "]", ":", "\n", "            ", "log", ".", "print3", "(", "job_id", "+", "\" WARN: Invalid sampling category! Sampling map just zeros! No [\"", "+", "cat_str", "+", "\n", "\"] samples from this subject!\"", ")", "\n", "assert", "n_samples_for_cat", "==", "0", "\n", "continue", "# This should not be needed, the next func should also handle it. But whatever.", "\n", "\n", "", "time_sample_idx0", "=", "time", ".", "time", "(", ")", "\n", "idxs_sampl_centers", "=", "sample_idxs_of_segments", "(", "log", ",", "\n", "job_id", ",", "\n", "n_samples_for_cat", ",", "\n", "sampling_map", ")", "\n", "time_sample_idxs", "+=", "time", ".", "time", "(", ")", "-", "time_sample_idx0", "\n", "str_samples_per_cat", "+=", "\"[\"", "+", "cat_str", "+", "\": \"", "+", "str", "(", "len", "(", "idxs_sampl_centers", "[", "0", "]", ")", ")", "+", "\"/\"", "+", "str", "(", "n_samples_for_cat", ")", "+", "\"] \"", "\n", "\n", "# Use the just sampled coordinates of slices to actually extract the segments (data) from the subject's images.", "\n", "for", "image_part_i", "in", "range", "(", "len", "(", "idxs_sampl_centers", "[", "0", "]", ")", ")", ":", "\n", "            ", "coord_center", "=", "idxs_sampl_centers", "[", ":", ",", "image_part_i", "]", "\n", "\n", "time_extr_sample_0", "=", "time", ".", "time", "(", ")", "\n", "(", "channs_of_sample_per_path", ",", "\n", "lbls_predicted_part_of_sample", ")", "=", "extractSegmentGivenSliceCoords", "(", "train_val_or_test", ",", "\n", "cnn3d", ",", "\n", "coord_center", ",", "\n", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ")", "\n", "time_extr_samples", "+=", "time", ".", "time", "(", ")", "-", "time_extr_sample_0", "\n", "\n", "# Augmentation of segments", "\n", "time_augm_sample_0", "=", "time", ".", "time", "(", ")", "\n", "(", "channs_of_sample_per_path", ",", "\n", "lbls_predicted_part_of_sample", ")", "=", "augment_sample", "(", "channs_of_sample_per_path", ",", "\n", "lbls_predicted_part_of_sample", ",", "\n", "augm_sample_prms", ")", "\n", "time_augm_samples", "+=", "time", ".", "time", "(", ")", "-", "time_augm_sample_0", "\n", "\n", "for", "pathway_i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", ":", "\n", "                ", "channs_of_samples_per_path", "[", "pathway_i", "]", ".", "append", "(", "channs_of_sample_per_path", "[", "pathway_i", "]", ")", "\n", "", "lbls_predicted_part_of_samples", ".", "append", "(", "lbls_predicted_part_of_sample", ")", "\n", "\n", "", "", "log", ".", "print3", "(", "job_id", "+", "str_samples_per_cat", ")", "\n", "log", ".", "print3", "(", "job_id", "+", "\" TIMING: \"", "+", "\n", "\"[Load: {0:.1f}\"", ".", "format", "(", "time_load", ")", "+", "\"] \"", "\n", "\"[Preproc: {0:.1f}\"", ".", "format", "(", "time_prep", ")", "+", "\"] \"", "+", "\n", "\"[Augm-Img: {0:.1f}\"", ".", "format", "(", "time_augm_img", ")", "+", "\"] \"", "+", "\n", "\"[Sample Coords: {0:.1f}\"", ".", "format", "(", "time_sample_idxs", ")", "+", "\"] \"", "+", "\n", "\"[Extract Sampl: {0:.1f}\"", ".", "format", "(", "time_extr_samples", ")", "+", "\"] \"", "+", "\n", "\"[Augm-Samples: {0:.1f}\"", ".", "format", "(", "time_augm_samples", ")", "+", "\"] secs\"", ")", "\n", "return", "(", "channs_of_samples_per_path", ",", "lbls_predicted_part_of_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.load_imgs_of_subject": [[412, 485], ["log.print3", "len", "range", "deepmedic.dataManagement.io.load_volume", "deepmedic.dataManagement.io.load_volume", "len", "numpy.zeros", "range", "str", "deepmedic.dataManagement.io.load_volume", "log.print3", "log.print3", "numpy.rint().astype", "log.print3", "numpy.rint().astype", "deepmedic.dataManagement.io.load_volume", "list", "numpy.zeros", "list", "numpy.all", "ValueError", "numpy.rint", "numpy.rint", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.load_volume", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.load_volume", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.load_volume", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.io.load_volume"], ["", "def", "load_imgs_of_subject", "(", "log", ",", "\n", "job_id", ",", "\n", "subj_i", ",", "\n", "paths_per_chan_per_subj", ",", "\n", "paths_to_lbls_per_subj", ",", "\n", "paths_to_wmaps_per_sampl_cat_per_subj", ",", "\n", "paths_to_masks_per_subj", "\n", ")", ":", "\n", "# paths_per_chan_per_subj: None or List of lists. One sublist per case. Each should contain...", "\n", "# ... as many elements(strings-filenamePaths) as numberOfChannels, pointing to (nii) channels of this case.", "\n", "\n", "    ", "log", ".", "print3", "(", "job_id", "+", "\" Loading subject with 1st channel at: \"", "+", "str", "(", "paths_per_chan_per_subj", "[", "subj_i", "]", "[", "0", "]", ")", ")", "\n", "\n", "n_channels", "=", "len", "(", "paths_per_chan_per_subj", "[", "0", "]", ")", "\n", "\n", "# Load the channels of the patient.", "\n", "inp_chan_dims", "=", "None", "# Dimensions of the (padded) input channels.", "\n", "channels", "=", "None", "\n", "for", "channel_i", "in", "range", "(", "n_channels", ")", ":", "\n", "        ", "path_to_chan", "=", "paths_per_chan_per_subj", "[", "subj_i", "]", "[", "channel_i", "]", "\n", "if", "path_to_chan", "!=", "\"-\"", ":", "# normal case, filepath was given.", "\n", "            ", "channel", "=", "load_volume", "(", "path_to_chan", ")", "\n", "\n", "if", "channels", "is", "None", ":", "\n", "# Initialize the array in which all the channels for the patient will be placed.", "\n", "                ", "inp_chan_dims", "=", "list", "(", "channel", ".", "shape", ")", "\n", "channels", "=", "np", ".", "zeros", "(", "(", "n_channels", ",", "inp_chan_dims", "[", "0", "]", ",", "inp_chan_dims", "[", "1", "]", ",", "inp_chan_dims", "[", "2", "]", ")", ")", "\n", "\n", "", "channels", "[", "channel_i", "]", "=", "channel", "\n", "", "else", ":", "# \"-\" was given in the config-listing file. Do Min-fill!", "\n", "            ", "log", ".", "print3", "(", "job_id", "+", "\" WARN: No modality #\"", "+", "str", "(", "channel_i", ")", "+", "\" given. Will make zero-filled channel.\"", ")", "\n", "channels", "[", "channel_i", "]", "=", "0.0", "\n", "\n", "# Load the class labels.", "\n", "", "", "if", "paths_to_lbls_per_subj", "is", "not", "None", ":", "\n", "        ", "path_to_lbl", "=", "paths_to_lbls_per_subj", "[", "subj_i", "]", "\n", "gt_lbl_img", "=", "load_volume", "(", "path_to_lbl", ")", "\n", "\n", "if", "gt_lbl_img", ".", "dtype", ".", "kind", "not", "in", "[", "'i'", ",", "'u'", "]", ":", "\n", "            ", "dtype_gt_lbls", "=", "'int16'", "\n", "log", ".", "print3", "(", "job_id", "+", "\" WARN: Loaded labels are dtype [\"", "+", "str", "(", "gt_lbl_img", ".", "dtype", ")", "+", "\"].\"", "\n", "\" Rounding and casting to [\"", "+", "dtype_gt_lbls", "+", "\"]!\"", ")", "\n", "gt_lbl_img", "=", "np", ".", "rint", "(", "gt_lbl_img", ")", ".", "astype", "(", "dtype_gt_lbls", ")", "\n", "", "", "else", ":", "\n", "        ", "gt_lbl_img", "=", "None", "# For validation and testing", "\n", "\n", "", "if", "paths_to_masks_per_subj", "is", "not", "None", ":", "\n", "        ", "path_to_roi_mask", "=", "paths_to_masks_per_subj", "[", "subj_i", "]", "\n", "roi_mask", "=", "load_volume", "(", "path_to_roi_mask", ")", "\n", "\n", "if", "roi_mask", ".", "dtype", ".", "kind", "not", "in", "[", "'i'", ",", "'u'", "]", ":", "\n", "            ", "dtype_roi_mask", "=", "'int16'", "\n", "log", ".", "print3", "(", "job_id", "+", "\" WARN: Loaded ROI-mask is dtype [\"", "+", "str", "(", "roi_mask", ".", "dtype", ")", "+", "\"].\"", "\n", "\" Rounding and casting to [\"", "+", "dtype_roi_mask", "+", "\"]!\"", ")", "\n", "roi_mask", "=", "np", ".", "rint", "(", "roi_mask", ")", ".", "astype", "(", "dtype_roi_mask", ")", "\n", "", "", "else", ":", "\n", "        ", "roi_mask", "=", "None", "\n", "\n", "# May be provided only for training.", "\n", "", "if", "paths_to_wmaps_per_sampl_cat_per_subj", "is", "not", "None", ":", "\n", "        ", "n_sampl_categs", "=", "len", "(", "paths_to_wmaps_per_sampl_cat_per_subj", ")", "\n", "wmaps_to_sample_per_cat", "=", "np", ".", "zeros", "(", "[", "n_sampl_categs", "]", "+", "list", "(", "channels", "[", "0", "]", ".", "shape", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "for", "cat_i", "in", "range", "(", "n_sampl_categs", ")", ":", "\n", "            ", "path_to_wmaps_for_this_cat_per_subj", "=", "paths_to_wmaps_per_sampl_cat_per_subj", "[", "cat_i", "]", "\n", "path_to_wmap_for_this_cat", "=", "path_to_wmaps_for_this_cat_per_subj", "[", "subj_i", "]", "\n", "wmap_for_this_cat", "=", "load_volume", "(", "path_to_wmap_for_this_cat", ")", "\n", "if", "not", "np", ".", "all", "(", "wmap_for_this_cat", ">=", "0", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"Negative values found in weightmap. Unexpected. Zero or positives allowed.\"", ")", "\n", "", "wmaps_to_sample_per_cat", "[", "cat_i", "]", "=", "wmap_for_this_cat", "\n", "", "", "else", ":", "\n", "        ", "wmaps_to_sample_per_cat", "=", "None", "\n", "\n", "", "return", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.preproc_imgs_of_subj": [[487, 504], ["deepmedic.dataManagement.preprocessing.pad_imgs_of_case", "deepmedic.dataManagement.preprocessing.normalize_int_of_subj", "sampling.check_gt_vs_num_classes"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.pad_imgs_of_case", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.normalize_int_of_subj", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.check_gt_vs_num_classes"], ["", "def", "preproc_imgs_of_subj", "(", "log", ",", "job_id", ",", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "\n", "run_input_checks", ",", "n_classes", ",", "pad_input_imgs", ",", "unpred_margin", ",", "norm_prms", ")", ":", "\n", "# job_id: Should be \"\" in testing.", "\n", "\n", "    ", "if", "run_input_checks", ":", "\n", "        ", "check_gt_vs_num_classes", "(", "log", ",", "job_id", ",", "gt_lbl_img", ",", "n_classes", ")", "\n", "\n", "", "(", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "roi_mask", ",", "\n", "wmaps_to_sample_per_cat", ",", "\n", "pad_left_right_per_axis", ")", "=", "pad_imgs_of_case", "(", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "\n", "pad_input_imgs", ",", "unpred_margin", ")", "\n", "\n", "channels", "=", "normalize_int_of_subj", "(", "log", ",", "channels", ",", "roi_mask", ",", "norm_prms", ",", "job_id", ")", "\n", "\n", "return", "channels", ",", "gt_lbl_img", ",", "roi_mask", ",", "wmaps_to_sample_per_cat", ",", "pad_left_right_per_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.comp_valid_sampling_mask_excluding_edges": [[506, 545], ["numpy.zeros", "numpy.zeros", "range", "len", "len", "math.floor"], "function", ["None"], ["", "def", "comp_valid_sampling_mask_excluding_edges", "(", "dims_of_segment", ",", "shape", ")", ":", "\n", "# I look for lesions that are not closer to the image boundaries than the ImagePart dimensions allow.", "\n", "# KernelDim is always odd. BUT ImagePart dimensions can be odd or even.", "\n", "# If odd, ok, floor(dim/2) from central.", "\n", "# If even, dim/2-1 voxels towards the begining of the axis and dim/2 towards the end.", "\n", "# Ie, \"central\" imagePart voxel is 1 closer to begining.", "\n", "# BTW imagePartDim takes kernel into account (ie if I want 9^3 voxels classified per imagePart with kernel 5x5,", "\n", "# I want 13 dim ImagePart)", "\n", "\n", "# number of voxels to exclude from edges of the image, left and right in each axis, when sampling...", "\n", "# ...the center of a segment. So that the segment will be fully contained in the image. (half segm left & right)", "\n", "# dim1: 1 row per r,c,z. Dim2: left/right width not to sample from (=half segment).", "\n", "    ", "n_vox_excl_left_right", "=", "np", ".", "zeros", "(", "(", "len", "(", "dims_of_segment", ")", ",", "2", ")", ",", "dtype", "=", "'int16'", ")", "\n", "\n", "# The below starts all zero. Will be Multiplied by other true-false arrays expressing if the relevant", "\n", "# voxels are within boundaries.", "\n", "# In the end, the final vector will be true only for the indices of lesions that are within all boundaries.", "\n", "mask_excl_near_edges", "=", "np", ".", "zeros", "(", "shape", ",", "dtype", "=", "'int8'", ")", "\n", "\n", "# This loop leads to mask_excl_near_edges to be true for the indices ...", "\n", "# ...that allow getting an imagePart CENTERED on them, and be safely within image boundaries. Note that ...", "\n", "# ... if the imagePart is of even dimension, the \"central\" voxel is one voxel to the left.", "\n", "for", "rcz_i", "in", "range", "(", "len", "(", "dims_of_segment", ")", ")", ":", "\n", "        ", "if", "dims_of_segment", "[", "rcz_i", "]", "%", "2", "==", "0", ":", "# even", "\n", "            ", "dims_div_2", "=", "dims_of_segment", "[", "rcz_i", "]", "//", "2", "\n", "# central of ImagePart is 1 vox closer to begining of axes.", "\n", "n_vox_excl_left_right", "[", "rcz_i", "]", "=", "[", "dims_div_2", "-", "1", ",", "dims_div_2", "]", "\n", "", "else", ":", "# odd", "\n", "# If odd, middle voxel is the \"central\". Eg 5/2 = 2, with 3rd voxel being the central.", "\n", "            ", "dims_div_2_floor", "=", "math", ".", "floor", "(", "dims_of_segment", "[", "rcz_i", "]", "//", "2", ")", "\n", "n_vox_excl_left_right", "[", "rcz_i", "]", "=", "[", "dims_div_2_floor", ",", "dims_div_2_floor", "]", "\n", "# used to be [n_vox_excl_left_right[0][0]: -n_vox_excl_left_right[0][1]],", "\n", "# but in 2D case n_vox_excl_left_right might be ==0, causes problem and you get a null slice.", "\n", "", "", "mask_excl_near_edges", "[", "\n", "n_vox_excl_left_right", "[", "0", "]", "[", "0", "]", ":", "shape", "[", "0", "]", "-", "n_vox_excl_left_right", "[", "0", "]", "[", "1", "]", ",", "\n", "n_vox_excl_left_right", "[", "1", "]", "[", "0", "]", ":", "shape", "[", "1", "]", "-", "n_vox_excl_left_right", "[", "1", "]", "[", "1", "]", ",", "\n", "n_vox_excl_left_right", "[", "2", "]", "[", "0", "]", ":", "shape", "[", "2", "]", "-", "n_vox_excl_left_right", "[", "2", "]", "[", "1", "]", "]", "=", "1", "\n", "\n", "return", "mask_excl_near_edges", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.sampling_cumsum": [[546, 554], ["p_1darr.cumsum", "numpy.clip", "numpy.random.random", "numpy.searchsorted"], "function", ["None"], ["", "def", "sampling_cumsum", "(", "p_1darr", ",", "n_samples", ")", ":", "\n", "    ", "p_cumsum", "=", "p_1darr", ".", "cumsum", "(", "dtype", "=", "'float64'", ")", "# This is dangerous, final elements go below or beyond 1.", "\n", "p_cumsum", "=", "np", ".", "clip", "(", "p_cumsum", ",", "a_min", "=", "None", ",", "a_max", "=", "1.", ",", "out", "=", "p_cumsum", ")", "\n", "#p_cumsum[p_cumsum>1.] = 1.", "\n", "p_cumsum", "[", "-", "1", "]", "=", "1.", "\n", "random_ps", "=", "np", ".", "random", ".", "random", "(", "size", "=", "n_samples", ")", "\n", "idxs_sampled", "=", "np", ".", "searchsorted", "(", "p_cumsum", ",", "random_ps", ")", "\n", "return", "idxs_sampled", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.sample_with_appropriate_algorithm": [[555, 577], ["sampling_map.ravel", "numpy.all", "numpy.asarray", "numpy.logical_or", "numpy.arange", "numpy.random.choice", "numpy.multiply", "numpy.random.choice", "numpy.unravel_index"], "function", ["None"], ["", "def", "sample_with_appropriate_algorithm", "(", "n_samples", ",", "sampling_map", ",", "sum_sampl_map", ")", ":", "\n", "\n", "    ", "p_sampling_flat", "=", "sampling_map", ".", "ravel", "(", ")", "# Unnormalized", "\n", "is_0", "=", "p_sampling_flat", "==", "0.", "# np.isclose(p_sampling_flat, 0.)", "\n", "is_1", "=", "p_sampling_flat", "==", "1.", "# np.isclose(p_sampling_flat, 1.)", "\n", "if", "np", ".", "all", "(", "np", ".", "logical_or", "(", "is_0", ",", "is_1", ")", ")", ":", "# Whole sampling map is either 0 or 1. Do faster sampling only under valid idxs.", "\n", "        ", "idxs", "=", "np", ".", "arange", "(", "p_sampling_flat", ".", "size", ",", "dtype", "=", "'int32'", ")", "# Unlikely large image size will need int64", "\n", "valid_idxs", "=", "idxs", "[", "is_1", ">", "0", "]", "\n", "idxs_sampled", "=", "np", ".", "random", ".", "choice", "(", "valid_idxs", ",", "size", "=", "n_samples", ",", "replace", "=", "True", ")", "\n", "", "else", ":", "#if np.any( np.logical_and(sampling_map != 0., sampling_map != 1.)):", "\n", "# Normalize, because sampling method np.random.choice requires it.", "\n", "        ", "p_sampling_normed", "=", "np", ".", "multiply", "(", "p_sampling_flat", ",", "1.", "/", "sum_sampl_map", ",", "dtype", "=", "'float64'", ")", "# as before.", "\n", "#idxs_sampled = sampling_cumsum(p_sampling_normed, n_samples)", "\n", "idxs_sampled", "=", "np", ".", "random", ".", "choice", "(", "p_sampling_normed", ".", "size", ",", "size", "=", "n_samples", ",", "replace", "=", "True", ",", "p", "=", "p_sampling_normed", ")", "\n", "\n", "# np.unravel_index([listOfIndicesInFlattened], dims) returns a tuple of arrays (eg 3 of them if 3 dimImage), ", "\n", "# where each of the array in the tuple has the same shape as the listOfIndices. ", "\n", "# They have the r/c/z coords that correspond to the index of the flattened version.", "\n", "# So, idxs_sampled will be array of shape: 3(rcz) x n_samples.", "\n", "", "idxs_sampled", "=", "np", ".", "asarray", "(", "np", ".", "unravel_index", "(", "idxs_sampled", ",", "sampling_map", ".", "shape", ")", ")", "\n", "\n", "return", "idxs_sampled", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.sample_idxs_of_segments": [[579, 605], ["numpy.sum", "numpy.isclose", "sampling.sample_with_appropriate_algorithm", "log.print3"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.sample_with_appropriate_algorithm", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "sample_idxs_of_segments", "(", "log", ",", "\n", "job_id", ",", "\n", "n_samples", ",", "\n", "sampling_map", ")", ":", "\n", "    ", "\"\"\"\n    sampling_map: np.array of shape (H,W,D), dtype=\"int16\" or potentially float if weightmaps given by user.\n    Returns: idxs_of_sampled_centers\n             Coordinates (xyz indices) of the \"central\" voxel of sampled segments (1 voxel to the left if dimension is even).\n    \n    > idxs_of_sampled_centers: array with shape: 3(xyz) x n_samples.\n        Example: [ xCoordsForCentralVoxelOfEachPart, yCoordsForCentralVoxelOfEachPart, zCoordsForCentralVoxelOfEachPart ]\n        >> x/y/z-CoordsForCentralVoxelOfEachPart: 1-dim array with n_samples, holding the x-indices of samples in image.\n    \"\"\"", "\n", "# Check if the weight map is fully-zeros. In this case, return no element.", "\n", "# Note: Currently, the caller function is checking this case already and does not let this being called.", "\n", "# Which is still fine.", "\n", "sum_sampl_map", "=", "np", ".", "sum", "(", "sampling_map", ",", "dtype", "=", "'float64'", ")", "\n", "if", "np", ".", "isclose", "(", "sum_sampl_map", ",", "0.", ")", ":", "# is zero", "\n", "        ", "log", ".", "print3", "(", "job_id", "+", "\" WARN: Sampling map for category (after excluding near edges) is just zeros! \"", "+", "\" No samples for category from subject!\"", ")", "\n", "return", "[", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", ",", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", "]", "\n", "\n", "# Sample indexes of pixels around which we should extract sample segments.", "\n", "", "idxs_of_sampled_centers", "=", "sample_with_appropriate_algorithm", "(", "n_samples", ",", "sampling_map", ",", "sum_sampl_map", ")", "\n", "\n", "return", "idxs_of_sampled_centers", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_subsampl_segment": [[607, 678], ["numpy.ones", "range", "range", "int", "max", "min", "int", "len", "deepmedic.dataManagement.preprocessing.calc_border_int_of_3d_img", "range", "range", "range", "range", "range", "range", "range", "math.ceil", "range", "abs", "math.ceil"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.preprocessing.calc_border_int_of_3d_img"], ["", "def", "get_subsampl_segment", "(", "rec_field_hr_path", ",", "channels", ",", "segment_hr_slice_coords", ",", "subs_factor", ",", "dims_lr_segm", ")", ":", "\n", "    ", "\"\"\"\n    Given the segment_hr_slice_coords, which has the coordinates where the high-resolution image segment starts and\n    ends (inclusive), this returns the corresponding image segment of down-sampled context for the parallel path(s).\n\n    (Actually, in this implementation, the right (end) part of segment_hr_slice_coords is not used.)\n    The way it works is NOT optimal. It ASSUMES that receptive field or high res and low-res paths are the same size.\n    From the beginning of the high-resolution segment,\n    it goes further to the left 1 receptive-field and then forward subs_factor * receptive-fields.\n    This stops it from being used with arbitrary size of subsampled segment (decoupled by the high-res segment).\n    Now, the subsampled receptive-field has to be of the same size as the normal-scale.\n    To change this, I should find where THE FIRST TOP LEFT CENTRAL (predicted) VOXEL is, <=================\n    and do the back-one-(sub)rec_field + front-3-(sub)ref_fields from there, not from the beginning of the patch.\n\n    Current way it works (correct):\n    If I have eg subsample factor=3 and 9 central-pred-voxels, I get 3 \"central\" voxels for the\n    subsampled-segment. Straightforward. If I have a number of central voxels that is not an exact multiple of\n    the subfactor, eg 10 central-voxels, I get 3+1 central voxels in the subsampled-segment.\n    When the cnn is convolving them, they will get repeated to 4(last-layer-neurons)*3(factor) = 12,\n    and will get sliced down to 10, in order to have same dimension with the 1st pathway.\n    \"\"\"", "\n", "dims_hr_segm", "=", "[", "segment_hr_slice_coords", "[", "d", "]", "[", "1", "]", "-", "segment_hr_slice_coords", "[", "d", "]", "[", "0", "]", "+", "1", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "dims_outp_hr_path", "=", "[", "dims_hr_segm", "[", "d", "]", "-", "rec_field_hr_path", "[", "d", "]", "+", "1", "for", "d", "in", "range", "(", "3", ")", "]", "# Assumes no stride.", "\n", "dims_img", "=", "channels", ".", "shape", "[", "1", ":", "]", "# Channels: [batch, X, Y, Z]", "\n", "\n", "segment_lr", "=", "np", ".", "ones", "(", "(", "channels", ".", "shape", "[", "0", "]", ",", "dims_lr_segm", "[", "0", "]", ",", "dims_lr_segm", "[", "1", "]", ",", "dims_lr_segm", "[", "2", "]", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "n_vox_before", "=", "[", "None", ",", "None", ",", "None", "]", "\n", "centre_of_downsampl_kernel", "=", "[", "None", ",", "None", ",", "None", "]", "\n", "for", "d", "in", "range", "(", "3", ")", ":", "\n", "        ", "if", "subs_factor", "[", "d", "]", "%", "2", "==", "1", ":", "# Odd", "\n", "            ", "n_vox_before", "[", "d", "]", "=", "(", "(", "subs_factor", "[", "d", "]", "-", "1", ")", "//", "2", ")", "*", "rec_field_hr_path", "[", "d", "]", "# TODO: Should be rec_field_lr_path", "\n", "centre_of_downsampl_kernel", "[", "d", "]", "=", "subs_factor", "[", "d", "]", "//", "2", "# 3 ==> 1", "\n", "", "else", ":", "\n", "            ", "n_vox_before", "[", "d", "]", "=", "(", "subs_factor", "[", "d", "]", "-", "2", ")", "//", "2", "*", "rec_field_hr_path", "[", "d", "]", "+", "rec_field_hr_path", "[", "d", "]", "//", "2", "\n", "centre_of_downsampl_kernel", "[", "d", "]", "=", "subs_factor", "[", "d", "]", "//", "2", "-", "1", "# One pixel closer to the beginning of dim.", "\n", "\n", "# This is where to start taking voxels from the subsampled image: From the beginning of the hr_segment...", "\n", "# ... go forward a few steps to the voxel that is like the \"central\" in this subsampled (eg 3x3) area.", "\n", "# ...Then go backwards -Patchsize to find the first voxel of the subsampled.", "\n", "\n", "# These indices can run out of image boundaries. I ll correct them afterwards.", "\n", "", "", "low", "=", "[", "segment_hr_slice_coords", "[", "d", "]", "[", "0", "]", "+", "centre_of_downsampl_kernel", "[", "d", "]", "-", "n_vox_before", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "# If the rec_field is 17x17, I want a 17x17 subsampled Patch. BUT if the segment is 25x25 (9voxClass),", "\n", "# I want 3 voxels in my subsampled-segment to cover this area!", "\n", "# That is what the last term below is taking care of.", "\n", "high_non_incl", "=", "[", "int", "(", "low", "[", "d", "]", "+", "subs_factor", "[", "d", "]", "*", "rec_field_hr_path", "[", "d", "]", "+", "(", "\n", "math", ".", "ceil", "(", "dims_outp_hr_path", "[", "d", "]", "/", "subs_factor", "[", "d", "]", ")", "-", "1", ")", "*", "subs_factor", "[", "d", "]", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n", "low_corrected", "=", "[", "max", "(", "low", "[", "d", "]", ",", "0", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "high_non_incl_corrected", "=", "[", "min", "(", "high_non_incl", "[", "d", "]", ",", "dims_img", "[", "d", "]", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n", "low_to_put_slice_in_segm", "=", "[", "0", "if", "low", "[", "d", "]", ">=", "0", "else", "abs", "(", "low", "[", "d", "]", ")", "//", "subs_factor", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "dims_of_slice_not_padded", "=", "[", "int", "(", "math", ".", "ceil", "(", "(", "high_non_incl_corrected", "[", "d", "]", "-", "low_corrected", "[", "d", "]", ")", "*", "1.0", "/", "subs_factor", "[", "d", "]", ")", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "# dims_of_slice_not_padded =! dims_lr_segm when sampling at borders.", "\n", "\n", "# I now have exactly where to get the slice from and where to put it in the new array.", "\n", "for", "channel_i", "in", "range", "(", "len", "(", "channels", ")", ")", ":", "\n", "        ", "segment_lr", "[", "channel_i", "]", "*=", "calc_border_int_of_3d_img", "(", "channels", "[", "channel_i", "]", ")", "# Make black", "\n", "\n", "chan_slice_lr", "=", "channels", "[", "channel_i", ",", "\n", "low_corrected", "[", "0", "]", ":", "high_non_incl_corrected", "[", "0", "]", ":", "subs_factor", "[", "0", "]", ",", "\n", "low_corrected", "[", "1", "]", ":", "high_non_incl_corrected", "[", "1", "]", ":", "subs_factor", "[", "1", "]", ",", "\n", "low_corrected", "[", "2", "]", ":", "high_non_incl_corrected", "[", "2", "]", ":", "subs_factor", "[", "2", "]", "]", "\n", "segment_lr", "[", "channel_i", ",", "\n", "low_to_put_slice_in_segm", "[", "0", "]", ":", "low_to_put_slice_in_segm", "[", "0", "]", "+", "dims_of_slice_not_padded", "[", "0", "]", ",", "\n", "low_to_put_slice_in_segm", "[", "1", "]", ":", "low_to_put_slice_in_segm", "[", "1", "]", "+", "dims_of_slice_not_padded", "[", "1", "]", ",", "\n", "low_to_put_slice_in_segm", "[", "2", "]", ":", "low_to_put_slice_in_segm", "[", "2", "]", "+", "dims_of_slice_not_padded", "[", "2", "]", "\n", "]", "=", "chan_slice_lr", "\n", "\n", "", "return", "segment_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.shuffle_samples": [[680, 694], ["len", "list", "random.shuffle", "list", "zip", "zip"], "function", ["None"], ["", "def", "shuffle_samples", "(", "channs_of_samples_per_path", ",", "lbls_predicted_part_of_samples", ")", ":", "\n", "    ", "n_paths_taking_inp", "=", "len", "(", "channs_of_samples_per_path", ")", "\n", "inp_to_zip", "=", "[", "sublist_for_path", "for", "sublist_for_path", "in", "channs_of_samples_per_path", "]", "\n", "inp_to_zip", "+=", "[", "lbls_predicted_part_of_samples", "]", "\n", "\n", "combined", "=", "list", "(", "zip", "(", "*", "inp_to_zip", ")", ")", "# list() for python3 compatibility, as range cannot get assignment in shuffle()", "\n", "random", ".", "shuffle", "(", "combined", ")", "\n", "sublists_with_shuffled_samples", "=", "list", "(", "zip", "(", "*", "combined", ")", ")", "\n", "\n", "shuffled_channs_of_samples_per_path", "=", "[", "sublist_for_path", "for", "sublist_for_path", "in", "\n", "sublists_with_shuffled_samples", "[", ":", "n_paths_taking_inp", "]", "]", "\n", "shuffled_lbls_predicted_part_of_samples", "=", "sublists_with_shuffled_samples", "[", "n_paths_taking_inp", "]", "\n", "\n", "return", "(", "shuffled_channs_of_samples_per_path", ",", "shuffled_lbls_predicted_part_of_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.extractSegmentGivenSliceCoords": [[698, 762], ["range", "range", "numpy.copy", "len", "cnn3d.pathways[].subs_factor", "channs_of_sample_per_path.append", "len", "sampling.get_subsampl_segment", "channs_of_sample_per_path.append", "numpy.array", "cnn3d.pathways[].pType", "cnn3d.pathways[].subs_factor", "range", "range", "range", "range", "cnn3d.pathways[].pType", "cnn3d.pathways[].pType", "range", "cnn3d.pathways[].rec_field"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_subsampl_segment", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["", "def", "extractSegmentGivenSliceCoords", "(", "train_val_or_test", ",", "\n", "cnn3d", ",", "\n", "coord_center", ",", "\n", "channels", ",", "\n", "gt_lbl_img", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ")", ":", "\n", "# channels: numpy array [ n_channels, x, y, z ]", "\n", "# coord_center: indeces of the central voxel for the patch to be extracted.", "\n", "\n", "    ", "channs_of_sample_per_path", "=", "[", "]", "\n", "# Sampling", "\n", "for", "path_idx", "in", "range", "(", "len", "(", "cnn3d", ".", "pathways", "[", ":", "1", "]", ")", ")", ":", "# Hack. The rest of this loop can work for the whole .pathways...", "\n", "# ... BUT the loop does not check what happens if boundaries are out of limits, to fill with zeros.", "\n", "# This is done in get_subsampl_segment().", "\n", "# ... Update it in a nice way to be done here, and then take get_subsampl_segment()", "\n", "# out and make loop go for every pathway.", "\n", "\n", "        ", "if", "cnn3d", ".", "pathways", "[", "path_idx", "]", ".", "pType", "(", ")", "==", "pt", ".", "FC", ":", "\n", "            ", "continue", "\n", "", "subs_factor", "=", "cnn3d", ".", "pathways", "[", "path_idx", "]", ".", "subs_factor", "(", ")", "\n", "pathwayInputShapeRcz", "=", "inp_shapes_per_path", "[", "path_idx", "]", "\n", "leftBoundaryRcz", "=", "[", "coord_center", "[", "d", "]", "-", "subs_factor", "[", "d", "]", "*", "(", "pathwayInputShapeRcz", "[", "d", "]", "-", "1", ")", "//", "2", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "rightBoundaryRcz", "=", "[", "leftBoundaryRcz", "[", "d", "]", "+", "subs_factor", "[", "d", "]", "*", "pathwayInputShapeRcz", "[", "d", "]", "-", "1", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n", "channelsForThisImagePart", "=", "channels", "[", ":", ",", "\n", "leftBoundaryRcz", "[", "0", "]", ":", "rightBoundaryRcz", "[", "0", "]", "+", "1", ":", "subs_factor", "[", "0", "]", ",", "\n", "leftBoundaryRcz", "[", "1", "]", ":", "rightBoundaryRcz", "[", "1", "]", "+", "1", ":", "subs_factor", "[", "1", "]", ",", "\n", "leftBoundaryRcz", "[", "2", "]", ":", "rightBoundaryRcz", "[", "2", "]", "+", "1", ":", "subs_factor", "[", "2", "]", "]", "\n", "\n", "channs_of_sample_per_path", ".", "append", "(", "channelsForThisImagePart", ")", "\n", "\n", "# Extract the samples for secondary pathways. This whole for can go away,", "\n", "# if I update above code to check to slices out of limits.", "\n", "", "for", "pathway_i", "in", "range", "(", "len", "(", "cnn3d", ".", "pathways", ")", ")", ":", "# Except Normal 1st, cause that was done already.", "\n", "        ", "if", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "pType", "(", ")", "==", "pt", ".", "FC", "or", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "pType", "(", ")", "==", "pt", ".", "NORM", ":", "\n", "            ", "continue", "\n", "# this datastructure is similar to channelsForThisImagePart, but contains voxels from the subsampled image.", "\n", "", "segment_hr_dims", "=", "inp_shapes_per_path", "[", "pathway_i", "]", "\n", "\n", "slicesCoordsOfSegmForPrimaryPathway", "=", "[", "[", "leftBoundaryRcz", "[", "d", "]", ",", "rightBoundaryRcz", "[", "d", "]", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "channsForThisSubsampledPartAndPathway", "=", "get_subsampl_segment", "(", "cnn3d", ".", "pathways", "[", "0", "]", ".", "rec_field", "(", ")", "[", "0", "]", ",", "\n", "channels", ",", "\n", "slicesCoordsOfSegmForPrimaryPathway", ",", "\n", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "subs_factor", "(", ")", ",", "\n", "inp_shapes_per_path", "[", "pathway_i", "]", ")", "\n", "\n", "channs_of_sample_per_path", ".", "append", "(", "channsForThisSubsampledPartAndPathway", ")", "\n", "\n", "# Get ground truth labels for training.", "\n", "", "numOfCentralVoxelsClassifRcz", "=", "outp_pred_dims", "\n", "leftBoundaryRcz", "=", "[", "coord_center", "[", "d", "]", "-", "(", "numOfCentralVoxelsClassifRcz", "[", "d", "]", "-", "1", ")", "//", "2", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "rightBoundaryRcz", "=", "[", "leftBoundaryRcz", "[", "d", "]", "+", "numOfCentralVoxelsClassifRcz", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "lbls_predicted_part_of_sample", "=", "gt_lbl_img", "[", "leftBoundaryRcz", "[", "0", "]", ":", "rightBoundaryRcz", "[", "0", "]", ",", "\n", "leftBoundaryRcz", "[", "1", "]", ":", "rightBoundaryRcz", "[", "1", "]", ",", "\n", "leftBoundaryRcz", "[", "2", "]", ":", "rightBoundaryRcz", "[", "2", "]", "]", "\n", "\n", "# Make COPIES of the segments, instead of having a VIEW (slice) of them.", "\n", "# This is so that the the whole volume are afterwards released from RAM.", "\n", "channs_of_sample_per_path", "=", "[", "np", ".", "array", "(", "pathw_channs", ",", "copy", "=", "True", ",", "dtype", "=", "'float32'", ")", "for", "pathw_channs", "in", "channs_of_sample_per_path", "]", "\n", "lbls_predicted_part_of_sample", "=", "np", ".", "copy", "(", "lbls_predicted_part_of_sample", ")", "\n", "\n", "return", "channs_of_sample_per_path", ",", "lbls_predicted_part_of_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_slice_coords_of_all_img_tiles": [[774, 838], ["log.print3", "len", "range", "log.print3", "min", "sliceCoordsOfSegmentsToReturn.append", "min", "min", "isinstance", "sliceCoordsOfSegmentsToReturn.append", "numpy.any"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "get_slice_coords_of_all_img_tiles", "(", "log", ",", "\n", "segment_hr_dims", ",", "# xyz dims of input to primary pathway (normal)", "\n", "strideOfSegmentsPerDimInVoxels", ",", "\n", "batch_size", ",", "\n", "inp_chan_dims", ",", "\n", "roi_mask", "\n", ")", ":", "\n", "# inp_chan_dims: Dimensions of the (padded) input channels. [x, y, z]", "\n", "    ", "log", ".", "print3", "(", "\"Starting to (tile) extract Segments from the images of the subject for Segmentation...\"", ")", "\n", "\n", "sliceCoordsOfSegmentsToReturn", "=", "[", "]", "\n", "\n", "zLowBoundaryNext", "=", "0", "\n", "zAxisCentralPartPredicted", "=", "False", "\n", "while", "not", "zAxisCentralPartPredicted", ":", "\n", "        ", "zFarBoundary", "=", "min", "(", "zLowBoundaryNext", "+", "segment_hr_dims", "[", "2", "]", ",", "inp_chan_dims", "[", "2", "]", ")", "# Excluding.", "\n", "zLowBoundary", "=", "zFarBoundary", "-", "segment_hr_dims", "[", "2", "]", "\n", "zLowBoundaryNext", "=", "zLowBoundaryNext", "+", "strideOfSegmentsPerDimInVoxels", "[", "2", "]", "\n", "zAxisCentralPartPredicted", "=", "False", "if", "zFarBoundary", "<", "inp_chan_dims", "[", "2", "]", "else", "True", "# IMPORTANT CRITERION", "\n", "\n", "cLowBoundaryNext", "=", "0", "\n", "cAxisCentralPartPredicted", "=", "False", "\n", "while", "not", "cAxisCentralPartPredicted", ":", "\n", "            ", "cFarBoundary", "=", "min", "(", "cLowBoundaryNext", "+", "segment_hr_dims", "[", "1", "]", ",", "inp_chan_dims", "[", "1", "]", ")", "# Excluding.", "\n", "cLowBoundary", "=", "cFarBoundary", "-", "segment_hr_dims", "[", "1", "]", "\n", "cLowBoundaryNext", "=", "cLowBoundaryNext", "+", "strideOfSegmentsPerDimInVoxels", "[", "1", "]", "\n", "cAxisCentralPartPredicted", "=", "False", "if", "cFarBoundary", "<", "inp_chan_dims", "[", "1", "]", "else", "True", "\n", "\n", "rLowBoundaryNext", "=", "0", "\n", "rAxisCentralPartPredicted", "=", "False", "\n", "while", "not", "rAxisCentralPartPredicted", ":", "\n", "                ", "rFarBoundary", "=", "min", "(", "rLowBoundaryNext", "+", "segment_hr_dims", "[", "0", "]", ",", "inp_chan_dims", "[", "0", "]", ")", "# Excluding.", "\n", "rLowBoundary", "=", "rFarBoundary", "-", "segment_hr_dims", "[", "0", "]", "\n", "rLowBoundaryNext", "=", "rLowBoundaryNext", "+", "strideOfSegmentsPerDimInVoxels", "[", "0", "]", "\n", "rAxisCentralPartPredicted", "=", "False", "if", "rFarBoundary", "<", "inp_chan_dims", "[", "0", "]", "else", "True", "\n", "\n", "# In case I pass a brain-mask, I ll use it to only predict inside it. Otherwise, whole image.", "\n", "if", "isinstance", "(", "roi_mask", ",", "np", ".", "ndarray", ")", ":", "\n", "                    ", "if", "not", "np", ".", "any", "(", "roi_mask", "[", "rLowBoundary", ":", "rFarBoundary", ",", "\n", "cLowBoundary", ":", "cFarBoundary", ",", "\n", "zLowBoundary", ":", "zFarBoundary", "]", "\n", ")", ":", "# all of it is out of the brain so skip it.", "\n", "                        ", "continue", "\n", "\n", "", "", "sliceCoordsOfSegmentsToReturn", ".", "append", "(", "[", "[", "rLowBoundary", ",", "rFarBoundary", "-", "1", "]", ",", "\n", "[", "cLowBoundary", ",", "cFarBoundary", "-", "1", "]", ",", "\n", "[", "zLowBoundary", ",", "zFarBoundary", "-", "1", "]", "]", ")", "\n", "\n", "# I need to have a total number of image-parts that can be exactly-divided by the 'batch_size'.", "\n", "# For this reason, I add in the far end of the list multiple copies of the last element.", "\n", "", "", "", "total_number_of_image_parts", "=", "len", "(", "sliceCoordsOfSegmentsToReturn", ")", "\n", "number_of_imageParts_missing_for_exact_division", "=", "batch_size", "-", "total_number_of_image_parts", "%", "batch_size", "if", "total_number_of_image_parts", "%", "batch_size", "!=", "0", "else", "0", "\n", "for", "extra_useless_image_part_i", "in", "range", "(", "number_of_imageParts_missing_for_exact_division", ")", ":", "\n", "        ", "sliceCoordsOfSegmentsToReturn", ".", "append", "(", "sliceCoordsOfSegmentsToReturn", "[", "-", "1", "]", ")", "\n", "\n", "# I think that since the parts are acquired in a certain order and are sorted this way in the list, it is easy", "\n", "# to know which part of the image they came from, as it depends only on the stride-size and the imagePart size.", "\n", "\n", "", "log", ".", "print3", "(", "\"Finished (tiling) extracting Segments from the images of the subject for Segmentation.\"", ")", "\n", "\n", "# sliceCoordsOfSegmentsToReturn: list with 3 dimensions. numberOfSegments x 3(rcz) x 2", "\n", "# (lower and upper limit of the segment, INCLUSIVE both sides)", "\n", "return", "sliceCoordsOfSegmentsToReturn", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.extractSegmentsGivenSliceCoords": [[842, 885], ["len", "range", "channsForSegmentsPerPathToReturn[].append", "range", "range", "len", "sampling.get_subsampl_segment", "channsForSegmentsPerPathToReturn[].append", "cnn3d.getNumPathwaysThatRequireInput", "cnn3d.pathways[].subs_factor", "cnn3d.pathways[].pType", "cnn3d.pathways[].pType", "cnn3d.pathways[].rec_field"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.get_subsampl_segment", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["", "def", "extractSegmentsGivenSliceCoords", "(", "cnn3d", ",", "\n", "sliceCoordsOfSegmentsToExtract", ",", "\n", "channelsOfImageNpArray", ",", "\n", "inp_shapes_per_path", ",", "\n", "outp_pred_dims", ")", ":", "\n", "# sliceCoordsOfSegmentsToExtract: list of length num_segments. Each elem: [[r_low, r_high], [c_l, c_h], [z_l, z_h]]", "\n", "# channelsOfImageNpArray: numpy array [ n_channels, x, y, z ]", "\n", "# Returns: list with length [num_pathways], where each element is a list of length [num_segments],", "\n", "#          of arrays [channels, r, c, z]", "\n", "# TODO: Change result to a list of arrays [num_segments, channs, r, c, z]", "\n", "\n", "    ", "numberOfSegmentsToExtract", "=", "len", "(", "sliceCoordsOfSegmentsToExtract", ")", "\n", "channsForSegmentsPerPathToReturn", "=", "[", "[", "]", "for", "i", "in", "range", "(", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", ")", "]", "\n", "\n", "for", "segment_i", "in", "range", "(", "numberOfSegmentsToExtract", ")", ":", "\n", "        ", "rLowBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "0", "]", "[", "0", "]", "\n", "rFarBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "0", "]", "[", "1", "]", "\n", "cLowBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "1", "]", "[", "0", "]", "\n", "cFarBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "1", "]", "[", "1", "]", "\n", "zLowBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "2", "]", "[", "0", "]", "\n", "zFarBoundary", "=", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", "[", "2", "]", "[", "1", "]", "\n", "# segment for primary pathway", "\n", "channsForPrimaryPathForThisSegm", "=", "channelsOfImageNpArray", "[", ":", ",", "\n", "rLowBoundary", ":", "rFarBoundary", "+", "1", ",", "\n", "cLowBoundary", ":", "cFarBoundary", "+", "1", ",", "\n", "zLowBoundary", ":", "zFarBoundary", "+", "1", "\n", "]", "\n", "channsForSegmentsPerPathToReturn", "[", "0", "]", ".", "append", "(", "channsForPrimaryPathForThisSegm", ")", "\n", "\n", "# Subsampled pathways", "\n", "for", "pathway_i", "in", "range", "(", "len", "(", "cnn3d", ".", "pathways", ")", ")", ":", "# Except Normal 1st, cause that was done already.", "\n", "            ", "if", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "pType", "(", ")", "==", "pt", ".", "FC", "or", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "pType", "(", ")", "==", "pt", ".", "NORM", ":", "\n", "                ", "continue", "\n", "\n", "", "channsForThisSubsPathForThisSegm", "=", "get_subsampl_segment", "(", "cnn3d", ".", "pathways", "[", "0", "]", ".", "rec_field", "(", ")", "[", "0", "]", ",", "\n", "channelsOfImageNpArray", ",", "\n", "sliceCoordsOfSegmentsToExtract", "[", "segment_i", "]", ",", "\n", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ".", "subs_factor", "(", ")", ",", "\n", "inp_shapes_per_path", "[", "pathway_i", "]", ")", "\n", "\n", "channsForSegmentsPerPathToReturn", "[", "pathway_i", "]", ".", "append", "(", "channsForThisSubsPathForThisSegm", ")", "\n", "\n", "", "", "return", "channsForSegmentsPerPathToReturn", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.dataManagement.sampling.check_gt_vs_num_classes": [[891, 903], ["numpy.max", "numpy.max", "log.print3", "ValueError", "str", "str"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "check_gt_vs_num_classes", "(", "log", ",", "job_id", ",", "img_gt", ",", "num_classes", ")", ":", "\n", "    ", "if", "img_gt", "is", "None", ":", "# If manual labels are not provided. E.g. in testing.", "\n", "        ", "return", "\n", "\n", "", "max_in_gt", "=", "np", ".", "max", "(", "img_gt", ")", "\n", "if", "np", ".", "max", "(", "img_gt", ")", ">", "num_classes", "-", "1", ":", "# num_classes includes background=0", "\n", "        ", "msg", "=", "job_id", "+", "\" ERROR:\\t GT labels include value [\"", "+", "str", "(", "max_in_gt", ")", "+", "\"] greater than what CNN expects.\"", "+", "\"\\n\\t In model-config the number of classes was specified as [\"", "+", "str", "(", "num_classes", ")", "+", "\"].\"", "+", "\"\\n\\t Check your data or change the number of classes in model-config.\"", "+", "\"\\n\\t Note: number of classes in model config should include the background as a class.\"", "\n", "log", ".", "print3", "(", "msg", ")", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.PathwayWrapperForSampling.__init__": [[15, 19], ["pathwayInstance.pType", "pathwayInstance.subs_factor", "pathwayInstance.rec_field"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["    ", "def", "__init__", "(", "self", ",", "pathwayInstance", ")", ":", "\n", "        ", "self", ".", "_pType", "=", "pathwayInstance", ".", "pType", "(", ")", "\n", "self", ".", "_subs_factor", "=", "pathwayInstance", ".", "subs_factor", "(", ")", "\n", "self", ".", "_rec_field", "=", "pathwayInstance", ".", "rec_field", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.PathwayWrapperForSampling.pType": [[20, 22], ["None"], "methods", ["None"], ["", "def", "pType", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_pType", "\n", "", "def", "subs_factor", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.PathwayWrapperForSampling.subs_factor": [[22, 24], ["None"], "methods", ["None"], ["", "def", "subs_factor", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_subs_factor", "\n", "", "def", "rec_field", "(", "self", ")", ":", "# Used by sampling of low-res context (old version) during training.", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.PathwayWrapperForSampling.rec_field": [[24, 26], ["None"], "methods", ["None"], ["", "def", "rec_field", "(", "self", ")", ":", "# Used by sampling of low-res context (old version) during training.", "\n", "        ", "return", "self", ".", "_rec_field", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.CnnWrapperForSampling.__init__": [[30, 40], ["cnn3d.getNumPathwaysThatRequireInput", "range", "len", "wrappers.CnnWrapperForSampling.pathways.append", "wrappers.PathwayWrapperForSampling"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput"], ["    ", "def", "__init__", "(", "self", ",", "cnn3d", ")", ":", "\n", "# Cnn", "\n", "        ", "self", ".", "num_classes", "=", "cnn3d", ".", "num_classes", "\n", "# Pathways related", "\n", "self", ".", "_numPathwaysThatRequireInput", "=", "cnn3d", ".", "getNumPathwaysThatRequireInput", "(", ")", "\n", "self", ".", "numSubsPaths", "=", "cnn3d", ".", "numSubsPaths", "\n", "\n", "self", ".", "pathways", "=", "[", "]", "\n", "for", "pathway_i", "in", "range", "(", "len", "(", "cnn3d", ".", "pathways", ")", ")", ":", "\n", "            ", "self", ".", "pathways", ".", "append", "(", "PathwayWrapperForSampling", "(", "cnn3d", ".", "pathways", "[", "pathway_i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.wrappers.CnnWrapperForSampling.getNumPathwaysThatRequireInput": [[41, 43], ["None"], "methods", ["None"], ["", "", "def", "getNumPathwaysThatRequireInput", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_numPathwaysThatRequireInput", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.__init__": [[28, 47], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "cnnModelName", "=", "None", "\n", "\n", "self", ".", "pathways", "=", "[", "]", "# There should be only 1 normal and only one FC pathway. Eg, see self.getFcPathway()", "\n", "self", ".", "numSubsPaths", "=", "0", "\n", "\n", "self", ".", "finalTargetLayer", "=", "\"\"", "\n", "\n", "self", ".", "num_classes", "=", "None", "\n", "\n", "#======= Output tensors Y_GT ========", "\n", "# For each targetLayer, I should be placing a y_gt placeholder/feed.", "\n", "self", ".", "_output_gt_tensor_feeds", "=", "{", "'train'", ":", "{", "}", ",", "\n", "'val'", ":", "{", "}", "}", "\n", "\n", "######## These entries are setup in the setup_train/val/test functions here ############", "\n", "self", ".", "_ops_main", "=", "{", "'train'", ":", "{", "}", ",", "'val'", ":", "{", "}", ",", "'test'", ":", "{", "}", "}", "\n", "self", ".", "_feeds_main", "=", "{", "'train'", ":", "{", "}", ",", "'val'", ":", "{", "}", ",", "'test'", ":", "{", "}", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumSubsPathways": [[49, 55], ["pathway.pType"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType"], ["", "def", "getNumSubsPathways", "(", "self", ")", ":", "\n", "        ", "count", "=", "0", "\n", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "if", "pathway", ".", "pType", "(", ")", "==", "pt", ".", "SUBS", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getNumPathwaysThatRequireInput": [[56, 62], ["pathway.pType"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType"], ["", "def", "getNumPathwaysThatRequireInput", "(", "self", ")", ":", "\n", "        ", "count", "=", "0", "\n", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "if", "pathway", ".", "pType", "(", ")", "!=", "pt", ".", "FC", ":", "\n", "                ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getFcPathway": [[63, 68], ["pathway.pType"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType"], ["", "def", "getFcPathway", "(", "self", ")", ":", "\n", "        ", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "if", "pathway", ".", "pType", "(", ")", "==", "pt", ".", "FC", ":", "\n", "                ", "return", "pathway", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.update_arrays_of_bn_moving_avg": [[74, 78], ["pathway.get_blocks", "block.update_arrays_of_bn_moving_avg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.update_arrays_of_bn_moving_avg"], ["", "def", "update_arrays_of_bn_moving_avg", "(", "self", ",", "sessionTf", ")", ":", "\n", "        ", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "for", "block", "in", "pathway", ".", "get_blocks", "(", ")", ":", "\n", "                ", "block", ".", "update_arrays_of_bn_moving_avg", "(", "sessionTf", ")", "# Will do nothing if no BN.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d._get_update_ops_for_bn_moving_avg": [[79, 87], ["pathway.get_blocks", "updatesForBnRollingAverage.extend", "block.get_update_ops_for_bn_moving_avg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.get_update_ops_for_bn_moving_avg"], ["", "", "", "def", "_get_update_ops_for_bn_moving_avg", "(", "self", ")", ":", "\n", "# These are not the variables of the normalization of the FMs' distributions that are optimized during training. These are only the Mu and Stds that are used during inference,", "\n", "# ... and here we update the sharedVariable which is used \"from the outside during do_training()\" to update the rolling-average-matrix for inference. Do for all layers.", "\n", "        ", "updatesForBnRollingAverage", "=", "[", "]", "\n", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "for", "block", "in", "pathway", ".", "get_blocks", "(", ")", ":", "\n", "                ", "updatesForBnRollingAverage", ".", "extend", "(", "block", ".", "get_update_ops_for_bn_moving_avg", "(", ")", ")", "\n", "", "", "return", "updatesForBnRollingAverage", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_trainable_params": [[88, 98], ["range", "len", "pathway.get_blocks", "log.print3", "pathway.get_block().trainable_params", "pathway.pType", "pathway.get_block", "str", "str", "pathway.getStringType"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_block", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.getStringType"], ["", "def", "get_trainable_params", "(", "self", ",", "log", ",", "indicesOfLayersPerPathwayTypeToFreeze", ")", ":", "\n", "# Called from Trainer.", "\n", "        ", "paramsToOptDuringTraining", "=", "[", "]", "# Ws and Bs", "\n", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "for", "block_i", "in", "range", "(", "len", "(", "pathway", ".", "get_blocks", "(", ")", ")", ")", ":", "\n", "                ", "if", "block_i", "not", "in", "indicesOfLayersPerPathwayTypeToFreeze", "[", "pathway", ".", "pType", "(", ")", "]", ":", "\n", "                    ", "paramsToOptDuringTraining", "=", "paramsToOptDuringTraining", "+", "pathway", ".", "get_block", "(", "block_i", ")", ".", "trainable_params", "(", ")", "\n", "", "else", ":", "# Layer will be held fixed. Notice that Batch Norm parameters are still learnt.", "\n", "                    ", "log", ".", "print3", "(", "\"WARN: [Pathway_\"", "+", "str", "(", "pathway", ".", "getStringType", "(", ")", ")", "+", "\"] The weights of [Layer-\"", "+", "str", "(", "block_i", ")", "+", "\"] will NOT be trained as specified (index, first layer is 0).\"", ")", "\n", "", "", "", "return", "paramsToOptDuringTraining", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.params_for_L1_L2_reg": [[99, 105], ["pathway.get_blocks", "block.params_for_L1_L2_reg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg"], ["", "def", "params_for_L1_L2_reg", "(", "self", ")", ":", "\n", "        ", "total_params", "=", "[", "]", "\n", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "            ", "for", "block", "in", "pathway", ".", "get_blocks", "(", ")", ":", "\n", "                ", "total_params", "+=", "block", ".", "params_for_L1_L2_reg", "(", ")", "\n", "", "", "return", "total_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_ops": [[106, 109], ["None"], "methods", ["None"], ["", "def", "get_main_ops", "(", "self", ",", "str_train_val_test", ")", ":", "\n", "# str_train_val_test: \"train\", \"val\" or \"test\"", "\n", "        ", "return", "self", ".", "_ops_main", "[", "str_train_val_test", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_main_feeds": [[110, 112], ["None"], "methods", ["None"], ["", "def", "get_main_feeds", "(", "self", ",", "str_train_val_test", ")", ":", "\n", "        ", "return", "self", ".", "_feeds_main", "[", "str_train_val_test", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_train": [[114, 136], ["log.print3", "tensorflow.group", "log.print3", "cnn3d.Cnn3d.finalTargetLayer.get_rp_rn_tp_tn", "range", "log.print3", "cnn3d.Cnn3d._get_update_ops_for_bn_moving_avg", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.get_rp_rn_tp_tn", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d._get_update_ops_for_bn_moving_avg"], ["", "def", "setup_ops_n_feeds_to_train", "(", "self", ",", "log", ",", "inp_plchldrs", ",", "p_y_given_x", ",", "total_cost", ",", "updates_of_params_wrt_total_cost", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"...Building the training function...\"", ")", "\n", "\n", "y_gt", "=", "self", ".", "_output_gt_tensor_feeds", "[", "'train'", "]", "[", "'y_gt'", "]", "\n", "\n", "#================BATCH NORMALIZATION ROLLING AVERAGE UPDATES======================", "\n", "updates", "=", "updates_of_params_wrt_total_cost", "+", "self", ".", "_get_update_ops_for_bn_moving_avg", "(", ")", "\n", "updates_grouped_op", "=", "tf", ".", "group", "(", "*", "updates", ")", "# this op returns no output when run.", "\n", "\n", "#======================== Collecting ops and feeds =================", "\n", "log", ".", "print3", "(", "\"...Collecting ops and feeds for training...\"", ")", "\n", "\n", "self", ".", "_ops_main", "[", "'train'", "]", "[", "'cost'", "]", "=", "total_cost", "\n", "self", ".", "_ops_main", "[", "'train'", "]", "[", "'list_rp_rn_tp_tn'", "]", "=", "self", ".", "finalTargetLayer", ".", "get_rp_rn_tp_tn", "(", "p_y_given_x", ",", "y_gt", ")", "\n", "self", ".", "_ops_main", "[", "'train'", "]", "[", "'updates_grouped_op'", "]", "=", "updates_grouped_op", "\n", "\n", "self", ".", "_feeds_main", "[", "'train'", "]", "[", "'x'", "]", "=", "inp_plchldrs", "[", "'x'", "]", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "# if there are subsampled paths...", "\n", "            ", "self", ".", "_feeds_main", "[", "'train'", "]", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "=", "inp_plchldrs", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "\n", "", "self", ".", "_feeds_main", "[", "'train'", "]", "[", "'y_gt'", "]", "=", "y_gt", "\n", "\n", "log", ".", "print3", "(", "\"Done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_val": [[137, 154], ["log.print3", "log.print3", "cnn3d.Cnn3d.finalTargetLayer.get_rp_rn_tp_tn", "range", "log.print3", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.get_rp_rn_tp_tn", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "setup_ops_n_feeds_to_val", "(", "self", ",", "log", ",", "inp_plchldrs", ",", "p_y_given_x", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"...Building the validation function...\"", ")", "\n", "\n", "y_gt", "=", "self", ".", "_output_gt_tensor_feeds", "[", "'val'", "]", "[", "'y_gt'", "]", "\n", "\n", "log", ".", "print3", "(", "\"...Collecting ops and feeds for validation...\"", ")", "\n", "\n", "self", ".", "_ops_main", "[", "'val'", "]", "=", "{", "}", "\n", "self", ".", "_ops_main", "[", "'val'", "]", "[", "'list_rp_rn_tp_tn'", "]", "=", "self", ".", "finalTargetLayer", ".", "get_rp_rn_tp_tn", "(", "p_y_given_x", ",", "y_gt", ")", "\n", "\n", "self", ".", "_feeds_main", "[", "'val'", "]", "=", "{", "}", "\n", "self", ".", "_feeds_main", "[", "'val'", "]", "[", "'x'", "]", "=", "inp_plchldrs", "[", "'x'", "]", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "# if there are subsampled paths...", "\n", "            ", "self", ".", "_feeds_main", "[", "'val'", "]", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "=", "inp_plchldrs", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "\n", "", "self", ".", "_feeds_main", "[", "'val'", "]", "[", "'y_gt'", "]", "=", "y_gt", "\n", "\n", "log", ".", "print3", "(", "\"Done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.setup_ops_n_feeds_to_test": [[156, 182], ["log.print3", "log.print3", "range", "log.print3", "pathway.get_blocks", "range", "pathway.pType", "len", "str", "str", "len", "listToReturnWithAllTheFmActivationsPerLayer.append", "blocks[].fm_activations"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.fm_activations"], ["", "def", "setup_ops_n_feeds_to_test", "(", "self", ",", "log", ",", "inp_plchldrs", ",", "p_y_given_x", ",", "indices_fms_per_pathtype_per_layer_to_save", "=", "None", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"...Building the function for testing and visualisation of FMs...\"", ")", "\n", "\n", "listToReturnWithAllTheFmActivationsPerLayer", "=", "[", "]", "\n", "if", "indices_fms_per_pathtype_per_layer_to_save", "is", "not", "None", ":", "\n", "            ", "for", "pathway", "in", "self", ".", "pathways", ":", "\n", "                ", "indicesOfFmsToVisualisePerLayerOfCertainPathway", "=", "indices_fms_per_pathtype_per_layer_to_save", "[", "pathway", ".", "pType", "(", ")", "]", "\n", "if", "indicesOfFmsToVisualisePerLayerOfCertainPathway", "!=", "[", "]", ":", "\n", "                    ", "blocks", "=", "pathway", ".", "get_blocks", "(", ")", "\n", "for", "block_i", "in", "range", "(", "len", "(", "blocks", ")", ")", ":", "# each layer that this pathway/fc has.", "\n", "                        ", "indicesOfFmsToExtractFromThisLayer", "=", "indicesOfFmsToVisualisePerLayerOfCertainPathway", "[", "block_i", "]", "\n", "if", "len", "(", "indicesOfFmsToExtractFromThisLayer", ")", ">", "0", ":", "#if no FMs are to be taken, this should be []", "\n", "                            ", "listToReturnWithAllTheFmActivationsPerLayer", ".", "append", "(", "blocks", "[", "block_i", "]", ".", "fm_activations", "(", "indicesOfFmsToExtractFromThisLayer", ")", ")", "\n", "\n", "", "", "", "", "", "log", ".", "print3", "(", "\"...Collecting ops and feeds for testing...\"", ")", "\n", "\n", "self", ".", "_ops_main", "[", "'test'", "]", "=", "{", "}", "\n", "self", ".", "_ops_main", "[", "'test'", "]", "[", "'list_of_fms_per_layer'", "]", "=", "listToReturnWithAllTheFmActivationsPerLayer", "\n", "self", ".", "_ops_main", "[", "'test'", "]", "[", "'pred_probs'", "]", "=", "p_y_given_x", "\n", "\n", "self", ".", "_feeds_main", "[", "'test'", "]", "=", "{", "}", "\n", "self", ".", "_feeds_main", "[", "'test'", "]", "[", "'x'", "]", "=", "inp_plchldrs", "[", "'x'", "]", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "# if there are subsampled paths...", "\n", "            ", "self", ".", "_feeds_main", "[", "'test'", "]", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "=", "inp_plchldrs", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "\n", "\n", "", "log", ".", "print3", "(", "\"Done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.create_inp_plchldrs": [[184, 187], ["cnn3d.Cnn3d.calc_inp_dims_of_paths_from_hr_inp", "cnn3d.Cnn3d._setup_inp_plchldrs"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_inp_dims_of_paths_from_hr_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d._setup_inp_plchldrs"], ["", "def", "create_inp_plchldrs", "(", "self", ",", "inp_dims", ",", "train_val_test", ")", ":", "# TODO: Remove for eager", "\n", "            ", "inp_shapes_per_path", "=", "self", ".", "calc_inp_dims_of_paths_from_hr_inp", "(", "inp_dims", ")", "\n", "return", "self", ".", "_setup_inp_plchldrs", "(", "train_val_test", ",", "inp_shapes_per_path", ")", ",", "inp_shapes_per_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d._setup_inp_plchldrs": [[188, 195], ["tensorflow.compat.v1.placeholder", "range", "tensorflow.compat.v1.placeholder", "cnn3d.Cnn3d.pathways[].get_n_fms_in", "str", "cnn3d.Cnn3d.pathways[].get_n_fms_in", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_in", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_in"], ["", "def", "_setup_inp_plchldrs", "(", "self", ",", "train_val_test", ",", "inp_shapes_per_path", ")", ":", "# TODO: REMOVE for eager", "\n", "        ", "assert", "train_val_test", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", "\n", "inp_plchldrs", "=", "{", "}", "\n", "inp_plchldrs", "[", "'x'", "]", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"float32\"", ",", "shape", "=", "[", "None", ",", "self", ".", "pathways", "[", "0", "]", ".", "get_n_fms_in", "(", ")", "]", "+", "inp_shapes_per_path", "[", "0", "]", ",", "name", "=", "'inp_x_'", "+", "train_val_test", ")", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "# if there are subsampled paths...", "\n", "            ", "inp_plchldrs", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"float32\"", ",", "shape", "=", "[", "None", ",", "self", ".", "pathways", "[", "0", "]", ".", "get_n_fms_in", "(", ")", "]", "+", "inp_shapes_per_path", "[", "subpath_i", "+", "1", "]", ",", "name", "=", "\"inp_x_sub_\"", "+", "str", "(", "subpath_i", ")", "+", "'_'", "+", "train_val_test", ")", "\n", "", "return", "inp_plchldrs", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.make_cnn_model": [[196, 358], ["len", "numpy.random.RandomState", "log.print3", "deepmedic.neuralnet.pathways.NormalPathway", "cnn3d.Cnn3d.pathways.append", "deepmedic.neuralnet.pathways.SubsampledPathway.pType", "len", "deepmedic.neuralnet.pathways.SubsampledPathway.build", "range", "range", "deepmedic.neuralnet.pathways.FcPathway", "cnn3d.Cnn3d.pathways.append", "deepmedic.neuralnet.pathways.SubsampledPathway.pType", "len", "deepmedic.neuralnet.pathways.SubsampledPathway.build", "log.print3", "deepmedic.neuralnet.blocks.SoftmaxBlock", "cnn3d.Cnn3d.finalTargetLayer.build", "cnn3d.Cnn3d.getFcPathway().get_block().connect_target_block", "tensorflow.compat.v1.placeholder", "tensorflow.compat.v1.placeholder", "log.print3", "deepmedic.neuralnet.pathways.SubsampledPathway", "cnn3d.Cnn3d.pathways.append", "deepmedic.neuralnet.pathways.SubsampledPathway.pType", "len", "deepmedic.neuralnet.pathways.SubsampledPathway.build", "len", "cnn3d.Cnn3d.pathways[].get_n_fms_out", "cnn3d.Cnn3d.getFcPathway().get_n_fms_out", "cnn3d.Cnn3d.getFcPathway().get_block", "cnn3d.Cnn3d.getFcPathway", "cnn3d.Cnn3d.getFcPathway"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.connect_target_block", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_out", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_out", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_block", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getFcPathway", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.getFcPathway"], ["", "def", "make_cnn_model", "(", "self", ",", "\n", "log", ",", "\n", "cnnModelName", ",", "\n", "#=== Model Parameters ===", "\n", "numberOfOutputClasses", ",", "\n", "n_img_channs", ",", "\n", "\n", "#=== Normal Pathway ===", "\n", "nkerns", ",", "\n", "kernelDimensions", ",", "\n", "pad_mode_per_l_norm", ",", "\n", "#=== Subsampled Pathway ===", "\n", "# THESE NEXT TWO, ALONG WITH THE ONES FOR FC, COULD BE PUT IN ONE STRUCTURE WITH NORMAL, EG LIKE kerns = [ [kernsNorm], [kernsSub], [kernsFc]]", "\n", "nkernsSubsampled", ",", "# Used to control if secondary pathways: [] if no secondary pathways. Now its the \"factors\"", "\n", "kernelDimensionsSubsampled", ",", "\n", "pad_mode_per_l_subs", ",", "\n", "subsampleFactorsPerSubPath", ",", "# Controls how many pathways: [] if no secondary pathways. Else, List of lists. One sublist per secondary pathway. Each sublist has 3 ints, the rcz subsampling factors.", "\n", "#=== FC Layers ===", "\n", "fcLayersFMs", ",", "\n", "kernelDimensionsFc", ",", "\n", "pad_mode_per_l_fc", ",", "\n", "softmaxTemperature", ",", "\n", "\n", "#=== Other Architectural params ===", "\n", "activationFunc", ",", "\n", "#---Residual Connections----", "\n", "indicesOfLayersToConnectResidualsInOutput", ",", "\n", "#--Lower Rank Layer Per Pathway---", "\n", "indicesOfLowerRankLayersPerPathway", ",", "\n", "ranksOfLowerRankLayersForEachPathway", ",", "\n", "#---Pooling---", "\n", "maxPoolingParamsStructure", ",", "\n", "\n", "#=== Others ===", "\n", "# Dropout", "\n", "dropoutRatesForAllPathways", ",", "# list of sublists, one for each pathway. Each either empty or full with the dropout rates of all the layers in the path.", "\n", "# Initialization", "\n", "convWInitMethod", ",", "\n", "# Batch Normalization", "\n", "applyBnToInputOfPathways", ",", "# one Boolean flag per pathway type. Placeholder for the FC pathway.", "\n", "movingAvForBnOverXBatches", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "cnnModelName", "=", "cnnModelName", "\n", "self", ".", "num_classes", "=", "numberOfOutputClasses", "\n", "self", ".", "numSubsPaths", "=", "len", "(", "subsampleFactorsPerSubPath", ")", "# do I want this as attribute? Or function is ok?", "\n", "#==============================", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "None", ")", "\n", "\n", "######################", "\n", "# BUILD ACTUAL MODEL #", "\n", "######################", "\n", "log", ".", "print3", "(", "\"...Building the CNN model...\"", ")", "\n", "\n", "#=======================Make the NORMAL PATHWAY of the CNN=======================", "\n", "thisPathway", "=", "NormalPathway", "(", ")", "\n", "self", ".", "pathways", ".", "append", "(", "thisPathway", ")", "\n", "thisPathwayType", "=", "thisPathway", ".", "pType", "(", ")", "\n", "thisPathWayNKerns", "=", "nkerns", "\n", "thisPathWayKernelDimensions", "=", "kernelDimensions", "\n", "thisPathwayNumOfLayers", "=", "len", "(", "thisPathWayNKerns", ")", "\n", "thisPathwayConvPadModePerLayer", "=", "pad_mode_per_l_norm", "\n", "thisPathwayUseBnPerLayer", "=", "[", "movingAvForBnOverXBatches", ">", "0", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayUseBnPerLayer", "[", "0", "]", "=", "applyBnToInputOfPathways", "[", "thisPathwayType", "]", "if", "movingAvForBnOverXBatches", ">", "0", "else", "False", "# For the 1st layer, ask specific flag.", "\n", "thisPathwayActivFuncPerLayer", "=", "[", "activationFunc", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayActivFuncPerLayer", "[", "0", "]", "=", "\"linear\"", "if", "thisPathwayType", "!=", "pt", ".", "FC", "else", "activationFunc", "# To not apply activation on raw input. -1 is linear activation.", "\n", "\n", "thisPathway", ".", "build", "(", "log", ",", "\n", "rng", ",", "\n", "n_img_channs", ",", "\n", "thisPathWayNKerns", ",", "\n", "thisPathWayKernelDimensions", ",", "\n", "convWInitMethod", ",", "\n", "thisPathwayConvPadModePerLayer", ",", "\n", "thisPathwayUseBnPerLayer", ",", "\n", "movingAvForBnOverXBatches", ",", "\n", "thisPathwayActivFuncPerLayer", ",", "\n", "dropoutRatesForAllPathways", "[", "thisPathwayType", "]", ",", "\n", "maxPoolingParamsStructure", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLowerRankLayersPerPathway", "[", "thisPathwayType", "]", ",", "\n", "ranksOfLowerRankLayersForEachPathway", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLayersToConnectResidualsInOutput", "[", "thisPathwayType", "]", "\n", ")", "\n", "\n", "#=======================Make the SUBSAMPLED PATHWAYs of the CNN=============================", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "\n", "            ", "thisPathway", "=", "SubsampledPathway", "(", "subsampleFactorsPerSubPath", "[", "subpath_i", "]", ")", "\n", "self", ".", "pathways", ".", "append", "(", "thisPathway", ")", "# There will be at least an entry as a secondary pathway. But it won't have any layers if it was not actually used.", "\n", "thisPathwayType", "=", "thisPathway", ".", "pType", "(", ")", "\n", "thisPathWayNKerns", "=", "nkernsSubsampled", "[", "subpath_i", "]", "\n", "thisPathWayKernelDimensions", "=", "kernelDimensionsSubsampled", "\n", "thisPathwayNumOfLayers", "=", "len", "(", "thisPathWayNKerns", ")", "\n", "thisPathwayConvPadModePerLayer", "=", "pad_mode_per_l_subs", "\n", "thisPathwayUseBnPerLayer", "=", "[", "movingAvForBnOverXBatches", ">", "0", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayUseBnPerLayer", "[", "0", "]", "=", "applyBnToInputOfPathways", "[", "thisPathwayType", "]", "if", "movingAvForBnOverXBatches", ">", "0", "else", "False", "# For the 1st layer, ask specific flag.", "\n", "thisPathwayActivFuncPerLayer", "=", "[", "activationFunc", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayActivFuncPerLayer", "[", "0", "]", "=", "\"linear\"", "if", "thisPathwayType", "!=", "pt", ".", "FC", "else", "activationFunc", "# To not apply activation on raw input. -1 is linear activation.", "\n", "\n", "thisPathway", ".", "build", "(", "log", ",", "\n", "rng", ",", "\n", "n_img_channs", ",", "\n", "thisPathWayNKerns", ",", "\n", "thisPathWayKernelDimensions", ",", "\n", "convWInitMethod", ",", "\n", "thisPathwayConvPadModePerLayer", ",", "\n", "thisPathwayUseBnPerLayer", ",", "\n", "movingAvForBnOverXBatches", ",", "\n", "thisPathwayActivFuncPerLayer", ",", "\n", "dropoutRatesForAllPathways", "[", "thisPathwayType", "]", ",", "\n", "maxPoolingParamsStructure", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLowerRankLayersPerPathway", "[", "thisPathwayType", "]", ",", "\n", "ranksOfLowerRankLayersForEachPathway", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLayersToConnectResidualsInOutput", "[", "thisPathwayType", "]", "\n", ")", "\n", "\n", "#====================================CONCATENATE the output of the 2 cnn-pathways=============================", "\n", "", "n_fms_inp_to_fc_path", "=", "0", "\n", "for", "path_i", "in", "range", "(", "len", "(", "self", ".", "pathways", ")", ")", ":", "\n", "            ", "n_fms_inp_to_fc_path", "+=", "self", ".", "pathways", "[", "path_i", "]", ".", "get_n_fms_out", "(", ")", "\n", "\n", "#======================= Make the Fully Connected Layers =======================", "\n", "", "thisPathway", "=", "FcPathway", "(", ")", "\n", "self", ".", "pathways", ".", "append", "(", "thisPathway", ")", "\n", "thisPathwayType", "=", "thisPathway", ".", "pType", "(", ")", "\n", "thisPathWayNKerns", "=", "fcLayersFMs", "+", "[", "self", ".", "num_classes", "]", "\n", "thisPathWayKernelDimensions", "=", "kernelDimensionsFc", "\n", "thisPathwayNumOfLayers", "=", "len", "(", "thisPathWayNKerns", ")", "\n", "thisPathwayConvPadModePerLayer", "=", "pad_mode_per_l_fc", "\n", "thisPathwayUseBnPerLayer", "=", "[", "movingAvForBnOverXBatches", ">", "0", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayUseBnPerLayer", "[", "0", "]", "=", "applyBnToInputOfPathways", "[", "thisPathwayType", "]", "if", "movingAvForBnOverXBatches", ">", "0", "else", "False", "# For the 1st layer, ask specific flag.", "\n", "thisPathwayActivFuncPerLayer", "=", "[", "activationFunc", "]", "*", "thisPathwayNumOfLayers", "\n", "thisPathwayActivFuncPerLayer", "[", "0", "]", "=", "\"linear\"", "if", "thisPathwayType", "!=", "pt", ".", "FC", "else", "activationFunc", "# To not apply activation on raw input. -1 is linear activation.", "\n", "\n", "thisPathway", ".", "build", "(", "log", ",", "\n", "rng", ",", "\n", "n_fms_inp_to_fc_path", ",", "\n", "thisPathWayNKerns", ",", "\n", "thisPathWayKernelDimensions", ",", "\n", "convWInitMethod", ",", "\n", "thisPathwayConvPadModePerLayer", ",", "\n", "thisPathwayUseBnPerLayer", ",", "\n", "movingAvForBnOverXBatches", ",", "\n", "thisPathwayActivFuncPerLayer", ",", "\n", "dropoutRatesForAllPathways", "[", "thisPathwayType", "]", ",", "\n", "maxPoolingParamsStructure", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLowerRankLayersPerPathway", "[", "thisPathwayType", "]", ",", "\n", "ranksOfLowerRankLayersForEachPathway", "[", "thisPathwayType", "]", ",", "\n", "indicesOfLayersToConnectResidualsInOutput", "[", "thisPathwayType", "]", "\n", ")", "\n", "\n", "# =========== Make the final Target Layer (softmax, regression, whatever) ==========", "\n", "log", ".", "print3", "(", "\"Adding the final Softmax layer...\"", ")", "\n", "\n", "self", ".", "finalTargetLayer", "=", "SoftmaxBlock", "(", ")", "\n", "self", ".", "finalTargetLayer", ".", "build", "(", "rng", ",", "self", ".", "getFcPathway", "(", ")", ".", "get_n_fms_out", "(", ")", ",", "softmaxTemperature", ")", "\n", "self", ".", "getFcPathway", "(", ")", ".", "get_block", "(", "-", "1", ")", ".", "connect_target_block", "(", "self", ".", "finalTargetLayer", ")", "\n", "\n", "# =============== BUILDING FINISHED - BELOW IS TEMPORARY ========================    ", "\n", "self", ".", "_output_gt_tensor_feeds", "[", "'train'", "]", "[", "'y_gt'", "]", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"int32\"", ",", "shape", "=", "[", "None", ",", "None", ",", "None", ",", "None", "]", ",", "name", "=", "\"y_train\"", ")", "\n", "self", ".", "_output_gt_tensor_feeds", "[", "'val'", "]", "[", "'y_gt'", "]", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"int32\"", ",", "shape", "=", "[", "None", ",", "None", ",", "None", ",", "None", "]", ",", "name", "=", "\"y_val\"", ")", "\n", "\n", "log", ".", "print3", "(", "\"Finished building the CNN's model.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.apply": [[360, 387], ["cnn3d.Cnn3d.pathways[].apply", "range", "tensorflow.concat", "cnn3d.Cnn3d.pathways[].apply", "cnn3d.Cnn3d.finalTargetLayer.apply", "this_pathway.apply", "this_pathway.upsample_to_high_res", "fms_from_paths_to_concat.append", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.upsample_to_high_res"], ["", "def", "apply", "(", "self", ",", "inputs_per_pathw", ",", "mode", ",", "train_val_test", ",", "verbose", "=", "True", ",", "log", "=", "None", ")", ":", "\n", "# Currently applies it on the placeholders. TODO: On actual input.", "\n", "# train_val_test: TEMPORARY. ONLY TO RETURN FMS. REMOVE IN END OF REFACTORING.", "\n", "#assert len(inputs_per_pathw) == len(self.pathways) - 1", "\n", "\n", "#===== Apply High-Res path =========", "\n", "        ", "input", "=", "inputs_per_pathw", "[", "'x'", "]", "\n", "out", "=", "self", ".", "pathways", "[", "0", "]", ".", "apply", "(", "input", ",", "mode", ",", "train_val_test", ",", "verbose", ",", "log", ")", "\n", "dims_outp_pathway_hr", "=", "out", ".", "shape", "\n", "fms_from_paths_to_concat", "=", "[", "out", "]", "\n", "\n", "# === Subsampled pathways =========", "\n", "for", "subpath_i", "in", "range", "(", "self", ".", "numSubsPaths", ")", ":", "\n", "            ", "input", "=", "inputs_per_pathw", "[", "'x_sub_'", "+", "str", "(", "subpath_i", ")", "]", "\n", "this_pathway", "=", "self", ".", "pathways", "[", "subpath_i", "+", "1", "]", "\n", "out_lr", "=", "this_pathway", ".", "apply", "(", "input", ",", "mode", ",", "train_val_test", ",", "verbose", ",", "log", ")", "\n", "# this creates essentially the \"upsampling layer\"", "\n", "out", "=", "this_pathway", ".", "upsample_to_high_res", "(", "out_lr", ",", "shape_to_match", "=", "dims_outp_pathway_hr", ",", "upsampl_type", "=", "\"repeat\"", ")", "\n", "fms_from_paths_to_concat", ".", "append", "(", "out", ")", "\n", "\n", "# ===== Concatenate and final convs ========", "\n", "", "conc_inp_fms", "=", "tf", ".", "concat", "(", "fms_from_paths_to_concat", ",", "axis", "=", "1", ")", "\n", "logits_no_bias", "=", "self", ".", "pathways", "[", "-", "1", "]", ".", "apply", "(", "conc_inp_fms", ",", "mode", ",", "train_val_test", ",", "verbose", ",", "log", ")", "\n", "# Softmax", "\n", "p_y_given_x", "=", "self", ".", "finalTargetLayer", ".", "apply", "(", "logits_no_bias", ",", "mode", ")", "\n", "\n", "return", "p_y_given_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_inp_dims_of_paths_from_hr_inp": [[388, 407], ["cnn3d.Cnn3d.pathways[].calc_outp_dims_given_inp", "range", "len", "cnn3d.Cnn3d.pathways[].pType", "inp_shape_per_path.append", "cnn3d.Cnn3d.pathways[].pType", "cnn3d.Cnn3d.pathways[].calc_inp_dims_given_outp_after_upsample", "inp_shape_per_path.append", "cnn3d.Cnn3d.pathways[].pType", "inp_shape_per_path.append", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.calc_inp_dims_given_outp_after_upsample", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType"], ["", "def", "calc_inp_dims_of_paths_from_hr_inp", "(", "self", ",", "inp_hr_dims", ")", ":", "\n", "        ", "out_shape_of_hr_path", "=", "self", ".", "pathways", "[", "0", "]", ".", "calc_outp_dims_given_inp", "(", "inp_hr_dims", ")", "\n", "inp_shape_per_path", "=", "[", "]", "\n", "for", "path_idx", "in", "range", "(", "len", "(", "self", ".", "pathways", ")", ")", ":", "\n", "            ", "if", "self", ".", "pathways", "[", "path_idx", "]", ".", "pType", "(", ")", "==", "pt", ".", "NORM", ":", "\n", "                ", "inp_shape_per_path", ".", "append", "(", "inp_hr_dims", ")", "\n", "", "elif", "self", ".", "pathways", "[", "path_idx", "]", ".", "pType", "(", ")", "!=", "pt", ".", "FC", ":", "# it's a low-res pathway.", "\n", "                ", "inp_shape_lr", "=", "self", ".", "pathways", "[", "path_idx", "]", ".", "calc_inp_dims_given_outp_after_upsample", "(", "out_shape_of_hr_path", ")", "\n", "inp_shape_per_path", ".", "append", "(", "inp_shape_lr", ")", "\n", "", "elif", "self", ".", "pathways", "[", "path_idx", "]", ".", "pType", "(", ")", "==", "pt", ".", "FC", ":", "\n", "                ", "inp_shape_per_path", ".", "append", "(", "out_shape_of_hr_path", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "# [ [path0-in-dim-x, path0-in-dim-y, path0-in-dim-z],", "\n", "#   [path1-in-dim-x, path1-in-dim-y, path1-in-dim-z],", "\n", "#    ...", "\n", "#   [pathFc-in-dim-x, pathFc-in-dim-y, pathFc-in-dim-z] ]", "\n", "", "", "return", "inp_shape_per_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d._calc_receptive_field_cnn_wrt_hr_inp": [[408, 412], ["cnn3d.Cnn3d.pathways[].rec_field", "cnn3d.Cnn3d.pathways[].rec_field"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["", "def", "_calc_receptive_field_cnn_wrt_hr_inp", "(", "self", ")", ":", "\n", "        ", "rec_field_hr_path", ",", "strides_rf_at_end_of_hr_path", "=", "self", ".", "pathways", "[", "0", "]", ".", "rec_field", "(", ")", "\n", "cnn_rf", ",", "_", "=", "self", ".", "pathways", "[", "-", "1", "]", ".", "rec_field", "(", "rec_field_hr_path", ",", "strides_rf_at_end_of_hr_path", ")", "\n", "return", "cnn_rf", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_outp_dims_given_inp": [[413, 416], ["cnn3d.Cnn3d.pathways[].calc_outp_dims_given_inp", "cnn3d.Cnn3d.pathways[].calc_outp_dims_given_inp"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims_hr_path", ")", ":", "\n", "        ", "outp_dims_hr_path", "=", "self", ".", "pathways", "[", "0", "]", ".", "calc_outp_dims_given_inp", "(", "inp_dims_hr_path", ")", "\n", "return", "self", ".", "pathways", "[", "-", "1", "]", ".", "calc_outp_dims_given_inp", "(", "outp_dims_hr_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.calc_unpredicted_margin": [[417, 423], ["cnn3d.Cnn3d.calc_outp_dims_given_inp", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp"], ["", "def", "calc_unpredicted_margin", "(", "self", ",", "inp_dims_hr_path", ")", ":", "\n", "# unpred_margin: [[before-x, after-x], [before-y, after-y], [before-z, after-z]]", "\n", "        ", "outp_dims", "=", "self", ".", "calc_outp_dims_given_inp", "(", "inp_dims_hr_path", ")", "\n", "n_unpred_vox", "=", "[", "inp_dims_hr_path", "[", "d", "]", "-", "outp_dims", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "unpred_margin", "=", "[", "[", "n_unpred_vox", "[", "d", "]", "//", "2", ",", "n_unpred_vox", "[", "d", "]", "-", "n_unpred_vox", "[", "d", "]", "//", "2", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "return", "unpred_margin", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.conv_3d": [[27, 52], ["tensorflow.transpose", "tensorflow.transpose", "tensorflow.nn.conv3d", "tensorflow.transpose", "ops.pad_by_mirroring", "range"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.pad_by_mirroring"], ["", "def", "conv_3d", "(", "input", ",", "w", ",", "padding", "=", "\"VALID\"", ")", ":", "\n", "# input weight matrix W has shape: [ #ChannelsOut, #ChannelsIn, R, C, Z ]", "\n", "# Input signal given in shape [BatchSize, Channels, R, C, Z]", "\n", "# padding: 'VALID', 'SAME' or 'MIRROR'", "\n", "# Tensorflow's Conv3d requires filter shape: [ D/Z, H/C, W/R, C_in, C_out ] #ChannelsOut, #ChannelsIn, Z, R, C ]", "\n", "    ", "if", "padding", "in", "[", "'MIRROR'", ",", "'mirror'", "]", ":", "# If mirror, do it here and perform conv as if not pad ('SAME')", "\n", "        ", "input", "=", "pad_by_mirroring", "(", "input", ",", "n_vox_pad_per_dim", "=", "[", "w", ".", "shape", "[", "2", "+", "d", "]", "-", "1", "for", "d", "in", "range", "(", "3", ")", "]", ")", "\n", "padding", "=", "'VALID'", "\n", "", "elif", "padding", "in", "[", "'ZERO'", ",", "'zero'", "]", ":", "\n", "        ", "padding", "=", "'SAME'", "\n", "", "elif", "padding", "is", "None", "or", "padding", "in", "[", "'none'", ",", "'VALID'", ",", "'valid'", "]", ":", "\n", "        ", "padding", "=", "'VALID'", "\n", "\n", "", "w_resh", "=", "tf", ".", "transpose", "(", "w", ",", "perm", "=", "[", "4", ",", "3", ",", "2", ",", "1", ",", "0", "]", ")", "\n", "# Conv3d requires signal in shape: [BatchSize, Channels, Z, R, C]", "\n", "input_resh", "=", "tf", ".", "transpose", "(", "input", ",", "perm", "=", "[", "0", ",", "4", ",", "3", ",", "2", ",", "1", "]", ")", "\n", "output", "=", "tf", ".", "nn", ".", "conv3d", "(", "input", "=", "input_resh", ",", "# batch_size, time, num_of_input_channels, rows, columns", "\n", "filters", "=", "w_resh", ",", "# TF: Depth, Height, Wight, Chans_in, Chans_out", "\n", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "padding", "=", "padding", ",", "\n", "data_format", "=", "\"NDHWC\"", "\n", ")", "\n", "#Output is in the shape of the input image (signals_shape).", "\n", "output", "=", "tf", ".", "transpose", "(", "output", ",", "perm", "=", "[", "0", ",", "4", ",", "3", ",", "2", ",", "1", "]", ")", "#reshape the result, back to the shape of the input image.", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.relu": [[53, 56], ["tensorflow.maximum"], "function", ["None"], ["", "def", "relu", "(", "input", ")", ":", "\n", "#input is a tensor of shape (batchSize, FMs, r, c, z)", "\n", "    ", "return", "tf", ".", "maximum", "(", "0.", ",", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.prelu": [[57, 62], ["tensorflow.maximum", "abs"], "function", ["None"], ["", "def", "prelu", "(", "input", ",", "a", ")", ":", "\n", "# a = tensor of floats, [1, n_channels, 1, 1, 1]", "\n", "    ", "pos", "=", "tf", ".", "maximum", "(", "0.", ",", "input", ")", "\n", "neg", "=", "a", "*", "(", "input", "-", "abs", "(", "input", ")", ")", "*", "0.5", "\n", "return", "pos", "+", "neg", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.elu": [[63, 66], ["tensorflow.nn.elu"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.elu"], ["", "def", "elu", "(", "input", ")", ":", "\n", "#input is a tensor of shape (batchSize, FMs, r, c, z)", "\n", "    ", "return", "tf", ".", "nn", ".", "elu", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.selu": [[67, 73], ["NotImplementedError", "tensorflow.nn.elu"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.elu"], ["", "def", "selu", "(", "input", ")", ":", "\n", "#input is a tensor of shape (batchSize, FMs, r, c, z)", "\n", "    ", "lambda01", "=", "1.0507", "# calc in p4 of paper.", "\n", "alpha01", "=", "1.6733", "# WHERE IS THIS USED? I AM DOING SOMETHING WRONG I THINK.", "\n", "raise", "NotImplementedError", "(", ")", "\n", "return", "lambda01", "*", "tf", ".", "nn", ".", "elu", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.pool_3d": [[75, 97], ["tensorflow.transpose", "tensorflow.nn.pool", "tensorflow.transpose", "ops.pad_by_mirroring", "range"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.pad_by_mirroring"], ["", "def", "pool_3d", "(", "input", ",", "window_size", ",", "strides", ",", "pad_mode", ",", "pool_mode", ")", ":", "\n", "# input dimensions: (batch, fms, r, c, z)", "\n", "# poolParams: [[dsr,dsc,dsz], [strr,strc,strz], [mirrorPad-r,-c,-z], mode]", "\n", "# pool_mode: 'MAX' or 'AVG'", "\n", "    ", "if", "pad_mode", "in", "[", "'MIRROR'", ",", "'mirror'", "]", ":", "\n", "        ", "input", "=", "pad_by_mirroring", "(", "input", ",", "n_vox_pad_per_dim", "=", "[", "window_size", ".", "shape", "[", "2", "+", "d", "]", "-", "1", "for", "d", "in", "range", "(", "3", ")", "]", ")", "\n", "pad_mode", "=", "'VALID'", "\n", "", "elif", "padding", "in", "[", "'ZERO'", ",", "'zero'", "]", ":", "\n", "        ", "padding", "=", "'SAME'", "\n", "", "elif", "padding", "is", "None", "or", "padding", "in", "[", "'none'", "]", ":", "\n", "        ", "padding", "=", "'VALID'", "\n", "\n", "", "inp_resh", "=", "tf", ".", "transpose", "(", "input", ",", "perm", "=", "[", "0", ",", "4", ",", "3", ",", "2", ",", "1", "]", ")", "# Channels last.", "\n", "pooled_out", "=", "tf", ".", "nn", ".", "pool", "(", "input", "=", "inp_resh", ",", "\n", "window_shape", "=", "window_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "pad_mode", ",", "# SAME or VALID", "\n", "pooling_type", "=", "pool_mode", ",", "\n", "data_format", "=", "\"NDHWC\"", ")", "# AVG or MAX", "\n", "pooled_out", "=", "tf", ".", "transpose", "(", "pooled_out", ",", "perm", "=", "[", "0", ",", "4", ",", "3", ",", "2", ",", "1", "]", ")", "\n", "\n", "return", "pooled_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.crop_center": [[99, 118], ["tensorflow.shape"], "function", ["None"], ["", "def", "crop_center", "(", "fms", ",", "listOfNumberOfCentralVoxelsToGetPerDimension", ")", ":", "\n", "# fms: a 5D tensor, [batch, fms, r, c, z]", "\n", "# listOfNumberOfCentralVoxelsToGetPerDimension: list of 3 scalars or Tensorflow 1D tensor (eg from tf.shape(x)). [r, c, z]", "\n", "# NOTE: Because of the indexing in the end, the shape returned is commonyl (None, Fms, None, None, None). Should be reshape to preserve shape.", "\n", "    ", "fmsShape", "=", "tf", ".", "shape", "(", "fms", ")", "#fms.shape works too.", "\n", "# if part is of even width, one voxel to the left is the centre.", "\n", "rCentreOfPartIndex", "=", "(", "fmsShape", "[", "2", "]", "-", "1", ")", "//", "2", "\n", "rIndexToStartGettingCentralVoxels", "=", "rCentreOfPartIndex", "-", "(", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "0", "]", "-", "1", ")", "//", "2", "\n", "rIndexToStopGettingCentralVoxels", "=", "rIndexToStartGettingCentralVoxels", "+", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "0", "]", "# Excluding", "\n", "cCentreOfPartIndex", "=", "(", "fmsShape", "[", "3", "]", "-", "1", ")", "//", "2", "\n", "cIndexToStartGettingCentralVoxels", "=", "cCentreOfPartIndex", "-", "(", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "1", "]", "-", "1", ")", "//", "2", "\n", "cIndexToStopGettingCentralVoxels", "=", "cIndexToStartGettingCentralVoxels", "+", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "1", "]", "# Excluding", "\n", "zCentreOfPartIndex", "=", "(", "fmsShape", "[", "4", "]", "-", "1", ")", "//", "2", "\n", "zIndexToStartGettingCentralVoxels", "=", "zCentreOfPartIndex", "-", "(", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "2", "]", "-", "1", ")", "//", "2", "\n", "zIndexToStopGettingCentralVoxels", "=", "zIndexToStartGettingCentralVoxels", "+", "listOfNumberOfCentralVoxelsToGetPerDimension", "[", "2", "]", "# Excluding", "\n", "return", "fms", "[", ":", ",", ":", ",", "\n", "rIndexToStartGettingCentralVoxels", ":", "rIndexToStopGettingCentralVoxels", ",", "\n", "cIndexToStartGettingCentralVoxels", ":", "cIndexToStopGettingCentralVoxels", ",", "\n", "zIndexToStartGettingCentralVoxels", ":", "zIndexToStopGettingCentralVoxels", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.crop_to_match_dims": [[120, 128], ["None"], "function", ["None"], ["", "def", "crop_to_match_dims", "(", "input", ",", "dims_to_match", ")", ":", "\n", "# dims_to_match : [ batch size, num of fms, r, c, z] ", "\n", "    ", "output", "=", "input", "[", ":", ",", "\n", ":", ",", "\n", ":", "dims_to_match", "[", "2", "]", ",", "\n", ":", "dims_to_match", "[", "3", "]", ",", "\n", ":", "dims_to_match", "[", "4", "]", "]", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.make_residual_connection": [[130, 152], ["tensorflow.shape", "tensorflow.shape", "ops.crop_center", "tensorflow.reshape", "tensorflow.zeros", "tensor_2.get_shape", "tensor_1.get_shape", "tensorflow.concat"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.crop_center"], ["", "def", "make_residual_connection", "(", "tensor_1", ",", "tensor_2", ")", ":", "\n", "# tensor_1: earlier tensor", "\n", "# tensor_2: deeper tensor", "\n", "# Add the outputs of the two layers and return the output, as well as its dimensions.", "\n", "# tensor_2 & tensor_1: 5D tensors [batchsize, chans, x, y, z], outputs of deepest and earliest layer of the Res.Conn.", "\n", "# Result: Shape of result should be exactly the same as the output of Deeper layer.", "\n", "    ", "tens_1_shape", "=", "tf", ".", "shape", "(", "tensor_1", ")", "\n", "tens_2_shape", "=", "tf", ".", "shape", "(", "tensor_2", ")", "\n", "# Get part of the earlier layer that is of the same dimensions as the FMs of the deeper:", "\n", "tens_1_center_crop", "=", "crop_center", "(", "tensor_1", ",", "tens_2_shape", "[", "2", ":", "]", ")", "\n", "# Add the FMs, after taking care of zero padding if the deeper layer has more FMs.", "\n", "if", "tensor_2", ".", "get_shape", "(", ")", "[", "1", "]", ">=", "tensor_1", ".", "get_shape", "(", ")", "[", "1", "]", ":", "# ifs not allowed via tensor (from tf.shape(...))", "\n", "        ", "blank_channels", "=", "tf", ".", "zeros", "(", "shape", "=", "[", "tens_2_shape", "[", "0", "]", ",", "\n", "tens_2_shape", "[", "1", "]", "-", "tens_1_shape", "[", "1", "]", ",", "\n", "tens_2_shape", "[", "2", "]", ",", "tens_2_shape", "[", "3", "]", ",", "tens_2_shape", "[", "4", "]", "]", ",", "dtype", "=", "\"float32\"", ")", "\n", "res_out", "=", "tensor_2", "+", "tf", ".", "concat", "(", "[", "tens_1_center_crop", ",", "blank_channels", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "else", ":", "# Deeper FMs are fewer than earlier. This should not happen in most architectures. But oh well...", "\n", "        ", "res_out", "=", "tensor_2", "+", "tens_1_center_crop", "[", ":", ",", ":", "tens_2_shape", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "# The following reshape is to enforce the 4 dimensions to be \"visible\" to TF (cause the indexing in crop_center makes them dynamic/None)", "\n", "", "res_out", "=", "tf", ".", "reshape", "(", "res_out", ",", "shape", "=", "[", "-", "1", ",", "res_out", ".", "shape", "[", "1", "]", ",", "tensor_2", ".", "shape", "[", "2", "]", ",", "tensor_2", ".", "shape", "[", "3", "]", ",", "tensor_2", ".", "shape", "[", "4", "]", "]", ")", "\n", "return", "res_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.upsample_by_repeat": [[154, 176], ["tensorflow.shape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.reshape", "tensorflow.shape", "tensorflow.reshape", "input.get_shape", "tensorflow.tile", "tensorflow.tile", "tensorflow.tile", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape"], "function", ["None"], ["", "def", "upsample_by_repeat", "(", "input", ",", "up_factors", ")", ":", "\n", "# input: [batch size, num of FMs, r, c, z]. Ala input/output of conv layers.", "\n", "# Repeat FM in the three last dimensions, to upsample back to the normal resolution space.", "\n", "# In numpy below: (but tf has no repeat, only tile, so, implementation is funny.", "\n", "# up_factors: list of upsampling factors per (3d) dimension. [up-x, up-y, up-z]", "\n", "    ", "res", "=", "input", "\n", "res_shape", "=", "tf", ".", "shape", "(", "input", ")", "# Dynamic. For batch and r,c,z dimensions. (unknown prior to runtime)", "\n", "n_fms", "=", "input", ".", "get_shape", "(", ")", "[", "1", "]", "# Static via get_shape(). Known. For reshape to return tensor with *known* shape[1].", "\n", "# If tf.shape()[1] is used, reshape changes res.get_shape()[1] to (?).", "\n", "\n", "res", "=", "tf", ".", "reshape", "(", "tf", ".", "tile", "(", "tf", ".", "reshape", "(", "res", ",", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "res_shape", "[", "1", "]", "*", "res_shape", "[", "2", "]", ",", "1", ",", "res_shape", "[", "3", "]", ",", "res_shape", "[", "4", "]", "]", ")", ",", "\n", "multiples", "=", "[", "1", ",", "1", ",", "up_factors", "[", "0", "]", ",", "1", ",", "1", "]", ")", ",", "\n", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "n_fms", ",", "res_shape", "[", "2", "]", "*", "up_factors", "[", "0", "]", ",", "res_shape", "[", "3", "]", ",", "res_shape", "[", "4", "]", "]", ")", "\n", "res_shape", "=", "tf", ".", "shape", "(", "res", ")", "\n", "res", "=", "tf", ".", "reshape", "(", "tf", ".", "tile", "(", "tf", ".", "reshape", "(", "res", ",", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "res_shape", "[", "1", "]", ",", "res_shape", "[", "2", "]", "*", "res_shape", "[", "3", "]", ",", "1", ",", "res_shape", "[", "4", "]", "]", ")", ",", "\n", "multiples", "=", "[", "1", ",", "1", ",", "1", ",", "up_factors", "[", "1", "]", ",", "1", "]", ")", ",", "\n", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "n_fms", ",", "res_shape", "[", "2", "]", ",", "res_shape", "[", "3", "]", "*", "up_factors", "[", "1", "]", ",", "res_shape", "[", "4", "]", "]", ")", "\n", "res_shape", "=", "tf", ".", "shape", "(", "res", ")", "\n", "res", "=", "tf", ".", "reshape", "(", "tf", ".", "tile", "(", "tf", ".", "reshape", "(", "res", ",", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "res_shape", "[", "1", "]", ",", "res_shape", "[", "2", "]", ",", "res_shape", "[", "3", "]", "*", "res_shape", "[", "4", "]", ",", "1", "]", ")", ",", "\n", "multiples", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "up_factors", "[", "2", "]", "]", ")", ",", "\n", "shape", "=", "[", "res_shape", "[", "0", "]", ",", "n_fms", ",", "res_shape", "[", "2", "]", ",", "res_shape", "[", "3", "]", ",", "res_shape", "[", "4", "]", "*", "up_factors", "[", "2", "]", "]", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.upsample_5D_tens_and_crop": [[177, 193], ["ops.upsample_by_repeat", "print", "exit", "ops.crop_to_match_dims"], "function", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.upsample_by_repeat", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.crop_to_match_dims"], ["", "def", "upsample_5D_tens_and_crop", "(", "input", ",", "up_factors", ",", "upsampl_type", "=", "\"repeat\"", ",", "dims_to_match", "=", "None", ")", ":", "\n", "# input: [batch_size, numberOfFms, r, c, z].", "\n", "# up_factors: list of upsampling factors per (3d) dimension. [up-x, up-y, up-z]", "\n", "    ", "if", "upsampl_type", "==", "\"repeat\"", ":", "\n", "        ", "out_hr", "=", "upsample_by_repeat", "(", "input", ",", "up_factors", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"ERROR: in upsample_5D_tens_and_crop(...). Not implemented type of upsampling! Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n", "\n", "", "if", "dims_to_match", "is", "not", "None", ":", "\n", "# If the central-voxels are eg 10, the susampled-part will have 4 central voxels. Which above will be repeated to 3*4 = 12.", "\n", "# I need to clip the last ones, to have the same dimension as the input from 1st pathway, which will have dimensions equal to the centrally predicted voxels (10)", "\n", "        ", "out_hr_crop", "=", "crop_to_match_dims", "(", "out_hr", ",", "dims_to_match", ")", "\n", "", "else", ":", "\n", "        ", "out_hr_crop", "=", "out_hr", "\n", "\n", "", "return", "out_hr_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.pad_by_mirroring": [[195, 215], ["int", "int", "int", "int", "int", "int", "numpy.all", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "tensorflow.concat", "int", "int"], "function", ["None"], ["", "def", "pad_by_mirroring", "(", "input", ",", "n_vox_pad_per_dim", ")", ":", "\n", "# input shape: [batchSize, #channels#, r, c, z]", "\n", "# inputImageDimensions : [ batchSize, #channels, dim r, dim c, dim z ] of input", "\n", "# n_vox_pad_per_dim shape: [ num o voxels in r-dim to add, ...c-dim, ...z-dim ]", "\n", "# If n_vox_pad_per_dim is odd, 1 more voxel is added to the right side.", "\n", "# r-axis", "\n", "    ", "assert", "np", ".", "all", "(", "n_vox_pad_per_dim", ")", ">=", "0", "\n", "padLeft", "=", "int", "(", "n_vox_pad_per_dim", "[", "0", "]", "//", "2", ")", ";", "padRight", "=", "int", "(", "(", "n_vox_pad_per_dim", "[", "0", "]", "+", "1", ")", "//", "2", ")", ";", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "input", "[", ":", ",", ":", ",", "int", "(", "n_vox_pad_per_dim", "[", "0", "]", "//", "2", ")", "-", "1", ":", ":", "-", "1", ",", ":", ",", ":", "]", ",", "input", "]", ",", "axis", "=", "2", ")", "if", "padLeft", ">", "0", "else", "input", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "paddedImage", ",", "paddedImage", "[", ":", ",", ":", ",", "-", "1", ":", "-", "1", "-", "int", "(", "(", "n_vox_pad_per_dim", "[", "0", "]", "+", "1", ")", "//", "2", ")", ":", "-", "1", ",", ":", ",", ":", "]", "]", ",", "axis", "=", "2", ")", "if", "padRight", ">", "0", "else", "paddedImage", "\n", "# c-axis", "\n", "padLeft", "=", "int", "(", "n_vox_pad_per_dim", "[", "1", "]", "//", "2", ")", ";", "padRight", "=", "int", "(", "(", "n_vox_pad_per_dim", "[", "1", "]", "+", "1", ")", "//", "2", ")", ";", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "paddedImage", "[", ":", ",", ":", ",", ":", ",", "padLeft", "-", "1", ":", ":", "-", "1", ",", ":", "]", ",", "paddedImage", "]", ",", "axis", "=", "3", ")", "if", "padLeft", ">", "0", "else", "paddedImage", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "paddedImage", ",", "paddedImage", "[", ":", ",", ":", ",", ":", ",", "-", "1", ":", "-", "1", "-", "padRight", ":", "-", "1", ",", ":", "]", "]", ",", "axis", "=", "3", ")", "if", "padRight", ">", "0", "else", "paddedImage", "\n", "# z-axis", "\n", "padLeft", "=", "int", "(", "n_vox_pad_per_dim", "[", "2", "]", "//", "2", ")", ";", "padRight", "=", "int", "(", "(", "n_vox_pad_per_dim", "[", "2", "]", "+", "1", ")", "//", "2", ")", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "paddedImage", "[", ":", ",", ":", ",", ":", ",", ":", ",", "padLeft", "-", "1", ":", ":", "-", "1", "]", ",", "paddedImage", "]", ",", "axis", "=", "4", ")", "if", "padLeft", ">", "0", "else", "paddedImage", "\n", "paddedImage", "=", "tf", ".", "concat", "(", "[", "paddedImage", ",", "paddedImage", "[", ":", ",", ":", ",", ":", ",", ":", ",", "-", "1", ":", "-", "1", "-", "padRight", ":", "-", "1", "]", "]", ",", "axis", "=", "4", ")", "if", "padRight", ">", "0", "else", "paddedImage", "\n", "\n", "return", "paddedImage", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.__init__": [[29, 95], ["log.print3", "tensorflow.Variable", "tensorflow.compat.v1.placeholder", "tensorflow.compat.v1.placeholder", "tensorflow.compat.v1.assign"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["    ", "def", "__init__", "(", "self", ",", "\n", "log", ",", "\n", "indicesOfLayersPerPathwayTypeToFreeze", ",", "\n", "losses_and_weights", ",", "\n", "L1_reg_weight", ",", "\n", "L2_reg_weight", ",", "\n", "# Cost schedules", "\n", "reweight_classes_in_cost", ",", "\n", "network_to_train", ")", ":", "\n", "\n", "        ", "log", ".", "print3", "(", "\"Building Trainer.\"", ")", "\n", "\n", "self", ".", "_net", "=", "network_to_train", "# Used to grab trainable parameter, and most of all, to formulate the costs in set_costs.", "\n", "self", ".", "_indicesOfLayersPerPathwayTypeToFreeze", "=", "indicesOfLayersPerPathwayTypeToFreeze", "# Layers to train (eg for pretrained models.", "\n", "# Regularisation", "\n", "self", ".", "_L1_reg_weight", "=", "L1_reg_weight", "\n", "self", ".", "_L2_reg_weight", "=", "L2_reg_weight", "\n", "# Costs", "\n", "self", ".", "_losses_and_weights", "=", "losses_and_weights", "# \"L\", \"D\" or \"J\"", "\n", "self", ".", "_total_cost", "=", "None", "# This is set-up by calling self.setup_costs(...)", "\n", "# Params for costs", "\n", "self", ".", "_reweight_classes_in_cost", "=", "reweight_classes_in_cost", "\n", "\n", "\n", "################# OPTIMIZER AND SCHEDULES ###############", "\n", "\n", "######### training state ##########", "\n", "self", ".", "_num_epochs_trained_tfv", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "\"int64\"", ",", "trainable", "=", "False", ",", "name", "=", "\"num_epochs_trained\"", ")", "# int32 tf.vars cannot be (explicitly) loaded to gpu.", "\n", "# State Ops", "\n", "# TODO: All the ops should be constructed and kept into one place (eg dict), and then can be easily called from outside...", "\n", "# ... INSTEAD of called a public function such as set_lr or change_lr.", "\n", "self", ".", "_tf_plchld_float32", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"float32\"", ",", "name", "=", "\"tf_plchld_float32\"", ")", "# convenience feed for tf.assign", "\n", "self", ".", "_tf_plchld_int32", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"int32\"", ",", "name", "=", "\"tf_plchld_int32\"", ")", "# convenience feed for tf.assign", "\n", "self", ".", "_op_increase_num_epochs_trained", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_num_epochs_trained_tfv", ",", "self", ".", "_num_epochs_trained_tfv", "+", "1", ")", "\n", "\n", "\n", "########### Optimizer ###########", "\n", "# Optimizers", "\n", "self", ".", "_optimizer", "=", "None", "# Trainer could be coordinating multiple optimizers, over multiple costs?", "\n", "\n", "######## LR schedule specific ######", "\n", "# These are separated from the above, \"Trainer\" section, for future further modularization...", "\n", "# ... in case I decice it is wiser to have one trainer, coordinating multiple optimizers, with one LR schedule each.", "\n", "# I could also have one trainer per optimizer, and one trainer-manager.", "\n", "# In that case, the above \"Trainer\" section could be moved to the \"trainer-manager\" class.", "\n", "self", ".", "_lr_sched_params", "=", "None", "# To control if schedule-specific API is available (eg auto)", "\n", "self", ".", "_curr_lr", "=", "None", "# Tensor (or tfv if auto). Used for printing.", "\n", "self", ".", "_curr_mom", "=", "None", "# Tensor. Used for printing.", "\n", "# State", "\n", "self", ".", "_init_lr_tfv", "=", "None", "# used by exponential schedule", "\n", "# Mom is only for SGD/RmsProp", "\n", "self", ".", "_init_mom_tfv", "=", "None", "# used by exponential schedule", "\n", "\n", "# ====== [Auto] - learning rate schedule ====", "\n", "# These should only be defined if auto-schedule is chosen.", "\n", "# State", "\n", "self", ".", "_learning_rate_tfv", "=", "None", "# tf.var", "\n", "self", ".", "_momentum_tfv", "=", "None", "\n", "self", ".", "_top_mean_val_acc_tfv", "=", "None", "\n", "self", ".", "_epoch_with_top_mean_val_acc_tvf", "=", "None", "\n", "self", ".", "_last_epoch_lr_got_lowered_tvf", "=", "None", "\n", "self", ".", "_op_assign_new_lr", "=", "None", "\n", "self", ".", "_op_assign_new_mom", "=", "None", "\n", "self", ".", "_op_assign_top_mean_val_acc_tfv", "=", "None", "\n", "self", ".", "_op_assign_epoch_with_top_mean_val_acc_tvf", "=", "None", "\n", "self", ".", "_op_assign_last_epoch_lr_lowered", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.compute_costs": [[98, 123], ["log.print3", "exit", "log.print3", "trainer.Trainer._compute_w_per_class_vector_for_xentr", "log.print3", "log.print3", "deepmedic.cost_L1", "deepmedic.cost_L1", "deepmedic.cost_L2", "deepmedic.cost_L2", "deepmedic.x_entr", "deepmedic.x_entr", "deepmedic.iou", "deepmedic.iou", "deepmedic.dsc", "deepmedic.dsc", "trainer.Trainer._net.params_for_L1_L2_reg", "trainer.Trainer._net.params_for_L1_L2_reg", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._compute_w_per_class_vector_for_xentr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L1", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L2", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L2", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.x_entr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.x_entr", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.iou", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.iou", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.dsc", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.dsc", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg"], ["", "def", "compute_costs", "(", "self", ",", "log", ",", "p_y_given_x", ")", ":", "# Needs to be run with initialized self._num_epochs_trained_tfv", "\n", "        ", "if", "not", "self", ".", "_total_cost", "is", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"ERROR: Problem in Trainer. It was called to setup the total cost, but it was not None.\"", "+", "\"\\n\\t This should not happen. Setup should be called only once.\\n Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "# Cost functions", "\n", "", "cost", "=", "0", "\n", "y_gt", "=", "self", ".", "_net", ".", "_output_gt_tensor_feeds", "[", "'train'", "]", "[", "'y_gt'", "]", "\n", "if", "\"xentr\"", "in", "self", ".", "_losses_and_weights", "and", "self", ".", "_losses_and_weights", "[", "\"xentr\"", "]", "is", "not", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"COST: Using cross entropy with weight: \"", "+", "str", "(", "self", ".", "_losses_and_weights", "[", "\"xentr\"", "]", ")", ")", "\n", "w_per_cl_vec", "=", "self", ".", "_compute_w_per_class_vector_for_xentr", "(", "self", ".", "_net", ".", "num_classes", ",", "y_gt", ")", "\n", "cost", "+=", "self", ".", "_losses_and_weights", "[", "\"xentr\"", "]", "*", "cfs", ".", "x_entr", "(", "p_y_given_x", ",", "y_gt", ",", "w_per_cl_vec", ")", "\n", "", "if", "\"iou\"", "in", "self", ".", "_losses_and_weights", "and", "self", ".", "_losses_and_weights", "[", "\"iou\"", "]", "is", "not", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"COST: Using iou loss with weight: \"", "+", "str", "(", "self", ".", "_losses_and_weights", "[", "\"iou\"", "]", ")", ")", "\n", "cost", "+=", "self", ".", "_losses_and_weights", "[", "\"iou\"", "]", "*", "cfs", ".", "iou", "(", "p_y_given_x", ",", "y_gt", ")", "\n", "", "if", "\"dsc\"", "in", "self", ".", "_losses_and_weights", "and", "self", ".", "_losses_and_weights", "[", "\"dsc\"", "]", "is", "not", "None", ":", "\n", "            ", "log", ".", "print3", "(", "\"COST: Using dsc loss with weight: \"", "+", "str", "(", "self", ".", "_losses_and_weights", "[", "\"dsc\"", "]", ")", ")", "\n", "cost", "+=", "self", ".", "_losses_and_weights", "[", "\"dsc\"", "]", "*", "cfs", ".", "dsc", "(", "p_y_given_x", ",", "y_gt", ")", "\n", "\n", "", "cost_L1_reg", "=", "self", ".", "_L1_reg_weight", "*", "cfs", ".", "cost_L1", "(", "self", ".", "_net", ".", "params_for_L1_L2_reg", "(", ")", ")", "\n", "cost_L2_reg", "=", "self", ".", "_L2_reg_weight", "*", "cfs", ".", "cost_L2", "(", "self", ".", "_net", ".", "params_for_L1_L2_reg", "(", ")", ")", "\n", "cost", "=", "cost", "+", "cost_L1_reg", "+", "cost_L2_reg", "\n", "\n", "self", ".", "_total_cost", "=", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.create_optimizer": [[126, 174], ["log.print3", "tensorflow.Variable", "trainer.Trainer._get_lr_from_schedule", "tensorflow.Variable", "trainer.Trainer._get_mom_from_schedule", "trainer.Trainer._net.get_trainable_params", "deepmedic.SgdOptimizer", "deepmedic.SgdOptimizer", "deepmedic.AdamOptimizer", "deepmedic.AdamOptimizer", "deepmedic.RmsPropOptimizer", "deepmedic.RmsPropOptimizer"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._get_lr_from_schedule", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._get_mom_from_schedule", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cnn3d.Cnn3d.get_trainable_params"], ["", "def", "create_optimizer", "(", "self", ",", "\n", "log", ",", "\n", "sgd0orAdam1orRmsProp2", ",", "\n", "lr_sched_params", ",", "# Could be given to init and saved there.", "\n", "learning_rate_init", ",", "\n", "momentum_init", ",", "\n", "classicMomentum0OrNesterov1", ",", "\n", "momentumTypeNONNormalized0orNormalized1", ",", "\n", "b1ParamForAdam", ",", "\n", "b2ParamForAdam", ",", "\n", "epsilonForAdam", ",", "\n", "rhoParamForRmsProp", ",", "\n", "epsilonForRmsProp", "\n", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"...Initializing state of the optimizer...\"", ")", "\n", "\n", "self", ".", "_lr_sched_params", "=", "lr_sched_params", "\n", "\n", "# Learning rate and momentum", "\n", "self", ".", "_init_lr_tfv", "=", "tf", ".", "Variable", "(", "learning_rate_init", ",", "dtype", "=", "\"float32\"", ",", "trainable", "=", "False", ",", "name", "=", "\"init_lr\"", ")", "# This is important for the learning rate schedule to work.", "\n", "self", ".", "_curr_lr", "=", "self", ".", "_get_lr_from_schedule", "(", ")", "\n", "\n", "# SGD and RMS only.", "\n", "self", ".", "_init_mom_tfv", "=", "tf", ".", "Variable", "(", "momentum_init", ",", "dtype", "=", "\"float32\"", ",", "trainable", "=", "False", ",", "name", "=", "\"init_mom\"", ")", "\n", "self", ".", "_curr_mom", "=", "self", ".", "_get_mom_from_schedule", "(", ")", "\n", "\n", "# Optimizer", "\n", "params_to_opt", "=", "self", ".", "_net", ".", "get_trainable_params", "(", "log", ",", "self", ".", "_indicesOfLayersPerPathwayTypeToFreeze", ")", "\n", "if", "sgd0orAdam1orRmsProp2", "==", "0", ":", "\n", "            ", "self", ".", "_optimizer", "=", "optimizers_dm", ".", "SgdOptimizer", "(", "params_to_opt", ",", "\n", "self", ".", "_curr_lr", ",", "\n", "self", ".", "_curr_mom", ",", "\n", "momentumTypeNONNormalized0orNormalized1", ",", "\n", "classicMomentum0OrNesterov1", ")", "\n", "", "elif", "sgd0orAdam1orRmsProp2", "==", "1", ":", "\n", "            ", "self", ".", "_optimizer", "=", "optimizers_dm", ".", "AdamOptimizer", "(", "params_to_opt", ",", "\n", "self", ".", "_curr_lr", ",", "\n", "b1ParamForAdam", ",", "\n", "b2ParamForAdam", ",", "\n", "epsilonForAdam", ")", "\n", "", "elif", "sgd0orAdam1orRmsProp2", "==", "2", ":", "\n", "            ", "self", ".", "_optimizer", "=", "optimizers_dm", ".", "RmsPropOptimizer", "(", "params_to_opt", ",", "\n", "self", ".", "_curr_lr", ",", "\n", "self", ".", "_curr_mom", ",", "\n", "momentumTypeNONNormalized0orNormalized1", ",", "\n", "classicMomentum0OrNesterov1", ",", "\n", "rhoParamForRmsProp", ",", "\n", "epsilonForRmsProp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_total_cost": [[177, 180], ["None"], "methods", ["None"], ["", "", "def", "get_total_cost", "(", "self", ")", ":", "\n", "# Run only after: self.setup_costs(...)", "\n", "        ", "return", "self", ".", "_total_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_param_updates_wrt_total_cost": [[182, 186], ["trainer.Trainer._optimizer.get_update_ops_given_cost", "trainer.Trainer.get_total_cost"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.get_update_ops_given_cost", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_total_cost"], ["", "def", "get_param_updates_wrt_total_cost", "(", "self", ")", ":", "\n", "# Excludes BN rolling average updates.", "\n", "        ", "updates", "=", "self", ".", "_optimizer", ".", "get_update_ops_given_cost", "(", "self", ".", "get_total_cost", "(", ")", ")", "# A list of assign ops. For cnn AND optimizer's params.", "\n", "return", "updates", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_num_epochs_trained_tfv": [[187, 189], ["None"], "methods", ["None"], ["", "def", "get_num_epochs_trained_tfv", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_num_epochs_trained_tfv", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.get_incr_num_epochs_trained_op": [[191, 193], ["None"], "methods", ["None"], ["", "def", "get_incr_num_epochs_trained_op", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_op_increase_num_epochs_trained", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._compute_w_per_class_vector_for_xentr": [[197, 238], ["tensorflow.ones", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.cast", "tensorflow.math.bincount", "tensorflow.reduce_prod", "tensorflow.constant", "tensorflow.shape", "len"], "methods", ["None"], ["", "def", "_compute_w_per_class_vector_for_xentr", "(", "self", ",", "num_classes", ",", "y_gt", ",", "eps", "=", "1e-6", ")", ":", "\n", "# Re-weights samples in the cost function on a per-class basis.", "\n", "# E.g. to exclude a class, or counter class imbalance.", "\n", "# From first to given epoch, start from weighting classes equally to natural frequency, decreasing weighting linearly.", "\n", "# Return value: a function of epochs_trained_tfv", "\n", "\n", "        ", "if", "self", ".", "_reweight_classes_in_cost", "is", "None", "or", "self", ".", "_reweight_classes_in_cost", "[", "\"type\"", "]", "is", "None", ":", "# No re-weighting.", "\n", "            ", "w_per_cl_vec", "=", "tf", ".", "ones", "(", "shape", "=", "[", "num_classes", "]", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "", "else", ":", "# A type of reweighting has been specified", "\n", "\n", "            ", "if", "self", ".", "_reweight_classes_in_cost", "[", "\"type\"", "]", "==", "\"freq\"", ":", "\n", "# Frequency re-weighting", "\n", "                ", "num_lbls_in_ygt", "=", "tf", ".", "cast", "(", "tf", ".", "reduce_prod", "(", "tf", ".", "shape", "(", "y_gt", ")", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "num_lbls_in_ygt_per_c", "=", "tf", ".", "math", ".", "bincount", "(", "arr", "=", "y_gt", ",", "minlength", "=", "num_classes", ",", "maxlength", "=", "num_classes", ",", "dtype", "=", "\"float32\"", ")", "# without the min/max, length of vector can change.", "\n", "y1", "=", "(", "1.", "/", "(", "num_lbls_in_ygt_per_c", "+", "eps", ")", ")", "*", "(", "num_lbls_in_ygt", "/", "num_classes", ")", "\n", "\n", "", "elif", "self", ".", "_reweight_classes_in_cost", "[", "\"type\"", "]", "==", "\"per_c\"", ":", "\n", "# self._reweight_classes_in_cost[\"prms\"] should be a list, with one float per class", "\n", "                ", "assert", "len", "(", "self", ".", "_reweight_classes_in_cost", "[", "\"prms\"", "]", ")", "==", "num_classes", "\n", "y1", "=", "tf", ".", "constant", "(", "self", ".", "_reweight_classes_in_cost", "[", "\"prms\"", "]", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "# Linear schedule:", "\n", "", "lin_schedule_min_max_epoch", "=", "self", ".", "_reweight_classes_in_cost", "[", "\"schedule\"", "]", "\n", "assert", "lin_schedule_min_max_epoch", "[", "0", "]", "<", "lin_schedule_min_max_epoch", "[", "1", "]", "\n", "\n", "# yx - y1 = (x - x1) * (y2 - y1)/(x2 - x1)", "\n", "# yx = the multiplier I currently want, y1 = the multiplier at the beginning, y2 = the multiplier at the end", "\n", "# x = current epoch, x1 = epoch where linear decrease starts, x2 = epoch where linear decrease ends", "\n", "y2", "=", "1.", "# Where weight should be after end of schedule.", "\n", "\n", "x1", "=", "tf", ".", "cast", "(", "lin_schedule_min_max_epoch", "[", "0", "]", ",", "dtype", "=", "\"float32\"", ")", "\n", "x2", "=", "tf", ".", "cast", "(", "lin_schedule_min_max_epoch", "[", "1", "]", ",", "dtype", "=", "\"float32\"", ")", "\n", "x", "=", "tf", ".", "cast", "(", "self", ".", "_num_epochs_trained_tfv", ",", "dtype", "=", "\"float32\"", ")", "\n", "# To handle the piecewise linear behaviour of x being before x1 and after x2 giving the same y as if =x1 or =x2 :", "\n", "x", "=", "tf", ".", "maximum", "(", "x1", ",", "x", ")", "\n", "x", "=", "tf", ".", "minimum", "(", "x", ",", "x2", ")", "\n", "yx", "=", "(", "x", "-", "x1", ")", "*", "(", "y2", "-", "y1", ")", "/", "(", "x2", "-", "x1", ")", "+", "y1", "\n", "w_per_cl_vec", "=", "yx", "\n", "\n", "", "return", "w_per_cl_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._get_mom_from_schedule": [[240, 260], ["tensorflow.cast", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.constant"], "methods", ["None"], ["", "def", "_get_mom_from_schedule", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'expon'", ":", "\n", "# Increased linearly.", "\n", "            ", "first_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'epochs_wait_before_decr'", "]", "\n", "final_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'final_ep_for_sch'", "]", "# * subepochs_per_ep", "\n", "assert", "first_it_for_sch", "<", "final_it_for_sch", "\n", "curr_it", "=", "tf", ".", "cast", "(", "self", ".", "_num_epochs_trained_tfv", ",", "dtype", "=", "'float32'", ")", "# * subepochs_per_ep + curr_subepoch", "\n", "\n", "x_min", "=", "0.", "\n", "x2", "=", "final_it_for_sch", "-", "first_it_for_sch", "\n", "x", "=", "tf", ".", "maximum", "(", "tf", ".", "constant", "(", "0", ",", "dtype", "=", "\"float32\"", ")", ",", "curr_it", "-", "first_it_for_sch", ")", "\n", "x", "=", "tf", ".", "minimum", "(", "x", ",", "x2", ")", "\n", "y_min", "=", "self", ".", "_init_mom_tfv", "\n", "y_max", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'mom_to_reach_at_last_ep'", "]", "\n", "\n", "curr_mom", "=", "(", "x", "-", "x_min", ")", "/", "(", "x2", "-", "x_min", ")", "*", "(", "y_max", "-", "y_min", ")", "+", "y_max", "\n", "", "else", ":", "\n", "            ", "curr_mom", "=", "self", ".", "_init_mom_tfv", "\n", "\n", "", "return", "curr_mom", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._get_lr_from_schedule": [[262, 319], ["tensorflow.cast", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.constant", "tensorflow.pow", "tensorflow.cast", "tensorflow.maximum", "tensorflow.minimum", "tensorflow.pow", "tensorflow.constant", "tensorflow.pow", "tensorflow.compat.v1.train.piecewise_constant", "tensorflow.cast", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "pow", "range", "len"], "methods", ["None"], ["", "def", "_get_lr_from_schedule", "(", "self", ")", ":", "\n", "        ", "TINY", "=", "1e-8", "\n", "\n", "if", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'stable'", ":", "\n", "            ", "curr_lr", "=", "self", ".", "_init_lr_tfv", "\n", "\n", "", "elif", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'poly'", ":", "\n", "            ", "first_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'poly'", "]", "[", "'epochs_wait_before_decr'", "]", "\n", "final_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'poly'", "]", "[", "'final_ep_for_sch'", "]", "# * subepochs_per_ep", "\n", "assert", "first_it_for_sch", "<", "final_it_for_sch", "\n", "curr_it", "=", "tf", ".", "cast", "(", "self", ".", "_num_epochs_trained_tfv", ",", "dtype", "=", "'float32'", ")", "# * subepochs_per_ep + curr_subepoch", "\n", "\n", "#curr_lr = init_lr * ( 1 - x/x2) ^ power. Power = 0.9 in parsenet, which we validated to behave ok.", "\n", "x2", "=", "final_it_for_sch", "-", "first_it_for_sch", "\n", "x", "=", "tf", ".", "maximum", "(", "tf", ".", "constant", "(", "0", ",", "dtype", "=", "\"float32\"", ")", ",", "curr_it", "-", "first_it_for_sch", ")", "# to make schedule happen within the window (first, final) epoch, stable outside.", "\n", "x", "=", "tf", ".", "minimum", "(", "x", ",", "x2", ")", "# in case the current iteration is after max, so that I keep schedule stable afterwards. ", "\n", "y1", "=", "self", ".", "_init_lr_tfv", "\n", "y2", "=", "0.9", "\n", "curr_lr", "=", "y1", "*", "tf", ".", "pow", "(", "1.0", "-", "x", "/", "x2", ",", "y2", ")", "\n", "\n", "", "elif", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'expon'", ":", "\n", "            ", "first_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'epochs_wait_before_decr'", "]", "\n", "final_it_for_sch", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'final_ep_for_sch'", "]", "# * subepochs_per_ep", "\n", "assert", "first_it_for_sch", "<", "final_it_for_sch", "\n", "curr_it", "=", "tf", ".", "cast", "(", "self", ".", "_num_epochs_trained_tfv", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "# y = y1 * gamma^x. gamma = (y2 / y1)^(1/x2)", "\n", "x2", "=", "final_it_for_sch", "-", "first_it_for_sch", "\n", "x", "=", "tf", ".", "maximum", "(", "tf", ".", "constant", "(", "0", ",", "dtype", "=", "\"float32\"", ")", ",", "curr_it", "-", "first_it_for_sch", ")", "\n", "x", "=", "tf", ".", "minimum", "(", "x", ",", "x2", ")", "\n", "y1", "=", "self", ".", "_init_lr_tfv", "\n", "y2", "=", "self", ".", "_lr_sched_params", "[", "'expon'", "]", "[", "'lr_to_reach_at_last_ep'", "]", "\n", "gamma", "=", "tf", ".", "pow", "(", "(", "y2", "+", "TINY", ")", "/", "y1", ",", "1.0", "/", "x2", ")", "\n", "curr_lr", "=", "y1", "*", "tf", ".", "pow", "(", "gamma", ",", "x", ")", "\n", "\n", "", "elif", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'predef'", ":", "\n", "#Predefined Schedule.", "\n", "            ", "div_lr_by", "=", "self", ".", "_lr_sched_params", "[", "'predef'", "]", "[", "'div_lr_by'", "]", "\n", "epochs_boundaries", "=", "[", "tf", ".", "cast", "(", "e", ",", "tf", ".", "int32", ")", "for", "e", "in", "self", ".", "_lr_sched_params", "[", "'predef'", "]", "[", "'epochs'", "]", "]", "\n", "lr_values", "=", "[", "(", "self", ".", "_init_lr_tfv", "/", "pow", "(", "div_lr_by", ",", "i", ")", ")", "for", "i", "in", "range", "(", "1", "+", "len", "(", "epochs_boundaries", ")", ")", "]", "\n", "curr_lr", "=", "tf", ".", "compat", ".", "v1", ".", "train", ".", "piecewise_constant", "(", "self", ".", "_num_epochs_trained_tfv", ",", "boundaries", "=", "epochs_boundaries", ",", "values", "=", "lr_values", ")", "\n", "\n", "", "elif", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'auto'", ":", "\n", "            ", "self", ".", "_learning_rate_tfv", "=", "tf", ".", "Variable", "(", "self", ".", "_init_lr_tfv", ",", "dtype", "=", "\"float32\"", ",", "trainable", "=", "False", ",", "name", "=", "\"curr_lr_tfv\"", ")", "\n", "self", ".", "_top_mean_val_acc_tfv", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "\"float32\"", ",", "trainable", "=", "False", ",", "name", "=", "\"top_mean_val_acc\"", ")", "\n", "self", ".", "_epoch_with_top_mean_val_acc_tvf", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "self", ".", "_num_epochs_trained_tfv", ".", "dtype", ".", "as_numpy_dtype", ",", "trainable", "=", "False", ",", "name", "=", "\"ep_top_mean_val_acc\"", ")", "\n", "self", ".", "_last_epoch_lr_got_lowered_tvf", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "\"float32\"", ",", "trainable", "=", "False", ",", "name", "=", "\"last_ep_lr_lowered\"", ")", "\n", "\n", "self", ".", "_op_assign_new_lr", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_learning_rate_tfv", ",", "self", ".", "_tf_plchld_float32", ")", "\n", "self", ".", "_op_assign_top_mean_val_acc_tfv", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_top_mean_val_acc_tfv", ",", "self", ".", "_tf_plchld_float32", ")", "\n", "self", ".", "_op_assign_epoch_with_top_mean_val_acc_tvf", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_epoch_with_top_mean_val_acc_tvf", ",", "self", ".", "_tf_plchld_int32", ")", "\n", "self", ".", "_op_assign_last_epoch_lr_lowered", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_last_epoch_lr_got_lowered_tvf", ",", "self", ".", "_tf_plchld_float32", ")", "\n", "\n", "# The LR will be changed during the routine.training, by a call to function self.run_lr_sched_updates( sessionTf )", "\n", "curr_lr", "=", "self", ".", "_learning_rate_tfv", "\n", "\n", "", "return", "curr_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer.run_updates_end_of_ep": [[323, 333], ["trainer.Trainer._run_lr_sched_updates", "sessionTf.run", "log.print3", "log.print3", "log.print3", "str", "str", "str", "sessionTf.run", "sessionTf.run"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._run_lr_sched_updates", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "def", "run_updates_end_of_ep", "(", "self", ",", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", ":", "\n", "# In case I will need to do more than lr_sched_updates.", "\n", "        ", "self", ".", "_run_lr_sched_updates", "(", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", "\n", "\n", "# Done with everything in epoch. Increase number of trained epochs.", "\n", "num_eps_trained", "=", "sessionTf", ".", "run", "(", "self", ".", "_op_increase_num_epochs_trained", ")", "\n", "\n", "log", ".", "print3", "(", "\"Trainer: Current learning rate: \"", "+", "str", "(", "sessionTf", ".", "run", "(", "self", ".", "_curr_lr", ")", ")", ")", "\n", "log", ".", "print3", "(", "\"Trainer: Current momentum: \"", "+", "str", "(", "sessionTf", ".", "run", "(", "self", ".", "_curr_mom", ")", ")", ")", "\n", "log", ".", "print3", "(", "\"Trainer: Number of epochs the model has been trained: \"", "+", "str", "(", "num_eps_trained", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._run_lr_sched_updates": [[336, 342], ["trainer.Trainer._update_top_acc_if_needed", "trainer.Trainer._run_auto_sched_updates"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._update_top_acc_if_needed", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._run_auto_sched_updates"], ["", "def", "_run_lr_sched_updates", "(", "self", ",", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", ":", "# This should be the only API.", "\n", "# The majority of schedules are implemented as tf operations on the graph.", "\n", "# Here, only implement the ones that need to change dynamically with things happening during training. Eg Auto.", "\n", "        ", "if", "self", ".", "_lr_sched_params", "[", "'type'", "]", "==", "'auto'", ":", "\n", "            ", "self", ".", "_update_top_acc_if_needed", "(", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", "\n", "self", ".", "_run_auto_sched_updates", "(", "log", ",", "sessionTf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._check_valid_func_call_for_lr_sched": [[344, 349], ["log.print3", "exit1", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "_check_valid_func_call_for_lr_sched", "(", "self", ",", "log", ",", "list_allowed_scheds", ")", ":", "\n", "        ", "if", "self", ".", "_lr_sched_params", "[", "'type'", "]", "not", "in", "list_allowed_scheds", ":", "\n", "            ", "log", ".", "print3", "(", "\"ERROR: Asked to manually change learning rate. This is only expected if LR-schedule is auto.\"", "+", "\"\\n\\t Current schedule is [\"", "+", "str", "(", "self", ".", "_lr_sched_type", ")", "+", "\"]. Exiting!\"", ")", "\n", "exit1", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._change_lr_to": [[351, 357], ["trainer.Trainer._check_valid_func_call_for_lr_sched", "log.print3", "sessionTf.run", "trainer.Trainer._num_epochs_trained_tfv.eval", "sessionTf.run", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._check_valid_func_call_for_lr_sched", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "_change_lr_to", "(", "self", ",", "log", ",", "sessionTf", ",", "new_lr", ")", ":", "\n", "        ", "self", ".", "_check_valid_func_call_for_lr_sched", "(", "log", ",", "[", "'auto'", "]", ")", "# currently should never be called with a different schedule.", "\n", "log", ".", "print3", "(", "\"UPDATE: Changing the network's learning rate to: \"", "+", "str", "(", "new_lr", ")", ")", "\n", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_assign_new_lr", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_float32", ":", "new_lr", "}", ")", "\n", "last_epoch_lr_lowered", "=", "self", ".", "_num_epochs_trained_tfv", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_assign_last_epoch_lr_lowered", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_float32", ":", "last_epoch_lr_lowered", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._divide_lr_by": [[359, 364], ["trainer.Trainer._check_valid_func_call_for_lr_sched", "sessionTf.run", "trainer.Trainer._change_lr_to"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._check_valid_func_call_for_lr_sched", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._change_lr_to"], ["", "def", "_divide_lr_by", "(", "self", ",", "log", ",", "sessionTf", ",", "div_lr_by", ")", ":", "\n", "        ", "self", ".", "_check_valid_func_call_for_lr_sched", "(", "log", ",", "[", "'auto'", "]", ")", "# currently should never be called with a different schedule.", "\n", "old_lr", "=", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_learning_rate_tfv", ")", "\n", "new_lr", "=", "old_lr", "/", "div_lr_by", "\n", "self", ".", "_change_lr_to", "(", "log", ",", "sessionTf", ",", "new_lr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._run_auto_sched_updates": [[367, 385], ["trainer.Trainer._check_valid_func_call_for_lr_sched", "trainer.Trainer._num_epochs_trained_tfv.eval", "trainer.Trainer._epoch_with_top_mean_val_acc_tvf.eval", "trainer.Trainer._last_epoch_lr_got_lowered_tvf.eval", "log.print3", "trainer.Trainer._divide_lr_by", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._check_valid_func_call_for_lr_sched", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._divide_lr_by"], ["", "def", "_run_auto_sched_updates", "(", "self", ",", "log", ",", "sessionTf", ")", ":", "\n", "        ", "self", ".", "_check_valid_func_call_for_lr_sched", "(", "log", ",", "[", "'auto'", "]", ")", "\n", "num_epochs_trained", "=", "self", ".", "_num_epochs_trained_tfv", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "epoch_with_top_mean_val_acc", "=", "self", ".", "_epoch_with_top_mean_val_acc_tvf", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "last_epoch_lr_got_lowered", "=", "self", ".", "_last_epoch_lr_got_lowered_tvf", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "epochs_wait_before_decr", "=", "self", ".", "_lr_sched_params", "[", "'auto'", "]", "[", "'epochs_wait_before_decr'", "]", "\n", "\n", "if", "(", "num_epochs_trained", ">=", "epoch_with_top_mean_val_acc", "+", "epochs_wait_before_decr", ")", "and", "(", "num_epochs_trained", ">=", "last_epoch_lr_got_lowered", "+", "epochs_wait_before_decr", ")", ":", "\n", "\n", "            ", "log", ".", "print3", "(", "\"DEBUG: Going to lower Learning Rate because of [AUTO] schedule.\"", "+", "\"\\n\\t The network has been trained for: \"", "+", "str", "(", "num_epochs_trained", ")", "+", "\" epochs.\"", "+", "\"\\n\\t Epoch with highest achieved validation accuracy: \"", "+", "str", "(", "epoch_with_top_mean_val_acc", ")", "+", "\"\\n\\t Epoch that learning rate was lowered last time: \"", "+", "str", "(", "last_epoch_lr_got_lowered", ")", "+", "\"\\n\\t Waited that many epochs for accuracy to increase: \"", "+", "str", "(", "epochs_wait_before_decr", ")", "+", "\" epochs.\"", "+", "\"\\n\\t Going to lower learning rate...\"", ")", "\n", "\n", "self", ".", "_divide_lr_by", "(", "log", ",", "sessionTf", ",", "self", ".", "_lr_sched_params", "[", "'auto'", "]", "[", "'div_lr_by'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.trainer.Trainer._update_top_acc_if_needed": [[387, 397], ["trainer.Trainer._top_mean_val_acc_tfv.eval", "trainer.Trainer._num_epochs_trained_tfv.eval", "log.print3", "sessionTf.run", "sessionTf.run", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3"], ["", "", "def", "_update_top_acc_if_needed", "(", "self", ",", "log", ",", "sessionTf", ",", "mean_val_acc_of_ep", ")", ":", "\n", "# Called at the end of an epoch, right before increasing self._num_epochs_trained_tfv", "\n", "        ", "assert", "(", "mean_val_acc_of_ep", "is", "not", "None", ")", "and", "(", "mean_val_acc_of_ep", ">=", "0", ")", "# flags in case validation is not performed.", "\n", "top_mean_val_acc", "=", "self", ".", "_top_mean_val_acc_tfv", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "num_epochs_trained", "=", "self", ".", "_num_epochs_trained_tfv", ".", "eval", "(", "session", "=", "sessionTf", ")", "\n", "\n", "if", "mean_val_acc_of_ep", ">", "top_mean_val_acc", "+", "self", ".", "_lr_sched_params", "[", "'auto'", "]", "[", "'min_incr_of_val_acc_considered'", "]", ":", "\n", "            ", "log", ".", "print3", "(", "\"UPDATE: In this epoch the CNN achieved a new highest mean validation accuracy of: \"", "+", "str", "(", "mean_val_acc_of_ep", ")", ")", "\n", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_assign_top_mean_val_acc_tfv", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_float32", ":", "mean_val_acc_of_ep", "}", ")", "\n", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_assign_epoch_with_top_mean_val_acc_tvf", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_int32", ":", "num_epochs_trained", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.apply": [[31, 34], ["NotImplementedError"], "methods", ["None"], ["    ", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "# mode: \"train\" or \"infer\"", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.trainable_params": [[35, 37], ["NotImplementedError"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.params_for_L1_L2_reg": [[38, 40], ["None"], "methods", ["None"], ["", "def", "params_for_L1_L2_reg", "(", "self", ")", ":", "\n", "        ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.rec_field": [[41, 47], ["None"], "methods", ["None"], ["", "def", "rec_field", "(", "self", ",", "rf_at_inp", ",", "stride_rf_at_inp", ")", ":", "\n", "# stride_rf_at_inp: [str-x, str-y, str-z", "\n", "#                stride of the rec field at prev layer wrt cnn's inp", "\n", "# Returns: receptive field [x,y,z] of neurons in this input, and ...", "\n", "#          stride of rf wrt input-image when shifting between 2 consequtive neurons in this layer", "\n", "        ", "return", "rf_at_inp", ",", "stride_rf_at_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.calc_outp_dims_given_inp": [[48, 50], ["None"], "methods", ["None"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "\n", "        ", "return", "inp_dims", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.Layer.calc_inp_dims_given_outp": [[51, 53], ["None"], "methods", ["None"], ["", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "return", "outp_dims", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.__init__": [[55, 64], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "window_size", ",", "strides", ",", "pad_mode", ",", "pool_mode", ")", ":", "\n", "# window_size: [wx, wy, wz]", "\n", "# strides: [sx, sy, sz]", "\n", "# mode: 'MAX' or 'AVG'", "\n", "# mirror_pad: [mirrorPad-x,-y,-z]", "\n", "        ", "self", ".", "_window_size", "=", "window_size", "\n", "self", ".", "_strides", "=", "strides", "\n", "self", ".", "_pad_mode", "=", "pad_mode", "\n", "self", ".", "_pool_mode", "=", "pool_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.apply": [[65, 68], ["deepmedic.pool_3d"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.pool_3d"], ["", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "\n", "# input dimensions: (batch, fms, r, c, z)", "\n", "        ", "return", "ops", ".", "pool_3d", "(", "input", ",", "self", ".", "_window_size", ",", "self", ".", "_strides", ",", "self", ".", "_pad_mode", ",", "self", ".", "_pool_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.trainable_params": [[69, 71], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer._n_padding": [[72, 75], ["range"], "methods", ["None"], ["", "def", "_n_padding", "(", "self", ")", ":", "\n", "# Returns [padx,pady,padz], how much pad would have been added to preserve dimensions ('SAME' or 'MIRROR').", "\n", "        ", "return", "[", "0", ",", "0", ",", "0", "]", "if", "self", ".", "_pad_mode", "==", "'VALID'", "else", "[", "self", ".", "_window_size", "[", "d", "]", "-", "1", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.rec_field": [[76, 78], ["NotImplementedError"], "methods", ["None"], ["", "def", "rec_field", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.calc_outp_dims_given_inp": [[79, 85], ["layers.PoolingLayer._n_padding", "numpy.any", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "# Same as conv.", "\n", "        ", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "if", "np", ".", "any", "(", "[", "inp_dims", "[", "d", "]", "+", "padding", "[", "d", "]", "<", "self", ".", "_window_size", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", ")", ":", "\n", "            ", "return", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "1", "+", "(", "inp_dims", "[", "d", "]", "+", "padding", "[", "d", "]", "-", "self", ".", "_window_size", "[", "d", "]", ")", "//", "self", ".", "_strides", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PoolingLayer.calc_inp_dims_given_outp": [[86, 90], ["numpy.all", "layers.PoolingLayer._n_padding", "range", "range"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "assert", "np", ".", "all", "(", "[", "outp_dims", "[", "d", "]", ">", "0", "for", "d", "in", "range", "(", "3", ")", "]", ")", "\n", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "return", "[", "(", "outp_dims", "[", "d", "]", "-", "1", ")", "*", "self", ".", "_strides", "[", "d", "]", "+", "self", ".", "_window_size", "[", "d", "]", "-", "padding", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.__init__": [[92, 99], ["layers.ConvolutionalLayer._get_std_init", "numpy.asarray", "tensorflow.Variable", "rng.normal"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer._get_std_init"], ["    ", "def", "__init__", "(", "self", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", ":", "\n", "# filter_shape of dimensions: list/np.array: [#FMs in this layer, #FMs in input, kern-dim-x, kern-dim-y, kern-dim-z]", "\n", "        ", "std_init", "=", "self", ".", "_get_std_init", "(", "init_method", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ")", "\n", "w_init", "=", "np", ".", "asarray", "(", "rng", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "std_init", ",", "size", "=", "[", "fms_out", ",", "fms_in", "]", "+", "conv_kernel_dims", ")", ",", "dtype", "=", "'float32'", ")", "\n", "self", ".", "_w", "=", "tf", ".", "Variable", "(", "w_init", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"W\"", ")", "# w shape: [#FMs of this layer, #FMs of Input, x, y, z]", "\n", "self", ".", "_strides", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "self", ".", "_pad_mode", "=", "pad_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer._get_std_init": [[100, 107], ["numpy.sqrt", "numpy.prod"], "methods", ["None"], ["", "def", "_get_std_init", "(", "self", ",", "init_method", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ")", ":", "\n", "        ", "if", "init_method", "[", "0", "]", "==", "\"normal\"", ":", "\n", "            ", "std_init", "=", "init_method", "[", "1", "]", "# commonly 0.01 from Krizhevski", "\n", "", "elif", "init_method", "[", "0", "]", "==", "\"fanIn\"", ":", "\n", "            ", "var_scale", "=", "init_method", "[", "1", "]", "# 2 for init ala Delving into Rectifier, 1 for SNN.", "\n", "std_init", "=", "np", ".", "sqrt", "(", "var_scale", "/", "np", ".", "prod", "(", "[", "fms_in", "]", "+", "conv_kernel_dims", ")", ")", "\n", "", "return", "std_init", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.apply": [[108, 110], ["deepmedic.conv_3d"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.conv_3d"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "        ", "return", "ops", ".", "conv_3d", "(", "input", ",", "self", ".", "_w", ",", "self", ".", "_pad_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.trainable_params": [[111, 113], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "_w", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.params_for_L1_L2_reg": [[114, 116], ["layers.ConvolutionalLayer.trainable_params"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params"], ["", "def", "params_for_L1_L2_reg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "trainable_params", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer._n_padding": [[117, 120], ["range", "layers.ConvolutionalLayer._w.shape.as_list"], "methods", ["None"], ["", "def", "_n_padding", "(", "self", ")", ":", "\n", "# Returns [padx,pady,padz], how much pad would have been added to preserve dimensions ('SAME' or 'MIRROR').", "\n", "        ", "return", "[", "0", ",", "0", ",", "0", "]", "if", "self", ".", "_pad_mode", "==", "'VALID'", "else", "[", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", "-", "1", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.rec_field": [[121, 125], ["range", "range", "layers.ConvolutionalLayer._w.shape.as_list"], "methods", ["None"], ["", "def", "rec_field", "(", "self", ",", "rf_at_inp", ",", "stride_rf_at_inp", ")", ":", "\n", "        ", "rf_out", "=", "[", "rf_at_inp", "[", "d", "]", "+", "(", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", "-", "1", ")", "*", "stride_rf_at_inp", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "stride_rf", "=", "[", "stride_rf_at_inp", "[", "d", "]", "*", "self", ".", "_strides", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "return", "rf_out", ",", "stride_rf", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.calc_outp_dims_given_inp": [[126, 132], ["layers.ConvolutionalLayer._n_padding", "numpy.any", "range", "range", "layers.ConvolutionalLayer._w.shape.as_list", "layers.ConvolutionalLayer._w.shape.as_list"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "\n", "        ", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "if", "np", ".", "any", "(", "[", "inp_dims", "[", "d", "]", "+", "padding", "[", "d", "]", "<", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", ")", ":", "\n", "            ", "return", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "1", "+", "(", "inp_dims", "[", "d", "]", "+", "padding", "[", "d", "]", "-", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", ")", "//", "self", ".", "_strides", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer.calc_inp_dims_given_outp": [[133, 137], ["numpy.all", "layers.ConvolutionalLayer._n_padding", "range", "range", "layers.ConvolutionalLayer._w.shape.as_list"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "assert", "np", ".", "all", "(", "[", "outp_dims", "[", "d", "]", ">", "0", "for", "d", "in", "range", "(", "3", ")", "]", ")", "\n", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "return", "[", "(", "outp_dims", "[", "d", "]", "-", "1", ")", "*", "self", ".", "_strides", "[", "d", "]", "+", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", "-", "padding", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.__init__": [[145, 164], ["layers.LowRankConvolutionalLayer._get_std_init", "numpy.asarray", "tensorflow.Variable", "numpy.asarray", "tensorflow.Variable", "numpy.asarray", "tensorflow.Variable", "rng.normal", "rng.normal", "rng.normal"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ConvolutionalLayer._get_std_init"], ["    ", "def", "__init__", "(", "self", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", ":", "\n", "        ", "self", ".", "_conv_kernel_dims", "=", "conv_kernel_dims", "# For _crop_sub_outputs_same_dims_and_concat(). Could be done differently?", "\n", "std_init", "=", "self", ".", "_get_std_init", "(", "init_method", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ")", "\n", "\n", "x_subfilter_shape", "=", "[", "fms_out", "//", "3", ",", "fms_in", ",", "conv_kernel_dims", "[", "0", "]", ",", "1", "if", "self", ".", "_rank", "==", "1", "else", "conv_kernel_dims", "[", "1", "]", ",", "1", "]", "\n", "w_init", "=", "np", ".", "asarray", "(", "rng", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "std_init", ",", "size", "=", "x_subfilter_shape", ")", ",", "dtype", "=", "'float32'", ")", "\n", "self", ".", "_w_x", "=", "tf", ".", "Variable", "(", "w_init", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"w_x\"", ")", "\n", "\n", "y_subfilter_shape", "=", "[", "fms_out", "//", "3", ",", "fms_in", ",", "1", ",", "conv_kernel_dims", "[", "1", "]", ",", "1", "if", "self", ".", "_rank", "==", "1", "else", "conv_kernel_dims", "[", "2", "]", "]", "\n", "w_init", "=", "np", ".", "asarray", "(", "rng", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "std_init", ",", "size", "=", "y_subfilter_shape", ")", ",", "dtype", "=", "'float32'", ")", "\n", "self", ".", "_w_y", "=", "tf", ".", "Variable", "(", "w_init", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"w_y\"", ")", "\n", "\n", "n_fms_left", "=", "fms_out", "-", "2", "*", "(", "fms_out", "//", "3", ")", "# Cause of possibly inexact integer division.", "\n", "z_subfilter_shape", "=", "[", "n_fms_left", ",", "fms_in", ",", "1", "if", "self", ".", "_rank", "==", "1", "else", "conv_kernel_dims", "[", "0", "]", ",", "1", ",", "conv_kernel_dims", "[", "2", "]", "]", "\n", "w_init", "=", "np", ".", "asarray", "(", "rng", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "std_init", ",", "size", "=", "z_subfilter_shape", ")", ",", "dtype", "=", "'float32'", ")", "\n", "self", ".", "_w_z", "=", "tf", ".", "Variable", "(", "w_init", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"w_z\"", ")", "\n", "\n", "self", ".", "_strides", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "self", ".", "_pad_mode", "=", "pad_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.trainable_params": [[165, 167], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "_w_x", ",", "self", ".", "_w_y", ",", "self", ".", "_w_z", "]", "# Note: these tensors have different shapes! Treat carefully.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.params_for_L1_L2_reg": [[168, 170], ["layers.LowRankConvolutionalLayer.trainable_params"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params"], ["", "def", "params_for_L1_L2_reg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "trainable_params", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.apply": [[171, 178], ["deepmedic.conv_3d", "deepmedic.conv_3d", "deepmedic.conv_3d", "layers.LowRankConvolutionalLayer._crop_sub_outputs_same_dims_and_concat"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.conv_3d", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.conv_3d", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.conv_3d", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._crop_sub_outputs_same_dims_and_concat"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "        ", "out_x", "=", "ops", ".", "conv_3d", "(", "input", ",", "self", ".", "_w_x", ",", "self", ".", "_pad_mode", ")", "\n", "out_y", "=", "ops", ".", "conv_3d", "(", "input", ",", "self", ".", "_w_y", ",", "self", ".", "_pad_mode", ")", "\n", "out_z", "=", "ops", ".", "conv_3d", "(", "input", ",", "self", ".", "_w_z", ",", "self", ".", "_pad_mode", ")", "\n", "# concatenate together.", "\n", "out", "=", "self", ".", "_crop_sub_outputs_same_dims_and_concat", "(", "out_x", ",", "out_y", ",", "out_z", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._crop_sub_outputs_same_dims_and_concat": [[179, 195], ["slice", "slice", "slice", "tensorflow.concat", "slice", "slice", "slice"], "methods", ["None"], ["", "def", "_crop_sub_outputs_same_dims_and_concat", "(", "self", ",", "tens_x", ",", "tens_y", ",", "tens_z", ")", ":", "\n", "        ", "assert", "(", "tens_x", ".", "shape", "[", "0", "]", "==", "tens_y", ".", "shape", "[", "0", "]", ")", "and", "(", "tens_y", ".", "shape", "[", "0", "]", "==", "tens_z", ".", "shape", "[", "0", "]", ")", "# batch-size", "\n", "conv_tens_shape", "=", "[", "tens_x", ".", "shape", "[", "0", "]", ",", "\n", "tens_x", ".", "shape", "[", "1", "]", "+", "tens_y", ".", "shape", "[", "1", "]", "+", "tens_z", ".", "shape", "[", "1", "]", ",", "\n", "tens_x", ".", "shape", "[", "2", "]", ",", "\n", "tens_y", ".", "shape", "[", "3", "]", ",", "\n", "tens_z", ".", "shape", "[", "4", "]", "\n", "]", "\n", "x_crop_slice", "=", "slice", "(", "(", "self", ".", "_conv_kernel_dims", "[", "0", "]", "-", "1", ")", "//", "2", ",", "(", "self", ".", "_conv_kernel_dims", "[", "0", "]", "-", "1", ")", "//", "2", "+", "conv_tens_shape", "[", "2", "]", ")", "\n", "y_crop_slice", "=", "slice", "(", "(", "self", ".", "_conv_kernel_dims", "[", "1", "]", "-", "1", ")", "//", "2", ",", "(", "self", ".", "_conv_kernel_dims", "[", "1", "]", "-", "1", ")", "//", "2", "+", "conv_tens_shape", "[", "3", "]", ")", "\n", "z_crop_slice", "=", "slice", "(", "(", "self", ".", "_conv_kernel_dims", "[", "2", "]", "-", "1", ")", "//", "2", ",", "(", "self", ".", "_conv_kernel_dims", "[", "2", "]", "-", "1", ")", "//", "2", "+", "conv_tens_shape", "[", "4", "]", ")", "\n", "tens_x_crop", "=", "tens_x", "[", ":", ",", ":", ",", ":", ",", "y_crop_slice", "if", "self", ".", "_rank", "==", "1", "else", "slice", "(", "0", ",", "MAX_INT", ")", ",", "z_crop_slice", "]", "\n", "tens_y_crop", "=", "tens_y", "[", ":", ",", ":", ",", "x_crop_slice", ",", ":", ",", "z_crop_slice", "if", "self", ".", "_rank", "==", "1", "else", "slice", "(", "0", ",", "MAX_INT", ")", "]", "\n", "tens_z_crop", "=", "tens_z", "[", ":", ",", ":", ",", "x_crop_slice", "if", "self", ".", "_rank", "==", "1", "else", "slice", "(", "0", ",", "MAX_INT", ")", ",", "y_crop_slice", ",", ":", "]", "\n", "conc_tens", "=", "tf", ".", "concat", "(", "[", "tens_x_crop", ",", "tens_y_crop", ",", "tens_z_crop", "]", ",", "axis", "=", "1", ")", "#concatenate the FMs", "\n", "return", "conc_tens", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding": [[196, 203], ["None"], "methods", ["None"], ["", "def", "_n_padding", "(", "self", ")", ":", "\n", "# Returns [padx,pady,padz], how much pad would have been added to preserve dimensions ('SAME' or 'MIRROR').", "\n", "        ", "if", "self", ".", "_pad_mode", "==", "'VALID'", ":", "\n", "            ", "padding", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "padding", "=", "[", "self", ".", "_w_x", ".", "shape", "[", "2", "]", "-", "1", ",", "self", ".", "_w_y", ".", "shape", "[", "3", "]", "-", "1", ",", "self", ".", "_w_z", ".", "shape", "[", "4", "]", "-", "1", "]", "\n", "", "return", "padding", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.rec_field": [[204, 210], ["range"], "methods", ["None"], ["", "def", "rec_field", "(", "self", ",", "rf_at_inp", ",", "stride_rf_at_inp", ")", ":", "\n", "        ", "rf_out", "=", "[", "rf_at_inp", "[", "0", "]", "+", "(", "self", ".", "_w_x", ".", "shape", "[", "2", "]", "-", "1", ")", "*", "stride_rf_at_inp", "[", "0", "]", ",", "\n", "rf_at_inp", "[", "1", "]", "+", "(", "self", ".", "_w_y", ".", "shape", "[", "3", "]", "-", "1", ")", "*", "stride_rf_at_inp", "[", "1", "]", ",", "\n", "rf_at_inp", "[", "2", "]", "+", "(", "self", ".", "_w_z", ".", "shape", "[", "4", "]", "-", "1", ")", "*", "stride_rf_at_inp", "[", "2", "]", "]", "\n", "stride_rf", "=", "[", "stride_rf_at_inp", "[", "d", "]", "*", "self", ".", "_strides", "[", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "return", "rf_out", ",", "stride_rf", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.calc_outp_dims_given_inp": [[211, 219], ["layers.LowRankConvolutionalLayer._n_padding", "numpy.any", "range", "layers.LowRankConvolutionalLayer._w.shape.as_list", "layers.LowRankConvolutionalLayer._w_x.shape.as_list", "layers.LowRankConvolutionalLayer._w_y.shape.as_list", "layers.LowRankConvolutionalLayer._w_z.shape.as_list"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "\n", "        ", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "if", "np", ".", "any", "(", "[", "inp_dims", "[", "d", "]", "+", "padding", "[", "d", "]", "<", "self", ".", "_w", ".", "shape", ".", "as_list", "(", ")", "[", "2", "+", "d", "]", "for", "d", "in", "range", "(", "3", ")", "]", ")", ":", "\n", "            ", "return", "[", "0", ",", "0", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "1", "+", "(", "inp_dims", "[", "0", "]", "+", "padding", "[", "0", "]", "-", "self", ".", "_w_x", ".", "shape", ".", "as_list", "(", ")", "[", "2", "]", ")", "//", "self", ".", "_strides", "[", "0", "]", ",", "\n", "1", "+", "(", "inp_dims", "[", "1", "]", "+", "padding", "[", "1", "]", "-", "self", ".", "_w_y", ".", "shape", ".", "as_list", "(", ")", "[", "3", "]", ")", "//", "self", ".", "_strides", "[", "1", "]", ",", "\n", "1", "+", "(", "inp_dims", "[", "2", "]", "+", "padding", "[", "2", "]", "-", "self", ".", "_w_z", ".", "shape", ".", "as_list", "(", ")", "[", "4", "]", ")", "//", "self", ".", "_strides", "[", "2", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer.calc_inp_dims_given_outp": [[220, 226], ["numpy.all", "layers.LowRankConvolutionalLayer._n_padding", "range", "layers.LowRankConvolutionalLayer._w_x.shape.as_list", "layers.LowRankConvolutionalLayer._w_y.shape.as_list", "layers.LowRankConvolutionalLayer._w_z.shape.as_list"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.LowRankConvolutionalLayer._n_padding"], ["", "", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "assert", "np", ".", "all", "(", "[", "outp_dims", "[", "d", "]", ">", "0", "for", "d", "in", "range", "(", "3", ")", "]", ")", "\n", "padding", "=", "self", ".", "_n_padding", "(", ")", "\n", "return", "[", "(", "outp_dims", "[", "0", "]", "-", "1", ")", "*", "self", ".", "_strides", "[", "0", "]", "+", "self", ".", "_w_x", ".", "shape", ".", "as_list", "(", ")", "[", "2", "]", "-", "padding", "[", "0", "]", ",", "\n", "(", "outp_dims", "[", "1", "]", "-", "1", ")", "*", "self", ".", "_strides", "[", "1", "]", "+", "self", ".", "_w_y", ".", "shape", ".", "as_list", "(", ")", "[", "3", "]", "-", "padding", "[", "1", "]", ",", "\n", "(", "outp_dims", "[", "2", "]", "-", "1", ")", "*", "self", ".", "_strides", "[", "2", "]", "+", "self", ".", "_w_z", ".", "shape", ".", "as_list", "(", ")", "[", "4", "]", "-", "padding", "[", "2", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.DropoutLayer.__init__": [[228, 231], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dropout_rate", ",", "rng", ")", ":", "\n", "        ", "self", ".", "_keep_prob", "=", "1", "-", "dropout_rate", "\n", "self", ".", "_rng", "=", "rng", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.DropoutLayer.apply": [[232, 248], ["tensorflow.random.uniform", "tensorflow.floor", "NotImplementedError", "tensorflow.shape", "layers.DropoutLayer._rng.randint"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "        ", "if", "self", ".", "_keep_prob", ">", "0.999", ":", "#Dropout below 0.001 I take it as if there is no dropout. To avoid float problems with drop == 0.0", "\n", "            ", "return", "input", "\n", "\n", "", "if", "mode", "==", "\"train\"", ":", "\n", "            ", "random_tensor", "=", "self", ".", "_keep_prob", "\n", "random_tensor", "+=", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "tf", ".", "shape", "(", "input", ")", ",", "minval", "=", "0.", ",", "maxval", "=", "1.", ",", "seed", "=", "self", ".", "_rng", ".", "randint", "(", "999999", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "# 0. if [keep_prob, 1.0) and 1. if [1.0, 1.0 + keep_prob)", "\n", "dropout_mask", "=", "tf", ".", "floor", "(", "random_tensor", ")", "\n", "output", "=", "input", "*", "dropout_mask", "\n", "", "elif", "mode", "==", "\"infer\"", ":", "\n", "            ", "output", "=", "input", "*", "self", ".", "_keep_prob", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.DropoutLayer.trainable_params": [[249, 251], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BiasLayer.__init__": [[253, 255], ["tensorflow.Variable", "numpy.zeros"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ")", ":", "\n", "        ", "self", ".", "_b", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"b\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BiasLayer.apply": [[257, 260], ["tensorflow.reshape"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "\n", "# self._b.shape[0] should already be input.shape[1] number of input channels.", "\n", "        ", "return", "input", "+", "tf", ".", "reshape", "(", "self", ".", "_b", ",", "shape", "=", "[", "1", ",", "input", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BiasLayer.trainable_params": [[261, 263], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "_b", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BatchNormLayer.__init__": [[267, 282], ["tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.compat.v1.placeholder", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "moving_avg_length", ",", "n_channels", ")", ":", "\n", "        ", "self", ".", "_moving_avg_length", "=", "moving_avg_length", "# integer. The number of iterations (batches) over which to compute a moving average.", "\n", "self", ".", "_g", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"gBn\"", ")", "\n", "self", ".", "_b", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"bBn\"", ")", "\n", "#for moving average:", "\n", "self", ".", "_array_mus_for_moving_avg", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "moving_avg_length", ",", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"muBnsForRollingAverage\"", ")", "\n", "self", ".", "_array_vars_for_moving_avg", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "moving_avg_length", ",", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"varBnsForRollingAverage\"", ")", "\n", "self", ".", "_new_mu_batch", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"sharedNewMu_B\"", ")", "# Value will be assigned every training-iteration.", "\n", "self", ".", "_new_var_batch", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", ",", "name", "=", "\"sharedNewVar_B\"", ")", "\n", "# Create ops for updating the matrices with the bn inference stats.", "\n", "self", ".", "_tf_plchld_int32", "=", "tf", ".", "compat", ".", "v1", ".", "placeholder", "(", "dtype", "=", "\"int32\"", ",", "name", "=", "\"tf_plchld_int32\"", ")", "# convenience for tf.assign", "\n", "self", ".", "_op_update_mtrx_bn_inf_mu", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_array_mus_for_moving_avg", "[", "self", ".", "_tf_plchld_int32", "]", ",", "self", ".", "_new_mu_batch", ")", "# Cant it just take tensor? self._latest_mu_batch?", "\n", "self", ".", "_op_update_mtrx_bn_inf_var", "=", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "self", ".", "_array_vars_for_moving_avg", "[", "self", ".", "_tf_plchld_int32", "]", ",", "self", ".", "_new_var_batch", ")", "\n", "\n", "self", ".", "_idx_where_moving_avg_is", "=", "0", "#Index in the rolling-average matrices of the layers, of the entry to update in the next batch. Could be tf.Var.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BatchNormLayer.trainable_params": [[283, 285], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "_g", ",", "self", ".", "_b", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BatchNormLayer.apply": [[286, 311], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.reshape", "numpy.finfo", "tensorflow.nn.moments", "tensorflow.sqrt", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "NotImplementedError"], "methods", ["None"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ",", "e1", "=", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "tiny", ")", ":", "\n", "# mode: String in [\"train\", \"infer\"]", "\n", "        ", "n_channs", "=", "input", ".", "shape", "[", "1", "]", "\n", "\n", "if", "mode", "==", "\"train\"", ":", "\n", "            ", "self", ".", "_new_mu_batch_t", ",", "self", ".", "_new_var_batch_t", "=", "tf", ".", "nn", ".", "moments", "(", "input", ",", "axes", "=", "[", "0", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "mu", "=", "self", ".", "_new_mu_batch_t", "\n", "var", "=", "self", ".", "_new_var_batch_t", "\n", "", "elif", "mode", "==", "\"infer\"", ":", "\n", "            ", "mu", "=", "tf", ".", "reduce_mean", "(", "self", ".", "_array_mus_for_moving_avg", ",", "axis", "=", "0", ")", "\n", "var", "=", "tf", ".", "reduce_mean", "(", "self", ".", "_array_vars_for_moving_avg", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "# Reshape for broadcast.", "\n", "", "g_resh", "=", "tf", ".", "reshape", "(", "self", ".", "_g", ",", "shape", "=", "[", "1", ",", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "b_resh", "=", "tf", ".", "reshape", "(", "self", ".", "_b", ",", "shape", "=", "[", "1", ",", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "mu", "=", "tf", ".", "reshape", "(", "mu", ",", "shape", "=", "[", "1", ",", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "var", "=", "tf", ".", "reshape", "(", "var", ",", "shape", "=", "[", "1", ",", "n_channs", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "# Normalize", "\n", "norm_inp", "=", "(", "input", "-", "mu", ")", "/", "tf", ".", "sqrt", "(", "var", "+", "e1", ")", "# e1 should come OUT of the sqrt! ", "\n", "norm_inp", "=", "g_resh", "*", "norm_inp", "+", "b_resh", "\n", "\n", "# Returns mu_batch, var_batch to update the moving average afterwards (during training)", "\n", "return", "norm_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BatchNormLayer.get_update_ops_for_bn_moving_avg": [[312, 316], ["tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign"], "methods", ["None"], ["", "def", "get_update_ops_for_bn_moving_avg", "(", "self", ")", ":", "# I think this is utterly useless.", "\n", "# This function or something similar should stay, even if I clean the BN rolling average.", "\n", "        ", "return", "[", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "self", ".", "_new_mu_batch", ",", "value", "=", "self", ".", "_new_mu_batch_t", ",", "validate_shape", "=", "True", ")", ",", "\n", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "self", ".", "_new_var_batch", ",", "value", "=", "self", ".", "_new_var_batch_t", ",", "validate_shape", "=", "True", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.BatchNormLayer.update_arrays_of_bn_moving_avg": [[317, 321], ["sessionTf.run", "sessionTf.run"], "methods", ["None"], ["", "def", "update_arrays_of_bn_moving_avg", "(", "self", ",", "sessionTf", ")", ":", "\n", "            ", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_update_mtrx_bn_inf_mu", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_int32", ":", "self", ".", "_idx_where_moving_avg_is", "}", ")", "\n", "sessionTf", ".", "run", "(", "fetches", "=", "self", ".", "_op_update_mtrx_bn_inf_var", ",", "feed_dict", "=", "{", "self", ".", "_tf_plchld_int32", ":", "self", ".", "_idx_where_moving_avg_is", "}", ")", "\n", "self", ".", "_idx_where_moving_avg_is", "=", "(", "self", ".", "_idx_where_moving_avg_is", "+", "1", ")", "%", "self", ".", "_moving_avg_length", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PreluLayer.__init__": [[336, 338], ["tensorflow.Variable", "numpy.ones"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "alpha", "=", "0.01", ")", ":", "\n", "        ", "self", ".", "_a", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "n_channels", ")", ",", "dtype", "=", "'float32'", ")", "*", "alpha", ",", "name", "=", "\"aPrelu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PreluLayer.apply": [[339, 342], ["deepmedic.prelu", "tensorflow.reshape"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.prelu"], ["", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "\n", "# input is a tensor of shape (batchSize, FMs, r, c, z)", "\n", "        ", "return", "ops", ".", "prelu", "(", "input", ",", "tf", ".", "reshape", "(", "self", ".", "_a", ",", "shape", "=", "[", "1", ",", "input", ".", "shape", "[", "1", "]", ",", "1", ",", "1", ",", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.PreluLayer.trainable_params": [[343, 345], ["None"], "methods", ["None"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "_a", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.IdentityLayer.apply": [[347, 348], ["None"], "methods", ["None"], ["    ", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "return", "input", "\n", "def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.IdentityLayer.trainable_params": [[348, 349], ["None"], "methods", ["None"], ["def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ReluLayer.apply": [[351, 352], ["deepmedic.relu"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.relu"], ["    ", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "return", "ops", ".", "relu", "(", "input", ")", "\n", "def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.ReluLayer.trainable_params": [[352, 353], ["None"], "methods", ["None"], ["def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.EluLayer.apply": [[355, 356], ["deepmedic.elu"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.elu"], ["    ", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "return", "ops", ".", "elu", "(", "input", ")", "\n", "def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.EluLayer.trainable_params": [[356, 357], ["None"], "methods", ["None"], ["def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.SeluLayer.apply": [[359, 360], ["deepmedic.selu"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.selu"], ["    ", "def", "apply", "(", "self", ",", "input", ",", "_", ")", ":", "return", "ops", ".", "selu", "(", "input", ")", "\n", "def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.SeluLayer.trainable_params": [[360, 361], ["None"], "methods", ["None"], ["def", "trainable_params", "(", "self", ")", ":", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.get_act_layer": [[323, 334], ["layers.IdentityLayer", "layers.ReluLayer", "layers.PreluLayer", "layers.EluLayer", "layers.SeluLayer"], "function", ["None"], ["", "", "def", "get_act_layer", "(", "act_str", ",", "n_fms_in", ")", ":", "\n", "    ", "if", "act_str", "==", "\"linear\"", ":", "# -1 stands for \"no nonlinearity\". Used for input layers of the pathway.", "\n", "        ", "return", "IdentityLayer", "(", ")", "\n", "", "elif", "act_str", "==", "\"relu\"", ":", "\n", "        ", "return", "ReluLayer", "(", ")", "\n", "", "elif", "act_str", "==", "\"prelu\"", ":", "\n", "        ", "return", "PreluLayer", "(", "n_fms_in", ")", "\n", "", "elif", "act_str", "==", "\"elu\"", ":", "\n", "        ", "return", "EluLayer", "(", ")", "\n", "", "elif", "act_str", "==", "\"selu\"", ":", "\n", "        ", "return", "SeluLayer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.__init__": [[30, 44], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# === Basic architecture parameters === ", "\n", "        ", "self", ".", "_n_fms_in", "=", "None", "\n", "self", ".", "_n_fms_out", "=", "None", "\n", "\n", "#=== All layers that the block applies ===", "\n", "self", ".", "_layers", "=", "[", "]", "\n", "self", ".", "_bn_l", "=", "None", "# Keep track to update moving avg. Only when rollingAverageForBn>0 AND use_bn, with the latter used for the 1st layers of pathways (on image).", "\n", "\n", "# === Output of the block ===", "\n", "self", ".", "output", "=", "{", "\"train\"", ":", "None", ",", "\"val\"", ":", "None", ",", "\"test\"", ":", "None", "}", "# TODO: Remove for eigen.", "\n", "\n", "# ==== Target Block Connected to that layer (softmax, regression, auxiliary loss etc), if any ======", "\n", "self", ".", "_target_blocks", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.rec_field": [[45, 53], ["layer.rec_field"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["", "def", "rec_field", "(", "self", ",", "rf_at_inp", "=", "[", "1", ",", "1", ",", "1", "]", ",", "stride_rf_at_inp", "=", "[", "1", ",", "1", ",", "1", "]", ")", ":", "\n", "# Returns: Rf of neurons at the output of the final layer of the block, with respect to input.", "\n", "#          Stride of rf at the block's output wrt input (how much it shifts at inp if we shift 1 neuron at out)", "\n", "        ", "rf_prev_layer", "=", "rf_at_inp", "\n", "stride_rf_prev_layer", "=", "stride_rf_at_inp", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "rf_prev_layer", ",", "stride_rf_prev_layer", "=", "layer", ".", "rec_field", "(", "rf_prev_layer", ",", "stride_rf_prev_layer", ")", "\n", "", "return", "rf_prev_layer", ",", "stride_rf_prev_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.calc_outp_dims_given_inp": [[54, 59], ["layer.calc_outp_dims_given_inp"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "\n", "        ", "outp_dims_prev_layer", "=", "inp_dims", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "outp_dims_prev_layer", "=", "layer", ".", "calc_outp_dims_given_inp", "(", "outp_dims_prev_layer", ")", "\n", "", "return", "outp_dims_prev_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.calc_inp_dims_given_outp": [[60, 65], ["layer.calc_inp_dims_given_outp"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_inp_dims_given_outp"], ["", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "inp_dims_deeper_layer", "=", "outp_dims", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "inp_dims_deeper_layer", "=", "layer", ".", "calc_inp_dims_given_outp", "(", "inp_dims_deeper_layer", ")", "\n", "", "return", "inp_dims_deeper_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.get_n_fms_in": [[67, 69], ["None"], "methods", ["None"], ["", "def", "get_n_fms_in", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_fms_in", "\n", "", "def", "get_n_fms_out", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.get_n_fms_out": [[69, 71], ["None"], "methods", ["None"], ["", "def", "get_n_fms_out", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_fms_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.fm_activations": [[72, 74], ["None"], "methods", ["None"], ["", "def", "fm_activations", "(", "self", ",", "indices_of_fms_in_layer_to_visualise_from_to_exclusive", ")", ":", "\n", "        ", "return", "self", ".", "output", "[", "\"test\"", "]", "[", ":", ",", "indices_of_fms_in_layer_to_visualise_from_to_exclusive", "[", "0", "]", ":", "indices_of_fms_in_layer_to_visualise_from_to_exclusive", "[", "1", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.apply": [[76, 82], ["layer.apply"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "# mode: 'train' or 'infer'", "\n", "        ", "signal", "=", "input", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "signal", "=", "layer", ".", "apply", "(", "signal", ",", "mode", ")", "\n", "", "return", "signal", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.connect_target_block": [[83, 86], ["None"], "methods", ["None"], ["", "def", "connect_target_block", "(", "self", ",", "new_target_block_instance", ")", ":", "\n", "# new_target_block_instance : eg softmax layer. Future: Regression layer, or other auxiliary classifiers.", "\n", "        ", "self", ".", "_target_blocks", "+=", "[", "new_target_block_instance", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params": [[87, 94], ["layer.trainable_params", "block.trainable_params"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.trainable_params"], ["", "def", "trainable_params", "(", "self", ")", ":", "\n", "        ", "total_params", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "total_params", "+=", "layer", ".", "trainable_params", "(", ")", "# concat lists", "\n", "", "for", "block", "in", "self", ".", "_target_blocks", ":", "\n", "            ", "total_params", "+=", "block", ".", "trainable_params", "(", ")", "# concat lists", "\n", "", "return", "total_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg": [[95, 102], ["layer.params_for_L1_L2_reg", "block.params_for_L1_L2_reg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.params_for_L1_L2_reg"], ["", "def", "params_for_L1_L2_reg", "(", "self", ")", ":", "\n", "        ", "total_params", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "_layers", ":", "\n", "            ", "total_params", "+=", "layer", ".", "params_for_L1_L2_reg", "(", ")", "\n", "", "for", "block", "in", "self", ".", "_target_blocks", ":", "\n", "            ", "total_params", "+=", "block", ".", "params_for_L1_L2_reg", "(", ")", "\n", "", "return", "total_params", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.update_arrays_of_bn_moving_avg": [[103, 107], ["blocks.Block._bn_l.update_arrays_of_bn_moving_avg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.update_arrays_of_bn_moving_avg"], ["", "def", "update_arrays_of_bn_moving_avg", "(", "self", ",", "sessionTf", ")", ":", "\n", "# This function should be erazed when I reimplement the Rolling average.", "\n", "        ", "if", "self", ".", "_bn_l", "is", "not", "None", ":", "\n", "            ", "self", ".", "_bn_l", ".", "update_arrays_of_bn_moving_avg", "(", "sessionTf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.get_update_ops_for_bn_moving_avg": [[108, 110], ["blocks.Block._bn_l.get_update_ops_for_bn_moving_avg"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.Block.get_update_ops_for_bn_moving_avg"], ["", "", "def", "get_update_ops_for_bn_moving_avg", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_bn_l", ".", "get_update_ops_for_bn_moving_avg", "(", ")", "if", "self", ".", "_bn_l", "is", "not", "None", "else", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.ConvBlock.__init__": [[115, 117], ["blocks.Block.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "Block", ".", "__init__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.ConvBlock.build": [[119, 172], ["deepmedic.get_act_layer", "blocks.ConvBlock._layers.append", "deepmedic.DropoutLayer", "blocks.ConvBlock._layers.append", "blocks.ConvBlock._create_conv_layer", "blocks.ConvBlock._layers.append", "deepmedic.BatchNormLayer", "blocks.ConvBlock._layers.append", "deepmedic.BiasLayer", "blocks.ConvBlock._layers.append", "len", "PoolingLayer", "blocks.ConvBlock._layers.append"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.layers.get_act_layer", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.LowRankConvBlock._create_conv_layer"], ["", "def", "build", "(", "self", ",", "\n", "rng", ",", "\n", "n_fms_in", ",", "\n", "n_fms_out", ",", "\n", "conv_kernel_dims", ",", "\n", "pool_prms", ",", "# Can be []", "\n", "conv_w_init_method", ",", "\n", "conv_pad_mode", ",", "\n", "use_bn", ",", "\n", "moving_avg_length", ",", "#If this is <= 0, we are not using BatchNormalization, even if above is True.", "\n", "activ_func", "=", "\"relu\"", ",", "\n", "dropout_rate", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"\n        param rng: numpy.random.RandomState used to initialize weights\n        param inputToLayer: tensor5 of shape inputToLayerShape\n        param filterShape: (number of filters, num input feature maps,\n                            filter height, filter width, filter depth)\n        param inputToLayerShape: (batch size, num input feature maps,\n                            image height, image width, filter depth)\n        use_bn: True of False. Used to not allow doing BN on first layers straight on image, even if rollingAvForBnOverThayManyBatches > 0.\n        \"\"\"", "\n", "self", ".", "_n_fms_in", "=", "n_fms_in", "\n", "self", ".", "_n_fms_out", "=", "n_fms_out", "\n", "\n", "#  Order of what is applied, ala He et al \"Identity Mappings in Deep Residual Networks\" 2016", "\n", "#  Input -> [ BatchNorm OR biases applied] -> NonLinearity -> DropOut -> Pooling --> Conv ]", "\n", "\n", "#------------------ Batch Normalization ------------------", "\n", "if", "use_bn", "and", "moving_avg_length", ">", "0", ":", "\n", "            ", "self", ".", "_bn_l", "=", "dm_layers", ".", "BatchNormLayer", "(", "moving_avg_length", ",", "n_channels", "=", "n_fms_in", ")", "\n", "self", ".", "_layers", ".", "append", "(", "self", ".", "_bn_l", ")", "\n", "", "else", ":", "#Not using batch normalization", "\n", "#make the bias terms and apply them. Like the old days before BN's own learnt bias terms.", "\n", "            ", "bias_l", "=", "dm_layers", ".", "BiasLayer", "(", "n_fms_in", ")", "\n", "self", ".", "_layers", ".", "append", "(", "bias_l", ")", "\n", "\n", "#------------ Apply Activation/ non-linearity -----------", "\n", "", "act_l", "=", "dm_layers", ".", "get_act_layer", "(", "activ_func", ",", "n_fms_in", ")", "\n", "self", ".", "_layers", ".", "append", "(", "act_l", ")", "\n", "\n", "#------------- Dropout --------------", "\n", "dropout_l", "=", "dm_layers", ".", "DropoutLayer", "(", "dropout_rate", ",", "rng", ")", "\n", "self", ".", "_layers", ".", "append", "(", "dropout_l", ")", "\n", "\n", "#-----------  Pooling ----------------------------------", "\n", "if", "len", "(", "pool_prms", ")", ">", "0", ":", "#Max pooling is actually happening here...", "\n", "# if len == 0, pool_prms == [], no max pooling before this conv.", "\n", "            ", "pooling_l", "=", "PoolingLayer", "(", "pool_prms", "[", "0", "]", ",", "pool_prms", "[", "1", "]", ",", "pool_prms", "[", "2", "]", ",", "pool_prms", "[", "3", "]", ")", "\n", "self", ".", "_layers", ".", "append", "(", "pooling_l", ")", "\n", "\n", "# --------- Convolution ---------------------------------", "\n", "", "conv_l", "=", "self", ".", "_create_conv_layer", "(", "n_fms_in", ",", "n_fms_out", ",", "conv_kernel_dims", ",", "conv_w_init_method", ",", "conv_pad_mode", ",", "rng", ")", "\n", "self", ".", "_layers", ".", "append", "(", "conv_l", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.ConvBlock._create_conv_layer": [[173, 175], ["deepmedic.ConvolutionalLayer"], "methods", ["None"], ["", "def", "_create_conv_layer", "(", "self", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", ":", "\n", "        ", "return", "dm_layers", ".", "ConvolutionalLayer", "(", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.LowRankConvBlock.__init__": [[179, 182], ["blocks.ConvBlock.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "rank", "=", "2", ")", ":", "\n", "        ", "ConvBlock", ".", "__init__", "(", "self", ")", "\n", "self", ".", "_rank", "=", "rank", "# 1 or 2 dimensions", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.LowRankConvBlock._create_conv_layer": [[184, 186], ["deepmedic.LowRankConvolutionalLayer"], "methods", ["None"], ["", "def", "_create_conv_layer", "(", "self", ",", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", ":", "\n", "        ", "return", "dm_layers", ".", "LowRankConvolutionalLayer", "(", "fms_in", ",", "fms_out", ",", "conv_kernel_dims", ",", "init_method", ",", "pad_mode", ",", "rng", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.__init__": [[190, 193], ["blocks.Block.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "Block", ".", "__init__", "(", "self", ")", "\n", "self", ".", "_temperature", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.build": [[194, 206], ["deepmedic.BiasLayer", "blocks.SoftmaxBlock._layers.append"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "\n", "rng", ",", "\n", "n_fms", ",", "\n", "t", "=", "1", ")", ":", "\n", "# t: temperature. Scalar", "\n", "\n", "        ", "self", ".", "_n_fms_in", "=", "n_fms", "\n", "self", ".", "_n_fms_out", "=", "n_fms", "\n", "self", ".", "_temperature", "=", "t", "\n", "\n", "self", ".", "_bias_l", "=", "dm_layers", ".", "BiasLayer", "(", "n_fms", ")", "\n", "self", ".", "_layers", ".", "append", "(", "self", ".", "_bias_l", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.apply": [[207, 214], ["blocks.SoftmaxBlock._bias_l.apply", "tensorflow.nn.softmax"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ")", ":", "\n", "# At this last classification layer, the conv output needs to have bias added before the softmax.", "\n", "# NOTE: So, two biases are associated with this layer. self.b which is added in the ouput of the previous layer's output of conv,", "\n", "# and this self._bClassLayer that is added only to this final output before the softmax.       ", "\n", "        ", "logits", "=", "self", ".", "_bias_l", ".", "apply", "(", "input", ",", "mode", ")", "\n", "p_y_given_x", "=", "tf", ".", "nn", ".", "softmax", "(", "logits", "/", "self", ".", "_temperature", ",", "axis", "=", "1", ")", "\n", "return", "p_y_given_x", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.get_rp_rn_tp_tn": [[216, 241], ["tensorflow.argmax", "range", "tensorflow.equal", "tensorflow.logical_not", "tensorflow.equal", "tensorflow.logical_not", "tensorflow.logical_and", "tensorflow.logical_and", "list_num_rp_rn_tp_tn_per_class.append", "list_num_rp_rn_tp_tn_per_class.append", "list_num_rp_rn_tp_tn_per_class.append", "list_num_rp_rn_tp_tn_per_class.append", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast"], "methods", ["None"], ["", "def", "get_rp_rn_tp_tn", "(", "self", ",", "p_y_given_x", ",", "y_gt", ")", ":", "\n", "# The returned list has (numberOfClasses)x4 integers: >numberOfRealPositives, numberOfRealNegatives, numberOfTruePredictedPositives, numberOfTruePredictedNegatives< for each class (incl background).", "\n", "# Order in the list is the natural order of the classes (ie class-0 RP,RN,TPP,TPN, class-1 RP,RN,TPP,TPN, class-2 RP,RN,TPP,TPN ...)", "\n", "# param y_gt: y_gt = T.itensor4('y'). Dimensions [batchSize, r, c, z]", "\n", "# mode: 'train' or 'infer'", "\n", "        ", "y_pred", "=", "tf", ".", "argmax", "(", "p_y_given_x", ",", "axis", "=", "1", ")", "\n", "\n", "list_num_rp_rn_tp_tn_per_class", "=", "[", "]", "\n", "\n", "for", "class_i", "in", "range", "(", "0", ",", "self", ".", "_n_fms_out", ")", ":", "\n", "#Number of Real Positive, Real Negatives, True Predicted Positives and True Predicted Negatives are reported PER CLASS (first for WHOLE).", "\n", "            ", "is_rp", "=", "tf", ".", "equal", "(", "y_gt", ",", "class_i", ")", "\n", "is_rn", "=", "tf", ".", "logical_not", "(", "is_rp", ")", "\n", "\n", "is_predicted_pos", "=", "tf", ".", "equal", "(", "y_pred", ",", "class_i", ")", "\n", "is_predicted_neg", "=", "tf", ".", "logical_not", "(", "is_predicted_pos", ")", "\n", "is_tp", "=", "tf", ".", "logical_and", "(", "is_rp", ",", "is_predicted_pos", ")", "\n", "is_tn", "=", "tf", ".", "logical_and", "(", "is_rn", ",", "is_predicted_neg", ")", "\n", "\n", "list_num_rp_rn_tp_tn_per_class", ".", "append", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "cast", "(", "is_rp", ",", "dtype", "=", "\"int32\"", ")", ")", ")", "\n", "list_num_rp_rn_tp_tn_per_class", ".", "append", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "cast", "(", "is_rn", ",", "dtype", "=", "\"int32\"", ")", ")", ")", "\n", "list_num_rp_rn_tp_tn_per_class", ".", "append", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "cast", "(", "is_tp", ",", "dtype", "=", "\"int32\"", ")", ")", ")", "\n", "list_num_rp_rn_tp_tn_per_class", ".", "append", "(", "tf", ".", "reduce_sum", "(", "tf", ".", "cast", "(", "is_tn", ",", "dtype", "=", "\"int32\"", ")", ")", ")", "\n", "\n", "", "return", "list_num_rp_rn_tp_tn_per_class", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.blocks.SoftmaxBlock.mean_error": [[243, 256], ["y_gt.dtype.startswith", "tensorflow.logical_not", "tensorflow.reduce_mean", "NotImplementedError", "tensorflow.equal"], "methods", ["None"], ["", "def", "mean_error", "(", "self", ",", "y_pred", ",", "y_gt", ")", ":", "\n", "# Returns float = number of errors / number of examples of the minibatch ; [0., 1.]", "\n", "# y_gt = T.itensor4('y'). Dimensions [batchSize, r, c, z]", "\n", "\n", "# check if y is of the correct datatype", "\n", "        ", "if", "y_gt", ".", "dtype", ".", "startswith", "(", "'int'", ")", ":", "\n", "# the T.neq operator returns a vector of 0s and 1s, where 1", "\n", "# represents a mistake in prediction", "\n", "            ", "tneq", "=", "tf", ".", "logical_not", "(", "tf", ".", "equal", "(", "y_pred", ",", "y_gt", ")", ")", "\n", "mean_error", "=", "tf", ".", "reduce_mean", "(", "tneq", ")", "\n", "return", "mean_error", "#The percentage of the predictions that is not the correct class.", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Not implemented behaviour for y_gt.dtype different than int.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathwayTypes.PathwayTypes.pTypes": [[19, 22], ["None"], "methods", ["None"], ["def", "pTypes", "(", "self", ")", ":", "#To iterate over if needed.", "\n", "# This enumeration is also the index in various datastructures ala: [ [listForNorm], [listForSubs], [listForFc] ] ", "\n", "        ", "return", "[", "self", ".", "NORM", ",", "self", ".", "SUBS", ",", "self", ".", "FC", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.x_entr": [[13, 29], ["tensorflow.math.log", "tensorflow.reshape", "tensorflow.one_hot", "tensorflow.cast", "tensorflow.reduce_prod", "tensorflow.reduce_sum", "tensorflow.shape", "tensorflow.shape", "tensorflow.shape"], "function", ["None"], ["def", "x_entr", "(", "p_y_given_x_train", ",", "y_gt", ",", "weightPerClass", ",", "eps", "=", "1e-6", ")", ":", "\n", "# p_y_given_x_train : tensor5 [batchSize, classes, r, c, z]", "\n", "# y: T.itensor4('y'). Dimensions [batchSize, r, c, z]", "\n", "# weightPerClass is a vector with 1 element per class.", "\n", "\n", "#Weighting the cost of the different classes in the cost-function, in order to counter class imbalance.", "\n", "    ", "log_p_y_given_x_train", "=", "tf", ".", "math", ".", "log", "(", "p_y_given_x_train", "+", "eps", ")", "\n", "\n", "weightPerClass5D", "=", "tf", ".", "reshape", "(", "weightPerClass", ",", "shape", "=", "[", "1", ",", "tf", ".", "shape", "(", "p_y_given_x_train", ")", "[", "1", "]", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "weighted_log_p_y_given_x_train", "=", "log_p_y_given_x_train", "*", "weightPerClass5D", "\n", "\n", "y_one_hot", "=", "tf", ".", "one_hot", "(", "indices", "=", "y_gt", ",", "depth", "=", "tf", ".", "shape", "(", "p_y_given_x_train", ")", "[", "1", "]", ",", "axis", "=", "1", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "num_samples", "=", "tf", ".", "cast", "(", "tf", ".", "reduce_prod", "(", "tf", ".", "shape", "(", "y_gt", ")", ")", ",", "\"float32\"", ")", "\n", "\n", "return", "-", "(", "1.", "/", "num_samples", ")", "*", "tf", ".", "reduce_sum", "(", "weighted_log_p_y_given_x_train", "*", "y_one_hot", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.iou": [[31, 45], ["tensorflow.one_hot", "tensorflow.cast", "tensorflow.reduce_sum", "tensorflow.reduce_mean", "tensorflow.less", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.shape"], "function", ["None"], ["", "def", "iou", "(", "p_y_given_x_train", ",", "y_gt", ",", "eps", "=", "1e-5", ")", ":", "\n", "# Intersection-Over-Union / Jaccard: https://en.wikipedia.org/wiki/Jaccard_index", "\n", "# Analysed in: Nowozin S, Optimal Decisions from Probabilistic Models: the Intersection-over-Union Case, CVPR 2014", "\n", "# First computes IOU per class. Finally averages over the class-ious.", "\n", "# p_y_given_x_train : tensor5 [batchSize, classes, r, c, z]", "\n", "# y: T.itensor4('y'). Dimensions [batchSize, r, c, z]", "\n", "    ", "y_one_hot", "=", "tf", ".", "one_hot", "(", "indices", "=", "y_gt", ",", "depth", "=", "tf", ".", "shape", "(", "p_y_given_x_train", ")", "[", "1", "]", ",", "axis", "=", "1", ",", "dtype", "=", "\"float32\"", ")", "\n", "ones_at_real_negs", "=", "tf", ".", "cast", "(", "tf", ".", "less", "(", "y_one_hot", ",", "0.0001", ")", ",", "dtype", "=", "\"float32\"", ")", "# tf.equal(y_one_hot,0), but less may be more stable with floats.", "\n", "numer", "=", "tf", ".", "reduce_sum", "(", "p_y_given_x_train", "*", "y_one_hot", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "# 2 * TP", "\n", "denom", "=", "tf", ".", "reduce_sum", "(", "p_y_given_x_train", "*", "ones_at_real_negs", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "+", "tf", ".", "reduce_sum", "(", "y_one_hot", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "# Pred + RP", "\n", "iou", "=", "(", "numer", "+", "eps", ")", "/", "(", "denom", "+", "eps", ")", "# eps in both num/den => dsc=1 when class missing.", "\n", "av_class_iou", "=", "tf", ".", "reduce_mean", "(", "iou", ")", "# Along the class-axis. Mean DSC of classes. ", "\n", "cost", "=", "1.", "-", "av_class_iou", "\n", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.dsc": [[47, 57], ["tensorflow.one_hot", "tensorflow.reduce_mean", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.shape"], "function", ["None"], ["", "def", "dsc", "(", "p_y_given_x_train", ",", "y_gt", ",", "eps", "=", "1e-5", ")", ":", "\n", "# Similar to Intersection-Over-Union / Jaccard above.", "\n", "# Dice coefficient: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient", "\n", "    ", "y_one_hot", "=", "tf", ".", "one_hot", "(", "indices", "=", "y_gt", ",", "depth", "=", "tf", ".", "shape", "(", "p_y_given_x_train", ")", "[", "1", "]", ",", "axis", "=", "1", ",", "dtype", "=", "\"float32\"", ")", "\n", "numer", "=", "2.", "*", "tf", ".", "reduce_sum", "(", "p_y_given_x_train", "*", "y_one_hot", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "# 2 * TP", "\n", "denom", "=", "tf", ".", "reduce_sum", "(", "p_y_given_x_train", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "+", "tf", ".", "reduce_sum", "(", "y_one_hot", ",", "axis", "=", "(", "0", ",", "2", ",", "3", ",", "4", ")", ")", "# Pred + RP", "\n", "dsc", "=", "(", "numer", "+", "eps", ")", "/", "(", "denom", "+", "eps", ")", "# eps in both num/den => dsc=1 when class missing.", "\n", "av_class_dsc", "=", "tf", ".", "reduce_mean", "(", "dsc", ")", "# Along the class-axis. Mean DSC of classes. ", "\n", "cost", "=", "1.", "-", "av_class_dsc", "\n", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L1": [[58, 64], ["tensorflow.reduce_sum", "tensorflow.abs"], "function", ["None"], ["", "def", "cost_L1", "(", "prms", ")", ":", "\n", "# prms: list of tensors", "\n", "    ", "cost", "=", "0", "\n", "for", "prm", "in", "prms", ":", "\n", "        ", "cost", "+=", "tf", ".", "reduce_sum", "(", "tf", ".", "abs", "(", "prm", ")", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.cost_functions.cost_L2": [[65, 71], ["tensorflow.reduce_sum"], "function", ["None"], ["", "def", "cost_L2", "(", "prms", ")", ":", "#Called for L2 weigths regularisation", "\n", "# prms: list of tensors", "\n", "    ", "cost", "=", "0", "\n", "for", "prm", "in", "prms", ":", "\n", "        ", "cost", "+=", "tf", ".", "reduce_sum", "(", "prm", "**", "2", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.__init__": [[27, 40], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pName", "=", "None", ")", ":", "\n", "        ", "self", ".", "_pName", "=", "pName", "\n", "self", ".", "_pType", "=", "None", "# Pathway Type.", "\n", "\n", "# === Input to the pathway ===", "\n", "self", ".", "_n_fms_in", "=", "None", "\n", "# === Basic architecture parameters ===", "\n", "self", ".", "_blocks", "=", "[", "]", "\n", "self", ".", "_subs_factor", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "self", ".", "_inds_of_blocks_for_res_conns_at_out", "=", "None", "\n", "\n", "# === Output of the block ===", "\n", "self", ".", "_n_fms_out", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_in": [[42, 44], ["None"], "methods", ["None"], ["", "def", "get_n_fms_in", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_fms_in", "\n", "", "def", "get_n_fms_out", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_n_fms_out": [[44, 46], ["None"], "methods", ["None"], ["", "def", "get_n_fms_out", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_fms_out", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply": [[47, 77], ["enumerate", "log.print3", "block.apply", "log.print3", "log.print3", "log.print3", "deepmedic.make_residual_connection", "str", "str", "str", "str", "str", "str", "pathways.Pathway.getStringType", "str", "pathways.Pathway.getStringType"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.apply", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.make_residual_connection", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.getStringType", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.getStringType"], ["", "def", "apply", "(", "self", ",", "input", ",", "mode", ",", "train_val_test", ",", "verbose", "=", "False", ",", "log", "=", "None", ")", ":", "\n", "# mode: 'train' / 'infer'", "\n", "# train_val_test: TEMPORARY. ONLY TO RETURN FMS. REMOVE IN END OF REFACTORING.", "\n", "        ", "if", "verbose", ":", "\n", "            ", "log", ".", "print3", "(", "\"Pathway [\"", "+", "str", "(", "self", ".", "getStringType", "(", ")", ")", "+", "\"], Mode: [\"", "+", "mode", "+", "\"], Input's Shape: \"", "+", "str", "(", "input", ".", "shape", ")", ")", "\n", "\n", "", "input_to_prev_layer", "=", "None", "\n", "input_to_next_layer", "=", "input", "\n", "\n", "for", "idx", ",", "block", "in", "enumerate", "(", "self", ".", "_blocks", ")", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "log", ".", "print3", "(", "\"\\tBlock [\"", "+", "str", "(", "idx", ")", "+", "\"], Mode: [\"", "+", "mode", "+", "\"], Input's Shape: \"", "+", "str", "(", "input_to_next_layer", ".", "shape", ")", ")", "\n", "\n", "", "out", "=", "block", ".", "apply", "(", "input_to_next_layer", ",", "mode", ")", "\n", "block", ".", "output", "[", "train_val_test", "]", "=", "out", "# HACK TEMPORARY. ONLY USED FOR RETURNING FMS.", "\n", "if", "idx", "not", "in", "self", ".", "_inds_of_blocks_for_res_conns_at_out", ":", "#not a residual connecting here", "\n", "                ", "input_to_prev_layer", "=", "input_to_next_layer", "\n", "input_to_next_layer", "=", "out", "\n", "", "else", ":", "#make residual connection", "\n", "                ", "assert", "idx", ">", "0", "# The very first block (index 0), should never be provided for now. Cause I am connecting 2 layers back.", "\n", "log", ".", "print3", "(", "\"\\tResidual-Connection made between: output of [Block_\"", "+", "str", "(", "idx", ")", "+", "\"] & input of previous block.\"", ")", "\n", "out_res", "=", "ops", ".", "make_residual_connection", "(", "input_to_prev_layer", ",", "out", ")", "\n", "input_to_prev_layer", "=", "input_to_next_layer", "\n", "input_to_next_layer", "=", "out_res", "\n", "\n", "", "", "if", "verbose", ":", "\n", "            ", "log", ".", "print3", "(", "\"Pathway [\"", "+", "str", "(", "self", ".", "getStringType", "(", ")", ")", "+", "\"], Mode: [\"", "+", "mode", "+", "\"], Output's Shape: \"", "+", "str", "(", "input_to_next_layer", ".", "shape", ")", ")", "\n", "#log.print3(\"Pathway [\" + str(self.getStringType()) + \"] done.\")", "\n", "\n", "", "return", "input_to_next_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field": [[78, 86], ["block.rec_field"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.rec_field"], ["", "def", "rec_field", "(", "self", ",", "rf_at_inp", "=", "[", "1", ",", "1", ",", "1", "]", ",", "stride_rf_at_inp", "=", "[", "1", ",", "1", ",", "1", "]", ")", ":", "\n", "# Returns: Rf of neurons at the output of the final layer of the block, with respect to input.", "\n", "#          Stride of rf at the block's output wrt input (how much it shifts at inp if we shift 1 neuron at out)", "\n", "        ", "rf_prev_block", "=", "rf_at_inp", "\n", "stride_rf_prev_block", "=", "stride_rf_at_inp", "\n", "for", "block", "in", "self", ".", "_blocks", ":", "\n", "            ", "rf_prev_block", ",", "stride_rf_prev_block", "=", "block", ".", "rec_field", "(", "rf_prev_block", ",", "stride_rf_prev_block", ")", "\n", "", "return", "rf_prev_block", ",", "stride_rf_prev_block", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp": [[87, 92], ["block.calc_outp_dims_given_inp"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_outp_dims_given_inp"], ["", "def", "calc_outp_dims_given_inp", "(", "self", ",", "inp_dims", ")", ":", "\n", "        ", "outp_dims_prev_block", "=", "inp_dims", "\n", "for", "block", "in", "self", ".", "_blocks", ":", "\n", "            ", "outp_dims_prev_block", "=", "block", ".", "calc_outp_dims_given_inp", "(", "outp_dims_prev_block", ")", "\n", "", "return", "outp_dims_prev_block", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_inp_dims_given_outp": [[93, 98], ["block.calc_inp_dims_given_outp"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_inp_dims_given_outp"], ["", "def", "calc_inp_dims_given_outp", "(", "self", ",", "outp_dims", ")", ":", "\n", "        ", "inp_dims_deeper_block", "=", "outp_dims", "\n", "for", "block", "in", "self", ".", "_blocks", ":", "\n", "            ", "inp_dims_deeper_block", "=", "block", ".", "calc_inp_dims_given_outp", "(", "inp_dims_deeper_block", ")", "\n", "", "return", "inp_dims_deeper_block", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build": [[99, 152], ["log.print3", "len", "range", "log.print3", "deepmedic.neuralnet.blocks.ConvBlock.build", "pathways.Pathway._blocks.append", "deepmedic.neuralnet.blocks.LowRankConvBlock", "deepmedic.neuralnet.blocks.ConvBlock", "str", "str", "pathways.Pathway.getStringType", "inds_of_lower_rank_convs.index", "str", "len", "len", "str", "str"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.logging.loggers.Logger.print3", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.build", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.getStringType"], ["", "def", "build", "(", "self", ",", "\n", "log", ",", "\n", "rng", ",", "\n", "n_input_channels", ",", "\n", "num_kerns_per_layer", ",", "\n", "conv_kernel_dims_per_layer", ",", "\n", "conv_w_init_method", ",", "\n", "conv_pad_mode_per_layer", ",", "\n", "use_bn_per_layer", ",", "# As a flag for case that I want to apply BN on input image. I want to apply to input of FC.", "\n", "moving_avg_length", ",", "\n", "activ_func_per_layer", ",", "\n", "dropout_rate_per_layer", "=", "[", "]", ",", "\n", "pool_prms_for_path", "=", "[", "]", ",", "\n", "inds_of_lower_rank_convs", "=", "[", "]", ",", "\n", "ranks_of_lower_rank_convs", "=", "[", "]", ",", "\n", "inds_of_blocks_for_res_conns_at_out", "=", "[", "]", "\n", ")", ":", "\n", "        ", "log", ".", "print3", "(", "\"[Pathway_\"", "+", "str", "(", "self", ".", "getStringType", "(", ")", ")", "+", "\"] is being built...\"", ")", "\n", "\n", "self", ".", "_n_fms_in", "=", "n_input_channels", "\n", "self", ".", "_inds_of_blocks_for_res_conns_at_out", "=", "inds_of_blocks_for_res_conns_at_out", "\n", "\n", "n_fms_input_to_prev_layer", "=", "None", "\n", "n_fms_input_to_next_layer", "=", "n_input_channels", "\n", "n_blocks", "=", "len", "(", "num_kerns_per_layer", ")", "\n", "for", "layer_i", "in", "range", "(", "0", ",", "n_blocks", ")", ":", "\n", "\n", "            ", "if", "layer_i", "in", "inds_of_lower_rank_convs", ":", "\n", "                ", "block", "=", "LowRankConvBlock", "(", "ranks_of_lower_rank_convs", "[", "inds_of_lower_rank_convs", ".", "index", "(", "layer_i", ")", "]", ")", "\n", "", "else", ":", "# normal conv block", "\n", "                ", "block", "=", "ConvBlock", "(", ")", "\n", "\n", "", "log", ".", "print3", "(", "\"\\tBlock [\"", "+", "str", "(", "layer_i", ")", "+", "\"], FMs-In: \"", "+", "str", "(", "n_fms_input_to_next_layer", ")", "+", "\", FMs-Out: \"", "+", "str", "(", "num_kerns_per_layer", "[", "layer_i", "]", ")", "+", "\", Conv Filter dimensions: \"", "+", "str", "(", "conv_kernel_dims_per_layer", "[", "layer_i", "]", ")", ")", "\n", "block", ".", "build", "(", "rng", ",", "\n", "n_fms_in", "=", "n_fms_input_to_next_layer", ",", "\n", "n_fms_out", "=", "num_kerns_per_layer", "[", "layer_i", "]", ",", "\n", "conv_kernel_dims", "=", "conv_kernel_dims_per_layer", "[", "layer_i", "]", ",", "\n", "pool_prms", "=", "pool_prms_for_path", "[", "layer_i", "]", ",", "\n", "conv_w_init_method", "=", "conv_w_init_method", ",", "\n", "conv_pad_mode", "=", "conv_pad_mode_per_layer", "[", "layer_i", "]", "if", "len", "(", "conv_pad_mode_per_layer", ")", ">", "0", "else", "None", ",", "\n", "use_bn", "=", "use_bn_per_layer", "[", "layer_i", "]", ",", "\n", "moving_avg_length", "=", "moving_avg_length", ",", "\n", "activ_func", "=", "activ_func_per_layer", "[", "layer_i", "]", ",", "\n", "dropout_rate", "=", "dropout_rate_per_layer", "[", "layer_i", "]", "if", "len", "(", "dropout_rate_per_layer", ")", ">", "0", "else", "0", "\n", ")", "\n", "self", ".", "_blocks", ".", "append", "(", "block", ")", "\n", "\n", "n_fms_input_to_prev_layer", "=", "n_fms_input_to_next_layer", "\n", "n_fms_input_to_next_layer", "=", "num_kerns_per_layer", "[", "layer_i", "]", "\n", "\n", "", "self", ".", "_n_fms_out", "=", "n_fms_input_to_next_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pName": [[155, 157], ["None"], "methods", ["None"], ["", "def", "pName", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_pName", "\n", "", "def", "pType", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.pType": [[157, 159], ["None"], "methods", ["None"], ["", "def", "pType", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_pType", "\n", "", "def", "get_blocks", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_blocks": [[159, 161], ["None"], "methods", ["None"], ["", "def", "get_blocks", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_blocks", "\n", "", "def", "get_block", "(", "self", ",", "index", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.get_block": [[161, 163], ["None"], "methods", ["None"], ["", "def", "get_block", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "_blocks", "[", "index", "]", "\n", "", "def", "subs_factor", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor": [[163, 165], ["None"], "methods", ["None"], ["", "def", "subs_factor", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_subs_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.getStringType": [[167, 168], ["NotImplementedMethod"], "methods", ["None"], ["", "def", "getStringType", "(", "self", ")", ":", "raise", "NotImplementedMethod", "(", ")", "# Abstract implementation. Children classes should implement this.", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.NormalPathway.__init__": [[171, 174], ["pathways.Pathway.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pName", "=", "None", ")", ":", "\n", "        ", "Pathway", ".", "__init__", "(", "self", ",", "pName", ")", "\n", "self", ".", "_pType", "=", "PathwayTypes", ".", "NORM", "\n", "# Override parent's abstract classes.", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.NormalPathway.getStringType": [[175, 177], ["None"], "methods", ["None"], ["", "def", "getStringType", "(", "self", ")", ":", "\n", "        ", "return", "\"NORMAL\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.__init__": [[180, 184], ["pathways.Pathway.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "subsamplingFactor", ",", "pName", "=", "None", ")", ":", "\n", "        ", "Pathway", ".", "__init__", "(", "self", ",", "pName", ")", "\n", "self", ".", "_pType", "=", "PathwayTypes", ".", "SUBS", "\n", "self", ".", "_subs_factor", "=", "subsamplingFactor", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.upsample_to_high_res": [[185, 188], ["deepmedic.upsample_5D_tens_and_crop", "pathways.SubsampledPathway.subs_factor"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.ops.upsample_5D_tens_and_crop", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor"], ["", "def", "upsample_to_high_res", "(", "self", ",", "input", ",", "shape_to_match", ",", "upsampl_type", "=", "\"repeat\"", ")", ":", "\n", "# shape_to_match: list of dimensions x,y,z to match, eg by cropping after upsampling. [dimx, dimy, dimz]", "\n", "        ", "return", "ops", ".", "upsample_5D_tens_and_crop", "(", "input", ",", "self", ".", "subs_factor", "(", ")", ",", "upsampl_type", ",", "shape_to_match", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.getStringType": [[190, 192], ["str", "pathways.SubsampledPathway.subs_factor"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor"], ["", "def", "getStringType", "(", "self", ")", ":", "\n", "        ", "return", "\"SUBSAMPLED\"", "+", "str", "(", "self", ".", "subs_factor", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.SubsampledPathway.calc_inp_dims_given_outp_after_upsample": [[193, 197], ["pathways.SubsampledPathway.calc_inp_dims_given_outp", "int", "math.ceil", "range", "int", "pathways.SubsampledPathway.subs_factor"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.calc_inp_dims_given_outp", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.Pathway.subs_factor"], ["", "def", "calc_inp_dims_given_outp_after_upsample", "(", "self", ",", "outp_dims_in_hr", ")", ":", "\n", "        ", "outp_dims_in_lr", "=", "[", "int", "(", "ceil", "(", "int", "(", "outp_dims_in_hr", "[", "d", "]", ")", "/", "self", ".", "subs_factor", "(", ")", "[", "d", "]", ")", ")", "for", "d", "in", "range", "(", "3", ")", "]", "\n", "inp_dims_req", "=", "self", ".", "calc_inp_dims_given_outp", "(", "outp_dims_in_lr", ")", "\n", "return", "inp_dims_req", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.__init__": [[199, 202], ["pathways.Pathway.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pName", "=", "None", ")", ":", "\n", "        ", "Pathway", ".", "__init__", "(", "self", ",", "pName", ")", "\n", "self", ".", "_pType", "=", "PathwayTypes", ".", "FC", "\n", "# Override parent's abstract classes.", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.pathways.FcPathway.getStringType": [[203, 205], ["None"], "methods", ["None"], ["", "def", "getStringType", "(", "self", ")", ":", "\n", "        ", "return", "\"FC\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.calc_rec_field_of_path_assuming_strides_1": [[12, 23], ["len", "range", "range", "len"], "function", ["None"], ["\n", "def", "abs_from_rel_path", "(", "pathGiven", ",", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "#os.path.normpath \"cleans\" Additional ../.// etc.", "\n", "    ", "if", "os", ".", "path", ".", "isabs", "(", "pathGiven", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "normpath", "(", "pathGiven", ")", "\n", "", "else", ":", "#relative path given. Need to make absolute path", "\n", "        ", "if", "os", ".", "path", ".", "isdir", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "absolutePathToWhereRelativePathRelatesTo", "\n", "", "elif", "os", ".", "path", ".", "isfile", "(", "absolutePathToWhereRelativePathRelatesTo", ")", ":", "\n", "            ", "relativePathToWhatGiven", "=", "os", ".", "path", ".", "dirname", "(", "absolutePathToWhereRelativePathRelatesTo", ")", "\n", "", "else", ":", "#not file, not dir, exit.", "\n", "            ", "print", "(", "\"ERROR: in [func:returnAbsolutePathEvenIfRelativePathIsGiven()] Given path :\"", ",", "absolutePathToWhereRelativePathRelatesTo", ",", "\" does not correspond to neither an existing file nor a directory. Exiting!\"", ")", ";", "exit", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.check_rec_field_vs_inp_dims": [[25, 39], ["len", "len", "range", "print", "exit", "print"], "function", ["None"], ["\n", "\n", "", "", "def", "checkIfAllElementsOfAListAreFilesAndExitIfNot", "(", "pathToTheListingFile", ",", "list1", ")", ":", "\n", "    ", "for", "filepath", "in", "list1", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isfile", "(", "filepath", ")", ":", "\n", "            ", "print", "(", "\"ERROR: in [checkIfAllElementsOfAListExistAndExitIfNot()] path:\"", ",", "filepath", ",", "\" given in :\"", ",", "pathToTheListingFile", ",", "\" does not correspond to a file. Exiting!\"", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "\n", "", "", "", "def", "parse_filelist", "(", "filelist_path", ",", "make_abs", "=", "False", ")", ":", "\n", "# os.path.normpath below is to \"clean\" the paths from ./..//...", "\n", "    ", "path_to_folder_w_filelist", "=", "os", ".", "path", ".", "dirname", "(", "filelist_path", ")", "\n", "list1", "=", "[", "]", "\n", "with", "open", "(", "filelist_path", ",", "\"r\"", ")", "as", "inp", ":", "\n", "        ", "for", "line", "in", "inp", ":", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.check_kern_dims_per_l_correct_3d_and_n_layers": [[41, 51], ["len", "len"], "function", ["None"], ["                ", "list1", ".", "append", "(", "\"-\"", ")", "\n", "", "elif", "not", "line", ".", "startswith", "(", "\"#\"", ")", "and", "line", ".", "strip", "(", ")", "!=", "\"\"", ":", "\n", "                ", "path_to_file", "=", "line", ".", "strip", "(", ")", "\n", "\n", "if", "(", "not", "make_abs", ")", "or", "os", ".", "path", ".", "isabs", "(", "path_to_file", ")", ":", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_file", ")", ")", "\n", "", "else", ":", "# relative path to this listing-file.", "\n", "                    ", "list1", ".", "append", "(", "os", ".", "path", ".", "normpath", "(", "path_to_folder_w_filelist", "+", "\"/\"", "+", "path_to_file", ")", ")", "\n", "", "", "", "", "return", "list1", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.utils.subsample_factor_is_even": [[53, 58], ["range", "len"], "function", ["None"], ["    ", "numberOfContainedCasesInList", "=", "len", "(", "listOfFilepathsToChannelIForEachCase", ")", "\n", "if", "numberOfCasesPreviously", "!=", "numberOfContainedCasesInList", ":", "\n", "        ", "raise", "IOError", "(", "\"ERROR: Given file:\"", ",", "pathToGivenListFile", "+", "\"\\n\\t contains #\"", ",", "numberOfContainedCasesInList", ",", "\" entries, whereas previously checked files contained #\"", ",", "numberOfCasesPreviously", ",", "\".\"", "+", "\"\\n\\t All listing-files for channels, masks, etc, should contain the same number of entries, one for each case.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.__init__": [[14, 17], ["optimizers.Optimizer._initialize_vars"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer._initialize_vars"], ["    ", "def", "__init__", "(", "self", ",", "params_to_opt", ")", ":", "\n", "        ", "self", ".", "_params_to_opt", "=", "params_to_opt", "\n", "self", ".", "_initialize_vars", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer._initialize_vars": [[19, 21], ["NotImplementedError"], "methods", ["None"], ["", "def", "_initialize_vars", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Not implemented virtual function.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.get_update_ops_given_grads": [[23, 25], ["NotImplementedError"], "methods", ["None"], ["", "def", "get_update_ops_given_grads", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Not implemented virtual function.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.get_grads_for_params_responsible": [[27, 30], ["tensorflow.gradients"], "methods", ["None"], ["", "def", "get_grads_for_params_responsible", "(", "self", ",", "cost", ")", ":", "\n", "# create a list of gradients for all parameters that this is optimizing", "\n", "        ", "return", "tf", ".", "gradients", "(", "cost", ",", "self", ".", "_params_to_opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.get_update_ops_given_cost": [[31, 34], ["optimizers.Optimizer.get_grads_for_params_responsible", "optimizers.Optimizer.get_update_ops_given_grads"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.Optimizer.get_grads_for_params_responsible", "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.get_update_ops_given_grads"], ["", "def", "get_update_ops_given_cost", "(", "self", ",", "cost", ")", ":", "\n", "        ", "grads", "=", "self", ".", "get_grads_for_params_responsible", "(", "cost", ")", "\n", "return", "self", ".", "get_update_ops_given_grads", "(", "grads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.SgdOptimizer.__init__": [[36, 53], ["optimizers.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "params_to_opt", ",", "\n", "learning_rate", ",", "\n", "momentum", ",", "\n", "momentumTypeNONNormalized0orNormalized1", ",", "\n", "classicMomentum0OrNesterov1", ")", ":", "\n", "\n", "        ", "self", ".", "name", "=", "\"SgdOptimizer\"", "\n", "\n", "self", ".", "_learning_rate", "=", "learning_rate", "# tf.var", "\n", "self", ".", "_momentum", "=", "momentum", "# tf.var", "\n", "self", ".", "_momentumTypeNONNormalized0orNormalized1", "=", "momentumTypeNONNormalized0orNormalized1", "\n", "self", ".", "_classicMomentum0OrNesterov1", "=", "classicMomentum0OrNesterov1", "\n", "\n", "self", ".", "_velocities_for_mom", "=", "None", "# list  tf.var", "\n", "\n", "Optimizer", ".", "__init__", "(", "self", ",", "params_to_opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.SgdOptimizer._initialize_vars": [[54, 58], ["optimizers.SgdOptimizer._velocities_for_mom.append", "tensorflow.Variable"], "methods", ["None"], ["", "def", "_initialize_vars", "(", "self", ")", ":", "\n", "        ", "self", ".", "_velocities_for_mom", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "_params_to_opt", ":", "\n", "            ", "self", ".", "_velocities_for_mom", ".", "append", "(", "tf", ".", "Variable", "(", "param", "*", "0.", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"velocities_for_mom\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.SgdOptimizer.get_update_ops_given_grads": [[60, 78], ["zip", "updates.append", "updates.append", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign"], "methods", ["None"], ["", "", "def", "get_update_ops_given_grads", "(", "self", ",", "grads", ")", ":", "\n", "        ", "updates", "=", "[", "]", "\n", "# The below will be 1 if nonNormalized momentum, and (1-momentum) if I am using normalized momentum.", "\n", "multiplierForCurrentGradUpdateForNonNormalizedOrNormalizedMomentum", "=", "1.0", "-", "self", ".", "_momentum", "*", "self", ".", "_momentumTypeNONNormalized0orNormalized1", "\n", "\n", "for", "param", ",", "grad", ",", "v", "in", "zip", "(", "self", ".", "_params_to_opt", ",", "grads", ",", "self", ".", "_velocities_for_mom", ")", ":", "\n", "            ", "stepToGradientDirection", "=", "multiplierForCurrentGradUpdateForNonNormalizedOrNormalizedMomentum", "*", "self", ".", "_learning_rate", "*", "grad", "\n", "newVelocity", "=", "self", ".", "_momentum", "*", "v", "-", "stepToGradientDirection", "\n", "\n", "if", "self", ".", "_classicMomentum0OrNesterov1", "==", "0", ":", "\n", "                ", "updateToParam", "=", "newVelocity", "\n", "", "else", ":", "# Nesterov", "\n", "                ", "updateToParam", "=", "self", ".", "_momentum", "*", "newVelocity", "-", "stepToGradientDirection", "\n", "\n", "", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "v", ",", "value", "=", "newVelocity", ",", "validate_shape", "=", "True", ")", ")", "# I can do (1-mom)*learnRate*grad.", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "param", ",", "value", "=", "param", "+", "updateToParam", ",", "validate_shape", "=", "True", ")", ")", "\n", "\n", "", "return", "updates", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.AdamOptimizer.__init__": [[81, 101], ["optimizers.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "params_to_opt", ",", "\n", "learning_rate", ",", "\n", "b1_adam", ",", "\n", "b2_adam", ",", "\n", "eps", ")", ":", "\n", "\n", "        ", "self", ".", "name", "=", "\"AdamOptimizer\"", "\n", "\n", "self", ".", "_learning_rate", "=", "learning_rate", "\n", "self", ".", "_b1_adam", "=", "b1_adam", "\n", "self", ".", "_b2_adam", "=", "b2_adam", "\n", "self", ".", "_eps", "=", "eps", "\n", "\n", "self", ".", "_i_adam", "=", "None", "\n", "self", ".", "_means_of_grads", "=", "None", "\n", "self", ".", "_vars_of_grads", "=", "None", "\n", "\n", "\n", "Optimizer", ".", "__init__", "(", "self", ",", "params_to_opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.AdamOptimizer._initialize_vars": [[102, 109], ["tensorflow.Variable", "optimizers.AdamOptimizer._means_of_grads.append", "optimizers.AdamOptimizer._vars_of_grads.append", "tensorflow.Variable", "tensorflow.Variable"], "methods", ["None"], ["", "def", "_initialize_vars", "(", "self", ")", ":", "\n", "        ", "self", ".", "_i_adam", "=", "tf", ".", "Variable", "(", "0.0", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"i_adam\"", ")", "# Current iteration of Adam", "\n", "self", ".", "_means_of_grads", "=", "[", "]", "# list of mean of grads for all parameters, for ADAM optimizer.", "\n", "self", ".", "_vars_of_grads", "=", "[", "]", "# list of variances of grads for all parameters, for ADAM optimizer.", "\n", "for", "param", "in", "self", ".", "_params_to_opt", ":", "\n", "            ", "self", ".", "_means_of_grads", ".", "append", "(", "tf", ".", "Variable", "(", "param", "*", "0.", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"means_of_grads\"", ")", ")", "\n", "self", ".", "_vars_of_grads", ".", "append", "(", "tf", ".", "Variable", "(", "param", "*", "0.", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"vars_of_grads\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.AdamOptimizer.get_update_ops_given_grads": [[110, 132], ["zip", "updates.append", "updates.append", "updates.append", "updates.append", "tensorflow.compat.v1.assign", "tensorflow.sqrt", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.square", "tensorflow.sqrt"], "methods", ["None"], ["", "", "def", "get_update_ops_given_grads", "(", "self", ",", "grads", ")", ":", "\n", "# Epsilon on paper was 10**(-8).", "\n", "# Code is on par with version V8 of Kingma's paper.", "\n", "        ", "updates", "=", "[", "]", "\n", "\n", "i", "=", "self", ".", "_i_adam", "\n", "i_t", "=", "i", "+", "1.", "\n", "fix1", "=", "1.", "-", "(", "self", ".", "_b1_adam", ")", "**", "i_t", "\n", "fix2", "=", "1.", "-", "(", "self", ".", "_b2_adam", ")", "**", "i_t", "\n", "lr_t", "=", "self", ".", "_learning_rate", "*", "(", "tf", ".", "sqrt", "(", "fix2", ")", "/", "fix1", ")", "\n", "for", "param", ",", "grad", ",", "m", ",", "v", "in", "zip", "(", "self", ".", "_params_to_opt", ",", "grads", ",", "self", ".", "_means_of_grads", ",", "self", ".", "_vars_of_grads", ")", ":", "\n", "            ", "m_t", "=", "(", "self", ".", "_b1_adam", "*", "m", ")", "+", "(", "(", "1.", "-", "self", ".", "_b1_adam", ")", "*", "grad", ")", "\n", "v_t", "=", "(", "self", ".", "_b2_adam", "*", "v", ")", "+", "(", "(", "1.", "-", "self", ".", "_b2_adam", ")", "*", "tf", ".", "square", "(", "grad", ")", ")", "# Double check this with the paper.", "\n", "grad_t", "=", "m_t", "/", "(", "tf", ".", "sqrt", "(", "v_t", ")", "+", "self", ".", "_eps", ")", "\n", "param_t", "=", "param", "-", "(", "lr_t", "*", "grad_t", ")", "\n", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "m", ",", "value", "=", "m_t", ",", "validate_shape", "=", "True", ")", ")", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "v", ",", "value", "=", "v_t", ",", "validate_shape", "=", "True", ")", ")", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "param", ",", "value", "=", "param_t", ",", "validate_shape", "=", "True", ")", ")", "\n", "", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "i", ",", "value", "=", "i_t", ",", "validate_shape", "=", "True", ")", ")", "\n", "\n", "return", "updates", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__": [[135, 157], ["optimizers.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "params_to_opt", ",", "\n", "learning_rate", ",", "\n", "momentum", ",", "\n", "momentumTypeNONNormalized0orNormalized1", ",", "\n", "classicMomentum0OrNesterov1", ",", "\n", "rho", ",", "\n", "eps", ")", ":", "\n", "\n", "        ", "self", ".", "name", "=", "\"RmsPropOptimizer\"", "\n", "\n", "self", ".", "_learning_rate", "=", "learning_rate", "\n", "self", ".", "_momentum", "=", "momentum", "\n", "self", ".", "_momentumTypeNONNormalized0orNormalized1", "=", "momentumTypeNONNormalized0orNormalized1", "\n", "self", ".", "_classicMomentum0OrNesterov1", "=", "classicMomentum0OrNesterov1", "\n", "self", ".", "_rho", "=", "rho", "\n", "self", ".", "_eps", "=", "eps", "\n", "\n", "self", ".", "_accu_grad_squared", "=", "None", "\n", "self", ".", "_velocities_for_mom", "=", "None", "\n", "\n", "Optimizer", ".", "__init__", "(", "self", ",", "params_to_opt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer._initialize_vars": [[158, 164], ["optimizers.RmsPropOptimizer._accu_grad_squared.append", "optimizers.RmsPropOptimizer._velocities_for_mom.append", "tensorflow.Variable", "tensorflow.Variable"], "methods", ["None"], ["", "def", "_initialize_vars", "(", "self", ")", ":", "\n", "        ", "self", ".", "_accu_grad_squared", "=", "[", "]", "\n", "self", ".", "_velocities_for_mom", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "_params_to_opt", ":", "\n", "            ", "self", ".", "_accu_grad_squared", ".", "append", "(", "tf", ".", "Variable", "(", "param", "*", "0.", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"accu_grad_squared\"", ")", ")", "# accumulates the mean of the grad's square.", "\n", "self", ".", "_velocities_for_mom", ".", "append", "(", "tf", ".", "Variable", "(", "param", "*", "0.", ",", "dtype", "=", "\"float32\"", ",", "name", "=", "\"velocities_for_mom\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Kamnitsask_deepmedic.neuralnet.optimizers.RmsPropOptimizer.get_update_ops_given_grads": [[165, 185], ["zip", "updates.append", "updates.append", "updates.append", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.compat.v1.assign", "tensorflow.square", "tensorflow.sqrt"], "methods", ["None"], ["", "", "def", "get_update_ops_given_grads", "(", "self", ",", "grads", ")", ":", "\n", "        ", "updates", "=", "[", "]", "\n", "# The below will be 1 if nonNormalized momentum, and (1-momentum) if I am using normalized momentum.", "\n", "multiplierForCurrentGradUpdateForNonNormalizedOrNormalizedMomentum", "=", "1.0", "-", "self", ".", "_momentum", "*", "self", ".", "_momentumTypeNONNormalized0orNormalized1", "\n", "\n", "for", "param", ",", "grad", ",", "accu", ",", "v", "in", "zip", "(", "self", ".", "_params_to_opt", ",", "grads", ",", "self", ".", "_accu_grad_squared", ",", "self", ".", "_velocities_for_mom", ")", ":", "\n", "            ", "accu_new", "=", "self", ".", "_rho", "*", "accu", "+", "(", "1", "-", "self", ".", "_rho", ")", "*", "tf", ".", "square", "(", "grad", ")", "\n", "stepToGradientDirection", "=", "multiplierForCurrentGradUpdateForNonNormalizedOrNormalizedMomentum", "*", "(", "self", ".", "_learning_rate", "*", "grad", "/", "tf", ".", "sqrt", "(", "accu_new", "+", "self", ".", "_eps", ")", ")", "\n", "newVelocity", "=", "self", ".", "_momentum", "*", "v", "-", "stepToGradientDirection", "\n", "\n", "if", "self", ".", "_classicMomentum0OrNesterov1", "==", "0", ":", "\n", "                ", "updateToParam", "=", "newVelocity", "\n", "", "else", ":", "# Nesterov", "\n", "                ", "updateToParam", "=", "self", ".", "_momentum", "*", "newVelocity", "-", "stepToGradientDirection", "\n", "\n", "", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "accu", ",", "value", "=", "accu_new", ",", "validate_shape", "=", "True", ")", ")", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "v", ",", "value", "=", "newVelocity", ",", "validate_shape", "=", "True", ")", ")", "# I can do (1-mom)*learnRate*grad.", "\n", "updates", ".", "append", "(", "tf", ".", "compat", ".", "v1", ".", "assign", "(", "ref", "=", "param", ",", "value", "=", "param", "+", "updateToParam", ",", "validate_shape", "=", "True", ")", ")", "\n", "\n", "", "return", "updates", "\n", "\n"]]}